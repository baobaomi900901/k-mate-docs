import {
  ElAffix,
  ElAlert,
  ElAnchor,
  ElAnchorLink,
  ElAside,
  ElAutoResizer,
  ElAutocomplete,
  ElAvatar,
  ElBacktop,
  ElBadge,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElButton,
  ElButtonGroup,
  ElCalendar,
  ElCard,
  ElCarousel,
  ElCarouselItem,
  ElCascader,
  ElCascaderPanel,
  ElCheckTag,
  ElCheckbox,
  ElCheckboxButton,
  ElCheckboxGroup,
  ElCol,
  ElCollapse,
  ElCollapseItem,
  ElCollapseTransition,
  ElCollection,
  ElCollectionItem,
  ElColorPicker,
  ElConfigProvider,
  ElContainer,
  ElCountdown,
  ElDatePicker,
  ElDescriptions,
  ElDescriptionsItem,
  ElDialog,
  ElDivider,
  ElDrawer,
  ElDropdown,
  ElDropdownItem,
  ElDropdownMenu,
  ElEmpty,
  ElFooter,
  ElForm,
  ElFormItem,
  ElHeader,
  ElIcon,
  ElImage,
  ElImageViewer,
  ElInfiniteScroll,
  ElInput,
  ElInputNumber,
  ElLink,
  ElLoading,
  ElMain,
  ElMention,
  ElMenu,
  ElMenuItem,
  ElMenuItemGroup,
  ElMessage,
  ElMessageBox,
  ElNotification,
  ElOption,
  ElOptionGroup,
  ElOverlay,
  ElPageHeader,
  ElPagination,
  ElPopconfirm,
  ElPopover,
  ElPopoverDirective,
  ElPopper,
  ElPopperArrow,
  ElPopperContent,
  ElPopperTrigger,
  ElProgress,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElRate,
  ElRow,
  ElScrollbar,
  ElSelect,
  ElSelectV2,
  ElSkeleton,
  ElSkeletonItem,
  ElSlider,
  ElSpace,
  ElStatistic,
  ElStep,
  ElSteps,
  ElSubMenu,
  ElSwitch,
  ElTabPane,
  ElTabs,
  ElTag,
  ElText,
  ElTimePicker,
  ElTimeSelect,
  ElTimeline,
  ElTimelineItem,
  ElTooltip,
  ElTour,
  ElTourStep,
  ElTransfer,
  ElTree,
  ElTreeSelect,
  ElUpload,
  ElWatermark,
  Loading,
  es_exports,
  installer,
  vLoading
} from "./chunk-WMQUZUT2.js";
import "./chunk-O3YQPVDG.js";
import {
  Comment,
  Fragment,
  Teleport,
  Text,
  TransitionGroup,
  computed,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineComponent,
  effectScope,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isRef,
  isVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  toRefs,
  unref,
  useSlots,
  vShow,
  watch,
  watchPostEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-SSSTV3QS.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/xe-utils/setupDefaults.js
var require_setupDefaults = __commonJS({
  "node_modules/xe-utils/setupDefaults.js"(exports2, module2) {
    "use strict";
    var setupDefaults = {
      cookies: {
        path: "/"
      },
      treeOptions: {
        parentKey: "parentId",
        key: "id",
        children: "children"
      },
      parseDateFormat: "yyyy-MM-dd HH:mm:ss",
      firstDayOfWeek: 1
    };
    module2.exports = setupDefaults;
  }
});

// node_modules/xe-utils/arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/xe-utils/arrayEach.js"(exports2, module2) {
    function arrayEach(list, iterate, context) {
      if (list) {
        if (list.forEach) {
          list.forEach(iterate, context);
        } else {
          for (var index2 = 0, len = list.length; index2 < len; index2++) {
            iterate.call(context, list[index2], index2, list);
          }
        }
      }
    }
    module2.exports = arrayEach;
  }
});

// node_modules/xe-utils/staticObjectToString.js
var require_staticObjectToString = __commonJS({
  "node_modules/xe-utils/staticObjectToString.js"(exports2, module2) {
    var objectToString2 = Object.prototype.toString;
    module2.exports = objectToString2;
  }
});

// node_modules/xe-utils/helperCreateInInObjectString.js
var require_helperCreateInInObjectString = __commonJS({
  "node_modules/xe-utils/helperCreateInInObjectString.js"(exports2, module2) {
    var objectToString2 = require_staticObjectToString();
    function helperCreateInInObjectString(type) {
      return function(obj) {
        return "[object " + type + "]" === objectToString2.call(obj);
      };
    }
    module2.exports = helperCreateInInObjectString;
  }
});

// node_modules/xe-utils/isArray.js
var require_isArray = __commonJS({
  "node_modules/xe-utils/isArray.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isArray2 = Array.isArray || helperCreateInInObjectString("Array");
    module2.exports = isArray2;
  }
});

// node_modules/xe-utils/hasOwnProp.js
var require_hasOwnProp = __commonJS({
  "node_modules/xe-utils/hasOwnProp.js"(exports2, module2) {
    function hasOwnProp(obj, key) {
      return obj && obj.hasOwnProperty ? obj.hasOwnProperty(key) : false;
    }
    module2.exports = hasOwnProp;
  }
});

// node_modules/xe-utils/objectEach.js
var require_objectEach = __commonJS({
  "node_modules/xe-utils/objectEach.js"(exports2, module2) {
    var hasOwnProp = require_hasOwnProp();
    function objectEach(obj, iterate, context) {
      if (obj) {
        for (var key in obj) {
          if (hasOwnProp(obj, key)) {
            iterate.call(context, obj[key], key, obj);
          }
        }
      }
    }
    module2.exports = objectEach;
  }
});

// node_modules/xe-utils/each.js
var require_each = __commonJS({
  "node_modules/xe-utils/each.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var arrayEach = require_arrayEach();
    var objectEach = require_objectEach();
    function each(obj, iterate, context) {
      if (obj) {
        return (isArray2(obj) ? arrayEach : objectEach)(obj, iterate, context);
      }
      return obj;
    }
    module2.exports = each;
  }
});

// node_modules/xe-utils/helperCreateInTypeof.js
var require_helperCreateInTypeof = __commonJS({
  "node_modules/xe-utils/helperCreateInTypeof.js"(exports2, module2) {
    function helperCreateInTypeof(type) {
      return function(obj) {
        return typeof obj === type;
      };
    }
    module2.exports = helperCreateInTypeof;
  }
});

// node_modules/xe-utils/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/xe-utils/isFunction.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isFunction2 = helperCreateInTypeof("function");
    module2.exports = isFunction2;
  }
});

// node_modules/xe-utils/helperCreateGetObjects.js
var require_helperCreateGetObjects = __commonJS({
  "node_modules/xe-utils/helperCreateGetObjects.js"(exports2, module2) {
    var each = require_each();
    function helperCreateGetObjects(name, getIndex) {
      var proMethod = Object[name];
      return function(obj) {
        var result = [];
        if (obj) {
          if (proMethod) {
            return proMethod(obj);
          }
          each(obj, getIndex > 1 ? function(key) {
            result.push(["" + key, obj[key]]);
          } : function() {
            result.push(arguments[getIndex]);
          });
        }
        return result;
      };
    }
    module2.exports = helperCreateGetObjects;
  }
});

// node_modules/xe-utils/keys.js
var require_keys = __commonJS({
  "node_modules/xe-utils/keys.js"(exports2, module2) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var keys = helperCreateGetObjects("keys", 1);
    module2.exports = keys;
  }
});

// node_modules/xe-utils/clone.js
var require_clone = __commonJS({
  "node_modules/xe-utils/clone.js"(exports2, module2) {
    var objectToString2 = require_staticObjectToString();
    var objectEach = require_objectEach();
    var arrayEach = require_arrayEach();
    function getCativeCtor(val, args) {
      var Ctor = val.__proto__.constructor;
      return args ? new Ctor(args) : new Ctor();
    }
    function handleValueClone(item, isDeep) {
      return isDeep ? copyValue(item, isDeep) : item;
    }
    function copyValue(val, isDeep) {
      if (val) {
        switch (objectToString2.call(val)) {
          case "[object Object]": {
            var restObj = Object.create(Object.getPrototypeOf(val));
            objectEach(val, function(item, key) {
              restObj[key] = handleValueClone(item, isDeep);
            });
            return restObj;
          }
          case "[object Date]":
          case "[object RegExp]": {
            return getCativeCtor(val, val.valueOf());
          }
          case "[object Array]":
          case "[object Arguments]": {
            var restArr = [];
            arrayEach(val, function(item) {
              restArr.push(handleValueClone(item, isDeep));
            });
            return restArr;
          }
          case "[object Set]": {
            var restSet = getCativeCtor(val);
            restSet.forEach(function(item) {
              restSet.add(handleValueClone(item, isDeep));
            });
            return restSet;
          }
          case "[object Map]": {
            var restMap = getCativeCtor(val);
            restMap.forEach(function(item, key) {
              restMap.set(key, handleValueClone(item, isDeep));
            });
            return restMap;
          }
        }
      }
      return val;
    }
    function clone2(obj, deep) {
      if (obj) {
        return copyValue(obj, deep);
      }
      return obj;
    }
    module2.exports = clone2;
  }
});

// node_modules/xe-utils/assign.js
var require_assign = __commonJS({
  "node_modules/xe-utils/assign.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var keys = require_keys();
    var isArray2 = require_isArray();
    var clone2 = require_clone();
    var objectAssignFns = Object.assign;
    function handleAssign(destination, args, isClone) {
      var len = args.length;
      for (var source, index2 = 1; index2 < len; index2++) {
        source = args[index2];
        arrayEach(keys(args[index2]), isClone ? function(key) {
          destination[key] = clone2(source[key], isClone);
        } : function(key) {
          destination[key] = source[key];
        });
      }
      return destination;
    }
    var assign3 = function(target) {
      if (target) {
        var args = arguments;
        if (target === true) {
          if (args.length > 1) {
            target = isArray2(target[1]) ? [] : {};
            return handleAssign(target, args, true);
          }
        } else {
          return objectAssignFns ? objectAssignFns.apply(Object, args) : handleAssign(target, args);
        }
      }
      return target;
    };
    module2.exports = assign3;
  }
});

// node_modules/xe-utils/ctor.js
var require_ctor = __commonJS({
  "node_modules/xe-utils/ctor.js"(exports2, module2) {
    "use strict";
    var setupDefaults = require_setupDefaults();
    var arrayEach = require_arrayEach();
    var each = require_each();
    var isFunction2 = require_isFunction();
    var assign3 = require_assign();
    var XEUtils156 = function() {
    };
    function mixin() {
      arrayEach(arguments, function(methods) {
        each(methods, function(fn2, name) {
          XEUtils156[name] = isFunction2(fn2) ? function() {
            var result = fn2.apply(XEUtils156.$context, arguments);
            XEUtils156.$context = null;
            return result;
          } : fn2;
        });
      });
    }
    function setup3(options) {
      return assign3(setupDefaults, options);
    }
    XEUtils156.VERSION = "3.5.32";
    XEUtils156.mixin = mixin;
    XEUtils156.setup = setup3;
    module2.exports = XEUtils156;
  }
});

// node_modules/xe-utils/lastArrayEach.js
var require_lastArrayEach = __commonJS({
  "node_modules/xe-utils/lastArrayEach.js"(exports2, module2) {
    function lastArrayEach(obj, iterate, context) {
      for (var len = obj.length - 1; len >= 0; len--) {
        iterate.call(context, obj[len], len, obj);
      }
    }
    module2.exports = lastArrayEach;
  }
});

// node_modules/xe-utils/lastObjectEach.js
var require_lastObjectEach = __commonJS({
  "node_modules/xe-utils/lastObjectEach.js"(exports2, module2) {
    var lastArrayEach = require_lastArrayEach();
    var keys = require_keys();
    function lastObjectEach(obj, iterate, context) {
      lastArrayEach(keys(obj), function(key) {
        iterate.call(context, obj[key], key, obj);
      });
    }
    module2.exports = lastObjectEach;
  }
});

// node_modules/xe-utils/isNull.js
var require_isNull = __commonJS({
  "node_modules/xe-utils/isNull.js"(exports2, module2) {
    function isNull(obj) {
      return obj === null;
    }
    module2.exports = isNull;
  }
});

// node_modules/xe-utils/property.js
var require_property = __commonJS({
  "node_modules/xe-utils/property.js"(exports2, module2) {
    var isNull = require_isNull();
    function property(name, defs) {
      return function(obj) {
        return isNull(obj) ? defs : obj[name];
      };
    }
    module2.exports = property;
  }
});

// node_modules/xe-utils/objectMap.js
var require_objectMap = __commonJS({
  "node_modules/xe-utils/objectMap.js"(exports2, module2) {
    var each = require_each();
    var isFunction2 = require_isFunction();
    var property = require_property();
    function objectMap(obj, iterate, context) {
      var result = {};
      if (obj) {
        if (iterate) {
          if (!isFunction2(iterate)) {
            iterate = property(iterate);
          }
          each(obj, function(val, index2) {
            result[index2] = iterate.call(context, val, index2, obj);
          });
        } else {
          return obj;
        }
      }
      return result;
    }
    module2.exports = objectMap;
  }
});

// node_modules/xe-utils/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/xe-utils/isPlainObject.js"(exports2, module2) {
    function isPlainObject2(obj) {
      return obj ? obj.constructor === Object : false;
    }
    module2.exports = isPlainObject2;
  }
});

// node_modules/xe-utils/merge.js
var require_merge = __commonJS({
  "node_modules/xe-utils/merge.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isPlainObject2 = require_isPlainObject();
    var each = require_each();
    function handleMerge(target, source) {
      if (isPlainObject2(target) && isPlainObject2(source) || isArray2(target) && isArray2(source)) {
        each(source, function(obj, key) {
          target[key] = handleMerge(target[key], obj);
        });
        return target;
      }
      return source;
    }
    var merge = function(target) {
      if (!target) {
        target = {};
      }
      var args = arguments;
      var len = args.length;
      for (var source, index2 = 1; index2 < len; index2++) {
        source = args[index2];
        if (source) {
          handleMerge(target, source);
        }
      }
      return target;
    };
    module2.exports = merge;
  }
});

// node_modules/xe-utils/map.js
var require_map = __commonJS({
  "node_modules/xe-utils/map.js"(exports2, module2) {
    var each = require_each();
    function map(obj, iterate, context) {
      var result = [];
      if (obj && arguments.length > 1) {
        if (obj.map) {
          return obj.map(iterate, context);
        } else {
          each(obj, function() {
            result.push(iterate.apply(context, arguments));
          });
        }
      }
      return result;
    }
    module2.exports = map;
  }
});

// node_modules/xe-utils/helperCreateIterateHandle.js
var require_helperCreateIterateHandle = __commonJS({
  "node_modules/xe-utils/helperCreateIterateHandle.js"(exports2, module2) {
    var hasOwnProp = require_hasOwnProp();
    var isArray2 = require_isArray();
    function helperCreateIterateHandle(prop, useArray, restIndex, matchValue, defaultValue) {
      return function(obj, iterate, context) {
        if (obj && iterate) {
          if (prop && obj[prop]) {
            return obj[prop](iterate, context);
          } else {
            if (useArray && isArray2(obj)) {
              for (var index2 = 0, len = obj.length; index2 < len; index2++) {
                if (!!iterate.call(context, obj[index2], index2, obj) === matchValue) {
                  return [true, false, index2, obj[index2]][restIndex];
                }
              }
            } else {
              for (var key in obj) {
                if (hasOwnProp(obj, key)) {
                  if (!!iterate.call(context, obj[key], key, obj) === matchValue) {
                    return [true, false, key, obj[key]][restIndex];
                  }
                }
              }
            }
          }
        }
        return defaultValue;
      };
    }
    module2.exports = helperCreateIterateHandle;
  }
});

// node_modules/xe-utils/some.js
var require_some = __commonJS({
  "node_modules/xe-utils/some.js"(exports2, module2) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var some = helperCreateIterateHandle("some", 1, 0, true, false);
    module2.exports = some;
  }
});

// node_modules/xe-utils/every.js
var require_every = __commonJS({
  "node_modules/xe-utils/every.js"(exports2, module2) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var every = helperCreateIterateHandle("every", 1, 1, false, true);
    module2.exports = every;
  }
});

// node_modules/xe-utils/includes.js
var require_includes = __commonJS({
  "node_modules/xe-utils/includes.js"(exports2, module2) {
    var hasOwnProp = require_hasOwnProp();
    function includes(obj, val) {
      if (obj) {
        if (obj.includes) {
          return obj.includes(val);
        }
        for (var key in obj) {
          if (hasOwnProp(obj, key)) {
            if (val === obj[key]) {
              return true;
            }
          }
        }
      }
      return false;
    }
    module2.exports = includes;
  }
});

// node_modules/xe-utils/includeArrays.js
var require_includeArrays = __commonJS({
  "node_modules/xe-utils/includeArrays.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var includes = require_includes();
    function includeArrays(array1, array2) {
      var len;
      var index2 = 0;
      if (isArray2(array1) && isArray2(array2)) {
        for (len = array2.length; index2 < len; index2++) {
          if (!includes(array1, array2[index2])) {
            return false;
          }
        }
        return true;
      }
      return includes(array1, array2);
    }
    module2.exports = includeArrays;
  }
});

// node_modules/xe-utils/uniq.js
var require_uniq = __commonJS({
  "node_modules/xe-utils/uniq.js"(exports2, module2) {
    var each = require_each();
    var includes = require_includes();
    var isFunction2 = require_isFunction();
    var property = require_property();
    function uniq(array, iterate, context) {
      var result = [];
      if (iterate) {
        if (!isFunction2(iterate)) {
          iterate = property(iterate);
        }
        var val, valMap = {};
        each(array, function(item, key) {
          val = iterate.call(context, item, key, array);
          if (!valMap[val]) {
            valMap[val] = 1;
            result.push(item);
          }
        });
      } else {
        each(array, function(value) {
          if (!includes(result, value)) {
            result.push(value);
          }
        });
      }
      return result;
    }
    module2.exports = uniq;
  }
});

// node_modules/xe-utils/toArray.js
var require_toArray = __commonJS({
  "node_modules/xe-utils/toArray.js"(exports2, module2) {
    var map = require_map();
    function toArray2(list) {
      return map(list, function(item) {
        return item;
      });
    }
    module2.exports = toArray2;
  }
});

// node_modules/xe-utils/union.js
var require_union = __commonJS({
  "node_modules/xe-utils/union.js"(exports2, module2) {
    var uniq = require_uniq();
    var toArray2 = require_toArray();
    function union() {
      var args = arguments;
      var result = [];
      var index2 = 0;
      var len = args.length;
      for (; index2 < len; index2++) {
        result = result.concat(toArray2(args[index2]));
      }
      return uniq(result);
    }
    module2.exports = union;
  }
});

// node_modules/xe-utils/staticStrUndefined.js
var require_staticStrUndefined = __commonJS({
  "node_modules/xe-utils/staticStrUndefined.js"(exports2, module2) {
    var staticStrUndefined = "undefined";
    module2.exports = staticStrUndefined;
  }
});

// node_modules/xe-utils/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/xe-utils/isUndefined.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isUndefined = helperCreateInTypeof(staticStrUndefined);
    module2.exports = isUndefined;
  }
});

// node_modules/xe-utils/eqNull.js
var require_eqNull = __commonJS({
  "node_modules/xe-utils/eqNull.js"(exports2, module2) {
    var isNull = require_isNull();
    var isUndefined = require_isUndefined();
    function eqNull(obj) {
      return isNull(obj) || isUndefined(obj);
    }
    module2.exports = eqNull;
  }
});

// node_modules/xe-utils/staticHGKeyRE.js
var require_staticHGKeyRE = __commonJS({
  "node_modules/xe-utils/staticHGKeyRE.js"(exports2, module2) {
    var staticHGKeyRE = /(.+)?\[(\d+)\]$/;
    module2.exports = staticHGKeyRE;
  }
});

// node_modules/xe-utils/helperGetHGSKeys.js
var require_helperGetHGSKeys = __commonJS({
  "node_modules/xe-utils/helperGetHGSKeys.js"(exports2, module2) {
    function helperGetHGSKeys(property) {
      return property ? property.splice && property.join ? property : ("" + property).replace(/(\[\d+\])\.?/g, "$1.").replace(/\.$/, "").split(".") : [];
    }
    module2.exports = helperGetHGSKeys;
  }
});

// node_modules/xe-utils/get.js
var require_get = __commonJS({
  "node_modules/xe-utils/get.js"(exports2, module2) {
    var staticHGKeyRE = require_staticHGKeyRE();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    var isUndefined = require_isUndefined();
    var eqNull = require_eqNull();
    function get(obj, property, defaultValue) {
      if (eqNull(obj)) {
        return defaultValue;
      }
      var result = getValueByPath(obj, property);
      return isUndefined(result) ? defaultValue : result;
    }
    function getDeepProps(obj, key) {
      var matchs = key ? key.match(staticHGKeyRE) : "";
      return matchs ? matchs[1] ? obj[matchs[1]] ? obj[matchs[1]][matchs[2]] : void 0 : obj[matchs[2]] : obj[key];
    }
    function getValueByPath(obj, property) {
      if (obj) {
        var rest, props, len;
        var index2 = 0;
        if (obj[property] || hasOwnProp(obj, property)) {
          return obj[property];
        } else {
          props = helperGetHGSKeys(property);
          len = props.length;
          if (len) {
            for (rest = obj; index2 < len; index2++) {
              rest = getDeepProps(rest, props[index2]);
              if (eqNull(rest)) {
                if (index2 === len - 1) {
                  return rest;
                }
                return;
              }
            }
          }
          return rest;
        }
      }
    }
    module2.exports = get;
  }
});

// node_modules/xe-utils/orderBy.js
var require_orderBy = __commonJS({
  "node_modules/xe-utils/orderBy.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var toArray2 = require_toArray();
    var map = require_map();
    var isArray2 = require_isArray();
    var isFunction2 = require_isFunction();
    var isPlainObject2 = require_isPlainObject();
    var isUndefined = require_isUndefined();
    var isNull = require_isNull();
    var eqNull = require_eqNull();
    var get = require_get();
    var property = require_property();
    var ORDER_PROP_ASC = "asc";
    var ORDER_PROP_DESC = "desc";
    function handleSort(v12, v22) {
      if (isUndefined(v12)) {
        return 1;
      }
      if (isNull(v12)) {
        return isUndefined(v22) ? -1 : 1;
      }
      return v12 && v12.localeCompare ? v12.localeCompare(v22) : v12 > v22 ? 1 : -1;
    }
    function buildMultiOrders(name, confs, compares) {
      return function(item1, item2) {
        var v12 = item1[name];
        var v22 = item2[name];
        if (v12 === v22) {
          return compares ? compares(item1, item2) : 0;
        }
        return confs.order === ORDER_PROP_DESC ? handleSort(v22, v12) : handleSort(v12, v22);
      };
    }
    function getSortConfs(arr, list, fieldConfs, context) {
      var sortConfs = [];
      fieldConfs = isArray2(fieldConfs) ? fieldConfs : [fieldConfs];
      arrayEach(fieldConfs, function(handle, index2) {
        if (handle) {
          var field = handle;
          var order;
          if (isArray2(handle)) {
            field = handle[0];
            order = handle[1];
          } else if (isPlainObject2(handle)) {
            field = handle.field;
            order = handle.order;
          }
          sortConfs.push({
            field,
            order: order || ORDER_PROP_ASC
          });
          arrayEach(list, isFunction2(field) ? function(item, key) {
            item[index2] = field.call(context, item.data, key, arr);
          } : function(item) {
            item[index2] = field ? get(item.data, field) : item.data;
          });
        }
      });
      return sortConfs;
    }
    function orderBy(arr, fieldConfs, context) {
      if (arr) {
        if (eqNull(fieldConfs)) {
          return toArray2(arr).sort(handleSort);
        }
        var compares;
        var list = map(arr, function(item) {
          return { data: item };
        });
        var sortConfs = getSortConfs(arr, list, fieldConfs, context);
        var len = sortConfs.length - 1;
        while (len >= 0) {
          compares = buildMultiOrders(len, sortConfs[len], compares);
          len--;
        }
        if (compares) {
          list = list.sort(compares);
        }
        return map(list, property("data"));
      }
      return [];
    }
    module2.exports = orderBy;
  }
});

// node_modules/xe-utils/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/xe-utils/sortBy.js"(exports2, module2) {
    var orderBy = require_orderBy();
    var sortBy = orderBy;
    module2.exports = sortBy;
  }
});

// node_modules/xe-utils/random.js
var require_random = __commonJS({
  "node_modules/xe-utils/random.js"(exports2, module2) {
    function random(minVal, maxVal) {
      return minVal >= maxVal ? minVal : (minVal = minVal >> 0) + Math.round(Math.random() * ((maxVal || 9) - minVal));
    }
    module2.exports = random;
  }
});

// node_modules/xe-utils/values.js
var require_values = __commonJS({
  "node_modules/xe-utils/values.js"(exports2, module2) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var values = helperCreateGetObjects("values", 0);
    module2.exports = values;
  }
});

// node_modules/xe-utils/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/xe-utils/shuffle.js"(exports2, module2) {
    var random = require_random();
    var values = require_values();
    function shuffle(array) {
      var index2;
      var result = [];
      var list = values(array);
      var len = list.length - 1;
      for (; len >= 0; len--) {
        index2 = len > 0 ? random(0, len) : 0;
        result.push(list[index2]);
        list.splice(index2, 1);
      }
      return result;
    }
    module2.exports = shuffle;
  }
});

// node_modules/xe-utils/sample.js
var require_sample = __commonJS({
  "node_modules/xe-utils/sample.js"(exports2, module2) {
    var shuffle = require_shuffle();
    function sample(array, number2) {
      var result = shuffle(array);
      if (arguments.length <= 1) {
        return result[0];
      }
      if (number2 < result.length) {
        result.length = number2 || 0;
      }
      return result;
    }
    module2.exports = sample;
  }
});

// node_modules/xe-utils/helperCreateToNumber.js
var require_helperCreateToNumber = __commonJS({
  "node_modules/xe-utils/helperCreateToNumber.js"(exports2, module2) {
    function helperCreateToNumber(handle) {
      return function(str) {
        if (str) {
          var num = handle(str && str.replace ? str.replace(/,/g, "") : str);
          if (!isNaN(num)) {
            return num;
          }
        }
        return 0;
      };
    }
    module2.exports = helperCreateToNumber;
  }
});

// node_modules/xe-utils/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/xe-utils/toNumber.js"(exports2, module2) {
    var helperCreateToNumber = require_helperCreateToNumber();
    var toNumber = helperCreateToNumber(parseFloat);
    module2.exports = toNumber;
  }
});

// node_modules/xe-utils/slice.js
var require_slice = __commonJS({
  "node_modules/xe-utils/slice.js"(exports2, module2) {
    var toNumber = require_toNumber();
    function slice(array, startIndex, endIndex) {
      var result = [];
      var argsSize = arguments.length;
      if (array) {
        startIndex = argsSize >= 2 ? toNumber(startIndex) : 0;
        endIndex = argsSize >= 3 ? toNumber(endIndex) : array.length;
        if (array.slice) {
          return array.slice(startIndex, endIndex);
        }
        for (; startIndex < endIndex; startIndex++) {
          result.push(array[startIndex]);
        }
      }
      return result;
    }
    module2.exports = slice;
  }
});

// node_modules/xe-utils/filter.js
var require_filter = __commonJS({
  "node_modules/xe-utils/filter.js"(exports2, module2) {
    var each = require_each();
    function filter(obj, iterate, context) {
      var result = [];
      if (obj && iterate) {
        if (obj.filter) {
          return obj.filter(iterate, context);
        }
        each(obj, function(val, key) {
          if (iterate.call(context, val, key, obj)) {
            result.push(val);
          }
        });
      }
      return result;
    }
    module2.exports = filter;
  }
});

// node_modules/xe-utils/findKey.js
var require_findKey = __commonJS({
  "node_modules/xe-utils/findKey.js"(exports2, module2) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var findKey = helperCreateIterateHandle("", 0, 2, true);
    module2.exports = findKey;
  }
});

// node_modules/xe-utils/find.js
var require_find = __commonJS({
  "node_modules/xe-utils/find.js"(exports2, module2) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var find2 = helperCreateIterateHandle("find", 1, 3, true);
    module2.exports = find2;
  }
});

// node_modules/xe-utils/findLast.js
var require_findLast = __commonJS({
  "node_modules/xe-utils/findLast.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var values = require_values();
    function findLast(obj, iterate, context) {
      if (obj) {
        if (!isArray2(obj)) {
          obj = values(obj);
        }
        for (var len = obj.length - 1; len >= 0; len--) {
          if (iterate.call(context, obj[len], len, obj)) {
            return obj[len];
          }
        }
      }
    }
    module2.exports = findLast;
  }
});

// node_modules/xe-utils/reduce.js
var require_reduce = __commonJS({
  "node_modules/xe-utils/reduce.js"(exports2, module2) {
    var keys = require_keys();
    function reduce(array, callback, initialValue) {
      if (array) {
        var len, reduceMethod;
        var index2 = 0;
        var context = null;
        var previous = initialValue;
        var isInitialVal = arguments.length > 2;
        var keyList = keys(array);
        if (array.length && array.reduce) {
          reduceMethod = function() {
            return callback.apply(context, arguments);
          };
          if (isInitialVal) {
            return array.reduce(reduceMethod, previous);
          }
          return array.reduce(reduceMethod);
        }
        if (isInitialVal) {
          index2 = 1;
          previous = array[keyList[0]];
        }
        for (len = keyList.length; index2 < len; index2++) {
          previous = callback.call(context, previous, array[keyList[index2]], index2, array);
        }
        return previous;
      }
    }
    module2.exports = reduce;
  }
});

// node_modules/xe-utils/copyWithin.js
var require_copyWithin = __commonJS({
  "node_modules/xe-utils/copyWithin.js"(exports2, module2) {
    var isArray2 = require_isArray();
    function copyWithin(array, target, start, end) {
      if (isArray2(array) && array.copyWithin) {
        return array.copyWithin(target, start, end);
      }
      var replaceIndex, replaceArray;
      var targetIndex = target >> 0;
      var startIndex = start >> 0;
      var len = array.length;
      var endIndex = arguments.length > 3 ? end >> 0 : len;
      if (targetIndex < len) {
        targetIndex = targetIndex >= 0 ? targetIndex : len + targetIndex;
        if (targetIndex >= 0) {
          startIndex = startIndex >= 0 ? startIndex : len + startIndex;
          endIndex = endIndex >= 0 ? endIndex : len + endIndex;
          if (startIndex < endIndex) {
            for (replaceIndex = 0, replaceArray = array.slice(startIndex, endIndex); targetIndex < len; targetIndex++) {
              if (replaceArray.length <= replaceIndex) {
                break;
              }
              array[targetIndex] = replaceArray[replaceIndex++];
            }
          }
        }
      }
      return array;
    }
    module2.exports = copyWithin;
  }
});

// node_modules/xe-utils/chunk.js
var require_chunk = __commonJS({
  "node_modules/xe-utils/chunk.js"(exports2, module2) {
    var isArray2 = require_isArray();
    function chunk(array, size) {
      var index2;
      var result = [];
      var arrLen = size >> 0 || 1;
      if (isArray2(array)) {
        if (arrLen >= 0 && array.length > arrLen) {
          index2 = 0;
          while (index2 < array.length) {
            result.push(array.slice(index2, index2 + arrLen));
            index2 += arrLen;
          }
        } else {
          result = array.length ? [array] : array;
        }
      }
      return result;
    }
    module2.exports = chunk;
  }
});

// node_modules/xe-utils/pluck.js
var require_pluck = __commonJS({
  "node_modules/xe-utils/pluck.js"(exports2, module2) {
    var map = require_map();
    var property = require_property();
    function pluck(obj, key) {
      return map(obj, property(key));
    }
    module2.exports = pluck;
  }
});

// node_modules/xe-utils/helperCreateMinMax.js
var require_helperCreateMinMax = __commonJS({
  "node_modules/xe-utils/helperCreateMinMax.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var eqNull = require_eqNull();
    var get = require_get();
    var arrayEach = require_arrayEach();
    function helperCreateMinMax(handle) {
      return function(arr, iterate) {
        if (arr && arr.length) {
          var rest, itemIndex;
          arrayEach(arr, function(itemVal, index2) {
            if (iterate) {
              itemVal = isFunction2(iterate) ? iterate(itemVal, index2, arr) : get(itemVal, iterate);
            }
            if (!eqNull(itemVal) && (eqNull(rest) || handle(rest, itemVal))) {
              itemIndex = index2;
              rest = itemVal;
            }
          });
          return arr[itemIndex];
        }
        return rest;
      };
    }
    module2.exports = helperCreateMinMax;
  }
});

// node_modules/xe-utils/max.js
var require_max = __commonJS({
  "node_modules/xe-utils/max.js"(exports2, module2) {
    var helperCreateMinMax = require_helperCreateMinMax();
    var max = helperCreateMinMax(function(rest, itemVal) {
      return rest < itemVal;
    });
    module2.exports = max;
  }
});

// node_modules/xe-utils/unzip.js
var require_unzip = __commonJS({
  "node_modules/xe-utils/unzip.js"(exports2, module2) {
    var pluck = require_pluck();
    var max = require_max();
    function unzip(arrays) {
      var index2, maxItem, len;
      var result = [];
      if (arrays && arrays.length) {
        index2 = 0;
        maxItem = max(arrays, function(item) {
          return item ? item.length : 0;
        });
        for (len = maxItem ? maxItem.length : 0; index2 < len; index2++) {
          result.push(pluck(arrays, index2));
        }
      }
      return result;
    }
    module2.exports = unzip;
  }
});

// node_modules/xe-utils/zip.js
var require_zip = __commonJS({
  "node_modules/xe-utils/zip.js"(exports2, module2) {
    var unzip = require_unzip();
    function zip() {
      return unzip(arguments);
    }
    module2.exports = zip;
  }
});

// node_modules/xe-utils/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/xe-utils/zipObject.js"(exports2, module2) {
    var values = require_values();
    var each = require_each();
    function zipObject(props, arr) {
      var result = {};
      arr = arr || [];
      each(values(props), function(val, key) {
        result[val] = arr[key];
      });
      return result;
    }
    module2.exports = zipObject;
  }
});

// node_modules/xe-utils/flatten.js
var require_flatten = __commonJS({
  "node_modules/xe-utils/flatten.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var arrayEach = require_arrayEach();
    function flattenDeep(array, deep) {
      var result = [];
      arrayEach(array, function(vals) {
        result = result.concat(isArray2(vals) ? deep ? flattenDeep(vals, deep) : vals : [vals]);
      });
      return result;
    }
    function flatten(array, deep) {
      if (isArray2(array)) {
        return flattenDeep(array, deep);
      }
      return [];
    }
    module2.exports = flatten;
  }
});

// node_modules/xe-utils/invoke.js
var require_invoke = __commonJS({
  "node_modules/xe-utils/invoke.js"(exports2, module2) {
    var map = require_map();
    var isArray2 = require_isArray();
    function deepGetObj(obj, path) {
      var index2 = 0;
      var len = path.length;
      while (obj && index2 < len) {
        obj = obj[path[index2++]];
      }
      return len && obj ? obj : 0;
    }
    function invoke(list, path) {
      var func;
      var args = arguments;
      var params = [];
      var paths = [];
      var index2 = 2;
      var len = args.length;
      for (; index2 < len; index2++) {
        params.push(args[index2]);
      }
      if (isArray2(path)) {
        len = path.length - 1;
        for (index2 = 0; index2 < len; index2++) {
          paths.push(path[index2]);
        }
        path = path[len];
      }
      return map(list, function(context) {
        if (paths.length) {
          context = deepGetObj(context, paths);
        }
        func = context[path] || path;
        if (func && func.apply) {
          return func.apply(context, params);
        }
      });
    }
    module2.exports = invoke;
  }
});

// node_modules/xe-utils/helperDeleteProperty.js
var require_helperDeleteProperty = __commonJS({
  "node_modules/xe-utils/helperDeleteProperty.js"(exports2, module2) {
    function helperDeleteProperty(obj, property) {
      try {
        delete obj[property];
      } catch (e16) {
        obj[property] = void 0;
      }
    }
    module2.exports = helperDeleteProperty;
  }
});

// node_modules/xe-utils/lastEach.js
var require_lastEach = __commonJS({
  "node_modules/xe-utils/lastEach.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var lastArrayEach = require_lastArrayEach();
    var lastObjectEach = require_lastObjectEach();
    function lastEach(obj, iterate, context) {
      if (obj) {
        return (isArray2(obj) ? lastArrayEach : lastObjectEach)(obj, iterate, context);
      }
      return obj;
    }
    module2.exports = lastEach;
  }
});

// node_modules/xe-utils/isObject.js
var require_isObject = __commonJS({
  "node_modules/xe-utils/isObject.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isObject3 = helperCreateInTypeof("object");
    module2.exports = isObject3;
  }
});

// node_modules/xe-utils/clear.js
var require_clear = __commonJS({
  "node_modules/xe-utils/clear.js"(exports2, module2) {
    var helperDeleteProperty = require_helperDeleteProperty();
    var isPlainObject2 = require_isPlainObject();
    var isObject3 = require_isObject();
    var isArray2 = require_isArray();
    var isNull = require_isNull();
    var assign3 = require_assign();
    var objectEach = require_objectEach();
    function clear(obj, defs, assigns) {
      if (obj) {
        var len;
        var isDefs = arguments.length > 1 && (isNull(defs) || !isObject3(defs));
        var extds = isDefs ? assigns : defs;
        if (isPlainObject2(obj)) {
          objectEach(obj, isDefs ? function(val, key) {
            obj[key] = defs;
          } : function(val, key) {
            helperDeleteProperty(obj, key);
          });
          if (extds) {
            assign3(obj, extds);
          }
        } else if (isArray2(obj)) {
          if (isDefs) {
            len = obj.length;
            while (len > 0) {
              len--;
              obj[len] = defs;
            }
          } else {
            obj.length = 0;
          }
          if (extds) {
            obj.push.apply(obj, extds);
          }
        }
      }
      return obj;
    }
    module2.exports = clear;
  }
});

// node_modules/xe-utils/remove.js
var require_remove = __commonJS({
  "node_modules/xe-utils/remove.js"(exports2, module2) {
    var helperDeleteProperty = require_helperDeleteProperty();
    var isFunction2 = require_isFunction();
    var isArray2 = require_isArray();
    var each = require_each();
    var arrayEach = require_arrayEach();
    var lastEach = require_lastEach();
    var clear = require_clear();
    var eqNull = require_eqNull();
    function pluckProperty(name) {
      return function(obj, key) {
        return key === name;
      };
    }
    function remove(obj, iterate, context) {
      if (obj) {
        if (!eqNull(iterate)) {
          var removeKeys = [];
          var rest = [];
          if (!isFunction2(iterate)) {
            iterate = pluckProperty(iterate);
          }
          each(obj, function(item, index2, rest2) {
            if (iterate.call(context, item, index2, rest2)) {
              removeKeys.push(index2);
            }
          });
          if (isArray2(obj)) {
            lastEach(removeKeys, function(item, key) {
              rest.push(obj[item]);
              obj.splice(item, 1);
            });
          } else {
            rest = {};
            arrayEach(removeKeys, function(key) {
              rest[key] = obj[key];
              helperDeleteProperty(obj, key);
            });
          }
          return rest;
        }
        return clear(obj);
      }
      return obj;
    }
    module2.exports = remove;
  }
});

// node_modules/xe-utils/toArrayTree.js
var require_toArrayTree = __commonJS({
  "node_modules/xe-utils/toArrayTree.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var map = require_map();
    var orderBy = require_orderBy();
    var clone2 = require_clone();
    var eqNull = require_eqNull();
    var each = require_each();
    var remove = require_remove();
    var assign3 = require_assign();
    function strictTree(array, optChildren) {
      each(array, function(item) {
        if (item[optChildren] && !item[optChildren].length) {
          remove(item, optChildren);
        }
      });
    }
    function toArrayTree(array, options) {
      var opts = assign3({}, setupDefaults.treeOptions, options);
      var optStrict = opts.strict;
      var optKey = opts.key;
      var optParentKey = opts.parentKey;
      var optChildren = opts.children;
      var optMapChildren = opts.mapChildren;
      var optSortKey = opts.sortKey;
      var optReverse = opts.reverse;
      var optData = opts.data;
      var result = [];
      var treeMap = {};
      var idsMap = {};
      var id2, treeData, parentId;
      if (optSortKey) {
        array = orderBy(clone2(array), optSortKey);
        if (optReverse) {
          array = array.reverse();
        }
      }
      each(array, function(item) {
        id2 = item[optKey];
        idsMap[id2] = true;
      });
      each(array, function(item) {
        id2 = item[optKey];
        if (optData) {
          treeData = {};
          treeData[optData] = item;
        } else {
          treeData = item;
        }
        parentId = item[optParentKey];
        treeMap[id2] = treeMap[id2] || [];
        treeData[optKey] = id2;
        treeData[optParentKey] = parentId;
        if (id2 === parentId) {
          parentId = null;
          console.log("Fix infinite Loop.", item);
        }
        treeMap[parentId] = treeMap[parentId] || [];
        treeMap[parentId].push(treeData);
        treeData[optChildren] = treeMap[id2];
        if (optMapChildren) {
          treeData[optMapChildren] = treeMap[id2];
        }
        if (!optStrict || optStrict && eqNull(parentId)) {
          if (!idsMap[parentId]) {
            result.push(treeData);
          }
        }
      });
      if (optStrict) {
        strictTree(array, optChildren);
      }
      return result;
    }
    module2.exports = toArrayTree;
  }
});

// node_modules/xe-utils/toTreeArray.js
var require_toTreeArray = __commonJS({
  "node_modules/xe-utils/toTreeArray.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var each = require_each();
    var assign3 = require_assign();
    function unTreeList(result, array, opts) {
      var optChildren = opts.children;
      var optData = opts.data;
      var optClear = opts.clear;
      each(array, function(item) {
        var children = item[optChildren];
        if (optData) {
          item = item[optData];
        }
        result.push(item);
        if (children && children.length) {
          unTreeList(result, children, opts);
        }
        if (optClear) {
          delete item[optChildren];
        }
      });
      return result;
    }
    function toTreeArray(array, options) {
      return unTreeList([], array, assign3({}, setupDefaults.treeOptions, options));
    }
    module2.exports = toTreeArray;
  }
});

// node_modules/xe-utils/helperCreateTreeFunc.js
var require_helperCreateTreeFunc = __commonJS({
  "node_modules/xe-utils/helperCreateTreeFunc.js"(exports2, module2) {
    function helperCreateTreeFunc(handle) {
      return function(obj, iterate, options, context) {
        var opts = options || {};
        var optChildren = opts.children || "children";
        return handle(null, obj, iterate, context, [], [], optChildren, opts);
      };
    }
    module2.exports = helperCreateTreeFunc;
  }
});

// node_modules/xe-utils/findTree.js
var require_findTree = __commonJS({
  "node_modules/xe-utils/findTree.js"(exports2, module2) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    function findTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      if (obj) {
        var item, index2, len, paths, nodes, match;
        for (index2 = 0, len = obj.length; index2 < len; index2++) {
          item = obj[index2];
          paths = path.concat(["" + index2]);
          nodes = node.concat([item]);
          if (iterate.call(context, item, index2, obj, paths, parent, nodes)) {
            return { index: index2, item, path: paths, items: obj, parent, nodes };
          }
          if (parseChildren && item) {
            match = findTreeItem(item, item[parseChildren], iterate, context, paths.concat([parseChildren]), nodes, parseChildren, opts);
            if (match) {
              return match;
            }
          }
        }
      }
    }
    var findTree = helperCreateTreeFunc(findTreeItem);
    module2.exports = findTree;
  }
});

// node_modules/xe-utils/eachTree.js
var require_eachTree = __commonJS({
  "node_modules/xe-utils/eachTree.js"(exports2, module2) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var each = require_each();
    function eachTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes;
      each(obj, function(item, index2) {
        paths = path.concat(["" + index2]);
        nodes = node.concat([item]);
        iterate.call(context, item, index2, obj, paths, parent, nodes);
        if (item && parseChildren) {
          paths.push(parseChildren);
          eachTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        }
      });
    }
    var eachTree = helperCreateTreeFunc(eachTreeItem);
    module2.exports = eachTree;
  }
});

// node_modules/xe-utils/mapTree.js
var require_mapTree = __commonJS({
  "node_modules/xe-utils/mapTree.js"(exports2, module2) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var map = require_map();
    function mapTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes, rest;
      var mapChildren = opts.mapChildren || parseChildren;
      return map(obj, function(item, index2) {
        paths = path.concat(["" + index2]);
        nodes = node.concat([item]);
        rest = iterate.call(context, item, index2, obj, paths, parent, nodes);
        if (rest && item && parseChildren && item[parseChildren]) {
          rest[mapChildren] = mapTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        }
        return rest;
      });
    }
    var mapTree = helperCreateTreeFunc(mapTreeItem);
    module2.exports = mapTree;
  }
});

// node_modules/xe-utils/filterTree.js
var require_filterTree = __commonJS({
  "node_modules/xe-utils/filterTree.js"(exports2, module2) {
    var eachTree = require_eachTree();
    function filterTree(obj, iterate, options, context) {
      var result = [];
      if (obj && iterate) {
        eachTree(obj, function(item, index2, items, path, parent, nodes) {
          if (iterate.call(context, item, index2, items, path, parent, nodes)) {
            result.push(item);
          }
        }, options);
      }
      return result;
    }
    module2.exports = filterTree;
  }
});

// node_modules/xe-utils/searchTree.js
var require_searchTree = __commonJS({
  "node_modules/xe-utils/searchTree.js"(exports2, module2) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var arrayEach = require_arrayEach();
    var assign3 = require_assign();
    function searchTreeItem(matchParent, parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes, rest, isMatch, hasChild;
      var rests = [];
      var hasOriginal = opts.original;
      var sourceData = opts.data;
      var mapChildren = opts.mapChildren || parseChildren;
      var isEvery = opts.isEvery;
      arrayEach(obj, function(item, index2) {
        paths = path.concat(["" + index2]);
        nodes = node.concat([item]);
        isMatch = matchParent && !isEvery || iterate.call(context, item, index2, obj, paths, parent, nodes);
        hasChild = parseChildren && item[parseChildren];
        if (isMatch || hasChild) {
          if (hasOriginal) {
            rest = item;
          } else {
            rest = assign3({}, item);
            if (sourceData) {
              rest[sourceData] = item;
            }
          }
          rest[mapChildren] = searchTreeItem(isMatch, item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
          if (isMatch || rest[mapChildren].length) {
            rests.push(rest);
          }
        } else if (isMatch) {
          rests.push(rest);
        }
      });
      return rests;
    }
    var searchTree = helperCreateTreeFunc(function(parent, obj, iterate, context, path, nodes, parseChildren, opts) {
      return searchTreeItem(0, parent, obj, iterate, context, path, nodes, parseChildren, opts);
    });
    module2.exports = searchTree;
  }
});

// node_modules/xe-utils/arrayIndexOf.js
var require_arrayIndexOf = __commonJS({
  "node_modules/xe-utils/arrayIndexOf.js"(exports2, module2) {
    function arrayIndexOf(list, val) {
      if (list.indexOf) {
        return list.indexOf(val);
      }
      for (var index2 = 0, len = list.length; index2 < len; index2++) {
        if (val === list[index2]) {
          return index2;
        }
      }
    }
    module2.exports = arrayIndexOf;
  }
});

// node_modules/xe-utils/arrayLastIndexOf.js
var require_arrayLastIndexOf = __commonJS({
  "node_modules/xe-utils/arrayLastIndexOf.js"(exports2, module2) {
    function arrayLastIndexOf(list, val) {
      if (list.lastIndexOf) {
        return list.lastIndexOf(val);
      }
      for (var len = list.length - 1; len >= 0; len--) {
        if (val === list[len]) {
          return len;
        }
      }
      return -1;
    }
    module2.exports = arrayLastIndexOf;
  }
});

// node_modules/xe-utils/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/xe-utils/isNumber.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isNumber2 = helperCreateInTypeof("number");
    module2.exports = isNumber2;
  }
});

// node_modules/xe-utils/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/xe-utils/isNaN.js"(exports2, module2) {
    var isNumber2 = require_isNumber();
    function isNumberNaN(obj) {
      return isNumber2(obj) && isNaN(obj);
    }
    module2.exports = isNumberNaN;
  }
});

// node_modules/xe-utils/isString.js
var require_isString = __commonJS({
  "node_modules/xe-utils/isString.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isString3 = helperCreateInTypeof("string");
    module2.exports = isString3;
  }
});

// node_modules/xe-utils/isDate.js
var require_isDate = __commonJS({
  "node_modules/xe-utils/isDate.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isDate2 = helperCreateInInObjectString("Date");
    module2.exports = isDate2;
  }
});

// node_modules/xe-utils/staticParseInt.js
var require_staticParseInt = __commonJS({
  "node_modules/xe-utils/staticParseInt.js"(exports2, module2) {
    var staticParseInt = parseInt;
    module2.exports = staticParseInt;
  }
});

// node_modules/xe-utils/helperGetUTCDateTime.js
var require_helperGetUTCDateTime = __commonJS({
  "node_modules/xe-utils/helperGetUTCDateTime.js"(exports2, module2) {
    function helperGetUTCDateTime(resMaps) {
      return Date.UTC(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
    }
    module2.exports = helperGetUTCDateTime;
  }
});

// node_modules/xe-utils/helperGetDateTime.js
var require_helperGetDateTime = __commonJS({
  "node_modules/xe-utils/helperGetDateTime.js"(exports2, module2) {
    function helperGetDateTime(date) {
      return date.getTime();
    }
    module2.exports = helperGetDateTime;
  }
});

// node_modules/xe-utils/toStringDate.js
var require_toStringDate = __commonJS({
  "node_modules/xe-utils/toStringDate.js"(exports2, module2) {
    var staticParseInt = require_staticParseInt();
    var helperGetUTCDateTime = require_helperGetUTCDateTime();
    var helperGetDateTime = require_helperGetDateTime();
    var isString3 = require_isString();
    var isDate2 = require_isDate();
    function getParseRule(txt) {
      return "(\\d{" + txt + "})";
    }
    function toParseMs(num) {
      if (num < 10) {
        return num * 100;
      } else if (num < 100) {
        return num * 10;
      }
      return num;
    }
    function toParseNum(num) {
      return isNaN(num) ? num : staticParseInt(num);
    }
    var d22 = getParseRule(2);
    var d1or2 = getParseRule("1,2");
    var d1or7 = getParseRule("1,7");
    var d3or4 = getParseRule("3,4");
    var place = ".{1}";
    var d1Or2RE = place + d1or2;
    var dzZ = "(([zZ])|([-+]\\d{2}:?\\d{2}))";
    var defaulParseStrs = [d3or4, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, place + d1or7, dzZ];
    var defaulParseREs = [];
    for (len = defaulParseStrs.length - 1; len >= 0; len--) {
      rule = "";
      for (i = 0; i < len + 1; i++) {
        rule += defaulParseStrs[i];
      }
      defaulParseREs.push(new RegExp("^" + rule + "$"));
    }
    var rule;
    var i;
    var len;
    function parseDefaultRules(str) {
      var matchRest, resMaps = {};
      for (var i10 = 0, dfrLen = defaulParseREs.length; i10 < dfrLen; i10++) {
        matchRest = str.match(defaulParseREs[i10]);
        if (matchRest) {
          resMaps.y = matchRest[1];
          resMaps.M = matchRest[2];
          resMaps.d = matchRest[3];
          resMaps.H = matchRest[4];
          resMaps.m = matchRest[5];
          resMaps.s = matchRest[6];
          resMaps.S = matchRest[7];
          resMaps.Z = matchRest[8];
          break;
        }
      }
      return resMaps;
    }
    var customParseStrs = [
      ["yyyy", d3or4],
      ["yy", d22],
      ["MM", d22],
      ["M", d1or2],
      ["dd", d22],
      ["d", d1or2],
      ["HH", d22],
      ["H", d1or2],
      ["mm", d22],
      ["m", d1or2],
      ["ss", d22],
      ["s", d1or2],
      ["SSS", getParseRule(3)],
      ["S", d1or7],
      ["Z", dzZ]
    ];
    var parseRuleMaps = {};
    var parseRuleKeys = ["\\[([^\\]]+)\\]"];
    for (i = 0; i < customParseStrs.length; i++) {
      itemRule = customParseStrs[i];
      parseRuleMaps[itemRule[0]] = itemRule[1] + "?";
      parseRuleKeys.push(itemRule[0]);
    }
    var itemRule;
    var i;
    var customParseRes = new RegExp(parseRuleKeys.join("|"), "g");
    var cacheFormatMaps = {};
    function parseCustomRules(str, format4) {
      var cacheItem = cacheFormatMaps[format4];
      if (!cacheItem) {
        var posIndexs = [];
        var re = format4.replace(/([$(){}*+.?\\^|])/g, "\\$1").replace(customParseRes, function(text, val) {
          var firstChar = text.charAt(0);
          if (firstChar === "[") {
            return val;
          }
          posIndexs.push(firstChar);
          return parseRuleMaps[text];
        });
        cacheItem = cacheFormatMaps[format4] = {
          _i: posIndexs,
          _r: new RegExp(re)
        };
      }
      var resMaps = {};
      var matchRest = str.match(cacheItem._r);
      if (matchRest) {
        var _i2 = cacheItem._i;
        for (var i10 = 1, len2 = matchRest.length; i10 < len2; i10++) {
          resMaps[_i2[i10 - 1]] = matchRest[i10];
        }
        return resMaps;
      }
      return resMaps;
    }
    function parseTimeZone(resMaps) {
      if (/^[zZ]/.test(resMaps.Z)) {
        return new Date(helperGetUTCDateTime(resMaps));
      } else {
        var matchRest = resMaps.Z.match(/([-+])(\d{2}):?(\d{2})/);
        if (matchRest) {
          return new Date(helperGetUTCDateTime(resMaps) - (matchRest[1] === "-" ? -1 : 1) * staticParseInt(matchRest[2]) * 36e5 + staticParseInt(matchRest[3]) * 6e4);
        }
      }
      return /* @__PURE__ */ new Date("");
    }
    function toStringDate(str, format4) {
      if (str) {
        var isDType = isDate2(str);
        if (isDType || !format4 && /^[0-9]{11,15}$/.test(str)) {
          return new Date(isDType ? helperGetDateTime(str) : staticParseInt(str));
        }
        if (isString3(str)) {
          var resMaps = format4 ? parseCustomRules(str, format4) : parseDefaultRules(str);
          if (resMaps.y) {
            if (resMaps.M) {
              resMaps.M = toParseNum(resMaps.M) - 1;
            }
            if (resMaps.S) {
              resMaps.S = toParseMs(toParseNum(resMaps.S.substring(0, 3)));
            }
            if (resMaps.Z) {
              return parseTimeZone(resMaps);
            } else {
              return new Date(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
            }
          }
        }
      }
      return /* @__PURE__ */ new Date("");
    }
    module2.exports = toStringDate;
  }
});

// node_modules/xe-utils/helperNewDate.js
var require_helperNewDate = __commonJS({
  "node_modules/xe-utils/helperNewDate.js"(exports2, module2) {
    function helperNewDate() {
      return /* @__PURE__ */ new Date();
    }
    module2.exports = helperNewDate;
  }
});

// node_modules/xe-utils/isLeapYear.js
var require_isLeapYear = __commonJS({
  "node_modules/xe-utils/isLeapYear.js"(exports2, module2) {
    var isDate2 = require_isDate();
    var toStringDate = require_toStringDate();
    var helperNewDate = require_helperNewDate();
    function isLeapYear(date) {
      var year;
      var currentDate = date ? toStringDate(date) : helperNewDate();
      if (isDate2(currentDate)) {
        year = currentDate.getFullYear();
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      return false;
    }
    module2.exports = isLeapYear;
  }
});

// node_modules/xe-utils/forOf.js
var require_forOf = __commonJS({
  "node_modules/xe-utils/forOf.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var hasOwnProp = require_hasOwnProp();
    function forOf(obj, iterate, context) {
      if (obj) {
        if (isArray2(obj)) {
          for (var index2 = 0, len = obj.length; index2 < len; index2++) {
            if (iterate.call(context, obj[index2], index2, obj) === false) {
              break;
            }
          }
        } else {
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (iterate.call(context, obj[key], key, obj) === false) {
                break;
              }
            }
          }
        }
      }
    }
    module2.exports = forOf;
  }
});

// node_modules/xe-utils/lastForOf.js
var require_lastForOf = __commonJS({
  "node_modules/xe-utils/lastForOf.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var keys = require_hasOwnProp();
    function lastForOf(obj, iterate, context) {
      if (obj) {
        var len, list;
        if (isArray2(obj)) {
          for (len = obj.length - 1; len >= 0; len--) {
            if (iterate.call(context, obj[len], len, obj) === false) {
              break;
            }
          }
        } else {
          list = keys(obj);
          for (len = list.length - 1; len >= 0; len--) {
            if (iterate.call(context, obj[list[len]], list[len], obj) === false) {
              break;
            }
          }
        }
      }
    }
    module2.exports = lastForOf;
  }
});

// node_modules/xe-utils/helperCreateIndexOf.js
var require_helperCreateIndexOf = __commonJS({
  "node_modules/xe-utils/helperCreateIndexOf.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isString3 = require_isString();
    var hasOwnProp = require_hasOwnProp();
    function helperCreateIndexOf(name, callback) {
      return function(obj, val) {
        if (obj) {
          if (obj[name]) {
            return obj[name](val);
          }
          if (isString3(obj) || isArray2(obj)) {
            return callback(obj, val);
          }
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (val === obj[key]) {
                return key;
              }
            }
          }
        }
        return -1;
      };
    }
    module2.exports = helperCreateIndexOf;
  }
});

// node_modules/xe-utils/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/xe-utils/indexOf.js"(exports2, module2) {
    var helperCreateIndexOf = require_helperCreateIndexOf();
    var arrayIndexOf = require_arrayIndexOf();
    var indexOf = helperCreateIndexOf("indexOf", arrayIndexOf);
    module2.exports = indexOf;
  }
});

// node_modules/xe-utils/lastIndexOf.js
var require_lastIndexOf = __commonJS({
  "node_modules/xe-utils/lastIndexOf.js"(exports2, module2) {
    var helperCreateIndexOf = require_helperCreateIndexOf();
    var arrayLastIndexOf = require_arrayLastIndexOf();
    var lastIndexOf = helperCreateIndexOf("lastIndexOf", arrayLastIndexOf);
    module2.exports = lastIndexOf;
  }
});

// node_modules/xe-utils/getSize.js
var require_getSize = __commonJS({
  "node_modules/xe-utils/getSize.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isString3 = require_isString();
    var each = require_each();
    function getSize(obj) {
      var len = 0;
      if (isString3(obj) || isArray2(obj)) {
        return obj.length;
      }
      each(obj, function() {
        len++;
      });
      return len;
    }
    module2.exports = getSize;
  }
});

// node_modules/xe-utils/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/xe-utils/isFinite.js"(exports2, module2) {
    var isNumber2 = require_isNumber();
    function isNumberFinite(obj) {
      return isNumber2(obj) && isFinite(obj);
    }
    module2.exports = isNumberFinite;
  }
});

// node_modules/xe-utils/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/xe-utils/isInteger.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isNull = require_isNull();
    var isInteger = function(obj) {
      return !isNull(obj) && !isNaN(obj) && !isArray2(obj) && obj % 1 === 0;
    };
    module2.exports = isInteger;
  }
});

// node_modules/xe-utils/isFloat.js
var require_isFloat = __commonJS({
  "node_modules/xe-utils/isFloat.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isInteger = require_isInteger();
    var isNull = require_isNull();
    function isFloat(obj) {
      return !isNull(obj) && !isNaN(obj) && !isArray2(obj) && !isInteger(obj);
    }
    module2.exports = isFloat;
  }
});

// node_modules/xe-utils/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/xe-utils/isBoolean.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isBoolean2 = helperCreateInTypeof("boolean");
    module2.exports = isBoolean2;
  }
});

// node_modules/xe-utils/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/xe-utils/isRegExp.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isRegExp2 = helperCreateInInObjectString("RegExp");
    module2.exports = isRegExp2;
  }
});

// node_modules/xe-utils/isError.js
var require_isError = __commonJS({
  "node_modules/xe-utils/isError.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isError = helperCreateInInObjectString("Error");
    module2.exports = isError;
  }
});

// node_modules/xe-utils/isTypeError.js
var require_isTypeError = __commonJS({
  "node_modules/xe-utils/isTypeError.js"(exports2, module2) {
    function isTypeError(obj) {
      return obj ? obj.constructor === TypeError : false;
    }
    module2.exports = isTypeError;
  }
});

// node_modules/xe-utils/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/xe-utils/isEmpty.js"(exports2, module2) {
    function isEmpty(obj) {
      for (var key in obj) {
        return false;
      }
      return true;
    }
    module2.exports = isEmpty;
  }
});

// node_modules/xe-utils/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/xe-utils/isSymbol.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportSymbol = typeof Symbol !== staticStrUndefined;
    function isSymbol(obj) {
      return supportSymbol && Symbol.isSymbol ? Symbol.isSymbol(obj) : typeof obj === "symbol";
    }
    module2.exports = isSymbol;
  }
});

// node_modules/xe-utils/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/xe-utils/isArguments.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isArguments = helperCreateInInObjectString("Arguments");
    module2.exports = isArguments;
  }
});

// node_modules/xe-utils/isElement.js
var require_isElement = __commonJS({
  "node_modules/xe-utils/isElement.js"(exports2, module2) {
    var isString3 = require_isString();
    var isNumber2 = require_isNumber();
    function isElement(obj) {
      return !!(obj && isString3(obj.nodeName) && isNumber2(obj.nodeType));
    }
    module2.exports = isElement;
  }
});

// node_modules/xe-utils/staticDocument.js
var require_staticDocument = __commonJS({
  "node_modules/xe-utils/staticDocument.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticDocument = typeof document === staticStrUndefined ? 0 : document;
    module2.exports = staticDocument;
  }
});

// node_modules/xe-utils/isDocument.js
var require_isDocument = __commonJS({
  "node_modules/xe-utils/isDocument.js"(exports2, module2) {
    var staticDocument = require_staticDocument();
    function isDocument(obj) {
      return !!(obj && staticDocument && obj.nodeType === 9);
    }
    module2.exports = isDocument;
  }
});

// node_modules/xe-utils/staticWindow.js
var require_staticWindow = __commonJS({
  "node_modules/xe-utils/staticWindow.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticWindow = typeof window === staticStrUndefined ? 0 : window;
    module2.exports = staticWindow;
  }
});

// node_modules/xe-utils/isWindow.js
var require_isWindow = __commonJS({
  "node_modules/xe-utils/isWindow.js"(exports2, module2) {
    var staticWindow = require_staticWindow();
    function isWindow(obj) {
      return !!(staticWindow && !!(obj && obj === obj.window));
    }
    module2.exports = isWindow;
  }
});

// node_modules/xe-utils/isFormData.js
var require_isFormData = __commonJS({
  "node_modules/xe-utils/isFormData.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportFormData = typeof FormData !== staticStrUndefined;
    function isFormData(obj) {
      return supportFormData && obj instanceof FormData;
    }
    module2.exports = isFormData;
  }
});

// node_modules/xe-utils/isMap.js
var require_isMap = __commonJS({
  "node_modules/xe-utils/isMap.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportMap = typeof Map !== staticStrUndefined;
    function isMap(obj) {
      return supportMap && obj instanceof Map;
    }
    module2.exports = isMap;
  }
});

// node_modules/xe-utils/isWeakMap.js
var require_isWeakMap = __commonJS({
  "node_modules/xe-utils/isWeakMap.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportWeakMap = typeof WeakMap !== staticStrUndefined;
    function isWeakMap(obj) {
      return supportWeakMap && obj instanceof WeakMap;
    }
    module2.exports = isWeakMap;
  }
});

// node_modules/xe-utils/isSet.js
var require_isSet = __commonJS({
  "node_modules/xe-utils/isSet.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportSet = typeof Set !== staticStrUndefined;
    function isSet(obj) {
      return supportSet && obj instanceof Set;
    }
    module2.exports = isSet;
  }
});

// node_modules/xe-utils/isWeakSet.js
var require_isWeakSet = __commonJS({
  "node_modules/xe-utils/isWeakSet.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportWeakSet = typeof WeakSet !== staticStrUndefined;
    function isWeakSet(obj) {
      return supportWeakSet && obj instanceof WeakSet;
    }
    module2.exports = isWeakSet;
  }
});

// node_modules/xe-utils/helperCreateiterateIndexOf.js
var require_helperCreateiterateIndexOf = __commonJS({
  "node_modules/xe-utils/helperCreateiterateIndexOf.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isString3 = require_isString();
    var isArray2 = require_isArray();
    var hasOwnProp = require_hasOwnProp();
    function helperCreateiterateIndexOf(callback) {
      return function(obj, iterate, context) {
        if (obj && isFunction2(iterate)) {
          if (isArray2(obj) || isString3(obj)) {
            return callback(obj, iterate, context);
          }
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (iterate.call(context, obj[key], key, obj)) {
                return key;
              }
            }
          }
        }
        return -1;
      };
    }
    module2.exports = helperCreateiterateIndexOf;
  }
});

// node_modules/xe-utils/findIndexOf.js
var require_findIndexOf = __commonJS({
  "node_modules/xe-utils/findIndexOf.js"(exports2, module2) {
    var helperCreateiterateIndexOf = require_helperCreateiterateIndexOf();
    var findIndexOf = helperCreateiterateIndexOf(function(obj, iterate, context) {
      for (var index2 = 0, len = obj.length; index2 < len; index2++) {
        if (iterate.call(context, obj[index2], index2, obj)) {
          return index2;
        }
      }
      return -1;
    });
    module2.exports = findIndexOf;
  }
});

// node_modules/xe-utils/helperEqualCompare.js
var require_helperEqualCompare = __commonJS({
  "node_modules/xe-utils/helperEqualCompare.js"(exports2, module2) {
    var isNumber2 = require_isNumber();
    var isArray2 = require_isArray();
    var isString3 = require_isString();
    var isRegExp2 = require_isRegExp();
    var isDate2 = require_isDate();
    var isBoolean2 = require_isBoolean();
    var isUndefined = require_isUndefined();
    var keys = require_keys();
    var every = require_every();
    function helperEqualCompare(val1, val2, compare, func, key, obj1, obj2) {
      if (val1 === val2) {
        return true;
      }
      if (val1 && val2 && !isNumber2(val1) && !isNumber2(val2) && !isString3(val1) && !isString3(val2)) {
        if (isRegExp2(val1)) {
          return compare("" + val1, "" + val2, key, obj1, obj2);
        }
        if (isDate2(val1) || isBoolean2(val1)) {
          return compare(+val1, +val2, key, obj1, obj2);
        } else {
          var result, val1Keys, val2Keys;
          var isObj1Arr = isArray2(val1);
          var isObj2Arr = isArray2(val2);
          if (isObj1Arr || isObj2Arr ? isObj1Arr && isObj2Arr : val1.constructor === val2.constructor) {
            val1Keys = keys(val1);
            val2Keys = keys(val2);
            if (func) {
              result = func(val1, val2, key);
            }
            if (val1Keys.length === val2Keys.length) {
              return isUndefined(result) ? every(val1Keys, function(key2, index2) {
                return key2 === val2Keys[index2] && helperEqualCompare(val1[key2], val2[val2Keys[index2]], compare, func, isObj1Arr || isObj2Arr ? index2 : key2, val1, val2);
              }) : !!result;
            }
            return false;
          }
        }
      }
      return compare(val1, val2, key, obj1, obj2);
    }
    module2.exports = helperEqualCompare;
  }
});

// node_modules/xe-utils/helperDefaultCompare.js
var require_helperDefaultCompare = __commonJS({
  "node_modules/xe-utils/helperDefaultCompare.js"(exports2, module2) {
    function helperDefaultCompare(v12, v22) {
      return v12 === v22;
    }
    module2.exports = helperDefaultCompare;
  }
});

// node_modules/xe-utils/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/xe-utils/isEqual.js"(exports2, module2) {
    var helperEqualCompare = require_helperEqualCompare();
    var helperDefaultCompare = require_helperDefaultCompare();
    function isEqual(obj1, obj2) {
      return helperEqualCompare(obj1, obj2, helperDefaultCompare);
    }
    module2.exports = isEqual;
  }
});

// node_modules/xe-utils/isMatch.js
var require_isMatch = __commonJS({
  "node_modules/xe-utils/isMatch.js"(exports2, module2) {
    var keys = require_keys();
    var findIndexOf = require_findIndexOf();
    var isEqual = require_isEqual();
    var some = require_some();
    var includeArrays = require_includeArrays();
    function isMatch(obj, source) {
      var objKeys = keys(obj);
      var sourceKeys = keys(source);
      if (sourceKeys.length) {
        if (includeArrays(objKeys, sourceKeys)) {
          return some(sourceKeys, function(key2) {
            return findIndexOf(objKeys, function(key1) {
              return key1 === key2 && isEqual(obj[key1], source[key2]);
            }) > -1;
          });
        }
      } else {
        return true;
      }
      return isEqual(obj, source);
    }
    module2.exports = isMatch;
  }
});

// node_modules/xe-utils/isEqualWith.js
var require_isEqualWith = __commonJS({
  "node_modules/xe-utils/isEqualWith.js"(exports2, module2) {
    var helperEqualCompare = require_helperEqualCompare();
    var helperDefaultCompare = require_helperDefaultCompare();
    var isFunction2 = require_isFunction();
    var isUndefined = require_isUndefined();
    function isEqualWith(obj1, obj2, func) {
      if (isFunction2(func)) {
        return helperEqualCompare(obj1, obj2, function(v12, v22, key, obj12, obj22) {
          var result = func(v12, v22, key, obj12, obj22);
          return isUndefined(result) ? helperDefaultCompare(v12, v22) : !!result;
        }, func);
      }
      return helperEqualCompare(obj1, obj2, helperDefaultCompare);
    }
    module2.exports = isEqualWith;
  }
});

// node_modules/xe-utils/getType.js
var require_getType = __commonJS({
  "node_modules/xe-utils/getType.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var isDate2 = require_isDate();
    var isArray2 = require_isArray();
    var isRegExp2 = require_isRegExp();
    var isError = require_isError();
    var isNull = require_isNull();
    function getType(obj) {
      if (isNull(obj)) {
        return "null";
      }
      if (isSymbol(obj)) {
        return "symbol";
      }
      if (isDate2(obj)) {
        return "date";
      }
      if (isArray2(obj)) {
        return "array";
      }
      if (isRegExp2(obj)) {
        return "regexp";
      }
      if (isError(obj)) {
        return "error";
      }
      return typeof obj;
    }
    module2.exports = getType;
  }
});

// node_modules/xe-utils/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/xe-utils/uniqueId.js"(exports2, module2) {
    var __uniqueId = 0;
    function uniqueId(prefix) {
      return [prefix, ++__uniqueId].join("");
    }
    module2.exports = uniqueId;
  }
});

// node_modules/xe-utils/findLastIndexOf.js
var require_findLastIndexOf = __commonJS({
  "node_modules/xe-utils/findLastIndexOf.js"(exports2, module2) {
    var helperCreateiterateIndexOf = require_helperCreateiterateIndexOf();
    var findLastIndexOf = helperCreateiterateIndexOf(function(obj, iterate, context) {
      for (var len = obj.length - 1; len >= 0; len--) {
        if (iterate.call(context, obj[len], len, obj)) {
          return len;
        }
      }
      return -1;
    });
    module2.exports = findLastIndexOf;
  }
});

// node_modules/xe-utils/toStringJSON.js
var require_toStringJSON = __commonJS({
  "node_modules/xe-utils/toStringJSON.js"(exports2, module2) {
    var isPlainObject2 = require_isPlainObject();
    var isString3 = require_isString();
    function toStringJSON(str) {
      if (isPlainObject2(str)) {
        return str;
      } else if (isString3(str)) {
        try {
          return JSON.parse(str);
        } catch (e16) {
        }
      }
      return {};
    }
    module2.exports = toStringJSON;
  }
});

// node_modules/xe-utils/toJSONString.js
var require_toJSONString = __commonJS({
  "node_modules/xe-utils/toJSONString.js"(exports2, module2) {
    var eqNull = require_eqNull();
    function toJSONString(obj) {
      return eqNull(obj) ? "" : JSON.stringify(obj);
    }
    module2.exports = toJSONString;
  }
});

// node_modules/xe-utils/entries.js
var require_entries = __commonJS({
  "node_modules/xe-utils/entries.js"(exports2, module2) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var entries = helperCreateGetObjects("entries", 2);
    module2.exports = entries;
  }
});

// node_modules/xe-utils/helperCreatePickOmit.js
var require_helperCreatePickOmit = __commonJS({
  "node_modules/xe-utils/helperCreatePickOmit.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isArray2 = require_isArray();
    var each = require_each();
    var findIndexOf = require_findIndexOf();
    function helperCreatePickOmit(case1, case2) {
      return function(obj, callback) {
        var item, index2;
        var rest = {};
        var result = [];
        var context = this;
        var args = arguments;
        var len = args.length;
        if (!isFunction2(callback)) {
          for (index2 = 1; index2 < len; index2++) {
            item = args[index2];
            result.push.apply(result, isArray2(item) ? item : [item]);
          }
          callback = 0;
        }
        each(obj, function(val, key) {
          if ((callback ? callback.call(context, val, key, obj) : findIndexOf(result, function(name) {
            return name === key;
          }) > -1) ? case1 : case2) {
            rest[key] = val;
          }
        });
        return rest;
      };
    }
    module2.exports = helperCreatePickOmit;
  }
});

// node_modules/xe-utils/pick.js
var require_pick = __commonJS({
  "node_modules/xe-utils/pick.js"(exports2, module2) {
    var helperCreatePickOmit = require_helperCreatePickOmit();
    var pick = helperCreatePickOmit(1, 0);
    module2.exports = pick;
  }
});

// node_modules/xe-utils/omit.js
var require_omit = __commonJS({
  "node_modules/xe-utils/omit.js"(exports2, module2) {
    var helperCreatePickOmit = require_helperCreatePickOmit();
    var omit = helperCreatePickOmit(0, 1);
    module2.exports = omit;
  }
});

// node_modules/xe-utils/first.js
var require_first = __commonJS({
  "node_modules/xe-utils/first.js"(exports2, module2) {
    var values = require_values();
    function first(obj) {
      return values(obj)[0];
    }
    module2.exports = first;
  }
});

// node_modules/xe-utils/last.js
var require_last = __commonJS({
  "node_modules/xe-utils/last.js"(exports2, module2) {
    var values = require_values();
    function last(obj) {
      var list = values(obj);
      return list[list.length - 1];
    }
    module2.exports = last;
  }
});

// node_modules/xe-utils/has.js
var require_has = __commonJS({
  "node_modules/xe-utils/has.js"(exports2, module2) {
    var staticHGKeyRE = require_staticHGKeyRE();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    function has(obj, property) {
      if (obj) {
        if (hasOwnProp(obj, property)) {
          return true;
        } else {
          var prop, arrIndex, objProp, matchs, rest, isHas;
          var props = helperGetHGSKeys(property);
          var index2 = 0;
          var len = props.length;
          for (rest = obj; index2 < len; index2++) {
            isHas = false;
            prop = props[index2];
            matchs = prop ? prop.match(staticHGKeyRE) : "";
            if (matchs) {
              arrIndex = matchs[1];
              objProp = matchs[2];
              if (arrIndex) {
                if (rest[arrIndex]) {
                  if (hasOwnProp(rest[arrIndex], objProp)) {
                    isHas = true;
                    rest = rest[arrIndex][objProp];
                  }
                }
              } else {
                if (hasOwnProp(rest, objProp)) {
                  isHas = true;
                  rest = rest[objProp];
                }
              }
            } else {
              if (hasOwnProp(rest, prop)) {
                isHas = true;
                rest = rest[prop];
              }
            }
            if (isHas) {
              if (index2 === len - 1) {
                return true;
              }
            } else {
              break;
            }
          }
        }
      }
      return false;
    }
    module2.exports = has;
  }
});

// node_modules/xe-utils/set.js
var require_set = __commonJS({
  "node_modules/xe-utils/set.js"(exports2, module2) {
    var staticParseInt = require_staticParseInt();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    var sKeyRE = /(.+)?\[(\d+)\]$/;
    function setDeepProps(obj, key, isEnd, nextKey, value) {
      if (obj[key]) {
        if (isEnd) {
          obj[key] = value;
        }
      } else {
        var index2;
        var rest;
        var currMatchs = key ? key.match(sKeyRE) : null;
        if (isEnd) {
          rest = value;
        } else {
          var nextMatchs = nextKey ? nextKey.match(sKeyRE) : null;
          if (nextMatchs && !nextMatchs[1]) {
            rest = new Array(staticParseInt(nextMatchs[2]) + 1);
          } else {
            rest = {};
          }
        }
        if (currMatchs) {
          if (currMatchs[1]) {
            index2 = staticParseInt(currMatchs[2]);
            if (obj[currMatchs[1]]) {
              if (isEnd) {
                obj[currMatchs[1]][index2] = rest;
              } else {
                if (obj[currMatchs[1]][index2]) {
                  rest = obj[currMatchs[1]][index2];
                } else {
                  obj[currMatchs[1]][index2] = rest;
                }
              }
            } else {
              obj[currMatchs[1]] = new Array(index2 + 1);
              obj[currMatchs[1]][index2] = rest;
            }
          } else {
            obj[currMatchs[2]] = rest;
          }
        } else {
          obj[key] = rest;
        }
        return rest;
      }
      return obj[key];
    }
    function set(obj, property, value) {
      if (obj) {
        if ((obj[property] || hasOwnProp(obj, property)) && !isPrototypePolluted(property)) {
          obj[property] = value;
        } else {
          var rest = obj;
          var props = helperGetHGSKeys(property);
          var len = props.length;
          for (var index2 = 0; index2 < len; index2++) {
            if (isPrototypePolluted(props[index2])) {
              continue;
            }
            var isEnd = index2 === len - 1;
            rest = setDeepProps(rest, props[index2], isEnd, isEnd ? null : props[index2 + 1], value);
          }
        }
      }
      return obj;
    }
    function isPrototypePolluted(key) {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    }
    module2.exports = set;
  }
});

// node_modules/xe-utils/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/xe-utils/groupBy.js"(exports2, module2) {
    var isEmpty = require_isEmpty();
    var isObject3 = require_isObject();
    var isFunction2 = require_isFunction();
    var property = require_property();
    var each = require_each();
    function createiterateEmpty(iterate) {
      return function() {
        return isEmpty(iterate);
      };
    }
    function groupBy(obj, iterate, context) {
      var groupKey;
      var result = {};
      if (obj) {
        if (iterate && isObject3(iterate)) {
          iterate = createiterateEmpty(iterate);
        } else if (!isFunction2(iterate)) {
          iterate = property(iterate);
        }
        each(obj, function(val, key) {
          groupKey = iterate ? iterate.call(context, val, key, obj) : val;
          if (result[groupKey]) {
            result[groupKey].push(val);
          } else {
            result[groupKey] = [val];
          }
        });
      }
      return result;
    }
    module2.exports = groupBy;
  }
});

// node_modules/xe-utils/countBy.js
var require_countBy = __commonJS({
  "node_modules/xe-utils/countBy.js"(exports2, module2) {
    var groupBy = require_groupBy();
    var objectEach = require_objectEach();
    function countBy(obj, iterate, context) {
      var result = groupBy(obj, iterate, context || this);
      objectEach(result, function(item, key) {
        result[key] = item.length;
      });
      return result;
    }
    module2.exports = countBy;
  }
});

// node_modules/xe-utils/range.js
var require_range = __commonJS({
  "node_modules/xe-utils/range.js"(exports2, module2) {
    function range(start, stop, step) {
      var index2, len;
      var result = [];
      var args = arguments;
      if (args.length < 2) {
        stop = args[0];
        start = 0;
      }
      index2 = start >> 0;
      len = stop >> 0;
      if (index2 < stop) {
        step = step >> 0 || 1;
        for (; index2 < len; index2 += step) {
          result.push(index2);
        }
      }
      return result;
    }
    module2.exports = range;
  }
});

// node_modules/xe-utils/destructuring.js
var require_destructuring = __commonJS({
  "node_modules/xe-utils/destructuring.js"(exports2, module2) {
    var keys = require_keys();
    var slice = require_slice();
    var includes = require_includes();
    var arrayEach = require_arrayEach();
    var assign3 = require_assign();
    function destructuring(destination, sources) {
      if (destination && sources) {
        var rest = assign3.apply(this, [{}].concat(slice(arguments, 1)));
        var restKeys = keys(rest);
        arrayEach(keys(destination), function(key) {
          if (includes(restKeys, key)) {
            destination[key] = rest[key];
          }
        });
      }
      return destination;
    }
    module2.exports = destructuring;
  }
});

// node_modules/xe-utils/min.js
var require_min = __commonJS({
  "node_modules/xe-utils/min.js"(exports2, module2) {
    var helperCreateMinMax = require_helperCreateMinMax();
    var min = helperCreateMinMax(function(rest, itemVal) {
      return rest > itemVal;
    });
    module2.exports = min;
  }
});

// node_modules/xe-utils/helperNumberDecimal.js
var require_helperNumberDecimal = __commonJS({
  "node_modules/xe-utils/helperNumberDecimal.js"(exports2, module2) {
    function helperNumberDecimal(numStr) {
      return (numStr.split(".")[1] || "").length;
    }
    module2.exports = helperNumberDecimal;
  }
});

// node_modules/xe-utils/helperStringRepeat.js
var require_helperStringRepeat = __commonJS({
  "node_modules/xe-utils/helperStringRepeat.js"(exports2, module2) {
    var staticParseInt = require_staticParseInt();
    function helperStringRepeat(str, count) {
      if (str.repeat) {
        return str.repeat(count);
      }
      var list = isNaN(count) ? [] : new Array(staticParseInt(count));
      return list.join(str) + (list.length > 0 ? str : "");
    }
    module2.exports = helperStringRepeat;
  }
});

// node_modules/xe-utils/helperNumberOffsetPoint.js
var require_helperNumberOffsetPoint = __commonJS({
  "node_modules/xe-utils/helperNumberOffsetPoint.js"(exports2, module2) {
    function helperNumberOffsetPoint(str, offsetIndex) {
      return str.substring(0, offsetIndex) + "." + str.substring(offsetIndex, str.length);
    }
    module2.exports = helperNumberOffsetPoint;
  }
});

// node_modules/xe-utils/toNumberString.js
var require_toNumberString = __commonJS({
  "node_modules/xe-utils/toNumberString.js"(exports2, module2) {
    var helperStringRepeat = require_helperStringRepeat();
    var helperNumberOffsetPoint = require_helperNumberOffsetPoint();
    function toNumberString(num) {
      var rest = "" + num;
      var scienceMatchs = rest.match(/^([-+]?)((\d+)|((\d+)?[.](\d+)?))e([-+]{1})([0-9]+)$/);
      if (scienceMatchs) {
        var isNegative = num < 0;
        var absFlag = isNegative ? "-" : "";
        var intNumStr = scienceMatchs[3] || "";
        var dIntNumStr = scienceMatchs[5] || "";
        var dFloatNumStr = scienceMatchs[6] || "";
        var sciencFlag = scienceMatchs[7];
        var scienceNumStr = scienceMatchs[8];
        var floatOffsetIndex = scienceNumStr - dFloatNumStr.length;
        var intOffsetIndex = scienceNumStr - intNumStr.length;
        var dIntOffsetIndex = scienceNumStr - dIntNumStr.length;
        if (sciencFlag === "+") {
          if (intNumStr) {
            return absFlag + intNumStr + helperStringRepeat("0", scienceNumStr);
          }
          if (floatOffsetIndex > 0) {
            return absFlag + dIntNumStr + dFloatNumStr + helperStringRepeat("0", floatOffsetIndex);
          }
          return absFlag + dIntNumStr + helperNumberOffsetPoint(dFloatNumStr, scienceNumStr);
        }
        if (intNumStr) {
          if (intOffsetIndex > 0) {
            return absFlag + "0." + helperStringRepeat("0", Math.abs(intOffsetIndex)) + intNumStr;
          }
          return absFlag + helperNumberOffsetPoint(intNumStr, intOffsetIndex);
        }
        if (dIntOffsetIndex > 0) {
          return absFlag + "0." + helperStringRepeat("0", Math.abs(dIntOffsetIndex)) + dIntNumStr + dFloatNumStr;
        }
        return absFlag + helperNumberOffsetPoint(dIntNumStr, dIntOffsetIndex) + dFloatNumStr;
      }
      return rest;
    }
    module2.exports = toNumberString;
  }
});

// node_modules/xe-utils/helperMultiply.js
var require_helperMultiply = __commonJS({
  "node_modules/xe-utils/helperMultiply.js"(exports2, module2) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    function helperMultiply(multiplier, multiplicand) {
      var str1 = toNumberString(multiplier);
      var str2 = toNumberString(multiplicand);
      return parseInt(str1.replace(".", "")) * parseInt(str2.replace(".", "")) / Math.pow(10, helperNumberDecimal(str1) + helperNumberDecimal(str2));
    }
    module2.exports = helperMultiply;
  }
});

// node_modules/xe-utils/helperCreateMathNumber.js
var require_helperCreateMathNumber = __commonJS({
  "node_modules/xe-utils/helperCreateMathNumber.js"(exports2, module2) {
    var helperMultiply = require_helperMultiply();
    var toNumber = require_toNumber();
    var toNumberString = require_toNumberString();
    function helperCreateMathNumber(name) {
      return function(num, digits) {
        var numRest = toNumber(num);
        var rest = numRest;
        if (numRest) {
          digits = digits >> 0;
          var numStr = toNumberString(numRest);
          var nums = numStr.split(".");
          var intStr = nums[0];
          var floatStr = nums[1] || "";
          var fStr = floatStr.substring(0, digits + 1);
          var subRest = intStr + (fStr ? "." + fStr : "");
          if (digits >= floatStr.length) {
            return toNumber(subRest);
          }
          subRest = numRest;
          if (digits > 0) {
            var ratio = Math.pow(10, digits);
            rest = Math[name](helperMultiply(subRest, ratio)) / ratio;
          } else {
            rest = Math[name](subRest);
          }
        }
        return rest;
      };
    }
    module2.exports = helperCreateMathNumber;
  }
});

// node_modules/xe-utils/round.js
var require_round = __commonJS({
  "node_modules/xe-utils/round.js"(exports2, module2) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var round = helperCreateMathNumber("round");
    module2.exports = round;
  }
});

// node_modules/xe-utils/ceil.js
var require_ceil = __commonJS({
  "node_modules/xe-utils/ceil.js"(exports2, module2) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var ceil = helperCreateMathNumber("ceil");
    module2.exports = ceil;
  }
});

// node_modules/xe-utils/floor.js
var require_floor = __commonJS({
  "node_modules/xe-utils/floor.js"(exports2, module2) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var floor = helperCreateMathNumber("floor");
    module2.exports = floor;
  }
});

// node_modules/xe-utils/toValueString.js
var require_toValueString = __commonJS({
  "node_modules/xe-utils/toValueString.js"(exports2, module2) {
    var eqNull = require_eqNull();
    var isNumber2 = require_isNumber();
    var toNumberString = require_toNumberString();
    function toValueString(obj) {
      if (isNumber2(obj)) {
        return toNumberString(obj);
      }
      return "" + (eqNull(obj) ? "" : obj);
    }
    module2.exports = toValueString;
  }
});

// node_modules/xe-utils/toFixed.js
var require_toFixed = __commonJS({
  "node_modules/xe-utils/toFixed.js"(exports2, module2) {
    var round = require_round();
    var toValueString = require_toValueString();
    var helperStringRepeat = require_helperStringRepeat();
    var helperNumberOffsetPoint = require_helperNumberOffsetPoint();
    function toFixed(num, digits) {
      digits = digits >> 0;
      var str = toValueString(round(num, digits));
      var nums = str.split(".");
      var intStr = nums[0];
      var floatStr = nums[1] || "";
      var digitOffsetIndex = digits - floatStr.length;
      if (digits) {
        if (digitOffsetIndex > 0) {
          return intStr + "." + floatStr + helperStringRepeat("0", digitOffsetIndex);
        }
        return intStr + helperNumberOffsetPoint(floatStr, Math.abs(digitOffsetIndex));
      }
      return intStr;
    }
    module2.exports = toFixed;
  }
});

// node_modules/xe-utils/commafy.js
var require_commafy = __commonJS({
  "node_modules/xe-utils/commafy.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var round = require_round();
    var ceil = require_ceil();
    var floor = require_floor();
    var isNumber2 = require_isNumber();
    var toValueString = require_toValueString();
    var toFixed = require_toFixed();
    var toNumberString = require_toNumberString();
    var assign3 = require_assign();
    function commafy(num, options) {
      var opts = assign3({}, setupDefaults.commafyOptions, options);
      var optDigits = opts.digits;
      var isNum = isNumber2(num);
      var rest, result, isNegative, intStr, floatStr;
      if (isNum) {
        rest = (opts.ceil ? ceil : opts.floor ? floor : round)(num, optDigits);
        result = toNumberString(optDigits ? toFixed(rest, optDigits) : rest).split(".");
        intStr = result[0];
        floatStr = result[1];
        isNegative = intStr && rest < 0;
        if (isNegative) {
          intStr = intStr.substring(1, intStr.length);
        }
      } else {
        rest = toValueString(num).replace(/,/g, "");
        result = rest ? [rest] : [];
        intStr = result[0];
      }
      if (result.length) {
        return (isNegative ? "-" : "") + intStr.replace(new RegExp("(?=(?!(\\b))(.{" + (opts.spaceNumber || 3) + "})+$)", "g"), opts.separator || ",") + (floatStr ? "." + floatStr : "");
      }
      return rest;
    }
    module2.exports = commafy;
  }
});

// node_modules/xe-utils/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/xe-utils/toInteger.js"(exports2, module2) {
    var staticParseInt = require_staticParseInt();
    var helperCreateToNumber = require_helperCreateToNumber();
    var toInteger = helperCreateToNumber(staticParseInt);
    module2.exports = toInteger;
  }
});

// node_modules/xe-utils/multiply.js
var require_multiply = __commonJS({
  "node_modules/xe-utils/multiply.js"(exports2, module2) {
    var helperMultiply = require_helperMultiply();
    var toNumber = require_toNumber();
    function multiply(num1, num2) {
      var multiplier = toNumber(num1);
      var multiplicand = toNumber(num2);
      return helperMultiply(multiplier, multiplicand);
    }
    module2.exports = multiply;
  }
});

// node_modules/xe-utils/helperNumberAdd.js
var require_helperNumberAdd = __commonJS({
  "node_modules/xe-utils/helperNumberAdd.js"(exports2, module2) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var multiply = require_multiply();
    function helperNumberAdd(addend, augend) {
      var str1 = toNumberString(addend);
      var str2 = toNumberString(augend);
      var ratio = Math.pow(10, Math.max(helperNumberDecimal(str1), helperNumberDecimal(str2)));
      return (multiply(addend, ratio) + multiply(augend, ratio)) / ratio;
    }
    module2.exports = helperNumberAdd;
  }
});

// node_modules/xe-utils/add.js
var require_add = __commonJS({
  "node_modules/xe-utils/add.js"(exports2, module2) {
    var helperNumberAdd = require_helperNumberAdd();
    var toNumber = require_toNumber();
    function add(num1, num2) {
      return helperNumberAdd(toNumber(num1), toNumber(num2));
    }
    module2.exports = add;
  }
});

// node_modules/xe-utils/subtract.js
var require_subtract = __commonJS({
  "node_modules/xe-utils/subtract.js"(exports2, module2) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var toNumber = require_toNumber();
    var toFixed = require_toFixed();
    function subtract(num1, num2) {
      var subtrahend = toNumber(num1);
      var minuend = toNumber(num2);
      var str1 = toNumberString(subtrahend);
      var str2 = toNumberString(minuend);
      var digit1 = helperNumberDecimal(str1);
      var digit2 = helperNumberDecimal(str2);
      var ratio = Math.pow(10, Math.max(digit1, digit2));
      var precision = digit1 >= digit2 ? digit1 : digit2;
      return parseFloat(toFixed((subtrahend * ratio - minuend * ratio) / ratio, precision));
    }
    module2.exports = subtract;
  }
});

// node_modules/xe-utils/helperNumberDivide.js
var require_helperNumberDivide = __commonJS({
  "node_modules/xe-utils/helperNumberDivide.js"(exports2, module2) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var multiply = require_multiply();
    function helperNumberDivide(divisor, dividend) {
      var str1 = toNumberString(divisor);
      var str2 = toNumberString(dividend);
      var divisorDecimal = helperNumberDecimal(str1);
      var dividendDecimal = helperNumberDecimal(str2);
      var powY = dividendDecimal - divisorDecimal;
      var isMinus = powY < 0;
      var multiplicand = Math.pow(10, isMinus ? Math.abs(powY) : powY);
      return multiply(str1.replace(".", "") / str2.replace(".", ""), isMinus ? 1 / multiplicand : multiplicand);
    }
    module2.exports = helperNumberDivide;
  }
});

// node_modules/xe-utils/divide.js
var require_divide = __commonJS({
  "node_modules/xe-utils/divide.js"(exports2, module2) {
    var helperNumberDivide = require_helperNumberDivide();
    var toNumber = require_toNumber();
    function divide(num1, num2) {
      return helperNumberDivide(toNumber(num1), toNumber(num2));
    }
    module2.exports = divide;
  }
});

// node_modules/xe-utils/sum.js
var require_sum = __commonJS({
  "node_modules/xe-utils/sum.js"(exports2, module2) {
    var helperNumberAdd = require_helperNumberAdd();
    var isFunction2 = require_isFunction();
    var isArray2 = require_isArray();
    var each = require_each();
    var get = require_get();
    function sum(array, iterate, context) {
      var result = 0;
      each(array && array.length > 2 && isArray2(array) ? array.sort() : array, iterate ? isFunction2(iterate) ? function() {
        result = helperNumberAdd(result, iterate.apply(context, arguments));
      } : function(val) {
        result = helperNumberAdd(result, get(val, iterate));
      } : function(val) {
        result = helperNumberAdd(result, val);
      });
      return result;
    }
    module2.exports = sum;
  }
});

// node_modules/xe-utils/mean.js
var require_mean = __commonJS({
  "node_modules/xe-utils/mean.js"(exports2, module2) {
    var helperNumberDivide = require_helperNumberDivide();
    var getSize = require_getSize();
    var sum = require_sum();
    function mean(array, iterate, context) {
      return helperNumberDivide(sum(array, iterate, context), getSize(array));
    }
    module2.exports = mean;
  }
});

// node_modules/xe-utils/staticStrFirst.js
var require_staticStrFirst = __commonJS({
  "node_modules/xe-utils/staticStrFirst.js"(exports2, module2) {
    var staticStrFirst = "first";
    module2.exports = staticStrFirst;
  }
});

// node_modules/xe-utils/staticStrLast.js
var require_staticStrLast = __commonJS({
  "node_modules/xe-utils/staticStrLast.js"(exports2, module2) {
    var staticStrLast = "last";
    module2.exports = staticStrLast;
  }
});

// node_modules/xe-utils/helperGetDateFullYear.js
var require_helperGetDateFullYear = __commonJS({
  "node_modules/xe-utils/helperGetDateFullYear.js"(exports2, module2) {
    function helperGetDateFullYear(date) {
      return date.getFullYear();
    }
    module2.exports = helperGetDateFullYear;
  }
});

// node_modules/xe-utils/staticDayTime.js
var require_staticDayTime = __commonJS({
  "node_modules/xe-utils/staticDayTime.js"(exports2, module2) {
    var staticDayTime = 864e5;
    module2.exports = staticDayTime;
  }
});

// node_modules/xe-utils/helperGetDateMonth.js
var require_helperGetDateMonth = __commonJS({
  "node_modules/xe-utils/helperGetDateMonth.js"(exports2, module2) {
    function helperGetDateMonth(date) {
      return date.getMonth();
    }
    module2.exports = helperGetDateMonth;
  }
});

// node_modules/xe-utils/isValidDate.js
var require_isValidDate = __commonJS({
  "node_modules/xe-utils/isValidDate.js"(exports2, module2) {
    var isDate2 = require_isDate();
    var helperGetDateTime = require_helperGetDateTime();
    function isValidDate(val) {
      return isDate2(val) && !isNaN(helperGetDateTime(val));
    }
    module2.exports = isValidDate;
  }
});

// node_modules/xe-utils/getWhatMonth.js
var require_getWhatMonth = __commonJS({
  "node_modules/xe-utils/getWhatMonth.js"(exports2, module2) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var staticDayTime = require_staticDayTime();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateTime = require_helperGetDateTime();
    var helperGetDateMonth = require_helperGetDateMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isNumber2 = require_isNumber();
    function getWhatMonth(date, offsetMonth, offsetDay) {
      var monthNum = offsetMonth && !isNaN(offsetMonth) ? offsetMonth : 0;
      date = toStringDate(date);
      if (isValidDate(date)) {
        if (offsetDay === staticStrFirst) {
          return new Date(helperGetDateFullYear(date), helperGetDateMonth(date) + monthNum, 1);
        } else if (offsetDay === staticStrLast) {
          return new Date(helperGetDateTime(getWhatMonth(date, monthNum + 1, staticStrFirst)) - 1);
        } else if (isNumber2(offsetDay)) {
          date.setDate(offsetDay);
        }
        if (monthNum) {
          var currDate = date.getDate();
          date.setMonth(helperGetDateMonth(date) + monthNum);
          if (currDate !== date.getDate()) {
            date.setDate(1);
            return new Date(helperGetDateTime(date) - staticDayTime);
          }
        }
      }
      return date;
    }
    module2.exports = getWhatMonth;
  }
});

// node_modules/xe-utils/getWhatYear.js
var require_getWhatYear = __commonJS({
  "node_modules/xe-utils/getWhatYear.js"(exports2, module2) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getWhatYear(date, offset, month) {
      var number2;
      date = toStringDate(date);
      if (isValidDate(date)) {
        if (offset) {
          number2 = offset && !isNaN(offset) ? offset : 0;
          date.setFullYear(helperGetDateFullYear(date) + number2);
        }
        if (month || !isNaN(month)) {
          if (month === staticStrFirst) {
            return new Date(helperGetDateFullYear(date), 0, 1);
          } else if (month === staticStrLast) {
            date.setMonth(11);
            return getWhatMonth(date, 0, staticStrLast);
          } else {
            date.setMonth(month);
          }
        }
      }
      return date;
    }
    module2.exports = getWhatYear;
  }
});

// node_modules/xe-utils/getWhatQuarter.js
var require_getWhatQuarter = __commonJS({
  "node_modules/xe-utils/getWhatQuarter.js"(exports2, module2) {
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getQuarterNumber(date) {
      var month = date.getMonth();
      if (month < 3) {
        return 1;
      } else if (month < 6) {
        return 2;
      } else if (month < 9) {
        return 3;
      }
      return 4;
    }
    function getWhatQuarter(date, offset, day) {
      var currMonth, monthOffset = offset && !isNaN(offset) ? offset * 3 : 0;
      date = toStringDate(date);
      if (isValidDate(date)) {
        currMonth = (getQuarterNumber(date) - 1) * 3;
        date.setMonth(currMonth);
        return getWhatMonth(date, monthOffset, day);
      }
      return date;
    }
    module2.exports = getWhatQuarter;
  }
});

// node_modules/xe-utils/getWhatDay.js
var require_getWhatDay = __commonJS({
  "node_modules/xe-utils/getWhatDay.js"(exports2, module2) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var staticParseInt = require_staticParseInt();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    var helperGetDateTime = require_helperGetDateTime();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getWhatDay(date, offset, mode) {
      date = toStringDate(date);
      if (isValidDate(date) && !isNaN(offset)) {
        date.setDate(date.getDate() + staticParseInt(offset));
        if (mode === staticStrFirst) {
          return new Date(helperGetDateFullYear(date), helperGetDateMonth(date), date.getDate());
        } else if (mode === staticStrLast) {
          return new Date(helperGetDateTime(getWhatDay(date, 1, staticStrFirst)) - 1);
        }
      }
      return date;
    }
    module2.exports = getWhatDay;
  }
});

// node_modules/xe-utils/helperStringUpperCase.js
var require_helperStringUpperCase = __commonJS({
  "node_modules/xe-utils/helperStringUpperCase.js"(exports2, module2) {
    function helperStringUpperCase(str) {
      return str.toUpperCase();
    }
    module2.exports = helperStringUpperCase;
  }
});

// node_modules/xe-utils/staticWeekTime.js
var require_staticWeekTime = __commonJS({
  "node_modules/xe-utils/staticWeekTime.js"(exports2, module2) {
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = staticDayTime * 7;
    module2.exports = staticWeekTime;
  }
});

// node_modules/xe-utils/getWhatWeek.js
var require_getWhatWeek = __commonJS({
  "node_modules/xe-utils/getWhatWeek.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = require_staticWeekTime();
    var helperGetDateTime = require_helperGetDateTime();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isNumber2 = require_isNumber();
    function getWhatWeek(date, offsetWeek, offsetDay, firstDay) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        var hasCustomDay = isNumber2(offsetDay);
        var hasStartDay = isNumber2(firstDay);
        var whatDayTime = helperGetDateTime(date);
        if (hasCustomDay || hasStartDay) {
          var viewStartDay = hasStartDay ? firstDay : setupDefaults.firstDayOfWeek;
          var currentDay = date.getDay();
          var customDay = hasCustomDay ? offsetDay : currentDay;
          if (currentDay !== customDay) {
            var offsetNum = 0;
            if (viewStartDay > currentDay) {
              offsetNum = -(7 - viewStartDay + currentDay);
            } else if (viewStartDay < currentDay) {
              offsetNum = viewStartDay - currentDay;
            }
            if (customDay > viewStartDay) {
              whatDayTime += ((customDay === 0 ? 7 : customDay) - viewStartDay + offsetNum) * staticDayTime;
            } else if (customDay < viewStartDay) {
              whatDayTime += (7 - viewStartDay + customDay + offsetNum) * staticDayTime;
            } else {
              whatDayTime += offsetNum * staticDayTime;
            }
          }
        }
        if (offsetWeek && !isNaN(offsetWeek)) {
          whatDayTime += offsetWeek * staticWeekTime;
        }
        return new Date(whatDayTime);
      }
      return date;
    }
    module2.exports = getWhatWeek;
  }
});

// node_modules/xe-utils/helperCreateGetDateWeek.js
var require_helperCreateGetDateWeek = __commonJS({
  "node_modules/xe-utils/helperCreateGetDateWeek.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var staticWeekTime = require_staticWeekTime();
    var isNumber2 = require_isNumber();
    var isValidDate = require_isValidDate();
    var getWhatWeek = require_getWhatWeek();
    var helperGetDateTime = require_helperGetDateTime();
    function helperCreateGetDateWeek(getStartDate) {
      return function(date, firstDay) {
        var viewStartDay = isNumber2(firstDay) ? firstDay : setupDefaults.firstDayOfWeek;
        var targetDate = getWhatWeek(date, 0, viewStartDay, viewStartDay);
        if (isValidDate(targetDate)) {
          var targetOffsetDate = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
          var targerStartDate = getStartDate(targetDate);
          var targetFirstDay = targerStartDate.getDay();
          if (targetFirstDay > viewStartDay) {
            targerStartDate.setDate(7 - targetFirstDay + viewStartDay + 1);
          }
          if (targetFirstDay < viewStartDay) {
            targerStartDate.setDate(viewStartDay - targetFirstDay + 1);
          }
          return Math.floor((helperGetDateTime(targetOffsetDate) - helperGetDateTime(targerStartDate)) / staticWeekTime + 1);
        }
        return NaN;
      };
    }
    module2.exports = helperCreateGetDateWeek;
  }
});

// node_modules/xe-utils/getYearWeek.js
var require_getYearWeek = __commonJS({
  "node_modules/xe-utils/getYearWeek.js"(exports2, module2) {
    var helperCreateGetDateWeek = require_helperCreateGetDateWeek();
    var getYearWeek = helperCreateGetDateWeek(function(targetDate) {
      return new Date(targetDate.getFullYear(), 0, 1);
    });
    module2.exports = getYearWeek;
  }
});

// node_modules/xe-utils/helperGetYMD.js
var require_helperGetYMD = __commonJS({
  "node_modules/xe-utils/helperGetYMD.js"(exports2, module2) {
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    function helperGetYMD(date) {
      return new Date(helperGetDateFullYear(date), helperGetDateMonth(date), date.getDate());
    }
    module2.exports = helperGetYMD;
  }
});

// node_modules/xe-utils/helperGetYMDTime.js
var require_helperGetYMDTime = __commonJS({
  "node_modules/xe-utils/helperGetYMDTime.js"(exports2, module2) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperGetYMD = require_helperGetYMD();
    function helperGetYMDTime(date) {
      return helperGetDateTime(helperGetYMD(date));
    }
    module2.exports = helperGetYMDTime;
  }
});

// node_modules/xe-utils/getYearDay.js
var require_getYearDay = __commonJS({
  "node_modules/xe-utils/getYearDay.js"(exports2, module2) {
    var staticDayTime = require_staticDayTime();
    var staticStrFirst = require_staticStrFirst();
    var helperGetYMDTime = require_helperGetYMDTime();
    var getWhatYear = require_getWhatYear();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getYearDay(date) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return Math.floor((helperGetYMDTime(date) - helperGetYMDTime(getWhatYear(date, 0, staticStrFirst))) / staticDayTime) + 1;
      }
      return NaN;
    }
    module2.exports = getYearDay;
  }
});

// node_modules/xe-utils/padStart.js
var require_padStart = __commonJS({
  "node_modules/xe-utils/padStart.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var isUndefined = require_isUndefined();
    var helperStringRepeat = require_helperStringRepeat();
    function padStart(str, targetLength, padString) {
      var rest = toValueString(str);
      targetLength = targetLength >> 0;
      padString = isUndefined(padString) ? " " : "" + padString;
      if (rest.padStart) {
        return rest.padStart(targetLength, padString);
      }
      if (targetLength > rest.length) {
        targetLength -= rest.length;
        if (targetLength > padString.length) {
          padString += helperStringRepeat(padString, targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + rest;
      }
      return rest;
    }
    module2.exports = padStart;
  }
});

// node_modules/xe-utils/toDateString.js
var require_toDateString = __commonJS({
  "node_modules/xe-utils/toDateString.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var helperStringUpperCase = require_helperStringUpperCase();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    var toStringDate = require_toStringDate();
    var getYearWeek = require_getYearWeek();
    var getYearDay = require_getYearDay();
    var assign3 = require_assign();
    var isValidDate = require_isValidDate();
    var isFunction2 = require_isFunction();
    var padStart = require_padStart();
    function handleCustomTemplate(date, formats6, match, value) {
      var format4 = formats6[match];
      if (format4) {
        if (isFunction2(format4)) {
          return format4(value, match, date);
        } else {
          return format4[value];
        }
      }
      return value;
    }
    var dateFormatRE = /\[([^\]]+)]|y{2,4}|M{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|Z{1,2}|W{1,2}|D{1,3}|[aAeEq]/g;
    function toDateString(date, format4, options) {
      if (date) {
        date = toStringDate(date);
        if (isValidDate(date)) {
          var result = format4 || setupDefaults.parseDateFormat || setupDefaults.formatString;
          var hours = date.getHours();
          var apm = hours < 12 ? "am" : "pm";
          var formats6 = assign3({}, setupDefaults.parseDateRules || setupDefaults.formatStringMatchs, options ? options.formats : null);
          var fy2 = function(match, length) {
            return ("" + helperGetDateFullYear(date)).substr(4 - length);
          };
          var fM = function(match, length) {
            return padStart(helperGetDateMonth(date) + 1, length, "0");
          };
          var fd2 = function(match, length) {
            return padStart(date.getDate(), length, "0");
          };
          var fH = function(match, length) {
            return padStart(hours, length, "0");
          };
          var fh2 = function(match, length) {
            return padStart(hours <= 12 ? hours : hours - 12, length, "0");
          };
          var fm = function(match, length) {
            return padStart(date.getMinutes(), length, "0");
          };
          var fs2 = function(match, length) {
            return padStart(date.getSeconds(), length, "0");
          };
          var fS = function(match, length) {
            return padStart(date.getMilliseconds(), length, "0");
          };
          var fZ = function(match, length) {
            var zoneHours = date.getTimezoneOffset() / 60 * -1;
            return handleCustomTemplate(date, formats6, match, (zoneHours >= 0 ? "+" : "-") + padStart(zoneHours, 2, "0") + (length === 1 ? ":" : "") + "00");
          };
          var fW = function(match, length) {
            return padStart(handleCustomTemplate(date, formats6, match, getYearWeek(date, (options ? options.firstDay : null) || setupDefaults.firstDayOfWeek)), length, "0");
          };
          var fD = function(match, length) {
            return padStart(handleCustomTemplate(date, formats6, match, getYearDay(date)), length, "0");
          };
          var parseDates = {
            yyyy: fy2,
            yy: fy2,
            MM: fM,
            M: fM,
            dd: fd2,
            d: fd2,
            HH: fH,
            H: fH,
            hh: fh2,
            h: fh2,
            mm: fm,
            m: fm,
            ss: fs2,
            s: fs2,
            SSS: fS,
            S: fS,
            ZZ: fZ,
            Z: fZ,
            WW: fW,
            W: fW,
            DDD: fD,
            D: fD,
            a: function(match) {
              return handleCustomTemplate(date, formats6, match, apm);
            },
            A: function(match) {
              return handleCustomTemplate(date, formats6, match, helperStringUpperCase(apm));
            },
            e: function(match) {
              return handleCustomTemplate(date, formats6, match, date.getDay());
            },
            E: function(match) {
              return handleCustomTemplate(date, formats6, match, date.getDay());
            },
            q: function(match) {
              return handleCustomTemplate(date, formats6, match, Math.floor((helperGetDateMonth(date) + 3) / 3));
            }
          };
          return result.replace(dateFormatRE, function(match, skip) {
            return skip || (parseDates[match] ? parseDates[match](match, match.length) : match);
          });
        }
        return "Invalid Date";
      }
      return "";
    }
    module2.exports = toDateString;
  }
});

// node_modules/xe-utils/now.js
var require_now = __commonJS({
  "node_modules/xe-utils/now.js"(exports2, module2) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperNewDate = require_helperNewDate();
    var now2 = Date.now || function() {
      return helperGetDateTime(helperNewDate());
    };
    module2.exports = now2;
  }
});

// node_modules/xe-utils/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/xe-utils/timestamp.js"(exports2, module2) {
    var helperGetDateTime = require_helperGetDateTime();
    var now2 = require_now();
    var toStringDate = require_toStringDate();
    var isDate2 = require_isDate();
    var timestamp = function(str, format4) {
      if (str) {
        var date = toStringDate(str, format4);
        return isDate2(date) ? helperGetDateTime(date) : date;
      }
      return now2();
    };
    module2.exports = timestamp;
  }
});

// node_modules/xe-utils/isDateSame.js
var require_isDateSame = __commonJS({
  "node_modules/xe-utils/isDateSame.js"(exports2, module2) {
    var toDateString = require_toDateString();
    function isDateSame(date1, date2, format4) {
      if (date1 && date2) {
        date1 = toDateString(date1, format4);
        return date1 !== "Invalid Date" && date1 === toDateString(date2, format4);
      }
      return false;
    }
    module2.exports = isDateSame;
  }
});

// node_modules/xe-utils/getMonthWeek.js
var require_getMonthWeek = __commonJS({
  "node_modules/xe-utils/getMonthWeek.js"(exports2, module2) {
    var helperCreateGetDateWeek = require_helperCreateGetDateWeek();
    var getMonthWeek = helperCreateGetDateWeek(function(targetDate) {
      return new Date(targetDate.getFullYear(), targetDate.getMonth(), 1);
    });
    module2.exports = getMonthWeek;
  }
});

// node_modules/xe-utils/getDayOfYear.js
var require_getDayOfYear = __commonJS({
  "node_modules/xe-utils/getDayOfYear.js"(exports2, module2) {
    var getWhatYear = require_getWhatYear();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isLeapYear = require_isLeapYear();
    function getDayOfYear(date, year) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return isLeapYear(getWhatYear(date, year)) ? 366 : 365;
      }
      return NaN;
    }
    module2.exports = getDayOfYear;
  }
});

// node_modules/xe-utils/getDayOfMonth.js
var require_getDayOfMonth = __commonJS({
  "node_modules/xe-utils/getDayOfMonth.js"(exports2, module2) {
    var staticDayTime = require_staticDayTime();
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var helperGetDateTime = require_helperGetDateTime();
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getDayOfMonth(date, month) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return Math.floor((helperGetDateTime(getWhatMonth(date, month, staticStrLast)) - helperGetDateTime(getWhatMonth(date, month, staticStrFirst))) / staticDayTime) + 1;
      }
      return NaN;
    }
    module2.exports = getDayOfMonth;
  }
});

// node_modules/xe-utils/getDateDiff.js
var require_getDateDiff = __commonJS({
  "node_modules/xe-utils/getDateDiff.js"(exports2, module2) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperNewDate = require_helperNewDate();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var dateDiffRules = [
      ["yyyy", 31536e6],
      ["MM", 2592e6],
      ["dd", 864e5],
      ["HH", 36e5],
      ["mm", 6e4],
      ["ss", 1e3],
      ["S", 0]
    ];
    function getDateDiff(startDate, endDate) {
      var startTime, endTime, item, diffTime, len, index2;
      var result = { done: false, time: 0 };
      startDate = toStringDate(startDate);
      endDate = endDate ? toStringDate(endDate) : helperNewDate();
      if (isValidDate(startDate) && isValidDate(endDate)) {
        startTime = helperGetDateTime(startDate);
        endTime = helperGetDateTime(endDate);
        if (startTime < endTime) {
          diffTime = result.time = endTime - startTime;
          result.done = true;
          for (index2 = 0, len = dateDiffRules.length; index2 < len; index2++) {
            item = dateDiffRules[index2];
            if (diffTime >= item[1]) {
              if (index2 === len - 1) {
                result[item[0]] = diffTime || 0;
              } else {
                result[item[0]] = Math.floor(diffTime / item[1]);
                diffTime -= result[item[0]] * item[1];
              }
            } else {
              result[item[0]] = 0;
            }
          }
        }
      }
      return result;
    }
    module2.exports = getDateDiff;
  }
});

// node_modules/xe-utils/padEnd.js
var require_padEnd = __commonJS({
  "node_modules/xe-utils/padEnd.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var isUndefined = require_isUndefined();
    var helperStringRepeat = require_helperStringRepeat();
    function padEnd(str, targetLength, padString) {
      var rest = toValueString(str);
      targetLength = targetLength >> 0;
      padString = isUndefined(padString) ? " " : "" + padString;
      if (rest.padEnd) {
        return rest.padEnd(targetLength, padString);
      }
      if (targetLength > rest.length) {
        targetLength -= rest.length;
        if (targetLength > padString.length) {
          padString += helperStringRepeat(padString, targetLength / padString.length);
        }
        return rest + padString.slice(0, targetLength);
      }
      return rest;
    }
    module2.exports = padEnd;
  }
});

// node_modules/xe-utils/repeat.js
var require_repeat = __commonJS({
  "node_modules/xe-utils/repeat.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var helperStringRepeat = require_helperStringRepeat();
    function repeat(str, count) {
      return helperStringRepeat(toValueString(str), count);
    }
    module2.exports = repeat;
  }
});

// node_modules/xe-utils/trimRight.js
var require_trimRight = __commonJS({
  "node_modules/xe-utils/trimRight.js"(exports2, module2) {
    var toValueString = require_toValueString();
    function trimRight(str) {
      return str && str.trimRight ? str.trimRight() : toValueString(str).replace(/[\s\uFEFF\xA0]+$/g, "");
    }
    module2.exports = trimRight;
  }
});

// node_modules/xe-utils/trimLeft.js
var require_trimLeft = __commonJS({
  "node_modules/xe-utils/trimLeft.js"(exports2, module2) {
    var toValueString = require_toValueString();
    function trimLeft(str) {
      return str && str.trimLeft ? str.trimLeft() : toValueString(str).replace(/^[\s\uFEFF\xA0]+/g, "");
    }
    module2.exports = trimLeft;
  }
});

// node_modules/xe-utils/trim.js
var require_trim = __commonJS({
  "node_modules/xe-utils/trim.js"(exports2, module2) {
    var trimRight = require_trimRight();
    var trimLeft = require_trimLeft();
    function trim(str) {
      return str && str.trim ? str.trim() : trimRight(trimLeft(str));
    }
    module2.exports = trim;
  }
});

// node_modules/xe-utils/staticEscapeMap.js
var require_staticEscapeMap = __commonJS({
  "node_modules/xe-utils/staticEscapeMap.js"(exports2, module2) {
    var staticEscapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
    module2.exports = staticEscapeMap;
  }
});

// node_modules/xe-utils/helperFormatEscaper.js
var require_helperFormatEscaper = __commonJS({
  "node_modules/xe-utils/helperFormatEscaper.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var keys = require_keys();
    function helperFormatEscaper(dataMap) {
      var replaceRegexp = new RegExp("(?:" + keys(dataMap).join("|") + ")", "g");
      return function(str) {
        return toValueString(str).replace(replaceRegexp, function(match) {
          return dataMap[match];
        });
      };
    }
    module2.exports = helperFormatEscaper;
  }
});

// node_modules/xe-utils/escape.js
var require_escape = __commonJS({
  "node_modules/xe-utils/escape.js"(exports2, module2) {
    var staticEscapeMap = require_staticEscapeMap();
    var helperFormatEscaper = require_helperFormatEscaper();
    var escape2 = helperFormatEscaper(staticEscapeMap);
    module2.exports = escape2;
  }
});

// node_modules/xe-utils/unescape.js
var require_unescape = __commonJS({
  "node_modules/xe-utils/unescape.js"(exports2, module2) {
    var staticEscapeMap = require_staticEscapeMap();
    var helperFormatEscaper = require_helperFormatEscaper();
    var each = require_each();
    var unescapeMap = {};
    each(staticEscapeMap, function(item, key) {
      unescapeMap[staticEscapeMap[key]] = key;
    });
    var unescape = helperFormatEscaper(unescapeMap);
    module2.exports = unescape;
  }
});

// node_modules/xe-utils/helperStringSubstring.js
var require_helperStringSubstring = __commonJS({
  "node_modules/xe-utils/helperStringSubstring.js"(exports2, module2) {
    function helperStringSubstring(str, start, end) {
      return str.substring(start, end);
    }
    module2.exports = helperStringSubstring;
  }
});

// node_modules/xe-utils/helperStringLowerCase.js
var require_helperStringLowerCase = __commonJS({
  "node_modules/xe-utils/helperStringLowerCase.js"(exports2, module2) {
    function helperStringLowerCase(str) {
      return str.toLowerCase();
    }
    module2.exports = helperStringLowerCase;
  }
});

// node_modules/xe-utils/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/xe-utils/camelCase.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var helperStringSubstring = require_helperStringSubstring();
    var helperStringUpperCase = require_helperStringUpperCase();
    var helperStringLowerCase = require_helperStringLowerCase();
    var camelCacheMaps = {};
    function camelCase(str) {
      str = toValueString(str);
      if (camelCacheMaps[str]) {
        return camelCacheMaps[str];
      }
      var strLen = str.length;
      var rest = str.replace(/([-]+)/g, function(text, flag, index2) {
        return index2 && index2 + flag.length < strLen ? "-" : "";
      });
      strLen = rest.length;
      rest = rest.replace(/([A-Z]+)/g, function(text, upper, index2) {
        var upperLen = upper.length;
        upper = helperStringLowerCase(upper);
        if (index2) {
          if (upperLen > 2 && index2 + upperLen < strLen) {
            return helperStringUpperCase(helperStringSubstring(upper, 0, 1)) + helperStringSubstring(upper, 1, upperLen - 1) + helperStringUpperCase(helperStringSubstring(upper, upperLen - 1, upperLen));
          }
          return helperStringUpperCase(helperStringSubstring(upper, 0, 1)) + helperStringSubstring(upper, 1, upperLen);
        } else {
          if (upperLen > 1 && index2 + upperLen < strLen) {
            return helperStringSubstring(upper, 0, upperLen - 1) + helperStringUpperCase(helperStringSubstring(upper, upperLen - 1, upperLen));
          }
        }
        return upper;
      }).replace(/(-[a-zA-Z])/g, function(text, upper) {
        return helperStringUpperCase(helperStringSubstring(upper, 1, upper.length));
      });
      camelCacheMaps[str] = rest;
      return rest;
    }
    module2.exports = camelCase;
  }
});

// node_modules/xe-utils/kebabCase.js
var require_kebabCase = __commonJS({
  "node_modules/xe-utils/kebabCase.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var helperStringSubstring = require_helperStringSubstring();
    var helperStringLowerCase = require_helperStringLowerCase();
    var kebabCacheMaps = {};
    function kebabCase(str) {
      str = toValueString(str);
      if (kebabCacheMaps[str]) {
        return kebabCacheMaps[str];
      }
      if (/^[A-Z]+$/.test(str)) {
        return helperStringLowerCase(str);
      }
      var rest = str.replace(/^([a-z])([A-Z]+)([a-z]+)$/, function(text, prevLower, upper, nextLower) {
        var upperLen = upper.length;
        if (upperLen > 1) {
          return prevLower + "-" + helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper, upperLen - 1, upperLen)) + nextLower;
        }
        return helperStringLowerCase(prevLower + "-" + upper + nextLower);
      }).replace(/^([A-Z]+)([a-z]+)?$/, function(text, upper, nextLower) {
        var upperLen = upper.length;
        return helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1) + "-" + helperStringSubstring(upper, upperLen - 1, upperLen) + (nextLower || ""));
      }).replace(/([a-z]?)([A-Z]+)([a-z]?)/g, function(text, prevLower, upper, nextLower, index2) {
        var upperLen = upper.length;
        if (upperLen > 1) {
          if (prevLower) {
            prevLower += "-";
          }
          if (nextLower) {
            return (prevLower || "") + helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper, upperLen - 1, upperLen)) + nextLower;
          }
        }
        return (prevLower || "") + (index2 ? "-" : "") + helperStringLowerCase(upper) + (nextLower || "");
      });
      rest = rest.replace(/([-]+)/g, function(text, flag, index2) {
        return index2 && index2 + flag.length < rest.length ? "-" : "";
      });
      kebabCacheMaps[str] = rest;
      return rest;
    }
    module2.exports = kebabCase;
  }
});

// node_modules/xe-utils/startsWith.js
var require_startsWith = __commonJS({
  "node_modules/xe-utils/startsWith.js"(exports2, module2) {
    var toValueString = require_toValueString();
    function startsWith(str, val, startIndex) {
      var rest = toValueString(str);
      return (arguments.length === 1 ? rest : rest.substring(startIndex)).indexOf(val) === 0;
    }
    module2.exports = startsWith;
  }
});

// node_modules/xe-utils/endsWith.js
var require_endsWith = __commonJS({
  "node_modules/xe-utils/endsWith.js"(exports2, module2) {
    var toValueString = require_toValueString();
    function endsWith(str, val, startIndex) {
      var rest = toValueString(str);
      var argsLen = arguments.length;
      return argsLen > 1 && (argsLen > 2 ? rest.substring(0, startIndex).indexOf(val) === startIndex - 1 : rest.indexOf(val) === rest.length - 1);
    }
    module2.exports = endsWith;
  }
});

// node_modules/xe-utils/template.js
var require_template = __commonJS({
  "node_modules/xe-utils/template.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var toValueString = require_toValueString();
    var trim = require_trim();
    var get = require_get();
    function template(str, args, options) {
      return toValueString(str).replace((options || setupDefaults).tmplRE || /\{{2}([.\w[\]\s]+)\}{2}/g, function(match, key) {
        return get(args, trim(key));
      });
    }
    module2.exports = template;
  }
});

// node_modules/xe-utils/toFormatString.js
var require_toFormatString = __commonJS({
  "node_modules/xe-utils/toFormatString.js"(exports2, module2) {
    var template = require_template();
    function toFormatString(str, obj) {
      return template(str, obj, { tmplRE: /\{([.\w[\]\s]+)\}/g });
    }
    module2.exports = toFormatString;
  }
});

// node_modules/xe-utils/noop.js
var require_noop = __commonJS({
  "node_modules/xe-utils/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// node_modules/xe-utils/bind.js
var require_bind = __commonJS({
  "node_modules/xe-utils/bind.js"(exports2, module2) {
    var slice = require_slice();
    function bind(callback, context) {
      var args = slice(arguments, 2);
      return function() {
        return callback.apply(context, slice(arguments).concat(args));
      };
    }
    module2.exports = bind;
  }
});

// node_modules/xe-utils/once.js
var require_once = __commonJS({
  "node_modules/xe-utils/once.js"(exports2, module2) {
    var slice = require_slice();
    function once(callback, context) {
      var done = false;
      var rest = null;
      var args = slice(arguments, 2);
      return function() {
        if (done) {
          return rest;
        }
        rest = callback.apply(context, slice(arguments).concat(args));
        done = true;
        return rest;
      };
    }
    module2.exports = once;
  }
});

// node_modules/xe-utils/after.js
var require_after = __commonJS({
  "node_modules/xe-utils/after.js"(exports2, module2) {
    var slice = require_slice();
    function after(count, callback, context) {
      var runCount = 0;
      var rests = [];
      return function() {
        var args = arguments;
        runCount++;
        if (runCount <= count) {
          rests.push(args[0]);
        }
        if (runCount >= count) {
          callback.apply(context, [rests].concat(slice(args)));
        }
      };
    }
    module2.exports = after;
  }
});

// node_modules/xe-utils/before.js
var require_before = __commonJS({
  "node_modules/xe-utils/before.js"(exports2, module2) {
    var slice = require_slice();
    function before(count, callback, context) {
      var runCount = 0;
      var rests = [];
      context = context || this;
      return function() {
        var args = arguments;
        runCount++;
        if (runCount < count) {
          rests.push(args[0]);
          callback.apply(context, [rests].concat(slice(args)));
        }
      };
    }
    module2.exports = before;
  }
});

// node_modules/xe-utils/throttle.js
var require_throttle = __commonJS({
  "node_modules/xe-utils/throttle.js"(exports2, module2) {
    function throttle2(callback, wait, options) {
      var args = null;
      var context = null;
      var opts = options || {};
      var runFlag = false;
      var timeout = null;
      var optLeading = "leading" in opts ? opts.leading : true;
      var optTrailing = "trailing" in opts ? opts.trailing : false;
      var gcFn = function() {
        args = null;
        context = null;
      };
      var runFn = function() {
        runFlag = true;
        callback.apply(context, args);
        timeout = setTimeout(endFn, wait);
        gcFn();
      };
      var endFn = function() {
        timeout = null;
        if (!runFlag && optTrailing === true) {
          runFn();
        }
      };
      var cancelFn = function() {
        var rest = timeout !== null;
        if (rest) {
          clearTimeout(timeout);
        }
        gcFn();
        timeout = null;
        runFlag = false;
        return rest;
      };
      var throttled = function() {
        args = arguments;
        context = this;
        runFlag = false;
        if (timeout === null) {
          if (optLeading === true) {
            runFn();
          } else if (optTrailing === true) {
            timeout = setTimeout(endFn, wait);
          }
        }
      };
      throttled.cancel = cancelFn;
      return throttled;
    }
    module2.exports = throttle2;
  }
});

// node_modules/xe-utils/debounce.js
var require_debounce = __commonJS({
  "node_modules/xe-utils/debounce.js"(exports2, module2) {
    function debounce(callback, wait, options) {
      var args = null;
      var context = null;
      var opts = options || {};
      var runFlag = false;
      var timeout = null;
      var isLeading = typeof options === "boolean";
      var optLeading = "leading" in opts ? opts.leading : isLeading;
      var optTrailing = "trailing" in opts ? opts.trailing : !isLeading;
      var gcFn = function() {
        args = null;
        context = null;
      };
      var runFn = function() {
        runFlag = true;
        callback.apply(context, args);
        gcFn();
      };
      var endFn = function() {
        if (optLeading === true) {
          timeout = null;
        }
        if (!runFlag && optTrailing === true) {
          runFn();
        }
      };
      var cancelFn = function() {
        var rest = timeout !== null;
        if (rest) {
          clearTimeout(timeout);
        }
        gcFn();
        timeout = null;
        runFlag = false;
        return rest;
      };
      var debounced = function() {
        runFlag = false;
        args = arguments;
        context = this;
        if (timeout === null) {
          if (optLeading === true) {
            runFn();
          }
        } else {
          clearTimeout(timeout);
        }
        timeout = setTimeout(endFn, wait);
      };
      debounced.cancel = cancelFn;
      return debounced;
    }
    module2.exports = debounce;
  }
});

// node_modules/xe-utils/delay.js
var require_delay = __commonJS({
  "node_modules/xe-utils/delay.js"(exports2, module2) {
    var slice = require_slice();
    function delay(callback, wait) {
      var args = slice(arguments, 2);
      var context = this;
      return setTimeout(function() {
        callback.apply(context, args);
      }, wait);
    }
    module2.exports = delay;
  }
});

// node_modules/xe-utils/staticDecodeURIComponent.js
var require_staticDecodeURIComponent = __commonJS({
  "node_modules/xe-utils/staticDecodeURIComponent.js"(exports2, module2) {
    var staticDecodeURIComponent = decodeURIComponent;
    module2.exports = staticDecodeURIComponent;
  }
});

// node_modules/xe-utils/unserialize.js
var require_unserialize = __commonJS({
  "node_modules/xe-utils/unserialize.js"(exports2, module2) {
    var staticDecodeURIComponent = require_staticDecodeURIComponent();
    var arrayEach = require_arrayEach();
    var isString3 = require_isString();
    function unserialize(str) {
      var items;
      var result = {};
      if (str && isString3(str)) {
        arrayEach(str.split("&"), function(param) {
          items = param.split("=");
          result[staticDecodeURIComponent(items[0])] = staticDecodeURIComponent(items[1] || "");
        });
      }
      return result;
    }
    module2.exports = unserialize;
  }
});

// node_modules/xe-utils/staticEncodeURIComponent.js
var require_staticEncodeURIComponent = __commonJS({
  "node_modules/xe-utils/staticEncodeURIComponent.js"(exports2, module2) {
    var staticEncodeURIComponent = encodeURIComponent;
    module2.exports = staticEncodeURIComponent;
  }
});

// node_modules/xe-utils/serialize.js
var require_serialize = __commonJS({
  "node_modules/xe-utils/serialize.js"(exports2, module2) {
    var staticEncodeURIComponent = require_staticEncodeURIComponent();
    var each = require_each();
    var isArray2 = require_isArray();
    var isNull = require_isNull();
    var isUndefined = require_isUndefined();
    var isPlainObject2 = require_isPlainObject();
    function stringifyParams(resultVal, resultKey, isArr) {
      var _arr;
      var result = [];
      each(resultVal, function(item, key) {
        _arr = isArray2(item);
        if (isPlainObject2(item) || _arr) {
          result = result.concat(stringifyParams(item, resultKey + "[" + key + "]", _arr));
        } else {
          result.push(staticEncodeURIComponent(resultKey + "[" + (isArr ? "" : key) + "]") + "=" + staticEncodeURIComponent(isNull(item) ? "" : item));
        }
      });
      return result;
    }
    function serialize(query) {
      var _arr;
      var params = [];
      each(query, function(item, key) {
        if (!isUndefined(item)) {
          _arr = isArray2(item);
          if (isPlainObject2(item) || _arr) {
            params = params.concat(stringifyParams(item, key, _arr));
          } else {
            params.push(staticEncodeURIComponent(key) + "=" + staticEncodeURIComponent(isNull(item) ? "" : item));
          }
        }
      });
      return params.join("&").replace(/%20/g, "+");
    }
    module2.exports = serialize;
  }
});

// node_modules/xe-utils/staticLocation.js
var require_staticLocation = __commonJS({
  "node_modules/xe-utils/staticLocation.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticLocation = typeof location === staticStrUndefined ? 0 : location;
    module2.exports = staticLocation;
  }
});

// node_modules/xe-utils/helperGetLocatOrigin.js
var require_helperGetLocatOrigin = __commonJS({
  "node_modules/xe-utils/helperGetLocatOrigin.js"(exports2, module2) {
    var staticLocation = require_staticLocation();
    function helperGetLocatOrigin() {
      return staticLocation ? staticLocation.origin || staticLocation.protocol + "//" + staticLocation.host : "";
    }
    module2.exports = helperGetLocatOrigin;
  }
});

// node_modules/xe-utils/parseUrl.js
var require_parseUrl = __commonJS({
  "node_modules/xe-utils/parseUrl.js"(exports2, module2) {
    var staticLocation = require_staticLocation();
    var unserialize = require_unserialize();
    var helperGetLocatOrigin = require_helperGetLocatOrigin();
    function parseURLQuery(uri) {
      return unserialize(uri.split("?")[1] || "");
    }
    function parseUrl(url) {
      var hashs, portText, searchs, parsed;
      var href = "" + url;
      if (href.indexOf("//") === 0) {
        href = (staticLocation ? staticLocation.protocol : "") + href;
      } else if (href.indexOf("/") === 0) {
        href = helperGetLocatOrigin() + href;
      }
      searchs = href.replace(/#.*/, "").match(/(\?.*)/);
      parsed = {
        href,
        hash: "",
        host: "",
        hostname: "",
        protocol: "",
        port: "",
        search: searchs && searchs[1] && searchs[1].length > 1 ? searchs[1] : ""
      };
      parsed.path = href.replace(/^([a-z0-9.+-]*:)\/\//, function(text, protocol) {
        parsed.protocol = protocol;
        return "";
      }).replace(/^([a-z0-9.+-]*)(:\d+)?\/?/, function(text, hostname, port) {
        portText = port || "";
        parsed.port = portText.replace(":", "");
        parsed.hostname = hostname;
        parsed.host = hostname + portText;
        return "/";
      }).replace(/(#.*)/, function(text, hash) {
        parsed.hash = hash.length > 1 ? hash : "";
        return "";
      });
      hashs = parsed.hash.match(/#((.*)\?|(.*))/);
      parsed.pathname = parsed.path.replace(/(\?|#.*).*/, "");
      parsed.origin = parsed.protocol + "//" + parsed.host;
      parsed.hashKey = hashs ? hashs[2] || hashs[1] || "" : "";
      parsed.hashQuery = parseURLQuery(parsed.hash);
      parsed.searchQuery = parseURLQuery(parsed.search);
      return parsed;
    }
    module2.exports = parseUrl;
  }
});

// node_modules/xe-utils/getBaseURL.js
var require_getBaseURL = __commonJS({
  "node_modules/xe-utils/getBaseURL.js"(exports2, module2) {
    var staticLocation = require_staticLocation();
    var helperGetLocatOrigin = require_helperGetLocatOrigin();
    var lastIndexOf = require_lastIndexOf();
    function getBaseURL() {
      if (staticLocation) {
        var pathname = staticLocation.pathname;
        var lastIndex = lastIndexOf(pathname, "/") + 1;
        return helperGetLocatOrigin() + (lastIndex === pathname.length ? pathname : pathname.substring(0, lastIndex));
      }
      return "";
    }
    module2.exports = getBaseURL;
  }
});

// node_modules/xe-utils/locat.js
var require_locat = __commonJS({
  "node_modules/xe-utils/locat.js"(exports2, module2) {
    var staticLocation = require_staticLocation();
    var parseUrl = require_parseUrl();
    function locat() {
      return staticLocation ? parseUrl(staticLocation.href) : {};
    }
    module2.exports = locat;
  }
});

// node_modules/xe-utils/cookie.js
var require_cookie = __commonJS({
  "node_modules/xe-utils/cookie.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var staticDocument = require_staticDocument();
    var staticDecodeURIComponent = require_staticDecodeURIComponent();
    var staticEncodeURIComponent = require_staticEncodeURIComponent();
    var isArray2 = require_isArray();
    var isObject3 = require_isObject();
    var isDate2 = require_isDate();
    var isUndefined = require_isUndefined();
    var includes = require_includes();
    var keys = require_keys();
    var assign3 = require_assign();
    var arrayEach = require_arrayEach();
    var helperNewDate = require_helperNewDate();
    var helperGetDateTime = require_helperGetDateTime();
    var getWhatYear = require_getWhatYear();
    var getWhatMonth = require_getWhatMonth();
    var getWhatDay = require_getWhatDay();
    function toCookieUnitTime(unit, expires) {
      var num = parseFloat(expires);
      var nowdate = helperNewDate();
      var time = helperGetDateTime(nowdate);
      switch (unit) {
        case "y":
          return helperGetDateTime(getWhatYear(nowdate, num));
        case "M":
          return helperGetDateTime(getWhatMonth(nowdate, num));
        case "d":
          return helperGetDateTime(getWhatDay(nowdate, num));
        case "h":
        case "H":
          return time + num * 60 * 60 * 1e3;
        case "m":
          return time + num * 60 * 1e3;
        case "s":
          return time + num * 1e3;
      }
      return time;
    }
    function toCookieUTCString(date) {
      return (isDate2(date) ? date : new Date(date)).toUTCString();
    }
    function cookie(name, value, options) {
      if (staticDocument) {
        var opts, expires, values, result, cookies, keyIndex;
        var inserts = [];
        var args = arguments;
        if (isArray2(name)) {
          inserts = name;
        } else if (args.length > 1) {
          inserts = [assign3({ name, value }, options)];
        } else if (isObject3(name)) {
          inserts = [name];
        }
        if (inserts.length > 0) {
          arrayEach(inserts, function(obj) {
            opts = assign3({}, setupDefaults.cookies, obj);
            values = [];
            if (opts.name) {
              expires = opts.expires;
              values.push(staticEncodeURIComponent(opts.name) + "=" + staticEncodeURIComponent(isObject3(opts.value) ? JSON.stringify(opts.value) : opts.value));
              if (expires) {
                if (isNaN(expires)) {
                  expires = expires.replace(/^([0-9]+)(y|M|d|H|h|m|s)$/, function(text, num, unit) {
                    return toCookieUTCString(toCookieUnitTime(unit, num));
                  });
                } else if (/^[0-9]{11,13}$/.test(expires) || isDate2(expires)) {
                  expires = toCookieUTCString(expires);
                } else {
                  expires = toCookieUTCString(toCookieUnitTime("d", expires));
                }
                opts.expires = expires;
              }
              arrayEach(["expires", "path", "domain", "secure"], function(key) {
                if (!isUndefined(opts[key])) {
                  values.push(opts[key] && key === "secure" ? key : key + "=" + opts[key]);
                }
              });
            }
            staticDocument.cookie = values.join("; ");
          });
          return true;
        } else {
          result = {};
          cookies = staticDocument.cookie;
          if (cookies) {
            arrayEach(cookies.split("; "), function(val) {
              keyIndex = val.indexOf("=");
              result[staticDecodeURIComponent(val.substring(0, keyIndex))] = staticDecodeURIComponent(val.substring(keyIndex + 1) || "");
            });
          }
          return args.length === 1 ? result[name] : result;
        }
      }
      return false;
    }
    function hasCookieItem(value) {
      return includes(cookieKeys(), value);
    }
    function getCookieItem(name) {
      return cookie(name);
    }
    function setCookieItem(name, value, options) {
      cookie(name, value, options);
      return cookie;
    }
    function removeCookieItem(name, options) {
      cookie(name, "", assign3({ expires: -1 }, setupDefaults.cookies, options));
    }
    function cookieKeys() {
      return keys(cookie());
    }
    function cookieJson() {
      return cookie();
    }
    assign3(cookie, {
      has: hasCookieItem,
      set: setCookieItem,
      setItem: setCookieItem,
      get: getCookieItem,
      getItem: getCookieItem,
      remove: removeCookieItem,
      removeItem: removeCookieItem,
      keys: cookieKeys,
      getJSON: cookieJson
    });
    module2.exports = cookie;
  }
});

// node_modules/xe-utils/browse.js
var require_browse = __commonJS({
  "node_modules/xe-utils/browse.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticDocument = require_staticDocument();
    var staticWindow = require_staticWindow();
    var assign3 = require_assign();
    var arrayEach = require_arrayEach();
    function isBrowseStorage(storage) {
      try {
        var testKey = "__xe_t";
        storage.setItem(testKey, 1);
        storage.removeItem(testKey);
        return true;
      } catch (e16) {
        return false;
      }
    }
    function isBrowseType(type) {
      return navigator.userAgent.indexOf(type) > -1;
    }
    function browse4() {
      var $body, isChrome, isEdge;
      var isMobile = false;
      var isLocalStorage = false;
      var isSessionStorage = false;
      var result = {
        isNode: false,
        isMobile,
        isPC: false,
        isDoc: !!staticDocument
      };
      if (!staticWindow && typeof process !== staticStrUndefined) {
        result.isNode = true;
      } else {
        isEdge = isBrowseType("Edge");
        isChrome = isBrowseType("Chrome");
        isMobile = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent);
        if (result.isDoc) {
          $body = staticDocument.body || staticDocument.documentElement;
          arrayEach(["webkit", "khtml", "moz", "ms", "o"], function(core) {
            result["-" + core] = !!$body[core + "MatchesSelector"];
          });
        }
        try {
          isLocalStorage = isBrowseStorage(staticWindow.localStorage);
        } catch (e16) {
        }
        try {
          isSessionStorage = isBrowseStorage(staticWindow.sessionStorage);
        } catch (e16) {
        }
        assign3(result, {
          edge: isEdge,
          firefox: isBrowseType("Firefox"),
          msie: !isEdge && result["-ms"],
          safari: !isChrome && !isEdge && isBrowseType("Safari"),
          isMobile,
          isPC: !isMobile,
          isLocalStorage,
          isSessionStorage
        });
      }
      return result;
    }
    module2.exports = browse4;
  }
});

// node_modules/xe-utils/index.js
var require_xe_utils = __commonJS({
  "node_modules/xe-utils/index.js"(exports2, module2) {
    "use strict";
    var XEUtils156 = require_ctor();
    var assign3 = require_assign();
    var objectEach = require_objectEach();
    var lastObjectEach = require_lastObjectEach();
    var objectMap = require_objectMap();
    var merge = require_merge();
    var map = require_map();
    var some = require_some();
    var every = require_every();
    var includeArrays = require_includeArrays();
    var arrayEach = require_arrayEach();
    var lastArrayEach = require_lastArrayEach();
    var uniq = require_uniq();
    var union = require_union();
    var toArray2 = require_toArray();
    var sortBy = require_sortBy();
    var orderBy = require_orderBy();
    var shuffle = require_shuffle();
    var sample = require_sample();
    var slice = require_slice();
    var filter = require_filter();
    var findKey = require_findKey();
    var includes = require_includes();
    var find2 = require_find();
    var findLast = require_findLast();
    var reduce = require_reduce();
    var copyWithin = require_copyWithin();
    var chunk = require_chunk();
    var zip = require_zip();
    var unzip = require_unzip();
    var zipObject = require_zipObject();
    var flatten = require_flatten();
    var pluck = require_pluck();
    var invoke = require_invoke();
    var toArrayTree = require_toArrayTree();
    var toTreeArray = require_toTreeArray();
    var findTree = require_findTree();
    var eachTree = require_eachTree();
    var mapTree = require_mapTree();
    var filterTree = require_filterTree();
    var searchTree = require_searchTree();
    var arrayIndexOf = require_arrayIndexOf();
    var arrayLastIndexOf = require_arrayLastIndexOf();
    var hasOwnProp = require_hasOwnProp();
    var isArray2 = require_isArray();
    var isNull = require_isNull();
    var isNumberNaN = require_isNaN();
    var isUndefined = require_isUndefined();
    var isFunction2 = require_isFunction();
    var isObject3 = require_isObject();
    var isString3 = require_isString();
    var isPlainObject2 = require_isPlainObject();
    var isLeapYear = require_isLeapYear();
    var isDate2 = require_isDate();
    var eqNull = require_eqNull();
    var each = require_each();
    var forOf = require_forOf();
    var lastForOf = require_lastForOf();
    var indexOf = require_indexOf();
    var lastIndexOf = require_lastIndexOf();
    var keys = require_keys();
    var values = require_values();
    var clone2 = require_clone();
    var getSize = require_getSize();
    var lastEach = require_lastEach();
    var remove = require_remove();
    var clear = require_clear();
    var isNumberFinite = require_isFinite();
    var isFloat = require_isFloat();
    var isInteger = require_isInteger();
    var isBoolean2 = require_isBoolean();
    var isNumber2 = require_isNumber();
    var isRegExp2 = require_isRegExp();
    var isError = require_isError();
    var isTypeError = require_isTypeError();
    var isEmpty = require_isEmpty();
    var isSymbol = require_isSymbol();
    var isArguments = require_isArguments();
    var isElement = require_isElement();
    var isDocument = require_isDocument();
    var isWindow = require_isWindow();
    var isFormData = require_isFormData();
    var isMap = require_isMap();
    var isWeakMap = require_isWeakMap();
    var isSet = require_isSet();
    var isWeakSet = require_isWeakSet();
    var isMatch = require_isMatch();
    var isEqual = require_isEqual();
    var isEqualWith = require_isEqualWith();
    var getType = require_getType();
    var uniqueId = require_uniqueId();
    var findIndexOf = require_findIndexOf();
    var findLastIndexOf = require_findLastIndexOf();
    var toStringJSON = require_toStringJSON();
    var toJSONString = require_toJSONString();
    var entries = require_entries();
    var pick = require_pick();
    var omit = require_omit();
    var first = require_first();
    var last = require_last();
    var has = require_has();
    var get = require_get();
    var set = require_set();
    var groupBy = require_groupBy();
    var countBy = require_countBy();
    var range = require_range();
    var destructuring = require_destructuring();
    var random = require_random();
    var max = require_max();
    var min = require_min();
    var commafy = require_commafy();
    var round = require_round();
    var ceil = require_ceil();
    var floor = require_floor();
    var toFixed = require_toFixed();
    var toInteger = require_toInteger();
    var toNumber = require_toNumber();
    var toNumberString = require_toNumberString();
    var add = require_add();
    var subtract = require_subtract();
    var multiply = require_multiply();
    var divide = require_divide();
    var sum = require_sum();
    var mean = require_mean();
    var getWhatYear = require_getWhatYear();
    var getWhatQuarter = require_getWhatQuarter();
    var getWhatMonth = require_getWhatMonth();
    var getWhatDay = require_getWhatDay();
    var toStringDate = require_toStringDate();
    var toDateString = require_toDateString();
    var now2 = require_now();
    var timestamp = require_timestamp();
    var isValidDate = require_isValidDate();
    var isDateSame = require_isDateSame();
    var getWhatWeek = require_getWhatWeek();
    var getYearDay = require_getYearDay();
    var getYearWeek = require_getYearWeek();
    var getMonthWeek = require_getMonthWeek();
    var getDayOfYear = require_getDayOfYear();
    var getDayOfMonth = require_getDayOfMonth();
    var getDateDiff = require_getDateDiff();
    var padEnd = require_padEnd();
    var padStart = require_padStart();
    var repeat = require_repeat();
    var trim = require_trim();
    var trimRight = require_trimRight();
    var trimLeft = require_trimLeft();
    var escape2 = require_escape();
    var unescape = require_unescape();
    var camelCase = require_camelCase();
    var kebabCase = require_kebabCase();
    var startsWith = require_startsWith();
    var endsWith = require_endsWith();
    var template = require_template();
    var toFormatString = require_toFormatString();
    var toValueString = require_toValueString();
    var noop = require_noop();
    var property = require_property();
    var bind = require_bind();
    var once = require_once();
    var after = require_after();
    var before = require_before();
    var throttle2 = require_throttle();
    var debounce = require_debounce();
    var delay = require_delay();
    var unserialize = require_unserialize();
    var serialize = require_serialize();
    var parseUrl = require_parseUrl();
    var getBaseURL = require_getBaseURL();
    var locat = require_locat();
    var cookie = require_cookie();
    var browse4 = require_browse();
    assign3(XEUtils156, {
      // object
      assign: assign3,
      objectEach,
      lastObjectEach,
      objectMap,
      merge,
      // array
      uniq,
      union,
      sortBy,
      orderBy,
      shuffle,
      sample,
      some,
      every,
      slice,
      filter,
      find: find2,
      findLast,
      findKey,
      includes,
      arrayIndexOf,
      arrayLastIndexOf,
      map,
      reduce,
      copyWithin,
      chunk,
      zip,
      unzip,
      zipObject,
      flatten,
      toArray: toArray2,
      includeArrays,
      pluck,
      invoke,
      arrayEach,
      lastArrayEach,
      toArrayTree,
      toTreeArray,
      findTree,
      eachTree,
      mapTree,
      filterTree,
      searchTree,
      // base
      hasOwnProp,
      eqNull,
      isNaN: isNumberNaN,
      isFinite: isNumberFinite,
      isUndefined,
      isArray: isArray2,
      isFloat,
      isInteger,
      isFunction: isFunction2,
      isBoolean: isBoolean2,
      isString: isString3,
      isNumber: isNumber2,
      isRegExp: isRegExp2,
      isObject: isObject3,
      isPlainObject: isPlainObject2,
      isDate: isDate2,
      isError,
      isTypeError,
      isEmpty,
      isNull,
      isSymbol,
      isArguments,
      isElement,
      isDocument,
      isWindow,
      isFormData,
      isMap,
      isWeakMap,
      isSet,
      isWeakSet,
      isLeapYear,
      isMatch,
      isEqual,
      isEqualWith,
      getType,
      uniqueId,
      getSize,
      indexOf,
      lastIndexOf,
      findIndexOf,
      findLastIndexOf,
      toStringJSON,
      toJSONString,
      keys,
      values,
      entries,
      pick,
      omit,
      first,
      last,
      each,
      forOf,
      lastForOf,
      lastEach,
      has,
      get,
      set,
      groupBy,
      countBy,
      clone: clone2,
      clear,
      remove,
      range,
      destructuring,
      // number
      random,
      min,
      max,
      commafy,
      round,
      ceil,
      floor,
      toFixed,
      toNumber,
      toNumberString,
      toInteger,
      add,
      subtract,
      multiply,
      divide,
      sum,
      mean,
      // date
      now: now2,
      timestamp,
      isValidDate,
      isDateSame,
      toStringDate,
      toDateString,
      getWhatYear,
      getWhatQuarter,
      getWhatMonth,
      getWhatWeek,
      getWhatDay,
      getYearDay,
      getYearWeek,
      getMonthWeek,
      getDayOfYear,
      getDayOfMonth,
      getDateDiff,
      // string
      trim,
      trimLeft,
      trimRight,
      escape: escape2,
      unescape,
      camelCase,
      kebabCase,
      repeat,
      padStart,
      padEnd,
      startsWith,
      endsWith,
      template,
      toFormatString,
      toString: toValueString,
      toValueString,
      // function
      noop,
      property,
      bind,
      once,
      after,
      before,
      throttle: throttle2,
      debounce,
      delay,
      // url
      unserialize,
      serialize,
      parseUrl,
      // web
      getBaseURL,
      locat,
      browse: browse4,
      cookie
    });
    module2.exports = XEUtils156;
  }
});

// node_modules/chinese-lunar-calendar/src/utils.js
var require_utils = __commonJS({
  "node_modules/chinese-lunar-calendar/src/utils.js"(exports2, module2) {
    function base64ToBit(base64Str) {
      const base64CodeMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const result = [];
      for (let i = 0; i < base64Str.length; i++) {
        let n = base64CodeMap.indexOf(base64Str[i]);
        result.push(n.toString(2).padStart(6, "0"));
      }
      return result.join("");
    }
    function checkDate(year, month, date) {
      if (year < 1901 || year > 2100) {
        throw new Error("Invalid Year");
      }
      if (month < 1 || month > 12) {
        throw new Error("Invalid Month");
      }
      if (date < 1 || date > 31) {
        throw new Error("Invalid Date");
      }
      if ([4, 6, 9, 11].indexOf(month) != -1 && date > 30) {
        throw new Error("Invalid Date");
      }
      if (month == 2) {
        if (date > 29) {
          throw new Error("Invalid Date");
        } else {
          let isLeap = false;
          if (year % 400 == 0) {
            isLeap = true;
          } else if (year % 4 == 0 && year % 100 != 0) {
            isLeap = true;
          }
          if (!isLeap && date > 28) {
            throw new Error("Invalid Date");
          }
        }
      }
    }
    module2.exports = {
      base64ToBit,
      checkDate
    };
  }
});

// node_modules/chinese-lunar-calendar/src/solar_term.js
var require_solar_term = __commonJS({
  "node_modules/chinese-lunar-calendar/src/solar_term.js"(exports2, module2) {
    var { base64ToBit, checkDate } = require_utils();
    var names = [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ];
    var baseDate = [4, 19, 3, 18, 4, 19, 4, 19, 4, 20, 4, 20, 6, 22, 6, 22, 6, 22, 7, 22, 6, 21, 6, 21];
    var table = [];
    function decompressData() {
      const codeStr = "ABCDAECDAECDFGHIJKHILKMILABNOABNOAENOAENOAEPQRGSTUGSTLAVTOAWXOAWXOAYXOAYZOabcdebcQUfgThijkOilXOimXOimXOimcOnocdpqcQrsgktujkvumXvumXvumcvumcvwocxyqcz0sj10s213u243um43um53wm56wq567q589s+/0s~/3u~!3u@#3um";
      const groupsStr = "paaqmqqpqaquqqqqqvruruqq6qWaWZqlqaqqqqqqlaaqmqqppaaqqqqqqrququqqqqWaWZaVlaaampqlpaaqqqqplaWampqlqaququqqqqWZWZVVlaWaWZqlqqVZWZVVlaWaWZaVlaaqmpqpqmVZVZVVVaWaWZaVlaWampqpqlVZVZVVqVVZVVVVVaWZWZVVqVVVVVVVVaVZWZVVpaaqmpqpqVFVVVVVVaVZVZVVlaWaWZalpaaampqppVFVRVVVVWVZVZVVlaWaWpqlpVFVRVVUVVVZVVVVVaWZWZaVVFVZVVVVVFVVVVVVpVFVRUVUVFFVVVVVpVFFRUVUVFFVRVVVlVBFRUVUUFFVRVVVlVBFBEVUUFFVRVVUlVBFBEVQUFFFRUVUlVBFBEFQUFBFRUVUlVBEBEFAQFBFBEVUVVBEBEFAVVVVVVVVQFBFBEVQVVBEBEAAVVAEAEAAQFBFBEFQUFBFBUVUQFBEBEFAUFBFBEVUVQAEAAAAAFBEBEFAVQAAAAAAAFBEBEAAVAAAAAAAAFBEAEAA";
      const groups = [];
      for (let i = 0; i < groupsStr.length; i += 8) {
        const groupBitStr = base64ToBit(groupsStr.substr(i, 8));
        const group = [];
        for (let j = 0; j < groupBitStr.length; j += 2) {
          group.push(+`0b${groupBitStr.substr(j, 2)}`);
        }
        groups.push(group);
      }
      const codeMapStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/~!@#";
      for (let i = 0; i < codeStr.length; i++) {
        table.push(groups[codeMapStr.indexOf(codeStr[i])]);
      }
    }
    decompressData();
    function getSolarTerm(year, month, date) {
      year = Math.floor(+year);
      month = Math.floor(+month);
      date = Math.floor(+date);
      checkDate(year, month, date);
      const index2 = (month - 1) * 2 + (date < 15 ? 0 : 1);
      const d = baseDate[index2] + table[year - 1901][index2];
      if (date == d) {
        return names[index2];
      } else {
        return null;
      }
    }
    module2.exports = { getSolarTerm };
  }
});

// node_modules/chinese-lunar-calendar/src/lunar_calendar.js
var require_lunar_calendar = __commonJS({
  "node_modules/chinese-lunar-calendar/src/lunar_calendar.js"(exports2, module2) {
    var { base64ToBit, checkDate } = require_utils();
    var { getSolarTerm } = require_solar_term();
    var table = [];
    var heavenlyStemStr = "";
    var earthlyBranchStr = "";
    var zodiacStr = "";
    var lunarMonthStr = "";
    var nubmerStr = "";
    function decompressData() {
      const base64Str = "hLaCVwUrqpNDSYNlUaqgrUE1pJXQSuak2FJoaSrqlC1QNailtBK26TcElwpLWyWDUoNqJW1ArYJVySXgkuzJYNSg6lVtSC1oFbHJuCS58loZKhqU20oLVQVqSq2BLoSWlkrCpV7SoNlBaqqrUE2gpbNSuClcVKg6VBqpq1QVaglslK4KVwUmPpMGyrrVQVqCW1UroJWhSamk0NJY1ShaoFtTS2glbBJtKS4Ul1ZLBqUG1GraBVsEq6pLwSXBks2pQdSw1lBawKtlk2hJcGSyalQ1KDaUlqoK1PVbAl0JLVyVhUqFpSWqgrVlVqCXQUtspXBSsKk0dKg1UFapJtQS2alcFJwaTL0mDVMFqja1BLbaV0ErQpNbSWGkoapLtUC1oFbSStgk29JcKSwqlW1KDaQVtGq2CTeEl4JLgyWzUoOpQaqSrYFVwSXHkuDJZ9SoalBtKq1UFagptRS6ClsVKwqVC0prVQVqgq0lLoKWwUrOpODSbuUwaqCtVU2oJbBSuik4NFo6TBqkG1TNagVtBK5KToUWhoqWyUNUg";
      const bitStr = base64ToBit(base64Str);
      let solarDate = { y: 1900, m: 1, d: 31, obj: new Date(1900, 0, 31, 0, 0, 0, 0) };
      let heavenlyStem = 6;
      let earthlyBranch = 0;
      for (let i = 0; i < bitStr.length; ) {
        if (i + 16 >= bitStr.length) {
          break;
        }
        const head = bitStr.substr(i, 4);
        i += 4;
        const leapMonth = +`0b${head}`;
        const monthCount = leapMonth > 0 ? 13 : 12;
        const months = bitStr.substr(i, monthCount).split("").map((o) => +o);
        i += monthCount;
        table.push({
          solarDate,
          leapMonth,
          months,
          heavenlyStem,
          earthlyBranch
        });
        const dateCount = monthCount * 29 + months.filter((o) => o == 1).length;
        const newSolarDate = new Date(solarDate.y, solarDate.m - 1, solarDate.d + dateCount, 0, 0, 0, 0);
        solarDate = {
          y: newSolarDate.getFullYear(),
          m: newSolarDate.getMonth() + 1,
          d: newSolarDate.getDate(),
          obj: newSolarDate
        };
        heavenlyStem = (heavenlyStem + 1) % 10;
        earthlyBranch = (earthlyBranch + 1) % 12;
      }
    }
    decompressData();
    function isBefore(base, target) {
      if (base.y != target.y) {
        return base.y > target.y;
      } else if (base.m != target.m) {
        return base.m > target.m;
      } else if (base.d != target.d) {
        return base.d > target.d;
      }
      return false;
    }
    function getLunarStr(month, date, isLeap) {
      const monthStr = `${isLeap ? "" : ""}${lunarMonthStr[month - 1]}`;
      if (date <= 10) {
        return `${monthStr}${nubmerStr[date - 1]}`;
      } else if (date < 20) {
        return `${monthStr}${nubmerStr[date - 11]}`;
      } else if (date == 20) {
        return `${monthStr}`;
      } else if (date > 20) {
        return `${monthStr}${nubmerStr[date - 21]}`;
      } else {
        return `${monthStr}`;
      }
    }
    function getLunar(year, month, date) {
      year = Math.floor(+year);
      month = Math.floor(+month);
      date = Math.floor(+date);
      checkDate(year, month, date);
      let index2 = year - 1900;
      let row = table[index2];
      if (isBefore(row.solarDate, { y: year, m: month, d: date })) {
        index2 -= 1;
        row = table[index2];
      }
      if (!row) {
        throw new Error("Invalid Date");
      }
      const targetDate = new Date(year, month - 1, date, 0, 0, 0, 0);
      let delta = Math.round((targetDate.getTime() - row.solarDate.obj.getTime()) / (24 * 60 * 60 * 1e3));
      let afterLeap = false;
      for (let i = 0; i < row.months.length; i++) {
        const isLeap = row.leapMonth > 0 && i == row.leapMonth;
        if (isLeap) {
          afterLeap = true;
        }
        const days = 29 + row.months[i];
        if (delta < days) {
          let lunarMonth = afterLeap ? i : i + 1;
          return {
            lunarMonth,
            lunarDate: delta + 1,
            isLeap,
            solarTerm: getSolarTerm(year, month, date),
            lunarYear: `${heavenlyStemStr[row.heavenlyStem]}${earthlyBranchStr[row.earthlyBranch]}`,
            zodiac: `${zodiacStr[row.earthlyBranch]}`,
            dateStr: getLunarStr(lunarMonth, delta + 1, isLeap)
          };
        } else {
          delta -= days;
        }
      }
      throw new Error(`There's something wrong!`);
    }
    module2.exports = { getLunar };
  }
});

// node_modules/sortablejs/modular/sortable.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.6";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el2, event, fn2) {
  el2.addEventListener(event, fn2, !IE11OrLess && captureMode);
}
function off(el2, event, fn2) {
  el2.removeEventListener(event, fn2, !IE11OrLess && captureMode);
}
function matches(el2, selector) {
  if (!selector) return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el2) {
    try {
      if (el2.matches) {
        return el2.matches(selector);
      } else if (el2.msMatchesSelector) {
        return el2.msMatchesSelector(selector);
      } else if (el2.webkitMatchesSelector) {
        return el2.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el2) {
  return el2.host && el2 !== document && el2.host.nodeType ? el2.host : el2.parentNode;
}
function closest(el2, selector, ctx, includeCTX) {
  if (el2) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el2.parentNode === ctx && matches(el2, selector) : matches(el2, selector)) || includeCTX && el2 === ctx) {
        return el2;
      }
      if (el2 === ctx) break;
    } while (el2 = getParentOrHost(el2));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el2, name, state) {
  if (el2 && name) {
    if (el2.classList) {
      el2.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el2.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el2.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el2, prop, val) {
  var style = el2 && el2.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el2, "");
      } else if (el2.currentStyle) {
        val = el2.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el2, selfOnly) {
  var appliedTransforms = "";
  if (typeof el2 === "string") {
    appliedTransforms = el2;
  } else {
    do {
      var transform2 = css(el2, "transform");
      if (transform2 && transform2 !== "none") {
        appliedTransforms = transform2 + " " + appliedTransforms;
      }
    } while (!selfOnly && (el2 = el2.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el2, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el2.getBoundingClientRect && el2 !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el2 !== window && el2.parentNode && el2 !== getWindowScrollingElement()) {
    elRect = el2.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el2 !== window) {
    container = container || el2.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el2 !== window) {
    var elMatrix = matrix(container || el2), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el2, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el2, true), elSideVal = getRect(el2)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el2, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el2.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el2, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el2, selector) {
  var last = el2.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el2, selector) {
  var index2 = 0;
  if (!el2 || !el2.parentNode) {
    return -1;
  }
  while (el2 = el2.previousElementSibling) {
    if (el2.nodeName.toUpperCase() !== "TEMPLATE" && el2 !== Sortable.clone && (!selector || matches(el2, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el2) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el2) {
    do {
      var elMatrix = matrix(el2), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el2.scrollLeft * scaleX;
      offsetTop += el2.scrollTop * scaleY;
    } while (el2 !== winScroller && (el2 = el2.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el2, includeSelf) {
  if (!el2 || !el2.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el2;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms2) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms2);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el2, x, y) {
  el2.scrollLeft += x;
  el2.scrollTop += y;
}
function clone(el2) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el2).cloneNode(true);
  } else if ($) {
    return $(el2).clone(true)[0];
  } else {
    return el2.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl2) {
  var rect = {};
  Array.from(container.children).forEach(function(child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function") callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function") callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function") callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el2, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el2, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2)) continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function") return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable) return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists) return;
  if (IE11OrLess) {
    return false;
  }
  var el2 = document.createElement("x");
  el2.style.cssText = "pointer-events:auto";
  return el2.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el2, options) {
  var elCSS = css(el2), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el2, 0, options), child2 = getChild(el2, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to2, from, dragEl2, evt) {
      var sameGroup = to2.options.group.name && from.options.group.name && to2.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to2, from, dragEl2, evt), pull)(to2, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to2 : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el2, options) {
  if (!(el2 && el2.nodeType && el2.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el2));
  }
  this.el = el2;
  this.options = options = _extends({}, options);
  el2[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el2.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el2, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && (!Safari || IOS),
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el2, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el2, "pointerdown", this._onTapStart);
  } else {
    on(el2, "mousedown", this._onTapStart);
    on(el2, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el2, "dragover", this);
    on(el2, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable) return;
    var _this = this, el2 = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el2);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el2, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el2,
          fromEl: el2
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el2, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el2,
            toEl: el2
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el2, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el2 = _this.el, options = _this.options, ownerDocument = el2.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el2) {
      var dragRect = getRect(target);
      rootEl = el2;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      if (options.supportPointer) {
        on(ownerDocument, "pointerup", _this._onDrop);
        !this.nativeDraggable && on(ownerDocument, "pointercancel", _this._onDrop);
      } else {
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop);
      }
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        if (options.supportPointer) {
          on(ownerDocument, "pointerup", _this._disableDelayedDrag);
          on(ownerDocument, "pointercancel", _this._disableDelayedDrag);
        } else {
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        }
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e16) {
    var touch = e16.touches ? e16.touches[0] : e16;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "pointerup", this._disableDelayedDrag);
    off(ownerDocument, "pointercancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy2 = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy2 - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy2
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy2;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    window.getSelection().removeAllRanges();
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el2 = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el2, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el2 && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el2,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el2, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el2, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el2 === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el2.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el2.appendChild(dragEl);
          }
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el2, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el2.insertBefore(dragEl, firstChild);
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el2) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el2, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el2.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el2.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "pointercancel", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el2 = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el2, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el2) {
      el2.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [], el2, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el2 = children[i];
      if (closest(el2, options.draggable, this.el, false)) {
        order.push(el2.getAttribute(options.dataIdAttr) || _generateId(el2));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id2, i) {
      var el2 = rootEl2.children[i];
      if (closest(el2, this.options.draggable, rootEl2, false)) {
        items[id2] = el2;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id2) {
      if (items[id2]) {
        rootEl2.removeChild(items[id2]);
        rootEl2.appendChild(items[id2]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el2, selector) {
    return closest(el2, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el2 = this.el;
    el2[expando] = null;
    off(el2, "mousedown", this._onTapStart);
    off(el2, "touchstart", this._onTapStart);
    off(el2, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el2, "dragover", this);
      off(el2, "dragenter", this);
    }
    Array.prototype.forEach.call(el2.querySelectorAll("[draggable]"), function(el3) {
      el3.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el2 = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled) return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el2) {
  el2.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el2) {
  var str = el2.tagName + el2.className + el2.src + el2.href + el2.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el2 = inputs[idx];
    el2.checked && savedInputChecked.push(el2);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id2) {
  return clearTimeout(id2);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el2, selector) {
    return !!closest(el2, selector, el2, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild,
  expando
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array) plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el2, options) {
  return new Sortable(el2, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el2 = currentParent, rect = getRect(el2), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el2.scrollWidth, scrollHeight = el2.scrollHeight, elCSS = css(el2), scrollPosX = el2.scrollLeft, scrollPosY = el2.scrollTop;
    if (el2 === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy2 = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy2 || autoScrolls[layersOut].el !== el2) {
      autoScrolls[layersOut].el = el2;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy2;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy2 != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval((function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }).bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// node_modules/vxe-table/es/components.js
var components_exports = {};
__export(components_exports, {
  Colgroup: () => Colgroup,
  Column: () => Column,
  Grid: () => Grid,
  Table: () => Table,
  Toolbar: () => Toolbar,
  VXETable: () => VXETable,
  VxeColgroup: () => VxeColgroup,
  VxeColumn: () => VxeColumn,
  VxeGrid: () => VxeGrid,
  VxeTable: () => VxeTable,
  VxeToolbar: () => VxeToolbar,
  VxeUI: () => VxeUI,
  _t: () => _t,
  clipboard: () => clipboard2,
  commands: () => commands2,
  config: () => config,
  formats: () => formats2,
  getConfig: () => getConfig2,
  getI18n: () => getI18n2,
  getIcon: () => getIcon2,
  getTheme: () => getTheme2,
  globalEvents: () => globalEvents2,
  globalResize: () => globalResize2,
  hooks: () => hooks2,
  install: () => install,
  interceptor: () => interceptor2,
  log: () => log2,
  menus: () => menus2,
  modal: () => modal,
  print: () => print,
  readFile: () => readFile,
  renderer: () => renderer2,
  saveFile: () => saveFile,
  setConfig: () => setConfig2,
  setI18n: () => setI18n2,
  setIcon: () => setIcon2,
  setLanguage: () => setLanguage2,
  setTheme: () => setTheme2,
  setup: () => setup,
  t: () => t,
  use: () => use2,
  validators: () => validators2,
  version: () => version3
});

// node_modules/@vxe-ui/core/es/src/core.js
var coreVersion = "4.0.23";
var VxeCore = {
  coreVersion,
  uiVersion: "",
  tableVersion: ""
};

// node_modules/@vxe-ui/core/es/src/config.js
var import_xe_utils = __toESM(require_xe_utils());

// node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = "z-index-manage";
var styleEl = null;
var styleId = "z-index-style";
var storeMainKey = "m";
var storeSubKey = "s";
var storeData = {
  m: 1e3,
  s: 1e3
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== "undefined") {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName("body")[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName("*");
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement("style");
        styleEl.id = styleId;
        dom.getElementsByTagName("head")[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = "--dom-";
    var propKey = "-z-index";
    styEl.innerHTML = ":root{" + prefixes + "main" + propKey + ":" + getCurrent() + ";" + prefixes + "sub" + propKey + ":" + getSubCurrent() + "}";
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement("div");
          storeEl.id = storeId;
          storeEl.style.display = "none";
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function(value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el2 = getStoreDom();
      if (el2) {
        if (el2.dataset) {
          el2.dataset[key] = value + "";
        } else {
          el2.setAttribute("data-" + key, value + "");
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent2(currZindex) {
    var zIndex;
    var el2 = getStoreDom();
    if (el2) {
      var domVal = el2.dataset ? el2.dataset[key] : el2.getAttribute("data-" + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
var DomZIndex = {
  setCurrent,
  getCurrent,
  getNext,
  setSubCurrent,
  getSubCurrent,
  getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
var index_esm_default = DomZIndex;

// node_modules/@vxe-ui/core/es/src/configStore.js
var globalConfigStore = {
  size: "",
  version: 1,
  zIndex: 999,
  resizeInterval: 500
};

// node_modules/@vxe-ui/core/es/src/themeStore.js
var themeConfigStore = {
  theme: ""
};

// node_modules/@vxe-ui/core/es/src/theme.js
function setTheme(name) {
  const theme = !name || name === "default" ? "light" : name;
  themeConfigStore.theme = theme;
  if (typeof document !== "undefined") {
    const documentElement = document.documentElement;
    if (documentElement) {
      documentElement.setAttribute("data-vxe-ui-theme", theme);
    }
  }
  return VxeCore;
}
function getTheme() {
  return themeConfigStore.theme;
}

// node_modules/@vxe-ui/core/es/src/config.js
function setConfig(options) {
  if (options) {
    if (options.zIndex) {
      index_esm_default.setCurrent(options.zIndex);
    }
    if (options.theme) {
      setTheme(options.theme);
    }
    import_xe_utils.default.merge(globalConfigStore, options);
  }
  return VxeCore;
}
function getConfig(key, defaultValue) {
  return arguments.length ? import_xe_utils.default.get(globalConfigStore, key, defaultValue) : globalConfigStore;
}

// node_modules/@vxe-ui/core/es/src/dataStore.js
var globalStore = {};

// node_modules/@vxe-ui/core/es/src/icon.js
var import_xe_utils2 = __toESM(require_xe_utils());

// node_modules/@vxe-ui/core/es/src/iconStore.js
var iconConfigStore = {};

// node_modules/@vxe-ui/core/es/src/icon.js
function setIcon(options) {
  if (options) {
    Object.assign(iconConfigStore, options);
  }
  return VxeCore;
}
function getIcon(key) {
  return arguments.length ? import_xe_utils2.default.get(iconConfigStore, key) : iconConfigStore;
}

// node_modules/@vxe-ui/core/es/src/event.js
var import_xe_utils3 = __toESM(require_xe_utils());
var GLOBAL_EVENT_KEYS = {
  F2: "F2",
  ESCAPE: "Escape",
  ENTER: "Enter",
  TAB: "Tab",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  SPACEBAR: " ",
  CONTEXT_MENU: "ContextMenu",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  R: "R",
  P: "P",
  Z: "Z",
  X: "X",
  C: "C",
  V: "V",
  M: "M"
};
var browse = import_xe_utils3.default.browse();
var convertEventKeys = {
  " ": "Spacebar",
  Apps: GLOBAL_EVENT_KEYS.CONTEXT_MENU,
  Del: GLOBAL_EVENT_KEYS.DELETE,
  Up: GLOBAL_EVENT_KEYS.ARROW_UP,
  Down: GLOBAL_EVENT_KEYS.ARROW_DOWN,
  Left: GLOBAL_EVENT_KEYS.ARROW_LEFT,
  Right: GLOBAL_EVENT_KEYS.ARROW_RIGHT
};
var wheelName = browse.firefox ? "DOMMouseScroll" : "mousewheel";
var eventStore = [];
function triggerEvent(evnt) {
  const isWheel = evnt.type === wheelName;
  eventStore.forEach(({ type, cb: cb2 }) => {
    if (!evnt.cancelBubble) {
      if (type === evnt.type || isWheel && type === "mousewheel") {
        cb2(evnt);
      }
    }
  });
}
var VxeComponentEvent = class {
  constructor(evnt, params1, params2) {
    Object.defineProperty(this, "$event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "key", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    this.$event = evnt;
    if (evnt) {
      if (evnt.type) {
        this.type = evnt.type;
      }
      if (evnt.key) {
        this.key = evnt.key;
      }
      if (evnt.code) {
        this.code = evnt.code;
      }
    }
    Object.assign(this, params1, params2);
  }
  stopPropagation() {
    const evnt = this.$event;
    if (evnt) {
      evnt.stopPropagation();
    }
  }
  preventDefault() {
    const evnt = this.$event;
    if (evnt) {
      evnt.preventDefault();
    }
  }
};
var createEvent = (evnt, params1, params2) => {
  return new VxeComponentEvent(evnt, params1, params2);
};
var globalEvents = {
  on(comp, type, cb2) {
    eventStore.push({ comp, type, cb: cb2 });
  },
  off(comp, type) {
    import_xe_utils3.default.remove(eventStore, (item) => item.comp === comp && item.type === type);
  },
  hasKey(evnt, targetKey) {
    const { key } = evnt;
    targetKey = targetKey.toLowerCase();
    return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    window.addEventListener("copy", triggerEvent, false);
    window.addEventListener("cut", triggerEvent, false);
    window.addEventListener("paste", triggerEvent, false);
  }
  document.addEventListener("keydown", triggerEvent, false);
  document.addEventListener("contextmenu", triggerEvent, false);
  window.addEventListener("mousedown", triggerEvent, false);
  window.addEventListener("blur", triggerEvent, false);
  window.addEventListener("resize", triggerEvent, false);
  window.addEventListener(wheelName, import_xe_utils3.default.throttle(triggerEvent, 100, { leading: true, trailing: false }), { passive: true, capture: false });
}

// node_modules/@vxe-ui/core/es/src/resize.js
var import_xe_utils4 = __toESM(require_xe_utils());
var resizeTimeout;
var eventStore2 = [];
var defaultInterval = 500;
function eventHandle() {
  if (eventStore2.length) {
    eventStore2.forEach((item) => {
      item.tarList.forEach((observer) => {
        const { target, width, heighe } = observer;
        const clientWidth = target.clientWidth;
        const clientHeight = target.clientHeight;
        const rWidth = clientWidth && width !== clientWidth;
        const rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, globalConfigStore.resizeInterval || defaultInterval);
}
var XEResizeObserver = class {
  constructor(callback) {
    Object.defineProperty(this, "tarList", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "callback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callback = callback;
  }
  observe(target) {
    if (target) {
      const { tarList } = this;
      if (!tarList.some((observer) => observer.target === target)) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!eventStore2.length) {
        eventListener();
      }
      if (!eventStore2.some((item) => item === this)) {
        eventStore2.push(this);
      }
    }
  }
  unobserve(target) {
    import_xe_utils4.default.remove(eventStore2, (item) => item.tarList.some((observer) => observer.target === target));
  }
  disconnect() {
    import_xe_utils4.default.remove(eventStore2, (item) => item === this);
  }
};
var globalResize = {
  create(callback) {
    if (window.ResizeObserver) {
      return new window.ResizeObserver(callback);
    }
    return new XEResizeObserver(callback);
  }
};

// node_modules/@vxe-ui/core/es/src/i18n.js
var import_xe_utils5 = __toESM(require_xe_utils());

// node_modules/@vxe-ui/core/es/src/i18nStore.js
var i18nConfigStore = reactive({
  language: "",
  langMaps: {}
});

// node_modules/@vxe-ui/core/es/src/i18n.js
var checkInstall = false;
function getI18n(key, args) {
  const { langMaps, language } = i18nConfigStore;
  const { i18n } = globalConfigStore;
  if (i18n) {
    return `${i18n(key, args) || ""}`;
  }
  if (!checkInstall) {
    if (!langMaps[language]) {
      console.error(`[vxe core] Language not installed. https://${VxeCore.uiVersion ? "vxeui.com" : "vxetable.cn"}/#/start/i18n`);
    }
    checkInstall = true;
  }
  return import_xe_utils5.default.toFormatString(import_xe_utils5.default.get(langMaps[language], key, key), args);
}
function setLanguage(locale) {
  i18nConfigStore.language = locale || "zh-CN";
  return VxeCore;
}
function setI18n(locale, data) {
  i18nConfigStore.langMaps[locale] = Object.assign({}, data);
  return VxeCore;
}
function hasLanguage(language) {
  const { langMaps } = i18nConfigStore;
  return !!langMaps[language];
}
function getLanguage() {
  const { language } = i18nConfigStore;
  return language;
}

// node_modules/@vxe-ui/core/es/src/renderer.js
var import_xe_utils6 = __toESM(require_xe_utils());

// node_modules/@vxe-ui/core/es/src/log.js
function createLog(type, name) {
  return function(key, args) {
    const msg = `[vxe ${name || ""}] ${getI18n(key, args)}`;
    console[type](msg);
    return msg;
  };
}
var version2 = "4.0.23";
var log = {
  create: createLog,
  warn: createLog("warn", `v${version2}`),
  err: createLog("error", `v${version2}`)
};

// node_modules/@vxe-ui/core/es/src/renderer.js
var renderMap = {};
var renderer = {
  mixin(opts) {
    import_xe_utils6.default.each(opts, (options, name) => renderer.add(name, options));
    return renderer;
  },
  get(name) {
    return renderMap[name] || null;
  },
  add(name, options) {
    if (name && options) {
      const renders = renderMap[name];
      if (renders) {
        if (true) {
          import_xe_utils6.default.each(options, (val, key) => {
            if (!import_xe_utils6.default.eqNull(renders[key]) && renders[key] !== val) {
              log.warn("vxe.error.coverProp", [`Renderer.${name}`, key]);
            }
          });
        }
        Object.assign(renders, options);
      } else {
        renderMap[name] = options;
      }
    }
    return renderer;
  },
  forEach(callback) {
    import_xe_utils6.default.objectEach(renderMap, callback);
    return renderer;
  },
  delete(name) {
    delete renderMap[name];
    return renderer;
  }
};

// node_modules/@vxe-ui/core/es/src/store.js
var import_xe_utils7 = __toESM(require_xe_utils());
var Store = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils7.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, options) {
    const conf = this.store[name];
    if (true) {
      const confKeys = import_xe_utils7.default.keys(conf);
      import_xe_utils7.default.each(options, (item, key) => {
        if (confKeys.includes(key)) {
          log.warn("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils7.default.merge(conf, options) : options;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils7.default.objectEach(this.store, callback);
  }
};
var store_default = Store;

// node_modules/@vxe-ui/core/es/src/validators.js
var validators = new store_default();
if (true) {
  Object.assign(validators, { _name: "Validators" });
}

// node_modules/@vxe-ui/core/es/src/menus.js
var import_xe_utils8 = __toESM(require_xe_utils());
var VXEMenusStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils8.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils8.default.isFunction(render)) {
      if (true) {
        log.warn("vxe.error.delProp", ["menus -> callback", "menuMethod"]);
      }
      render = {
        menuMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils8.default.keys(conf);
      import_xe_utils8.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          log.warn("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils8.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils8.default.objectEach(this.store, callback);
  }
};
var menus = new VXEMenusStore();
if (true) {
  Object.assign(menus, { _name: "Menus" });
}

// node_modules/@vxe-ui/core/es/src/formats.js
var import_xe_utils9 = __toESM(require_xe_utils());
var VXEFormatsStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils9.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils9.default.isFunction(render)) {
      if (true) {
        log.warn("vxe.error.delProp", ["formats -> callback", "cellFormatMethod"]);
      }
      render = {
        cellFormatMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils9.default.keys(conf);
      import_xe_utils9.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          log.warn("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils9.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils9.default.objectEach(this.store, callback);
  }
};
var formats = new VXEFormatsStore();
if (true) {
  Object.assign(formats, { _name: "Formats" });
}

// node_modules/@vxe-ui/core/es/src/commands.js
var import_xe_utils10 = __toESM(require_xe_utils());
var VXECommandsStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils10.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils10.default.isFunction(render)) {
      if (true) {
        log.warn("vxe.error.delProp", ["commands -> callback", "commandMethod"]);
      }
      render = {
        commandMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils10.default.keys(conf);
      import_xe_utils10.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          log.warn("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils10.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils10.default.objectEach(this.store, callback);
  }
};
var commands = new VXECommandsStore();
if (true) {
  Object.assign(commands, { _name: "Commands" });
}

// node_modules/@vxe-ui/core/es/src/interceptor.js
var import_xe_utils11 = __toESM(require_xe_utils());
var storeMap = {};
var interceptor = {
  mixin(options) {
    import_xe_utils11.default.each(options, (render, type) => {
      interceptor.add(type, render);
    });
    return interceptor;
  },
  get(type) {
    return storeMap[type] || [];
  },
  add(type, render) {
    if (import_xe_utils11.default.isFunction(render)) {
      render = {
        tableInterceptorMethod: render
      };
    }
    const callback = render.tableInterceptorMethod;
    if (callback) {
      let eList = storeMap[type];
      if (!eList) {
        eList = storeMap[type] = [];
      }
      if (true) {
        if (eList.indexOf(callback) > -1) {
          log.warn("vxe.error.coverProp", ["Interceptor", type]);
        }
      }
      eList.push(callback);
    }
    return interceptor;
  },
  delete(type, render) {
    const eList = storeMap[type];
    if (eList) {
      if (import_xe_utils11.default.isFunction(render)) {
        render = {
          tableInterceptorMethod: render
        };
      }
      const callback = render ? render.tableInterceptorMethod : null;
      if (callback) {
        import_xe_utils11.default.remove(eList, (fn2) => fn2 === callback);
      } else {
        delete storeMap[type];
      }
    }
  }
};

// node_modules/@vxe-ui/core/es/src/clipboard.js
var import_xe_utils12 = __toESM(require_xe_utils());
var copyElem;
var clipStore = {
  text: "",
  html: ""
};
function handleText(text) {
  if (!copyElem) {
    copyElem = document.createElement("textarea");
    copyElem.id = "$VxeCopy";
    const styles = copyElem.style;
    styles.width = "48px";
    styles.height = "24px";
    styles.position = "fixed";
    styles.zIndex = "0";
    styles.left = "-500px";
    styles.top = "-500px";
    document.body.appendChild(copyElem);
  }
  copyElem.value = text;
}
var clipboard = {
  getStore() {
    return clipStore;
  },
  setStore(data) {
    Object.assign(clipStore, data || {});
  },
  /**
   * 
   *
   * @param {String} content Text 
   */
  copy(content) {
    let result = false;
    try {
      const text = import_xe_utils12.default.toValueString(content);
      handleText(text);
      copyElem.select();
      copyElem.setSelectionRange(0, copyElem.value.length);
      result = document.execCommand("copy");
      copyElem.blur();
      clipStore.text = text;
      clipStore.html = "";
    } catch (e16) {
    }
    return result;
  }
};

// node_modules/@vxe-ui/core/es/src/permission.js
var import_xe_utils13 = __toESM(require_xe_utils());
function handleCheckInfo(permissionCode, permissionMethod) {
  let checkVisible = true;
  let checkDisabled = false;
  const checkMethod = permissionMethod || globalConfigStore.permissionMethod;
  if (permissionCode && checkMethod) {
    checkVisible = false;
    checkDisabled = true;
    let vDone = false;
    let dDone = false;
    const codeList = String(permissionCode).split("|");
    for (let i = 0; i < codeList.length; i++) {
      const code3 = codeList[i];
      let visible = true;
      let disabled = false;
      const rest = checkMethod({ code: code3 });
      if (import_xe_utils13.default.isBoolean(rest)) {
        visible = rest;
      } else if (rest) {
        visible = !!rest.visible;
        disabled = !!rest.disabled;
      }
      if (!disabled && !dDone) {
        dDone = true;
        checkDisabled = disabled;
      }
      if (visible && !vDone) {
        vDone = true;
        checkVisible = visible;
      }
      if (vDone && dDone) {
        break;
      }
    }
  }
  const info = {
    code: permissionCode,
    visible: checkVisible,
    disabled: checkDisabled
  };
  return info;
}
var permission = {
  getCheckInfo(code3) {
    return handleCheckInfo(code3);
  },
  checkVisible(code3) {
    const permissionInfo = handleCheckInfo(code3);
    return permissionInfo.visible;
  },
  checkDisable(code3) {
    const permissionInfo = handleCheckInfo(code3);
    return permissionInfo.disabled;
  }
};

// node_modules/@vxe-ui/core/es/src/hooks.js
var hooks = new store_default();

// node_modules/@vxe-ui/core/es/src/useFns.js
function useSize(props) {
  const xeSizeInfo = inject("xeSizeInfo", null);
  const computeSize = computed(() => {
    return props.size || (xeSizeInfo ? xeSizeInfo.value : null);
  });
  provide("xeSizeInfo", computeSize);
  return { computeSize };
}
function usePermission(props) {
  const computePermissionInfo = computed(() => {
    return handleCheckInfo(props.permissionCode, props.permissionMethod);
  });
  return {
    computePermissionInfo
  };
}
var useFns = {
  useSize,
  usePermission
};

// node_modules/@vxe-ui/core/es/index.esm.js
var installedPlugins = [];
function use(Plugin, options) {
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(VxeUI, options);
      installedPlugins.push(Plugin);
    }
  }
  return VxeUI;
}
var components = {};
function getComponent(name) {
  return components[name] || null;
}
function component(comp) {
  if (comp && comp.name) {
    components[comp.name] = comp;
  }
}
function renderEmptyElement() {
  return createCommentVNode();
}
var VxeUI = Object.assign(VxeCore, {
  renderEmptyElement,
  setTheme,
  getTheme,
  setConfig,
  getConfig,
  setIcon,
  getIcon,
  setLanguage,
  hasLanguage,
  getLanguage,
  setI18n,
  getI18n,
  globalEvents,
  GLOBAL_EVENT_KEYS,
  createEvent,
  globalResize,
  renderer,
  validators,
  menus,
  formats,
  commands,
  interceptor,
  clipboard,
  log,
  permission,
  globalStore,
  hooks,
  component,
  getComponent,
  useFns,
  use
});
setTheme();

// node_modules/vxe-table/es/ui/src/utils.js
var import_xe_utils14 = __toESM(require_xe_utils());
function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === void 0 || cellValue === "";
}
function parseFile(file) {
  const name = file.name;
  const tIndex = import_xe_utils14.default.lastIndexOf(name, ".");
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return { filename, type };
}
function nextZIndex() {
  return index_esm_default.getNext();
}
function getLastZIndex() {
  return index_esm_default.getCurrent();
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content, args) {
  if (content) {
    const translate2 = VxeUI.getConfig().translate;
    return import_xe_utils14.default.toValueString(translate2 ? translate2("" + content, args) : content);
  }
  return "";
}
function formatText(value, placeholder) {
  return "" + (isEmptyValue(value) ? placeholder ? VxeUI.getConfig().emptyCell : "" : value);
}
function eqEmptyValue(cellValue) {
  return cellValue === "" || import_xe_utils14.default.eqNull(cellValue);
}

// node_modules/vxe-table/es/ui/index.js
var version3 = "4.9.29";
VxeUI.version = version3;
VxeUI.tableVersion = version3;
VxeUI.setConfig({
  emptyCell: "",
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    padding: true,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 
    // },
    resizeConfig: {
      // refreshDelay: 250
    },
    resizableConfig: {
      dragMode: "auto",
      showDragTip: true
    },
    radioConfig: {
      // trigger: 'default'
      strict: true
    },
    rowDragConfig: {
      showIcon: true,
      animation: true
    },
    columnDragConfig: {
      showIcon: true,
      animation: true
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      autoClear: true,
      autoPos: true,
      message: "inline",
      msgMode: "single",
      theme: "beautify"
    },
    columnConfig: {
      maxFixedSize: 4
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      // enabled: false,
      allowVisible: true,
      allowResizable: true,
      allowFixed: true,
      allowSort: true,
      showFooter: true,
      placement: "top-right",
      //  storage: false,
      //  checkMethod () {},
      modalOptions: {
        showMaximize: true,
        mask: true,
        lockView: true,
        resize: true,
        escClosable: true
      },
      drawerOptions: {
        mask: true,
        lockView: true,
        escClosable: true,
        resize: true
      }
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: true,
      iconLayout: "vertical"
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      showIcon: true
    },
    treeConfig: {
      rowField: "id",
      parentField: "parentId",
      childrenField: "children",
      hasChildField: "hasChild",
      mapChildrenField: "_X_ROW_CHILD",
      indent: 20,
      showIcon: true
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: true
    },
    editConfig: {
      // mode: 'cell',
      showIcon: true,
      showAsterisk: true,
      autoFocus: true
    },
    importConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    printConfig: {},
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isEsc: true
    },
    areaConfig: {
      autoClear: true,
      selectCellByHeader: true,
      selectCellByBody: true
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    scrollX: {
      // enabled: false,
      gt: 60
      // oSize: 0
    },
    scrollY: {
      // enabled: false,
      gt: 100
      // oSize: 0
    }
  },
  // export: {
  //   types: {}
  // },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
      // perfect: false
    },
    toolbarConfig: {
      enabled: true
      // perfect: false
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      showResponseMsg: true,
      showActiveMsg: true,
      props: {
        list: null,
        result: "result",
        total: "page.total",
        message: "message"
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  }
});
var iconPrefix = "vxe-table-icon-";
VxeUI.setIcon({
  // table
  TABLE_SORT_ASC: iconPrefix + "caret-up",
  TABLE_SORT_DESC: iconPrefix + "caret-down",
  TABLE_FILTER_NONE: iconPrefix + "funnel",
  TABLE_FILTER_MATCH: iconPrefix + "funnel",
  TABLE_EDIT: iconPrefix + "edit",
  TABLE_TITLE_PREFIX: iconPrefix + "question-circle-fill",
  TABLE_TITLE_SUFFIX: iconPrefix + "question-circle-fill",
  TABLE_TREE_LOADED: iconPrefix + "spinner roll",
  TABLE_TREE_OPEN: iconPrefix + "caret-right rotate90",
  TABLE_TREE_CLOSE: iconPrefix + "caret-right",
  TABLE_EXPAND_LOADED: iconPrefix + "spinner roll",
  TABLE_EXPAND_OPEN: iconPrefix + "arrow-right rotate90",
  TABLE_EXPAND_CLOSE: iconPrefix + "arrow-right",
  TABLE_CHECKBOX_CHECKED: iconPrefix + "checkbox-checked-fill",
  TABLE_CHECKBOX_UNCHECKED: iconPrefix + "checkbox-unchecked",
  TABLE_CHECKBOX_INDETERMINATE: iconPrefix + "checkbox-indeterminate-fill",
  TABLE_RADIO_CHECKED: iconPrefix + "radio-checked-fill",
  TABLE_RADIO_UNCHECKED: iconPrefix + "radio-unchecked",
  TABLE_CUSTOM_SORT: iconPrefix + "drag-handle",
  TABLE_MENU_OPTIONS: iconPrefix + "arrow-right",
  TABLE_DRAG_ROW: iconPrefix + "drag-handle",
  TABLE_DRAG_COLUMN: iconPrefix + "drag-handle",
  TABLE_DRAG_STATUS_ROW: iconPrefix + "sort",
  TABLE_DRAG_STATUS_SUB_ROW: iconPrefix + "add-sub",
  TABLE_DRAG_STATUS_COLUMN: iconPrefix + "swap",
  TABLE_DRAG_DISABLED: iconPrefix + "no-drop",
  // toolbar
  TOOLBAR_TOOLS_REFRESH: iconPrefix + "repeat",
  TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + "repeat roll",
  TOOLBAR_TOOLS_IMPORT: iconPrefix + "upload",
  TOOLBAR_TOOLS_EXPORT: iconPrefix + "download",
  TOOLBAR_TOOLS_PRINT: iconPrefix + "print",
  TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + "fullscreen",
  TOOLBAR_TOOLS_MINIMIZE: iconPrefix + "minimize",
  TOOLBAR_TOOLS_CUSTOM: iconPrefix + "custom-column",
  TOOLBAR_TOOLS_FIXED_LEFT: iconPrefix + "fixed-left",
  TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE: iconPrefix + "fixed-left-fill",
  TOOLBAR_TOOLS_FIXED_RIGHT: iconPrefix + "fixed-right",
  TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE: iconPrefix + "fixed-right-fill"
});
var setTheme2 = VxeUI.setTheme;
var getTheme2 = VxeUI.getTheme;
var setConfig2 = VxeUI.setConfig;
var getConfig2 = VxeUI.getConfig;
var setIcon2 = VxeUI.setIcon;
var getIcon2 = VxeUI.getIcon;
var setLanguage2 = VxeUI.setLanguage;
var setI18n2 = VxeUI.setI18n;
var getI18n2 = VxeUI.getI18n;
var globalEvents2 = VxeUI.globalEvents;
var globalResize2 = VxeUI.globalResize;
var renderer2 = VxeUI.renderer;
var validators2 = VxeUI.validators;
var menus2 = VxeUI.menus;
var formats2 = VxeUI.formats;
var commands2 = VxeUI.commands;
var interceptor2 = VxeUI.interceptor;
var clipboard2 = VxeUI.clipboard;
var log2 = VxeUI.log;
var hooks2 = VxeUI.hooks;
var use2 = VxeUI.use;
var setup = (options) => {
  return VxeUI.setConfig(options);
};
VxeUI.setup = setup;
var config = (options) => {
  return VxeUI.setConfig(options);
};
VxeUI.config = config;
var t = (key, args) => {
  return VxeUI.getI18n(key, args);
};
VxeUI.t = t;
var _t = (content, args) => {
  return getFuncText(content, args);
};
VxeUI._t = _t;
var VXETable = VxeUI;
var saveFile = (options) => {
  return VxeUI.saveFile(options);
};
var readFile = (options) => {
  return VxeUI.readFile(options);
};
var print = (options) => {
  return VxeUI.print(options);
};
var modal = {
  /**
   * 
   * @deprecated
   */
  get(id2) {
    return VxeUI.modal.get(id2);
  },
  /**
   * 
   * @deprecated
   */
  close(id2) {
    return VxeUI.modal.close(id2);
  },
  /**
   * 
   * @deprecated
   */
  open(options) {
    return VxeUI.modal.open(options);
  },
  /**
   * 
   * @deprecated
   */
  alert(content, title, options) {
    return VxeUI.modal.alert(content, title, options);
  },
  /**
   * 
   * @deprecated
   */
  confirm(content, title, options) {
    return VxeUI.modal.confirm(content, title, options);
  },
  /**
   * 
   * @deprecated
   */
  message(content, options) {
    return VxeUI.modal.message(content, options);
  },
  /**
   * 
   * @deprecated
   */
  notification(content, title, options) {
    return VxeUI.modal.notification(content, title, options);
  }
};

// node_modules/vxe-table/es/table/src/util.js
var import_xe_utils17 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/src/columnInfo.js
var import_xe_utils15 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/ui/src/log.js
var { log: log3 } = VxeUI;
var version4 = `table v${"4.9.29"}`;
var warnLog = log3.create("warn", version4);
var errLog = log3.create("error", version4);

// node_modules/vxe-table/es/table/src/columnInfo.js
var { getI18n: getI18n3, formats: formats3 } = VxeUI;
var ColumnInfo = class {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor($xeTable, _vm, { renderHeader, renderCell, renderFooter, renderData } = {}) {
    const $xeGrid = $xeTable.xegrid;
    const formatter = _vm.formatter;
    const visible = import_xe_utils15.default.isBoolean(_vm.visible) ? _vm.visible : true;
    const { props: tableProps } = $xeTable;
    if (true) {
      const types = ["seq", "checkbox", "radio", "expand", "html"];
      if (_vm.type && types.indexOf(_vm.type) === -1) {
        warnLog("vxe.error.errProp", [`type=${_vm.type}`, types.join(", ")]);
      }
      if (import_xe_utils15.default.isBoolean(_vm.cellRender) || _vm.cellRender && !import_xe_utils15.default.isObject(_vm.cellRender)) {
        warnLog("vxe.error.errProp", [`column.cell-render=${_vm.cellRender}`, "column.cell-render={}"]);
      }
      if (import_xe_utils15.default.isBoolean(_vm.editRender) || _vm.editRender && !import_xe_utils15.default.isObject(_vm.editRender)) {
        warnLog("vxe.error.errProp", [`column.edit-render=${_vm.editRender}`, "column.edit-render={}"]);
      }
      if (_vm.cellRender && _vm.editRender) {
        warnLog("vxe.error.errConflicts", ["column.cell-render", "column.edit-render"]);
      }
      if (_vm.type === "expand") {
        const { treeConfig } = tableProps;
        const { computeTreeOpts } = $xeTable.getComputeMaps();
        const treeOpts = computeTreeOpts.value;
        if (treeConfig && (treeOpts.showLine || treeOpts.line)) {
          errLog("vxe.error.errConflicts", ["tree-config.showLine", "column.type=expand"]);
        }
      }
      if (formatter) {
        if (import_xe_utils15.default.isString(formatter)) {
          const gFormatOpts = formats3.get(formatter) || import_xe_utils15.default[formatter];
          if (!gFormatOpts || !import_xe_utils15.default.isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
            errLog("vxe.error.notFormats", [formatter]);
          }
        } else if (import_xe_utils15.default.isArray(formatter)) {
          const gFormatOpts = formats3.get(formatter[0]) || import_xe_utils15.default[formatter[0]];
          if (!gFormatOpts || !import_xe_utils15.default.isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
            errLog("vxe.error.notFormats", [formatter[0]]);
          }
        }
      }
    }
    Object.assign(this, {
      // 
      type: _vm.type,
      property: _vm.field,
      field: _vm.field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      maxWidth: _vm.maxWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter,
      footerFormatter: _vm.footerFormatter,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      filters: toFilters(_vm.filters),
      filterMultiple: import_xe_utils15.default.isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: _vm.filterRender,
      treeNode: _vm.treeNode,
      dragSort: _vm.dragSort,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: _vm.editRender,
      contentRender: _vm.contentRender,
      headerExportMethod: _vm.headerExportMethod,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      titleSuffix: _vm.titleSuffix,
      // 
      params: _vm.params,
      // 
      id: _vm.colId || import_xe_utils15.default.uniqueId("col_"),
      parentId: null,
      visible,
      // 
      halfVisible: false,
      defaultVisible: visible,
      defaultFixed: _vm.fixed,
      checked: false,
      halfChecked: false,
      disabled: false,
      // 
      level: 1,
      // 
      rowSpan: 1,
      // 
      colSpan: 1,
      // 
      order: null,
      sortTime: 0,
      // 
      sortNumber: 0,
      renderSortNumber: 0,
      renderFixed: "",
      renderVisible: false,
      renderWidth: 0,
      renderHeight: 0,
      renderResizeWidth: 0,
      renderAutoWidth: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData,
      //  grid 
      slots: _vm.slots
    });
    if ($xeGrid) {
      const { computeProxyOpts } = $xeGrid.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      if (proxyOpts.beforeColumn) {
        proxyOpts.beforeColumn({ $grid: $xeGrid, column: this });
      }
    }
  }
  getTitle() {
    return getFuncText(this.title || (this.type === "seq" ? getI18n3("vxe.table.seqTitle") : ""));
  }
  getKey() {
    const { type } = this;
    return this.field || (type ? `type=${type}` : null);
  }
  update(name, value) {
    if (name !== "filters") {
      if (name === "field") {
        this.property = value;
      }
      this[name] = value;
    }
  }
};

// node_modules/vxe-table/es/ui/src/dom.js
var import_xe_utils16 = __toESM(require_xe_utils());
var reClsMap = {};
var browse2 = import_xe_utils16.default.browse();
var tpImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";
function getPropClass(property, params) {
  return property ? import_xe_utils16.default.isFunction(property) ? property(params) : property : "";
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, "g");
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), "");
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = import_xe_utils16.default.toNumber(computedStyle.paddingTop);
    const paddingBottom = import_xe_utils16.default.toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
function updateCellTitle(overflowElem, column) {
  const content = column.type === "html" ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute("title") !== content) {
    overflowElem.setAttribute("title", content);
  }
}
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
var scrollIntoViewIfNeeded = "scrollIntoViewIfNeeded";
var scrollIntoView = "scrollIntoView";
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function triggerEvent2(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}

// node_modules/vxe-table/es/table/src/util.js
var getAllConvertColumns = (columns, parentColumn) => {
  const result = [];
  columns.forEach((column) => {
    column.parentId = parentColumn ? parentColumn.id : null;
    if (column.visible) {
      if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
        result.push(column);
        result.push(...getAllConvertColumns(column.children, column));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};
var convertHeaderColumnToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
      let colSpan = 0;
      column.children.forEach((subColumn) => {
        if (subColumn.visible) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function restoreScrollLocation($xeTable, scrollLeft, scrollTop) {
  const { internalData } = $xeTable;
  return $xeTable.clearScroll().then(() => {
    if (scrollLeft || scrollTop) {
      internalData.lastScrollLeft = 0;
      internalData.lastScrollTop = 0;
      return $xeTable.scrollTo(scrollLeft, scrollTop);
    }
  });
}
function getRowUniqueId() {
  return import_xe_utils17.default.uniqueId("row_");
}
function getRowkey($xeTable) {
  const { props } = $xeTable;
  const { computeRowOpts } = $xeTable.getComputeMaps();
  const { rowId } = props;
  const rowOpts = computeRowOpts.value;
  return rowId || rowOpts.keyField || "_X_ROW_KEY";
}
function getRowid($xeTable, row) {
  const rowid = import_xe_utils17.default.get(row, getRowkey($xeTable));
  return import_xe_utils17.default.eqNull(rowid) ? "" : encodeURIComponent(rowid);
}
var handleFieldOrColumn = ($xeTable, fieldOrColumn) => {
  if (fieldOrColumn) {
    return import_xe_utils17.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
  }
  return null;
};
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = import_xe_utils17.default.toNumber(computedStyle.paddingLeft);
    const paddingRight = import_xe_utils17.default.toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElementMarginWidth(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const marginLeft = import_xe_utils17.default.toNumber(computedStyle.marginLeft);
    const marginRight = import_xe_utils17.default.toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function queryCellElement(cell, selector) {
  return cell.querySelector(".vxe-cell" + selector);
}
function toFilters(filters) {
  if (filters && import_xe_utils17.default.isArray(filters)) {
    return filters.map(({ label, value, data, resetValue, checked }) => {
      return { label, value, data, resetValue, checked: !!checked, _checked: !!checked };
    });
  }
  return filters;
}
function toTreePathSeq(path) {
  return path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
}
function getCellValue(row, column) {
  return import_xe_utils17.default.get(row, column.field);
}
function setCellValue(row, column, value) {
  return import_xe_utils17.default.set(row, column.field, value);
}
function getRefElem(refEl) {
  if (refEl) {
    const rest = refEl.value;
    if (rest) {
      return rest.$el || rest;
    }
  }
  return null;
}
function getColReMinWidth(params) {
  const { $table, column, cell } = params;
  const { props: tableProps } = $table;
  const { computeResizableOpts } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const { minWidth: reMinWidth } = resizableOpts;
  if (reMinWidth) {
    const customMinWidth = import_xe_utils17.default.isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;
    if (customMinWidth !== "auto") {
      return Math.max(1, import_xe_utils17.default.toNumber(customMinWidth));
    }
  }
  const { showHeaderOverflow: allColumnHeaderOverflow } = tableProps;
  const { showHeaderOverflow, minWidth: colMinWidth } = column;
  const headOverflow = import_xe_utils17.default.isUndefined(showHeaderOverflow) || import_xe_utils17.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showEllipsis = headOverflow === "ellipsis";
  const showTitle = headOverflow === "title";
  const showTooltip = headOverflow === true || headOverflow === "tooltip";
  const hasEllipsis = showTitle || showTooltip || showEllipsis;
  const minTitleWidth = import_xe_utils17.default.floor((import_xe_utils17.default.toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);
  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ""));
  let mWidth = minTitleWidth + paddingLeftRight;
  if (hasEllipsis) {
    const dragIconWidth = getPaddingLeftRightSize(queryCellElement(cell, ">.vxe-cell--drag-handle"));
    const checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, ">.vxe-cell--checkbox"));
    const requiredIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell--required-icon"));
    const editIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell--edit-icon"));
    const prefixIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell-title-prefix-icon"));
    const suffixIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell-title-suffix-icon"));
    const sortIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell--sort"));
    const filterIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell--filter"));
    mWidth += dragIconWidth + checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;
  }
  if (colMinWidth) {
    const { refTableBody } = $table.getRefMaps();
    const tableBody = refTableBody.value;
    const bodyElem = tableBody ? tableBody.$el : null;
    if (bodyElem) {
      if (isScale(colMinWidth)) {
        const bodyWidth = bodyElem.clientWidth - 1;
        const meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(import_xe_utils17.default.toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, import_xe_utils17.default.toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
function isColumnInfo(column) {
  return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);
}
function createColumn($xeTable, options, renderOptions) {
  return isColumnInfo(options) ? options : reactive(new ColumnInfo($xeTable, options, renderOptions));
}
function watchColumn($xeTable, props, column) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      column.update(name, value);
      if ($xeTable) {
        if (name === "filters") {
          $xeTable.setFilter(column, value);
          $xeTable.handleUpdateDataQueue();
        } else if (["visible", "fixed", "width", "minWidth", "maxWidth"].includes(name)) {
          $xeTable.handleRefreshColumnQueue();
        }
      }
    });
  });
}
function assembleColumn($xeTable, elem, column, colgroup) {
  const { reactData } = $xeTable;
  const { staticColumns } = reactData;
  const parentElem = elem.parentNode;
  const parentColumn = colgroup ? colgroup.columnConfig : null;
  const parentCols = parentColumn ? parentColumn.children : staticColumns;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils17.default.arrayIndexOf(parentElem.children, elem), 0, column);
    reactData.staticColumns = staticColumns.slice(0);
  }
}
function destroyColumn($xeTable, column) {
  const { reactData } = $xeTable;
  const { staticColumns } = reactData;
  const matchObj = import_xe_utils17.default.findTree(staticColumns, (item) => item.id === column.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticColumns = staticColumns.slice(0);
}
function getRootColumn($xeTable, column) {
  const { internalData } = $xeTable;
  const { fullColumnIdData } = internalData;
  if (!column) {
    return null;
  }
  let parentColId = column.parentId;
  while (fullColumnIdData[parentColId]) {
    const column2 = fullColumnIdData[parentColId].column;
    parentColId = column2.parentId;
    if (!parentColId) {
      return column2;
    }
  }
  return column;
}
function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
function clearTableDefaultStatus($xeTable) {
  const { props, internalData } = $xeTable;
  internalData.initStatus = false;
  $xeTable.clearSort();
  $xeTable.clearCurrentRow();
  $xeTable.clearCurrentColumn();
  $xeTable.clearRadioRow();
  $xeTable.clearRadioReserve();
  $xeTable.clearCheckboxRow();
  $xeTable.clearCheckboxReserve();
  $xeTable.clearRowExpand();
  $xeTable.clearTreeExpand();
  $xeTable.clearTreeExpandReserve();
  $xeTable.clearPendingRow();
  if ($xeTable.clearFilter) {
    $xeTable.clearFilter();
  }
  if ($xeTable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {
    $xeTable.clearSelected();
  }
  if ($xeTable.clearCellAreas && props.mouseConfig) {
    $xeTable.clearCellAreas();
    $xeTable.clearCopyCellArea();
  }
  return $xeTable.clearScroll();
}
function clearTableAllStatus($xeTable) {
  if ($xeTable.clearFilter) {
    $xeTable.clearFilter();
  }
  return clearTableDefaultStatus($xeTable);
}
function rowToVisible($xeTable, row) {
  const { reactData, internalData } = $xeTable;
  const tableProps = $xeTable.props;
  const { showOverflow } = tableProps;
  const { refTableBody } = $xeTable.getRefMaps();
  const { columnStore, scrollYLoad } = reactData;
  const { afterFullData, scrollYStore, fullAllDataRowIdData } = internalData;
  const tableBody = refTableBody.value;
  const { leftList, rightList } = columnStore;
  const bodyElem = tableBody ? tableBody.$el : null;
  const rowid = getRowid($xeTable, row);
  let offsetFixedLeft = 0;
  leftList.forEach((item) => {
    offsetFixedLeft += item.renderWidth;
  });
  let offsetFixedRight = 0;
  rightList.forEach((item) => {
    offsetFixedRight += item.renderWidth;
  });
  if (bodyElem) {
    const bodyHeight = bodyElem.clientHeight;
    const bodyScrollTop = bodyElem.scrollTop;
    const trElem = bodyElem.querySelector(`[rowid="${rowid}"]`);
    if (trElem) {
      const trOffsetParent = trElem.offsetParent;
      const trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);
      const trHeight = trElem.clientHeight;
      if (trOffsetTop < bodyScrollTop || trOffsetTop > bodyScrollTop + bodyHeight) {
        return $xeTable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodyScrollTop) {
        return $xeTable.scrollTo(null, bodyScrollTop + trHeight);
      }
    } else {
      if (scrollYLoad) {
        if (showOverflow) {
          return $xeTable.scrollTo(null, ($xeTable.findRowIndexOf(afterFullData, row) - 1) * scrollYStore.rowHeight);
        }
        let scrollTop = 0;
        const rest = fullAllDataRowIdData[rowid];
        const rHeight = rest ? rest.height : 0;
        for (let i = 0; i < afterFullData.length; i++) {
          const currRow = afterFullData[i];
          const currRowid = getRowid($xeTable, currRow);
          if (currRow === row || currRowid === rowid) {
            break;
          }
          const rest2 = fullAllDataRowIdData[currRowid];
          scrollTop += rest2 ? rest2.height : 0;
        }
        if (scrollTop < bodyScrollTop) {
          return $xeTable.scrollTo(null, scrollTop - offsetFixedLeft - 1);
        }
        return $xeTable.scrollTo(null, scrollTop + rHeight - (bodyHeight - offsetFixedRight - 1));
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xeTable, column, row) {
  const { reactData, internalData } = $xeTable;
  const { refTableBody } = $xeTable.getRefMaps();
  const { columnStore, scrollXLoad } = reactData;
  const { visibleColumn } = internalData;
  const { leftList, rightList } = columnStore;
  const tableBody = refTableBody.value;
  const bodyElem = tableBody ? tableBody.$el : null;
  if (column.fixed) {
    return Promise.resolve();
  }
  let offsetFixedLeft = 0;
  leftList.forEach((item) => {
    offsetFixedLeft += item.renderWidth;
  });
  let offsetFixedRight = 0;
  rightList.forEach((item) => {
    offsetFixedRight += item.renderWidth;
  });
  if (bodyElem) {
    const bodyWidth = bodyElem.clientWidth;
    const bodyScrollLeft = bodyElem.scrollLeft;
    let tdElem = null;
    if (row) {
      const rowid = getRowid($xeTable, row);
      tdElem = bodyElem.querySelector(`[rowid="${rowid}"] .${column.id}`);
    }
    if (!tdElem) {
      tdElem = bodyElem.querySelector(`.${column.id}`);
    }
    if (tdElem) {
      const tdOffsetParent = tdElem.offsetParent;
      const tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);
      const cellWidth = tdElem.clientWidth;
      if (tdOffsetLeft < bodyScrollLeft + offsetFixedLeft) {
        return $xeTable.scrollTo(tdOffsetLeft - offsetFixedLeft - 1);
      } else if (tdOffsetLeft + cellWidth - bodyScrollLeft > bodyWidth - offsetFixedRight) {
        return $xeTable.scrollTo(tdOffsetLeft + cellWidth - (bodyWidth - offsetFixedRight - 1));
      }
    } else {
      if (scrollXLoad) {
        let scrollLeft = 0;
        const cellWidth = column.renderWidth;
        for (let i = 0; i < visibleColumn.length; i++) {
          const currCol = visibleColumn[i];
          if (currCol === column || currCol.id === column.id) {
            break;
          }
          scrollLeft += currCol.renderWidth;
        }
        if (scrollLeft < bodyScrollLeft) {
          return $xeTable.scrollTo(scrollLeft - offsetFixedLeft - 1);
        }
        return $xeTable.scrollTo(scrollLeft + cellWidth - (bodyWidth - offsetFixedRight - 1));
      }
    }
  }
  return Promise.resolve();
}

// node_modules/vxe-table/es/table/src/cell.js
var import_xe_utils19 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/ui/src/vn.js
var import_xe_utils18 = __toESM(require_xe_utils());
function getOnName(type) {
  return "on" + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
      return "input";
    case "select":
      return "change";
  }
  return "update:modelValue";
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeNumberInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function getSlotVNs(vns) {
  if (import_xe_utils18.default.isArray(vns)) {
    return vns;
  }
  return [vns];
}

// node_modules/vxe-table/es/table/src/cell.js
var { getI18n: getI18n4, getIcon: getIcon3, renderer: renderer3, formats: formats4, renderEmptyElement: renderEmptyElement2 } = VxeUI;
function renderTitlePrefixIcon(params) {
  const { $table, column } = params;
  const titlePrefix = column.titlePrefix || column.titleHelp;
  if (titlePrefix) {
    return h("i", {
      class: ["vxe-cell-title-prefix-icon", titlePrefix.icon || getIcon3().TABLE_TITLE_PREFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titlePrefix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    });
  }
  return renderEmptyElement2($table);
}
function renderTitleSuffixIcon(params) {
  const { $table, column } = params;
  const titleSuffix = column.titleSuffix;
  if (titleSuffix) {
    return h("i", {
      class: ["vxe-cell-title-suffix-icon", titleSuffix.icon || getIcon3().TABLE_TITLE_SUFFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titleSuffix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    });
  }
  return renderEmptyElement2($table);
}
function renderCellDragIcon(params) {
  const { $table } = params;
  const tableProps = $table.props;
  const { dragConfig } = tableProps;
  const { computeRowDragOpts } = $table.getComputeMaps();
  const rowDragOpts = computeRowDragOpts.value;
  const { icon, trigger, disabledMethod } = rowDragOpts;
  const rDisabledMethod = disabledMethod || (dragConfig ? dragConfig.rowDisabledMethod : null);
  const isDisabled = rDisabledMethod && rDisabledMethod(params);
  const ons = {};
  if (trigger !== "cell") {
    ons.onMousedown = (evnt) => {
      if (!isDisabled) {
        $table.handleCellDragMousedownEvent(evnt, params);
      }
    };
    ons.onMouseup = $table.handleCellDragMouseupEvent;
  }
  return h("span", Object.assign({ key: "dg", class: ["vxe-cell--drag-handle", {
    "is--disabled": isDisabled
  }] }, ons), [
    h("i", {
      class: icon || (dragConfig ? dragConfig.rowIcon : "") || getIcon3().TABLE_DRAG_ROW
    })
  ]);
}
function renderCellBaseVNs(params, content) {
  const { $table, column, level } = params;
  const { dragSort } = column;
  const tableProps = $table.props;
  const { treeConfig, dragConfig } = tableProps;
  const { computeRowOpts, computeRowDragOpts } = $table.getComputeMaps();
  const rowOpts = computeRowOpts.value;
  const rowDragOpts = computeRowDragOpts.value;
  const { showIcon, isCrossDrag, visibleMethod } = rowDragOpts;
  const rVisibleMethod = visibleMethod || (dragConfig ? dragConfig.rowVisibleMethod : null);
  const vns = import_xe_utils19.default.isArray(content) ? content : [content];
  if (dragSort && rowOpts.drag && ((showIcon || (dragConfig ? dragConfig.showRowIcon : false)) && (!rVisibleMethod || rVisibleMethod(params)))) {
    if (treeConfig) {
      if (isCrossDrag || !level) {
        vns.unshift(renderCellDragIcon(params));
      }
    } else {
      vns.unshift(renderCellDragIcon(params));
    }
  }
  return vns;
}
function renderHeaderCellDragIcon(params) {
  const { $table, column } = params;
  const { computeColumnOpts, computeColumnDragOpts } = $table.getComputeMaps();
  const columnOpts = computeColumnOpts.value;
  const columnDragOpts = computeColumnDragOpts.value;
  const { showIcon, icon, trigger, isCrossDrag, visibleMethod, disabledMethod } = columnDragOpts;
  if (columnOpts.drag && showIcon && (!visibleMethod || visibleMethod(params))) {
    if (!column.fixed && (isCrossDrag || !column.parentId)) {
      const isDisabled = disabledMethod && disabledMethod(params);
      const ons = {};
      if (trigger !== "cell") {
        ons.onMousedown = (evnt) => {
          if (!isDisabled) {
            $table.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        };
        ons.onMouseup = $table.handleHeaderCellDragMouseupEvent;
      }
      return h("span", Object.assign({ key: "dg", class: ["vxe-cell--drag-handle", {
        "is--disabled": isDisabled
      }] }, ons), [
        h("i", {
          class: icon || getIcon3().TABLE_DRAG_COLUMN
        })
      ]);
    }
  }
  return renderEmptyElement2($table);
}
function renderHeaderCellBaseVNs(params, content) {
  const vns = [
    renderTitlePrefixIcon(params),
    renderHeaderCellDragIcon(params),
    ...import_xe_utils19.default.isArray(content) ? content : [content],
    renderTitleSuffixIcon(params)
  ];
  return vns;
}
function renderTitleContent(params, content) {
  const { $table, column } = params;
  const { props, reactData } = $table;
  const { computeTooltipOpts } = $table.getComputeMaps();
  const { showHeaderOverflow: allColumnHeaderOverflow } = props;
  const { type, showHeaderOverflow } = column;
  const tooltipOpts = computeTooltipOpts.value;
  const showAllTip = tooltipOpts.showAll;
  const headOverflow = import_xe_utils19.default.isUndefined(showHeaderOverflow) || import_xe_utils19.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showTitle = headOverflow === "title";
  const showTooltip = headOverflow === true || headOverflow === "tooltip";
  const ons = {};
  if (showTitle || showTooltip || showAllTip) {
    ons.onMouseenter = (evnt) => {
      if (reactData._isResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip || showAllTip) {
    ons.onMouseleave = (evnt) => {
      if (reactData._isResize) {
        return;
      }
      if (showTooltip || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  return [
    type === "html" && import_xe_utils19.default.isString(content) ? h("span", Object.assign({ class: "vxe-cell--title", innerHTML: content }, ons)) : h("span", Object.assign({ class: "vxe-cell--title" }, ons), getSlotVNs(content))
  ];
}
function formatFooterLabel(footerFormatter, params) {
  if (import_xe_utils19.default.isFunction(footerFormatter)) {
    return footerFormatter(params);
  }
  const isArr = import_xe_utils19.default.isArray(footerFormatter);
  const gFormatOpts = isArr ? formats4.get(footerFormatter[0]) : formats4.get(footerFormatter);
  const footerFormatMethod = gFormatOpts ? gFormatOpts.tableFooterCellFormatMethod : null;
  if (footerFormatMethod) {
    return isArr ? footerFormatMethod(params, ...footerFormatter.slice(1)) : footerFormatMethod(params);
  }
  return "";
}
function getFooterContent(params) {
  const { $table, column, _columnIndex, items, row } = params;
  const { slots, editRender, cellRender, footerFormatter } = column;
  const renderOpts = editRender || cellRender;
  const footerSlot = slots ? slots.footer : null;
  if (footerSlot) {
    return $table.callSlot(footerSlot, params);
  }
  if (renderOpts) {
    const compConf = renderer3.get(renderOpts.name);
    if (compConf) {
      const rtFooter = compConf.renderTableFooter || compConf.renderFooter;
      if (rtFooter) {
        return getSlotVNs(rtFooter(renderOpts, params));
      }
    }
  }
  let itemValue = "";
  if (import_xe_utils19.default.isArray(items)) {
    itemValue = items[_columnIndex];
    return [
      footerFormatter ? formatFooterLabel(footerFormatter, {
        itemValue,
        column,
        row,
        items,
        _columnIndex
      }) : formatText(itemValue, 1)
    ];
  }
  itemValue = import_xe_utils19.default.get(row, column.field);
  return [
    footerFormatter ? formatFooterLabel(footerFormatter, {
      itemValue,
      column,
      row,
      items,
      _columnIndex
    }) : formatText(itemValue, 1)
  ];
}
function getDefaultCellLabel(params) {
  const { $table, row, column } = params;
  return formatText($table.getCellLabel(row, column), 1);
}
var Cell = {
  createColumn($xeTable, columnOpts) {
    const { type, sortable, filters, editRender, treeNode } = columnOpts;
    const { props } = $xeTable;
    const { editConfig } = props;
    const { computeEditOpts, computeCheckboxOpts } = $xeTable.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const editOpts = computeEditOpts.value;
    const renConfs = {
      renderHeader: Cell.renderDefaultHeader,
      renderCell: treeNode ? Cell.renderTreeCell : Cell.renderDefaultCell,
      renderFooter: Cell.renderDefaultFooter
    };
    switch (type) {
      case "seq":
        renConfs.renderHeader = Cell.renderSeqHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeIndexCell : Cell.renderSeqCell;
        break;
      case "radio":
        renConfs.renderHeader = Cell.renderRadioHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeRadioCell : Cell.renderRadioCell;
        break;
      case "checkbox":
        renConfs.renderHeader = Cell.renderCheckboxHeader;
        renConfs.renderCell = checkboxOpts.checkField ? treeNode ? Cell.renderTreeSelectionCellByProp : Cell.renderCheckboxCellByProp : treeNode ? Cell.renderTreeSelectionCell : Cell.renderCheckboxCell;
        break;
      case "expand":
        renConfs.renderCell = Cell.renderExpandCell;
        renConfs.renderData = Cell.renderExpandData;
        break;
      case "html":
        renConfs.renderCell = treeNode ? Cell.renderTreeHTMLCell : Cell.renderHTMLCell;
        if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
        break;
      default:
        if (editConfig && editRender) {
          renConfs.renderHeader = Cell.renderEditHeader;
          renConfs.renderCell = editOpts.mode === "cell" ? treeNode ? Cell.renderTreeCellEdit : Cell.renderCellEdit : treeNode ? Cell.renderTreeRowEdit : Cell.renderRowEdit;
        } else if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
    }
    return createColumn($xeTable, columnOpts, renConfs);
  },
  /**
   * 
   */
  renderHeaderTitle(params) {
    const { $table, column } = params;
    const { slots, editRender, cellRender } = column;
    const renderOpts = editRender || cellRender;
    const headerSlot = slots ? slots.header : null;
    if (headerSlot) {
      return renderTitleContent(params, $table.callSlot(headerSlot, params));
    }
    if (renderOpts) {
      const compConf = renderer3.get(renderOpts.name);
      if (compConf) {
        const rtHeader = compConf.renderTableHeader || compConf.renderHeader;
        if (rtHeader) {
          return renderTitleContent(params, getSlotVNs(rtHeader(renderOpts, params)));
        }
      }
    }
    return renderTitleContent(params, formatText(column.getTitle(), 1));
  },
  renderDefaultHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params));
  },
  renderDefaultCell(params) {
    const { $table, row, column } = params;
    const { slots, editRender, cellRender } = column;
    const renderOpts = editRender || cellRender;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    if (renderOpts) {
      const compConf = renderer3.get(renderOpts.name);
      if (compConf) {
        const rtCell = compConf.renderTableCell || compConf.renderCell;
        const rtDefault = compConf.renderTableDefault || compConf.renderDefault;
        const renderFn = editRender ? rtCell : rtDefault;
        if (renderFn) {
          return renderCellBaseVNs(params, getSlotVNs(renderFn(renderOpts, Object.assign({ $type: editRender ? "edit" : "cell" }, params))));
        }
      }
    }
    const cellValue = $table.getCellLabel(row, column);
    const cellPlaceholder = editRender ? editRender.placeholder : "";
    return renderCellBaseVNs(params, [
      h("span", {
        class: "vxe-cell--label"
      }, [
        // 
        editRender && eqEmptyValue(cellValue) ? h("span", {
          class: "vxe-cell--placeholder"
        }, formatText(getFuncText(cellPlaceholder), 1)) : h("span", formatText(cellValue, 1))
      ])
    ]);
  },
  renderTreeCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderDefaultCell(params));
  },
  renderDefaultFooter(params) {
    return [
      h("span", {
        class: "vxe-cell--item"
      }, getFooterContent(params))
    ];
  },
  /**
   * 
   */
  renderTreeIcon(params, cellVNodes) {
    const { $table, isHidden } = params;
    const { reactData, internalData } = $table;
    const { computeTreeOpts } = $table.getComputeMaps();
    const { treeExpandedMaps, treeExpandLazyLoadedMaps } = reactData;
    const { fullAllDataRowIdData } = internalData;
    const treeOpts = computeTreeOpts.value;
    const { row, column, level } = params;
    const { slots } = column;
    const { indent, lazy, trigger, iconLoaded, showIcon, iconOpen, iconClose } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowChilds = row[childrenField];
    const hasChild = rowChilds && rowChilds.length;
    const iconSlot = slots ? slots.icon : null;
    let hasLazyChilds = false;
    let isAceived = false;
    let isLazyLoading = false;
    let isLazyLoaded = false;
    const ons = {};
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!treeExpandedMaps[rowid];
      if (lazy) {
        const rest = fullAllDataRowIdData[rowid];
        isLazyLoading = !!treeExpandLazyLoadedMaps[rowid];
        hasLazyChilds = row[hasChildField];
        isLazyLoaded = !!rest.treeLoaded;
      }
    }
    if (!trigger || trigger === "default") {
      ons.onClick = (evnt) => {
        $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return [
      h("div", {
        class: ["vxe-cell--tree-node", {
          "is--active": isAceived
        }],
        style: {
          paddingLeft: `${level * indent}px`
        }
      }, [
        showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [
          h("div", Object.assign({ class: "vxe-tree--btn-wrapper" }, ons), [
            h("i", {
              class: ["vxe-tree--node-btn", isLazyLoading ? iconLoaded || getIcon3().TABLE_TREE_LOADED : isAceived ? iconOpen || getIcon3().TABLE_TREE_OPEN : iconClose || getIcon3().TABLE_TREE_CLOSE]
            })
          ])
        ] : null,
        h("div", {
          class: "vxe-tree-cell"
        }, cellVNodes)
      ])
    ];
  },
  /**
   * 
   */
  renderSeqHeader(params) {
    const { $table, column } = params;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    return renderHeaderCellBaseVNs(params, renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : formatText(column.getTitle(), 1)));
  },
  renderSeqCell(params) {
    const { $table, column } = params;
    const { props } = $table;
    const { treeConfig } = props;
    const { computeSeqOpts } = $table.getComputeMaps();
    const seqOpts = computeSeqOpts.value;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    const { seq } = params;
    const seqMethod = seqOpts.seqMethod;
    return renderCellBaseVNs(params, [
      h("span", `${formatText(seqMethod ? seqMethod(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)}`)
    ]);
  },
  renderTreeIndexCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderSeqCell(params));
  },
  /**
   * 
   */
  renderRadioHeader(params) {
    const { $table, column } = params;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    return renderHeaderCellBaseVNs(params, renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [
      h("span", {
        class: "vxe-radio--label"
      }, titleSlot ? $table.callSlot(titleSlot, params) : formatText(column.getTitle(), 1))
    ]));
  },
  renderRadioCell(params) {
    const { $table, column, isHidden } = params;
    const { reactData } = $table;
    const { computeRadioOpts } = $table.getComputeMaps();
    const { selectRadioRow } = reactData;
    const radioOpts = computeRadioOpts.value;
    const { slots } = column;
    const { labelField, checkMethod, visibleMethod } = radioOpts;
    const { row } = params;
    const defaultSlot = slots ? slots.default : null;
    const radioSlot = slots ? slots.radio : null;
    const isChecked = $table.eqRow(row, selectRadioRow);
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
    }
    const radioParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible });
    if (radioSlot) {
      return renderCellBaseVNs(params, $table.callSlot(radioSlot, radioParams));
    }
    const radioVNs = [];
    if (isVisible) {
      radioVNs.push(h("span", {
        class: ["vxe-radio--icon", isChecked ? getIcon3().TABLE_RADIO_CHECKED : getIcon3().TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push(h("span", {
        class: "vxe-radio--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams) : import_xe_utils19.default.get(row, labelField)));
    }
    return renderCellBaseVNs(params, [
      h("span", Object.assign({ class: ["vxe-cell--radio", {
        "is--checked": isChecked,
        "is--disabled": isDisabled
      }] }, ons), radioVNs)
    ]);
  },
  renderTreeRadioCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderRadioCell(params));
  },
  /**
   * 
   */
  renderCheckboxHeader(params) {
    const { $table, column, isHidden } = params;
    const { reactData } = $table;
    const { computeIsAllCheckboxDisabled, computeCheckboxOpts } = $table.getComputeMaps();
    const { isAllSelected: isAllCheckboxSelected, isIndeterminate: isAllCheckboxIndeterminate } = reactData;
    const isAllCheckboxDisabled = computeIsAllCheckboxDisabled.value;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    const checkboxOpts = computeCheckboxOpts.value;
    const headerTitle = column.getTitle();
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isAllCheckboxDisabled) {
            $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
          }
        }
      };
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isAllCheckboxSelected, disabled: isAllCheckboxDisabled, indeterminate: isAllCheckboxIndeterminate });
    if (headerSlot) {
      return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, $table.callSlot(headerSlot, checkboxParams)));
    }
    if (checkboxOpts.checkStrictly ? !checkboxOpts.showHeader : checkboxOpts.showHeader === false) {
      return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, [
        h("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ]));
    }
    return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isAllCheckboxSelected,
        "is--disabled": isAllCheckboxDisabled,
        "is--indeterminate": isAllCheckboxIndeterminate
      }], title: getI18n4("vxe.table.allTitle") }, ons), [
        h("span", {
          class: ["vxe-checkbox--icon", isAllCheckboxIndeterminate ? getIcon3().TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? getIcon3().TABLE_CHECKBOX_CHECKED : getIcon3().TABLE_CHECKBOX_UNCHECKED]
        })
      ].concat(titleSlot || headerTitle ? [
        h("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ] : []))
    ]));
  },
  renderCheckboxCell(params) {
    const { $table, row, column, isHidden } = params;
    const { props, reactData } = $table;
    const { treeConfig } = props;
    const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
    const { computeCheckboxOpts } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const { labelField, checkMethod, visibleMethod } = checkboxOpts;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!selectCheckboxMaps[rowid];
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
      if (treeConfig) {
        indeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate });
    if (checkboxSlot) {
      return renderCellBaseVNs(params, $table.callSlot(checkboxSlot, checkboxParams));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h("span", {
        class: ["vxe-checkbox--icon", indeterminate ? getIcon3().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon3().TABLE_CHECKBOX_CHECKED : getIcon3().TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push(h("span", {
        class: "vxe-checkbox--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : import_xe_utils19.default.get(row, labelField)));
    }
    return renderCellBaseVNs(params, [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminate,
        "is--hidden": !isVisible
      }] }, ons), checkVNs)
    ]);
  },
  renderTreeSelectionCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCell(params));
  },
  renderCheckboxCellByProp(params) {
    const { $table, row, column, isHidden } = params;
    const { props, reactData } = $table;
    const { treeConfig } = props;
    const { treeIndeterminateMaps } = reactData;
    const { computeCheckboxOpts } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const { labelField, checkField, checkMethod, visibleMethod } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let isIndeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = import_xe_utils19.default.get(row, checkField);
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
      if (treeConfig) {
        isIndeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate: isIndeterminate });
    if (checkboxSlot) {
      return renderCellBaseVNs(params, $table.callSlot(checkboxSlot, checkboxParams));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h("span", {
        class: ["vxe-checkbox--icon", isIndeterminate ? getIcon3().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon3().TABLE_CHECKBOX_CHECKED : getIcon3().TABLE_CHECKBOX_UNCHECKED]
      }));
      if (defaultSlot || labelField) {
        checkVNs.push(h("span", {
          class: "vxe-checkbox--label"
        }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : import_xe_utils19.default.get(row, labelField)));
      }
    }
    return renderCellBaseVNs(params, [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminateField && !isChecked ? row[indeterminateField] : isIndeterminate,
        "is--hidden": !isVisible
      }] }, ons), checkVNs)
    ]);
  },
  renderTreeSelectionCellByProp(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCellByProp(params));
  },
  /**
   * 
   */
  renderExpandCell(params) {
    const { $table, isHidden, row, column } = params;
    const { reactData } = $table;
    const { rowExpandedMaps, rowExpandLazyLoadedMaps } = reactData;
    const { computeExpandOpts } = $table.getComputeMaps();
    const expandOpts = computeExpandOpts.value;
    const { lazy, labelField, iconLoaded, showIcon, iconOpen, iconClose, visibleMethod } = expandOpts;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const iconSlot = slots ? slots.icon : null;
    let isAceived = false;
    let isLazyLoading = false;
    if (iconSlot) {
      return renderCellBaseVNs(params, $table.callSlot(iconSlot, params));
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!rowExpandedMaps[rowid];
      if (lazy) {
        isLazyLoading = !!rowExpandLazyLoadedMaps[rowid];
      }
    }
    return renderCellBaseVNs(params, [
      showIcon && (!visibleMethod || visibleMethod(params)) ? h("span", {
        class: ["vxe-table--expanded", {
          "is--active": isAceived
        }],
        onClick(evnt) {
          $table.triggerRowExpandEvent(evnt, params);
        }
      }, [
        h("i", {
          class: ["vxe-table--expand-btn", isLazyLoading ? iconLoaded || getIcon3().TABLE_EXPAND_LOADED : isAceived ? iconOpen || getIcon3().TABLE_EXPAND_OPEN : iconClose || getIcon3().TABLE_EXPAND_CLOSE]
        })
      ]) : renderEmptyElement2($table),
      defaultSlot || labelField ? h("span", {
        class: "vxe-table--expand-label"
      }, defaultSlot ? $table.callSlot(defaultSlot, params) : import_xe_utils19.default.get(row, labelField)) : renderEmptyElement2($table)
    ]);
  },
  renderExpandData(params) {
    const { $table, column } = params;
    const { slots, contentRender } = column;
    const contentSlot = slots ? slots.content : null;
    if (contentSlot) {
      return $table.callSlot(contentSlot, params);
    }
    if (contentRender) {
      const compConf = renderer3.get(contentRender.name);
      if (compConf) {
        const rtExpand = compConf.renderTableExpand || compConf.renderExpand;
        if (rtExpand) {
          return getSlotVNs(rtExpand(contentRender, params));
        }
      }
    }
    return [];
  },
  /**
   * HTML 
   */
  renderHTMLCell(params) {
    const { $table, column } = params;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    return renderCellBaseVNs(params, [
      h("span", {
        class: "vxe-cell--html",
        innerHTML: getDefaultCellLabel(params)
      })
    ]);
  },
  renderTreeHTMLCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderHTMLCell(params));
  },
  /**
   * 
   */
  renderSortAndFilterHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderSortIcon(params).concat(Cell.renderFilterIcon(params))));
  },
  /**
   * 
   */
  renderSortHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderSortIcon(params)));
  },
  renderSortIcon(params) {
    const { $table, column } = params;
    const { computeSortOpts } = $table.getComputeMaps();
    const sortOpts = computeSortOpts.value;
    const { showIcon, iconLayout, iconAsc, iconDesc } = sortOpts;
    const { order } = column;
    if (showIcon) {
      return [
        h("span", {
          class: ["vxe-cell--sort", `vxe-cell--sort-${iconLayout}-layout`]
        }, [
          h("i", {
            class: ["vxe-sort--asc-btn", iconAsc || getIcon3().TABLE_SORT_ASC, {
              "sort--active": order === "asc"
            }],
            title: getI18n4("vxe.table.sortAsc"),
            onClick(evnt) {
              evnt.stopPropagation();
              $table.triggerSortEvent(evnt, column, "asc");
            }
          }),
          h("i", {
            class: ["vxe-sort--desc-btn", iconDesc || getIcon3().TABLE_SORT_DESC, {
              "sort--active": order === "desc"
            }],
            title: getI18n4("vxe.table.sortDesc"),
            onClick(evnt) {
              evnt.stopPropagation();
              $table.triggerSortEvent(evnt, column, "desc");
            }
          })
        ])
      ];
    }
    return [];
  },
  /**
   * 
   */
  renderFilterHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderFilterIcon(params)));
  },
  renderFilterIcon(params) {
    const { $table, column, hasFilter } = params;
    const { reactData } = $table;
    const { filterStore } = reactData;
    const { computeFilterOpts } = $table.getComputeMaps();
    const filterOpts = computeFilterOpts.value;
    const { showIcon, iconNone, iconMatch } = filterOpts;
    return showIcon ? [
      h("span", {
        class: ["vxe-cell--filter", {
          "is--active": filterStore.visible && filterStore.column === column
        }]
      }, [
        h("i", {
          class: ["vxe-filter--btn", hasFilter ? iconMatch || getIcon3().TABLE_FILTER_MATCH : iconNone || getIcon3().TABLE_FILTER_NONE],
          title: getI18n4("vxe.table.filter"),
          onClick(evnt) {
            if ($table.triggerFilterEvent) {
              $table.triggerFilterEvent(evnt, params.column, params);
            }
          }
        })
      ])
    ] : [];
  },
  /**
   * 
   */
  renderEditHeader(params) {
    const { $table, column } = params;
    const { props } = $table;
    const { computeEditOpts } = $table.getComputeMaps();
    const { editConfig, editRules } = props;
    const editOpts = computeEditOpts.value;
    const { sortable, filters, editRender } = column;
    let isRequired = false;
    if (editRules) {
      const columnRules = import_xe_utils19.default.get(editRules, column.field);
      if (columnRules) {
        isRequired = columnRules.some((rule) => rule.required);
      }
    }
    let editIconVNs = [];
    if (isEnableConf(editConfig)) {
      editIconVNs = [
        isRequired && editOpts.showAsterisk ? h("i", {
          class: "vxe-cell--required-icon"
        }) : renderEmptyElement2($table),
        isEnableConf(editRender) && editOpts.showIcon ? h("i", {
          class: ["vxe-cell--edit-icon", editOpts.icon || getIcon3().TABLE_EDIT]
        }) : renderEmptyElement2($table)
      ];
    }
    return renderHeaderCellBaseVNs(params, editIconVNs.concat(Cell.renderHeaderTitle(params)).concat(sortable ? Cell.renderSortIcon(params) : []).concat(filters ? Cell.renderFilterIcon(params) : []));
  },
  // 
  renderRowEdit(params) {
    const { $table, column } = params;
    const { reactData } = $table;
    const { editStore } = reactData;
    const { actived } = editStore;
    const { editRender } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderTreeRowEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderRowEdit(params));
  },
  // 
  renderCellEdit(params) {
    const { $table, column } = params;
    const { reactData } = $table;
    const { editStore } = reactData;
    const { actived } = editStore;
    const { editRender } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderTreeCellEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderCellEdit(params));
  },
  runRenderer(params, isEdit) {
    const { $table, column } = params;
    const { slots, editRender, formatter } = column;
    const defaultSlot = slots ? slots.default : null;
    const editSlot = slots ? slots.edit : null;
    const compConf = renderer3.get(editRender.name);
    const rtEdit = compConf ? compConf.renderTableEdit || compConf.renderEdit : null;
    const cellParams = Object.assign({ $type: "", isEdit }, params);
    if (isEdit) {
      cellParams.$type = "edit";
      if (editSlot) {
        return $table.callSlot(editSlot, cellParams);
      }
      if (rtEdit) {
        return getSlotVNs(rtEdit(editRender, cellParams));
      }
      return [];
    }
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, cellParams));
    }
    if (formatter) {
      return renderCellBaseVNs(params, [
        h("span", {
          class: "vxe-cell--label"
        }, getDefaultCellLabel(cellParams))
      ]);
    }
    return Cell.renderDefaultCell(cellParams);
  }
};
var cell_default = Cell;

// node_modules/vxe-table/es/table/src/column.js
var columnProps = {
  // 
  colId: [String, Number],
  //  index,radio,checkbox,expand,html
  type: String,
  // 
  field: String,
  // 
  title: String,
  // 
  width: [Number, String],
  // 
  minWidth: [Number, String],
  // 
  maxWidth: [Number, String],
  // 
  resizable: {
    type: Boolean,
    default: null
  },
  // 
  fixed: String,
  // 
  align: String,
  // 
  headerAlign: String,
  // 
  footerAlign: String,
  // 
  showOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 
  showHeaderOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 
  showFooterOverflow: {
    type: [Boolean, String],
    default: null
  },
  //  className
  className: [String, Function],
  //  className
  headerClassName: [String, Function],
  //  className
  footerClassName: [String, Function],
  // 
  formatter: [Function, Array, String],
  // 
  footerFormatter: [Function, Array, String],
  // 
  sortable: Boolean,
  // 
  sortBy: [String, Function],
  // 
  sortType: String,
  // 
  filters: {
    type: Array,
    default: null
  },
  // 
  filterMultiple: {
    type: Boolean,
    default: true
  },
  // 
  filterMethod: Function,
  // 
  filterResetMethod: Function,
  // 
  filterRecoverMethod: Function,
  // 
  filterRender: Object,
  // 
  treeNode: Boolean,
  // 
  dragSort: Boolean,
  // 
  visible: {
    type: Boolean,
    default: null
  },
  // 
  headerExportMethod: Function,
  // 
  exportMethod: Function,
  // 
  footerExportMethod: Function,
  //  titlePrefix 
  titleHelp: Object,
  // 
  titlePrefix: Object,
  // 
  titleSuffix: Object,
  // 
  cellType: String,
  // 
  cellRender: Object,
  // 
  editRender: Object,
  // 
  contentRender: Object,
  // 
  params: Object
};
var column_default = defineComponent({
  name: "VxeColumn",
  props: columnProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeTable = inject("$xeTable", null);
    const $xeColgroup = inject("$xeColgroup", null);
    if (!$xeTable) {
      return () => createCommentVNode();
    }
    const columnConfig = cell_default.createColumn($xeTable, props);
    columnConfig.slots = slots;
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    const $xeColumn = {
      columnConfig,
      renderVN
    };
    watchColumn($xeTable, props, columnConfig);
    onMounted(() => {
      const elem = refElem.value;
      if (elem) {
        assembleColumn($xeTable, elem, columnConfig, $xeColgroup);
      }
    });
    onUnmounted(() => {
      destroyColumn($xeTable, columnConfig);
    });
    provide("$xeColumn", $xeColumn);
    provide("$xeGrid", null);
    return renderVN;
  }
});

// node_modules/vxe-table/es/column/index.js
var VxeColumn = Object.assign({}, column_default, {
  install(app) {
    app.component(column_default.name, column_default);
    app.component("VxeTableColumn", column_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(column_default.name, column_default);
  VxeUI.dynamicApp.component("VxeTableColumn", column_default);
}
VxeUI.component(column_default);
var Column = VxeColumn;

// node_modules/vxe-table/es/table/src/group.js
var group_default = defineComponent({
  name: "VxeColgroup",
  props: columnProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeTable = inject("$xeTable", null);
    const $xeParentColgroup = inject("$xeColgroup", null);
    if (!$xeTable) {
      return () => createCommentVNode();
    }
    const columnConfig = cell_default.createColumn($xeTable, props);
    const columnSlots = {};
    if (slots.header) {
      columnSlots.header = slots.header;
    }
    columnConfig.slots = columnSlots;
    columnConfig.children = [];
    watchColumn($xeTable, props, columnConfig);
    onMounted(() => {
      const elem = refElem.value;
      if (elem) {
        assembleColumn($xeTable, elem, columnConfig, $xeParentColgroup);
      }
    });
    onUnmounted(() => {
      destroyColumn($xeTable, columnConfig);
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, slots.default ? slots.default() : []);
    };
    const $xeColgroup = { columnConfig };
    provide("$xeColgroup", $xeColgroup);
    provide("$xeGrid", null);
    return renderVN;
  }
});

// node_modules/vxe-table/es/colgroup/index.js
var VxeColgroup = Object.assign({}, group_default, {
  install(app) {
    app.component(group_default.name, group_default);
    app.component("VxeTableColgroup", group_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(group_default.name, group_default);
  VxeUI.dynamicApp.component("VxeTableColgroup", group_default);
}
VxeUI.component(group_default);
var Colgroup = VxeColgroup;

// node_modules/vxe-table/es/grid/src/grid.js
var import_xe_utils38 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/src/table.js
var import_xe_utils27 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/src/body.js
var import_xe_utils20 = __toESM(require_xe_utils());
var { getI18n: getI18n5, renderer: renderer4, renderEmptyElement: renderEmptyElement3 } = VxeUI;
var renderType = "body";
var lineOffsetSizes = {
  mini: 3,
  small: 2,
  medium: 1
};
var body_default = defineComponent({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ""
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const xesize = inject("xesize", null);
    const { xID, props: tableProps, context: tableContext, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { refTableBody, refTableHeader, refTableFooter, refTableLeftBody, refTableRightBody, refScrollXHandleElem, refScrollYHandleElem } = $xeTable.getRefMaps();
    const { computeEditOpts, computeMouseOpts, computeAreaOpts, computeSYOpts, computeEmptyOpts, computeKeyboardOpts, computeTooltipOpts, computeRadioOpts, computeExpandOpts, computeTreeOpts, computeCheckboxOpts, computeCellOpts, computeValidOpts, computeRowOpts, computeColumnOpts, computeRowDragOpts, computeColumnDragOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refBodyTable = ref();
    const refBodyColgroup = ref();
    const refBodyTBody = ref();
    const refBodyXSpace = ref();
    const refBodyYSpace = ref();
    const refBodyEmptyBlock = ref();
    const getOffsetSize = () => {
      if (xesize) {
        const vSize = xesize.value;
        if (vSize) {
          return lineOffsetSizes[vSize] || 0;
        }
      }
      return 0;
    };
    const isVMScrollProcess = () => {
      const { delayHover } = tableProps;
      const { lastScrollTime, _isResize } = tableReactData;
      return !!(_isResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const countTreeExpand = (prevRow, params) => {
      let count = 1;
      if (!prevRow) {
        return count;
      }
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rowChildren = prevRow[childrenField];
      if (rowChildren && $xeTable.isTreeExpandByRow(prevRow)) {
        for (let index2 = 0; index2 < rowChildren.length; index2++) {
          count += countTreeExpand(rowChildren[index2], params);
        }
      }
      return count;
    };
    const calcTreeLine = (params, items, rIndex) => {
      let expandSize = 1;
      if (rIndex) {
        expandSize = countTreeExpand(items[rIndex - 1], params);
      }
      return tableReactData.rowHeight * expandSize - (rIndex ? 1 : 12 - getOffsetSize());
    };
    const renderLine = (params) => {
      const { row, column } = params;
      const { afterFullData } = tableInternalData;
      const { treeConfig } = tableProps;
      const treeOpts = computeTreeOpts.value;
      const { slots, treeNode } = column;
      const { fullAllDataRowIdData } = tableInternalData;
      const rowid = getRowid($xeTable, row);
      const rest = fullAllDataRowIdData[rowid];
      let rLevel = 0;
      let rIndex = 0;
      let items = [];
      if (rest) {
        rLevel = rest.level;
        rIndex = rest._index;
        items = rest.items;
      }
      if (slots && slots.line) {
        return $xeTable.callSlot(slots.line, params);
      }
      const isFirstRow = $xeTable.eqRow(afterFullData[0], row);
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        return [
          h("div", {
            class: "vxe-tree--line-wrapper"
          }, [
            h("div", {
              class: "vxe-tree--line",
              style: {
                height: `${isFirstRow ? 1 : calcTreeLine(params, items, rIndex)}px`,
                left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize() : 0) + 16}px`
              }
            })
          ])
        ];
      }
      return [];
    };
    const renderColumn = (seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const { fullAllDataRowIdData } = tableInternalData;
      const { columnKey, height, showOverflow: allColumnOverflow, cellClassName: allCellClassName, cellStyle, align: allAlign, spanMethod, mouseConfig, editConfig, editRules, tooltipConfig } = tableProps;
      const { tableData, overflowX, currentColumn, scrollXLoad, scrollYLoad, mergeList, editStore, isAllOverflow, validErrorMaps } = tableReactData;
      const { afterFullData } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const rowOpts = computeRowOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const { disabledMethod: dragDisabledMethod } = rowDragOpts;
      const sYOpts = computeSYOpts.value;
      const columnOpts = computeColumnOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { selectCellToRow } = areaOpts;
      const { type, cellRender, editRender, align, showOverflow, className, treeNode, slots } = column;
      const { verticalAlign } = cellOpts;
      const { actived } = editStore;
      const { rHeight: scrollYRHeight } = sYOpts;
      const { height: rowHeight } = rowOpts;
      const colid = column.id;
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? renderer4.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.tableCellClassName || compConf.cellClassName : null;
      const compCellStyle = compConf ? compConf.tableCellStyle || compConf.cellStyle : "";
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = $xeTable.getColumnIndex(column);
      const _columnIndex = $xeTable.getVTColumnIndex(column);
      const isEdit = isEnableConf(editRender);
      let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
      const cellOverflow = import_xe_utils20.default.isUndefined(showOverflow) || import_xe_utils20.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
      const showEllipsis = cellOverflow === "ellipsis";
      const showTitle = cellOverflow === "title";
      const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
      const hasEllipsis = allColumnOverflow || showTitle || showTooltip || showEllipsis;
      let isDirty;
      const tdOns = {};
      const rest = fullAllDataRowIdData[rowid];
      const cellAlign = align || (compConf ? compConf.tableCellAlign : "") || allAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${colid}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === "default" ? height || tableData.length > 1 : validOpts.message === "inline");
      const attrs = { colid };
      const params = {
        $table: $xeTable,
        $grid: $xeTable.xegrid,
        isEdit: false,
        seq,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        column,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: fixedType,
        type: renderType,
        isHidden: fixedHiddenColumn,
        level: rowLevel,
        visibleData: afterFullData,
        data: tableData,
        items
      };
      let isColDragCell = false;
      let isDisabledDrag = false;
      if (rowOpts.drag) {
        isColDragCell = rowDragOpts.trigger === "row" || column.dragSort && rowDragOpts.trigger === "cell";
      }
      if (isColDragCell) {
        isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(params));
      }
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column);
          } else if (showTooltip || showAllTip) {
            $xeTable.triggerBodyTooltipEvent(evnt, params);
          }
          $xeTable.dispatchEvent("cell-mouseenter", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTooltip || showAllTip) {
            $xeTable.handleTargetLeaveEvent(evnt);
          }
          $xeTable.dispatchEvent("cell-mouseleave", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (isColDragCell || checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = (evnt) => {
          $xeTable.triggerCellMousedownEvent(evnt, params);
        };
      }
      tdOns.onClick = (evnt) => {
        $xeTable.triggerCellClickEvent(evnt, params);
      };
      tdOns.onDblclick = (evnt) => {
        $xeTable.triggerCellDblclickEvent(evnt, params);
      };
      if (mergeList.length) {
        const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
        if (spanRest) {
          const { rowspan, colspan } = spanRest;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        const { rowspan = 1, colspan = 1 } = spanMethod(params) || {};
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          attrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          attrs.colspan = colspan;
        }
      }
      if (fixedHiddenColumn && mergeList) {
        if (attrs.colspan > 1 || attrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xeTable.isUpdateByRow(row, column.field);
      }
      const tdVNs = [];
      if (fixedHiddenColumn && (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {
        tdVNs.push(h("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
          }
        }));
      } else {
        tdVNs.push(...renderLine(params), h("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
          },
          title: showTitle ? $xeTable.getCellLabel(row, column) : null
        }, column.renderCell(params)));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = Object.assign(Object.assign(Object.assign({}, params), errorValidItem), { rule: errorValidItem });
          tdVNs.push(h("div", {
            class: ["vxe-cell--valid-error-tip", getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, [
            h("div", {
              class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${validOpts.theme || "normal"}`
            }, [
              validSlot ? $xeTable.callSlot(validSlot, validParams) : [
                h("span", {
                  class: "vxe-cell--valid-error-msg"
                }, errorValidItem.content)
              ]
            ])
          ]));
        }
      }
      let cellHeight = "";
      if (hasEllipsis && (scrollYRHeight || rowHeight)) {
        cellHeight = `${scrollYRHeight || rowHeight}px`;
      } else if (scrollXLoad || scrollYLoad) {
        if (!hasEllipsis) {
          cellHeight = `${rest.height || 24}px`;
        }
      }
      if (mouseConfig && mouseOpts.area && selectCellToRow) {
        if (!$columnIndex && selectCellToRow === true || selectCellToRow === column.field) {
          tdVNs.push(h("div", {
            class: "vxe-cell--area-status"
          }));
        }
      }
      return h("td", Object.assign(Object.assign(Object.assign({ class: [
        "vxe-body--column",
        colid,
        {
          [`col--${cellAlign}`]: cellAlign,
          [`col--vertical-${verticalAlign}`]: verticalAlign,
          [`col--${type}`]: type,
          "col--last": $columnIndex === columns.length - 1,
          "col--tree-node": treeNode,
          "col--edit": isEdit,
          "col--ellipsis": hasEllipsis,
          "fixed--hidden": fixedHiddenColumn,
          "is--drag-cell": isColDragCell,
          "is--drag-disabled": isDisabledDrag,
          "col--dirty": isDirty,
          "col--active": editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === "row")),
          "col--valid-error": !!errorValidItem,
          "col--current": currentColumn === column
        },
        getPropClass(compCellClassName, params),
        getPropClass(className, params),
        getPropClass(allCellClassName, params)
      ], key: columnKey || columnOpts.useKey || rowOpts.useKey || columnOpts.drag ? colid : $columnIndex }, attrs), { style: Object.assign({
        height: cellHeight
      }, import_xe_utils20.default.isFunction(compCellStyle) ? compCellStyle(params) : compCellStyle, import_xe_utils20.default.isFunction(cellStyle) ? cellStyle(params) : cellStyle) }), tdOns), tdVNs);
    };
    const renderRows = (fixedType, tableData, tableColumn) => {
      const { stripe, rowKey, highlightHoverRow, rowClassName, rowStyle, showOverflow: allColumnOverflow, editConfig, treeConfig } = tableProps;
      const { hasFixedColumn, treeExpandedMaps, scrollYLoad, rowExpandedMaps, expandColumn, selectRadioRow, pendingRowMaps, isDragColMove } = tableReactData;
      const { fullAllDataRowIdData } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { transform: transform2, seqMode } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      tableData.forEach((row, $rowIndex) => {
        const trOn = {};
        let rowIndex = $rowIndex;
        rowIndex = $xeTable.getRowIndex(row);
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = (evnt) => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.triggerHoverEvent(evnt, { row, rowIndex });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.clearHoverRow();
          };
        }
        const rowid = getRowid($xeTable, row);
        const rest = fullAllDataRowIdData[rowid];
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = 0;
        if (rest) {
          rowLevel = rest.level;
          if (treeConfig && transform2 && seqMode === "increasing") {
            seq = rest._index + 1;
          } else {
            seq = rest.seq;
          }
          _rowIndex = rest._index;
        }
        const params = { $table: $xeTable, seq, rowid, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
        const isExpandRow = expandColumn && !!rowExpandedMaps[rowid];
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xeTable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform2) {
          rowChildren = row[childrenField];
          isExpandTree = rowChildren && rowChildren.length > 0 && !!treeExpandedMaps[rowid];
        }
        if (rowOpts.drag && (!treeConfig || transform2)) {
          trOn.onDragstart = $xeTable.handleRowDragDragstartEvent;
          trOn.onDragend = $xeTable.handleRowDragDragendEvent;
          trOn.onDragover = $xeTable.handleRowDragDragoverEvent;
        }
        const trClass = [
          "vxe-body--row",
          treeConfig ? `row--level-${rowLevel}` : "",
          {
            "row--stripe": stripe && (_rowIndex + 1) % 2 === 0,
            "is--new": isNewRow,
            "is--expand-row": isExpandRow,
            "is--expand-tree": isExpandTree,
            "row--new": isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            "row--radio": radioOpts.highlight && $xeTable.eqRow(selectRadioRow, row),
            "row--checked": checkboxOpts.highlight && $xeTable.isCheckedByCheckboxRow(row),
            "row--pending": !!pendingRowMaps[rowid]
          },
          getPropClass(rowClassName, params)
        ];
        const tdVNs = tableColumn.map((column, $columnIndex) => {
          return renderColumn(seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        });
        rows.push(columnOpts.drag && columnDragOpts.animation ? h(TransitionGroup, Object.assign({ name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`, tag: "tr", class: trClass, rowid, style: rowStyle ? import_xe_utils20.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || rowOpts.useKey || rowOpts.drag || columnOpts.drag || treeConfig ? rowid : $rowIndex }, trOn), {
          default: () => tdVNs
        }) : h("tr", Object.assign({ class: trClass, rowid, style: rowStyle ? import_xe_utils20.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || rowOpts.useKey || rowOpts.drag || columnOpts.drag || treeConfig ? rowid : $rowIndex }, trOn), tdVNs));
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const { height: expandHeight, padding } = expandOpts;
          const cellStyle = {};
          if (expandHeight) {
            cellStyle.height = `${expandHeight}px`;
          }
          if (treeConfig) {
            cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
          }
          const { showOverflow } = expandColumn;
          const hasEllipsis = import_xe_utils20.default.isUndefined(showOverflow) || import_xe_utils20.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
          const expandParams = { $table: $xeTable, seq, column: expandColumn, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
          rows.push(h("tr", Object.assign({ class: ["vxe-body--expanded-row", {
            "is--padding": padding
          }], key: `expand_${rowid}`, style: rowStyle ? import_xe_utils20.default.isFunction(rowStyle) ? rowStyle(expandParams) : rowStyle : null }, trOn), [
            h("td", {
              class: {
                "vxe-body--expanded-column": 1,
                "fixed--hidden": fixedType && !hasFixedColumn,
                "col--ellipsis": hasEllipsis
              },
              colspan: tableColumn.length
            }, [
              h("div", {
                class: {
                  "vxe-body--expanded-cell": 1,
                  "is--ellipsis": expandHeight
                },
                style: cellStyle
              }, [
                expandColumn.renderData(expandParams)
              ])
            ])
          ]));
        }
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    const scrollEvent = (evnt) => {
      const { fixedType } = props;
      const { lastScrollTop, lastScrollLeft, inVirtualScroll, inBodyScroll, bodyScrollType, inFooterScroll } = tableInternalData;
      if (inVirtualScroll) {
        return;
      }
      if (inFooterScroll) {
        return;
      }
      if (inBodyScroll) {
        if (bodyScrollType !== fixedType) {
          return;
        }
      }
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const scrollBodyElem = refElem.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      const bodyElem = tableBody.$el;
      if (!bodyElem) {
        return;
      }
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const xHandleEl = refScrollXHandleElem.value;
      const yHandleEl = refScrollYHandleElem.value;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = bodyElem.scrollLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      tableInternalData.inBodyScroll = true;
      tableInternalData.bodyScrollType = fixedType;
      if (isRollY) {
        if (leftElem && fixedType === "left") {
          setScrollTop(bodyElem, scrollTop);
          setScrollTop(rightElem, scrollTop);
        } else if (rightElem && fixedType === "right") {
          setScrollTop(bodyElem, scrollTop);
          setScrollTop(leftElem, scrollTop);
        } else {
          setScrollTop(leftElem, scrollTop);
          setScrollTop(rightElem, scrollTop);
        }
        setScrollTop(yHandleEl, scrollTop);
        $xeTable.triggerScrollYEvent(evnt);
      }
      if (isRollX) {
        setScrollLeft(xHandleEl, scrollLeft);
        setScrollLeft(headerElem, scrollLeft);
        setScrollLeft(footerElem, scrollLeft);
        $xeTable.triggerScrollXEvent(evnt);
      }
      $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
        type: renderType,
        fixed: fixedType
      });
    };
    let wheelTime;
    let wheelYSize = 0;
    let wheelYInterval = 0;
    let wheelYTotal = 0;
    let isPrevWheelTop = false;
    const handleWheel = (evnt, isTopWheel, deltaTop, isRollX, isRollY) => {
      const { elemStore } = tableInternalData;
      const { scrollXLoad, scrollYLoad } = tableReactData;
      const tableBody = refTableBody.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const bodyElem = tableBody.$el;
      const bodyYElem = getRefElem(elemStore["main-body-ySpace"]);
      const bodyXElem = getRefElem(elemStore["main-body-xSpace"]);
      const bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      const bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      const remainSize = isPrevWheelTop === isTopWheel ? Math.max(0, wheelYSize - wheelYTotal) : 0;
      isPrevWheelTop = isTopWheel;
      wheelYSize = Math.abs(isTopWheel ? deltaTop - remainSize : deltaTop + remainSize);
      wheelYInterval = 0;
      wheelYTotal = 0;
      clearTimeout(wheelTime);
      const handleSmooth = () => {
        if (wheelYTotal < wheelYSize) {
          const { fixedType } = props;
          wheelYInterval = Math.max(5, Math.floor(wheelYInterval * 1.5));
          wheelYTotal = wheelYTotal + wheelYInterval;
          if (wheelYTotal > wheelYSize) {
            wheelYInterval = wheelYInterval - (wheelYTotal - wheelYSize);
          }
          const { scrollTop, clientHeight, scrollHeight } = bodyElem;
          const targerTop = scrollTop + wheelYInterval * (isTopWheel ? -1 : 1);
          bodyElem.scrollTop = targerTop;
          if (leftElem) {
            leftElem.scrollTop = targerTop;
          }
          if (rightElem) {
            rightElem.scrollTop = targerTop;
          }
          if (isTopWheel ? targerTop < scrollHeight - clientHeight : targerTop >= 0) {
            wheelTime = setTimeout(handleSmooth, 10);
          }
          $xeTable.dispatchEvent("scroll", {
            type: renderType,
            fixed: fixedType,
            scrollTop: bodyElem.scrollTop,
            scrollLeft: bodyElem.scrollLeft,
            scrollHeight: bodyElem.scrollHeight,
            scrollWidth: bodyElem.scrollWidth,
            bodyHeight,
            bodyWidth,
            isX: isRollX,
            isY: isRollY
          }, evnt);
        }
      };
      handleSmooth();
    };
    const wheelEvent = (evnt) => {
      const { deltaY, deltaX } = evnt;
      const { highlightHoverRow } = tableProps;
      const { scrollYLoad } = tableReactData;
      const { lastScrollTop, lastScrollLeft } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const tableBody = refTableBody.value;
      const scrollBodyElem = refElem.value;
      const bodyElem = tableBody.$el;
      const deltaTop = deltaY;
      const deltaLeft = deltaX;
      const isTopWheel = deltaTop < 0;
      if (isTopWheel ? scrollBodyElem.scrollTop <= 0 : scrollBodyElem.scrollTop >= scrollBodyElem.scrollHeight - scrollBodyElem.clientHeight) {
        return;
      }
      const scrollTop = scrollBodyElem.scrollTop + deltaTop;
      const scrollLeft = bodyElem.scrollLeft + deltaLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      if (isRollY) {
        evnt.preventDefault();
        tableInternalData.lastScrollTop = scrollTop;
        tableInternalData.lastScrollLeft = scrollLeft;
        tableReactData.lastScrollTime = Date.now();
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        handleWheel(evnt, isTopWheel, deltaTop, isRollX, isRollY);
        if (scrollYLoad) {
          $xeTable.triggerScrollYEvent(evnt);
        }
      }
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-body-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
      });
    });
    onBeforeUnmount(() => {
      clearTimeout(wheelTime);
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      let { fixedColumn, fixedType, tableColumn } = props;
      const { keyboardConfig, showOverflow: allColumnOverflow, spanMethod, mouseConfig } = tableProps;
      const { tableData, mergeList, scrollYLoad, isAllOverflow, isDragRowMove } = tableReactData;
      const { visibleColumn } = tableInternalData;
      const { slots } = tableContext;
      const rowOpts = computeRowOpts.value;
      const sYOpts = computeSYOpts.value;
      const emptyOpts = computeEmptyOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      if (fixedType) {
        if (!tableReactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
          if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      if (emptySlot) {
        emptyContent = $xeTable.callSlot(emptySlot, { $table: $xeTable, $grid: $xeTable.xegrid });
      } else {
        const compConf = emptyOpts.name ? renderer4.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          emptyContent = getSlotVNs(rtEmptyView(emptyOpts, { $table: $xeTable }));
        } else {
          emptyContent = tableProps.emptyText || getI18n5("vxe.table.emptyText");
        }
      }
      const ons = {
        onScroll: scrollEvent
      };
      if (sYOpts.mode === "wheel") {
        ons.onWheel = wheelEvent;
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--body-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"], xid: xID }, ons), [
        fixedType ? createCommentVNode() : h("div", {
          ref: refBodyXSpace,
          class: "vxe-body--x-space"
        }),
        h("div", {
          ref: refBodyYSpace,
          class: "vxe-body--y-space"
        }),
        h("table", {
          ref: refBodyTable,
          class: "vxe-table--body",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 
           */
          h("colgroup", {
            ref: refBodyColgroup
          }, tableColumn.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          })),
          /**
           * 
           */
          rowOpts.drag && rowDragOpts.animation ? h(TransitionGroup, {
            ref: refBodyTBody,
            name: `vxe-body--row-list${isDragRowMove ? "" : "-disabled"}`,
            tag: "tbody"
          }, {
            default: () => renderRows(fixedType, tableData, tableColumn)
          }) : h("tbody", {
            ref: refBodyTBody
          }, renderRows(fixedType, tableData, tableColumn))
        ]),
        h("div", {
          class: "vxe-table--checkbox-range"
        }),
        mouseConfig && mouseOpts.area ? h("div", {
          class: "vxe-table--cell-area"
        }, [
          h("span", {
            class: "vxe-table--cell-main-area"
          }, mouseOpts.extension ? [
            h("span", {
              class: "vxe-table--cell-main-area-btn",
              onMousedown(evnt) {
                if ($xeTable.triggerCellAreaExtendMousedownEvent) {
                  $xeTable.triggerCellAreaExtendMousedownEvent(evnt, { $table: $xeTable, fixed: fixedType, type: renderType });
                }
              }
            })
          ] : []),
          h("span", {
            class: "vxe-table--cell-copy-area"
          }),
          h("span", {
            class: "vxe-table--cell-extend-area"
          }),
          h("span", {
            class: "vxe-table--cell-multi-area"
          }),
          h("span", {
            class: "vxe-table--cell-active-area"
          })
        ]) : renderEmptyElement3($xeTable),
        !fixedType ? h("div", {
          class: "vxe-table--empty-block",
          ref: refBodyEmptyBlock
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, emptyContent)
        ]) : renderEmptyElement3($xeTable)
      ]);
    };
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/header.js
var import_xe_utils21 = __toESM(require_xe_utils());
var { renderer: renderer5 } = VxeUI;
var renderType2 = "header";
var header_default = defineComponent({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { refElem: tableRefElem, refTableBody, refLeftContainer, refRightContainer, refCellResizeBar, refCellResizeTip } = $xeTable.getRefMaps();
    const { computeColumnOpts, computeColumnDragOpts, computeResizableOpts } = $xeTable.getComputeMaps();
    const headerColumn = ref([]);
    const refElem = ref();
    const refHeaderTable = ref();
    const refHeaderColgroup = ref();
    const refHeaderTHead = ref();
    const refHeaderXSpace = ref();
    const refHeaderBorderRepair = ref();
    const uploadColumn = () => {
      const { isGroup } = tableReactData;
      headerColumn.value = isGroup ? convertHeaderColumnToRows(props.tableGroupColumn) : [];
    };
    const resizeMousedown = (evnt, params) => {
      const { column } = params;
      const { fixedType } = props;
      const { visibleColumn } = tableInternalData;
      const resizableOpts = computeResizableOpts.value;
      const tableBody = refTableBody.value;
      const tableEl = tableRefElem.value;
      const leftContainerElem = refLeftContainer.value;
      const rightContainerElem = refRightContainer.value;
      const resizeBarElem = refCellResizeBar.value;
      const resizeTipElem = refCellResizeTip.value;
      const { clientX: dragClientX } = evnt;
      const wrapperElem = refElem.value;
      const dragBtnElem = evnt.target;
      const cell = params.cell = dragBtnElem.parentNode;
      let dragLeft = 0;
      const tableBodyElem = tableBody.$el;
      const pos = getOffsetPos(dragBtnElem, wrapperElem);
      const dragBtnWidth = dragBtnElem.clientWidth;
      const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
      const minInterval = getColReMinWidth(params) - dragBtnOffsetWidth;
      let dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
      let dragPosLeft = pos.left + dragBtnOffsetWidth;
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const isLeftFixed = fixedType === "left";
      const isRightFixed = fixedType === "right";
      let fixedOffsetWidth = 0;
      if (isLeftFixed || isRightFixed) {
        const siblingProp = isLeftFixed ? "nextElementSibling" : "previousElementSibling";
        let tempCellElem = cell[siblingProp];
        while (tempCellElem) {
          if (hasClass(tempCellElem, "fixed--hidden")) {
            break;
          } else if (!hasClass(tempCellElem, "col--group")) {
            fixedOffsetWidth += tempCellElem.offsetWidth;
          }
          tempCellElem = tempCellElem[siblingProp];
        }
        if (isRightFixed && rightContainerElem) {
          dragPosLeft = rightContainerElem.offsetLeft + fixedOffsetWidth;
        }
      }
      const updateEvent = function(evnt2) {
        evnt2.stopPropagation();
        evnt2.preventDefault();
        const offsetX = evnt2.clientX - dragClientX;
        let left = dragPosLeft + offsetX;
        const scrollLeft = fixedType ? 0 : tableBodyElem.scrollLeft;
        if (isLeftFixed) {
          left = Math.min(left, (rightContainerElem ? rightContainerElem.offsetLeft : tableBodyElem.clientWidth) - fixedOffsetWidth - minInterval);
        } else if (isRightFixed) {
          dragMinLeft = (leftContainerElem ? leftContainerElem.clientWidth : 0) + fixedOffsetWidth + minInterval;
          left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
        } else {
          dragMinLeft = Math.max(tableBodyElem.scrollLeft, dragMinLeft);
        }
        dragLeft = Math.max(left, dragMinLeft);
        const resizeBarLeft = dragLeft - scrollLeft;
        resizeBarElem.style.left = `${resizeBarLeft}px`;
        if (resizableOpts.showDragTip && resizeTipElem) {
          const tableWidth = tableEl.clientWidth;
          const wrapperRect = wrapperElem.getBoundingClientRect();
          const resizeBarWidth = resizeBarElem.clientWidth;
          const resizeTipWidth = resizeTipElem.clientWidth;
          const resizeTipHeight = resizeTipElem.clientHeight;
          let resizeTipLeft = -resizeTipWidth;
          if (resizeBarLeft < resizeTipWidth + resizeBarWidth) {
            resizeTipLeft = resizeTipWidth + resizeBarWidth - resizeBarLeft;
          } else if (resizeBarLeft > tableWidth) {
            resizeTipLeft += tableWidth - resizeBarLeft;
          }
          resizeTipElem.style.left = `${resizeTipLeft}px`;
          resizeTipElem.style.top = `${Math.min(tableEl.clientHeight - resizeTipHeight, Math.max(0, evnt2.clientY - wrapperRect.y - resizeTipHeight / 2))}px`;
          resizeTipElem.textContent = `${column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft)}px`;
        }
      };
      tableReactData._isResize = true;
      addClass(tableEl, "drag--resize");
      resizeBarElem.style.display = "block";
      document.onmousemove = updateEvent;
      document.onmouseup = function(evnt2) {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        const resizeWidth = column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
        column.resizeWidth = resizeWidth;
        if (resizableOpts.dragMode === "fixed") {
          visibleColumn.forEach((item) => {
            if (item.id !== column.id) {
              if (!item.resizeWidth) {
                item.resizeWidth = item.renderWidth;
              }
            }
          });
        }
        resizeBarElem.style.display = "none";
        tableReactData._isResize = false;
        tableInternalData._lastResizeTime = Date.now();
        $xeTable.analyColumnWidth();
        $xeTable.recalculate(true).then(() => {
          $xeTable.saveCustomStore("update:visible");
          $xeTable.updateCellAreas();
          $xeTable.dispatchEvent("resizable-change", Object.assign(Object.assign({}, params), { resizeWidth }), evnt2);
          setTimeout(() => $xeTable.recalculate(true), 300);
        });
        removeClass(tableEl, "drag--resize");
      };
      updateEvent(evnt);
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const renderRows = (cols, $rowIndex) => {
      const { fixedType } = props;
      const { resizable: allResizable, border, columnKey, headerCellClassName, headerCellStyle, showHeaderOverflow: allColumnHeaderOverflow, headerAlign: allHeaderAlign, align: allAlign, mouseConfig } = tableProps;
      const { currentColumn, scrollXLoad, overflowX, scrollbarWidth } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { disabledMethod: dragDisabledMethod } = columnDragOpts;
      return cols.map((column, $columnIndex) => {
        const { type, showHeaderOverflow, headerAlign, align, headerClassName, editRender, cellRender } = column;
        const colid = column.id;
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer5.get(renderOpts.name) : null;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : !!column.fixed && overflowX;
        const headOverflow = import_xe_utils21.default.eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : "") || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        let showEllipsis = headOverflow === "ellipsis";
        const showTitle = headOverflow === "title";
        const showTooltip = headOverflow === true || headOverflow === "tooltip";
        let hasEllipsis = showTitle || showTooltip || showEllipsis;
        const hasFilter = column.filters && column.filters.some((item) => item.checked);
        const columnIndex = $xeTable.getColumnIndex(column);
        const _columnIndex = $xeTable.getVTColumnIndex(column);
        const params = { $table: $xeTable, $grid: $xeTable.xegrid, $rowIndex, column, columnIndex, $columnIndex, _columnIndex, fixed: fixedType, type: renderType2, isHidden: fixedHiddenColumn, hasFilter };
        const thAttrs = {
          colid,
          colspan: column.colSpan > 1 ? column.colSpan : null,
          rowspan: column.rowSpan > 1 ? column.rowSpan : null
        };
        const thOns = {
          onClick: (evnt) => $xeTable.triggerHeaderCellClickEvent(evnt, params),
          onDblclick: (evnt) => $xeTable.triggerHeaderCellDblclickEvent(evnt, params)
        };
        if (scrollXLoad && !hasEllipsis) {
          showEllipsis = hasEllipsis = true;
        }
        const isColDragCell = columnOpts.drag && columnDragOpts.trigger === "cell";
        let isDisabledDrag = false;
        if (isColDragCell) {
          isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(params));
        }
        if (mouseConfig || isColDragCell) {
          thOns.onMousedown = (evnt) => $xeTable.triggerHeaderCellMousedownEvent(evnt, params);
        }
        if (columnOpts.drag) {
          thOns.onDragstart = $xeTable.handleHeaderCellDragDragstartEvent;
          thOns.onDragend = $xeTable.handleHeaderCellDragDragendEvent;
          thOns.onDragover = $xeTable.handleHeaderCellDragDragoverEvent;
          if (isColDragCell) {
            thOns.onMouseup = $xeTable.handleHeaderCellDragMouseupEvent;
          }
        }
        return h("th", Object.assign(Object.assign(Object.assign({ class: [
          "vxe-header--column",
          colid,
          {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            "col--last": $columnIndex === cols.length - 1,
            "col--fixed": column.fixed,
            "col--group": isColGroup,
            "col--ellipsis": hasEllipsis,
            "fixed--hidden": fixedHiddenColumn,
            "is--sortable": column.sortable,
            "col--filter": !!column.filters,
            "is--filter-active": hasFilter,
            "is--drag-disabled": isDisabledDrag,
            "col--current": currentColumn === column
          },
          headerClassName ? import_xe_utils21.default.isFunction(headerClassName) ? headerClassName(params) : headerClassName : "",
          headerCellClassName ? import_xe_utils21.default.isFunction(headerCellClassName) ? headerCellClassName(params) : headerCellClassName : ""
        ], style: headerCellStyle ? import_xe_utils21.default.isFunction(headerCellStyle) ? headerCellStyle(params) : headerCellStyle : null }, thAttrs), thOns), { key: columnKey || columnOpts.useKey || columnOpts.drag || isColGroup ? colid : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }]
          }, column.renderHeader(params)),
          /**
           * 
           */
          !fixedHiddenColumn && !isColGroup && (import_xe_utils21.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? h("div", {
            class: ["vxe-resizable", {
              "is--line": !border || border === "none"
            }],
            onMousedown: (evnt) => resizeMousedown(evnt, params)
          }) : null
        ]);
      }).concat(scrollbarWidth ? [
        h("th", {
          key: `gr${$rowIndex}`,
          class: "vxe-header--gutter col--gutter"
        })
      ] : []);
    };
    const renderHeads = (headerGroups) => {
      const { fixedType } = props;
      const { headerRowClassName, headerRowStyle } = tableProps;
      const { isDragColMove } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return headerGroups.map((cols, $rowIndex) => {
        const params = { $table: $xeTable, $rowIndex, fixed: fixedType, type: renderType2 };
        if (columnOpts.drag && columnDragOpts.animation) {
          return h(TransitionGroup, {
            name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`,
            tag: "tr",
            class: [
              "vxe-header--row",
              headerRowClassName ? import_xe_utils21.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
            ],
            style: headerRowStyle ? import_xe_utils21.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
          }, {
            default: () => renderRows(cols, $rowIndex)
          });
        }
        return h("tr", {
          class: [
            "vxe-header--row",
            headerRowClassName ? import_xe_utils21.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
          ],
          style: headerRowStyle ? import_xe_utils21.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
        }, renderRows(cols, $rowIndex));
      });
    };
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { showHeaderOverflow: allColumnHeaderOverflow } = tableProps;
      const { isGroup, scrollXLoad, scrollbarWidth } = tableReactData;
      const { visibleColumn } = tableInternalData;
      let headerGroups = headerColumn.value;
      let renderColumnList = tableColumn;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        if (fixedType) {
          if (scrollXLoad || allColumnHeaderOverflow) {
            renderColumnList = fixedColumn;
          }
        }
        headerGroups = [renderColumnList];
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--header-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        fixedType ? createCommentVNode() : h("div", {
          ref: refHeaderXSpace,
          class: "vxe-body--x-space"
        }),
        h("table", {
          ref: refHeaderTable,
          class: "vxe-table--header",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 
           */
          h("colgroup", {
            ref: refHeaderColgroup
          }, renderColumnList.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 
           */
          h("thead", {
            ref: refHeaderTHead
          }, renderHeads(headerGroups))
        ]),
        /**
         * 
         */
        h("div", {
          ref: refHeaderBorderRepair,
          class: "vxe-table--header-border-line"
        })
      ]);
    };
    watch(() => props.tableColumn, uploadColumn);
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { internalData } = $xeTable;
        const { elemStore } = internalData;
        const prefix = `${fixedType || "main"}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { internalData } = $xeTable;
      const { elemStore } = internalData;
      const prefix = `${fixedType || "main"}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/footer.js
var import_xe_utils22 = __toESM(require_xe_utils());
var { renderer: renderer6 } = VxeUI;
var renderType3 = "footer";
function mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeFooterList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeFooterList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
var footer_default = defineComponent({
  name: "VxeTableFooter",
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { refTableHeader, refTableBody, refScrollXHandleElem } = $xeTable.getRefMaps();
    const { computeTooltipOpts, computeColumnOpts, computeColumnDragOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refFooterTable = ref();
    const refFooterColgroup = ref();
    const refFooterTFoot = ref();
    const refFooterXSpace = ref();
    const scrollEvent = (evnt) => {
      const { inVirtualScroll, inBodyScroll } = tableInternalData;
      if (inVirtualScroll) {
        return;
      }
      if (inBodyScroll) {
        return;
      }
      const { fixedType } = props;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = refElem.value;
      if (!footerElem) {
        return;
      }
      const bodyElem = tableBody ? tableBody.$el : null;
      if (!bodyElem) {
        return;
      }
      const xHandleEl = refScrollXHandleElem.value;
      const scrollLeft = footerElem.scrollLeft;
      const isRollX = true;
      const isRollY = false;
      const scrollTop = bodyElem.scrollTop;
      tableInternalData.inFooterScroll = true;
      setScrollLeft(xHandleEl, scrollLeft);
      setScrollLeft(headerElem, scrollLeft);
      setScrollLeft(bodyElem, scrollLeft);
      $xeTable.triggerScrollXEvent(evnt);
      $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
        type: renderType3,
        fixed: fixedType
      });
    };
    const renderRows = (tableColumn, footerTableData, row, $rowIndex, _rowIndex) => {
      const { fixedType } = props;
      const { footerCellClassName, footerCellStyle, footerAlign: allFooterAlign, footerSpanMethod, align: allAlign, columnKey, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { scrollXLoad, overflowX, scrollbarWidth, currentColumn, mergeFooterList } = tableReactData;
      const tooltipOpts = computeTooltipOpts.value;
      const columnOpts = computeColumnOpts.value;
      return tableColumn.map((column, $columnIndex) => {
        const { type, showFooterOverflow, footerAlign, align, footerClassName, editRender, cellRender } = column;
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer6.get(renderOpts.name) : null;
        const showAllTip = tooltipOpts.showAll;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
        const footOverflow = import_xe_utils22.default.eqNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
        const footAlign = footerAlign || (compConf ? compConf.tableFooterCellAlign : "") || allFooterAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        let showEllipsis = footOverflow === "ellipsis";
        const showTitle = footOverflow === "title";
        const showTooltip = footOverflow === true || footOverflow === "tooltip";
        let hasEllipsis = showTitle || showTooltip || showEllipsis;
        const attrs = { colid: column.id };
        const tfOns = {};
        const columnIndex = $xeTable.getColumnIndex(column);
        const _columnIndex = $xeTable.getVTColumnIndex(column);
        const itemIndex = _columnIndex;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeTable.xegrid,
          row,
          rowIndex: _rowIndex,
          _rowIndex,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          itemIndex,
          items: row,
          fixed: fixedType,
          type: renderType3,
          data: footerTableData
        };
        if (scrollXLoad && !hasEllipsis) {
          showEllipsis = hasEllipsis = true;
        }
        if (showTitle || showTooltip || showAllTip) {
          tfOns.onMouseenter = (evnt) => {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              $xeTable.triggerFooterTooltipEvent(evnt, cellParams);
            }
          };
        }
        if (showTooltip || showAllTip) {
          tfOns.onMouseleave = (evnt) => {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          };
        }
        tfOns.onClick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-click", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        tfOns.onDblclick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        if (mergeFooterList.length) {
          const spanRest = mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex);
          if (spanRest) {
            const { rowspan, colspan } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              attrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              attrs.colspan = colspan;
            }
          }
        } else if (footerSpanMethod) {
          const { rowspan = 1, colspan = 1 } = footerSpanMethod(cellParams) || {};
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
        return h("td", Object.assign(Object.assign(Object.assign(Object.assign({ class: ["vxe-footer--column", column.id, {
          [`col--${footAlign}`]: footAlign,
          [`col--${type}`]: type,
          "col--last": $columnIndex === tableColumn.length - 1,
          "fixed--hidden": fixedHiddenColumn,
          "col--ellipsis": hasEllipsis,
          "col--current": currentColumn === column
        }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)] }, attrs), { style: footerCellStyle ? import_xe_utils22.default.isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null }), tfOns), { key: columnKey || columnOpts.useKey || columnOpts.drag ? column.id : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }]
          }, column.renderFooter(cellParams))
        ]);
      }).concat(scrollbarWidth ? [
        h("td", {
          key: `gr${$rowIndex}`,
          class: "vxe-footer--gutter col--gutter"
        })
      ] : []);
    };
    const renderHeads = (footerTableData) => {
      const { fixedType, tableColumn } = props;
      const { footerRowClassName, footerRowStyle } = tableProps;
      const { isDragColMove } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return footerTableData.map((row, $rowIndex) => {
        const _rowIndex = $rowIndex;
        const rowParams = { $table: $xeTable, row, _rowIndex, $rowIndex, fixed: fixedType, type: renderType3 };
        if (columnOpts.drag && columnDragOpts.animation) {
          return h(TransitionGroup, {
            name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`,
            tag: "tr",
            class: [
              "vxe-footer--row",
              footerRowClassName ? import_xe_utils22.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
            ],
            style: footerRowStyle ? import_xe_utils22.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
          }, {
            default: () => renderRows(tableColumn, footerTableData, row, $rowIndex, _rowIndex)
          });
        }
        return h("tr", {
          class: [
            "vxe-footer--row",
            footerRowClassName ? import_xe_utils22.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
          ],
          style: footerRowStyle ? import_xe_utils22.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
        }, renderRows(tableColumn, footerTableData, row, $rowIndex, _rowIndex));
      });
    };
    const renderVN = () => {
      let { fixedType, fixedColumn, tableColumn, footerTableData } = props;
      const { footerSpanMethod, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { visibleColumn } = tableInternalData;
      const { scrollXLoad, scrollbarWidth, mergeFooterList } = tableReactData;
      if (fixedType) {
        if (!tableReactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
          if (!mergeFooterList.length || !footerSpanMethod) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      const ons = {};
      if (!fixedType) {
        ons.onScroll = scrollEvent;
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--footer-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"], xid: xID }, ons), [
        fixedType ? createCommentVNode() : h("div", {
          ref: refFooterXSpace,
          class: "vxe-body--x-space"
        }),
        h("table", {
          ref: refFooterTable,
          class: "vxe-table--footer",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 
           */
          h("colgroup", {
            ref: refFooterColgroup
          }, tableColumn.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 
           */
          h("tfoot", {
            ref: refFooterTFoot
          }, renderHeads(footerTableData))
        ])
      ]);
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/props.js
var { getConfig: getConfig3 } = VxeUI;
var props_default = {
  /**  */
  id: [String, Function],
  // 
  data: Array,
  // 
  height: [Number, String],
  // 
  minHeight: {
    type: [Number, String],
    default: () => getConfig3().table.minHeight
  },
  // 
  maxHeight: [Number, String],
  //  column-config.resizable 
  resizable: {
    type: Boolean,
    default: () => getConfig3().table.resizable
  },
  // 
  stripe: {
    type: Boolean,
    default: () => getConfig3().table.stripe
  },
  // 
  border: {
    type: [Boolean, String],
    default: () => getConfig3().table.border
  },
  // 
  padding: {
    type: Boolean,
    default: () => getConfig3().table.padding
  },
  // 
  round: {
    type: Boolean,
    default: () => getConfig3().table.round
  },
  // 
  size: {
    type: String,
    default: () => getConfig3().table.size || getConfig3().size
  },
  // 
  fit: {
    type: Boolean,
    default: () => getConfig3().table.fit
  },
  // 
  loading: Boolean,
  // 
  align: {
    type: String,
    default: () => getConfig3().table.align
  },
  // 
  headerAlign: {
    type: String,
    default: () => getConfig3().table.headerAlign
  },
  // 
  footerAlign: {
    type: String,
    default: () => getConfig3().table.footerAlign
  },
  // 
  showHeader: {
    type: Boolean,
    default: () => getConfig3().table.showHeader
  },
  // 
  highlightCurrentRow: {
    type: Boolean,
    default: () => getConfig3().table.highlightCurrentRow
  },
  // 
  highlightHoverRow: {
    type: Boolean,
    default: () => getConfig3().table.highlightHoverRow
  },
  // 
  highlightCurrentColumn: {
    type: Boolean,
    default: () => getConfig3().table.highlightCurrentColumn
  },
  // 
  highlightHoverColumn: {
    type: Boolean,
    default: () => getConfig3().table.highlightHoverColumn
  },
  // 
  highlightCell: Boolean,
  // 
  showFooter: Boolean,
  // 
  footerData: Array,
  // 
  footerMethod: Function,
  //  className
  rowClassName: [String, Function],
  //  className
  cellClassName: [String, Function],
  //  className
  headerRowClassName: [String, Function],
  //  className
  headerCellClassName: [String, Function],
  //  className
  footerRowClassName: [String, Function],
  //  className
  footerCellClassName: [String, Function],
  // 
  cellStyle: [Object, Function],
  // 
  headerCellStyle: [Object, Function],
  // 
  footerCellStyle: [Object, Function],
  // 
  rowStyle: [Object, Function],
  // 
  headerRowStyle: [Object, Function],
  // 
  footerRowStyle: [Object, Function],
  // 
  mergeCells: Array,
  // 
  mergeFooterItems: Array,
  // 
  spanMethod: Function,
  // 
  footerSpanMethod: Function,
  // 
  showOverflow: {
    type: [Boolean, String],
    default: () => getConfig3().table.showOverflow
  },
  // 
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => getConfig3().table.showHeaderOverflow
  },
  // 
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => getConfig3().table.showFooterOverflow
  },
  /**  */
  // columnKey  column-config.useKey 
  columnKey: Boolean,
  // rowKey  row-config.useKey 
  rowKey: Boolean,
  // rowId  row-config.keyField 
  rowId: {
    type: String,
    default: () => getConfig3().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => getConfig3().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => getConfig3().table.keepSource
  },
  // 
  autoResize: {
    type: Boolean,
    default: () => getConfig3().table.autoResize
  },
  // 
  syncResize: [Boolean, String, Number],
  // 
  resizeConfig: Object,
  // 
  columnConfig: Object,
  // 
  cellConfig: Object,
  // 
  rowConfig: Object,
  //  rowDragConfig 
  dragConfig: Object,
  // 
  rowDragConfig: Object,
  // 
  columnDragConfig: Object,
  // 
  resizableConfig: Object,
  // 
  seqConfig: Object,
  // 
  sortConfig: Object,
  // 
  filterConfig: Object,
  // 
  radioConfig: Object,
  // 
  checkboxConfig: Object,
  // tooltip 
  tooltipConfig: Object,
  // 
  exportConfig: Object,
  // 
  importConfig: Object,
  // 
  printConfig: Object,
  // 
  expandConfig: Object,
  // 
  treeConfig: Object,
  // 
  menuConfig: Object,
  // 
  mouseConfig: Object,
  // 
  areaConfig: Object,
  // 
  keyboardConfig: Object,
  // /
  clipConfig: Object,
  // /
  fnrConfig: Object,
  // 
  editConfig: Object,
  // 
  validConfig: Object,
  // 
  editRules: Object,
  // 
  loadingConfig: Object,
  // 
  emptyRender: Object,
  // 
  customConfig: Object,
  // 
  scrollX: Object,
  // 
  scrollY: Object,
  // 
  animat: {
    type: Boolean,
    default: () => getConfig3().table.animat
  },
  // 
  delayHover: {
    type: Number,
    default: () => getConfig3().table.delayHover
  },
  // 
  params: Object
};

// node_modules/vxe-table/es/table/src/emits.js
var emits_default = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "cell-delete-value",
  "cell-backspace-value",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "row-dragstart",
  "row-dragover",
  "row-dragend",
  "column-dragstart",
  "column-dragover",
  "column-dragend",
  "enter-append-row",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "scroll-boundary",
  "custom",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-selection",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
];

// node_modules/vxe-table/es/table/module/custom/panel.js
var import_xe_utils23 = __toESM(require_xe_utils());
var { getI18n: getI18n6, getIcon: getIcon4, renderEmptyElement: renderEmptyElement4 } = VxeUI;
var panel_default = defineComponent({
  name: "TableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIDrawerComponent = VxeUI.getComponent("VxeDrawer");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUINumberInputComponent = VxeUI.getComponent("VxeNumberInput");
    const VxeUIRadioGroupComponent = VxeUI.getComponent("VxeRadioGroup");
    const $xeTable = inject("$xeTable", {});
    const { props: tableProps, reactData, internalData } = $xeTable;
    const { computeCustomOpts, computeColumnDragOpts, computeColumnOpts, computeIsMaxFixedColumn, computeResizableOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const bodyElemRef = ref();
    const refDragLineElem = ref();
    const refDragTipElem = ref();
    const dragColumnRef = ref();
    let prevDragCol;
    let prevDragToChild = false;
    let prevDragPos;
    const handleWrapperMouseenterEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = true;
      $xeTable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xeTable.customCloseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = ({ $event }) => {
      reactData.isCustomStatus = true;
      $xeTable.saveCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("confirm", $event);
    };
    const cancelCloseEvent = ({ $event }) => {
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("close", $event);
    };
    const cancelCustomEvent = ({ $event }) => {
      $xeTable.cancelCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("cancel", $event);
    };
    const handleResetCustomEvent = (evnt) => {
      $xeTable.resetCustom(true);
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("reset", evnt);
    };
    const resetCustomEvent = ({ $event }) => {
      if (VxeUI.modal) {
        VxeUI.modal.confirm({
          content: getI18n6("vxe.custom.cstmConfirmRestore"),
          className: "vxe-table--ignore-clear",
          escClosable: true
        }).then((type) => {
          if (type === "confirm") {
            handleResetCustomEvent($event);
          }
        });
      } else {
        handleResetCustomEvent($event);
      }
    };
    const handleOptionCheck = (column) => {
      const { customColumnList } = reactData;
      const matchObj = import_xe_utils23.default.findTree(customColumnList, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.renderVisible = parent.children.every((column2) => column2.renderVisible);
          parent.halfVisible = !parent.renderVisible && parent.children.some((column2) => column2.renderVisible || column2.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = (column) => {
      const isChecked = !column.renderVisible;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        import_xe_utils23.default.eachTree([column], (item) => {
          item.visible = isChecked;
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils23.default.eachTree([column], (item) => {
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
      }
      handleOptionCheck(column);
      $xeTable.checkCustomStatus();
    };
    const changeColumnWidth = (column) => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderResizeWidth !== column.renderWidth) {
          column.resizeWidth = column.renderResizeWidth;
          column.renderWidth = column.renderResizeWidth;
          reactData.isCustomStatus = true;
          $xeTable.handleCustom();
          $xeTable.saveCustomStore("update:width");
        }
      }
    };
    const changeFixedOption = (column, colFixed) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderFixed === colFixed) {
          import_xe_utils23.default.eachTree([column], (col) => {
            col.fixed = "";
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            import_xe_utils23.default.eachTree([column], (col) => {
              col.fixed = colFixed;
              col.renderFixed = colFixed;
            });
          }
        }
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:fixed");
      } else {
        if (column.renderFixed === colFixed) {
          import_xe_utils23.default.eachTree([column], (col) => {
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            import_xe_utils23.default.eachTree([column], (col) => {
              col.renderFixed = colFixed;
            });
          }
        }
      }
    };
    const allOptionEvent = () => {
      $xeTable.toggleCustomAllCheckbox();
    };
    const showDropTip = (evnt, optEl, showLine, dragPos) => {
      const el2 = bodyElemRef.value;
      if (!el2) {
        return;
      }
      const wrapperRect = el2.getBoundingClientRect();
      if (optEl) {
        const dragLineEl = refDragLineElem.value;
        if (dragLineEl) {
          if (showLine) {
            const optRect = optEl.getBoundingClientRect();
            dragLineEl.style.display = "block";
            dragLineEl.style.top = `${Math.max(1, optRect.y + el2.scrollTop - wrapperRect.y)}px`;
            dragLineEl.style.height = `${optRect.height}px`;
            dragLineEl.style.width = `${optRect.width}px`;
            dragLineEl.setAttribute("drag-pos", dragPos);
            dragLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            dragLineEl.style.display = "";
          }
        }
      }
      const dragTipEl = refDragTipElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "block";
        dragTipEl.style.top = `${Math.min(el2.clientHeight + el2.scrollTop - dragTipEl.clientHeight, evnt.clientY + el2.scrollTop - wrapperRect.y)}px`;
        dragTipEl.style.left = `${Math.min(el2.clientWidth + el2.scrollLeft - dragTipEl.clientWidth, evnt.clientX + el2.scrollLeft - wrapperRect.x)}px`;
        dragTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const dragTipEl = refDragTipElem.value;
      const dragLineEl = refDragLineElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "";
      }
      if (dragLineEl) {
        dragLineEl.style.display = "";
      }
    };
    const sortMousedownEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      const colid = trEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      trEl.draggable = true;
      dragColumnRef.value = column;
      addClass(trEl, "active--drag-origin");
    };
    const sortMouseupEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      hideDropTip();
      trEl.draggable = false;
      dragColumnRef.value = null;
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragstartEvent = (evnt) => {
      if (evnt.dataTransfer) {
        const img = new Image();
        img.src = tpImg;
        evnt.dataTransfer.setDragImage(img, 0, 0);
      }
    };
    const sortDragendEvent = (evnt) => {
      const { mouseConfig } = tableProps;
      const { customColumnList } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const trEl = evnt.currentTarget;
      const dragCol = dragColumnRef.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod } = columnDragOpts;
      const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
      if (prevDragCol && dragCol) {
        if (prevDragCol !== dragCol) {
          const oldColumn = dragCol;
          const newColumn = prevDragCol;
          Promise.resolve(dragEndMethod ? dragEndMethod({
            oldColumn,
            newColumn,
            dragPos: prevDragPos,
            offsetIndex: dragOffsetIndex
          }) : true).then((status) => {
            if (!status) {
              return;
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            import_xe_utils23.default.eachTree([oldColumn], (column) => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            if (immediate) {
              if (oldColumn.parentId && newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!isSelfToChildDrag) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n6("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else if (oldColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!isSelfToChildDrag) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n6("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils23.default.findTree(collectColumn, (item) => item.id === oldColumn.id);
              if (isSelfToChildStatus && isSelfToChildDrag) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = oldColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = oldColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  oldColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils23.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isToChildDrag && prevDragToChild) {
                  oldColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([oldColumn]);
                } else {
                  oldColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, oldColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils23.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index2 + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
            } else {
              oafIndex = import_xe_utils23.default.findIndexOf(customColumnList, (item) => item.id === oldColumn.id);
              customColumnList.splice(oafIndex, 1);
              nafIndex = import_xe_utils23.default.findIndexOf(customColumnList, (item) => item.id === newColumn.id);
              customColumnList.splice(nafIndex + dragOffsetIndex, 0, oldColumn);
            }
            reactData.isDragColMove = true;
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            $xeTable.dispatchEvent("column-dragend", {
              oldColumn,
              newColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            }, evnt);
            if (immediate) {
              reactData.customColumnList = collectColumn.slice(0);
              $xeTable.refreshColumn(true).then(() => {
                $xeTable.updateCellAreas();
                $xeTable.handleCustom();
                $xeTable.saveCustomStore("update:sort");
              });
            }
          }).catch(() => {
          });
        }
      }
      hideDropTip();
      dragColumnRef.value = null;
      trEl.draggable = false;
      trEl.removeAttribute("drag-pos");
      removeClass(trEl, "active--drag-target");
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragoverEvent = (evnt) => {
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isToChildDrag } = columnDragOpts;
      const optEl = evnt.currentTarget;
      const hasCtrlKey = evnt.ctrlKey;
      const colid = optEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      const dragCol = dragColumnRef.value;
      if (column && (isCrossDrag || column.level === 1)) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - optEl.getBoundingClientRect().y;
        const dragPos = offsetY < optEl.clientHeight / 2 ? "top" : "bottom";
        if (dragCol && dragCol.id === column.id || !isCrossDrag && column.level > 1 || !immediate && column.level > 1 || column.renderFixed) {
          showDropTip(evnt, optEl, false, dragPos);
          return;
        }
        prevDragToChild = !!(isToChildDrag && hasCtrlKey && immediate);
        prevDragCol = column;
        prevDragPos = dragPos;
        showDropTip(evnt, optEl, true, dragPos);
      }
    };
    const renderDragTip = () => {
      const dragCol = dragColumnRef.value;
      return h("div", {}, [
        h("div", {
          ref: refDragLineElem,
          class: "vxe-table-custom-popup--drag-line"
        }),
        h("div", {
          ref: refDragTipElem,
          class: "vxe-table-custom-popup--drag-tip"
        }, [
          h("div", {
            class: "vxe-table-custom-popup--drag-tip-wrapper"
          }, [
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-status"
            }, [
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-normal-status", getIcon4().TABLE_DRAG_STATUS_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-sub-status", getIcon4().TABLE_DRAG_STATUS_SUB_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-disabled-status", getIcon4().TABLE_DRAG_DISABLED]
              })
            ]),
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-content"
            }, getI18n6("vxe.custom.cstmDragTarget", [dragCol && dragCol.type !== "html" ? dragCol.getTitle() : ""]))
          ])
        ])
      ]);
    };
    const renderSimplePanel = () => {
      const { customStore } = props;
      const { isCustomStatus, customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { maxHeight } = customStore;
      const { checkMethod, visibleMethod, allowVisible, allowSort, allowFixed, trigger, placement } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const colVNs = [];
      const customWrapperOns = {};
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      if (trigger === "hover") {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      const params = {
        $table: $xeTable,
        $grid: $xeTable.xegrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils23.default.eachTree(customColumnList, (column, index2, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          const isHidden = !isChecked;
          colVNs.push(h("li", {
            key: column.id,
            colid: column.id,
            class: ["vxe-table-custom--option", `level--${column.level}`, {
              "is--hidden": isDisabled || isHidden,
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isChecked,
                "is--indeterminate": isIndeterminate,
                "is--disabled": isDisabled
              }],
              title: getI18n6("vxe.custom.setting.colVisible"),
              onClick: () => {
                if (!isDisabled) {
                  changeCheckboxOption(column);
                }
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-table-custom--name-option"
            }, [
              allowSort && ((isCrossDrag ? immediate : false) || column.level === 1) ? h("div", {
                class: "vxe-table-custom--sort-option"
              }, [
                h("span", Object.assign({ class: ["vxe-table-custom--sort-btn", {
                  "is--disabled": isDisabled || isHidden || column.renderFixed
                }], title: getI18n6("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden || column.renderFixed ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon4().TABLE_CUSTOM_SORT
                  })
                ])
              ]) : createCommentVNode(),
              column.type === "html" ? h("div", {
                key: "1",
                class: "vxe-table-custom--checkbox-label",
                innerHTML: colTitle
              }) : h("div", {
                key: "0",
                class: "vxe-table-custom--checkbox-label"
              }, colTitle)
            ]),
            !parent && allowFixed ? h("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "left" ? getIcon4().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : getIcon4().TOOLBAR_TOOLS_FIXED_LEFT,
                status: column.renderFixed === "left" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n6(column.renderFixed === "left" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedLeft"),
                onClick: () => {
                  changeFixedOption(column, "left");
                }
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "right" ? getIcon4().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : getIcon4().TOOLBAR_TOOLS_FIXED_RIGHT,
                status: column.renderFixed === "right" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n6(column.renderFixed === "right" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedRight"),
                onClick: () => {
                  changeFixedOption(column, "right");
                }
              }) : createCommentVNode()
            ]) : createCommentVNode()
          ]));
        }
      });
      return h("div", {
        ref: refElem,
        key: "simple",
        class: ["vxe-table-custom-wrapper", `placement--${placement}`, {
          "is--active": customStore.visible
        }],
        style: maxHeight && !["left", "right"].includes(placement) ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, customStore.visible ? [
        h("div", {
          class: "vxe-table-custom--header"
        }, headerSlot ? $xeTable.callSlot(headerSlot, params) : [
          h("ul", {
            class: "vxe-table-custom--panel-list"
          }, [
            h("li", {
              class: "vxe-table-custom--option"
            }, [
              allowVisible ? h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isAllChecked,
                  "is--indeterminate": isAllIndeterminate
                }],
                title: getI18n6("vxe.table.allTitle"),
                onClick: allOptionEvent
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                }),
                h("span", {
                  class: "vxe-checkbox--label"
                }, getI18n6("vxe.toolbar.customAll"))
              ]) : h("span", {
                class: "vxe-checkbox--label"
              }, getI18n6("vxe.table.customTitle"))
            ])
          ])
        ]),
        h("div", {
          ref: bodyElemRef,
          class: "vxe-table-custom--body"
        }, [
          topSlot ? h("div", {
            class: "vxe-table-custom--panel-top"
          }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
          defaultSlot ? h("div", {
            class: "vxe-table-custom--panel-body"
          }, $xeTable.callSlot(defaultSlot, params)) : h(TransitionGroup, Object.assign({ class: "vxe-table-custom--panel-list", name: "vxe-table-custom--list", tag: "ul" }, customWrapperOns), {
            default: () => colVNs
          }),
          bottomSlot ? h("div", {
            class: "vxe-table-custom--panel-bottom"
          }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
          renderDragTip()
        ]),
        customOpts.showFooter ? h("div", {
          class: "vxe-table-custom--footer"
        }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
          h("div", {
            class: "vxe-table-custom--footer-buttons"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.resetButtonText || getI18n6("vxe.table.customRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : createCommentVNode(),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.closeButtonText || getI18n6("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.cancelButtonText || getI18n6("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : createCommentVNode(),
            immediate ? createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              status: "primary",
              content: customOpts.confirmButtonText || getI18n6("vxe.table.customConfirm"),
              onClick: confirmCustomEvent
            }) : createCommentVNode()
          ])
        ]) : null
      ] : []);
    };
    const renderPopupPanel = () => {
      const { customStore } = props;
      const { resizable: allResizable } = tableProps;
      const { isCustomStatus, customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { mode, modalOptions, drawerOptions, allowVisible, allowSort, allowFixed, allowResizable, checkMethod, visibleMethod } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      const resizableOpts = computeResizableOpts.value;
      const { minWidth: reMinWidth, maxWidth: reMaxWidth } = resizableOpts;
      const modalOpts = Object.assign({}, modalOptions);
      const drawerOpts = Object.assign({}, drawerOptions);
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const trVNs = [];
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      const params = {
        $table: $xeTable,
        $grid: $xeTable.xegrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils23.default.eachTree(customColumnList, (column, index2, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          let customMinWidth = 0;
          let customMaxWidth = 0;
          if (allowResizable) {
            const resizeParams = {
              $table: $xeTable,
              column,
              columnIndex: index2,
              $columnIndex: index2,
              $rowIndex: -1
            };
            if (reMinWidth) {
              customMinWidth = import_xe_utils23.default.toNumber(import_xe_utils23.default.isFunction(reMinWidth) ? reMinWidth(resizeParams) : reMinWidth);
            }
            if (reMaxWidth) {
              customMaxWidth = import_xe_utils23.default.toNumber(import_xe_utils23.default.isFunction(reMaxWidth) ? reMaxWidth(resizeParams) : reMaxWidth);
            }
          }
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          const isHidden = !isChecked;
          trVNs.push(h("tr", {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isChecked,
                  "is--indeterminate": isIndeterminate,
                  "is--disabled": isDisabled
                }],
                title: getI18n6("vxe.custom.setting.colVisible"),
                onClick: () => {
                  if (!isDisabled) {
                    changeCheckboxOption(column);
                  }
                }
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]) : createCommentVNode(),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              h("div", {
                class: "vxe-table-custom-popup--name"
              }, [
                allowSort ? (isCrossDrag ? immediate : false) || column.level === 1 ? h("div", Object.assign({ class: ["vxe-table-custom-popup--column-sort-btn", {
                  "is--disabled": isDisabled || isHidden || column.renderFixed
                }], title: getI18n6("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden || column.renderFixed ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon4().TABLE_CUSTOM_SORT
                  })
                ]) : h("div", {
                  class: "vxe-table-custom-popup--column-sort-placeholder"
                }) : createCommentVNode(),
                column.type === "html" ? h("div", {
                  key: "1",
                  class: "vxe-table-custom-popup--title",
                  innerHTML: colTitle
                }) : h("div", {
                  key: "0",
                  class: "vxe-table-custom-popup--title",
                  title: colTitle
                }, colTitle)
              ])
            ]),
            allowResizable ? h("td", {
              class: "vxe-table-custom-popup--column-item col--resizable"
            }, [
              column.children && column.children.length || !(import_xe_utils23.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? h("span", "-") : VxeUINumberInputComponent ? h(VxeUINumberInputComponent, {
                type: "integer",
                immediate: false,
                disabled: isDisabled || isHidden,
                modelValue: column.renderResizeWidth,
                min: customMinWidth || void 0,
                max: customMaxWidth || void 0,
                "onUpdate:modelValue"(value) {
                  const width = Math.max(0, Number(value));
                  column.renderResizeWidth = width;
                },
                onChange() {
                  changeColumnWidth(column);
                }
              }) : createCommentVNode()
            ]) : createCommentVNode(),
            allowFixed ? h("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              parent ? h("span", "-") : VxeUIRadioGroupComponent ? h(VxeUIRadioGroupComponent, {
                modelValue: column.renderFixed || "",
                type: "button",
                size: "mini",
                disabled: isDisabled || isHidden,
                options: [
                  { label: getI18n6("vxe.custom.setting.fixedLeft"), value: "left", disabled: isDisabled || isHidden || isMaxFixedColumn },
                  { label: getI18n6("vxe.custom.setting.fixedUnset"), value: "", disabled: isDisabled || isHidden },
                  { label: getI18n6("vxe.custom.setting.fixedRight"), value: "right", disabled: isDisabled || isHidden || isMaxFixedColumn }
                ],
                "onUpdate:modelValue"(value) {
                  changeFixedOption(column, value);
                }
              }) : createCommentVNode()
            ]) : createCommentVNode()
          ]));
        }
      });
      const scopedSlots = {
        default: () => {
          if (defaultSlot) {
            return $xeTable.callSlot(defaultSlot, params);
          }
          return h("div", {
            ref: bodyElemRef,
            class: "vxe-table-custom-popup--body"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-custom-popup--table-top"
            }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
            h("div", {
              class: "vxe-table-custom-popup--table-wrapper"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  allowVisible ? h("col", {
                    class: "vxe-table-custom-popup--table-col-seq"
                  }) : createCommentVNode(),
                  h("col", {
                    class: "vxe-table-custom-popup--table-col-title"
                  }),
                  allowResizable ? h("col", {
                    class: "vxe-table-custom-popup--table-col-width"
                  }) : createCommentVNode(),
                  allowFixed ? h("col", {
                    class: "vxe-table-custom-popup--table-col-fixed"
                  }) : createCommentVNode()
                ]),
                h("thead", {}, [
                  h("tr", {}, [
                    allowVisible ? h("th", {}, [
                      h("div", {
                        class: ["vxe-table-custom--checkbox-option", {
                          "is--checked": isAllChecked,
                          "is--indeterminate": isAllIndeterminate
                        }],
                        title: getI18n6("vxe.table.allTitle"),
                        onClick: allOptionEvent
                      }, [
                        h("span", {
                          class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                        }),
                        h("span", {
                          class: "vxe-checkbox--label"
                        }, getI18n6("vxe.toolbar.customAll"))
                      ])
                    ]) : createCommentVNode(),
                    h("th", {}, getI18n6("vxe.custom.setting.colTitle")),
                    allowResizable ? h("th", {}, getI18n6("vxe.custom.setting.colResizable")) : createCommentVNode(),
                    allowFixed ? h("th", {}, getI18n6(`vxe.custom.setting.${maxFixedSize ? "colFixedMax" : "colFixed"}`, [maxFixedSize])) : createCommentVNode()
                  ])
                ]),
                h(TransitionGroup, {
                  class: "vxe-table-custom--panel-list",
                  tag: "tbody",
                  name: "vxe-table-custom--list"
                }, {
                  default: () => trVNs
                })
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-custom-popup--table-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
            renderDragTip()
          ]);
        },
        footer: () => {
          if (footerSlot) {
            return $xeTable.callSlot(footerSlot, params);
          }
          return h("div", {
            class: "vxe-table-custom-popup--footer"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.resetButtonText || getI18n6("vxe.custom.cstmRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : createCommentVNode(),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.closeButtonText || getI18n6("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.cancelButtonText || getI18n6("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : createCommentVNode(),
            immediate ? createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              status: "primary",
              content: customOpts.confirmButtonText || getI18n6("vxe.custom.cstmConfirm"),
              onClick: confirmCustomEvent
            }) : createCommentVNode()
          ]);
        }
      };
      if (headerSlot) {
        scopedSlots.header = () => $xeTable.callSlot(headerSlot, params);
      }
      if (mode === "drawer") {
        return VxeUIDrawerComponent ? h(VxeUIDrawerComponent, {
          key: "drawer",
          className: ["vxe-table-custom-drawer-wrapper", "vxe-table--ignore-clear", drawerOpts.className || ""].join(" "),
          modelValue: customStore.visible,
          title: drawerOpts.title || getI18n6("vxe.custom.cstmTitle"),
          width: drawerOpts.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
          position: drawerOpts.position,
          resize: !!drawerOpts.resize,
          escClosable: !!drawerOpts.escClosable,
          maskClosable: !!drawerOpts.maskClosable,
          destroyOnClose: true,
          showFooter: true,
          "onUpdate:modelValue"(value) {
            customStore.visible = value;
          }
        }, scopedSlots) : createCommentVNode();
      }
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        key: "modal",
        className: ["vxe-table-custom-modal-wrapper", "vxe-table--ignore-clear", modalOpts.className || ""].join(" "),
        modelValue: customStore.visible,
        title: modalOpts.title || getI18n6("vxe.custom.cstmTitle"),
        width: modalOpts.width || Math.min(880, document.documentElement.clientWidth),
        minWidth: modalOpts.minWidth || 700,
        height: modalOpts.height || Math.min(680, document.documentElement.clientHeight),
        minHeight: modalOpts.minHeight || 400,
        showZoom: modalOpts.showZoom,
        showMaximize: modalOpts.showMaximize,
        showMinimize: modalOpts.showMinimize,
        mask: modalOpts.mask,
        lockView: modalOpts.lockView,
        resize: modalOpts.resize,
        escClosable: !!modalOpts.escClosable,
        maskClosable: !!modalOpts.maskClosable,
        destroyOnClose: true,
        showFooter: true,
        "onUpdate:modelValue"(value) {
          customStore.visible = value;
        }
      }, scopedSlots) : createCommentVNode();
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (["modal", "drawer", "popup"].includes(`${customOpts.mode}`)) {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    if (true) {
      nextTick(() => {
        const customOpts = computeCustomOpts.value;
        const { mode } = customOpts;
        if (!VxeUIModalComponent) {
          errLog("vxe.error.reqComp", ["vxe-modal"]);
        }
        if (!VxeUIDrawerComponent && mode === "drawer") {
          errLog("vxe.error.reqComp", ["vxe-drawer"]);
        }
        if (!VxeUIButtonComponent) {
          errLog("vxe.error.reqComp", ["vxe-button"]);
        }
        if (!VxeUINumberInputComponent) {
          errLog("vxe.error.reqComp", ["vxe-number-input"]);
        }
        if (!VxeUIRadioGroupComponent) {
          errLog("vxe.error.reqComp", ["vxe-radio-group"]);
        }
      });
    }
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/filter/panel.js
var { getI18n: getI18n7, getIcon: getIcon5, renderer: renderer7 } = VxeUI;
var panel_default2 = defineComponent({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: Object
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData, internalData: tableInternalData, getComputeMaps } = $xeTable;
    const { computeFilterOpts } = getComputeMaps();
    const computeHasCheckOption = computed(() => {
      const { filterStore } = props;
      return filterStore && filterStore.options.some((option2) => option2.checked);
    });
    const filterCheckAllEvent = (evnt, value) => {
      const { filterStore } = props;
      filterStore.options.forEach((option2) => {
        option2._checked = value;
        option2.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    const confirmFilter = (evnt) => {
      $xeTable.handleFilterConfirmFilter(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
    };
    const resetFilter = (evnt) => {
      $xeTable.handleFilterResetFilter(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
    };
    const changeOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeOption(evnt, checked, item);
    };
    const changeAllOption = (evnt, checked) => {
      const { filterStore } = props;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    const $panel = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    const renderOptions = (filterRender, compConf) => {
      const { filterStore } = props;
      const { column, multiple, maxHeight } = filterStore;
      const slots = column ? column.slots : null;
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xeTable });
      const rtFilter = compConf ? compConf.renderTableFilter || compConf.renderFilter : null;
      if (filterSlot) {
        return [
          h("div", {
            class: "vxe-table--filter-template"
          }, $xeTable.callSlot(filterSlot, params))
        ];
      } else if (rtFilter) {
        return [
          h("div", {
            class: "vxe-table--filter-template"
          }, getSlotVNs(rtFilter(filterRender, params)))
        ];
      }
      const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some((item) => item._checked);
      const isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [
        h("ul", {
          class: "vxe-table--filter-header"
        }, [
          h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": isAllChecked,
              "is--indeterminate": isAllIndeterminate
            }],
            title: getI18n7(multiple ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (evnt) => {
              changeAllOption(evnt, !filterStore.isAllSelected);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon5().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon5().TABLE_CHECKBOX_CHECKED : getIcon5().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, getI18n7("vxe.table.allFilter"))
          ]))
        ]),
        h("ul", {
          class: "vxe-table--filter-body",
          style: maxHeight ? {
            maxHeight: `${maxHeight}px`
          } : {}
        }, filterStore.options.map((item) => {
          const isChecked = item._checked;
          const isIndeterminate = false;
          return h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": item._checked
            }],
            title: item.label,
            onClick: (evnt) => {
              changeOption(evnt, !item._checked, item);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isIndeterminate ? getIcon5().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon5().TABLE_CHECKBOX_CHECKED : getIcon5().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, formatText(item.label, 1))
          ]));
        }))
      ];
    };
    const renderFooters = () => {
      const { filterStore } = props;
      const { column, multiple } = filterStore;
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const { filterRender } = column;
      const compConf = isEnableConf(filterRender) ? renderer7.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (compConf ? !(compConf.showTableFilterFooter === false || compConf.showFilterFooter === false || compConf.isFooter === false) : true) ? [
        h("div", {
          class: "vxe-table--filter-footer"
        }, [
          h("button", {
            class: {
              "is--disabled": isDisabled
            },
            disabled: isDisabled,
            onClick: confirmFilter
          }, filterOpts.confirmButtonText || getI18n7("vxe.table.confirmFilter")),
          h("button", {
            onClick: resetFilter
          }, filterOpts.resetButtonText || getI18n7("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    const renderVN = () => {
      const { filterStore } = props;
      const { initStore } = tableReactData;
      const { column } = filterStore;
      const filterRender = column ? column.filterRender : null;
      const compConf = isEnableConf(filterRender) ? renderer7.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.tableFilterClassName || compConf.filterClassName : "";
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xeTable });
      return h("div", {
        class: [
          "vxe-table--filter-wrapper",
          "filter--prevent-default",
          getPropClass(filterClassName, params),
          {
            "is--animat": $xeTable.props.animat,
            "is--multiple": filterStore.multiple,
            "is--active": filterStore.visible
          }
        ],
        style: filterStore.style
      }, initStore.filter && column ? renderOptions(filterRender, compConf).concat(renderFooters()) : []);
    };
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/export/import-panel.js
var import_xe_utils24 = __toESM(require_xe_utils());
var { getI18n: getI18n8, getIcon: getIcon6 } = VxeUI;
var import_panel_default = defineComponent({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const $xeTable = inject("$xeTable", {});
    const { computeImportOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      loading: false
    });
    const refFileBtn = ref();
    const computeSelectName = computed(() => {
      const { storeData: storeData2 } = props;
      return `${storeData2.filename}.${storeData2.type}`;
    });
    const computeHasFile = computed(() => {
      const { storeData: storeData2 } = props;
      return storeData2.file && storeData2.type;
    });
    const computeParseTypeLabel = computed(() => {
      const { storeData: storeData2 } = props;
      const { type, typeList } = storeData2;
      if (type) {
        const selectItem = import_xe_utils24.default.find(typeList, (item) => type === item.value);
        return selectItem ? selectItem.label : "*.*";
      }
      return `*.${typeList.map((item) => item.value).join(", *.")}`;
    });
    const clearFileEvent = () => {
      const { storeData: storeData2 } = props;
      Object.assign(storeData2, {
        filename: "",
        sheetName: "",
        type: ""
      });
    };
    const selectFileEvent = () => {
      const { storeData: storeData2, defaultOptions } = props;
      $xeTable.readFile(defaultOptions).then((params) => {
        const { file } = params;
        Object.assign(storeData2, parseFile(file), { file });
      }).catch((e16) => e16);
    };
    const showEvent = () => {
      nextTick(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const { storeData: storeData2 } = props;
      storeData2.visible = false;
    };
    const importEvent = () => {
      const { storeData: storeData2, defaultOptions } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xeTable.importByFile(storeData2.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData2.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const { defaultOptions, storeData: storeData2 } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_IMPORT_MODAL",
        modelValue: storeData2.visible,
        title: getI18n8("vxe.import.impTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData2.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeTable.xegrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : createCommentVNode(),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  h("tr", [
                    h("td", getI18n8("vxe.import.impFile")),
                    h("td", [
                      hasFile ? h("div", {
                        class: "vxe-table-export--selected--file",
                        title: selectName
                      }, [
                        h("span", selectName),
                        h("i", {
                          class: getIcon6().INPUT_CLEAR,
                          onClick: clearFileEvent
                        })
                      ]) : h("button", {
                        ref: refFileBtn,
                        class: "vxe-table-export--select--file",
                        onClick: selectFileEvent
                      }, getI18n8("vxe.import.impSelect"))
                    ])
                  ]),
                  h("tr", [
                    h("td", getI18n8("vxe.import.impType")),
                    h("td", parseTypeLabel)
                  ]),
                  h("tr", [
                    h("td", getI18n8("vxe.import.impMode")),
                    h("td", [
                      VxeUISelectComponent ? h(VxeUISelectComponent, {
                        modelValue: defaultOptions.mode,
                        options: storeData2.modeList,
                        "onUpdate:modelValue"(value) {
                          defaultOptions.mode = value;
                        }
                      }) : createCommentVNode()
                    ])
                  ])
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : createCommentVNode()
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeTable.xegrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n8("vxe.import.impCancel"),
                onClick: cancelEvent
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                status: "primary",
                disabled: !hasFile || reactData.loading,
                content: getI18n8("vxe.import.impConfirm"),
                onClick: importEvent
              }) : createCommentVNode()
            ])
          ]);
        }
      }) : createCommentVNode();
    };
    if (true) {
      nextTick(() => {
        if (!VxeUIModalComponent) {
          errLog("vxe.error.reqComp", ["vxe-modal"]);
        }
        if (!VxeUIButtonComponent) {
          errLog("vxe.error.reqComp", ["vxe-button"]);
        }
        if (!VxeUISelectComponent) {
          errLog("vxe.error.reqComp", ["vxe-select"]);
        }
      });
    }
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/export/export-panel.js
var import_xe_utils25 = __toESM(require_xe_utils());
var { getI18n: getI18n9, getIcon: getIcon7 } = VxeUI;
var export_panel_default = defineComponent({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const VxeUIInputComponent = VxeUI.getComponent("VxeInput");
    const VxeUICheckboxComponent = VxeUI.getComponent("VxeCheckbox");
    const $xeTable = inject("$xeTable", {});
    const { computeExportOpts, computePrintOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = ref();
    const xInputFilename = ref();
    const xInputSheetname = ref();
    const computeCheckedAll = computed(() => {
      const { storeData: storeData2 } = props;
      return storeData2.columns.every((column) => column.checked);
    });
    const computeShowSheet = computed(() => {
      const { defaultOptions } = props;
      return ["html", "xml", "xlsx", "pdf"].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = computed(() => {
      const { storeData: storeData2, defaultOptions } = props;
      return !defaultOptions.original && defaultOptions.mode === "current" && (storeData2.isPrint || ["html", "xlsx"].indexOf(defaultOptions.type) > -1);
    });
    const computeSupportStyle = computed(() => {
      const { defaultOptions } = props;
      return !defaultOptions.original && ["xlsx"].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = (column) => {
      const { storeData: storeData2 } = props;
      const matchObj = import_xe_utils25.default.findTree(storeData2.columns, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every((column2) => column2.checked);
          parent.halfChecked = !parent.checked && parent.children.some((column2) => column2.checked || column2.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const { storeData: storeData2 } = props;
      const columns = storeData2.columns;
      reactData.isAll = columns.every((column) => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some((column) => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = (column) => {
      const isChecked = !column.checked;
      import_xe_utils25.default.eachTree([column], (item) => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const { storeData: storeData2 } = props;
      const isAll = !reactData.isAll;
      import_xe_utils25.default.eachTree(storeData2.columns, (column) => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      nextTick(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const { storeData: storeData2, defaultOptions } = props;
      const { hasMerge, columns } = storeData2;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = import_xe_utils25.default.searchTree(columns, (column) => column.checked, { children: "children", mapChildren: "childNodes", original: true });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const { storeData: storeData2 } = props;
      const printOpts = computePrintOpts.value;
      storeData2.visible = false;
      $xeTable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const { storeData: storeData2 } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xeTable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData2.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const { storeData: storeData2 } = props;
      storeData2.visible = false;
    };
    const confirmEvent = () => {
      const { storeData: storeData2 } = props;
      if (storeData2.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const { defaultOptions, storeData: storeData2 } = props;
      const { isAll: isAllChecked, isIndeterminate: isAllIndeterminate } = reactData;
      const { hasTree, hasMerge, isPrint, hasColgroup, columns } = storeData2;
      const { isHeader } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const parameterSlot = slots.parameter;
      import_xe_utils25.default.eachTree(columns, (column) => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        const isHtml = column.type === "html";
        cols.push(h("li", {
          key: column.id,
          class: ["vxe-table-export--panel-column-option", `level--${column.level}`, {
            "is--group": isColGroup,
            "is--checked": isChecked,
            "is--indeterminate": indeterminate,
            "is--disabled": column.disabled
          }],
          title: isHtml ? "" : colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", indeterminate ? getIcon7().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon7().TABLE_CHECKBOX_CHECKED : getIcon7().TABLE_CHECKBOX_UNCHECKED]
          }),
          isHtml ? h("span", {
            key: "1",
            class: "vxe-checkbox--label",
            innerHTML: colTitle
          }) : h("span", {
            key: "0",
            class: "vxe-checkbox--label"
          }, colTitle)
        ]));
      });
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_EXPORT_MODAL",
        modelValue: storeData2.visible,
        title: getI18n9(isPrint ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData2.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeTable.xegrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : createCommentVNode(),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  [
                    isPrint ? createCommentVNode() : h("tr", [
                      h("td", getI18n9("vxe.export.expName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputFilename,
                          modelValue: defaultOptions.filename,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n9("vxe.export.expNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.filename = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    isPrint ? createCommentVNode() : h("tr", [
                      h("td", getI18n9("vxe.export.expType")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.type,
                          options: storeData2.typeList,
                          "onUpdate:modelValue"(value) {
                            defaultOptions.type = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    isPrint || showSheet ? h("tr", [
                      h("td", getI18n9("vxe.export.expSheetName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputSheetname,
                          modelValue: defaultOptions.sheetName,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n9("vxe.export.expSheetNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.sheetName = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]) : createCommentVNode(),
                    h("tr", [
                      h("td", getI18n9("vxe.export.expMode")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.mode,
                          options: storeData2.modeList.map((item) => {
                            return {
                              value: item.value,
                              label: getI18n9(item.label)
                            };
                          }),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.mode = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    h("tr", [
                      h("td", [getI18n9("vxe.export.expColumn")]),
                      h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-column"
                        }, [
                          h("ul", {
                            class: "vxe-table-export--panel-column-header"
                          }, [
                            h("li", {
                              class: ["vxe-table-export--panel-column-option", {
                                "is--checked": isAllChecked,
                                "is--indeterminate": isAllIndeterminate
                              }],
                              title: getI18n9("vxe.table.allTitle"),
                              onClick: allColumnEvent
                            }, [
                              h("span", {
                                class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon7().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon7().TABLE_CHECKBOX_CHECKED : getIcon7().TABLE_CHECKBOX_UNCHECKED]
                              }),
                              h("span", {
                                class: "vxe-checkbox--label"
                              }, getI18n9("vxe.export.expCurrentColumn"))
                            ])
                          ]),
                          h("ul", {
                            class: "vxe-table-export--panel-column-body"
                          }, cols)
                        ])
                      ])
                    ]),
                    h("tr", [
                      h("td", getI18n9("vxe.export.expOpts")),
                      parameterSlot ? h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, $xeTable.callSlot(parameterSlot, params))
                      ]) : h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.isHeader,
                            title: getI18n9("vxe.export.expHeaderTitle"),
                            content: getI18n9("vxe.export.expOptHeader"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isHeader = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.isFooter,
                            disabled: !storeData2.hasFooter,
                            title: getI18n9("vxe.export.expFooterTitle"),
                            content: getI18n9("vxe.export.expOptFooter"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isFooter = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.original,
                            title: getI18n9("vxe.export.expOriginalTitle"),
                            content: getI18n9("vxe.export.expOptOriginal"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.original = value;
                            }
                          }) : createCommentVNode()
                        ]),
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
                            title: getI18n9("vxe.export.expColgroupTitle"),
                            disabled: !isHeader || !hasColgroup || !supportMerge,
                            content: getI18n9("vxe.export.expOptColgroup"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isColgroup = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
                            title: getI18n9("vxe.export.expMergeTitle"),
                            disabled: !hasMerge || !supportMerge || !checkedAll,
                            content: getI18n9("vxe.export.expOptMerge"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isMerge = value;
                            }
                          }) : createCommentVNode(),
                          isPrint || !VxeUICheckboxComponent ? createCommentVNode() : h(VxeUICheckboxComponent, {
                            modelValue: supportStyle ? defaultOptions.useStyle : false,
                            disabled: !supportStyle,
                            title: getI18n9("vxe.export.expUseStyleTitle"),
                            content: getI18n9("vxe.export.expOptUseStyle"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.useStyle = value;
                            }
                          }),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasTree ? defaultOptions.isAllExpand : false,
                            disabled: !hasTree,
                            title: getI18n9("vxe.export.expAllExpandTitle"),
                            content: getI18n9("vxe.export.expOptAllExpand"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isAllExpand = value;
                            }
                          }) : createCommentVNode()
                        ])
                      ])
                    ])
                  ]
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : createCommentVNode()
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeTable.xegrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n9("vxe.export.expCancel"),
                onClick: cancelEvent
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                ref: xButtonConfirm,
                status: "primary",
                content: getI18n9(isPrint ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: confirmEvent
              }) : createCommentVNode()
            ])
          ]);
        }
      }) : createCommentVNode();
    };
    if (true) {
      nextTick(() => {
        if (!VxeUIModalComponent) {
          errLog("vxe.error.reqComp", ["vxe-modal"]);
        }
        if (!VxeUIButtonComponent) {
          errLog("vxe.error.reqComp", ["vxe-button"]);
        }
        if (!VxeUISelectComponent) {
          errLog("vxe.error.reqComp", ["vxe-select"]);
        }
        if (!VxeUIInputComponent) {
          errLog("vxe.error.reqComp", ["vxe-input"]);
        }
        if (!VxeUICheckboxComponent) {
          errLog("vxe.error.reqComp", ["vxe-checkbox"]);
        }
      });
    }
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/menu/panel.js
var import_xe_utils26 = __toESM(require_xe_utils());
var { getIcon: getIcon8 } = VxeUI;
var panel_default3 = defineComponent({
  name: "VxeTableMenuPanel",
  setup(props, context) {
    const xID = import_xe_utils26.default.uniqueId();
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData } = $xeTable;
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeMenuPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const { ctxMenuStore } = tableReactData;
      const { computeMenuOpts } = $xeTable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      return h(Teleport, {
        to: "body",
        disabled: false
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-table--context-menu-wrapper", menuOpts.className, {
            "is--visible": ctxMenuStore.visible
          }],
          style: ctxMenuStore.style
        }, ctxMenuStore.list.map((options, gIndex) => {
          return options.every((item) => item.visible === false) ? createCommentVNode() : h("ul", {
            class: "vxe-context-menu--option-wrapper",
            key: gIndex
          }, options.map((item, index2) => {
            const hasChildMenus = item.children && item.children.some((child) => child.visible !== false);
            const prefixOpts = Object.assign({}, item.prefixConfig);
            const suffixOpts = Object.assign({}, item.suffixConfig);
            return item.visible === false ? null : h("li", {
              class: [item.className, {
                "link--disabled": item.disabled,
                "link--active": item === ctxMenuStore.selected
              }],
              key: `${gIndex}_${index2}`
            }, [
              h("a", {
                class: "vxe-context-menu--link",
                onClick(evnt) {
                  $xeTable.ctxMenuLinkEvent(evnt, item);
                },
                onMouseover(evnt) {
                  $xeTable.ctxMenuMouseoverEvent(evnt, item);
                },
                onMouseout(evnt) {
                  $xeTable.ctxMenuMouseoutEvent(evnt, item);
                }
              }, [
                h("div", {
                  class: ["vxe-context-menu--link-prefix", prefixOpts.className || ""]
                }, [
                  h("i", {
                    class: prefixOpts.icon || item.prefixIcon
                  }),
                  prefixOpts.content ? h("span", {}, `${prefixOpts.content}`) : createCommentVNode()
                ]),
                h("div", {
                  class: "vxe-context-menu--link-content"
                }, getFuncText(item.name)),
                h("div", {
                  class: ["vxe-context-menu--link-suffix", suffixOpts.className || ""]
                }, [
                  h("i", {
                    class: suffixOpts.icon || item.suffixIcon || (hasChildMenus ? getIcon8().TABLE_MENU_OPTIONS : "")
                  }),
                  suffixOpts.content ? h("span", `${suffixOpts.content}`) : createCommentVNode()
                ])
              ]),
              hasChildMenus ? h("ul", {
                class: ["vxe-table--context-menu-clild-wrapper", {
                  "is--show": item === ctxMenuStore.selected && ctxMenuStore.showChild
                }]
              }, item.children.map((child, cIndex) => {
                const childPrefixOpts = Object.assign({}, child.prefixConfig);
                const childSuffixOpts = Object.assign({}, child.suffixConfig);
                return child.visible === false ? null : h("li", {
                  class: [child.className, {
                    "link--disabled": child.disabled,
                    "link--active": child === ctxMenuStore.selectChild
                  }],
                  key: `${gIndex}_${index2}_${cIndex}`
                }, [
                  h("a", {
                    class: "vxe-context-menu--link",
                    onClick(evnt) {
                      $xeTable.ctxMenuLinkEvent(evnt, child);
                    },
                    onMouseover(evnt) {
                      $xeTable.ctxMenuMouseoverEvent(evnt, item, child);
                    },
                    onMouseout(evnt) {
                      $xeTable.ctxMenuMouseoutEvent(evnt, item);
                    }
                  }, [
                    h("div", {
                      class: ["vxe-context-menu--link-prefix", childPrefixOpts.className || ""]
                    }, [
                      h("i", {
                        class: childPrefixOpts.icon || child.prefixIcon
                      }),
                      childPrefixOpts.content ? h("span", `${childPrefixOpts.content}`) : createCommentVNode()
                    ]),
                    h("div", {
                      class: "vxe-context-menu--link-content"
                    }, getFuncText(child.name)),
                    h("div", {
                      class: ["vxe-context-menu--link-suffix", childSuffixOpts.className || ""]
                    }, [
                      h("i", {
                        class: childSuffixOpts.icon
                      }),
                      childSuffixOpts.content ? h("span", `${childSuffixOpts.content}`) : createCommentVNode()
                    ])
                  ])
                ]);
              })) : null
            ]);
          }));
        }))
      ]);
    };
    $xeMenuPanel.renderVN = renderVN;
    return $xeMenuPanel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/table/src/table.js
var { getConfig: getConfig4, getIcon: getIcon9, getI18n: getI18n10, renderer: renderer8, formats: formats5, createEvent: createEvent2, globalResize: globalResize3, interceptor: interceptor3, hooks: hooks3, globalEvents: globalEvents3, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS2, useFns: useFns2, renderEmptyElement: renderEmptyElement5 } = VxeUI;
var customStorageKey = "VXE_CUSTOM_STORE";
var table_default = defineComponent({
  name: "VxeTable",
  props: props_default,
  emits: emits_default,
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils27.default.uniqueId();
    const VxeUILoadingComponent = VxeUI.getComponent("VxeLoading");
    const VxeUITooltipComponent = VxeUI.getComponent("VxeTooltip");
    const $xeTabs = inject("$xeTabs", null);
    const { computeSize } = useFns2.useSize(props);
    const reactData = reactive({
      isCalcColumn: false,
      // 
      staticColumns: [],
      // 
      tableGroupColumn: [],
      // 
      tableColumn: [],
      // 
      tableData: [],
      //  X 
      scrollXLoad: false,
      //  Y 
      scrollYLoad: false,
      // 
      overflowY: true,
      // 
      overflowX: false,
      // 
      scrollbarWidth: 0,
      // 
      scrollbarHeight: 0,
      // 
      lastScrollTime: 0,
      // 
      rowHeight: 0,
      // 
      parentHeight: 0,
      // 
      isGroup: false,
      isAllOverflow: false,
      // 
      isAllSelected: false,
      // 
      isIndeterminate: false,
      // 
      selectCheckboxMaps: {},
      // 
      currentRow: null,
      // 
      currentColumn: null,
      // 
      selectRadioRow: null,
      // 
      footerTableData: [],
      // 
      expandColumn: null,
      // 
      treeNodeColumn: null,
      hasFixedColumn: false,
      // 
      rowExpandedMaps: {},
      // 
      rowExpandLazyLoadedMaps: {},
      // 
      treeExpandedMaps: {},
      // 
      treeExpandLazyLoadedMaps: {},
      // 
      treeIndeterminateMaps: {},
      // 
      mergeList: [],
      // 
      mergeFooterList: [],
      // 
      upDataFlag: 0,
      // 
      reColumnFlag: 0,
      // 
      pendingRowMaps: {},
      // 
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      // 
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0,
        oldSortMaps: {},
        oldFixedMaps: {},
        oldVisibleMaps: {}
      },
      customColumnList: [],
      // 
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      // 
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        autoMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: [],
        remainList: []
      },
      // 
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 
        selected: {
          row: null,
          column: null
        },
        // 
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 
        actived: {
          row: null,
          column: null
        },
        // 
        focused: {
          row: null,
          column: null
        },
        insertMaps: {},
        removeMaps: {}
      },
      //  tooltip 
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false,
        currOpts: {}
      },
      // 
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 
      importStore: {
        inited: false,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: false
      },
      importParams: {
        mode: "",
        types: null,
        message: true
      },
      // 
      exportStore: {
        inited: false,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isFooter: false
      },
      scrollVMLoading: false,
      isCustomStatus: false,
      isDragRowMove: false,
      dragRow: null,
      isDragColMove: false,
      dragCol: null,
      dragTipText: "",
      _isResize: false,
      _isLoading: false
    });
    const internalData = {
      tZindex: 0,
      elemStore: {},
      //  X 
      scrollXStore: {
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      //  Y 
      scrollYStore: {
        rowHeight: 0,
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 
      tableWidth: 0,
      // 
      tableHeight: 0,
      // 
      headerHeight: 0,
      // 
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      //  hover 
      hoverRow: null,
      // 
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 
      radioReserveRow: null,
      // 
      checkboxReserveRowMap: {},
      // 
      rowExpandedReserveRowMap: {},
      // 
      treeExpandedReserveRowMap: {},
      // 
      treeIndeterminateRowMaps: {},
      // 
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      // 
      afterFullRowMaps: {},
      // 
      tableFullTreeData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 
      collectColumn: [],
      // 
      tableFullColumn: [],
      // 
      visibleColumn: [],
      // 
      fullAllDataRowIdData: {},
      // 
      sourceDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      // 
      columnStatusMaps: {},
      // 
      rowStatusMaps: {},
      // prevDragRow: null,
      inited: false,
      tooltipTimeout: null,
      initStatus: false,
      isActivated: false
    };
    let tableMethods = {};
    let tablePrivateMethods = {};
    const refElem = ref();
    const refTooltip = ref();
    const refCommTooltip = ref();
    const refValidTooltip = ref();
    const refTableMenu = ref();
    const refTableFilter = ref();
    const refTableCustom = ref();
    const refTableHeader = ref();
    const refTableBody = ref();
    const refTableFooter = ref();
    const refTableLeftHeader = ref();
    const refTableLeftBody = ref();
    const refTableLeftFooter = ref();
    const refTableRightHeader = ref();
    const refTableRightBody = ref();
    const refTableRightFooter = ref();
    const refLeftContainer = ref();
    const refRightContainer = ref();
    const refCellResizeBar = ref();
    const refCellResizeTip = ref();
    const refEmptyPlaceholder = ref();
    const refDragTipElem = ref();
    const refDragRowLineElem = ref();
    const refDragColLineElem = ref();
    const refScrollXVirtualElem = ref();
    const refScrollYVirtualElem = ref();
    const refScrollXHandleElem = ref();
    const refScrollYHandleElem = ref();
    const refScrollXSpaceElem = ref();
    const refScrollYSpaceElem = ref();
    const $xeGrid = inject("$xeGrid", null);
    let $xeToolbar;
    const computeTableId = computed(() => {
      const { id: id2 } = props;
      if (id2) {
        if (import_xe_utils27.default.isFunction(id2)) {
          return `${id2({ $table: $xeTable, $grid: $xeGrid }) || ""}`;
        }
        return `${id2}`;
      }
      return "";
    });
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig4().table.validConfig, props.validConfig);
    });
    const computeSXOpts = computed(() => {
      return Object.assign({}, getConfig4().table.scrollX, props.scrollX);
    });
    const computeScrollXThreshold = computed(() => {
      const sXOpts = computeSXOpts.value;
      const { threshold } = sXOpts;
      if (threshold) {
        return import_xe_utils27.default.toNumber(threshold);
      }
      return 0;
    });
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig4().table.scrollY, props.scrollY);
    });
    const computeScrollYThreshold = computed(() => {
      const sYOpts = computeSYOpts.value;
      const { threshold } = sYOpts;
      if (threshold) {
        return import_xe_utils27.default.toNumber(threshold);
      }
      return 0;
    });
    const computeRowHeightMaps = computed(() => {
      return {
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      };
    });
    const computeColumnOpts = computed(() => {
      return Object.assign({}, getConfig4().table.columnConfig, props.columnConfig);
    });
    const computeCellOpts = computed(() => {
      return Object.assign({}, getConfig4().table.cellConfig, props.cellConfig);
    });
    const computeRowOpts = computed(() => {
      return Object.assign({}, getConfig4().table.rowConfig, props.rowConfig);
    });
    const computeRowDragOpts = computed(() => {
      return Object.assign({}, getConfig4().table.rowDragConfig, props.rowDragConfig);
    });
    const computeColumnDragOpts = computed(() => {
      return Object.assign({}, getConfig4().table.columnDragConfig, props.columnDragConfig);
    });
    const computeResizeOpts = computed(() => {
      return Object.assign({}, getConfig4().table.resizeConfig, props.resizeConfig);
    });
    const computeResizableOpts = computed(() => {
      return Object.assign({}, getConfig4().table.resizableConfig, props.resizableConfig);
    });
    const computeSeqOpts = computed(() => {
      return Object.assign({ startIndex: 0 }, getConfig4().table.seqConfig, props.seqConfig);
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({}, getConfig4().table.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({}, getConfig4().table.checkboxConfig, props.checkboxConfig);
    });
    let computeTooltipOpts = ref();
    computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig4().tooltip, getConfig4().table.tooltipConfig, props.tooltipConfig);
    });
    const computeTipConfig = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts);
    });
    const computeValidTipOpts = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({ isArrow: false }, tooltipOpts);
    });
    const computeEditOpts = computed(() => {
      return Object.assign({}, getConfig4().table.editConfig, props.editConfig);
    });
    const computeSortOpts = computed(() => {
      return Object.assign({ orders: ["asc", "desc", null] }, getConfig4().table.sortConfig, props.sortConfig);
    });
    const computeFilterOpts = computed(() => {
      return Object.assign({}, getConfig4().table.filterConfig, props.filterConfig);
    });
    const computeMouseOpts = computed(() => {
      return Object.assign({}, getConfig4().table.mouseConfig, props.mouseConfig);
    });
    const computeAreaOpts = computed(() => {
      return Object.assign({}, getConfig4().table.areaConfig, props.areaConfig);
    });
    const computeKeyboardOpts = computed(() => {
      return Object.assign({}, getConfig4().table.keyboardConfig, props.keyboardConfig);
    });
    const computeClipOpts = computed(() => {
      return Object.assign({}, getConfig4().table.clipConfig, props.clipConfig);
    });
    const computeFNROpts = computed(() => {
      return Object.assign({}, getConfig4().table.fnrConfig, props.fnrConfig);
    });
    const computeMenuOpts = computed(() => {
      return Object.assign({}, getConfig4().table.menuConfig, props.menuConfig);
    });
    const computeHeaderMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    const computeBodyMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    const computeFooterMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    const computeIsMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerMenu = computeHeaderMenu.value;
      const bodyMenu = computeBodyMenu.value;
      const footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    const computeMenuList = computed(() => {
      const { ctxMenuStore } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach((list) => {
        list.forEach((item) => {
          rest.push(item);
        });
      });
      return rest;
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, getConfig4().table.exportConfig, props.exportConfig);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, getConfig4().table.importConfig, props.importConfig);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, getConfig4().table.printConfig, props.printConfig);
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig4().table.expandConfig, props.expandConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig4().table.treeConfig, props.treeConfig);
    });
    const computeEmptyOpts = computed(() => {
      return Object.assign({}, getConfig4().table.emptyRender, props.emptyRender);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig4().table.loadingConfig, props.loadingConfig);
    });
    const computeCellOffsetWidth = computed(() => {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, getConfig4().table.customConfig, props.customConfig);
    });
    const computeAutoWidthColumnList = computed(() => {
      const { visibleColumn } = internalData;
      const { tableColumn } = reactData;
      return tableColumn.length || visibleColumn.length ? visibleColumn.filter((column) => column.width === "auto" || column.minWidth === "auto") : [];
    });
    const computeFixedColumnSize = computed(() => {
      const { tableColumn } = reactData;
      const { collectColumn } = internalData;
      let fixedSize = 0;
      if (tableColumn.length && collectColumn.length) {
        collectColumn.forEach((column) => {
          if (column.renderFixed) {
            fixedSize++;
          }
        });
      }
      return fixedSize;
    });
    const computeIsMaxFixedColumn = computed(() => {
      const fixedColumnSize = computeFixedColumnSize.value;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    });
    const computeTableBorder = computed(() => {
      const { border } = props;
      if (border === true) {
        return "full";
      }
      if (border) {
        return border;
      }
      return "default";
    });
    const computeIsAllCheckboxDisabled = computed(() => {
      const { treeConfig } = props;
      const { tableData } = reactData;
      const { tableFullData } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const { strict, checkMethod } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
            }
            return tableFullData.every((row) => !checkMethod({ row }));
          }
          return false;
        }
        return true;
      }
      return false;
    });
    const computeVirtualScrollBars = computed(() => {
      const { overflowX, scrollXLoad, overflowY, scrollYLoad } = reactData;
      return {
        x: overflowX && scrollXLoad,
        y: overflowY && scrollYLoad
      };
    });
    const computeTableStyle = computed(() => {
      const { tableData } = reactData;
      const columnOpts = computeColumnOpts.value;
      const stys = {};
      if (columnOpts.drag) {
        stys["--vxe-ui-table-drag-column-move-delay"] = `${Math.max(0.06, Math.min(0.3, tableData.length / 800))}s`;
      }
      return stys;
    });
    const refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableCustom,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refCellResizeBar,
      refCellResizeTip,
      refScrollXVirtualElem,
      refScrollYVirtualElem,
      refScrollXHandleElem,
      refScrollYHandleElem,
      refScrollXSpaceElem,
      refScrollYSpaceElem
    };
    const computeMaps = {
      computeSize,
      computeTableId,
      computeValidOpts,
      computeSXOpts,
      computeSYOpts,
      computeColumnOpts,
      computeCellOpts,
      computeRowOpts,
      computeRowDragOpts,
      computeColumnDragOpts,
      computeResizeOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFNROpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCustomOpts,
      computeFixedColumnSize,
      computeIsMaxFixedColumn,
      computeIsAllCheckboxDisabled,
      computeVirtualScrollBars
    };
    const $xeTable = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      xegrid: $xeGrid
    };
    const eqCellValue = (row1, row2, field) => {
      const val1 = import_xe_utils27.default.get(row1, field);
      const val2 = import_xe_utils27.default.get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (import_xe_utils27.default.isString(val1) || import_xe_utils27.default.isNumber(val1)) {
        return "" + val1 === "" + val2;
      }
      return import_xe_utils27.default.isEqual(val1, val2);
    };
    const getNextSortOrder = (column) => {
      const sortOpts = computeSortOpts.value;
      const { orders } = sortOpts;
      const currOrder = column.order || null;
      const oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    const getCustomStorageMap = (id2) => {
      const version7 = getConfig4().version;
      const rest = import_xe_utils27.default.toStringJSON(localStorage.getItem(customStorageKey) || "");
      const maps = rest && rest._v === version7 ? rest : { _v: version7 };
      return (id2 ? maps[id2] : maps) || {};
    };
    const setCustomStorageMap = (id2, data) => {
      const version7 = getConfig4().version;
      const maps = getCustomStorageMap();
      maps[id2] = data || void 0;
      maps._v = version7;
      localStorage.setItem(customStorageKey, import_xe_utils27.default.toJSONString(maps));
    };
    const getRecoverRowMaps = (keyMaps) => {
      const { fullAllDataRowIdData } = internalData;
      const restKeys = {};
      import_xe_utils27.default.each(keyMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          restKeys[rowid] = row;
        }
      });
      return restKeys;
    };
    const handleReserveRow = (reserveRowMap) => {
      const { fullDataRowIdData } = internalData;
      const reserveList = [];
      import_xe_utils27.default.each(reserveRowMap, (item, rowid) => {
        if (fullDataRowIdData[rowid] && $xeTable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    const handleVirtualXVisible = () => {
      const { visibleColumn } = internalData;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      if (tableBodyElem) {
        const { scrollLeft, clientWidth } = tableBodyElem;
        const endWidth = scrollLeft + clientWidth;
        let toVisibleIndex = -1;
        let cWidth = 0;
        let visibleSize = 0;
        for (let colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {
          cWidth += visibleColumn[colIndex].renderWidth;
          if (toVisibleIndex === -1 && scrollLeft < cWidth) {
            toVisibleIndex = colIndex;
          }
          if (toVisibleIndex >= 0) {
            visibleSize++;
            if (cWidth > endWidth) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(6, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    };
    const computeRowHeight = () => {
      const { showOverflow } = props;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const vSize = computeSize.value;
      const rowHeightMaps = computeRowHeightMaps.value;
      let rowHeight = 24;
      if (showOverflow) {
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          let firstTrElem;
          firstTrElem = tableBodyElem.querySelector("tr");
          if (!firstTrElem && tableHeaderElem) {
            firstTrElem = tableHeaderElem.querySelector("tr");
          }
          if (firstTrElem) {
            rowHeight = firstTrElem.clientHeight;
          }
          if (!rowHeight) {
            rowHeight = rowHeightMaps[vSize || "default"];
          }
        }
      }
      return rowHeight;
    };
    const handleVirtualYVisible = () => {
      const { scrollYStore, afterFullData, fullAllDataRowIdData } = internalData;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const { rowHeight } = scrollYStore;
      if (tableBodyElem) {
        const { scrollTop, clientHeight } = tableBodyElem;
        const endHeight = scrollTop + clientHeight;
        let toVisibleIndex = -1;
        let offsetTop = 0;
        let visibleSize = 0;
        for (let rIndex = 0, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
          const row = afterFullData[rIndex];
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (!rowRest) {
            break;
          }
          offsetTop += rowRest.height || rowHeight;
          if (toVisibleIndex === -1 && scrollTop < offsetTop) {
            toVisibleIndex = rIndex;
          }
          if (toVisibleIndex >= 0) {
            visibleSize++;
            if (offsetTop > endHeight) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(8, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 8 };
    };
    const calculateMergerOffsetIndex = (list, offsetItem, type) => {
      for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
        const mergeItem = list[mcIndex];
        const { startIndex, endIndex } = offsetItem;
        const mergeStartIndex = mergeItem[type];
        const mergeSpanNumber = mergeItem[type + "span"];
        const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    const setMerges = (merges, mList, rowList) => {
      if (merges) {
        const { treeConfig } = props;
        const { visibleColumn } = internalData;
        if (!import_xe_utils27.default.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach((item) => {
          let { row, col, rowspan, colspan } = item;
          if (rowList && import_xe_utils27.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils27.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          if ((rowList ? row : import_xe_utils27.default.isNumber(row)) && col && (rowspan || colspan)) {
            rowspan = import_xe_utils27.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils27.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const mcIndex = import_xe_utils27.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xeTable, item2._row) === getRowid($xeTable, row)) && (item2._col.id === col || item2._col.id === col.id));
              const mergeItem = mList[mcIndex];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                const mergeRowIndex = rowList ? $xeTable.findRowIndexOf(rowList, row) : row;
                const mergeColIndex = tableMethods.getVTColumnIndex(col);
                mList.push({
                  row: mergeRowIndex,
                  col: mergeColIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: col,
                  _rowspan: rowspan,
                  _colspan: colspan
                });
              }
            }
          }
        });
      }
    };
    const removeMerges = (merges, mList, rowList) => {
      const rest = [];
      if (merges) {
        const { treeConfig } = props;
        const { visibleColumn } = internalData;
        if (!import_xe_utils27.default.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach((item) => {
          let { row, col } = item;
          if (rowList && import_xe_utils27.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils27.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          const mcIndex = import_xe_utils27.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xeTable, item2._row) === getRowid($xeTable, row)) && (item2._col.id === col || item2._col.id === col.id));
          if (mcIndex > -1) {
            const rItems = mList.splice(mcIndex, 1);
            rest.push(rItems[0]);
          }
        });
      }
      return rest;
    };
    const clearAllSort = () => {
      const { tableFullColumn } = internalData;
      tableFullColumn.forEach((column) => {
        column.order = null;
      });
    };
    const calcTableHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          const excludeHeight = $xeTable.getExcludeHeight();
          if (isScale(val)) {
            num = Math.floor((import_xe_utils27.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils27.default.toNumber(val);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    const handleCustomRestore = (storeData2) => {
      let { collectColumn } = internalData;
      const { resizableData, sortData, visibleData, fixedData } = storeData2;
      let hasCustomSort = false;
      if (resizableData || sortData || visibleData || fixedData) {
        import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
          const colKey = column.getKey();
          if (!parent) {
            if (fixedData && fixedData[colKey]) {
              column.fixed = fixedData[colKey];
            }
            if (sortData && import_xe_utils27.default.isNumber(sortData[colKey])) {
              hasCustomSort = true;
              column.renderSortNumber = sortData[colKey];
            }
          }
          if (resizableData && import_xe_utils27.default.isNumber(resizableData[colKey])) {
            column.resizeWidth = resizableData[colKey];
          }
          if (visibleData && import_xe_utils27.default.isBoolean(visibleData[colKey])) {
            column.visible = visibleData[colKey];
          }
        });
        if (hasCustomSort) {
          collectColumn = import_xe_utils27.default.orderBy(collectColumn, "renderSortNumber");
          internalData.collectColumn = collectColumn;
          internalData.tableFullColumn = getColumnList(collectColumn);
        }
        reactData.isCustomStatus = true;
      } else {
        reactData.isCustomStatus = false;
      }
    };
    const restoreCustomStorage = () => {
      const { customConfig } = props;
      const tableId = computeTableId.value;
      const customOpts = computeCustomOpts.value;
      const { storage, restoreStore } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
      const isCustomResizable = isAllCustom || storageOpts.resizable;
      const isCustomVisible = isAllCustom || storageOpts.visible;
      const isCustomFixed = isAllCustom || storageOpts.fixed;
      const isCustomSort = isAllCustom || storageOpts.sort;
      if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
        if (!tableId) {
          errLog("vxe.error.reqProp", ["id"]);
          return;
        }
        const storeData2 = getCustomStorageMap(tableId);
        if (restoreStore) {
          return Promise.resolve(restoreStore({ id: tableId, type: "restore", storeData: storeData2 })).then((storeData3) => {
            if (!storeData3) {
              return;
            }
            return handleCustomRestore(storeData3);
          }).catch((e16) => e16);
        } else {
          return handleCustomRestore(storeData2);
        }
      }
    };
    const cacheColumnMap = () => {
      const { tableFullColumn, collectColumn } = internalData;
      const fullColumnIdData = internalData.fullColumnIdData = {};
      const fullColumnFieldData = internalData.fullColumnFieldData = {};
      const mouseOpts = computeMouseOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isSelfToChildDrag } = columnDragOpts;
      const rowOpts = computeRowOpts.value;
      const isGroup = collectColumn.some(hasChildrenList);
      let isAllOverflow = !!props.showOverflow;
      let expandColumn;
      let treeNodeColumn;
      let checkboxColumn;
      let radioColumn;
      let htmlColumn;
      let hasFixed;
      const handleFunc = (column, index2, items, path, parent) => {
        const { id: colid, field, fixed, type, treeNode } = column;
        const rest = { $index: -1, _index: -1, column, colid, index: index2, items, parent: parent || null, width: 0 };
        if (field) {
          if (fullColumnFieldData[field]) {
            errLog("vxe.error.colRepet", ["field", field]);
          }
          fullColumnFieldData[field] = rest;
        } else {
          if (isCrossDrag || isSelfToChildDrag) {
            errLog("vxe.error.emptyProp", ["column.field"]);
          }
        }
        if (!hasFixed && fixed) {
          hasFixed = fixed;
        }
        if (!htmlColumn && type === "html") {
          htmlColumn = column;
        }
        if (treeNode) {
          if (true) {
            if (treeNodeColumn) {
              warnLog("vxe.error.colRepet", ["tree-node", treeNode]);
            }
          }
          if (!treeNodeColumn) {
            treeNodeColumn = column;
          }
        } else if (type === "expand") {
          if (true) {
            if (expandColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
          }
          if (!expandColumn) {
            expandColumn = column;
          }
        }
        if (true) {
          if (type === "checkbox") {
            if (checkboxColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!checkboxColumn) {
              checkboxColumn = column;
            }
          } else if (type === "radio") {
            if (radioColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!radioColumn) {
              radioColumn = column;
            }
          }
        }
        if (isAllOverflow && column.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColumnIdData[colid]) {
          errLog("vxe.error.colRepet", ["colId", colid]);
        }
        fullColumnIdData[colid] = rest;
      };
      if (isGroup) {
        import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent, nodes) => {
          column.level = nodes.length;
          handleFunc(column, index2, items, path, parent);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      if (true) {
        if (expandColumn && mouseOpts.area) {
          errLog("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]);
        }
      }
      if (true) {
        if (htmlColumn) {
          if (!columnOpts.useKey) {
            errLog("vxe.error.reqProp", ["column-config.useKey & column.type=html"]);
          }
          if (!rowOpts.useKey) {
            errLog("vxe.error.reqProp", ["row-config.useKey & column.type=html"]);
          }
        }
      }
      reactData.isGroup = isGroup;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    const updateHeight = () => {
      internalData.customHeight = calcTableHeight("height");
      internalData.customMinHeight = calcTableHeight("minHeight");
      internalData.customMaxHeight = calcTableHeight("maxHeight");
    };
    const calcCellWidth = () => {
      const autoWidthColumnList = computeAutoWidthColumnList.value;
      reactData.isCalcColumn = true;
      return nextTick().then(() => {
        const { fullColumnIdData } = internalData;
        const el2 = refElem.value;
        if (el2) {
          autoWidthColumnList.forEach((column) => {
            const colid = column.id;
            const colRest = fullColumnIdData[colid];
            const cellElList = el2.querySelectorAll(`.vxe-header--column.${column.id}>.vxe-cell,.vxe-body--column.${column.id}>.vxe-cell,.vxe-footer--column.${column.id}>.vxe-cell`);
            const firstCellEl = cellElList[0];
            let paddingSize = 0;
            if (firstCellEl) {
              const cellStyle = getComputedStyle(firstCellEl);
              paddingSize = Math.floor(import_xe_utils27.default.toNumber(cellStyle.paddingLeft) + import_xe_utils27.default.toNumber(cellStyle.paddingRight)) + 2;
            }
            let colWidth = column.renderAutoWidth - paddingSize;
            import_xe_utils27.default.arrayEach(cellElList, (itemEl) => {
              const cellEl = itemEl;
              const thElem = cellEl.parentElement;
              let titleWidth = 0;
              if (`${thElem.tagName}`.toLowerCase() === "th") {
                import_xe_utils27.default.arrayEach(cellEl.children, (btnEl) => {
                  titleWidth += btnEl.offsetWidth + 1;
                });
              } else {
                const labelEl = cellEl.firstElementChild;
                if (labelEl) {
                  titleWidth = labelEl.offsetWidth;
                }
              }
              if (titleWidth) {
                colWidth = Math.max(colWidth, Math.ceil(titleWidth) + 4);
              }
            });
            if (colRest) {
              colRest.width = Math.max(colWidth, colRest.width);
            }
            column.renderAutoWidth = colWidth + paddingSize;
          });
          tablePrivateMethods.analyColumnWidth();
        }
        reactData.isCalcColumn = false;
      });
    };
    const autoCellWidth = () => {
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const bodyElem = tableBody ? tableBody.$el : null;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      if (!bodyElem) {
        return;
      }
      let tableWidth = 0;
      const minCellWidth = 40;
      const bodyWidth = bodyElem.clientWidth - 1;
      let remainWidth = bodyWidth;
      let meanWidth = remainWidth / 100;
      const { fit } = props;
      const { columnStore } = reactData;
      const { resizeList, pxMinList, autoMinList, pxList, scaleList, scaleMinList, autoList, remainList } = columnStore;
      pxMinList.forEach((column) => {
        const minWidth = import_xe_utils27.default.toInteger(column.minWidth);
        tableWidth += minWidth;
        column.renderWidth = minWidth;
      });
      autoMinList.forEach((column) => {
        const scaleWidth = Math.max(60, import_xe_utils27.default.toInteger(column.renderAutoWidth));
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      scaleMinList.forEach((column) => {
        const scaleWidth = Math.floor(import_xe_utils27.default.toInteger(column.minWidth) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      scaleList.forEach((column) => {
        const scaleWidth = Math.floor(import_xe_utils27.default.toInteger(column.width) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      pxList.forEach((column) => {
        const width = import_xe_utils27.default.toInteger(column.width);
        tableWidth += width;
        column.renderWidth = width;
      });
      autoList.forEach((column) => {
        const width = Math.max(60, import_xe_utils27.default.toInteger(column.renderAutoWidth));
        tableWidth += width;
        column.renderWidth = width;
      });
      resizeList.forEach((column) => {
        const width = import_xe_utils27.default.toInteger(column.resizeWidth);
        tableWidth += width;
        column.renderWidth = width;
      });
      remainWidth -= tableWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoMinList.length + remainList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).concat(autoMinList).forEach((column) => {
            tableWidth += meanWidth;
            column.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      remainList.forEach((column) => {
        const width = Math.max(meanWidth, minCellWidth);
        column.renderWidth = width;
        tableWidth += width;
      });
      if (fit) {
        const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoMinList).concat(remainList);
        let dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          let odiffer = bodyWidth - tableWidth;
          if (odiffer > 0) {
            while (odiffer > 0 && dynamicSize >= 0) {
              odiffer--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tableWidth = bodyWidth;
          }
        }
      }
      const tableHeight = bodyElem.offsetHeight;
      const overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;
      let scrollbarWidth = 0;
      if (overflowY) {
        scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);
      }
      reactData.scrollbarWidth = scrollbarWidth;
      reactData.overflowY = overflowY;
      internalData.tableWidth = tableWidth;
      internalData.tableHeight = tableHeight;
      let headerHeight = 0;
      if (headerElem) {
        headerHeight = headerElem.clientHeight;
        nextTick(() => {
          if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
        });
      }
      internalData.headerHeight = headerHeight;
      let overflowX = false;
      let footerHeight = 0;
      let scrollbarHeight = 0;
      if (footerElem) {
        footerHeight = footerElem.offsetHeight;
        overflowX = tableWidth > footerElem.clientWidth;
        scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);
      } else {
        overflowX = tableWidth > bodyWidth;
        scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);
      }
      internalData.footerHeight = footerHeight;
      reactData.overflowX = overflowX;
      reactData.scrollbarHeight = scrollbarHeight;
      updateHeight();
      reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, tablePrivateMethods.getParentHeight());
      if (overflowX) {
        tablePrivateMethods.checkScrolling();
      }
    };
    const calcCellHeight = () => {
      const { showOverflow } = props;
      const { tableData, scrollXLoad, scrollYLoad } = reactData;
      const { fullAllDataRowIdData } = internalData;
      const el2 = refElem.value;
      if (!showOverflow && (scrollXLoad || scrollYLoad) && el2) {
        let paddingTop = 0;
        let paddingBottom = 0;
        let calcPadding = false;
        tableData.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          const trList = el2.querySelectorAll(`.vxe-body--row[rowid="${rowid}"]`);
          if (rowRest && trList.length) {
            let height = 0;
            for (let i = 0; i < trList.length; i++) {
              const trEl = trList[i];
              const tdList = trEl.children;
              for (let j = 0; j < tdList.length; j++) {
                const tdEl = tdList[j];
                const cellElem = tdEl.querySelector(".vxe-cell");
                if (!calcPadding) {
                  paddingTop = import_xe_utils27.default.toNumber(getComputedStyle(tdEl).paddingTop);
                  paddingBottom = import_xe_utils27.default.toNumber(getComputedStyle(tdEl).paddingBottom);
                  calcPadding = true;
                }
                let cellHeight = paddingTop + paddingBottom;
                if (cellElem) {
                  cellHeight += cellElem.offsetHeight;
                }
                height = Math.max(height, cellHeight);
              }
            }
            rowRest.height = scrollXLoad ? Math.max(rowRest.height, height) : height;
          }
        });
      }
    };
    const getOrderField = (column) => {
      const { sortBy, sortType } = column;
      return (row) => {
        let cellValue;
        if (sortBy) {
          cellValue = import_xe_utils27.default.isFunction(sortBy) ? sortBy({ row, column }) : import_xe_utils27.default.get(row, sortBy);
        } else {
          cellValue = tableMethods.getCellLabel(row, column);
        }
        if (!sortType || sortType === "auto") {
          return isNaN(cellValue) ? cellValue : import_xe_utils27.default.toNumber(cellValue);
        } else if (sortType === "number") {
          return import_xe_utils27.default.toNumber(cellValue);
        } else if (sortType === "string") {
          return import_xe_utils27.default.toValueString(cellValue);
        }
        return cellValue;
      };
    };
    const updateTreeDataIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeConfig) {
        if (treeOpts.transform) {
          afterFullData.forEach((row, index2) => {
            const rowid = getRowid($xeTable, row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = index2;
            } else {
              const rest = { row, rowid, seq: "-1", index: -1, $index: -1, _index: index2, items: [], parent: null, level: 0, height: 0 };
              fullAllDataRowIdData[rowid] = rest;
              fullDataRowIdData[rowid] = rest;
            }
          });
        }
      }
    };
    const updateAfterDataIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData, afterTreeFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const fullMaps = {};
      if (treeConfig) {
        import_xe_utils27.default.eachTree(afterTreeFullData, (row, index2, items, path) => {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
          if (rowRest) {
            rowRest.seq = seq;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: -1, items: [], parent: null, level: 0, height: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        }, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        updateTreeDataIndex();
      } else {
        afterFullData.forEach((row, index2) => {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          const seq = index2 + 1;
          if (rowRest) {
            rowRest.seq = seq;
            rowRest._index = index2;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: index2, items: [], parent: null, level: 0, height: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        });
      }
      internalData.afterFullRowMaps = fullMaps;
    };
    const handleVirtualTreeToList = () => {
      const { treeConfig } = props;
      const { treeExpandedMaps } = reactData;
      const { fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (treeConfig && treeOpts.transform) {
        const fullData = [];
        const expandMaps = {};
        import_xe_utils27.default.eachTree(internalData.afterTreeFullData, (row, index2, items, path, parent) => {
          const rowid = getRowid($xeTable, row);
          const parentRowid = getRowid($xeTable, parent);
          if (!parent || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = fullData.length;
            }
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: childrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      }
      return internalData.afterFullData;
    };
    const updateAfterFullData = () => {
      const { treeConfig } = props;
      const { tableFullColumn, tableFullData, tableFullTreeData } = internalData;
      const filterOpts = computeFilterOpts.value;
      const sortOpts = computeSortOpts.value;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const { transform: transform2 } = treeOpts;
      const { remote: allRemoteFilter, filterMethod: allFilterMethod } = filterOpts;
      const { remote: allRemoteSort, sortMethod: allSortMethod, multiple: sortMultiple, chronological } = sortOpts;
      let tableData = [];
      let tableTree = [];
      if (!allRemoteFilter || !allRemoteSort) {
        const filterColumns = [];
        let orderColumns = [];
        tableFullColumn.forEach((column) => {
          const { field, sortable, order, filters } = column;
          if (!allRemoteFilter && filters && filters.length) {
            const valueList = [];
            const itemList = [];
            filters.forEach((item) => {
              if (item.checked) {
                itemList.push(item);
                valueList.push(item.value);
              }
            });
            if (itemList.length) {
              filterColumns.push({ column, valueList, itemList });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (sortMultiple && chronological && orderColumns.length > 1) {
          orderColumns = import_xe_utils27.default.orderBy(orderColumns, "sortTime");
        }
        if (!allRemoteFilter && filterColumns.length) {
          const handleFilter = (row) => {
            return filterColumns.every(({ column, valueList, itemList }) => {
              const { filterMethod, filterRender } = column;
              const compConf = isEnableConf(filterRender) ? renderer8.get(filterRender.name) : null;
              const compFilterMethod = compConf ? compConf.tableFilterMethod || compConf.filterMethod : null;
              const tdFilterMethod = compConf ? compConf.tableFilterDefaultMethod || compConf.defaultTableFilterMethod || compConf.defaultFilterMethod : null;
              const cellValue = getCellValue(row, column);
              if (filterMethod) {
                return itemList.some((item) => filterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (compFilterMethod) {
                return itemList.some((item) => compFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (allFilterMethod) {
                return allFilterMethod({ options: itemList, values: valueList, cellValue, row, column });
              } else if (tdFilterMethod) {
                return itemList.some((item) => tdFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              }
              return valueList.indexOf(import_xe_utils27.default.get(row, column.field)) > -1;
            });
          };
          if (treeConfig && transform2) {
            tableTree = import_xe_utils27.default.searchTree(tableFullTreeData, handleFilter, {
              original: true,
              isEvery: true,
              children: treeOpts.mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (treeConfig && transform2) {
            tableTree = import_xe_utils27.default.searchTree(tableFullTreeData, () => true, {
              original: true,
              isEvery: true,
              children: treeOpts.mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        if (!allRemoteSort && orderColumns.length) {
          if (treeConfig && transform2) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xeTable });
              tableTree = import_xe_utils27.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              tableTree = import_xe_utils27.default.orderBy(tableTree, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableData, sortList: orderColumns, $table: $xeTable });
              tableData = import_xe_utils27.default.isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = import_xe_utils27.default.orderBy(tableData, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (treeConfig && transform2) {
          tableTree = import_xe_utils27.default.searchTree(tableFullTreeData, () => true, {
            original: true,
            isEvery: true,
            children: treeOpts.mapChildrenField,
            mapChildren: childrenField
          });
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      updateAfterDataIndex();
    };
    const updateStyle = () => {
      const { border, showFooter, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow, showFooterOverflow: allColumnFooterOverflow, mouseConfig, spanMethod, footerSpanMethod, keyboardConfig } = props;
      const { isGroup, currentRow, tableColumn, scrollXLoad, scrollYLoad, overflowX, scrollbarWidth, scrollbarHeight, columnStore, editStore, mergeList, mergeFooterList, isAllOverflow } = reactData;
      let { visibleColumn, fullColumnIdData, tableHeight, tableWidth, headerHeight, footerHeight, elemStore, customHeight, customMinHeight, customMaxHeight } = internalData;
      const containerList = ["main", "left", "right"];
      const emptyPlaceholderElem = refEmptyPlaceholder.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = `${headerHeight}px`;
        emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - scrollbarHeight}px` : "";
      }
      if (customHeight > 0) {
        if (showFooter) {
          customHeight += scrollbarHeight;
        }
      }
      const scrollXVirtualEl = refScrollXVirtualElem.value;
      if (scrollXVirtualEl) {
        scrollXVirtualEl.style.height = `${scrollbarHeight}px`;
      }
      const scrollYVirtualEl = refScrollYVirtualElem.value;
      if (scrollYVirtualEl) {
        let bodyHeight = 0;
        let bodyMaxHeight = 0;
        const bodyMinHeight = customMinHeight - headerHeight - footerHeight;
        if (customMaxHeight) {
          bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;
          bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);
        }
        if (customHeight) {
          bodyHeight = customHeight - headerHeight - footerHeight;
          if (bodyMaxHeight) {
            bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
          }
          bodyHeight = Math.max(bodyMinHeight, bodyHeight);
        }
        scrollYVirtualEl.style.top = `${headerHeight}px`;
        scrollYVirtualEl.style.width = `${scrollbarWidth}px`;
        scrollYVirtualEl.style.height = `${bodyHeight + (overflowX ? -Math.max(1, scrollbarHeight) : 0)}px`;
      }
      containerList.forEach((name, index2) => {
        const fixedType = index2 > 0 ? name : "";
        const layoutList = ["header", "body", "footer"];
        const isFixedLeft = fixedType === "left";
        let fixedColumn = [];
        let fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach((layout) => {
          const wrapperElem = getRefElem(elemStore[`${name}-${layout}-wrapper`]);
          const tableElem = getRefElem(elemStore[`${name}-${layout}-table`]);
          if (layout === "header") {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (isGroup) {
              renderColumnList = visibleColumn;
            } else {
              if (fixedType) {
                if (scrollXLoad || allColumnHeaderOverflow) {
                  renderColumnList = fixedColumn;
                }
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : "";
            }
            const repairElem = getRefElem(elemStore[`${name}-${layout}-repair`]);
            if (repairElem) {
              repairElem.style.width = `${tableWidth}px`;
            }
            const listElem = getRefElem(elemStore[`${name}-${layout}-list`]);
            if (isGroup && listElem) {
              import_xe_utils27.default.arrayEach(listElem.querySelectorAll(".col--group"), (thElem) => {
                const colNode = tableMethods.getColumnNode(thElem);
                if (colNode) {
                  const column = colNode.item;
                  const { showHeaderOverflow } = column;
                  const cellOverflow = import_xe_utils27.default.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;
                  const showEllipsis = cellOverflow === "ellipsis";
                  const showTitle = cellOverflow === "title";
                  const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
                  const hasEllipsis = showTitle || showTooltip || showEllipsis;
                  let childWidth = 0;
                  let countChild = 0;
                  if (hasEllipsis) {
                    import_xe_utils27.default.eachTree(column.children, (item) => {
                      if (!item.children || !column.children.length) {
                        countChild++;
                      }
                      childWidth += item.renderWidth;
                    }, { children: "children" });
                  }
                  thElem.style.width = hasEllipsis ? `${childWidth - countChild - (border ? 2 : 0)}px` : "";
                }
              });
            }
          } else if (layout === "body") {
            const emptyBlockElem = getRefElem(elemStore[`${name}-${layout}-emptyBlock`]);
            if (isNodeElement(wrapperElem)) {
              let bodyMaxHeight = 0;
              const bodyMinHeight = customMinHeight - headerHeight - footerHeight;
              if (customMaxHeight) {
                bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;
                if (fixedType) {
                  bodyMaxHeight -= showFooter ? 0 : scrollbarHeight;
                }
                bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);
                wrapperElem.style.maxHeight = `${bodyMaxHeight}px`;
              }
              if (customHeight) {
                let bodyHeight = customHeight - headerHeight - footerHeight;
                if (fixedType) {
                  bodyHeight -= showFooter ? 0 : scrollbarHeight;
                }
                if (bodyMaxHeight) {
                  bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
                }
                wrapperElem.style.height = `${Math.max(bodyMinHeight, bodyHeight)}px`;
              } else {
                wrapperElem.style.height = "";
              }
              wrapperElem.style.minHeight = `${bodyMinHeight}px`;
            }
            if (fixedWrapperElem) {
              if (isNodeElement(wrapperElem)) {
                wrapperElem.style.top = `${headerHeight}px`;
              }
              fixedWrapperElem.style.height = `${(customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1)}px`;
              fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, isFixedLeft ? 0 : scrollbarWidth)}px`;
            }
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (fixedType) {
              if (!reactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
              tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse2["-moz"] || browse2.safari) ? `${scrollbarWidth}px` : "";
            }
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "footer") {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (fixedType) {
              if (!reactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
                if (!mergeFooterList.length || !footerSpanMethod) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (isNodeElement(wrapperElem)) {
              if (fixedWrapperElem) {
                wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight}px`;
              }
              wrapperElem.style.marginTop = `${-Math.max(1, scrollbarHeight)}px`;
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : "";
            }
          }
          const colgroupElem = getRefElem(elemStore[`${name}-${layout}-colgroup`]);
          if (colgroupElem) {
            import_xe_utils27.default.arrayEach(colgroupElem.children, (colElem) => {
              const colid = colElem.getAttribute("name");
              if (colid === "col_gutter") {
                colElem.style.width = `${scrollbarWidth}px`;
              }
              if (fullColumnIdData[colid]) {
                const colRest = fullColumnIdData[colid];
                const column = colRest.column;
                const { showHeaderOverflow, showFooterOverflow, showOverflow } = column;
                let cellOverflow;
                colElem.style.width = `${column.renderWidth}px`;
                if (layout === "header") {
                  cellOverflow = import_xe_utils27.default.isUndefined(showHeaderOverflow) || import_xe_utils27.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
                } else if (layout === "footer") {
                  cellOverflow = import_xe_utils27.default.isUndefined(showFooterOverflow) || import_xe_utils27.default.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
                } else {
                  cellOverflow = import_xe_utils27.default.isUndefined(showOverflow) || import_xe_utils27.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
                }
                const showEllipsis = cellOverflow === "ellipsis";
                const showTitle = cellOverflow === "title";
                const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
                let hasEllipsis = showTitle || showTooltip || showEllipsis;
                const listElem = getRefElem(elemStore[`${name}-${layout}-list`]);
                if (scrollYLoad && !hasEllipsis) {
                  hasEllipsis = true;
                }
                if (listElem) {
                  import_xe_utils27.default.arrayEach(listElem.querySelectorAll(`.${column.id}`), (elem) => {
                    const colspan = parseInt(elem.getAttribute("colspan") || 1);
                    const cellElem = elem.querySelector(".vxe-cell");
                    let colWidth = column.renderWidth;
                    if (cellElem) {
                      if (colspan > 1) {
                        const columnIndex = tableMethods.getColumnIndex(column);
                        for (let index3 = 1; index3 < colspan; index3++) {
                          const nextColumn = tableMethods.getColumns(columnIndex + index3);
                          if (nextColumn) {
                            colWidth += nextColumn.renderWidth;
                          }
                        }
                      }
                      cellElem.style.width = hasEllipsis ? `${colWidth - cellOffsetWidth * colspan}px` : "";
                    }
                  });
                }
              }
            });
          }
        });
      });
      if (currentRow) {
        tableMethods.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xeTable.addCellSelectedClass();
      }
      return nextTick();
    };
    const checkValidate = (type) => {
      if ($xeTable.triggerValidate) {
        return $xeTable.triggerValidate(type);
      }
      return nextTick();
    };
    const handleChangeCell = (evnt, params) => {
      checkValidate("blur").catch((e16) => e16).then(() => {
        $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e16) => e16);
      });
    };
    const handleDefaultSort = () => {
      const { sortConfig } = props;
      if (sortConfig) {
        const sortOpts = computeSortOpts.value;
        let { defaultSort } = sortOpts;
        if (defaultSort) {
          if (!import_xe_utils27.default.isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index2) => {
              const { field, order } = item;
              if (field && order) {
                const column = tableMethods.getColumnByField(field);
                if (column && column.sortable) {
                  column.order = order;
                  column.sortTime = Date.now() + index2;
                }
              }
            });
            if (!sortOpts.remote) {
              tablePrivateMethods.handleTableData(true).then(updateStyle);
            }
          }
        }
      }
    };
    const handleDefaultSelectionChecked = () => {
      const { checkboxConfig } = props;
      if (checkboxConfig) {
        const { fullDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkAll, checkRowKeys } = checkboxOpts;
        if (checkAll) {
          handleCheckedAllCheckboxRow(true, true);
        } else if (checkRowKeys) {
          const defSelection = [];
          checkRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          handleCheckedCheckboxRow(defSelection, true, true);
        }
      }
    };
    const handleDefaultRadioChecked = () => {
      const { radioConfig } = props;
      if (radioConfig) {
        const { fullDataRowIdData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const { checkRowKey: rowid, reserve } = radioOpts;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
          }
          if (reserve) {
            const rowkey = getRowkey($xeTable);
            internalData.radioReserveRow = { [rowkey]: rowid };
          }
        }
      }
    };
    const handleDefaultRowExpand = () => {
      const { expandConfig } = props;
      if (expandConfig) {
        const { fullDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { expandAll, expandRowKeys } = expandOpts;
        if (expandAll) {
          tableMethods.setAllRowExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          tableMethods.setRowExpand(defExpandeds, true);
        }
      }
    };
    const handleRadioReserveRow = (row) => {
      const radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row;
      }
    };
    const handleCheckboxReserveRow = (row, checked) => {
      const { checkboxReserveRowMap } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (checked) {
          checkboxReserveRowMap[rowid] = row;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    const handleCheckedRadioRow = (row, isForce) => {
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      if (row && (isForce || (!checkMethod || checkMethod({ row })))) {
        reactData.selectRadioRow = row;
        handleRadioReserveRow(row);
      }
      return nextTick();
    };
    const handleCheckedCheckboxRow = (rows, value, isForce) => {
      if (rows && !import_xe_utils27.default.isArray(rows)) {
        rows = [rows];
      }
      $xeTable.handleBatchSelectRows(rows, !!value, isForce);
      $xeTable.checkSelectionStatus();
      return nextTick();
    };
    const handleCheckedAllCheckboxRow = (checked, isForce) => {
      const { treeConfig } = props;
      const { selectCheckboxMaps } = reactData;
      const { afterFullData, checkboxReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkField, reserve, checkMethod } = checkboxOpts;
      const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
      const selectRowMaps = {};
      if (checkField) {
        const checkValFn = (row) => {
          if (isForce || (!checkMethod || checkMethod({ row }))) {
            if (checked) {
              selectRowMaps[getRowid($xeTable, row)] = row;
            }
            import_xe_utils27.default.set(row, checkField, checked);
          }
          if (treeConfig && indeterminateField) {
            import_xe_utils27.default.set(row, indeterminateField, false);
          }
        };
        if (treeConfig) {
          import_xe_utils27.default.eachTree(afterFullData, checkValFn, { children: childrenField });
        } else {
          afterFullData.forEach(checkValFn);
        }
      } else {
        if (treeConfig) {
          if (checked) {
            import_xe_utils27.default.eachTree(afterFullData, (row) => {
              if (isForce || (!checkMethod || checkMethod({ row }))) {
                selectRowMaps[getRowid($xeTable, row)] = row;
              }
            }, { children: childrenField });
          } else {
            if (!isForce && checkMethod) {
              import_xe_utils27.default.eachTree(afterFullData, (row) => {
                const rowid = getRowid($xeTable, row);
                if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              }, { children: childrenField });
            }
          }
        } else {
          if (checked) {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = getRowid($xeTable, row);
                if (selectCheckboxMaps[rowid] || checkMethod({ row })) {
                  selectRowMaps[rowid] = row;
                }
              });
            } else {
              afterFullData.forEach((row) => {
                selectRowMaps[getRowid($xeTable, row)] = row;
              });
            }
          } else {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = getRowid($xeTable, row);
                if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              });
            }
          }
        }
      }
      if (reserve) {
        if (checked) {
          import_xe_utils27.default.each(selectRowMaps, (row, rowid) => {
            checkboxReserveRowMap[rowid] = row;
          });
        } else {
          afterFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
      }
      reactData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
      reactData.isAllSelected = checked;
      reactData.isIndeterminate = false;
      reactData.treeIndeterminateMaps = {};
      internalData.treeIndeterminateRowMaps = {};
      tablePrivateMethods.checkSelectionStatus();
      return nextTick();
    };
    const handleReserveStatus = () => {
      const { treeConfig } = props;
      const { expandColumn, currentRow, selectCheckboxMaps, selectRadioRow, rowExpandedMaps, treeExpandedMaps } = reactData;
      const { fullDataRowIdData, fullAllDataRowIdData, radioReserveRow } = internalData;
      const expandOpts = computeExpandOpts.value;
      const treeOpts = computeTreeOpts.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xeTable, selectRadioRow)]) {
        reactData.selectRadioRow = null;
      }
      if (radioOpts.reserve && radioReserveRow) {
        const rowid = getRowid($xeTable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
        }
      }
      reactData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps);
      if (checkboxOpts.reserve) {
        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xeTable, currentRow)]) {
        reactData.currentRow = null;
      }
      reactData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {};
      if (expandColumn && expandOpts.reserve) {
        tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      reactData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {};
      if (treeConfig && treeOpts.reserve) {
        tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    const handleDefaultTreeExpand = () => {
      const { treeConfig } = props;
      if (treeConfig) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { expandAll, expandRowKeys } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (expandAll) {
          tableMethods.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          const rowkey = getRowkey($xeTable);
          expandRowKeys.forEach((rowid) => {
            const matchObj = import_xe_utils27.default.findTree(tableFullData, (item) => rowid === import_xe_utils27.default.get(item, rowkey), { children: childrenField });
            if (matchObj) {
              defExpandeds.push(matchObj.item);
            }
          });
          tableMethods.setTreeExpand(defExpandeds, true);
        }
      }
    };
    const handleAsyncTreeExpandChilds = (row) => {
      const treeOpts = computeTreeOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { transform: transform2, loadMethod } = treeOpts;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { treeExpandLazyLoadedMaps } = reactData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          treeExpandLazyLoadedMaps[rowid] = row;
          Promise.resolve(loadMethod({ $table: $xeTable, row })).then((childRecords) => {
            if (rowRest) {
              rowRest.treeLoaded = true;
            }
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
            if (!import_xe_utils27.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return tableMethods.loadTreeChildren(row, childRecords).then((childRows) => {
                const { treeExpandedMaps } = reactData;
                if (childRows.length && !treeExpandedMaps[rowid]) {
                  treeExpandedMaps[rowid] = row;
                }
                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row)) {
                  handleCheckedCheckboxRow(childRows, true);
                }
                return nextTick().then(() => {
                  if (transform2) {
                    tablePrivateMethods.handleTableData();
                    updateTreeDataIndex();
                    return nextTick();
                  }
                });
              });
            }
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: treeExpandLazyLoadedMaps2 } = reactData;
            if (rowRest) {
              rowRest.treeLoaded = false;
            }
            if (treeExpandLazyLoadedMaps2[rowid]) {
              delete treeExpandLazyLoadedMaps2[rowid];
            }
          }).finally(() => {
            nextTick().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleTreeExpandReserve = (row, expanded) => {
      const { treeExpandedReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleAsyncRowExpand = (row) => {
      return new Promise((resolve) => {
        const expandOpts = computeExpandOpts.value;
        const { loadMethod } = expandOpts;
        if (loadMethod) {
          const { fullAllDataRowIdData } = internalData;
          const { rowExpandLazyLoadedMaps } = reactData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          rowExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xeTable, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }).then(() => {
            const { rowExpandedMaps } = reactData;
            if (rowRest) {
              rowRest.expandLoaded = true;
            }
            rowExpandedMaps[rowid] = row;
          }).catch(() => {
            if (rowRest) {
              rowRest.expandLoaded = false;
            }
          }).finally(() => {
            const { rowExpandLazyLoadedMaps: rowExpandLazyLoadedMaps2 } = reactData;
            if (rowExpandLazyLoadedMaps2[rowid]) {
              delete rowExpandLazyLoadedMaps2[rowid];
            }
            nextTick().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleRowExpandReserve = (row, expanded) => {
      const { rowExpandedReserveRowMap } = internalData;
      const expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleDefaultMergeCells = () => {
      const { mergeCells } = props;
      if (mergeCells) {
        tableMethods.setMergeCells(mergeCells);
      }
    };
    const handleDefaultMergeFooterItems = () => {
      const { mergeFooterItems } = props;
      if (mergeFooterItems) {
        tableMethods.setMergeFooterItems(mergeFooterItems);
      }
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { scrollXStore, scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const sXOpts = computeSXOpts.value;
        if (scrollXLoad) {
          const { visibleSize: visibleXSize } = handleVirtualXVisible();
          const offsetXSize = Math.max(0, sXOpts.oSize ? import_xe_utils27.default.toNumber(sXOpts.oSize) : browse2.edge ? 5 : 0);
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          tablePrivateMethods.updateScrollXData();
        } else {
          tablePrivateMethods.updateScrollXSpace();
        }
        calcCellHeight();
        const rowHeight = computeRowHeight();
        scrollYStore.rowHeight = rowHeight;
        reactData.rowHeight = rowHeight;
        const { visibleSize: visibleYSize } = handleVirtualYVisible();
        if (scrollYLoad) {
          const offsetYSize = Math.max(0, sYOpts.oSize ? import_xe_utils27.default.toNumber(sYOpts.oSize) : browse2.edge ? 10 : 0);
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          tablePrivateMethods.updateScrollYData();
        } else {
          tablePrivateMethods.updateScrollYSpace();
        }
        nextTick(updateStyle);
      });
    };
    const handleRecalculateLayout = (reFull) => {
      const el2 = refElem.value;
      if (!el2 || !el2.clientWidth) {
        return nextTick();
      }
      calcCellWidth();
      autoCellWidth();
      return computeScrollLoad().then(() => {
        if (reFull === true) {
          calcCellHeight();
          calcCellWidth();
          autoCellWidth();
          return computeScrollLoad();
        }
      });
    };
    const loadTableData = (datas) => {
      const { keepSource, treeConfig, showOverflow } = props;
      const { editStore, scrollYLoad: oldScrollYLoad } = reactData;
      const { scrollYStore, scrollXStore, lastScrollLeft, lastScrollTop } = internalData;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const { transform: transform2 } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let treeData = [];
      let fullData = reactive(datas ? datas.slice(0) : []);
      if (treeConfig) {
        if (transform2) {
          if (true) {
            if (!treeOpts.rowField) {
              errLog("vxe.error.reqProp", ["tree-config.rowField"]);
            }
            if (!treeOpts.parentField) {
              errLog("vxe.error.reqProp", ["tree-config.parentField"]);
            }
            if (!childrenField) {
              errLog("vxe.error.reqProp", ["tree-config.childrenField"]);
            }
            if (!treeOpts.mapChildrenField) {
              errLog("vxe.error.reqProp", ["tree-config.mapChildrenField"]);
            }
            if (childrenField === treeOpts.mapChildrenField) {
              errLog("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"]);
            }
          }
          treeData = import_xe_utils27.default.toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: childrenField,
            mapChildren: treeOpts.mapChildrenField
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      }
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      reactData.scrollVMLoading = false;
      editStore.insertMaps = {};
      editStore.removeMaps = {};
      const sYLoad = updateScrollYStatus(fullData);
      reactData.scrollYLoad = sYLoad;
      reactData.isDragRowMove = false;
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = treeData;
      tablePrivateMethods.cacheRowMap(true);
      internalData.tableSynchData = datas;
      if (keepSource) {
        tablePrivateMethods.cacheSourceMap(fullData);
      }
      if (sYLoad) {
        if (showOverflow) {
          if (!rowOpts.height) {
            const errColumn = internalData.tableFullColumn.find((column) => column.showOverflow === false);
            if (errColumn) {
              errLog("vxe.error.errProp", [`column[field="${errColumn.field}"].show-overflow=false`, "show-overflow=true"]);
            }
          }
        }
        if (true) {
          if (!(props.height || props.maxHeight)) {
            errLog("vxe.error.reqProp", ["table.height | table.max-height | table.scroll-y={enabled: false}"]);
          }
          if (props.spanMethod) {
            warnLog("vxe.error.scrollErrProp", ["table.span-method"]);
          }
        }
      }
      if ($xeTable.clearCellAreas && props.mouseConfig) {
        $xeTable.clearCellAreas();
        $xeTable.clearCopyCellArea();
      }
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      tableMethods.updateFooter();
      return nextTick().then(() => {
        updateHeight();
        updateStyle();
      }).then(() => {
        computeScrollLoad();
      }).then(() => {
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        handleReserveStatus();
        tablePrivateMethods.checkSelectionStatus();
        return new Promise((resolve) => {
          nextTick().then(() => tableMethods.recalculate()).then(() => {
            let targetScrollLeft = lastScrollLeft;
            let targetScrollTop = lastScrollTop;
            const sXOpts = computeSXOpts.value;
            const sYOpts = computeSYOpts.value;
            if (sXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (sYOpts.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(resolve);
            } else {
              setTimeout(() => restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(resolve));
            }
          });
        });
      });
    };
    const handleLoadDefaults = () => {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultMergeCells();
      handleDefaultMergeFooterItems();
      nextTick(() => setTimeout(() => tableMethods.recalculate()));
    };
    const handleInitDefaults = () => {
      handleDefaultSort();
    };
    const handleTableColumn = () => {
      const { scrollXLoad } = reactData;
      const { visibleColumn, scrollXStore, fullColumnIdData } = internalData;
      const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach((column, $index) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    const loadScrollXData = () => {
      const { mergeList, mergeFooterList } = reactData;
      const { scrollXStore } = internalData;
      const { startIndex, endIndex, offsetSize } = scrollXStore;
      const { toVisibleIndex, visibleSize } = handleVirtualXVisible();
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffsetIndex(mergeList.concat(mergeFooterList), offsetItem, "col");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollXData();
        }
      }
      tableMethods.closeTooltip();
    };
    const getColumnList = (columns) => {
      const result = [];
      columns.forEach((column) => {
        result.push(...column.children && column.children.length ? getColumnList(column.children) : [column]);
      });
      return result;
    };
    const parseColumns = () => {
      const { showOverflow } = props;
      const rowOpts = computeRowOpts.value;
      const leftList = [];
      const centerList = [];
      const rightList = [];
      const { isGroup, columnStore } = reactData;
      const sXOpts = computeSXOpts.value;
      const { collectColumn, tableFullColumn, scrollXStore, fullColumnIdData } = internalData;
      if (isGroup) {
        const leftGroupList = [];
        const centerGroupList = [];
        const rightGroupList = [];
        import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
          const isColGroup = hasChildrenList(column);
          if (parent && parent.fixed) {
            column.fixed = parent.fixed;
          }
          if (parent && column.fixed !== parent.fixed) {
            errLog("vxe.error.groupFixed");
          }
          if (isColGroup) {
            column.visible = !!import_xe_utils27.default.findTree(column.children, (subColumn) => hasChildrenList(subColumn) ? false : subColumn.visible);
          } else if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
        collectColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftGroupList.push(column);
            } else if (column.fixed === "right") {
              rightGroupList.push(column);
            } else {
              centerGroupList.push(column);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
      } else {
        tableFullColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
      }
      const visibleColumn = leftList.concat(centerList).concat(rightList);
      const scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && (sXOpts.gt === 0 || sXOpts.gt < tableFullColumn.length);
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, { leftList, centerList, rightList });
      if (scrollXLoad) {
        if (showOverflow) {
          if (!rowOpts.height) {
            const errColumn = internalData.tableFullColumn.find((column) => column.showOverflow === false);
            if (errColumn) {
              errLog("vxe.error.errProp", [`column[field="${errColumn.field}"].show-overflow=false`, "show-overflow=true"]);
            }
          }
        }
        if (true) {
          if (props.spanMethod) {
            warnLog("vxe.error.scrollErrProp", ["span-method"]);
          }
          if (props.footerSpanMethod) {
            warnLog("vxe.error.scrollErrProp", ["footer-span-method"]);
          }
        }
        const { visibleSize } = handleVirtualXVisible();
        scrollXStore.startIndex = 0;
        scrollXStore.endIndex = visibleSize;
        scrollXStore.visibleSize = visibleSize;
      }
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index2) => column === visibleColumn[index2])) {
        tableMethods.clearMergeCells();
        tableMethods.clearMergeFooterItems();
      }
      reactData.scrollXLoad = scrollXLoad;
      visibleColumn.forEach((column, index2) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest._index = index2;
        }
      });
      internalData.visibleColumn = visibleColumn;
      handleTableColumn();
      return tableMethods.updateFooter().then(() => {
        return tableMethods.recalculate();
      }).then(() => {
        tableMethods.updateCellAreas();
        return tableMethods.recalculate();
      });
    };
    const initColumnSort = () => {
      const { collectColumn } = internalData;
      collectColumn.forEach((column, index2) => {
        const sortIndex = index2 + 1;
        column.sortNumber = sortIndex;
        column.renderSortNumber = sortIndex;
      });
    };
    const handleColumn = (collectColumn) => {
      internalData.collectColumn = collectColumn;
      const tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      reactData._isLoading = true;
      reactData.isDragColMove = false;
      initColumnSort();
      return Promise.resolve(restoreCustomStorage()).then(() => {
        reactData._isLoading = false;
        cacheColumnMap();
        parseColumns().then(() => {
          if (reactData.scrollXLoad) {
            loadScrollXData();
          }
        });
        tableMethods.clearMergeCells();
        tableMethods.clearMergeFooterItems();
        tablePrivateMethods.handleTableData(true);
        if (true) {
          if ((reactData.scrollXLoad || reactData.scrollYLoad) && reactData.expandColumn) {
            warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
          }
        }
        return nextTick().then(() => {
          if ($xeToolbar) {
            $xeToolbar.syncUpdate({
              collectColumn: internalData.collectColumn,
              $table: $xeTable
            });
          }
          if ($xeTable.handleUpdateCustomColumn) {
            $xeTable.handleUpdateCustomColumn();
          }
          return tableMethods.recalculate();
        });
      });
    };
    const updateScrollYStatus = (fullData) => {
      const { treeConfig } = props;
      const sYOpts = computeSYOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform: transform2 } = treeOpts;
      const allList = fullData || internalData.tableFullData;
      const scrollYLoad = (transform2 || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const handleBaseTreeExpand = (rows, expanded) => {
      const { treeExpandedMaps, treeExpandLazyLoadedMaps, treeNodeColumn } = reactData;
      const treeTempExpandedMaps = Object.assign({}, treeExpandedMaps);
      const { fullAllDataRowIdData, tableFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { reserve, lazy, accordion, toggleMethod } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      const result = [];
      const columnIndex = tableMethods.getColumnIndex(treeNodeColumn);
      const $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);
      let validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row })) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        const matchObj = import_xe_utils27.default.findTree(tableFullData, (item) => item === validRows[0], { children: childrenField });
        if (matchObj) {
          matchObj.items.forEach((item) => {
            const rowid = getRowid($xeTable, item);
            if (treeTempExpandedMaps[rowid]) {
              delete treeTempExpandedMaps[rowid];
            }
          });
        }
      }
      if (expanded) {
        validRows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (!treeTempExpandedMaps[rowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const isLoad = lazy && row[hasChildField] && !rowRest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
              if (isLoad) {
                result.push(handleAsyncTreeExpandChilds(row));
              } else {
                if (row[childrenField] && row[childrenField].length) {
                  treeTempExpandedMaps[rowid] = row;
                }
              }
            }
          }
        });
      } else {
        validRows.forEach((item) => {
          const rowid = getRowid($xeTable, item);
          if (treeTempExpandedMaps[rowid]) {
            delete treeTempExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach((row) => handleTreeExpandReserve(row, expanded));
      }
      reactData.treeExpandedMaps = treeTempExpandedMaps;
      return Promise.all(result).then(() => {
        return tableMethods.recalculate();
      });
    };
    const handleVirtualTreeExpand = (rows, expanded) => {
      return handleBaseTreeExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        tablePrivateMethods.handleTableData();
        updateTreeDataIndex();
      }).then(() => {
        return tableMethods.recalculate();
      }).then(() => {
        setTimeout(() => {
          tableMethods.updateCellAreas();
        }, 30);
      });
    };
    const handleCheckAllEvent = (evnt, value) => {
      handleCheckedAllCheckboxRow(value);
      if (evnt) {
        dispatchEvent2("checkbox-all", {
          records: tableMethods.getCheckboxRecords(),
          reserves: tableMethods.getCheckboxReserveRecords(),
          indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
          checked: value
        }, evnt);
      }
    };
    const loadScrollYData = () => {
      const { showOverflow } = props;
      const { mergeList } = reactData;
      const { tableHeight, scrollYStore } = internalData;
      const { startIndex, endIndex, offsetSize } = scrollYStore;
      const offsetYSize = showOverflow ? offsetSize : offsetSize + Math.min(8, Math.ceil(tableHeight / 200));
      const { toVisibleIndex, visibleSize } = handleVirtualYVisible();
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetYSize),
        endIndex: toVisibleIndex + visibleSize + offsetYSize
      };
      calculateMergerOffsetIndex(mergeList, offsetItem, "row");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollYData();
        }
      }
    };
    const createGetRowCacheProp = (prop) => {
      return function(row) {
        const { fullAllDataRowIdData } = internalData;
        if (row) {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return rowRest[prop];
          }
        }
        return -1;
      };
    };
    const createGetColumnCacheProp = (prop) => {
      return function(column) {
        const { fullColumnIdData } = internalData;
        if (column) {
          const colRest = fullColumnIdData[column.id];
          if (colRest) {
            return colRest[prop];
          }
        }
        return -1;
      };
    };
    const lazyScrollXData = () => {
      const { lxTimeout, lxRunTime, scrollXStore } = internalData;
      const { visibleSize } = scrollXStore;
      const fpsTime = Math.min(80, Math.floor(visibleSize * 3));
      if (lxTimeout) {
        clearTimeout(lxTimeout);
      }
      if (!lxRunTime || lxRunTime + fpsTime < Date.now()) {
        internalData.lxRunTime = Date.now();
        loadScrollXData();
      }
      internalData.lxTimeout = setTimeout(() => {
        internalData.lxRunTime = void 0;
        internalData.lxRunTime = void 0;
        loadScrollXData();
      }, fpsTime);
    };
    const lazyScrollYData = () => {
      const { lyTimeout, lyRunTime, scrollYStore } = internalData;
      const { visibleSize } = scrollYStore;
      const fpsTime = Math.min(80, Math.floor(visibleSize * 2));
      if (lyTimeout) {
        clearTimeout(lyTimeout);
      }
      if (!lyRunTime || lyRunTime + fpsTime < Date.now()) {
        internalData.lyRunTime = Date.now();
        loadScrollYData();
      }
      internalData.lyTimeout = setTimeout(() => {
        internalData.lyTimeout = void 0;
        internalData.lyRunTime = void 0;
        loadScrollYData();
      }, fpsTime);
    };
    const scrollXEvent = (evnt) => {
      const { inFooterScroll, inBodyScroll, lastScrollTop } = internalData;
      if (inFooterScroll) {
        return;
      }
      if (inBodyScroll) {
        return;
      }
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const bodyElem = tableBody.$el;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      const yHandleEl = refScrollYHandleElem.value;
      const wrapperEl = evnt.currentTarget;
      const { scrollLeft } = wrapperEl;
      const yBodyEl = yHandleEl || bodyElem;
      let scrollTop = 0;
      if (yBodyEl) {
        scrollTop = yBodyEl.scrollTop;
      }
      const isRollX = true;
      const isRollY = scrollTop !== lastScrollTop;
      internalData.inVirtualScroll = true;
      setScrollLeft(bodyElem, scrollLeft);
      setScrollLeft(headerElem, scrollLeft);
      setScrollLeft(footerElem, scrollLeft);
      $xeTable.triggerScrollXEvent(evnt);
      $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
        type: "table",
        fixed: ""
      });
    };
    const scrollYEvent = (evnt) => {
      const { inFooterScroll, inBodyScroll, lastScrollLeft } = internalData;
      if (inFooterScroll) {
        return;
      }
      if (inBodyScroll) {
        return;
      }
      const tableBody = refTableBody.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const bodyElem = tableBody.$el;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const xHandleEl = refScrollXHandleElem.value;
      const wrapperEl = evnt.currentTarget;
      const { scrollTop } = wrapperEl;
      const xBodyEl = xHandleEl || bodyElem;
      let scrollLeft = 0;
      if (xBodyEl) {
        scrollLeft = xBodyEl.scrollLeft;
      }
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = true;
      internalData.inVirtualScroll = true;
      setScrollTop(bodyElem, scrollTop);
      setScrollTop(leftElem, scrollTop);
      setScrollTop(rightElem, scrollTop);
      $xeTable.triggerScrollYEvent(evnt);
      $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
        type: "table",
        fixed: ""
      });
    };
    const checkLastSyncScroll = (isRollX, isRollY) => {
      const { scrollXLoad, scrollYLoad } = reactData;
      const { lcsTimeout } = internalData;
      if (lcsTimeout) {
        clearTimeout(lcsTimeout);
      }
      internalData.lcsTimeout = setTimeout(() => {
        internalData.lcsTimeout = void 0;
        internalData.inVirtualScroll = false;
        internalData.inBodyScroll = false;
        internalData.bodyScrollType = "";
        internalData.inFooterScroll = false;
        if (isRollX && scrollXLoad) {
          tablePrivateMethods.updateScrollXData();
        }
        if (isRollY && scrollYLoad) {
          tablePrivateMethods.updateScrollYData();
        }
        tableMethods.updateCellAreas();
      }, 200);
    };
    let keyCtxTimeout;
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent2(evnt, { $table: $xeTable, $grid: $xeGrid }, params));
    };
    const handleScrollToRowColumn = (fieldOrColumn, row) => {
      const { fullColumnIdData } = internalData;
      const column = handleFieldOrColumn($xeTable, fieldOrColumn);
      if (column && fullColumnIdData[column.id]) {
        return colToVisible($xeTable, column, row);
      }
      return nextTick();
    };
    tableMethods = {
      dispatchEvent: dispatchEvent2,
      /**
       * 
       */
      clearAll() {
        return clearTableAllStatus($xeTable);
      },
      /**
       *  data 
       * 
       * 
       */
      syncData() {
        warnLog("vxe.error.delFunc", ["syncData", "getData"]);
        return nextTick().then(() => {
          reactData.tableData = [];
          emit("update:data", internalData.tableFullData);
          return nextTick();
        });
      },
      /**
       * 
       * ...
       */
      updateData() {
        const { scrollXLoad, scrollYLoad } = reactData;
        return tablePrivateMethods.handleTableData(true).then(() => {
          tableMethods.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              tablePrivateMethods.updateScrollXSpace();
            }
            if (scrollYLoad) {
              tablePrivateMethods.updateScrollYSpace();
            }
            return tableMethods.refreshScroll();
          }
        }).then(() => {
          tableMethods.updateCellAreas();
          return tableMethods.recalculate(true);
        }).then(() => {
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 
       * @param {Array} datas 
       */
      loadData(datas) {
        const { initStatus } = internalData;
        return loadTableData(datas).then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 
       * @param {Array} datas 
       */
      reloadData(datas) {
        return tableMethods.clearAll().then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas);
        }).then(() => {
          handleLoadDefaults();
          return tableMethods.recalculate();
        });
      },
      /**
       * 
       */
      setRow(rows, record) {
        if (rows && record) {
          let rest = rows;
          if (!import_xe_utils27.default.isArray(rows)) {
            rest = [rows];
          }
          const rowkey = getRowkey($xeTable);
          rest.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            const newRecord = import_xe_utils27.default.clone(Object.assign({}, record), true);
            import_xe_utils27.default.set(newRecord, rowkey, rowid);
            Object.assign(row, newRecord);
          });
        }
        return nextTick();
      },
      /**
       * 
       * 
       * @param {Row} row 
       * @param {Object} record 
       * @param {String} field 
       */
      reloadRow(row, record, field) {
        const { keepSource } = props;
        const { tableData } = reactData;
        const { tableSourceData } = internalData;
        if (keepSource) {
          const rowIndex = tableMethods.getRowIndex(row);
          const oRow = tableSourceData[rowIndex];
          if (oRow && row) {
            if (field) {
              const newValue = import_xe_utils27.default.clone(import_xe_utils27.default.get(record || row, field), true);
              import_xe_utils27.default.set(row, field, newValue);
              import_xe_utils27.default.set(oRow, field, newValue);
            } else {
              const rowkey = getRowkey($xeTable);
              const rowid = getRowid($xeTable, row);
              const newRecord = import_xe_utils27.default.clone(Object.assign({}, record), true);
              import_xe_utils27.default.set(newRecord, rowkey, rowid);
              import_xe_utils27.default.destructuring(oRow, Object.assign(row, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        } else {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
        }
        return nextTick();
      },
      getParams() {
        return props.params;
      },
      /**
       * 
       */
      loadTreeChildren(row, childRecords) {
        const { keepSource } = props;
        const { tableSourceData, fullDataRowIdData, fullAllDataRowIdData, sourceDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const parentRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        const parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then((rows) => {
          if (keepSource) {
            const rowid = getRowid($xeTable, row);
            const matchObj = import_xe_utils27.default.findTree(tableSourceData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
            if (matchObj) {
              matchObj.item[childrenField] = import_xe_utils27.default.clone(rows, true);
            }
            rows.forEach((childRow) => {
              const rowid2 = getRowid($xeTable, childRow);
              sourceDataRowIdData[rowid2] = import_xe_utils27.default.clone(childRow, true);
            });
          }
          import_xe_utils27.default.eachTree(rows, (childRow, index2, items, path, parent, nodes) => {
            const rowid = getRowid($xeTable, childRow);
            const parentRow = parent || parentRest.row;
            const rest = { row: childRow, rowid, seq: -1, index: index2, _index: -1, $index: -1, items, parent: parentRow, level: parentLevel + nodes.length, height: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, { children: childrenField });
          row[childrenField] = rows;
          if (transform2) {
            row[mapChildrenField] = import_xe_utils27.default.clone(rows, false);
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      /**
       * 
       * 
       * @param {ColumnInfo} columns 
       */
      loadColumn(columns) {
        const collectColumn = import_xe_utils27.default.mapTree(columns, (column) => reactive(cell_default.createColumn($xeTable, column)));
        return handleColumn(collectColumn);
      },
      /**
       * 
       * 
       * @param {ColumnInfo} columns 
       */
      reloadColumn(columns) {
        return tableMethods.clearAll().then(() => {
          return tableMethods.loadColumn(columns);
        });
      },
      /**
       *  tr  row 
       * @param {Element} tr 
       */
      getRowNode(tr2) {
        if (tr2) {
          const { fullAllDataRowIdData } = internalData;
          const rowid = tr2.getAttribute("rowid");
          if (rowid) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              return {
                rowid: rowRest.rowid,
                item: rowRest.row,
                index: rowRest.index,
                items: rowRest.items,
                parent: rowRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       *  th/td  column 
       * @param {Element} cell 
       */
      getColumnNode(cell) {
        if (cell) {
          const { fullColumnIdData } = internalData;
          const colid = cell.getAttribute("colid");
          if (colid) {
            const colRest = fullColumnIdData[colid];
            if (colRest) {
              return {
                colid: colRest.colid,
                item: colRest.column,
                index: colRest.index,
                items: colRest.items,
                parent: colRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       *  row 
       * @param {Row} row 
       */
      getRowSeq: createGetRowCacheProp("seq"),
      /**
       *  row  data 
       * @param {Row} row 
       */
      getRowIndex: createGetRowCacheProp("index"),
      /**
       *  row 
       * @param {Row} row 
       */
      getVTRowIndex: createGetRowCacheProp("_index"),
      /**
       *  row 
       * @param {Row} row 
       */
      getVMRowIndex: createGetRowCacheProp("$index"),
      /**
       *  column  columns 
       * @param {ColumnInfo} column 
       */
      getColumnIndex: createGetColumnCacheProp("index"),
      /**
       *  column 
       * @param {ColumnInfo} column 
       */
      getVTColumnIndex: createGetColumnCacheProp("_index"),
      /**
       *  column 
       * @param {ColumnInfo} column 
       */
      getVMColumnIndex: createGetColumnCacheProp("$index"),
      /**
       *  data 
       * 
       * @param {Array} records 
       */
      createData(records) {
        return nextTick().then(() => {
          return reactive(tablePrivateMethods.defineField(records));
        });
      },
      /**
       *  Row|Rows 
       * 
       * @param {Array/Object} records 
       */
      createRow(records) {
        const isArr = import_xe_utils27.default.isArray(records);
        if (!isArr) {
          records = [records || {}];
        }
        return tableMethods.createData(records).then((rows) => isArr ? rows : rows[0]);
      },
      // toOriginalRecords (rows: any[]) {
      //   const { treeConfig } = props
      //   const treeOpts = computeTreeOpts.value
      //   const { transform, mapChildrenField } = treeOpts
      //   const rowkey = getRowkey($xeTable)
      //   if (treeConfig) {
      //     if (transform) {
      //       return []
      //     }
      //     return []
      //   }
      //   return rows.map(item => {
      //     const obj = Object.assign({}, item)
      //     delete obj.rowkey
      //     return obj
      //   })
      // },
      /**
       * 
       * 
       *  row 
       *  rows 
       *  field 
       */
      revertData(rows, field) {
        const { keepSource } = props;
        const { tableSourceData, sourceDataRowIdData } = internalData;
        if (!keepSource) {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
          return nextTick();
        }
        let targetRows = rows;
        if (rows) {
          if (!import_xe_utils27.default.isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = import_xe_utils27.default.toArray($xeTable.getUpdateRecords());
        }
        if (targetRows.length) {
          targetRows.forEach((row) => {
            if (!tableMethods.isInsertByRow(row)) {
              const rowid = getRowid($xeTable, row);
              const oRow = sourceDataRowIdData[rowid];
              if (oRow && row) {
                if (field) {
                  import_xe_utils27.default.set(row, field, import_xe_utils27.default.clone(import_xe_utils27.default.get(oRow, field), true));
                } else {
                  import_xe_utils27.default.destructuring(row, import_xe_utils27.default.clone(oRow, true));
                }
              }
            }
          });
        }
        if (rows) {
          return nextTick();
        }
        return tableMethods.reloadData(tableSourceData);
      },
      /**
       * 
       * 
       *  row 
       *  rows 
       *  field 
       * @param {Array/Row} rows 
       * @param {String} field 
       */
      clearData(rows, field) {
        const { tableFullData, visibleColumn } = internalData;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !import_xe_utils27.default.isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach((row) => import_xe_utils27.default.set(row, field, null));
        } else {
          rows.forEach((row) => {
            visibleColumn.forEach((column) => {
              if (column.field) {
                setCellValue(row, column, null);
              }
            });
          });
        }
        return nextTick();
      },
      getCellElement(row, fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const rowid = getRowid($xeTable, row);
        const tableBody = refTableBody.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        let bodyElem;
        if (column) {
          if (column.fixed) {
            if (column.fixed === "left") {
              if (leftBody) {
                bodyElem = leftBody.$el;
              }
            } else {
              if (rightBody) {
                bodyElem = rightBody.$el;
              }
            }
          }
          if (!bodyElem) {
            bodyElem = tableBody.$el;
          }
          if (bodyElem) {
            return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
          }
        }
        return null;
      },
      getCellLabel(row, fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const formatter = column.formatter;
        const cellValue = getCellValue(row, column);
        let cellLabel = cellValue;
        if (formatter) {
          let formatData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xeTable, row);
          const colid = column.id;
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            formatData = rowRest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rowRest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          const formatParams = { cellValue, row, rowIndex: tableMethods.getRowIndex(row), column, columnIndex: tableMethods.getColumnIndex(column) };
          if (import_xe_utils27.default.isString(formatter)) {
            const gFormatOpts = formats5.get(formatter);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams) : "";
          } else if (import_xe_utils27.default.isArray(formatter)) {
            const gFormatOpts = formats5.get(formatter[0]);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams, ...formatter.slice(1)) : "";
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = { value: cellValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      /**
       * 
       * @param {Row} row 
       */
      isInsertByRow(row) {
        const { editStore } = reactData;
        const rowid = getRowid($xeTable, row);
        return !!editStore.insertMaps[rowid];
      },
      /**
       * 
       * @returns
       */
      removeInsertRow() {
        const { editStore } = reactData;
        editStore.insertMaps = {};
        return $xeTable.remove($xeTable.getInsertRecords());
      },
      /**
       * 
       * @param {Row} row 
       * @param {String} field 
       */
      isUpdateByRow(row, field) {
        const { keepSource } = props;
        const { tableFullColumn, fullDataRowIdData, sourceDataRowIdData } = internalData;
        if (keepSource) {
          const rowid = getRowid($xeTable, row);
          if (!fullDataRowIdData[rowid]) {
            return false;
          }
          const oRow = sourceDataRowIdData[rowid];
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row, field);
            }
            for (let index2 = 0, len = tableFullColumn.length; index2 < len; index2++) {
              const property = tableFullColumn[index2].field;
              if (property && !eqCellValue(oRow, row, property)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      /**
       * 
       * @param {Number} columnIndex 
       */
      getColumns(columnIndex) {
        const columns = internalData.visibleColumn;
        return import_xe_utils27.default.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];
      },
      /**
       * 
       */
      getColid(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column ? column.id : null;
      },
      /**
       * 
       * @param {String} colid 
       */
      getColumnById(colid) {
        const fullColumnIdData = internalData.fullColumnIdData;
        return colid && fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      /**
       * 
       * @param {String} field 
       */
      getColumnByField(field) {
        const fullColumnFieldData = internalData.fullColumnFieldData;
        return field && fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      getParentColumn(fieldOrColumn) {
        const fullColumnIdData = internalData.fullColumnIdData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column && column.parentId && fullColumnIdData[column.parentId] ? fullColumnIdData[column.parentId].column : null;
      },
      /**
       * 
       * 
       */
      getTableColumn() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      /**
       * 
       */
      getFullColumns() {
        const { collectColumn } = internalData;
        return collectColumn.slice(0);
      },
      /**
       *  data 
       */
      getData(rowIndex) {
        const tableSynchData = props.data || internalData.tableSynchData;
        return import_xe_utils27.default.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      /**
       * 
       */
      getCheckboxRecords(isFull) {
        const { treeConfig } = props;
        const { tableFullData, afterFullData, afterTreeFullData, tableFullTreeData, fullDataRowIdData, afterFullRowMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const { checkField } = checkboxOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let rowList = [];
        const currTableData = isFull ? transform2 ? tableFullTreeData : tableFullData : transform2 ? afterTreeFullData : afterFullData;
        if (checkField) {
          if (treeConfig) {
            rowList = import_xe_utils27.default.filterTree(currTableData, (row) => import_xe_utils27.default.get(row, checkField), { children: transform2 ? mapChildrenField : childrenField });
          } else {
            rowList = currTableData.filter((row) => import_xe_utils27.default.get(row, checkField));
          }
        } else {
          const { selectCheckboxMaps } = reactData;
          import_xe_utils27.default.each(selectCheckboxMaps, (row, rowid) => {
            if (isFull) {
              if (fullDataRowIdData[rowid]) {
                rowList.push(fullDataRowIdData[rowid].row);
              }
            } else {
              if (afterFullRowMaps[rowid]) {
                rowList.push(afterFullRowMaps[rowid]);
              }
            }
          });
        }
        return rowList;
      },
      /**
       *  tree-config 
       */
      getTreeRowChildren(rowOrRowid) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils27.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullDataRowIdData[rowid];
            const row = rest ? rest.row : null;
            if (row) {
              return row[transform2 ? mapChildrenField : childrenField] || [];
            }
          }
        }
        return [];
      },
      /**
       *  tree-config 
       */
      getTreeParentRow(rowOrRowid) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils27.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullDataRowIdData[rowid];
            return rest ? rest.parent : null;
          }
        }
        return null;
      },
      getParentRow(rowOrRowid) {
        warnLog("vxe.error.delFunc", ["getParentRow", "getTreeParentRow"]);
        return $xeTable.getTreeParentRow(rowOrRowid);
      },
      /**
       * 
       * @param {String/Number} rowid 
       */
      getRowById(cellValue) {
        const { fullDataRowIdData } = internalData;
        const rowid = import_xe_utils27.default.eqNull(cellValue) ? "" : encodeURIComponent(cellValue || "");
        return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;
      },
      /**
       * 
       * @param {Row} row 
       */
      getRowid(row) {
        return getRowid($xeTable, row);
      },
      /**
       * 
       * 
       * 
       */
      getTableData() {
        const { tableData, footerTableData } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData } = internalData;
        return {
          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      /**
       *  tree-config 
       */
      getFullData() {
        const { treeConfig } = props;
        const { tableFullData, tableFullTreeData } = internalData;
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const { transform: transform2, mapChildrenField } = treeOpts;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          if (transform2) {
            return import_xe_utils27.default.toArrayTree(import_xe_utils27.default.toTreeArray(tableFullTreeData, {
              children: mapChildrenField
            }), { children: childrenField });
          }
          return tableFullTreeData.slice(0);
        }
        return tableFullData.slice(0);
      },
      /**
       * 
       */
      setColumnFixed(fieldOrColumn, fixed) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        const columnOpts = computeColumnOpts.value;
        const isMaxFixedColumn = computeIsMaxFixedColumn.value;
        for (let i = 0; i < cols.length; i++) {
          const item = cols[i];
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed !== fixed) {
            if (!targetColumn.fixed && isMaxFixedColumn) {
              if (VxeUI.modal) {
                VxeUI.modal.message({
                  status: "error",
                  content: getI18n10("vxe.table.maxFixedCol", [columnOpts.maxFixedSize])
                });
              }
              return nextTick();
            }
            import_xe_utils27.default.eachTree([targetColumn], (column2) => {
              column2.fixed = fixed;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        }
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 
       */
      clearColumnFixed(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed) {
            import_xe_utils27.default.eachTree([targetColumn], (column2) => {
              column2.fixed = null;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 
       */
      hideColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && column.visible) {
            column.visible = false;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      /**
       * 
       */
      showColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && !column.visible) {
            column.visible = true;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      setColumnWidth(fieldOrColumn, width) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column) {
            const colWidth = import_xe_utils27.default.toInteger(width);
            let rdWidth = colWidth;
            if (isScale(width)) {
              const tableBody = refTableBody.value;
              const bodyElem = tableBody ? tableBody.$el : null;
              const bodyWidth = bodyElem ? bodyElem.clientWidth - 1 : 0;
              rdWidth = Math.floor(colWidth * bodyWidth);
            }
            column.resizeWidth = rdWidth;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      getColumnWidth(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.renderWidth;
        }
        return 0;
      },
      /**
       * 
       *  true 
       * 
       */
      resetColumn(options) {
        warnLog("vxe.error.delFunc", ["resetColumn", "resetCustom"]);
        return $xeTable.resetCustom(options);
      },
      /**
       * 
       * 
       *  true 
       */
      refreshColumn(initOrder) {
        if (initOrder) {
          const columnList = import_xe_utils27.default.orderBy(internalData.collectColumn, "renderSortNumber");
          internalData.collectColumn = columnList;
          const tableFullColumn = getColumnList(columnList);
          internalData.tableFullColumn = tableFullColumn;
          cacheColumnMap();
        }
        return parseColumns().then(() => {
          return tableMethods.refreshScroll();
        }).then(() => {
          return tableMethods.recalculate();
        });
      },
      /**
       * 
       */
      refreshScroll() {
        const { lastScrollLeft, lastScrollTop } = internalData;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        return new Promise((resolve) => {
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xeTable, lastScrollLeft, lastScrollTop).then().then(() => {
              setTimeout(resolve, 30);
            });
          }
          setScrollTop(tableBodyElem, lastScrollTop);
          setScrollTop(leftBodyElem, lastScrollTop);
          setScrollTop(rightBodyElem, lastScrollTop);
          setScrollLeft(tableFooterElem, lastScrollLeft);
          setTimeout(resolve, 30);
        });
      },
      /**
       * 
       * 
       */
      recalculate(reFull) {
        return new Promise((resolve) => {
          const { rceTimeout } = internalData;
          const el2 = refElem.value;
          if (el2 && el2.clientWidth) {
            autoCellWidth();
          }
          if (rceTimeout) {
            clearTimeout(rceTimeout);
            nextTick(() => {
              resolve();
            });
          } else {
            resolve(handleRecalculateLayout(!!reFull));
          }
          internalData.rceTimeout = setTimeout(() => {
            internalData.rceTimeout = void 0;
            handleRecalculateLayout(!!reFull);
          }, 20);
        });
      },
      openTooltip(target, content) {
        const $commTip = refCommTooltip.value;
        if ($commTip && $commTip.open) {
          return $commTip.open(target, content);
        }
        return nextTick();
      },
      /**
       *  tooltip
       */
      closeTooltip() {
        const { tooltipStore } = reactData;
        const $tooltip = refTooltip.value;
        const $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false,
            currOpts: {}
          });
          if ($tooltip && $tooltip.close) {
            $tooltip.close();
          }
        }
        if ($commTip && $commTip.close) {
          $commTip.close();
        }
        return nextTick();
      },
      /**
       * 
       */
      isAllCheckboxChecked() {
        return reactData.isAllSelected;
      },
      /**
       * 
       */
      isAllCheckboxIndeterminate() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      /**
       * 
       */
      getCheckboxIndeterminateRecords(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        const { treeIndeterminateMaps } = reactData;
        if (treeConfig) {
          const fullRest = [];
          const defRest = [];
          import_xe_utils27.default.each(treeIndeterminateMaps, (item, rowid) => {
            if (item) {
              fullRest.push(item);
              if (fullDataRowIdData[rowid]) {
                defRest.push(item);
              }
            }
          });
          if (isFull) {
            return fullRest;
          }
          return defRest;
        }
        return [];
      },
      /**
       * 
       * @param {Array/Row} rows 
       * @param {Boolean} value 
       */
      setCheckboxRow(rows, checked) {
        if (rows && !import_xe_utils27.default.isArray(rows)) {
          rows = [rows];
        }
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      setCheckboxRowKey(keys, checked) {
        const { fullAllDataRowIdData } = internalData;
        if (!import_xe_utils27.default.isArray(keys)) {
          keys = [keys];
        }
        const rows = [];
        keys.forEach((rowid) => {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            rows.push(rowRest.row);
          }
        });
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      isCheckedByCheckboxRow(row) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          return import_xe_utils27.default.get(row, checkField);
        }
        return !!selectCheckboxMaps[getRowid($xeTable, row)];
      },
      isCheckedByCheckboxRowKey(rowid) {
        const { selectCheckboxMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return import_xe_utils27.default.get(rowRest.row, checkField);
          }
          return false;
        }
        return !!selectCheckboxMaps[rowid];
      },
      isIndeterminateByCheckboxRow(row) {
        const { treeIndeterminateMaps } = reactData;
        return !!treeIndeterminateMaps[getRowid($xeTable, row)] && !$xeTable.isCheckedByCheckboxRow(row);
      },
      isIndeterminateByCheckboxRowKey(rowid) {
        const { treeIndeterminateMaps } = reactData;
        return !!treeIndeterminateMaps[rowid] && !$xeTable.isCheckedByCheckboxRowKey(rowid);
      },
      /**
       * 
       */
      toggleCheckboxRow(row) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const checked = checkField ? !import_xe_utils27.default.get(row, checkField) : !selectCheckboxMaps[getRowid($xeTable, row)];
        tablePrivateMethods.handleBatchSelectRows([row], checked, true);
        tablePrivateMethods.checkSelectionStatus();
        return nextTick();
      },
      /**
       * 
       * @param {Boolean} value 
       */
      setAllCheckboxRow(value) {
        return handleCheckedAllCheckboxRow(value, true);
      },
      /**
       * 
       */
      getRadioReserveRecord(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, radioReserveRow, afterFullData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (radioOpts.reserve && radioReserveRow) {
          const rowid = getRowid($xeTable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid]) {
              return radioReserveRow;
            }
          } else {
            const rowkey = getRowkey($xeTable);
            if (treeConfig) {
              const matchObj = import_xe_utils27.default.findTree(afterFullData, (row) => rowid === import_xe_utils27.default.get(row, rowkey), { children: childrenField });
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some((row) => rowid === import_xe_utils27.default.get(row, rowkey))) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve() {
        internalData.radioReserveRow = null;
        return nextTick();
      },
      /**
       * 
       */
      getCheckboxReserveRecords(isFull) {
        const { treeConfig } = props;
        const { afterFullData, fullDataRowIdData, checkboxReserveRowMap } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const reserveSelection = [];
        if (checkboxOpts.reserve) {
          const afterFullIdMaps = {};
          if (treeConfig) {
            import_xe_utils27.default.eachTree(afterFullData, (row) => {
              afterFullIdMaps[getRowid($xeTable, row)] = 1;
            }, { children: childrenField });
          } else {
            afterFullData.forEach((row) => {
              afterFullIdMaps[getRowid($xeTable, row)] = 1;
            });
          }
          import_xe_utils27.default.each(checkboxReserveRowMap, (oldRow, oldRowid) => {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve() {
        internalData.checkboxReserveRowMap = {};
        return nextTick();
      },
      /**
       * 
       */
      toggleAllCheckboxRow() {
        handleCheckAllEvent(null, !reactData.isAllSelected);
        return nextTick();
      },
      /**
       * 
       * 
       */
      clearCheckboxRow() {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, reserve } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          const handleClearChecked = (item) => {
            if (treeConfig && indeterminateField) {
              import_xe_utils27.default.set(item, indeterminateField, false);
            }
            import_xe_utils27.default.set(item, checkField, false);
          };
          if (treeConfig) {
            import_xe_utils27.default.eachTree(tableFullData, handleClearChecked, { children: childrenField });
          } else {
            tableFullData.forEach(handleClearChecked);
          }
        }
        if (reserve) {
          tableFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        reactData.selectCheckboxMaps = {};
        reactData.treeIndeterminateMaps = {};
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      setCurrentRow(row) {
        const rowOpts = computeRowOpts.value;
        const el2 = refElem.value;
        tableMethods.clearCurrentRow();
        reactData.currentRow = row;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el2) {
            import_xe_utils27.default.arrayEach(el2.querySelectorAll(`[rowid="${getRowid($xeTable, row)}"]`), (elem) => addClass(elem, "row--current"));
          }
        }
        return nextTick();
      },
      isCheckedByRadioRow(row) {
        const { selectRadioRow } = reactData;
        if (row && selectRadioRow) {
          return $xeTable.eqRow(selectRadioRow, row);
        }
        return false;
      },
      isCheckedByRadioRowKey(key) {
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          return key === getRowid($xeTable, selectRadioRow);
        }
        return false;
      },
      /**
       * 
       * @param {Row} row 
       */
      setRadioRow(row) {
        return handleCheckedRadioRow(row, true);
      },
      /**
       * 
       * @param key 
       */
      setRadioRowKey(rowid) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return handleCheckedRadioRow(rowRest.row, true);
        }
        return nextTick();
      },
      /**
       * 
       */
      clearCurrentRow() {
        const el2 = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el2) {
          import_xe_utils27.default.arrayEach(el2.querySelectorAll(".row--current"), (elem) => removeClass(elem, "row--current"));
        }
        return nextTick();
      },
      /**
       * 
       */
      clearRadioRow() {
        reactData.selectRadioRow = null;
        return nextTick();
      },
      /**
       * 
       */
      getCurrentRecord() {
        const rowOpts = computeRowOpts.value;
        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;
      },
      /**
       * 
       */
      getRadioRecord(isFull) {
        const { fullDataRowIdData, afterFullRowMaps } = internalData;
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          const rowid = getRowid($xeTable, selectRadioRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return selectRadioRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return selectRadioRow;
            }
          }
        }
        return null;
      },
      getCurrentColumn() {
        const columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      /**
       * 
       */
      setCurrentColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          tableMethods.clearCurrentColumn();
          reactData.currentColumn = column;
        }
        return nextTick();
      },
      /**
       * 
       */
      clearCurrentColumn() {
        reactData.currentColumn = null;
        return nextTick();
      },
      setPendingRow(rows, status) {
        const pendingMaps = Object.assign({}, reactData.pendingRowMaps);
        if (rows && !import_xe_utils27.default.isArray(rows)) {
          rows = [rows];
        }
        if (status) {
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            if (rowid && !pendingMaps[rowid]) {
              pendingMaps[rowid] = row;
            }
          });
        } else {
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            if (rowid && pendingMaps[rowid]) {
              delete pendingMaps[rowid];
            }
          });
        }
        reactData.pendingRowMaps = pendingMaps;
        return nextTick();
      },
      togglePendingRow(rows) {
        const pendingMaps = Object.assign({}, reactData.pendingRowMaps);
        if (rows && !import_xe_utils27.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (rowid) {
            if (pendingMaps[rowid]) {
              delete pendingMaps[rowid];
            } else {
              pendingMaps[rowid] = row;
            }
          }
        });
        reactData.pendingRowMaps = pendingMaps;
        return nextTick();
      },
      hasPendingByRow(row) {
        return tableMethods.isPendingByRow(row);
      },
      isPendingByRow(row) {
        const { pendingRowMaps } = reactData;
        const rowid = getRowid($xeTable, row);
        return !!pendingRowMaps[rowid];
      },
      getPendingRecords() {
        const { pendingRowMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const insertRecords = [];
        import_xe_utils27.default.each(pendingRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      clearPendingRow() {
        reactData.pendingRowMaps = {};
        return nextTick();
      },
      sort(sortConfs, sortOrder) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (sortConfs) {
          if (import_xe_utils27.default.isString(sortConfs)) {
            sortConfs = [
              { field: sortConfs, order: sortOrder }
            ];
          }
        }
        if (!import_xe_utils27.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index2) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils27.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index2;
            }
          });
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return nextTick().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      setSort(sortConfs, isUpdate) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (!import_xe_utils27.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs && sortConfs.length) {
          if (!multiple) {
            sortConfs = [sortConfs[0]];
            clearAllSort();
          }
          let firstColumn = null;
          sortConfs.forEach((confs, index2) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils27.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (!firstColumn) {
              firstColumn = column;
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index2;
            }
          });
          if (isUpdate) {
            if (!remote) {
              tablePrivateMethods.handleTableData(true);
            }
            $xeTable.handleColumnSortEvent(new Event("click"), firstColumn);
          }
          return nextTick().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      /**
       * 
       * 
       * @param {String} fieldOrColumn 
       */
      clearSort(fieldOrColumn) {
        const sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            column.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          tablePrivateMethods.handleTableData(true);
        }
        return nextTick().then(updateStyle);
      },
      isSort(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          return column ? column.sortable && !!column.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns() {
        const sortOpts = computeSortOpts.value;
        const { multiple, chronological } = sortOpts;
        const sortList = [];
        const { tableFullColumn } = internalData;
        tableFullColumn.forEach((column) => {
          const { field, order } = column;
          if (column.sortable && order) {
            sortList.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return import_xe_utils27.default.orderBy(sortList, "sortTime");
        }
        return sortList;
      },
      /**
       * 
       * @param {Event} evnt 
       */
      closeFilter() {
        const { filterStore } = reactData;
        const { column, visible } = filterStore;
        Object.assign(filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          options: [],
          visible: false
        });
        if (visible) {
          dispatchEvent2("filter-visible", { column, property: column.field, field: column.field, filterList: $xeTable.getCheckedFilters(), visible: false }, null);
        }
        return nextTick();
      },
      /**
       * 
       * @param {String} fieldOrColumn 
       */
      isActiveFilterByColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.filters && column.filters.some((option2) => option2.checked);
        }
        return $xeTable.getCheckedFilters().length > 0;
      },
      isFilter(fieldOrColumn) {
        return tableMethods.isActiveFilterByColumn(fieldOrColumn);
      },
      /**
       * 
       * @param {Row} row 
       */
      isRowExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.expandLoaded;
      },
      clearRowExpandLoaded(row) {
        const { rowExpandLazyLoadedMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (lazy && rowRest) {
          rowRest.expandLoaded = false;
          delete rowExpandLazyLoadedMaps[rowid];
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      reloadRowExpand(row) {
        const { rowExpandLazyLoadedMaps } = reactData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
          tableMethods.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand(row));
        }
        return nextTick();
      },
      reloadExpandContent(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]);
        }
        return tableMethods.reloadRowExpand(row);
      },
      /**
       * 
       */
      toggleRowExpand(row) {
        return tableMethods.setRowExpand(row, !tableMethods.isRowExpandByRow(row));
      },
      /**
       * 
       * @param {Boolean} expanded 
       */
      setAllRowExpand(expanded) {
        const treeOpts = computeTreeOpts.value;
        const { tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let expandedRows = [];
        if (props.treeConfig) {
          import_xe_utils27.default.eachTree(tableFullTreeData, (row) => {
            expandedRows.push(row);
          }, { children: childrenField });
        } else {
          expandedRows = tableFullData;
        }
        return tableMethods.setRowExpand(expandedRows, expanded);
      },
      /**
       * 
       * 
       * 
       * @param {Array/Row} rows 
       * @param {Boolean} expanded 
       */
      setRowExpand(rows, expanded) {
        const { rowExpandedMaps, rowExpandLazyLoadedMaps, expandColumn: column } = reactData;
        const { fullAllDataRowIdData } = internalData;
        let rExpandedMaps = Object.assign({}, rowExpandedMaps);
        const expandOpts = computeExpandOpts.value;
        const { reserve, lazy, accordion, toggleMethod } = expandOpts;
        const lazyRests = [];
        const columnIndex = tableMethods.getColumnIndex(column);
        const $columnIndex = tableMethods.getVMColumnIndex(column);
        if (rows) {
          if (!import_xe_utils27.default.isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            rExpandedMaps = {};
            rows = rows.slice(rows.length - 1, rows.length);
          }
          const validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column, columnIndex, $columnIndex, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) })) : rows;
          if (expanded) {
            validRows.forEach((row) => {
              const rowid = getRowid($xeTable, row);
              if (!rExpandedMaps[rowid]) {
                const rowRest = fullAllDataRowIdData[rowid];
                const isLoad = lazy && !rowRest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row));
                } else {
                  rExpandedMaps[rowid] = row;
                }
              }
            });
          } else {
            validRows.forEach((item) => {
              const rowid = getRowid($xeTable, item);
              if (rExpandedMaps[rowid]) {
                delete rExpandedMaps[rowid];
              }
            });
          }
          if (reserve) {
            validRows.forEach((row) => handleRowExpandReserve(row, expanded));
          }
        }
        reactData.rowExpandedMaps = rExpandedMaps;
        return Promise.all(lazyRests).then(() => tableMethods.recalculate());
      },
      /**
       * 
       * @param {Row} row 
       */
      isRowExpandByRow(row) {
        const { rowExpandedMaps } = reactData;
        const rowid = getRowid($xeTable, row);
        return !!rowExpandedMaps[rowid];
      },
      isExpandByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]);
        }
        return tableMethods.isRowExpandByRow(row);
      },
      /**
       * 
       */
      clearRowExpand() {
        const { tableFullData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { reserve } = expandOpts;
        const expList = tableMethods.getRowExpandRecords();
        reactData.rowExpandedMaps = {};
        if (reserve) {
          tableFullData.forEach((row) => handleRowExpandReserve(row, false));
        }
        return nextTick().then(() => {
          if (expList.length) {
            tableMethods.recalculate();
          }
        });
      },
      clearRowExpandReserve() {
        internalData.rowExpandedReserveRowMap = {};
        return nextTick();
      },
      getRowExpandRecords() {
        const rest = [];
        import_xe_utils27.default.each(reactData.rowExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      getTreeExpandRecords() {
        const rest = [];
        import_xe_utils27.default.each(reactData.treeExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      /**
       * 
       * @param {Row} row 
       */
      isTreeExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.treeLoaded;
      },
      clearTreeExpandLoaded(row) {
        const { treeExpandedMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, lazy } = treeOpts;
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (lazy && rowRest) {
          rowRest.treeLoaded = false;
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        }
        if (transform2) {
          handleVirtualTreeToList();
          return tablePrivateMethods.handleTableData();
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      reloadTreeExpand(row) {
        const { treeExpandLazyLoadedMaps } = reactData;
        const treeOpts = computeTreeOpts.value;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { transform: transform2, lazy } = treeOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
          return tableMethods.clearTreeExpandLoaded(row).then(() => {
            return handleAsyncTreeExpandChilds(row);
          }).then(() => {
            if (transform2) {
              handleVirtualTreeToList();
              return tablePrivateMethods.handleTableData();
            }
          }).then(() => {
            return tableMethods.recalculate();
          });
        }
        return nextTick();
      },
      reloadTreeChilds(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]);
        }
        return tableMethods.reloadTreeExpand(row);
      },
      /**
       * /
       */
      toggleTreeExpand(row) {
        return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));
      },
      /**
       * 
       * @param {Boolean} expanded 
       */
      setAllTreeExpand(expanded) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, lazy } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const expandeds = [];
        import_xe_utils27.default.eachTree(tableFullData, (row) => {
          const rowChildren = row[childrenField];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row);
          }
        }, { children: childrenField });
        return tableMethods.setTreeExpand(expandeds, expanded).then(() => {
          if (transform2) {
            handleVirtualTreeToList();
            return tableMethods.recalculate();
          }
        });
      },
      /**
       * 
       * 
       * 
       * @param {Array/Row} rows 
       * @param {Boolean} expanded 
       */
      setTreeExpand(rows, expanded) {
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2 } = treeOpts;
        if (rows) {
          if (!import_xe_utils27.default.isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            if (transform2) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       */
      isTreeExpandByRow(row) {
        const { treeExpandedMaps } = reactData;
        return !!treeExpandedMaps[getRowid($xeTable, row)];
      },
      /**
       * 
       */
      clearTreeExpand() {
        const { tableFullTreeData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { transform: transform2, reserve } = treeOpts;
        const expList = tableMethods.getTreeExpandRecords();
        reactData.treeExpandedMaps = {};
        if (reserve) {
          import_xe_utils27.default.eachTree(tableFullTreeData, (row) => handleTreeExpandReserve(row, false), { children: childrenField });
        }
        return tablePrivateMethods.handleTableData().then(() => {
          if (transform2) {
            handleVirtualTreeToList();
            return tablePrivateMethods.handleTableData();
          }
        }).then(() => {
          if (expList.length) {
            return tableMethods.recalculate();
          }
        });
      },
      clearTreeExpandReserve() {
        internalData.treeExpandedReserveRowMap = {};
        return nextTick();
      },
      /**
       * 
       */
      getScroll() {
        const { scrollXLoad, scrollYLoad } = reactData;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody.$el;
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          scrollTop: bodyElem.scrollTop,
          scrollLeft: bodyElem.scrollLeft
        };
      },
      /**
       * 
       * @param {Number} scrollLeft 
       * @param {Number} scrollTop 
       */
      scrollTo(scrollLeft, scrollTop) {
        const tableBody = refTableBody.value;
        const tableHeader = refTableHeader.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableHeaderElem = tableHeader ? tableHeader.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (import_xe_utils27.default.isNumber(scrollLeft)) {
          const xHandleEl = refScrollXHandleElem.value;
          if (xHandleEl) {
            setScrollLeft(xHandleEl, scrollLeft);
          } else {
            setScrollLeft(tableBodyElem, scrollLeft);
            setScrollLeft(tableHeaderElem, scrollLeft);
            setScrollLeft(tableFooterElem, scrollLeft);
          }
        }
        if (import_xe_utils27.default.isNumber(scrollTop)) {
          const yHandleEl = refScrollYHandleElem.value;
          if (yHandleEl) {
            setScrollTop(yHandleEl, scrollTop);
          } else {
            setScrollTop(tableBodyElem, scrollTop);
            setScrollTop(leftBodyElem, scrollTop);
            setScrollTop(rightBodyElem, scrollTop);
          }
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise((resolve) => {
            setTimeout(() => {
              nextTick(() => {
                resolve();
              });
            }, 30);
          });
        }
        return nextTick();
      },
      /**
       * 
       * @param {Row} row 
       * @param {ColumnInfo} fieldOrColumn 
       */
      scrollToRow(row, fieldOrColumn) {
        const rest = [];
        if (row) {
          if (props.treeConfig) {
            rest.push(tablePrivateMethods.scrollToTreeRow(row));
          } else {
            rest.push(rowToVisible($xeTable, row));
          }
        }
        if (fieldOrColumn) {
          rest.push(handleScrollToRowColumn(fieldOrColumn, row));
        }
        return Promise.all(rest);
      },
      /**
       * 
       */
      scrollToColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && fullColumnIdData[column.id]) {
          return colToVisible($xeTable, column);
        }
        return nextTick();
      },
      /**
       * 
       */
      clearScroll() {
        const { scrollXStore, scrollYStore } = internalData;
        const tableBody = refTableBody.value;
        const tableHeader = refTableHeader.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableHeaderElem = tableHeader ? tableHeader.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        const xHandleEl = refScrollXHandleElem.value;
        if (xHandleEl) {
          setScrollLeft(xHandleEl, 0);
        } else {
          setScrollLeft(tableBodyElem, 0);
          setScrollLeft(tableHeaderElem, 0);
          setScrollLeft(tableFooterElem, 0);
        }
        const yHandleEl = refScrollYHandleElem.value;
        if (yHandleEl) {
          setScrollTop(yHandleEl, 0);
        } else {
          setScrollTop(tableBodyElem, 0);
          setScrollTop(leftBodyElem, 0);
          setScrollTop(rightBodyElem, 0);
        }
        scrollXStore.startIndex = 0;
        scrollXStore.endIndex = scrollXStore.visibleSize;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = scrollYStore.visibleSize;
        return nextTick().then(() => {
          setScrollLeft(tableBodyElem, 0);
          setScrollLeft(tableHeaderElem, 0);
          setScrollLeft(tableFooterElem, 0);
          setScrollTop(tableBodyElem, 0);
          setScrollTop(leftBodyElem, 0);
          setScrollTop(rightBodyElem, 0);
        });
      },
      /**
       * 
       */
      updateFooter() {
        const { showFooter, footerData, footerMethod } = props;
        const { visibleColumn, afterFullData } = internalData;
        let footData = [];
        if (showFooter && footerData && footerData.length) {
          footData = footerData.slice(0);
        } else if (showFooter && footerMethod) {
          footData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xeTable, $grid: $xeGrid }) : [];
        }
        reactData.footerTableData = footData;
        return nextTick();
      },
      /**
       *  updateStatus({ row, column }, cellValue)
       *  v-model  change 
       * 
       */
      updateStatus(slotParams, cellValue) {
        const customVal = !import_xe_utils27.default.isUndefined(cellValue);
        return nextTick().then(() => {
          const { editRules } = props;
          const { validStore } = reactData;
          const tableBody = refTableBody.value;
          if (slotParams && tableBody && editRules) {
            const { row, column } = slotParams;
            const type = "change";
            if ($xeTable.hasCellRules) {
              if ($xeTable.hasCellRules(type, row, column)) {
                const cell = tableMethods.getCellElement(row, column);
                if (cell) {
                  return $xeTable.validCellRules(type, row, column, cellValue).then(() => {
                    if (customVal && validStore.visible) {
                      setCellValue(row, column, cellValue);
                    }
                    $xeTable.clearValidate(row, column);
                  }).catch(({ rule }) => {
                    if (customVal) {
                      setCellValue(row, column, cellValue);
                    }
                    $xeTable.showValidTooltip({ rule, row, column, cell });
                  });
                }
              }
            }
          }
        });
      },
      /**
       * 
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        setMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      /**
       * 
       * @param {TableMergeConfig[]} merges  [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 
       */
      getMergeCells() {
        return reactData.mergeList.slice(0);
      },
      /**
       * 
       */
      clearMergeCells() {
        reactData.mergeList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        setMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      removeMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 
       */
      getMergeFooterItems() {
        return reactData.mergeFooterList.slice(0);
      },
      /**
       * 
       */
      clearMergeFooterItems() {
        reactData.mergeFooterList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      updateCellAreas() {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xeTable.handleRecalculateCellAreas) {
          return $xeTable.handleRecalculateCellAreas();
        }
        return nextTick();
      },
      getCustomStoreData() {
        const { id: id2 } = props;
        const customOpts = computeCustomOpts.value;
        const { collectColumn } = internalData;
        const { checkMethod } = customOpts;
        const resizableData = {};
        const sortData = {};
        const visibleData = {};
        const fixedData = {};
        const storeData2 = {
          resizableData: void 0,
          sortData: void 0,
          visibleData: void 0,
          fixedData: void 0
        };
        if (!id2) {
          errLog("vxe.error.reqProp", ["id"]);
          return storeData2;
        }
        let hasResizable = 0;
        let hasSort = 0;
        let hasFixedt = 0;
        let hasVisible = 0;
        import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
          if (!parent) {
            collectColumn.forEach((column2) => {
              const colKey = column2.getKey();
              if (colKey) {
                hasSort = 1;
                sortData[colKey] = column2.renderSortNumber;
              }
            });
            if (column.fixed && column.fixed !== column.defaultFixed) {
              const colKey = column.getKey();
              if (colKey) {
                hasFixedt = 1;
                fixedData[colKey] = column.fixed;
              }
            }
          }
          if (column.resizeWidth) {
            const colKey = column.getKey();
            if (colKey) {
              hasResizable = 1;
              resizableData[colKey] = column.renderWidth;
            }
          }
          if (!checkMethod || checkMethod({ column })) {
            if (!column.visible && column.defaultVisible) {
              const colKey = column.getKey();
              if (colKey) {
                hasVisible = 1;
                visibleData[colKey] = false;
              }
            } else if (column.visible && !column.defaultVisible) {
              const colKey = column.getKey();
              if (colKey) {
                hasVisible = 1;
                visibleData[colKey] = true;
              }
            }
          }
        });
        if (hasResizable) {
          storeData2.resizableData = resizableData;
        }
        if (hasSort) {
          storeData2.sortData = sortData;
        }
        if (hasFixedt) {
          storeData2.fixedData = fixedData;
        }
        if (hasVisible) {
          storeData2.visibleData = visibleData;
        }
        return storeData2;
      },
      focus() {
        internalData.isActivated = true;
        return nextTick();
      },
      blur() {
        internalData.isActivated = false;
        return nextTick();
      },
      /**
       * 
       * @param $toolbar
       */
      connect($toolbar) {
        if ($toolbar) {
          $xeToolbar = $toolbar;
          $xeToolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xeTable });
        } else {
          errLog("vxe.error.barUnableLink");
        }
        return nextTick();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { editStore, ctxMenuStore, filterStore, customStore } = reactData;
      const { mouseConfig, editRules } = props;
      const el2 = refElem.value;
      const editOpts = computeEditOpts.value;
      const validOpts = computeValidOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { actived } = editStore;
      const $validTooltip = refValidTooltip.value;
      const tableFilter = refTableFilter.value;
      const tableCustom = refTableCustom.value;
      const tableMenu = refTableMenu.value;
      if (tableFilter) {
        if (getEventTargetNode(evnt, el2, "vxe-cell--filter").flag) {
        } else if (getEventTargetNode(evnt, tableFilter.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearFilter", filterStore.args, tableMethods.closeFilter);
          }
        }
      }
      if (tableCustom) {
        if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, "vxe-toolbar-custom-target").flag) {
        } else if (getEventTargetNode(evnt, tableCustom.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearCustom", {}, () => {
              if ($xeTable.closeCustom) {
                $xeTable.closeCustom();
              }
            });
          }
        }
      }
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          const cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {
            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearEdit", actived.args, () => {
                  let isClear;
                  if (editOpts.mode === "row") {
                    const rowTargetNode = getEventTargetNode(evnt, el2, "vxe-body--row");
                    const rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    isClear = rowNodeRest ? !$xeTable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    isClear = !getEventTargetNode(evnt, el2, "col--edit").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el2, "vxe-header--row").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el2, "vxe-footer--row").flag;
                  }
                  if (!isClear && props.height && !reactData.overflowY) {
                    const bodyWrapperElem = evnt.target;
                    if (hasClass(bodyWrapperElem, "vxe-table--body-wrapper")) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear || // 
                  !getEventTargetNode(evnt, el2).flag) {
                    setTimeout(() => {
                      $xeTable.handleClearEdit(evnt).then(() => {
                        if (!internalData.isActivated && editRules && validOpts.autoClear) {
                          reactData.validErrorMaps = {};
                        }
                      });
                    });
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el2).flag && !($xeGrid && getEventTargetNode(evnt, $xeGrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xeToolbar && getEventTargetNode(evnt, $xeToolbar.getRefMaps().refElem.value).flag)) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if (areaOpts.autoClear) {
            if ($xeTable.getCellAreas) {
              const cellAreas = $xeTable.getCellAreas();
              if (cellAreas && cellAreas.length && !getEventTargetNode(evnt, document.body, "vxe-table--ignore-areas-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearAreas", {}, () => {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                  dispatchEvent2("clear-cell-area-selection", { cellAreas }, evnt);
                });
              }
            }
          }
        }
      }
      if ($xeTable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xeTable.closeMenu();
        }
      }
      const isActivated = getEventTargetNode(evnt, $xeGrid ? $xeGrid.getRefMaps().refElem.value : el2).flag;
      if (!isActivated && editRules && validOpts.autoClear) {
        reactData.validErrorMaps = {};
      }
      internalData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const handleGlobalMousewheelEvent = () => {
      tableMethods.closeTooltip();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const keydownEvent = (evnt) => {
      const { mouseConfig, keyboardConfig } = props;
      const { filterStore, ctxMenuStore, editStore } = reactData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      const isEsc = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          dispatchEvent2("keydown-start", {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          }
          dispatchEvent2("keydown", {}, evnt);
          dispatchEvent2("keydown-end", {}, evnt);
        });
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      if (internalData.isActivated) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          const { mouseConfig, keyboardConfig, treeConfig, editConfig, highlightCurrentRow } = props;
          const { ctxMenuStore, editStore, currentRow } = reactData;
          const { afterFullData } = internalData;
          const isMenu = computeIsMenu.value;
          const bodyMenu = computeBodyMenu.value;
          const keyboardOpts = computeKeyboardOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const editOpts = computeEditOpts.value;
          const treeOpts = computeTreeOpts.value;
          const menuList = computeMenuList.value;
          const rowOpts = computeRowOpts.value;
          const { selected, actived } = editStore;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const keyCode = evnt.keyCode;
          const isEsc = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ESCAPE);
          const hasBackspaceKey = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.BACKSPACE);
          const isTab = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.TAB);
          const isEnter = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ENTER);
          const isSpacebar = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.SPACEBAR);
          const isLeftArrow = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_LEFT);
          const isUpArrow = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_UP);
          const isRightArrow = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_RIGHT);
          const isDwArrow = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_DOWN);
          const hasDeleteKey = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.DELETE);
          const isF2 = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.F2);
          const isContextMenu = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.CONTEXT_MENU);
          const hasMetaKey = evnt.metaKey;
          const hasCtrlKey = evnt.ctrlKey;
          const hasShiftKey = evnt.shiftKey;
          const isAltKey = evnt.altKey;
          const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          const operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
          if (operCtxMenu) {
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selectChild", isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selected", isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (isEsc) {
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === "checkbox" || selected.column.type === "radio")) {
            evnt.preventDefault();
            if (selected.column.type === "checkbox") {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xeTable.handleEdit(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(keyCtxTimeout);
            keyCtxTimeout = setTimeout(() => {
              internalData._keyCtx = false;
            }, 1e3);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            const { isLastEnterAppendRow, beforeEnterMethod, enterMethod } = keyboardOpts;
            if (hasCtrlKey) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => {
                    $xeTable.handleSelected(params, evnt);
                  });
                }
              }
            } else {
              if (selected.row || actived.row) {
                const activeParams = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    $xeTable.moveSelected(activeParams, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    const activeRow = selected.row || actived.row;
                    const activeColumn = selected.column || actived.column;
                    const _rowIndex = $xeTable.getVTRowIndex(activeRow);
                    const etrParams = {
                      row: activeRow,
                      rowIndex: $xeTable.getRowIndex(activeRow),
                      $rowIndex: $xeTable.getVMRowIndex(activeRow),
                      _rowIndex,
                      column: activeColumn,
                      columnIndex: $xeTable.getColumnIndex(activeColumn),
                      $columnIndex: $xeTable.getVMColumnIndex(activeColumn),
                      _columnIndex: $xeTable.getVTColumnIndex(activeColumn),
                      $table: $xeTable
                    };
                    if (!beforeEnterMethod || beforeEnterMethod(etrParams) !== false) {
                      if (isLastEnterAppendRow) {
                        if (_rowIndex >= afterFullData.length - 1) {
                          $xeTable.insertAt({}, -1).then(({ row: newRow }) => {
                            $xeTable.scrollToRow(newRow, activeColumn);
                            $xeTable.handleSelected(Object.assign(Object.assign({}, activeParams), { row: newRow }), evnt);
                          });
                          $xeTable.dispatchEvent("enter-append-row", etrParams, evnt);
                          return;
                        }
                      }
                      $xeTable.moveSelected(activeParams, isLeftArrow, false, isRightArrow, true, evnt);
                      if (enterMethod) {
                        enterMethod(etrParams);
                      }
                    }
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const childrens = currentRow[childrenField];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  const targetRow = childrens[0];
                  const params = {
                    $table: $xeTable,
                    row: targetRow,
                    rowIndex: tableMethods.getRowIndex(targetRow),
                    $rowIndex: tableMethods.getVMRowIndex(targetRow)
                  };
                  tableMethods.setTreeExpand(currentRow, true).then(() => tableMethods.scrollToRow(targetRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                $xeTable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            if (selected.row || selected.column) {
              $xeTable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xeTable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && keyboardOpts.isDel && hasDeleteKey && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { delMethod } = keyboardOpts;
              const params = {
                row: selected.row,
                rowIndex: tableMethods.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: tableMethods.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              if (!beforeEditMethod || beforeEditMethod(params)) {
                if (delMethod) {
                  delMethod(params);
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                tableMethods.updateFooter();
                dispatchEvent2("cell-delete-value", params, evnt);
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && keyboardOpts.isBack && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { backMethod } = keyboardOpts;
              if (keyboardOpts.isDel && isEnableConf(editConfig) && (selected.row || selected.column)) {
                const params = {
                  row: selected.row,
                  rowIndex: tableMethods.getRowIndex(selected.row),
                  column: selected.column,
                  columnIndex: tableMethods.getColumnIndex(selected.column),
                  $table: $xeTable,
                  $grid: $xeGrid
                };
                if (!beforeEditMethod || beforeEditMethod(params)) {
                  if (backMethod) {
                    backMethod(params);
                  } else {
                    setCellValue(selected.row, selected.column, null);
                    $xeTable.handleEdit(selected.args, evnt);
                  }
                  dispatchEvent2("cell-backspace-value", params, evnt);
                }
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && treeConfig && keyboardOpts.isBack && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
            const { parent: parentRow } = import_xe_utils27.default.findTree(internalData.afterTreeFullData, (item) => item === currentRow, { children: childrenField });
            if (parentRow) {
              evnt.preventDefault();
              const params = {
                row: parentRow,
                rowIndex: tableMethods.getRowIndex(parentRow),
                $rowIndex: tableMethods.getVMRowIndex(parentRow),
                $table: $xeTable,
                $grid: $xeGrid
              };
              tableMethods.setTreeExpand(parentRow, false).then(() => tableMethods.scrollToRow(parentRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            const { editMode, editMethod } = keyboardOpts;
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              const beforeEditMethod2 = editOpts.beforeEditMethod || editOpts.activeMethod;
              const params = {
                row: selected.row,
                rowIndex: tableMethods.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: tableMethods.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              if (!beforeEditMethod2 || beforeEditMethod2(Object.assign(Object.assign({}, selected.args), { $table: $xeTable, $grid: $xeGrid }))) {
                if (editMethod) {
                  editMethod(params);
                } else {
                  if (editMode !== "insert") {
                    setCellValue(selected.row, selected.column, null);
                  }
                  $xeTable.handleEdit(selected.args, evnt);
                }
              }
            }
          }
          dispatchEvent2("keydown", {}, evnt);
        });
      }
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handlePasteCellAreaEvent) {
            $xeTable.handlePasteCellAreaEvent(evnt);
          }
        }
        dispatchEvent2("paste", {}, evnt);
      }
    };
    const handleGlobalCopyEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCopyCellAreaEvent) {
            $xeTable.handleCopyCellAreaEvent(evnt);
          }
        }
        dispatchEvent2("copy", {}, evnt);
      }
    };
    const handleGlobalCutEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCutCellAreaEvent) {
            $xeTable.handleCutCellAreaEvent(evnt);
          }
        }
        dispatchEvent2("cut", {}, evnt);
      }
    };
    const handleGlobalResizeEvent = () => {
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      const el2 = refElem.value;
      if (!el2 || !el2.clientWidth) {
        return nextTick();
      }
      tableMethods.recalculate(true);
      tableMethods.updateCellAreas();
    };
    const handleTargetEnterEvent = (isClear) => {
      const $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(true);
        }
      }
    };
    const clearRowDropOrigin = () => {
      const el2 = refElem.value;
      if (el2) {
        const clss = "row--drag-origin";
        import_xe_utils27.default.arrayEach(el2.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateRowDropOrigin = (row) => {
      const el2 = refElem.value;
      if (el2) {
        const clss = "row--drag-origin";
        const rowid = getRowid($xeTable, row);
        import_xe_utils27.default.arrayEach(el2.querySelectorAll(`[rowid="${rowid}"]`), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const updateRowDropTipContent = (tdEl) => {
      const { dragConfig } = props;
      const { dragRow } = reactData;
      const rowDragOpts = computeRowDragOpts.value;
      const { tooltipMethod } = rowDragOpts;
      const rTooltipMethod = tooltipMethod || (dragConfig ? dragConfig.rowTooltipMethod : null);
      let tipContent = "";
      if (rTooltipMethod) {
        tipContent = `${rTooltipMethod({
          row: dragRow
        }) || ""}`;
      } else {
        tipContent = getI18n10("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const updateColDropOrigin = (column) => {
      const el2 = refElem.value;
      if (el2) {
        const colQuerys = [];
        import_xe_utils27.default.eachTree([column], (item) => {
          colQuerys.push(`[colid="${item.id}"]`);
        });
        const clss = "col--drag-origin";
        import_xe_utils27.default.arrayEach(el2.querySelectorAll(colQuerys.join(",")), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const clearColDropOrigin = () => {
      const el2 = refElem.value;
      if (el2) {
        const clss = "col--drag-origin";
        import_xe_utils27.default.arrayEach(el2.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateColDropTipContent = (tdEl) => {
      const { dragCol } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const { tooltipMethod } = columnDragOpts;
      let tipContent = "";
      if (tooltipMethod) {
        tipContent = `${tooltipMethod({
          column: dragCol
        }) || ""}`;
      } else {
        tipContent = getI18n10("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const showDropTip = (evnt, trEl, thEl, showLine, dragPos) => {
      const el2 = refElem.value;
      if (!el2) {
        return;
      }
      const { scrollbarWidth, scrollbarHeight } = reactData;
      const { prevDragToChild } = internalData;
      const wrapperRect = el2.getBoundingClientRect();
      if (trEl) {
        const rdLineEl = refDragRowLineElem.value;
        if (rdLineEl) {
          if (showLine) {
            const trRect = trEl.getBoundingClientRect();
            rdLineEl.style.display = "block";
            rdLineEl.style.top = `${Math.max(1, trRect.y - wrapperRect.y)}px`;
            rdLineEl.style.height = `${trRect.height}px`;
            rdLineEl.style.width = `${wrapperRect.width - scrollbarWidth}px`;
            rdLineEl.setAttribute("drag-pos", dragPos);
            rdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            rdLineEl.style.display = "";
          }
        }
      } else if (thEl) {
        const cdLineEl = refDragColLineElem.value;
        if (cdLineEl) {
          if (showLine) {
            const thRect = thEl.getBoundingClientRect();
            const offsetTop = Math.max(0, thRect.y - wrapperRect.y);
            cdLineEl.style.display = "block";
            cdLineEl.style.top = `${offsetTop}px`;
            cdLineEl.style.left = `${Math.max(1, thRect.x - wrapperRect.x)}px`;
            cdLineEl.style.width = `${thRect.width}px`;
            if (prevDragToChild) {
              cdLineEl.style.height = `${thRect.height}px`;
            } else {
              cdLineEl.style.height = `${wrapperRect.height - offsetTop - scrollbarHeight}px`;
            }
            cdLineEl.setAttribute("drag-pos", dragPos);
            cdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            cdLineEl.style.display = "";
          }
        }
      }
      const rdTipEl = refDragTipElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "block";
        rdTipEl.style.top = `${Math.min(el2.clientHeight - el2.scrollTop - rdTipEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
        rdTipEl.style.left = `${Math.min(el2.clientWidth - el2.scrollLeft - rdTipEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
        rdTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const rdTipEl = refDragTipElem.value;
      const rdLineEl = refDragRowLineElem.value;
      const cdLineEl = refDragColLineElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "";
      }
      if (rdLineEl) {
        rdLineEl.style.display = "";
      }
      if (cdLineEl) {
        cdLineEl.style.display = "";
      }
    };
    const handleTooltip = (evnt, cell, overflowElem, tipElem, params) => {
      params.cell = cell;
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      const { column, row } = params;
      const { showAll, contentMethod } = tooltipOpts;
      const customContent = contentMethod ? contentMethod(params) : null;
      const useCustom = contentMethod && !import_xe_utils27.default.eqNull(customContent);
      const content = useCustom ? customContent : import_xe_utils27.default.toString(column.type === "html" ? overflowElem.innerText : overflowElem.textContent).trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      if (content && (showAll || useCustom || isCellOverflow)) {
        Object.assign(tooltipStore, {
          row,
          column,
          visible: true,
          currOpts: {}
        });
        nextTick(() => {
          const $tooltip = refTooltip.value;
          if ($tooltip && $tooltip.open) {
            $tooltip.open(isCellOverflow ? overflowElem : tipElem || overflowElem, formatText(content));
          }
        });
      }
      return nextTick();
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if ($xeGrid) {
          return $xeGrid.callSlot(slotFunc, params);
        }
        if (import_xe_utils27.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    tablePrivateMethods = {
      getSetupOptions() {
        return getConfig4();
      },
      updateAfterDataIndex,
      callSlot,
      /**
       * 
       */
      getParentElem() {
        const el2 = refElem.value;
        if ($xeGrid) {
          const gridEl = $xeGrid.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el2 ? el2.parentNode : null;
      },
      /**
       * 
       */
      getParentHeight() {
        const { height } = props;
        const el2 = refElem.value;
        if (el2) {
          const parentElem = el2.parentNode;
          const parentPaddingSize = height === "100%" || height === "auto" ? getPaddingTopBottomSize(parentElem) : 0;
          return Math.floor($xeGrid ? $xeGrid.getParentHeight() : import_xe_utils27.default.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);
        }
        return 0;
      },
      /**
       * 
       * 
       * 
       */
      getExcludeHeight() {
        return $xeGrid ? $xeGrid.getExcludeHeight() : 0;
      },
      /**
       * 
       * @param {Row} records 
       */
      defineField(records) {
        const { treeConfig } = props;
        const expandOpts = computeExpandOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rowkey = getRowkey($xeTable);
        if (!import_xe_utils27.default.isArray(records)) {
          records = [records];
        }
        return records.map((record) => {
          internalData.tableFullColumn.forEach((column) => {
            const { field, editRender } = column;
            if (field && !import_xe_utils27.default.has(record, field) && !record[field]) {
              let cellValue = null;
              if (editRender) {
                const { defaultValue } = editRender;
                if (import_xe_utils27.default.isFunction(defaultValue)) {
                  cellValue = defaultValue({ column });
                } else if (!import_xe_utils27.default.isUndefined(defaultValue)) {
                  cellValue = defaultValue;
                }
              }
              import_xe_utils27.default.set(record, field, cellValue);
            }
          });
          const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
          otherFields.forEach((key) => {
            if (key && eqEmptyValue(import_xe_utils27.default.get(record, key))) {
              import_xe_utils27.default.set(record, key, null);
            }
          });
          if (treeConfig && treeOpts.lazy && import_xe_utils27.default.isUndefined(record[childrenField])) {
            record[childrenField] = null;
          }
          if (eqEmptyValue(import_xe_utils27.default.get(record, rowkey))) {
            import_xe_utils27.default.set(record, rowkey, getRowUniqueId());
          }
          return record;
        });
      },
      handleTableData(force) {
        const { scrollYLoad } = reactData;
        const { scrollYStore, fullDataRowIdData } = internalData;
        let fullList = internalData.afterFullData;
        if (force) {
          updateAfterFullData();
          fullList = handleVirtualTreeToList();
        }
        const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        tableData.forEach((row, $index) => {
          const rowid = getRowid($xeTable, row);
          const rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
        });
        reactData.tableData = tableData;
        return nextTick();
      },
      /**
       *  Map
       * 
       */
      cacheRowMap(isSource) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        const { fullAllDataRowIdData, tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const rowkey = getRowkey($xeTable);
        const isLazy = treeConfig && treeOpts.lazy;
        const fullAllDataRowIdMaps = {};
        const fullDataRowIdMaps = {};
        const handleRow = (row, index2, items, path, parent, nodes) => {
          let rowid = getRowid($xeTable, row);
          const seq = treeConfig && path ? toTreePathSeq(path) : index2 + 1;
          const level = nodes ? nodes.length - 1 : 0;
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            import_xe_utils27.default.set(row, rowkey, rowid);
          }
          if (isLazy && row[hasChildField] && import_xe_utils27.default.isUndefined(row[childrenField])) {
            row[childrenField] = null;
          }
          let cacheItem = fullAllDataRowIdData[rowid];
          if (!cacheItem) {
            cacheItem = { row, rowid, seq, index: -1, _index: -1, $index: -1, items, parent, level, height: 0 };
          }
          cacheItem.row = row;
          cacheItem.items = items;
          cacheItem.parent = parent;
          cacheItem.level = level;
          cacheItem.index = treeConfig && parent ? -1 : index2;
          if (isSource) {
            fullDataRowIdMaps[rowid] = cacheItem;
          }
          fullAllDataRowIdMaps[rowid] = cacheItem;
        };
        if (isSource) {
          internalData.fullDataRowIdData = fullDataRowIdMaps;
        }
        internalData.fullAllDataRowIdData = fullAllDataRowIdMaps;
        if (treeConfig) {
          import_xe_utils27.default.eachTree(tableFullTreeData, handleRow, { children: childrenField });
        } else {
          tableFullData.forEach(handleRow);
        }
      },
      cacheSourceMap(fullData) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        let { sourceDataRowIdData } = internalData;
        const sourceData = import_xe_utils27.default.clone(fullData, true);
        const rowkey = getRowkey($xeTable);
        sourceDataRowIdData = internalData.sourceDataRowIdData = {};
        const handleSourceRow = (row) => {
          let rowid = getRowid($xeTable, row);
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            import_xe_utils27.default.set(row, rowkey, rowid);
          }
          sourceDataRowIdData[rowid] = row;
        };
        if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          import_xe_utils27.default.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        } else {
          sourceData.forEach(handleSourceRow);
        }
        internalData.tableSourceData = sourceData;
      },
      /**
       * 
       */
      analyColumnWidth() {
        const { tableFullColumn } = internalData;
        const columnOpts = computeColumnOpts.value;
        const { width: defaultWidth, minWidth: defaultMinWidth } = columnOpts;
        const resizeList = [];
        const pxList = [];
        const pxMinList = [];
        const autoMinList = [];
        const scaleList = [];
        const scaleMinList = [];
        const autoList = [];
        const remainList = [];
        tableFullColumn.forEach((column) => {
          if (defaultWidth && !column.width) {
            column.width = defaultWidth;
          }
          if (defaultMinWidth && !column.minWidth) {
            column.minWidth = defaultMinWidth;
          }
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (column.width === "auto") {
              autoList.push(column);
            } else if (isPx(column.width)) {
              pxList.push(column);
            } else if (isScale(column.width)) {
              scaleList.push(column);
            } else if (isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (column.minWidth === "auto") {
              autoMinList.push(column);
            } else if (isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              remainList.push(column);
            }
          }
        });
        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, autoMinList, scaleList, scaleMinList, autoList, remainList });
      },
      saveCustomStore(type) {
        const { customConfig } = props;
        const tableId = computeTableId.value;
        const customOpts = computeCustomOpts.value;
        const { updateStore, storage } = customOpts;
        const isAllCustom = storage === true;
        const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
        const isCustomResizable = isAllCustom || storageOpts.resizable;
        const isCustomVisible = isAllCustom || storageOpts.visible;
        const isCustomFixed = isAllCustom || storageOpts.fixed;
        const isCustomSort = isAllCustom || storageOpts.sort;
        if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
          if (!tableId) {
            errLog("vxe.error.reqProp", ["id"]);
            return nextTick();
          }
          const storeData2 = type === "reset" ? {
            resizableData: {},
            sortData: {},
            visibleData: {},
            fixedData: {}
          } : tableMethods.getCustomStoreData();
          if (updateStore) {
            return updateStore({
              id: tableId,
              type,
              storeData: storeData2
            });
          } else {
            setCustomStorageMap(tableId, type === "reset" ? null : storeData2);
          }
        }
        return nextTick();
      },
      handleCustom() {
        const { mouseConfig } = props;
        if (mouseConfig) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if ($xeTable.clearCellAreas) {
            $xeTable.clearCellAreas();
            $xeTable.clearCopyCellArea();
          }
        }
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn(true);
      },
      handleUpdateDataQueue() {
        reactData.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        reactData.reColumnFlag++;
      },
      preventEvent(evnt, type, args, next, end) {
        let evntList = interceptor3.get(type);
        if (!evntList.length && type === "event.clearEdit") {
          evntList = interceptor3.get("event.clearActived");
          if (true) {
            if (evntList.length) {
              warnLog("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]);
            }
          }
        }
        let rest;
        if (!evntList.some((func) => func(Object.assign({ $grid: $xeGrid, $table: $xeTable, $event: evnt }, args)) === false)) {
          if (next) {
            rest = next();
          }
        }
        if (end) {
          end();
        }
        return rest;
      },
      updateCheckboxStatus() {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
        const selectRowMaps = Object.assign({}, selectCheckboxMaps);
        const halfRowMaps = Object.assign({}, treeIndeterminateMaps);
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const { afterTreeFullData } = internalData;
        if (checkStrictly) {
          return;
        }
        if (treeConfig) {
          const childRowMaps = {};
          const childRowList = [];
          import_xe_utils27.default.eachTree(afterTreeFullData, (row) => {
            const rowid = getRowid($xeTable, row);
            const childList = row[transform2 ? mapChildrenField : childrenField];
            if (childList && childList.length && !childRowMaps[rowid]) {
              childRowMaps[rowid] = 1;
              childRowList.unshift([row, rowid, childList]);
            }
          }, { children: transform2 ? mapChildrenField : childrenField });
          childRowList.forEach((vals) => {
            const row = vals[0];
            const rowid = vals[1];
            const childList = vals[2];
            let sLen = 0;
            let hLen = 0;
            let vLen = 0;
            childList.forEach(checkMethod ? (item) => {
              const childRowid = getRowid($xeTable, item);
              const isSelect = checkField ? import_xe_utils27.default.get(item, checkField) : selectRowMaps[childRowid];
              if (checkMethod({ row: item })) {
                if (isSelect) {
                  sLen++;
                } else if (halfRowMaps[childRowid]) {
                  hLen++;
                }
                vLen++;
              } else {
                if (isSelect) {
                  sLen++;
                } else if (halfRowMaps[childRowid]) {
                  hLen++;
                }
              }
            } : (item) => {
              const childRowid = getRowid($xeTable, item);
              const isSelect = checkField ? import_xe_utils27.default.get(item, checkField) : selectRowMaps[childRowid];
              if (isSelect) {
                sLen++;
              } else if (halfRowMaps[childRowid]) {
                hLen++;
              }
              vLen++;
            });
            const isSelected = sLen >= vLen;
            const halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
            if (checkField) {
              import_xe_utils27.default.get(row, checkField, isSelected);
            }
            if (isSelected) {
              if (!checkField) {
                selectRowMaps[rowid] = row;
              }
              if (halfRowMaps[rowid]) {
                delete halfRowMaps[rowid];
              }
            } else {
              if (!checkField) {
                if (selectRowMaps[rowid]) {
                  delete selectRowMaps[rowid];
                }
              }
              if (halfSelect) {
                halfRowMaps[rowid] = row;
              } else {
                if (halfRowMaps[rowid]) {
                  delete halfRowMaps[rowid];
                }
              }
            }
          });
        }
        reactData.selectCheckboxMaps = selectRowMaps;
        reactData.treeIndeterminateMaps = halfRowMaps;
      },
      updateAllCheckboxStatus() {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkMethod } = checkboxOpts;
        const { afterFullData, afterTreeFullData } = internalData;
        let sLen = 0;
        let hLen = 0;
        let vLen = 0;
        const rootList = treeConfig ? afterTreeFullData : afterFullData;
        rootList.forEach(checkMethod ? (row) => {
          const childRowid = getRowid($xeTable, row);
          const selected = checkField ? import_xe_utils27.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (checkMethod({ row })) {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateMaps[childRowid]) {
              hLen++;
            }
            vLen++;
          } else {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateMaps[childRowid]) {
              hLen++;
            }
          }
        } : (row) => {
          const childRowid = getRowid($xeTable, row);
          const selected = checkField ? import_xe_utils27.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (selected) {
            sLen++;
          } else if (treeIndeterminateMaps[childRowid]) {
            hLen++;
          }
          vLen++;
        });
        const isSelected = sLen >= vLen;
        const halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
        reactData.isAllSelected = isSelected;
        reactData.isIndeterminate = halfSelect;
      },
      checkSelectionStatus() {
        $xeTable.updateCheckboxStatus();
        $xeTable.updateAllCheckboxStatus();
      },
      /**
       * 
       * 
       */
      handleBatchSelectRows(rows, checked, isForce) {
        const { treeConfig } = props;
        const { selectCheckboxMaps } = reactData;
        const selectRowMaps = Object.assign({}, selectCheckboxMaps);
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          if (treeConfig && !checkStrictly) {
            import_xe_utils27.default.eachTree(rows, (row) => {
              if (isForce || (!checkMethod || checkMethod({ row }))) {
                import_xe_utils27.default.set(row, checkField, checked);
                if (indeterminateField) {
                  import_xe_utils27.default.set(row, indeterminateField, false);
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: transform2 ? mapChildrenField : childrenField });
            reactData.selectCheckboxMaps = selectRowMaps;
            return;
          } else {
            rows.forEach((row) => {
              if (isForce || (!checkMethod || checkMethod({ row }))) {
                import_xe_utils27.default.set(row, checkField, checked);
                handleCheckboxReserveRow(row, checked);
              }
            });
          }
          reactData.selectCheckboxMaps = selectRowMaps;
          return;
        }
        if (treeConfig && !checkStrictly) {
          import_xe_utils27.default.eachTree(rows, (row) => {
            const rowid = getRowid($xeTable, row);
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              if (checked) {
                selectRowMaps[rowid] = row;
              } else {
                if (selectRowMaps[rowid]) {
                  delete selectRowMaps[rowid];
                }
              }
              handleCheckboxReserveRow(row, checked);
            }
          }, { children: transform2 ? mapChildrenField : childrenField });
          reactData.selectCheckboxMaps = selectRowMaps;
          return;
        }
        rows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (isForce || (!checkMethod || checkMethod({ row }))) {
            if (checked) {
              if (!selectRowMaps[rowid]) {
                selectRowMaps[rowid] = row;
              }
            } else {
              if (selectRowMaps[rowid]) {
                delete selectRowMaps[rowid];
              }
            }
            handleCheckboxReserveRow(row, checked);
          }
        });
        reactData.selectCheckboxMaps = selectRowMaps;
      },
      /**
       * 
       * @deprecated
       */
      handleSelectRow({ row }, checked, isForce) {
        $xeTable.handleBatchSelectRows([row], checked, isForce);
      },
      triggerHeaderTitleEvent(evnt, iconParams, params) {
        const tipContent = iconParams.content || iconParams.message;
        if (tipContent) {
          const { tooltipStore } = reactData;
          const { column } = params;
          const content = getFuncText(tipContent);
          handleTargetEnterEvent(true);
          tooltipStore.row = null;
          tooltipStore.column = column;
          tooltipStore.visible = true;
          tooltipStore.currOpts = iconParams;
          nextTick(() => {
            const $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.open) {
              $tooltip.open(evnt.currentTarget, content);
            }
          });
        }
      },
      /**
       *  tooltip 
       */
      triggerHeaderTooltipEvent(evnt, params) {
        const { tooltipStore } = reactData;
        const { column } = params;
        const titleElem = evnt.currentTarget;
        handleTargetEnterEvent(true);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, titleElem, titleElem, null, params);
        }
      },
      /**
       *  tooltip 
       */
      triggerBodyTooltipEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const { tooltipStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const { row, column } = params;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);
        if (column.editRender && isEnableConf(editConfig)) {
          if (editOpts.mode === "row" && actived.row === row) {
            return;
          }
          if (actived.row === row && actived.column === column) {
            return;
          }
        }
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          let overflowElem;
          let tipElem;
          if (column.treeNode) {
            overflowElem = cell.querySelector(".vxe-tree-cell");
            if (column.type === "html") {
              tipElem = cell.querySelector(".vxe-cell--html");
            }
          } else {
            tipElem = cell.querySelector(column.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label");
          }
          handleTooltip(evnt, cell, overflowElem || cell.children[0], tipElem, params);
        }
      },
      /**
       *  tooltip 
       */
      triggerFooterTooltipEvent(evnt, params) {
        const { column } = params;
        const { tooltipStore } = reactData;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, cell, cell.querySelector(".vxe-cell--item") || cell.children[0], null, params);
        }
      },
      handleTargetLeaveEvent() {
        const tooltipOpts = computeTooltipOpts.value;
        let $tooltip = refTooltip.value;
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(() => {
            $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.isActived && !$tooltip.isActived()) {
              tableMethods.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          tableMethods.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent(evnt, params) {
        const { _lastResizeTime } = internalData;
        const sortOpts = computeSortOpts.value;
        const columnOpts = computeColumnOpts.value;
        const { column } = params;
        const cell = evnt.currentTarget;
        const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        if (sortOpts.trigger === "cell" && !(triggerResizable || triggerSort || triggerFilter)) {
          tablePrivateMethods.triggerSortEvent(evnt, column, getNextSortOrder(column));
        }
        dispatchEvent2("header-cell-click", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);
        if (columnOpts.isCurrent || props.highlightCurrentColumn) {
          tablePrivateMethods.triggerCurrentColumnEvent(evnt, params);
        }
      },
      triggerHeaderCellDblclickEvent(evnt, params) {
        dispatchEvent2("header-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
      },
      /**
       * 
       * 
       * 
       */
      triggerCellClickEvent(evnt, params) {
        const { highlightCurrentRow, editConfig } = props;
        const { editStore } = reactData;
        const expandOpts = computeExpandOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const rowOpts = computeRowOpts.value;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const cell = evnt.currentTarget;
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);
        if (!triggerCheckbox && !triggerRadio) {
          if (!triggerExpandNode && (expandOpts.trigger === "row" || isExpandType && expandOpts.trigger === "cell")) {
            tablePrivateMethods.triggerRowExpandEvent(evnt, params);
          }
          if (treeOpts.trigger === "row" || treeNode && treeOpts.trigger === "cell") {
            tablePrivateMethods.triggerTreeExpandEvent(evnt, params);
          }
        }
        if (!triggerTreeNode) {
          if (!triggerExpandNode) {
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);
              }
            }
            if (!triggerRadio && (radioOpts.trigger === "row" || isRadioType && radioOpts.trigger === "cell")) {
              tablePrivateMethods.triggerRadioRowEvent(evnt, params);
            }
            if (!triggerCheckbox && (checkboxOpts.trigger === "row" || isCheckboxType && checkboxOpts.trigger === "cell")) {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);
            }
          }
          if (isEnableConf(editConfig)) {
            if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === "cell" && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
              focused.column = column;
              focused.row = row;
            }
            if (editOpts.trigger === "manual") {
              if (actived.args && actived.row === row && column !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row !== actived.row || column !== actived.column) {
              if (editOpts.trigger === "click") {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === "dblclick") {
                if (editOpts.mode === "row" && actived.row === row) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (actived.row && actived.column) {
            if (editOpts.mode === "row") {
              if (!$xeTable.eqRow(actived.row, row)) {
                $xeTable.handleClearEdit(evnt);
              }
            } else if (editOpts.mode === "cell") {
              if (!$xeTable.eqRow(actived.row, row) || actived.column.id !== column.id) {
                $xeTable.handleClearEdit(evnt);
              }
            }
          }
        }
        dispatchEvent2("cell-click", params, evnt);
      },
      /**
       * 
       * 
       */
      triggerCellDblclickEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const cell = evnt.currentTarget;
        params = Object.assign({ cell }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === "row") {
              checkValidate("blur").catch((e16) => e16).then(() => {
                $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e16) => e16);
              });
            } else if (editOpts.mode === "cell") {
              $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e16) => e16);
            }
          }
        }
        dispatchEvent2("cell-dblclick", params, evnt);
      },
      handleToggleCheckRowEvent(evnt, params) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, trigger } = checkboxOpts;
        const { row } = params;
        if (trigger === "manual") {
          return;
        }
        let checked = false;
        if (checkField) {
          checked = !import_xe_utils27.default.get(row, checkField);
        } else {
          checked = !selectCheckboxMaps[getRowid($xeTable, row)];
        }
        if (evnt) {
          tablePrivateMethods.triggerCheckRowEvent(evnt, params, checked);
        } else {
          tablePrivateMethods.handleBatchSelectRows([row], checked);
          tablePrivateMethods.checkSelectionStatus();
        }
      },
      triggerCheckRowEvent(evnt, params, checked) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { row } = params;
        const { afterFullData } = internalData;
        const { checkMethod, trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {
          const checkboxRecords = tableMethods.getCheckboxRecords();
          if (checkboxRecords.length) {
            const firstRow = checkboxRecords[0];
            const _rowIndex = tableMethods.getVTRowIndex(row);
            const _firstRowIndex = tableMethods.getVTRowIndex(firstRow);
            if (_rowIndex !== _firstRowIndex) {
              tableMethods.setAllCheckboxRow(false);
              const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
              handleCheckedCheckboxRow(rangeRows, true, false);
              dispatchEvent2("checkbox-range-select", Object.assign({ rangeRecords: rangeRows }, params), evnt);
              return;
            }
          }
        }
        if (!checkMethod || checkMethod({ row })) {
          tablePrivateMethods.handleBatchSelectRows([row], checked);
          tablePrivateMethods.checkSelectionStatus();
          dispatchEvent2("checkbox-change", Object.assign({
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked
          }, params), evnt);
        }
      },
      /**
       * 
       */
      triggerCheckAllEvent(evnt, value) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        if (evnt) {
          evnt.stopPropagation();
        }
        handleCheckAllEvent(evnt, value);
      },
      /**
       * 
       */
      triggerRadioRowEvent(evnt, params) {
        const { selectRadioRow: oldValue } = reactData;
        const { row } = params;
        const radioOpts = computeRadioOpts.value;
        const { trigger } = radioOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        let newValue = row;
        let isChange = oldValue !== newValue;
        if (isChange) {
          handleCheckedRadioRow(newValue);
        } else if (!radioOpts.strict) {
          isChange = oldValue === newValue;
          if (isChange) {
            newValue = null;
            tableMethods.clearRadioRow();
          }
        }
        if (isChange) {
          dispatchEvent2("radio-change", Object.assign({ oldValue, newValue }, params), evnt);
        }
      },
      triggerCurrentColumnEvent(evnt, params) {
        const columnOpts = computeColumnOpts.value;
        const { currentMethod } = columnOpts;
        const { column } = params;
        if (!currentMethod || currentMethod({ column })) {
          tableMethods.setCurrentColumn(column);
        }
      },
      triggerCurrentRowEvent(evnt, params) {
        const { currentRow: oldValue } = reactData;
        const rowOpts = computeRowOpts.value;
        const { currentMethod } = rowOpts;
        const { row: newValue } = params;
        const isChange = oldValue !== newValue;
        if (!currentMethod || currentMethod({ row: newValue })) {
          tableMethods.setCurrentRow(newValue);
          if (isChange) {
            dispatchEvent2("current-change", Object.assign({ oldValue, newValue }, params), evnt);
          }
        }
      },
      /**
       * 
       */
      triggerRowExpandEvent(evnt, params) {
        const { rowExpandLazyLoadedMaps, expandColumn: column } = reactData;
        const expandOpts = computeExpandOpts.value;
        const { row } = params;
        const { lazy, trigger } = expandOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isRowExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setRowExpand(row, expanded);
          dispatchEvent2("toggle-row-expand", {
            expanded,
            column,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: tableMethods.getRowIndex(row),
            $rowIndex: tableMethods.getVMRowIndex(row)
          }, evnt);
        }
      },
      /**
       * 
       */
      triggerTreeExpandEvent(evnt, params) {
        const { treeExpandLazyLoadedMaps } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { row, column } = params;
        const { lazy, trigger } = treeOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isTreeExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setTreeExpand(row, expanded);
          dispatchEvent2("toggle-tree-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
        }
      },
      handleColumnSortEvent(evnt, column) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const { field, sortable } = column;
        if (sortable) {
          const params = { $table: $xeTable, $event: evnt, column, field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };
          if (mouseConfig && mouseOpts.area && $xeTable.handleSortEvent) {
            $xeTable.handleSortEvent(evnt, params);
          }
          dispatchEvent2("sort-change", params, evnt);
        }
      },
      /**
       * 
       */
      triggerSortEvent(evnt, column, order) {
        const sortOpts = computeSortOpts.value;
        const { field, sortable } = column;
        if (sortable) {
          if (!order || column.order === order) {
            tableMethods.clearSort(sortOpts.multiple ? column : null);
          } else {
            tableMethods.sort({ field, order });
          }
          $xeTable.handleColumnSortEvent(evnt, column);
        }
      },
      /**
       * 
       */
      triggerHeaderCellMousedownEvent(evnt, params) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const columnOpts = computeColumnOpts.value;
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, disabledMethod } = columnDragOpts;
        const cell = evnt.currentTarget;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerCheckbox = getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        let triggerDrag = false;
        if (!(triggerInput || triggerCheckbox || triggerSort || triggerFilter)) {
          if (columnOpts.drag && trigger === "cell" && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && mouseConfig && mouseOpts.area && $xeTable.handleHeaderCellAreaEvent) {
          $xeTable.handleHeaderCellAreaEvent(evnt, Object.assign({ cell, triggerSort, triggerFilter }, params));
        }
        $xeTable.focus();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      /**
       * 
       */
      triggerCellMousedownEvent(evnt, params) {
        const { column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const rowOpts = computeRowOpts.value;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, disabledMethod } = rowDragOpts;
        const cell = evnt.currentTarget;
        params.cell = cell;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        let isColDragCell = false;
        if (rowOpts.drag) {
          isColDragCell = trigger === "row" || column.dragSort && trigger === "cell";
        }
        let triggerDrag = false;
        if (!(triggerInput || triggerRadio || triggerCheckbox || triggerTreeNode || triggerExpandNode)) {
          if (isColDragCell && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && $xeTable.handleCellMousedownEvent) {
          $xeTable.handleCellMousedownEvent(evnt, params);
        }
        $xeTable.focus();
        $xeTable.closeFilter();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      /**
       * 
       */
      handleRowDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          const img = new Image();
          img.src = tpImg;
          evnt.dataTransfer.setDragImage(img, 0, 0);
        }
      },
      handleRowDragDragendEvent(evnt) {
        const { treeConfig, dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { fullAllDataRowIdData, prevDragToChild } = internalData;
        const { isCrossDrag, isSelfToChildDrag, dragEndMethod } = rowDragOpts;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, rowField, mapChildrenField, parentField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { dragRow } = reactData;
        const { afterFullData, tableFullData, prevDragRow, prevDragPos } = internalData;
        const dEndMethod = dragEndMethod || (dragConfig ? dragConfig.dragEndMethod : null);
        const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
        if (prevDragRow && dragRow) {
          if (prevDragRow !== dragRow) {
            Promise.resolve(dEndMethod ? dEndMethod({
              oldRow: dragRow,
              newRow: prevDragRow,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex
            }) : true).then((status) => {
              if (!status) {
                return;
              }
              let oafIndex = -1;
              let nafIndex = -1;
              if (treeConfig) {
                if (transform2) {
                  const oldRowid = getRowid($xeTable, dragRow);
                  const oldRest = fullAllDataRowIdData[oldRowid];
                  const newRowid = getRowid($xeTable, prevDragRow);
                  const newRest = fullAllDataRowIdData[newRowid];
                  if (oldRest && newRest) {
                    const { level: oldLevel } = oldRest;
                    const { level: newLevel } = newRest;
                    const oldAllMaps = {};
                    import_xe_utils27.default.eachTree([dragRow], (item) => {
                      oldAllMaps[getRowid($xeTable, item)] = item;
                    }, { children: mapChildrenField });
                    let isSelfToChildStatus = false;
                    if (oldLevel && newLevel) {
                      if (!isCrossDrag) {
                        return;
                      }
                      if (oldAllMaps[newRowid]) {
                        isSelfToChildStatus = true;
                        if (!isSelfToChildDrag) {
                          if (VxeUI.modal) {
                            VxeUI.modal.message({
                              status: "error",
                              content: getI18n10("vxe.error.treeDragChild")
                            });
                          }
                          return;
                        }
                      }
                    } else if (oldLevel) {
                      if (!isCrossDrag) {
                        return;
                      }
                    } else if (newLevel) {
                      if (!isCrossDrag) {
                        return;
                      }
                      if (oldAllMaps[newRowid]) {
                        isSelfToChildStatus = true;
                        if (!isSelfToChildDrag) {
                          if (VxeUI.modal) {
                            VxeUI.modal.message({
                              status: "error",
                              content: getI18n10("vxe.error.treeDragChild")
                            });
                          }
                          return;
                        }
                      }
                    } else {
                    }
                    const fullList = import_xe_utils27.default.toTreeArray(internalData.afterTreeFullData, { children: childrenField });
                    const otfIndex = $xeTable.findRowIndexOf(fullList, dragRow);
                    fullList.splice(otfIndex, 1);
                    const ptfIndex = $xeTable.findRowIndexOf(fullList, prevDragRow);
                    const ntfIndex = ptfIndex + dragOffsetIndex;
                    fullList.splice(ntfIndex, 0, dragRow);
                    if (isSelfToChildStatus && isSelfToChildDrag) {
                      import_xe_utils27.default.each(dragRow[childrenField], (childRow) => {
                        childRow[parentField] = dragRow[parentField];
                      });
                    }
                    dragRow[parentField] = prevDragToChild ? prevDragRow[rowField] : prevDragRow[parentField];
                    internalData.tableFullTreeData = import_xe_utils27.default.toArrayTree(fullList, {
                      key: treeOpts.rowField,
                      parentKey: treeOpts.parentField,
                      children: childrenField,
                      mapChildren: treeOpts.mapChildrenField
                    });
                  }
                }
              } else {
                oafIndex = $xeTable.findRowIndexOf(afterFullData, dragRow);
                const otfIndex = $xeTable.findRowIndexOf(tableFullData, dragRow);
                afterFullData.splice(oafIndex, 1);
                tableFullData.splice(otfIndex, 1);
                const pafIndex = $xeTable.findRowIndexOf(afterFullData, prevDragRow);
                const ptfIndex = $xeTable.findRowIndexOf(tableFullData, prevDragRow);
                nafIndex = pafIndex + dragOffsetIndex;
                const ntfIndex = ptfIndex + dragOffsetIndex;
                afterFullData.splice(nafIndex, 0, dragRow);
                tableFullData.splice(ntfIndex, 0, dragRow);
              }
              reactData.isDragRowMove = true;
              $xeTable.handleTableData(treeConfig && transform2);
              $xeTable.cacheRowMap();
              updateScrollYStatus();
              if (!(treeConfig && transform2)) {
                $xeTable.updateAfterDataIndex();
              }
              $xeTable.checkSelectionStatus();
              if (reactData.scrollYLoad) {
                $xeTable.updateScrollYSpace();
              }
              nextTick().then(() => {
                $xeTable.updateCellAreas();
                $xeTable.recalculate();
              });
              dispatchEvent2("row-dragend", {
                oldRow: dragRow,
                newRow: prevDragRow,
                dragPos: prevDragPos,
                offsetIndex: dragOffsetIndex,
                _index: {
                  newIndex: nafIndex,
                  oldIndex: oafIndex
                }
              }, evnt);
            }).catch(() => {
            });
          }
        }
        hideDropTip();
        clearRowDropOrigin();
        internalData.prevDragToChild = false;
        reactData.dragRow = null;
        reactData.dragCol = null;
        setTimeout(() => {
          reactData.isDragRowMove = false;
        }, 500);
      },
      handleRowDragDragoverEvent(evnt) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        const { dragRow } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2 } = treeOpts;
        const rowDragOpts = computeRowDragOpts.value;
        const { isCrossDrag, isToChildDrag } = rowDragOpts;
        if (!dragRow) {
          evnt.preventDefault();
          return;
        }
        const hasCtrlKey = evnt.ctrlKey;
        const trEl = evnt.currentTarget;
        const rowid = trEl.getAttribute("rowid") || "";
        const rest = fullAllDataRowIdData[rowid];
        if (rest) {
          const row = rest.row;
          evnt.preventDefault();
          const { dragRow: dragRow2 } = reactData;
          const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
          const dragPos = offsetY < trEl.clientHeight / 2 ? "top" : "bottom";
          if ($xeTable.eqRow(dragRow2, row) || !isCrossDrag && treeConfig && rest.level) {
            showDropTip(evnt, trEl, null, false, dragPos);
            return;
          }
          internalData.prevDragToChild = !!(treeConfig && transform2 && isToChildDrag && hasCtrlKey);
          internalData.prevDragRow = row;
          internalData.prevDragPos = dragPos;
          showDropTip(evnt, trEl, null, true, dragPos);
          dispatchEvent2("row-dragover", {
            oldRow: dragRow2,
            targetRow: row,
            dragPos
          }, evnt);
        }
      },
      handleCellDragMousedownEvent(evnt, params) {
        var _a2;
        evnt.stopPropagation();
        const { dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, dragStartMethod } = rowDragOpts;
        const { row } = params;
        const dragEl2 = evnt.currentTarget;
        const tdEl = trigger === "cell" || trigger === "row" ? dragEl2 : (_a2 = dragEl2.parentElement) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
        const trEl = tdEl.parentElement;
        const dStartMethod = dragStartMethod || (dragConfig ? dragConfig.dragStartMethod : null);
        clearRowDropOrigin();
        if (dStartMethod && !dStartMethod(params)) {
          trEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          hideDropTip();
          return;
        }
        reactData.dragRow = row;
        reactData.dragCol = null;
        trEl.draggable = true;
        updateRowDropOrigin(row);
        updateRowDropTipContent(tdEl);
        dispatchEvent2("row-dragstart", params, evnt);
      },
      handleCellDragMouseupEvent() {
        clearRowDropOrigin();
        hideDropTip();
        reactData.dragRow = null;
        reactData.dragCol = null;
        reactData.isDragRowMove = false;
      },
      /**
       * 
       */
      handleHeaderCellDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          const img = new Image();
          img.src = tpImg;
          evnt.dataTransfer.setDragImage(img, 0, 0);
        }
      },
      handleColDragSwapEvent(evnt, isSyncColumn, dragCol, prevDragCol, prevDragPos, prevDragToChild) {
        const { mouseConfig } = props;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod } = columnDragOpts;
        const { collectColumn } = internalData;
        const dragOffsetIndex = prevDragPos === "right" ? 1 : 0;
        if (prevDragCol && dragCol) {
          if (prevDragCol !== dragCol) {
            const oldColumn = dragCol;
            const newColumn = prevDragCol;
            return Promise.resolve(dragEndMethod ? dragEndMethod({
              oldColumn,
              newColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex
            }) : true).then((status) => {
              if (!status) {
                return;
              }
              let oafIndex = -1;
              let nafIndex = -1;
              const oldAllMaps = {};
              import_xe_utils27.default.eachTree([oldColumn], (column) => {
                oldAllMaps[column.id] = column;
              });
              let isSelfToChildStatus = false;
              if (oldColumn.parentId && newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!isSelfToChildDrag) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n10("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else if (oldColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!isSelfToChildDrag) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n10("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils27.default.findTree(collectColumn, (item) => item.id === oldColumn.id);
              if (isSelfToChildStatus && isSelfToChildDrag) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = oldColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = oldColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  oldColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils27.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isToChildDrag && prevDragToChild) {
                  oldColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([oldColumn]);
                } else {
                  oldColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, oldColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index2 + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
              reactData.isDragColMove = true;
              if (mouseConfig) {
                if ($xeTable.clearSelected) {
                  $xeTable.clearSelected();
                }
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              dispatchEvent2("column-dragend", {
                oldColumn,
                newColumn,
                dragPos: prevDragPos,
                offsetIndex: dragOffsetIndex,
                _index: {
                  newIndex: nafIndex,
                  oldIndex: oafIndex
                }
              }, evnt);
              if (isSyncColumn) {
                return tableMethods.refreshColumn(true).then(() => {
                  $xeTable.updateCellAreas();
                  return $xeTable.saveCustomStore("update:sort");
                });
              }
            }).catch(() => {
            });
          }
        }
        return Promise.resolve();
      },
      handleHeaderCellDragDragendEvent(evnt) {
        const { dragCol } = reactData;
        const { prevDragCol, prevDragPos, prevDragToChild } = internalData;
        $xeTable.handleColDragSwapEvent(evnt, true, dragCol, prevDragCol, prevDragPos, prevDragToChild);
        hideDropTip();
        clearColDropOrigin();
        internalData.prevDragToChild = false;
        reactData.dragRow = null;
        reactData.dragCol = null;
        setTimeout(() => {
          reactData.isDragColMove = false;
        }, 500);
      },
      handleHeaderCellDragDragoverEvent(evnt) {
        const { dragCol } = reactData;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isToChildDrag, isCrossDrag } = columnDragOpts;
        if (!dragCol) {
          evnt.preventDefault();
          return;
        }
        const hasCtrlKey = evnt.ctrlKey;
        const thEl = evnt.currentTarget;
        const colid = thEl.getAttribute("colid");
        const column = $xeTable.getColumnById(colid);
        if (column) {
          evnt.preventDefault();
          const { dragCol: dragCol2 } = reactData;
          const offsetX = evnt.clientX - thEl.getBoundingClientRect().x;
          const dragPos = offsetX < thEl.clientWidth / 2 ? "left" : "right";
          if (dragCol2 && dragCol2.id === column.id || !isCrossDrag && column.parentId) {
            showDropTip(evnt, null, thEl, false, dragPos);
            return;
          }
          internalData.prevDragToChild = !!(isToChildDrag && hasCtrlKey);
          internalData.prevDragCol = column;
          internalData.prevDragPos = dragPos;
          showDropTip(evnt, null, thEl, true, dragPos);
          dispatchEvent2("column-dragover", {
            oldColumn: dragCol2,
            targetColumn: column,
            dragPos
          }, evnt);
        }
      },
      handleHeaderCellDragMousedownEvent(evnt, params) {
        var _a2;
        evnt.stopPropagation();
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, dragStartMethod } = columnDragOpts;
        const { column } = params;
        const dragEl2 = evnt.currentTarget;
        const thEl = trigger === "cell" ? dragEl2 : (_a2 = dragEl2.parentElement) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
        reactData.isDragColMove = false;
        clearColDropOrigin();
        if (dragStartMethod && !dragStartMethod(params)) {
          thEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          hideDropTip();
          return;
        }
        reactData.dragCol = column;
        reactData.dragRow = null;
        thEl.draggable = true;
        updateColDropOrigin(column);
        updateColDropTipContent(thEl);
        dispatchEvent2("column-dragstart", params, evnt);
      },
      handleHeaderCellDragMouseupEvent() {
        clearColDropOrigin();
        hideDropTip();
        reactData.dragRow = null;
        reactData.dragCol = null;
        reactData.isDragColMove = false;
      },
      handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, params) {
        const { highlightHoverRow } = props;
        const { lastScrollLeft, lastScrollTop } = internalData;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody ? tableBody.$el : null;
        const rowOpts = computeRowOpts.value;
        const validTip = refValidTooltip.value;
        const tooltip = refTooltip.value;
        const bodyHeight = bodyElem ? bodyElem.clientHeight : 0;
        const bodyWidth = bodyElem ? bodyElem.clientWidth : 0;
        const scrollHeight = bodyElem ? bodyElem.scrollHeight : 0;
        const scrollWidth = bodyElem ? bodyElem.scrollWidth : 0;
        let isTop = false;
        let isBottom = false;
        let isLeft = false;
        let isRight = false;
        let direction = "";
        let isTopBoundary = false;
        let isBottomBoundary = false;
        let isLeftBoundary = false;
        let isRightBoundary = false;
        if (isRollX) {
          const xThreshold = computeScrollXThreshold.value;
          isLeft = scrollLeft <= 0;
          if (!isLeft) {
            isRight = scrollLeft + bodyWidth >= scrollWidth;
          }
          if (scrollLeft > lastScrollLeft) {
            direction = "right";
            if (scrollLeft + bodyWidth >= scrollWidth - xThreshold) {
              isRightBoundary = true;
            }
          } else {
            direction = "left";
            if (scrollLeft <= xThreshold) {
              isLeftBoundary = true;
            }
          }
          tablePrivateMethods.checkScrolling();
          internalData.lastScrollLeft = scrollLeft;
        }
        if (isRollY) {
          const yThreshold = computeScrollYThreshold.value;
          isTop = scrollTop <= 0;
          if (!isTop) {
            isBottom = scrollTop + bodyHeight >= scrollHeight;
          }
          if (scrollTop > lastScrollTop) {
            direction = "bottom";
            if (scrollTop + bodyHeight >= scrollHeight - yThreshold) {
              isBottomBoundary = true;
            }
          } else {
            direction = "top";
            if (scrollTop <= yThreshold) {
              isTopBoundary = true;
            }
          }
          internalData.lastScrollTop = scrollTop;
        }
        reactData.isDragColMove = false;
        reactData.isDragRowMove = false;
        reactData.lastScrollTime = Date.now();
        const evntParams = Object.assign({
          scrollTop,
          scrollLeft,
          bodyHeight,
          bodyWidth,
          scrollHeight,
          scrollWidth,
          isX: isRollX,
          isY: isRollY,
          isTop,
          isBottom,
          isLeft,
          isRight,
          direction
        }, params);
        checkLastSyncScroll(isRollX, isRollY);
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (tooltip && tooltip.reactData.visible) {
          tooltip.close();
        }
        if (isBottomBoundary || isTopBoundary || isRightBoundary || isLeftBoundary) {
          dispatchEvent2("scroll-boundary", evntParams, evnt);
        }
        dispatchEvent2("scroll", evntParams, evnt);
      },
      /**
       *  X 
       */
      triggerScrollXEvent() {
        const sXOpts = computeSXOpts.value;
        if (sXOpts.immediate) {
          loadScrollXData();
        } else {
          lazyScrollXData();
        }
      },
      /**
       *  Y 
       */
      triggerScrollYEvent() {
        const sYOpts = computeSYOpts.value;
        if (sYOpts.immediate) {
          loadScrollYData();
        } else {
          lazyScrollYData();
        }
      },
      /**
       * 
       * 
       * @param {Row} row 
       */
      scrollToTreeRow(row) {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const rests = [];
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const matchObj = import_xe_utils27.default.findTree(tableFullData, (item) => $xeTable.eqRow(item, row), { children: childrenField });
          if (matchObj) {
            const nodes = matchObj.nodes;
            nodes.forEach((row2, index2) => {
              if (index2 < nodes.length - 1 && !tableMethods.isTreeExpandByRow(row2)) {
                rests.push(tableMethods.setTreeExpand(row2, true));
              }
            });
          }
        }
        return Promise.all(rests).then(() => rowToVisible($xeTable, row));
      },
      updateScrollYStatus,
      //  X 
      updateScrollXSpace() {
        const { isGroup, scrollXLoad, scrollbarWidth } = reactData;
        const { visibleColumn, scrollXStore, elemStore, tableWidth } = internalData;
        const tableHeader = refTableHeader.value;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          const tableFooterElem = tableFooter ? tableFooter.$el : null;
          const headerElem = tableHeaderElem ? tableHeaderElem.querySelector(".vxe-table--header") : null;
          const bodyElem = tableBodyElem.querySelector(".vxe-table--body");
          const footerElem = tableFooterElem ? tableFooterElem.querySelector(".vxe-table--footer") : null;
          const leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce((previous, column) => previous + column.renderWidth, 0);
          let marginLeft = "";
          if (scrollXLoad) {
            marginLeft = `${leftSpaceWidth}px`;
          }
          if (headerElem) {
            headerElem.style.marginLeft = isGroup ? "" : marginLeft;
          }
          bodyElem.style.marginLeft = marginLeft;
          if (footerElem) {
            footerElem.style.marginLeft = marginLeft;
          }
          const containerList = ["main"];
          containerList.forEach((name) => {
            const layoutList = ["header", "body", "footer"];
            layoutList.forEach((layout) => {
              const xSpaceElem = getRefElem(elemStore[`${name}-${layout}-xSpace`]);
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? `${tableWidth + (layout === "header" ? scrollbarWidth : 0)}px` : "";
              }
            });
          });
          const scrollXSpaceEl = refScrollXSpaceElem.value;
          if (scrollXSpaceEl) {
            scrollXSpaceEl.style.width = `${tableWidth + scrollbarWidth}px`;
          }
          nextTick(updateStyle);
        }
      },
      //  Y 
      updateScrollYSpace() {
        const { showOverflow } = props;
        const { scrollYLoad } = reactData;
        const { scrollYStore, elemStore, afterFullData, fullAllDataRowIdData } = internalData;
        const { startIndex, rowHeight } = scrollYStore;
        let bodyHeight = 0;
        let topSpaceHeight = 0;
        const containerList = ["main", "left", "right"];
        let marginTop = "";
        let ySpaceHeight = "";
        if (scrollYLoad) {
          if (showOverflow) {
            bodyHeight = afterFullData.length * rowHeight;
            topSpaceHeight = Math.max(0, startIndex * rowHeight);
          } else {
            for (let i = 0; i < afterFullData.length; i++) {
              const row = afterFullData[i];
              const rowid = getRowid($xeTable, row);
              const rowRest = fullAllDataRowIdData[rowid];
              if (rowRest) {
                bodyHeight += rowRest.height || rowHeight;
              }
            }
            for (let i = 0; i < startIndex; i++) {
              const row = afterFullData[i];
              const rowid = getRowid($xeTable, row);
              const rowRest = fullAllDataRowIdData[rowid];
              if (rowRest) {
                topSpaceHeight += rowRest.height || rowHeight;
              }
            }
          }
          marginTop = `${topSpaceHeight}px`;
          ySpaceHeight = `${bodyHeight}px`;
        }
        containerList.forEach((name) => {
          const layoutList = ["header", "body", "footer"];
          const tableElem = getRefElem(elemStore[`${name}-body-table`]);
          if (tableElem) {
            tableElem.style.marginTop = marginTop;
          }
          layoutList.forEach((layout) => {
            const ySpaceElem = getRefElem(elemStore[`${name}-${layout}-ySpace`]);
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight;
            }
          });
        });
        const scrollYSpaceEl = refScrollYSpaceElem.value;
        if (scrollYSpaceEl) {
          scrollYSpaceEl.style.height = ySpaceHeight;
        }
        nextTick(updateStyle);
      },
      updateScrollXData() {
        const { showOverflow } = props;
        return nextTick().then(() => {
          handleTableColumn();
          calcCellHeight();
          tablePrivateMethods.updateScrollXSpace();
          if (!showOverflow) {
            tablePrivateMethods.updateScrollYSpace();
          }
        });
      },
      updateScrollYData() {
        return nextTick().then(() => {
          tablePrivateMethods.handleTableData();
          calcCellHeight();
          tablePrivateMethods.updateScrollYSpace();
        });
      },
      /**
       * 
       */
      checkScrolling() {
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody ? tableBody.$el : null;
        const xHandleEl = refScrollXHandleElem.value;
        const bodtTargetEl = xHandleEl || bodyElem;
        if (bodtTargetEl) {
          if (leftContainerElem) {
            if (bodtTargetEl.scrollLeft > 0) {
              addClass(leftContainerElem, "scrolling--middle");
            } else {
              removeClass(leftContainerElem, "scrolling--middle");
            }
          }
          if (rightContainerElem) {
            if (bodtTargetEl.clientWidth < bodtTargetEl.scrollWidth - Math.ceil(bodtTargetEl.scrollLeft)) {
              addClass(rightContainerElem, "scrolling--middle");
            } else {
              removeClass(rightContainerElem, "scrolling--middle");
            }
          }
        }
      },
      updateZindex() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      handleCheckedCheckboxRow,
      /**
       *  hover 
       */
      triggerHoverEvent(evnt, { row }) {
        tablePrivateMethods.setHoverRow(row);
      },
      setHoverRow(row) {
        const rowid = getRowid($xeTable, row);
        const el2 = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el2) {
          import_xe_utils27.default.arrayEach(el2.querySelectorAll(`[rowid="${rowid}"]`), (elem) => addClass(elem, "row--hover"));
        }
        internalData.hoverRow = row;
      },
      clearHoverRow() {
        const el2 = refElem.value;
        if (el2) {
          import_xe_utils27.default.arrayEach(el2.querySelectorAll(".vxe-body--row.row--hover"), (elem) => removeClass(elem, "row--hover"));
        }
        internalData.hoverRow = null;
      },
      /**
       *  getCellElement 
       * @deprecated
       */
      getCell(row, column) {
        return tableMethods.getCellElement(row, column);
      },
      findRowIndexOf(list, row) {
        return row ? import_xe_utils27.default.findIndexOf(list, (item) => $xeTable.eqRow(item, row)) : -1;
      },
      eqRow(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xeTable, row1) === getRowid($xeTable, row2);
        }
        return false;
      }
    };
    if (true) {
      "openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print".split(",").forEach((name) => {
        $xeTable[name] = function() {
          errLog("vxe.error.reqModule", ["VxeTableExportModule"]);
        };
      });
      "clearValidate,fullValidate,validate".split(",").forEach((name) => {
        $xeTable[name] = function() {
          errLog("vxe.error.reqModule", ["VxeTableValidatorModule"]);
        };
      });
    }
    Object.assign($xeTable, tableMethods, tablePrivateMethods);
    const renderFixed = (fixedType) => {
      const { showHeader, showFooter } = props;
      const { tableData, tableColumn, tableGroupColumn, columnStore, footerTableData } = reactData;
      const isFixedLeft = fixedType === "left";
      const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      return h("div", {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: `vxe-table--fixed-${fixedType}-wrapper`
      }, [
        showHeader ? h(header_default, {
          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
          fixedType,
          tableData,
          tableColumn,
          tableGroupColumn,
          fixedColumn
        }) : renderEmptyElement5($xeTable),
        h(body_default, {
          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
          fixedType,
          tableData,
          tableColumn,
          fixedColumn
        }),
        showFooter ? h(footer_default, {
          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
          footerTableData,
          tableColumn,
          fixedColumn,
          fixedType
        }) : renderEmptyElement5($xeTable)
      ]);
    };
    const renderEmptyBody = () => {
      const emptyOpts = computeEmptyOpts.value;
      const params = { $table: $xeTable };
      if (slots.empty) {
        return slots.empty(params);
      } else {
        const compConf = emptyOpts.name ? renderer8.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          return getSlotVNs(rtEmptyView(emptyOpts, params));
        }
      }
      return getFuncText(props.emptyText) || getI18n10("vxe.table.emptyText");
    };
    const renderDragTipContents = () => {
      const { dragConfig } = props;
      const { dragRow, dragCol, dragTipText } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const rowDragSlots = rowDragOpts.slots || {};
      const rTipSlot = rowDragSlots.tip || (dragConfig && dragConfig.slots ? dragConfig.slots.rowTip : null);
      const columnDragSlots = columnDragOpts.slots || {};
      const cTipSlot = columnDragSlots.tip;
      if (dragRow && rTipSlot) {
        return callSlot(rTipSlot, { row: dragRow });
      }
      if (dragCol && cTipSlot) {
        return callSlot(cTipSlot, { column: dragCol });
      }
      return [h("span", dragTipText)];
    };
    const renderDragTip = () => {
      const { dragRow } = reactData;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      if (rowOpts.drag || columnOpts.drag) {
        return h("div", {
          class: "vxe-table--drag-wrapper"
        }, [
          h("div", {
            ref: refDragRowLineElem,
            class: ["vxe-table--drag-row-line", {
              "is--guides": rowDragOpts.showGuidesStatus
            }]
          }),
          h("div", {
            ref: refDragColLineElem,
            class: ["vxe-table--drag-col-line", {
              "is--guides": columnDragOpts.showGuidesStatus
            }]
          }),
          h("div", {
            ref: refDragTipElem,
            class: "vxe-table--drag-sort-tip"
          }, [
            h("div", {
              class: "vxe-table--drag-sort-tip-wrapper"
            }, [
              h("div", {
                class: "vxe-table--drag-sort-tip-status"
              }, [
                h("span", {
                  class: ["vxe-table--drag-sort-tip-normal-status", dragRow ? getIcon9().TABLE_DRAG_STATUS_ROW : getIcon9().TABLE_DRAG_STATUS_COLUMN]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-sub-status", getIcon9().TABLE_DRAG_STATUS_SUB_ROW]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-disabled-status", getIcon9().TABLE_DRAG_DISABLED]
                })
              ]),
              h("div", {
                class: "vxe-table--drag-sort-tip-content"
              }, renderDragTipContents())
            ])
          ])
        ]);
      }
      return renderEmptyElement5($xeTable);
    };
    function handleUupdateResize() {
      const el2 = refElem.value;
      if (el2 && el2.clientWidth && el2.clientHeight) {
        tableMethods.recalculate();
      }
    }
    const renderVN = () => {
      const { loading: loading2, stripe, showHeader, height, treeConfig, mouseConfig, showFooter, highlightCell, highlightHoverRow, highlightHoverColumn, editConfig, editRules } = props;
      const { isCalcColumn, isGroup, overflowX, overflowY, scrollXLoad, scrollYLoad, scrollbarHeight, tableData, tableColumn, tableGroupColumn, footerTableData, initStore, columnStore, filterStore, customStore, tooltipStore } = reactData;
      const { leftList, rightList } = columnStore;
      const loadingSlot = slots.loading;
      const tipConfig = computeTipConfig.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const vSize = computeSize.value;
      const tableBorder = computeTableBorder.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const validTipOpts = computeValidTipOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isMenu = computeIsMenu.value;
      const currLoading = reactData._isLoading || loading2;
      const virtualScrollBars = computeVirtualScrollBars.value;
      const resizableOpts = computeResizableOpts.value;
      const isArea = mouseConfig && mouseOpts.area;
      const tableStyle = computeTableStyle.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-table", "vxe-table--render-default", `tid_${xID}`, `border--${tableBorder}`, {
          [`size--${vSize}`]: vSize,
          [`valid-msg--${validOpts.msgMode}`]: !!editRules,
          "vxe-editable": !!editConfig,
          "old-cell-valid": editRules && getConfig4().cellVaildMode === "obsolete",
          "cell--highlight": highlightCell,
          "cell--selected": mouseConfig && mouseOpts.selected,
          "cell--area": isArea,
          "header-cell--area": isArea && areaOpts.selectCellByHeader,
          "body-cell--area": isArea && areaOpts.selectCellByBody,
          "row--highlight": rowOpts.isHover || highlightHoverRow,
          "column--highlight": columnOpts.isHover || highlightHoverColumn,
          "checkbox--range": checkboxOpts.range,
          "column--calc": isCalcColumn,
          "col--drag-cell": columnOpts.drag && columnDragOpts.trigger === "cell",
          "is--header": showHeader,
          "is--footer": showFooter,
          "is--group": isGroup,
          "is--tree-line": treeConfig && (treeOpts.showLine || treeOpts.line),
          "is--fixed-left": leftList.length,
          "is--fixed-right": rightList.length,
          "is--animat": !!props.animat,
          "is--padding": props.padding,
          "is--round": props.round,
          "is--stripe": !treeConfig && stripe,
          "is--loading": currLoading,
          "is--empty": !currLoading && !tableData.length,
          "is--scroll-y": overflowY,
          "is--scroll-x": overflowX,
          "is--virtual-x": scrollXLoad,
          "is--virtual-y": scrollYLoad
        }],
        style: tableStyle,
        spellcheck: false,
        onKeydown: keydownEvent
      }, [
        /**
         * 
         */
        h("div", {
          class: "vxe-table-slots"
        }, slots.default ? slots.default({}) : []),
        h("div", {
          key: "tw",
          class: "vxe-table--render-wrapper"
        }, [
          h("div", {
            class: "vxe-table--main-wrapper"
          }, [
            /**
             * 
             */
            showHeader ? h(header_default, {
              ref: refTableHeader,
              tableData,
              tableColumn,
              tableGroupColumn
            }) : renderEmptyElement5($xeTable),
            /**
             * 
             */
            h(body_default, {
              ref: refTableBody,
              tableData,
              tableColumn
            }),
            /**
             * 
             */
            showFooter ? h(footer_default, {
              ref: refTableFooter,
              footerTableData,
              tableColumn
            }) : renderEmptyElement5($xeTable)
          ]),
          h("div", {
            class: "vxe-table--fixed-wrapper"
          }, [
            leftList && leftList.length && overflowX ? renderFixed("left") : renderEmptyElement5($xeTable),
            rightList && rightList.length && overflowX ? renderFixed("right") : renderEmptyElement5($xeTable)
          ])
        ]),
        virtualScrollBars.x ? h("div", {
          key: "vx",
          ref: refScrollXVirtualElem,
          class: "vxe-table--scroll-x-virtual"
        }, [
          h("div", {
            ref: refScrollXHandleElem,
            class: "vxe-table--scroll-x-handle",
            onScroll: scrollXEvent
          }, [
            h("div", {
              ref: refScrollXSpaceElem,
              class: "vxe-table--scroll-x-space"
            })
          ])
        ]) : renderEmptyElement5($xeTable),
        virtualScrollBars.y ? h("div", {
          key: "vy",
          ref: refScrollYVirtualElem,
          class: "vxe-table--scroll-y-virtual"
        }, [
          h("div", {
            ref: refScrollYHandleElem,
            class: "vxe-table--scroll-y-handle",
            onScroll: scrollYEvent
          }, [
            h("div", {
              ref: refScrollYSpaceElem,
              class: "vxe-table--scroll-y-space"
            })
          ])
        ]) : renderEmptyElement5($xeTable),
        /**
         * 
         */
        h("div", {
          key: "tn",
          ref: refEmptyPlaceholder,
          class: "vxe-table--empty-placeholder"
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, renderEmptyBody())
        ]),
        /**
         * 
         */
        h("div", {
          key: "tl",
          class: "vxe-table--border-line"
        }),
        /**
         * 
         */
        h("div", {
          key: "cl",
          ref: refCellResizeBar,
          class: "vxe-table--resizable-bar",
          style: overflowX ? {
            "padding-bottom": `${scrollbarHeight}px`
          } : null
        }, resizableOpts.showDragTip ? [
          h("div", {
            ref: refCellResizeTip,
            class: "vxe-table--resizable-number-tip"
          }, "23432px")
        ] : []),
        /**
         * 
         */
        VxeUILoadingComponent ? h(VxeUILoadingComponent, {
          key: "lg",
          class: "vxe-table--loading",
          modelValue: currLoading,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, loading: currLoading })
        } : {}) : loadingSlot ? h("div", {
          class: ["vxe-loading--custom-wrapper", {
            "is--visible": currLoading
          }]
        }, callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, loading: currLoading })) : renderEmptyElement5($xeTable),
        /**
         * 
         */
        initStore.custom ? h(panel_default, {
          key: "cs",
          ref: refTableCustom,
          customStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 
         */
        initStore.filter ? h(panel_default2, {
          key: "tf",
          ref: refTableFilter,
          filterStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 
         */
        initStore.import && props.importConfig ? h(import_panel_default, {
          key: "it",
          defaultOptions: reactData.importParams,
          storeData: reactData.importStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 
         */
        initStore.export && (props.exportConfig || props.printConfig) ? h(export_panel_default, {
          key: "et",
          defaultOptions: reactData.exportParams,
          storeData: reactData.exportStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 
         */
        isMenu ? h(panel_default3, {
          key: "tm",
          ref: refTableMenu
        }) : renderEmptyElement5($xeTable),
        /**
         * 
         */
        renderDragTip(),
        /**
         * 
         */
        VxeUITooltipComponent ? h("div", {}, [
          /**
           * 
           */
          h(VxeUITooltipComponent, {
            key: "ctp",
            ref: refCommTooltip,
            isArrow: false,
            enterable: false
          }),
          /**
            * 
            */
          h(VxeUITooltipComponent, Object.assign({
            key: "btp",
            ref: refTooltip
          }, tipConfig, tooltipStore.currOpts)),
          /**
            * 
            */
          props.editRules && validOpts.showMessage && (validOpts.message === "default" ? !height : validOpts.message === "tooltip") ? h(VxeUITooltipComponent, Object.assign({ key: "vtp", ref: refValidTooltip, class: [{
            "old-cell-valid": editRules && getConfig4().cellVaildMode === "obsolete"
          }, "vxe-table--valid-error"] }, validOpts.message === "tooltip" || tableData.length === 1 ? validTipOpts : {})) : renderEmptyElement5($xeTable)
        ]) : renderEmptyElement5($xeTable)
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      const { initStatus } = internalData;
      loadTableData(props.data || []).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if (true) {
          if ((scrollXLoad || scrollYLoad) && expandColumn) {
            warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
          }
        }
        tableMethods.recalculate();
      });
    });
    const staticColumnFlag = ref(0);
    watch(() => reactData.staticColumns.length, () => {
      staticColumnFlag.value++;
    });
    watch(() => reactData.staticColumns, () => {
      staticColumnFlag.value++;
    });
    watch(staticColumnFlag, () => {
      handleColumn(import_xe_utils27.default.clone(reactData.staticColumns));
    });
    const tableColumnFlag = ref(0);
    watch(() => reactData.tableColumn.length, () => {
      tableColumnFlag.value++;
    });
    watch(() => reactData.tableColumn, () => {
      tableColumnFlag.value++;
    });
    watch(tableColumnFlag, () => {
      tablePrivateMethods.analyColumnWidth();
    });
    watch(() => reactData.upDataFlag, () => {
      nextTick(() => {
        tableMethods.updateData();
      });
    });
    watch(() => reactData.reColumnFlag, () => {
      nextTick(() => {
        tableMethods.refreshColumn();
      });
    });
    watch(() => props.showHeader, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    watch(() => props.showFooter, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    const footFlag = ref(0);
    watch(() => props.footerData ? props.footerData.length : -1, () => {
      footFlag.value++;
    });
    watch(() => props.footerData, () => {
      footFlag.value++;
    });
    watch(footFlag, () => {
      tableMethods.updateFooter();
    });
    watch(() => props.height, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    watch(() => props.maxHeight, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        handleUupdateResize();
        nextTick(() => {
          handleUupdateResize();
          setTimeout(() => handleUupdateResize());
        });
      }
    });
    const mergeCellFlag = ref(0);
    watch(() => props.mergeCells ? props.mergeCells.length : -1, () => {
      mergeCellFlag.value++;
    });
    watch(() => props.mergeCells, () => {
      mergeCellFlag.value++;
    });
    watch(mergeCellFlag, () => {
      tableMethods.clearMergeCells();
      nextTick(() => {
        if (props.mergeCells) {
          tableMethods.setMergeCells(props.mergeCells);
        }
      });
    });
    const mergeFooterItemFlag = ref(0);
    watch(() => props.mergeFooterItems ? props.mergeFooterItems.length : -1, () => {
      mergeFooterItemFlag.value++;
    });
    watch(() => props.mergeFooterItems, () => {
      mergeFooterItemFlag.value++;
    });
    watch(mergeFooterItemFlag, () => {
      tableMethods.clearMergeFooterItems();
      nextTick(() => {
        if (props.mergeFooterItems) {
          tableMethods.setMergeFooterItems(props.mergeFooterItems);
        }
      });
    });
    if ($xeTabs) {
      watch(() => $xeTabs ? $xeTabs.reactData.resizeFlag : null, () => {
        handleGlobalResizeEvent();
      });
    }
    hooks3.forEach((options) => {
      const { setupTable } = options;
      if (setupTable) {
        const hookRest = setupTable($xeTable);
        if (hookRest && import_xe_utils27.default.isObject(hookRest)) {
          Object.assign($xeTable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, "created", { $table: $xeTable });
    let resizeObserver;
    onActivated(() => {
      tableMethods.recalculate().then(() => tableMethods.refreshScroll());
      tablePrivateMethods.preventEvent(null, "activated", { $table: $xeTable });
    });
    onDeactivated(() => {
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, "deactivated", { $table: $xeTable });
    });
    onMounted(() => {
      nextTick(() => {
        const { data, treeConfig, showOverflow } = props;
        const { scrollXStore, scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts = computeRowOpts.value;
        if (true) {
          if (props.rowId) {
            warnLog("vxe.error.delProp", ["row-id", "row-config.keyField"]);
          }
          if (props.rowKey) {
            warnLog("vxe.error.delProp", ["row-key", "row-config.useKey"]);
          }
          if (props.columnKey) {
            warnLog("vxe.error.delProp", ["column-id", "column-config.useKey"]);
          }
          if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
            warnLog("vxe.error.reqProp", ["row-config.keyField"]);
          }
          if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
          if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts.useKey) || !showOverflow)) {
            warnLog("vxe.error.reqProp", ["row-config.useKey | show-overflow"]);
          }
          if (treeConfig && !treeOpts.transform && props.stripe) {
            warnLog("vxe.error.noTree", ["stripe"]);
          }
          if (props.showFooter && !(props.footerMethod || props.footerData)) {
            warnLog("vxe.error.reqProp", ["footer-data | footer-method"]);
          }
          const { exportConfig, importConfig } = props;
          const exportOpts = computeExportOpts.value;
          const importOpts = computeImportOpts.value;
          if (importConfig && importOpts.types && !importOpts.importMethod && !import_xe_utils27.default.includeArrays(import_xe_utils27.default.keys(importOpts._typeMaps), importOpts.types)) {
            warnLog("vxe.error.errProp", [`export-config.types=${importOpts.types.join(",")}`, importOpts.types.filter((type) => import_xe_utils27.default.includes(import_xe_utils27.default.keys(importOpts._typeMaps), type)).join(",") || import_xe_utils27.default.keys(importOpts._typeMaps).join(",")]);
          }
          if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !import_xe_utils27.default.includeArrays(import_xe_utils27.default.keys(exportOpts._typeMaps), exportOpts.types)) {
            warnLog("vxe.error.errProp", [`export-config.types=${exportOpts.types.join(",")}`, exportOpts.types.filter((type) => import_xe_utils27.default.includes(import_xe_utils27.default.keys(exportOpts._typeMaps), type)).join(",") || import_xe_utils27.default.keys(exportOpts._typeMaps).join(",")]);
          }
        }
        if (true) {
          const customOpts = computeCustomOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const rowOpts2 = computeRowOpts.value;
          if (!props.id) {
            if ((props.customConfig ? isEnableConf(customOpts) : customOpts.enabled) && customOpts.storage) {
              errLog("vxe.error.reqProp", ["id"]);
            }
          }
          if (props.treeConfig && checkboxOpts.range) {
            errLog("vxe.error.noTree", ["checkbox-config.range"]);
          }
          if (rowOpts2.height && !props.showOverflow) {
            warnLog("vxe.error.notProp", ["table.show-overflow"]);
          }
          if (!$xeTable.handleMousedownCellAreaEvent) {
            if (props.areaConfig) {
              warnLog("vxe.error.notProp", ["area-config"]);
            }
            if (props.clipConfig) {
              warnLog("vxe.error.notProp", ["clip-config"]);
            }
            if (props.fnrConfig) {
              warnLog("vxe.error.notProp", ["fnr-config"]);
            }
            if (mouseOpts.area) {
              errLog("vxe.error.notProp", ["mouse-config.area"]);
              return;
            }
          }
          if (props.dragConfig) {
            warnLog("vxe.error.delProp", ["drag-config", "row-drag-config"]);
          }
          if (props.treeConfig && treeOpts.children) {
            warnLog("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]);
          }
          if (props.treeConfig && treeOpts.line) {
            warnLog("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]);
          }
          if (mouseOpts.area && mouseOpts.selected) {
            warnLog("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]);
          }
          if (mouseOpts.area && (props.treeConfig && !treeOpts.transform)) {
            errLog("vxe.error.noTree", ["mouse-config.area"]);
          }
          if (props.editConfig && editOpts.activeMethod) {
            warnLog("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]);
          }
          if (props.treeConfig && checkboxOpts.isShiftKey) {
            errLog("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]);
          }
          if (checkboxOpts.halfField) {
            warnLog("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
          }
        }
        if (true) {
          if (props.editConfig && !$xeTable.insert) {
            errLog("vxe.error.reqModule", ["Edit"]);
          }
          if (props.editRules && !$xeTable.validate) {
            errLog("vxe.error.reqModule", ["Validator"]);
          }
          if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xeTable.handleCellMousedownEvent) {
            errLog("vxe.error.reqModule", ["Keyboard"]);
          }
          if ((props.printConfig || props.importConfig || props.exportConfig) && !$xeTable.exportData) {
            errLog("vxe.error.reqModule", ["Export"]);
          }
        }
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0,
          adaptive: sYOpts.adaptive !== false
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        loadTableData(data || []).then(() => {
          if (data && data.length) {
            internalData.inited = true;
            internalData.initStatus = true;
            handleLoadDefaults();
          }
          handleInitDefaults();
          updateStyle();
        });
        if (props.autoResize) {
          const resizeOpts = computeResizeOpts.value;
          const { refreshDelay } = resizeOpts;
          const el2 = refElem.value;
          const parentEl2 = tablePrivateMethods.getParentElem();
          const handleOptimizeResize = refreshDelay ? import_xe_utils27.default.throttle(() => tableMethods.recalculate(true), refreshDelay, { leading: true, trailing: true }) : null;
          resizeObserver = globalResize3.create(handleOptimizeResize ? () => {
            if (props.autoResize) {
              handleOptimizeResize();
            }
          } : () => {
            if (props.autoResize) {
              tableMethods.recalculate(true);
            }
          });
          if (el2) {
            resizeObserver.observe(el2);
          }
          if (parentEl2) {
            resizeObserver.observe(parentEl2);
          }
        }
      });
      globalEvents3.on($xeTable, "paste", handleGlobalPasteEvent);
      globalEvents3.on($xeTable, "copy", handleGlobalCopyEvent);
      globalEvents3.on($xeTable, "cut", handleGlobalCutEvent);
      globalEvents3.on($xeTable, "mousedown", handleGlobalMousedownEvent);
      globalEvents3.on($xeTable, "blur", handleGlobalBlurEvent);
      globalEvents3.on($xeTable, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents3.on($xeTable, "keydown", handleGlobalKeydownEvent);
      globalEvents3.on($xeTable, "resize", handleGlobalResizeEvent);
      globalEvents3.on($xeTable, "contextmenu", $xeTable.handleGlobalContextmenuEvent);
      tablePrivateMethods.preventEvent(null, "mounted", { $table: $xeTable });
    });
    onBeforeUnmount(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      tablePrivateMethods.preventEvent(null, "beforeUnmount", { $table: $xeTable });
    });
    onUnmounted(() => {
      globalEvents3.off($xeTable, "paste");
      globalEvents3.off($xeTable, "copy");
      globalEvents3.off($xeTable, "cut");
      globalEvents3.off($xeTable, "mousedown");
      globalEvents3.off($xeTable, "blur");
      globalEvents3.off($xeTable, "mousewheel");
      globalEvents3.off($xeTable, "keydown");
      globalEvents3.off($xeTable, "resize");
      globalEvents3.off($xeTable, "contextmenu");
      tablePrivateMethods.preventEvent(null, "unmounted", { $table: $xeTable });
    });
    if (true) {
      nextTick(() => {
        if (props.loading) {
          if (!VxeUILoadingComponent && !slots.loading) {
            errLog("vxe.error.reqComp", ["vxe-loading"]);
          }
        }
        if (props.showOverflow === true || props.showOverflow === "tooltip" || (props.showHeaderOverflow === true || props.showHeaderOverflow === "tooltip") || (props.showFooterOverflow === true || props.showFooterOverflow === "tooltip") || props.tooltipConfig || props.editRules) {
          if (!VxeUITooltipComponent) {
            errLog("vxe.error.reqComp", ["vxe-tooltip"]);
          }
        }
      });
    }
    provide("$xeColgroup", null);
    provide("$xeTable", $xeTable);
    $xeTable.renderVN = renderVN;
    return $xeTable;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/table/src/use/cell-view.js
var import_xe_utils28 = __toESM(require_xe_utils());
function useCellView(props) {
  const currColumn = computed(() => {
    const { renderParams } = props;
    return renderParams.column;
  });
  const currRow = computed(() => {
    const { renderParams } = props;
    return renderParams.row;
  });
  const cellOptions = computed(() => {
    const { renderOpts } = props;
    return renderOpts.props || {};
  });
  const cellModel = computed({
    get() {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils28.default.get(row, column.field);
    },
    set(value) {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils28.default.set(row, column.field, value);
    }
  });
  return {
    currColumn,
    currRow,
    cellModel,
    cellOptions
  };
}

// node_modules/vxe-table/es/table/module/filter/hook.js
var import_xe_utils29 = __toESM(require_xe_utils());
var { renderer: renderer9, hooks: hooks4 } = VxeUI;
var tableFilterMethodKeys = ["openFilter", "setFilter", "clearFilter", "saveFilterPanel", "resetFilterPanel", "getCheckedFilters", "updateFilterOptionStatus"];
hooks4.add("tableFilterModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refTableHeader, refTableBody, refTableFilter } = $xeTable.getRefMaps();
    const { computeFilterOpts, computeMouseOpts } = $xeTable.getComputeMaps();
    const handleFilterConfirmFilter = (evnt) => {
      const { filterStore } = reactData;
      filterStore.options.forEach((option2) => {
        option2.checked = option2._checked;
      });
      $xeTable.confirmFilterEvent(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      const { filterStore } = reactData;
      filterStore.options.forEach((option2) => {
        option2._checked = false;
      });
      item._checked = checked;
      $xeTable.checkFilterOptions();
      handleFilterConfirmFilter(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      item._checked = checked;
      $xeTable.checkFilterOptions();
    };
    const handleFilterResetFilter = (evnt) => {
      const { filterStore } = reactData;
      $xeTable.handleClearFilter(filterStore.column);
      $xeTable.confirmFilterEvent(evnt);
    };
    const filterPrivateMethods = {
      checkFilterOptions() {
        const { filterStore } = reactData;
        filterStore.isAllSelected = filterStore.options.every((item) => item._checked);
        filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some((item) => item._checked);
      },
      /**
       * 
       * 
       * 
       * 
       * @param {Event} evnt 
       * @param {ColumnInfo} column 
       * @param {Object} params 
       */
      triggerFilterEvent(evnt, column, params) {
        const { initStore, filterStore } = reactData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const { target: targetElem, pageX } = evnt;
          const { visibleWidth } = getDomNode();
          const { filters, filterMultiple, filterRender } = column;
          const compConf = isEnableConf(filterRender) ? renderer9.get(filterRender.name) : null;
          const frMethod = column.filterRecoverMethod || (compConf ? compConf.tableFilterRecoverMethod || compConf.filterRecoverMethod : null);
          internalData._currFilterParams = params;
          Object.assign(filterStore, {
            multiple: filterMultiple,
            options: filters,
            column,
            style: null
          });
          filterStore.options.forEach((option2) => {
            const { _checked, checked } = option2;
            option2._checked = checked;
            if (!checked && _checked !== checked) {
              if (frMethod) {
                frMethod({ option: option2, column, $table: $xeTable });
              }
            }
          });
          this.checkFilterOptions();
          filterStore.visible = true;
          initStore.filter = true;
          nextTick(() => {
            const tableHeader = refTableHeader.value;
            const tableBody = refTableBody.value;
            const headerElem = tableHeader ? tableHeader.$el : null;
            const bodyElem = tableBody.$el;
            if (!bodyElem) {
              return;
            }
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.$el : null;
            if (!filterWrapperElem) {
              return;
            }
            const filterWidth = filterWrapperElem.offsetWidth;
            const filterHeight = filterWrapperElem.offsetHeight;
            const filterHeadElem = filterWrapperElem.querySelector(".vxe-table--filter-header");
            const filterFootElem = filterWrapperElem.querySelector(".vxe-table--filter-footer");
            const centerWidth = filterWidth / 2;
            const minMargin = 10;
            const maxLeft = bodyElem.clientWidth - filterWidth - minMargin;
            let left, right;
            const style = {
              top: `${targetElem.offsetTop + targetElem.offsetParent.offsetTop + targetElem.offsetHeight}px`
            };
            let maxHeight = null;
            const bodyHeight = bodyElem.clientHeight - (headerElem ? headerElem.clientHeight / 2 : 0);
            if (filterHeight >= bodyHeight) {
              maxHeight = Math.max(40, bodyHeight - (filterFootElem ? filterFootElem.offsetHeight : 0) - (filterHeadElem ? filterHeadElem.offsetHeight : 0));
            }
            if (column.fixed === "left") {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth;
            } else if (column.fixed === "right") {
              right = targetElem.offsetParent.offsetWidth - targetElem.offsetLeft + (targetElem.offsetParent.offsetParent.offsetWidth - targetElem.offsetParent.offsetLeft) - column.renderWidth - centerWidth;
            } else {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth - bodyElem.scrollLeft;
            }
            if (left) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                left -= overflowWidth;
              }
              style.left = `${Math.min(maxLeft, Math.max(minMargin, left))}px`;
            } else if (right) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                right += overflowWidth;
              }
              style.right = `${Math.max(minMargin, right)}px`;
            }
            filterStore.style = style;
            filterStore.maxHeight = maxHeight;
          });
        }
        $xeTable.dispatchEvent("filter-visible", { column, field: column.field, property: column.field, filterList: $xeTable.getCheckedFilters(), visible: filterStore.visible }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const { filters, filterRender } = column;
          if (filters) {
            const compConf = isEnableConf(filterRender) ? renderer9.get(filterRender.name) : null;
            const frMethod = column.filterResetMethod || (compConf ? compConf.tableFilterResetMethod || compConf.filterResetMethod : null);
            filters.forEach((item) => {
              item._checked = false;
              item.checked = false;
              if (!frMethod) {
                item.data = import_xe_utils29.default.clone(item.resetValue, true);
              }
            });
            if (frMethod) {
              frMethod({ options: filters, column, $table: $xeTable });
            }
          }
        }
      },
      handleColumnConfirmFilter(column, evnt) {
        const { mouseConfig } = props;
        const { scrollXLoad: oldScrollXLoad, scrollYLoad: oldScrollYLoad } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const { field } = column;
        const values = [];
        const datas = [];
        column.filters.forEach((item) => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xeTable.getCheckedFilters();
        const params = { $table: $xeTable, $event: evnt, column, field, property: field, values, datas, filters: filterList, filterList };
        if (!filterOpts.remote) {
          $xeTable.handleTableData(true);
          $xeTable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xeTable.handleFilterEvent) {
          $xeTable.handleFilterEvent(evnt, params);
        }
        if (evnt) {
          $xeTable.dispatchEvent("filter-change", params, evnt);
        }
        $xeTable.closeFilter();
        return $xeTable.updateFooter().then(() => {
          const { scrollXLoad, scrollYLoad } = reactData;
          if (oldScrollXLoad || scrollXLoad || (oldScrollYLoad || scrollYLoad)) {
            if (oldScrollXLoad || scrollXLoad) {
              $xeTable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
            return $xeTable.refreshScroll();
          }
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate(true);
        }).then(() => {
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 
       * 
       * @param {Event} evnt 
       */
      confirmFilterEvent(evnt) {
        const { filterStore } = reactData;
        const { column } = filterStore;
        $xeTable.handleColumnConfirmFilter(column, evnt);
      },
      handleFilterChangeRadioOption: changeRadioOption,
      handleFilterChangeMultipleOption: changeMultipleOption,
      // 
      handleFilterChangeOption(evnt, checked, item) {
        const { filterStore } = reactData;
        if (filterStore.multiple) {
          changeMultipleOption(evnt, checked, item);
        } else {
          changeRadioOption(evnt, checked, item);
        }
      },
      handleFilterConfirmFilter,
      handleFilterResetFilter
    };
    const filterMethods = {
      /**
       * 
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          const { elemStore } = internalData;
          const { fixed } = column;
          return $xeTable.scrollToColumn(column).then(() => {
            const headerWrapperElem = getRefElem(elemStore[`${fixed || "main"}-header-wrapper`] || elemStore["main-header-wrapper"]);
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-filter--btn`);
              triggerEvent2(filterBtnElem, "click");
            }
          });
        }
        return nextTick();
      },
      /**
       * 
       * @param {ColumnInfo} fieldOrColumn 
       * @param {Array} options 
       */
      setFilter(fieldOrColumn, options, isUpdate) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || []);
          if (isUpdate) {
            return $xeTable.handleColumnConfirmFilter(column, new Event("click"));
          }
        }
        return nextTick();
      },
      /**
       * 
       * 
       * @param {String} fieldOrColumn 
       */
      clearFilter(fieldOrColumn) {
        const { filterStore } = reactData;
        const { tableFullColumn } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            filterPrivateMethods.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach(filterPrivateMethods.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xeTable.updateData();
        }
        return nextTick();
      },
      saveFilterPanel() {
        handleFilterConfirmFilter(null);
        return nextTick();
      },
      resetFilterPanel() {
        handleFilterResetFilter(null);
        return nextTick();
      },
      getCheckedFilters() {
        const { tableFullColumn } = internalData;
        const filterList = [];
        tableFullColumn.forEach((column) => {
          const { field, filters } = column;
          const valueList = [];
          const dataList = [];
          if (filters && filters.length) {
            filters.forEach((item) => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({ column, field, property: field, values: valueList, datas: dataList });
            }
          }
        });
        return filterList;
      },
      updateFilterOptionStatus(item, checked) {
        item._checked = checked;
        item.checked = checked;
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, filterMethods), filterPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableFilterMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/menu/hook.js
var import_xe_utils30 = __toESM(require_xe_utils());
var { menus: menus3, hooks: hooks5, globalEvents: globalEvents4, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS3 } = VxeUI;
var tableMenuMethodKeys = ["closeMenu"];
hooks5.add("tableMenuModule", {
  setupTable($xeTable) {
    const { xID, props, reactData, internalData } = $xeTable;
    const { refElem, refTableFilter, refTableMenu } = $xeTable.getRefMaps();
    const { computeMouseOpts, computeIsMenu, computeMenuOpts } = $xeTable.getComputeMaps();
    let menuMethods = {};
    let menuPrivateMethods = {};
    const handleOpenMenuEvent = (evnt, type, params) => {
      const { ctxMenuStore } = reactData;
      const isMenu = computeIsMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config3 = menuOpts[type];
      const visibleMethod = menuOpts.visibleMethod;
      if (config3) {
        const { options, disabled } = config3;
        if (disabled) {
          evnt.preventDefault();
        } else if (isMenu && options && options.length) {
          params.options = options;
          $xeTable.preventEvent(evnt, "event.showMenu", params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xeTable.updateZindex();
              const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
              let top = evnt.clientY + scrollTop;
              let left = evnt.clientX + scrollLeft;
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                nextTick(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const { boundingTop, boundingLeft } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const { keyboard, row, column } = params;
              if (keyboard && row && column) {
                $xeTable.scrollToRow(row, column).then(() => {
                  const cell = $xeTable.getCellElement(row, column);
                  if (cell) {
                    const { boundingTop, boundingLeft } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xeTable.closeFilter();
    };
    menuMethods = {
      /**
       * 
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return nextTick();
      }
    };
    menuPrivateMethods = {
      /**
       * 
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = import_xe_utils30.default.findIndexOf(menuList, (item) => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (globalEvents4.hasKey(evnt, GLOBAL_EVENT_KEYS3.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (globalEvents4.hasKey(evnt, GLOBAL_EVENT_KEYS3.ARROW_DOWN)) {
          for (let index2 = selectIndex + 1; index2 < menuList.length; index2++) {
            if (menuList[index2].visible !== false) {
              selectItem = menuList[index2];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (globalEvents4.hasKey(evnt, GLOBAL_EVENT_KEYS3.ENTER) || globalEvents4.hasKey(evnt, GLOBAL_EVENT_KEYS3.SPACEBAR))) {
          menuPrivateMethods.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 
       */
      handleGlobalContextmenuEvent(evnt) {
        const { mouseConfig, menuConfig } = props;
        const { editStore, ctxMenuStore } = reactData;
        const { visibleColumn } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el2 = refElem.value;
        const { selected } = editStore;
        const layoutList = ["header", "body", "footer"];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = "body";
            const params = { type, $table: $xeTable, keyboard: true, columns: visibleColumn.slice(0), $event: evnt };
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xeTable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          for (let index2 = 0; index2 < layoutList.length; index2++) {
            const layout = layoutList[index2];
            const columnTargetNode = getEventTargetNode(evnt, el2, `vxe-${layout}--column`, (target) => {
              return target.parentNode.parentNode.parentNode.getAttribute("xid") === xID;
            });
            const params = { type: layout, $table: $xeTable, columns: visibleColumn.slice(0), $event: evnt };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xeTable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, { column, columnIndex: $xeTable.getColumnIndex(column), cell });
              }
              if (layout === "body") {
                const rowNodeRest = $xeTable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = "";
                if (row) {
                  params.row = row;
                  params.rowIndex = $xeTable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xeTable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el2, `vxe-table--${layout}-wrapper`, (target) => target.getAttribute("xid") === xID).flag) {
              if (menuOpts.trigger === "cell") {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.$el).flag) {
          $xeTable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const { ctxMenuStore } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            nextTick(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = "";
                let right = "";
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = "auto";
                  right = `${menuElem.offsetWidth}px`;
                }
                let top = "";
                let bottom = "";
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = "auto";
                  bottom = "0";
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const { ctxMenuStore } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 
       */
      ctxMenuLinkEvent(evnt, menu) {
        if (!menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = menus3.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, { menu, $table: $xeTable, $grid: $xeTable.xegrid, $event: evnt });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xeTable.dispatchEvent("menu-click", params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return Object.assign(Object.assign({}, menuMethods), menuPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableMenuMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/edit/hook.js
var import_xe_utils31 = __toESM(require_xe_utils());
var { getConfig: getConfig5, renderer: renderer10, hooks: hooks6, getI18n: getI18n11 } = VxeUI;
var tableEditMethodKeys = ["insert", "insertAt", "insertNextAt", "remove", "removeCheckboxRow", "removeRadioRow", "removeCurrentRow", "getRecordset", "getInsertRecords", "getRemoveRecords", "getUpdateRecords", "getEditRecord", "getActiveRecord", "getSelectedCell", "clearEdit", "clearActived", "clearSelected", "isEditByRow", "isActiveByRow", "setEditRow", "setActiveRow", "setEditCell", "setActiveCell", "setSelectCell"];
hooks6.add("tableEditModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem } = $xeTable.getRefMaps();
    const { computeMouseOpts, computeEditOpts, computeCheckboxOpts, computeTreeOpts, computeValidOpts } = $xeTable.getComputeMaps();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el2 = refElem.value;
      if (el2) {
        const cell = el2.querySelector(".col--selected");
        if (cell) {
          removeClass(cell, "col--selected");
        }
      }
    };
    function syncActivedCell() {
      const { editStore, tableColumn } = reactData;
      const editOpts = computeEditOpts.value;
      const { actived } = editStore;
      const { row, column } = actived;
      if (row || column) {
        if (editOpts.mode === "row") {
          tableColumn.forEach((column2) => setEditColumnModel(row, column2));
        } else {
          setEditColumnModel(row, column);
        }
      }
    }
    function insertTreeRow(newRecords, isAppend) {
      const { tableFullTreeData, afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { rowField, parentField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? "push" : "unshift";
      newRecords.forEach((item) => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xeTable, item);
        const matchObj = parentRowId ? import_xe_utils31.default.findTree(tableFullTreeData, (item2) => parentRowId === item2[rowField], { children: mapChildrenField }) : null;
        if (matchObj) {
          const { item: parentRow } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let parentChilds = parentRow[childrenField];
          let mapChilds = parentRow[mapChildrenField];
          if (!import_xe_utils31.default.isArray(parentChilds)) {
            parentChilds = parentRow[childrenField] = [];
          }
          if (!import_xe_utils31.default.isArray(mapChilds)) {
            mapChilds = parentRow[childrenField] = [];
          }
          parentChilds[funcName](item);
          mapChilds[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentChilds, parent: parentRow, level: parentLevel + 1, height: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (true) {
            if (parentRowId) {
              warnLog("vxe.error.unableInsert");
            }
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: tableFullTreeData, parent: null, level: 0, height: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    }
    const handleInsertRowAt = (records, row, isInsertNextRow) => {
      const { treeConfig } = props;
      const { mergeList, editStore } = reactData;
      const { tableFullTreeData, afterFullData, tableFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform: transform2, rowField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!import_xe_utils31.default.isArray(records)) {
        records = [records];
      }
      const newRecords = reactive($xeTable.defineField(records.map((record) => Object.assign(treeConfig && transform2 ? { [mapChildrenField]: [], [childrenField]: [] } : {}, record))));
      if (import_xe_utils31.default.eqNull(row)) {
        if (treeConfig && transform2) {
          insertTreeRow(newRecords, false);
        } else {
          newRecords.forEach((item) => {
            const rowid = getRowid($xeTable, item);
            const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: afterFullData, parent: null, level: 0, height: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
            afterFullData.unshift(item);
            tableFullData.unshift(item);
          });
          mergeList.forEach((mergeItem) => {
            const { row: mergeRowIndex } = mergeItem;
            if (mergeRowIndex > 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (row === -1) {
          if (treeConfig && transform2) {
            insertTreeRow(newRecords, true);
          } else {
            newRecords.forEach((item) => {
              const rowid = getRowid($xeTable, item);
              const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: afterFullData, parent: null, level: 0, height: 0 };
              fullDataRowIdData[rowid] = rest;
              fullAllDataRowIdData[rowid] = rest;
              afterFullData.push(item);
              tableFullData.push(item);
            });
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex + mergeRowspan > afterFullData.length) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        } else {
          if (treeConfig && transform2) {
            const matchMapObj = import_xe_utils31.default.findTree(tableFullTreeData, (item) => row[rowField] === item[rowField], { children: mapChildrenField });
            if (matchMapObj) {
              const { parent: parentRow } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              newRecords.forEach((item, i) => {
                const rowid = getRowid($xeTable, item);
                if (true) {
                  if (item[treeOpts.parentField]) {
                    if (parentRow && item[treeOpts.parentField] !== parentRow[rowField]) {
                      errLog("vxe.error.errProp", [`${treeOpts.parentField}=${item[treeOpts.parentField]}`, `${treeOpts.parentField}=${parentRow[rowField]}`]);
                    }
                  }
                }
                if (parentRow) {
                  item[treeOpts.parentField] = parentRow[rowField];
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, item);
                const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentMapChilds, parent: parentRow, level: parentLevel + 1, height: 0 };
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              });
              if (parentRow) {
                const matchObj = import_xe_utils31.default.findTree(tableFullTreeData, (item) => row[rowField] === item[rowField], { children: childrenField });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...newRecords);
                }
              }
            } else {
              if (true) {
                warnLog("vxe.error.unableInsert");
              }
              insertTreeRow(newRecords, true);
            }
          } else {
            if (treeConfig) {
              throw new Error(getI18n11("vxe.error.noTree", ["insert"]));
            }
            let afIndex = -1;
            if (import_xe_utils31.default.isNumber(row)) {
              if (row < afterFullData.length) {
                afIndex = row;
              }
            } else {
              afIndex = $xeTable.findRowIndexOf(afterFullData, row);
            }
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(getI18n11("vxe.error.unableInsert"));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            tableFullData.splice($xeTable.findRowIndexOf(tableFullData, row), 0, ...newRecords);
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex > afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      const { insertMaps } = editStore;
      newRecords.forEach((newRow) => {
        const rowid = getRowid($xeTable, newRow);
        insertMaps[rowid] = newRow;
      });
      $xeTable.cacheRowMap();
      $xeTable.updateScrollYStatus();
      $xeTable.handleTableData(treeConfig && transform2);
      if (!(treeConfig && transform2)) {
        $xeTable.updateAfterDataIndex();
      }
      $xeTable.updateFooter();
      $xeTable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xeTable.updateScrollYSpace();
      }
      return nextTick().then(() => {
        $xeTable.updateCellAreas();
        return $xeTable.recalculate();
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    const handleClearEdit = (evnt, targetRow) => {
      const { mouseConfig } = props;
      const { editStore } = reactData;
      const { actived, focused } = editStore;
      const { row, column } = actived;
      const validOpts = computeValidOpts.value;
      const mouseOpts = computeMouseOpts.value;
      if (row || column) {
        if (targetRow && getRowid($xeTable, targetRow) !== getRowid($xeTable, row)) {
          return nextTick();
        }
        syncActivedCell();
        actived.args = null;
        actived.row = null;
        actived.column = null;
        $xeTable.updateFooter();
        $xeTable.dispatchEvent("edit-closed", {
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex: $xeTable.getVMRowIndex(row),
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex: $xeTable.getVMColumnIndex(column)
        }, evnt || null);
      }
      nextTick(() => {
        if (mouseConfig && mouseOpts.area && $xeTable.handleRecalculateCellAreas) {
          return $xeTable.handleRecalculateCellAreas();
        }
      });
      if (validOpts.autoClear) {
        if (validOpts.msgMode !== "full" || getConfig5().cellVaildMode === "obsolete") {
          if ($xeTable.clearValidate) {
            return $xeTable.clearValidate();
          }
        }
      }
      focused.row = null;
      focused.column = null;
      return nextTick();
    };
    editMethods = {
      /**
       * 
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 
       *  row 
       *  row  -1 
       *  row 
       * @param {Object/Array} records 
       * @param {Row} row 
       */
      insertAt(records, row) {
        return handleInsertRowAt(records, row);
      },
      insertNextAt(records, row) {
        return handleInsertRowAt(records, row, true);
      },
      /**
       * 
       *  row 
       *  rows 
       * 
       */
      remove(rows) {
        const { treeConfig } = props;
        const { mergeList, editStore, selectCheckboxMaps } = reactData;
        const { tableFullTreeData, afterFullData, tableFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { actived, removeMaps } = editStore;
        const insertDataRowMaps = Object.assign({}, editStore.insertMaps);
        const pendingDataRowMaps = Object.assign({}, reactData.pendingRowMaps);
        const { checkField } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!import_xe_utils31.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          if (!$xeTable.isInsertByRow(row)) {
            const rowid = getRowid($xeTable, row);
            removeMaps[rowid] = row;
          }
        });
        if (!checkField) {
          const selectRowMaps = Object.assign({}, selectCheckboxMaps);
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            if (selectRowMaps[rowid]) {
              delete selectRowMaps[rowid];
            }
          });
          reactData.selectCheckboxMaps = selectRowMaps;
        }
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xeTable.clearMergeCells();
        } else {
          if (treeConfig && transform2) {
            rows.forEach((row) => {
              const rowid = getRowid($xeTable, row);
              const matchMapObj = import_xe_utils31.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xeTable, item), { children: mapChildrenField });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = import_xe_utils31.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else {
            rows.forEach((row) => {
              const tfIndex = $xeTable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                mergeList.forEach((mergeItem) => {
                  const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        if (actived.row && $xeTable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        rows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (insertDataRowMaps[rowid]) {
            delete insertDataRowMaps[rowid];
          }
          if (pendingDataRowMaps[rowid]) {
            delete pendingDataRowMaps[rowid];
          }
        });
        editStore.insertMaps = insertDataRowMaps;
        reactData.pendingRowMaps = pendingDataRowMaps;
        $xeTable.updateFooter();
        $xeTable.cacheRowMap();
        $xeTable.handleTableData(treeConfig && transform2);
        if (!(treeConfig && transform2)) {
          $xeTable.updateAfterDataIndex();
        }
        $xeTable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xeTable.updateScrollYSpace();
        }
        return nextTick().then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate();
        }).then(() => {
          return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };
        });
      },
      /**
       * 
       */
      removeCheckboxRow() {
        return editMethods.remove($xeTable.getCheckboxRecords()).then((params) => {
          $xeTable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 
       */
      removeRadioRow() {
        const radioRecord = $xeTable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then((params) => {
          $xeTable.clearRadioRow();
          return params;
        });
      },
      /**
       * 
       */
      removeCurrentRow() {
        const currentRecord = $xeTable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then((params) => {
          $xeTable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 
       */
      getRecordset() {
        const removeRecords = editMethods.getRemoveRecords();
        const pendingRecords = $xeTable.getPendingRecords();
        const delRecords = removeRecords.concat(pendingRecords);
        const updateRecords = editMethods.getUpdateRecords().filter((row) => {
          return !delRecords.some((item) => $xeTable.eqRow(item, row));
        });
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords,
          updateRecords,
          pendingRecords
        };
      },
      /**
       * 
       */
      getInsertRecords() {
        const { editStore } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const { insertMaps } = editStore;
        const insertRecords = [];
        import_xe_utils31.default.each(insertMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 
       */
      getRemoveRecords() {
        const { editStore } = reactData;
        const { removeMaps } = editStore;
        const removeRecords = [];
        import_xe_utils31.default.each(removeMaps, (row) => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 
       *  row 
       * 
       */
      getUpdateRecords() {
        const { keepSource, treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return import_xe_utils31.default.filterTree(tableFullData, (row) => $xeTable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter((row) => $xeTable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        if (true) {
          warnLog("vxe.error.delFunc", ["getActiveRecord", "getEditRecord"]);
        }
        return this.getEditRecord();
      },
      getEditRecord() {
        const { editStore } = reactData;
        const { afterFullData } = internalData;
        const el2 = refElem.value;
        const { args, row } = editStore.actived;
        if (args && $xeTable.findRowIndexOf(afterFullData, row) > -1 && el2.querySelectorAll(".vxe-body--column.col--active").length) {
          return Object.assign({}, args);
        }
        return null;
      },
      /**
       * 
       */
      getSelectedCell() {
        const { editStore } = reactData;
        const { args, column } = editStore.selected;
        if (args && column) {
          return Object.assign({}, args);
        }
        return null;
      },
      clearActived(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["clearActived", "clearEdit"]);
        }
        return this.clearEdit(row);
      },
      /**
       * 
       */
      clearEdit(row) {
        return handleClearEdit(null, row);
      },
      /**
       * 
       */
      clearSelected() {
        const { editStore } = reactData;
        const { selected } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return nextTick();
      },
      isActiveByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isActiveByRow", "isEditByRow"]);
        }
        return this.isEditByRow(row);
      },
      /**
       * 
       * @param {Row} row 
       */
      isEditByRow(row) {
        const { editStore } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveRow", "setEditRow"]);
        }
        return editMethods.setEditRow(row);
      },
      /**
       * 
       */
      setEditRow(row, fieldOrColumn) {
        const { visibleColumn } = internalData;
        let column = import_xe_utils31.default.find(visibleColumn, (column2) => isEnableConf(column2.editRender));
        if (fieldOrColumn) {
          column = import_xe_utils31.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        }
        return $xeTable.setEditCell(row, column);
      },
      setActiveCell(row, fieldOrColumn) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveCell", "setEditCell"]);
        }
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 
       */
      setEditCell(row, fieldOrColumn) {
        const { editConfig } = props;
        const column = import_xe_utils31.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {
          return $xeTable.scrollToRow(row, column).then(() => {
            const cell = $xeTable.getCellElement(row, column);
            if (cell) {
              editPrivateMethods.handleEdit({
                row,
                rowIndex: $xeTable.getRowIndex(row),
                column,
                columnIndex: $xeTable.getColumnIndex(column),
                cell,
                $table: $xeTable
              });
              internalData._lastCallTime = Date.now();
            }
            return nextTick();
          });
        }
        return nextTick();
      },
      /**
       *  trigger=dblclick 
       */
      setSelectCell(row, fieldOrColumn) {
        const { tableData } = reactData;
        const editOpts = computeEditOpts.value;
        const column = import_xe_utils31.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== "manual") {
          const rowIndex = $xeTable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xeTable.getCellElement(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell
            };
            $xeTable.handleSelected(params, {});
          }
        }
        return nextTick();
      }
    };
    editPrivateMethods = {
      /**
       * 
       */
      handleEdit(params, evnt) {
        const { editConfig, mouseConfig } = props;
        const { editStore, tableColumn } = reactData;
        const editOpts = computeEditOpts.value;
        const { mode } = editOpts;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { editRender } = column;
        const cell = params.cell || $xeTable.getCellElement(row, column);
        const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
        params.cell = cell;
        if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
          if (!$xeTable.isPendingByRow(row)) {
            if (actived.row !== row || (mode === "cell" ? actived.column !== column : false)) {
              let type = "edit-disabled";
              if (!beforeEditMethod || beforeEditMethod(Object.assign(Object.assign({}, params), { $table: $xeTable, $grid: $xeTable.xegrid }))) {
                if (mouseConfig) {
                  editMethods.clearSelected();
                  if ($xeTable.clearCellAreas) {
                    $xeTable.clearCellAreas();
                    $xeTable.clearCopyCellArea();
                  }
                }
                $xeTable.closeTooltip();
                if (actived.column) {
                  handleClearEdit(evnt);
                }
                type = "edit-activated";
                column.renderHeight = cell.offsetHeight;
                actived.args = params;
                actived.row = row;
                actived.column = column;
                if (mode === "row") {
                  tableColumn.forEach((column2) => getEditColumnModel(row, column2));
                } else {
                  getEditColumnModel(row, column);
                }
                const afterEditMethod = editOpts.afterEditMethod;
                nextTick(() => {
                  editPrivateMethods.handleFocus(params, evnt);
                  if (afterEditMethod) {
                    afterEditMethod(Object.assign(Object.assign({}, params), { $table: $xeTable, $grid: $xeTable.xegrid }));
                  }
                });
              }
              $xeTable.dispatchEvent(type, {
                row,
                rowIndex: $xeTable.getRowIndex(row),
                $rowIndex: $xeTable.getVMRowIndex(row),
                column,
                columnIndex: $xeTable.getColumnIndex(column),
                $columnIndex: $xeTable.getVMColumnIndex(column)
              }, evnt);
              if (type === "edit-activated") {
                $xeTable.dispatchEvent("edit-actived", {
                  row,
                  rowIndex: $xeTable.getRowIndex(row),
                  $rowIndex: $xeTable.getVMRowIndex(row),
                  column,
                  columnIndex: $xeTable.getColumnIndex(column),
                  $columnIndex: $xeTable.getVMColumnIndex(column)
                }, evnt);
              }
            } else {
              const { column: oldColumn } = actived;
              if (mouseConfig) {
                editMethods.clearSelected();
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              if (oldColumn !== column) {
                const { model: oldModel } = oldColumn;
                if (oldModel.update) {
                  setCellValue(row, oldColumn, oldModel.value);
                }
                if ($xeTable.clearValidate) {
                  $xeTable.clearValidate(row, column);
                }
              }
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.column = column;
              setTimeout(() => {
                editPrivateMethods.handleFocus(params, evnt);
              });
            }
            focused.column = null;
            focused.row = null;
            $xeTable.focus();
          }
        }
        return nextTick();
      },
      /**
       * @deprecated
       */
      handleActived(params, evnt) {
        return editPrivateMethods.handleEdit(params, evnt);
      },
      /**
       * 
       * @param evnt
       * @returns
       */
      handleClearEdit,
      /**
       * 
       */
      handleFocus(params) {
        const { row, column, cell } = params;
        const { editRender } = column;
        const editOpts = computeEditOpts.value;
        if (isEnableConf(editRender)) {
          const compRender = renderer10.get(editRender.name);
          let autoFocus = editRender.autofocus || editRender.autoFocus;
          let autoSelect = editRender.autoSelect || editRender.autoselect;
          let inputElem;
          if (editOpts.autoFocus) {
            if (!autoFocus && compRender) {
              autoFocus = compRender.tableAutoFocus || compRender.tableAutofocus || compRender.autofocus;
            }
            if (!autoSelect && compRender) {
              autoSelect = compRender.tableAutoSelect || compRender.autoselect;
            }
            if (import_xe_utils31.default.isFunction(autoFocus)) {
              inputElem = autoFocus(params);
            } else if (autoFocus) {
              if (autoFocus === true) {
                inputElem = cell.querySelector("input,textarea");
              } else {
                inputElem = cell.querySelector(autoFocus);
              }
              if (inputElem) {
                inputElem.focus();
              }
            }
          }
          if (inputElem) {
            if (autoSelect) {
              inputElem.select();
            } else {
              if (browse2.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            if (editOpts.autoPos) {
              if (!column.fixed) {
                $xeTable.scrollToRow(row, column);
              }
            }
          }
        }
      },
      /**
       * 
       */
      handleSelected(params, evnt) {
        const { mouseConfig } = props;
        const { editStore } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const { actived, selected } = editStore;
        const { row, column } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === "cell" ? actived.column !== column : false)) {
              handleClearEdit(evnt);
              editMethods.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xeTable.focus();
              if (evnt) {
                $xeTable.dispatchEvent("cell-selected", params, evnt);
              }
            }
          }
          return nextTick();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const { editStore } = reactData;
        const { selected } = editStore;
        const { row, column } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            addClass(cell, "col--selected");
          }
        }
      }
    };
    return Object.assign(Object.assign({}, editMethods), editPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableEditMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/export/hook.js
var import_xe_utils32 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/module/export/util.js
var defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",,"MicrosoftJhengHei",,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function getExportBlobByContent(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
function createHtmlPage(opts, content) {
  const { style } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.sheetName}</title>`,
    '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>',
    `<style>${defaultHtmlStyle}</style>`,
    style ? `<style>${style}</style>` : "",
    "</head>",
    `<body>${content}</body>`,
    "</html>"
  ].join("");
}

// node_modules/vxe-table/es/table/module/export/hook.js
var { getI18n: getI18n12, hooks: hooks7, renderer: renderer11 } = VxeUI;
var htmlCellElem;
var csvBOM = "\uFEFF";
var enterSymbol = "\r\n";
function defaultFilterExportColumn(column) {
  return column.property || ["seq", "checkbox", "radio"].indexOf(column.type) > -1;
}
var getConvertColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
var convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return "full";
  }
  if (border) {
    return border;
  }
  return "default";
}
function getBooleanValue(cellValue) {
  return cellValue === "TRUE" || cellValue === "true" || cellValue === true;
}
function getFooterData(opts, footerTableData) {
  const { footerFilterMethod } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index2) => footerFilterMethod({ items, $rowIndex: index2 })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === "seq") {
      return `	${cellValue}`;
    }
    switch (column.cellType) {
      case "string":
        if (!isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
      case "number":
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now2) {
  return `#${now2}@${import_xe_utils32.default.uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, (key) => import_xe_utils32.default.hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, (qVal) => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function parseCsvAndTxt(columns, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now2 = Date.now();
    list.forEach((rVal) => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now2);
          vMaps[key] = dVal ? '"' : "\n";
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now2);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map((val) => getTxtCellValue(val.trim(), vMaps));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return { fields, rows };
}
function parseCsv(columns, content) {
  return parseCsvAndTxt(columns, content, ",");
}
function parseTxt(columns, content) {
  return parseCsvAndTxt(columns, content, "	");
}
function parseHTML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "text/html");
  const bodyNodes = getElementsByTagName(xmlDoc, "body");
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], "table");
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], "thead");
      if (theadNodes.length) {
        import_xe_utils32.default.arrayEach(getElementsByTagName(theadNodes[0], "tr"), (rowNode) => {
          import_xe_utils32.default.arrayEach(getElementsByTagName(rowNode, "th"), (cellNode) => {
            fields.push(cellNode.textContent);
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], "tbody");
        if (tbodyNodes.length) {
          import_xe_utils32.default.arrayEach(getElementsByTagName(tbodyNodes[0], "tr"), (rowNode) => {
            const item = {};
            import_xe_utils32.default.arrayEach(getElementsByTagName(rowNode, "td"), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || "";
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return { fields, rows };
}
function parseXML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "application/xml");
  const sheetNodes = getElementsByTagName(xmlDoc, "Worksheet");
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], "Table");
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], "Row");
      if (rowNodes.length) {
        import_xe_utils32.default.arrayEach(getElementsByTagName(rowNodes[0], "Cell"), (cellNode) => {
          fields.push(cellNode.textContent);
        });
        import_xe_utils32.default.arrayEach(rowNodes, (rowNode, index2) => {
          if (index2) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, "Cell");
            import_xe_utils32.default.arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return { fields, rows };
}
function clearColumnConvert(columns) {
  import_xe_utils32.default.eachTree(columns, (column) => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, { children: "children" });
}
function checkImportData(columns, fields) {
  const tableFields = [];
  columns.forEach((column) => {
    const field = column.property;
    if (field) {
      tableFields.push(field);
    }
  });
  return fields.some((field) => tableFields.indexOf(field) > -1);
}
var tableExportMethodKeys = ["exportData", "importByFile", "importData", "saveFile", "readFile", "print", "getPrintHtml", "openImport", "closeImport", "openExport", "closeExport", "openPrint", "closePrint"];
hooks7.add("tableExportModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { computeTreeOpts, computePrintOpts, computeExportOpts, computeImportOpts, computeCustomOpts, computeSeqOpts, computeRadioOpts, computeCheckboxOpts, computeColumnOpts } = $xeTable.getComputeMaps();
    const $xeGrid = inject("$xeGrid", null);
    const hasTreeChildren = (row) => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (cellValue, row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMethod = seqOpts.seqMethod || column.seqMethod;
      if (seqMethod) {
        return seqMethod({
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex
        });
      }
      return cellValue;
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({ column, options: opts, $table: $xeTable }) : (opts.original ? column.property : column.getTitle()) || "";
    }
    const toBooleanValue = (cellValue) => {
      return import_xe_utils32.default.isBoolean(cellValue) ? cellValue ? "TRUE" : "FALSE" : cellValue;
    };
    const getBodyLabelData = (opts, columns, datas) => {
      const { isAllExpand, mode } = opts;
      const { treeConfig } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement("div");
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rest = [];
        const expandMaps = /* @__PURE__ */ new Map();
        import_xe_utils32.default.eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const parentRow = parent && parent._row ? parent._row : parent;
          if (isAllExpand || !parentRow || expandMaps.has(parentRow) && $xeTable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item2 = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xeTable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = "";
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = renderer11.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({ $table: $xeTable, row, column, options: opts });
              } else {
                switch (column.type) {
                  case "seq": {
                    const seqVal = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
                    cellValue = mode === "all" ? seqVal : getSeq(seqVal, row, $rowIndex, column, $columnIndex);
                    break;
                  }
                  case "checkbox":
                    cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                    item2._checkboxLabel = checkboxOpts.labelField ? import_xe_utils32.default.get(row, checkboxOpts.labelField) : "";
                    item2._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                    break;
                  case "radio":
                    cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                    item2._radioLabel = radioOpts.labelField ? import_xe_utils32.default.get(row, radioOpts.labelField) : "";
                    item2._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = `${$xeTable.getCellLabel(row, column)}`;
                      if (column.type === "html") {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xeTable.getCellElement(row, column);
                        if (cell) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item2[column.id] = import_xe_utils32.default.toValueString(cellValue);
            });
            expandMaps.set(row, 1);
            rest.push(Object.assign(item2, row));
          }
        }, { children: childrenField });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = "";
          const renderOpts = column.editRender || column.cellRender;
          let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
          if (!bodyExportMethod && renderOpts && renderOpts.name) {
            const compConf = renderer11.get(renderOpts.name);
            if (compConf) {
              bodyExportMethod = compConf.exportMethod;
            }
          }
          if (bodyExportMethod) {
            cellValue = bodyExportMethod({ $table: $xeTable, row, column, options: opts });
          } else {
            switch (column.type) {
              case "seq": {
                const seqValue = $rowIndex + 1;
                cellValue = mode === "all" ? seqValue : getSeq(seqValue, row, $rowIndex, column, $columnIndex);
                break;
              }
              case "checkbox":
                cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? import_xe_utils32.default.get(row, checkboxOpts.labelField) : "";
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                break;
              case "radio":
                cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? import_xe_utils32.default.get(row, radioOpts.labelField) : "";
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = `${$xeTable.getCellLabel(row, column)}`;
                  if (column.type === "html") {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xeTable.getCellElement(row, column);
                    if (cell) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = import_xe_utils32.default.toValueString(cellValue);
        });
        return item;
      });
    };
    const getExportData = (opts) => {
      const { columns, dataFilterMethod } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index2) => dataFilterMethod({ row, $rowIndex: index2 }));
      }
      return getBodyLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, row, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = renderer11.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.tableFooterExportMethod || compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      const _columnIndex = $xeTable.getVTColumnIndex(column);
      if (footLabelMethod) {
        return footLabelMethod({ $table: $xeTable, items: row, itemIndex: _columnIndex, row, _columnIndex, column, options: opts });
      }
      if (import_xe_utils32.default.isArray(row)) {
        return import_xe_utils32.default.toValueString(row[_columnIndex]);
      }
      return import_xe_utils32.default.get(row, column.field);
    };
    const toCsv = (opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join(",") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(",") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, row, column))).join(",") + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = (opts, columns, datas) => {
      let content = "";
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join("	") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(row[column.id])).join("	") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, row, column))).join("	") + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = import_xe_utils32.default.isUndefined(columnOverflow) || import_xe_utils32.default.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === "ellipsis";
      const showTitle = headOverflow === "title";
      const showTooltip = headOverflow === true || headOverflow === "tooltip";
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      const { scrollXLoad, scrollYLoad } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const { id: id2, border, treeConfig, headerAlign: allHeaderAlign, align: allAlign, footerAlign: allFooterAlign, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow } = props;
      const { isAllSelected, isIndeterminate, mergeList } = reactData;
      const treeOpts = computeTreeOpts.value;
      const { print: isPrint, isHeader, isFooter, isColgroup, isMerge, colgroups, original } = opts;
      const allCls = "check-all";
      const clss = [
        "vxe-table",
        `border--${toTableBorder(border)}`,
        isPrint ? "is--print" : "",
        isHeader ? "is--header" : ""
      ].filter((cls) => cls);
      const tables = [
        `<table class="${clss.join(" ")}" border="0" cellspacing="0" cellpadding="0">`,
        `<colgroup>${columns.map((column) => `<col style="width:${column.renderWidth}px">`).join("")}</colgroup>`
      ];
      if (isHeader) {
        tables.push("<thead>");
        if (isColgroup && !original) {
          colgroups.forEach((cols) => {
            tables.push(`<tr>${cols.map((column) => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              import_xe_utils32.default.eachTree([column], (item) => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, { children: "childNodes" });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === "checkbox") {
                return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join("")}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map((column) => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === "checkbox") {
              return `<th class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(" ")}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join("")}</tr>`);
        }
        tables.push("</thead>");
      }
      if (datas.length) {
        tables.push("<tbody>");
        if (treeConfig) {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = "";
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? "vxe-table--tree-fold-icon" : "vxe-table--tree-unfold-icon"}"></i>`;
                }
                classNames.push("vxe-table--tree-node");
                if (column.type === "radio") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id2}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === "checkbox") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id2}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        } else {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge && mergeList.length) {
                const _rowIndex = $xeTable.getVTRowIndex(item._row);
                const _columnIndex = $xeTable.getVTColumnIndex(column);
                const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
                if (spanRest) {
                  const { rowspan, colspan } = spanRest;
                  if (!rowspan || !colspan) {
                    return "";
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id2}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        }
        tables.push("</tbody>");
      }
      if (isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        if (footers.length) {
          tables.push("<tfoot>");
          footers.forEach((row) => {
            tables.push(`<tr>${columns.map((column) => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = getFooterCellValue(opts, row, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("")}</tr>`);
          });
          tables.push("</tfoot>");
        }
      }
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()<\/script>` : "";
      tables.push("</table>", script);
      return isPrint ? tables.join("") : createHtmlPage(opts, tables.join(""));
    };
    const toXML = (opts, columns, datas) => {
      let xml = [
        '<?xml version="1.0"?>',
        '<?mso-application progid="Excel.Sheet"?>',
        '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">',
        '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">',
        "<Version>16.00</Version>",
        "</DocumentProperties>",
        '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">',
        "<WindowHeight>7920</WindowHeight>",
        "<WindowWidth>21570</WindowWidth>",
        "<WindowTopX>32767</WindowTopX>",
        "<WindowTopY>32767</WindowTopY>",
        "<ProtectStructure>False</ProtectStructure>",
        "<ProtectWindows>False</ProtectWindows>",
        "</ExcelWorkbook>",
        `<Worksheet ss:Name="${opts.sheetName}">`,
        "<Table>",
        columns.map((column) => `<Column ss:Width="${column.renderWidth}"/>`).join("")
      ].join("");
      if (opts.isHeader) {
        xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join("")}</Row>`;
      }
      datas.forEach((row) => {
        xml += "<Row>" + columns.map((column) => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join("") + "</Row>";
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, row, column)}</Data></Cell>`).join("")}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = (opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case "csv":
            return toCsv(opts, columns, datas);
          case "txt":
            return toTxt(opts, columns, datas);
          case "html":
            return toHtml(opts, columns, datas);
          case "xml":
            return toXML(opts, columns, datas);
        }
      }
      return "";
    };
    const downloadFile = (opts, content) => {
      const { filename, type, download } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({ type, content, blob });
      }
      if (VxeUI.saveFile) {
        VxeUI.saveFile({ filename, type, content }).then(() => {
          if (opts.message !== false) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n12("vxe.table.expSuccess"), status: "success" });
            }
          }
        });
      }
    };
    const handleExport = (opts) => {
      const { remote, columns, colgroups, exportMethod, afterExportMethod } = opts;
      return new Promise((resolve) => {
        if (remote) {
          const params = { options: opts, $table: $xeTable, $grid: $xeGrid };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xeTable.preventEvent(null, "event.export", { options: opts, columns, colgroups, datas }, () => {
            return downloadFile(opts, getContent(opts, columns, datas));
          }));
        }
      }).then((params) => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: true, options: opts, $table: $xeTable, $grid: $xeGrid });
          }
        }
        return Object.assign({ status: true }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: false, options: opts, $table: $xeTable, $grid: $xeGrid });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const { tableFullColumn, _importResolve, _importReject } = internalData;
      let rest = { fields: [], rows: [] };
      switch (opts.type) {
        case "csv":
          rest = parseCsv(tableFullColumn, content);
          break;
        case "txt":
          rest = parseTxt(tableFullColumn, content);
          break;
        case "html":
          rest = parseHTML(tableFullColumn, content);
          break;
        case "xml":
          rest = parseXML(tableFullColumn, content);
          break;
      }
      const { fields, rows } = rest;
      const status = checkImportData(tableFullColumn, fields);
      if (status) {
        $xeTable.createData(rows).then((data) => {
          let loadRest;
          if (opts.mode === "insert" || opts.mode === "insertBottom") {
            loadRest = $xeTable.insertAt(data, -1);
          }
          if (opts.mode === "insertTop") {
            loadRest = $xeTable.insert(data);
          } else {
            loadRest = $xeTable.reloadData(data);
          }
          if (opts.message !== false) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n12("vxe.table.impSuccess", [rows.length]), status: "success" });
            }
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({ status: true });
            }
          });
        });
      } else if (opts.message !== false) {
        if (VxeUI.modal) {
          VxeUI.modal.message({ content: getI18n12("vxe.error.impFields"), status: "error" });
        }
        if (_importReject) {
          _importReject({ status: false });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const { importMethod, afterImportMethod } = opts;
      const { type, filename } = parseFile(file);
      const importOpts = computeImportOpts.value;
      if (!importMethod && !import_xe_utils32.default.includes(import_xe_utils32.default.keys(importOpts._typeMaps), type)) {
        if (opts.message !== false) {
          if (VxeUI.modal) {
            VxeUI.modal.message({ content: getI18n12("vxe.error.notType", [type]), status: "error" });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = (params) => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = (params) => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({ mode: "insertTop" }, opts, { type, filename });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({ file, options, $table: $xeTable })).then(() => {
                _importResolve({ status: true });
              }).catch(() => {
                _importResolve({ status: true });
              });
            } else {
              _importResolve({ status: true });
            }
          } else {
            const { tableFullColumn } = internalData;
            $xeTable.preventEvent(null, "event.import", { file, options, columns: tableFullColumn }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog("vxe.error.notType", [type]);
                _importReject({ status: false });
              };
              reader.onload = (e16) => {
                handleImport(e16.target.result, options);
              };
              reader.readAsText(file, options.encoding || "UTF-8");
            });
          }
        } else {
          if (true) {
            errLog("vxe.error.notExp");
          }
          _importResolve({ status: true });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({ status: true, options: opts, $table: $xeTable });
        }
      }).catch((e16) => {
        if (afterImportMethod) {
          afterImportMethod({ status: false, options: opts, $table: $xeTable });
        }
        return Promise.reject(e16);
      });
    };
    const handleExportAndPrint = (options, isPrint) => {
      const { treeConfig, showHeader, showFooter } = props;
      const { initStore, mergeList, isGroup, footerTableData, exportStore, exportParams } = reactData;
      const { collectColumn } = internalData;
      const exportOpts = computeExportOpts.value;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      const proxyOpts = $xeGrid ? $xeGrid.getComputeMaps().computeProxyOpts.value : {};
      const hasFooter = !!footerTableData.length;
      const hasMerge = !hasTree && mergeList.length;
      const defOpts = Object.assign({
        message: true,
        isHeader: showHeader,
        isFooter: showFooter,
        current: "current",
        modes: ["current", "selected"].concat(proxyOpts.ajax && proxyOpts.ajax.queryAll ? ["all"] : [])
      }, options);
      const types = defOpts.types || import_xe_utils32.default.keys(exportOpts._typeMaps);
      const modes = defOpts.modes || [];
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const { columns } = defOpts;
      const typeList = types.map((value) => {
        return {
          value,
          label: getI18n12(`vxe.export.types.${value}`)
        };
      });
      const modeList = modes.map((item) => {
        if (item && item.value) {
          return {
            value: item.value,
            label: item.label || item.value
          };
        }
        return {
          value: item,
          label: getI18n12(`vxe.export.modes.${item}`)
        };
      });
      import_xe_utils32.default.eachTree(exportColumns, (column, index2, items, path, parent) => {
        const isColGroup = column.children && column.children.length;
        if (isColGroup || defaultFilterExportColumn(column)) {
          column.checked = columns ? columns.some((item) => {
            if (isColumnInfo(item)) {
              return column === item;
            } else if (import_xe_utils32.default.isString(item)) {
              return column.field === item;
            } else {
              const colid = item.id || item.colId;
              const type = item.type;
              const field = item.property || item.field;
              if (colid) {
                return column.id === colid;
              } else if (field && type) {
                return column.property === field && column.type === type;
              } else if (field) {
                return column.property === field;
              } else if (type) {
                return column.type === type;
              }
            }
            return false;
          }) : column.visible;
          column.halfChecked = false;
          column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({ column }) : false);
        }
      });
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      Object.assign(exportParams, {
        mode: selectRecords.length ? "selected" : "current"
      }, defOpts);
      if (!modeList.some((item) => item.value === exportParams.mode)) {
        exportParams.mode = modeList[0].value;
      }
      if (!typeList.some((item) => item.value === exportParams.type)) {
        exportParams.type = typeList[0].value;
      }
      initStore.export = true;
      return nextTick();
    };
    const handleCloseExport = () => {
      if (VxeUI.modal) {
        return VxeUI.modal.close("VXE_EXPORT_MODAL");
      }
      return Promise.resolve();
    };
    const exportMethods = {
      /**
       *  csv/html/xml/txt
       * 
       *  dataFilterMethod 
       * @param {Object} options 
       */
      exportData(options) {
        const { treeConfig } = props;
        const { isGroup, tableGroupColumn } = reactData;
        const { tableFullColumn, afterFullData } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const opts = Object.assign({
          // filename: '',
          // sheetName: '',
          // original: false,
          // message: false,
          isHeader: true,
          isFooter: true,
          isColgroup: true,
          // isMerge: false,
          // isAllExpand: false,
          download: true,
          type: "csv",
          mode: "current"
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, {
          print: false
        }, options);
        const { type, mode, columns, original, beforeExportMethod } = opts;
        let groups = [];
        const customCols = columns && columns.length ? columns : null;
        let columnFilterMethod = opts.columnFilterMethod;
        if (!customCols && !columnFilterMethod) {
          columnFilterMethod = original ? ({ column }) => column.property : ({ column }) => defaultFilterExportColumn(column);
        }
        if (customCols) {
          opts._isCustomColumn = true;
          groups = import_xe_utils32.default.searchTree(import_xe_utils32.default.mapTree(customCols, (item) => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (import_xe_utils32.default.isString(item)) {
                targetColumn = $xeTable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type2 = item.type;
                const field = item.property || item.field;
                if (colid) {
                  targetColumn = $xeTable.getColumnById(colid);
                } else if (field && type2) {
                  targetColumn = tableFullColumn.find((column) => column.property === field && column.type === type2);
                } else if (field) {
                  targetColumn = $xeTable.getColumnByField(field);
                } else if (type2) {
                  targetColumn = tableFullColumn.find((column) => column.type === type2);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: "childNodes",
            mapChildren: "_children"
          }), (column, index2) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index2 })), {
            children: "_children",
            mapChildren: "childNodes",
            original: true
          });
        } else {
          groups = import_xe_utils32.default.searchTree(isGroup ? tableGroupColumn : tableFullColumn, (column, index2) => column.visible && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index2 })), { children: "children", mapChildren: "childNodes", original: true });
        }
        const cols = [];
        import_xe_utils32.default.eachTree(groups, (column) => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, { children: "childNodes" });
        opts.columns = cols;
        opts.colgroups = convertToRows(groups);
        if (!opts.filename) {
          opts.filename = getI18n12(opts.original ? "vxe.table.expOriginFilename" : "vxe.table.expFilename", [import_xe_utils32.default.toDateString(Date.now(), "yyyyMMddHHmmss")]);
        }
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        if (!opts.exportMethod && !import_xe_utils32.default.includes(import_xe_utils32.default.keys(exportOpts._typeMaps), type)) {
          errLog("vxe.error.notType", [type]);
          if (true) {
            if (["xlsx", "pdf"].includes(type)) {
              warnLog("vxe.error.reqPlugin", [4, "plugin-export-xlsx"]);
            }
          }
          const params = { status: false };
          return Promise.reject(params);
        }
        if (!opts.print) {
          if (beforeExportMethod) {
            beforeExportMethod({ options: opts, $table: $xeTable, $grid: $xeGrid });
          }
        }
        if (!opts.data) {
          opts.data = [];
          if (mode === "selected") {
            const selectRecords = $xeTable.getCheckboxRecords();
            if (["html", "pdf"].indexOf(type) > -1 && treeConfig) {
              opts.data = import_xe_utils32.default.searchTree($xeTable.getTableData().fullData, (item) => $xeTable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, { data: "_row" }));
            } else {
              opts.data = selectRecords;
            }
          } else if (mode === "all") {
            if (true) {
              if (!$xeGrid) {
                warnLog("vxe.error.errProp", ["all", "mode=current,selected"]);
              }
            }
            if ($xeGrid && !opts.remote) {
              const { reactData: gridReactData } = $xeGrid;
              const { computeProxyOpts } = $xeGrid.getComputeMaps();
              const { sortData } = gridReactData;
              const proxyOpts = computeProxyOpts.value;
              const { beforeQueryAll, afterQueryAll, ajax = {}, props: props2 = {} } = proxyOpts;
              const ajaxMethods = ajax.queryAll;
              const queryAllSuccessMethods = ajax.queryAllSuccess;
              const queryAllErrorMethods = ajax.queryAllError;
              if (true) {
                if (!ajaxMethods) {
                  warnLog("vxe.error.notFunc", ["proxy-config.ajax.queryAll"]);
                }
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  sort: sortData.length ? sortData[0] : {},
                  sorts: sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  options: opts
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).then((rest) => {
                  opts.data = (props2.list ? import_xe_utils32.default.get(rest, props2.list) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  if (queryAllSuccessMethods) {
                    queryAllSuccessMethods(Object.assign(Object.assign({}, params), { response: rest }));
                  }
                  return handleExport(opts);
                }).catch((rest) => {
                  if (queryAllErrorMethods) {
                    queryAllErrorMethods(Object.assign(Object.assign({}, params), { response: rest }));
                  }
                });
              }
            }
          } else if (mode === "current") {
            opts.data = afterFullData;
          }
        }
        return handleExport(opts);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const { beforeImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xeTable });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: import_xe_utils32.default.keys(importOpts._typeMaps)
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const { beforeImportMethod, afterImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xeTable });
        }
        return VxeUI.readFile(opts).catch((e16) => {
          if (afterImportMethod) {
            afterImportMethod({ status: false, options: opts, $table: $xeTable });
          }
          return Promise.reject(e16);
        }).then((params) => {
          const { file } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return VxeUI.saveFile(options);
      },
      readFile(options) {
        return VxeUI.readFile(options);
      },
      print(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        const beforePrintMethod = opts.beforePrintMethod;
        const tableHtml = opts.html || opts.content;
        return new Promise((resolve, reject) => {
          if (VxeUI.print) {
            if (tableHtml) {
              resolve(VxeUI.print({
                title: opts.sheetName,
                html: tableHtml,
                customStyle: opts.style,
                beforeMethod: beforePrintMethod ? ({ html }) => {
                  return beforePrintMethod({
                    html,
                    content: html,
                    options: opts,
                    $table: $xeTable
                  });
                } : void 0
              }));
            } else {
              resolve(exportMethods.exportData(opts).then(({ content }) => {
                return VxeUI.print({
                  title: opts.sheetName,
                  html: content,
                  customStyle: opts.style,
                  beforeMethod: beforePrintMethod ? ({ html }) => {
                    return beforePrintMethod({
                      html,
                      content: html,
                      options: opts,
                      $table: $xeTable
                    });
                  } : void 0
                });
              }));
            }
          } else {
            const e16 = { status: false };
            reject(e16);
          }
        });
      },
      getPrintHtml(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        return exportMethods.exportData(opts).then(({ content }) => {
          return {
            html: content
          };
        });
      },
      closeImport() {
        if (VxeUI.modal) {
          return VxeUI.modal.close("VXE_IMPORT_MODAL");
        }
        return Promise.resolve();
      },
      openImport(options) {
        const { treeConfig, importConfig } = props;
        const { initStore, importStore, importParams } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({
          mode: "insertTop",
          message: true,
          types: import_xe_utils32.default.keys(importOpts._typeMaps),
          modes: ["insertTop", "covering"]
        }, importOpts, options);
        const types = defOpts.types || [];
        const modes = defOpts.modes || [];
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n12("vxe.error.treeNotImp"), status: "error" });
            }
          }
          return;
        }
        if (!importConfig) {
          errLog("vxe.error.reqProp", ["import-config"]);
        }
        const typeList = types.map((value) => {
          return {
            value,
            label: getI18n12(`vxe.export.types.${value}`)
          };
        });
        const modeList = modes.map((item) => {
          if (item && item.value) {
            return {
              value: item.value,
              label: item.label || item.value
            };
          }
          return {
            value: item,
            label: getI18n12(`vxe.import.modes.${item}`)
          };
        });
        Object.assign(importStore, {
          file: null,
          type: "",
          filename: "",
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        if (!modeList.some((item) => item.value === importParams.mode)) {
          importParams.mode = modeList[0].value;
        }
        initStore.import = true;
      },
      closeExport: handleCloseExport,
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        const defOpts = Object.assign({
          message: true,
          types: import_xe_utils32.default.keys(exportOpts._typeMaps)
        }, exportOpts, options);
        if (true) {
          if (!props.exportConfig) {
            errLog("vxe.error.reqProp", ["export-config"]);
          }
        }
        handleExportAndPrint(defOpts);
      },
      closePrint: handleCloseExport,
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        const defOpts = Object.assign({
          message: true
        }, printOpts, options);
        if (true) {
          if (!props.printConfig) {
            errLog("vxe.error.reqProp", ["print-config"]);
          }
        }
        handleExportAndPrint(defOpts, true);
      }
    };
    return exportMethods;
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableExportMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/keyboard/hook.js
var import_xe_utils33 = __toESM(require_xe_utils());
var { hooks: hooks8 } = VxeUI;
function getTargetOffset(target, container) {
  let offsetTop = 0;
  let offsetLeft = 0;
  const triggerCheckboxLabel = !browse2.firefox && hasClass(target, "vxe-checkbox--label");
  if (triggerCheckboxLabel) {
    const checkboxLabelStyle = getComputedStyle(target);
    offsetTop -= import_xe_utils33.default.toNumber(checkboxLabelStyle.paddingTop);
    offsetLeft -= import_xe_utils33.default.toNumber(checkboxLabelStyle.paddingLeft);
  }
  while (target && target !== container) {
    offsetTop += target.offsetTop;
    offsetLeft += target.offsetLeft;
    target = target.offsetParent;
    if (triggerCheckboxLabel) {
      const checkboxStyle = getComputedStyle(target);
      offsetTop -= import_xe_utils33.default.toNumber(checkboxStyle.paddingTop);
      offsetLeft -= import_xe_utils33.default.toNumber(checkboxStyle.paddingLeft);
    }
  }
  return { offsetTop, offsetLeft };
}
hooks8.add("tableKeyboardModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem } = $xeTable.getRefMaps();
    const { computeEditOpts, computeCheckboxOpts, computeMouseOpts, computeTreeOpts } = $xeTable.getComputeMaps();
    function getCheckboxRangeRows(evnt, params, targetTrElem, trRect, offsetClientTop, moveRange) {
      let countHeight = 0;
      let rangeRows = [];
      let moveSize = 0;
      const isDown = moveRange > 0;
      const { scrollYLoad } = reactData;
      const { afterFullData, scrollYStore } = internalData;
      if (scrollYLoad) {
        if (isDown) {
          moveSize = offsetClientTop + moveRange;
        } else {
          moveSize = trRect.height - offsetClientTop + Math.abs(moveRange);
        }
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        if (isDown) {
          rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / scrollYStore.rowHeight));
        } else {
          rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / scrollYStore.rowHeight), _rowIndex + 1);
        }
      } else {
        if (isDown) {
          moveSize = evnt.clientY - trRect.y;
        } else {
          moveSize = trRect.y - evnt.clientY + trRect.height;
        }
        const siblingProp = isDown ? "next" : "previous";
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xeTable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const { column, cell } = params;
      if (column.type === "checkbox") {
        const el2 = refElem.value;
        const { elemStore } = internalData;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const bodyWrapperElem = getRefElem(elemStore[`${column.fixed || "main"}-body-wrapper`] || elemStore["main-body-wrapper"]);
        if (!bodyWrapperElem) {
          return;
        }
        const checkboxRangeElem = bodyWrapperElem.querySelector(".vxe-table--checkbox-range");
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const trElem = cell.parentElement;
        const selectRecords = $xeTable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const offsetRest = getTargetOffset(evnt.target, bodyWrapperElem);
        const startTop = offsetRest.offsetTop + evnt.offsetY;
        const startLeft = offsetRest.offsetLeft + evnt.offsetX;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        const trRect = trElem.getBoundingClientRect();
        const offsetClientTop = disY - trRect.y;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent3 = (type, evnt2) => {
          $xeTable.dispatchEvent(`checkbox-range-${type}`, { records: $xeTable.getCheckboxRecords(), reserves: $xeTable.getCheckboxReserveRecords() }, evnt2);
        };
        const handleChecked = (evnt2) => {
          const { clientX, clientY } = evnt2;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = "block";
          const rangeRows = getCheckboxRangeRows(evnt2, params, trElem, trRect, offsetClientTop, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            lastRangeRows = rangeRows;
            if (evnt2.ctrlKey) {
              rangeRows.forEach((row) => {
                $xeTable.handleBatchSelectRows([row], selectRecords.indexOf(row) === -1);
              });
            } else {
              $xeTable.setAllCheckboxRow(false);
              $xeTable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent3("change", evnt2);
          }
        };
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        const startMouseScroll = (evnt2) => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const { scrollLeft, scrollTop, clientHeight, scrollHeight } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xeTable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xeTable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el2, "drag--range");
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          evnt2.stopPropagation();
          const { clientY } = evnt2;
          const { boundingTop } = getAbsolutePos(bodyWrapperElem);
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt2);
        };
        document.onmouseup = (evnt2) => {
          stopMouseScroll();
          removeClass(el2, "drag--range");
          checkboxRangeElem.removeAttribute("style");
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          triggerEvent3("end", evnt2);
        };
        triggerEvent3("start", evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const { editConfig, checkboxConfig, mouseConfig } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xeTable.handleMousedownCellAreaEvent) {
        return $xeTable.handleMousedownCellAreaEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === "cell") {
            $xeTable.handleSelected(params, evnt);
          }
        }
      }
    };
    const keyboardMethods = {
      //  Tab 
      moveTabSelected(args, isLeft, evnt) {
        const { editConfig } = props;
        const { afterFullData, visibleColumn } = internalData;
        const editOpts = computeEditOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        const _columnIndex = $xeTable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          if (_columnIndex <= 0) {
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xeTable.getCellElement(params.row, params.column);
          if (editConfig) {
            if (editOpts.trigger === "click" || editOpts.trigger === "dblclick") {
              if (editOpts.mode === "row") {
                $xeTable.handleEdit(params, evnt);
              } else {
                $xeTable.scrollToRow(params.row, params.column).then(() => $xeTable.handleSelected(params, evnt));
              }
            }
          } else {
            $xeTable.scrollToRow(params.row, params.column).then(() => $xeTable.handleSelected(params, evnt));
          }
        }
      },
      // 
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const { treeConfig } = props;
        const { currentRow } = reactData;
        const { afterFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        evnt.preventDefault();
        if (currentRow) {
          if (treeConfig) {
            const { index: index2, items } = import_xe_utils33.default.findTree(afterFullData, (item) => item === currentRow, { children: childrenField });
            if (isUpArrow && index2 > 0) {
              targetRow = items[index2 - 1];
            } else if (isDwArrow && index2 < items.length - 1) {
              targetRow = items[index2 + 1];
            }
          } else {
            const _rowIndex = $xeTable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          const params = {
            $table: $xeTable,
            row: targetRow,
            rowIndex: $xeTable.getRowIndex(targetRow),
            $rowIndex: $xeTable.getVMRowIndex(targetRow)
          };
          $xeTable.scrollToRow(targetRow).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const { afterFullData, visibleColumn } = internalData;
        const params = Object.assign({}, args);
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        const _columnIndex = $xeTable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isUpArrow && _rowIndex > 0) {
          params.rowIndex = _rowIndex - 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
          params.rowIndex = _rowIndex + 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isLeftArrow && _columnIndex) {
          params.columnIndex = _columnIndex - 1;
          params.column = visibleColumn[params.columnIndex];
        } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
          params.columnIndex = _columnIndex + 1;
          params.column = visibleColumn[params.columnIndex];
        }
        $xeTable.scrollToRow(params.row, params.column).then(() => {
          params.cell = $xeTable.getCellElement(params.row, params.column);
          $xeTable.handleSelected(params, evnt);
        });
      },
      handleCellMousedownEvent
    };
    return keyboardMethods;
  }
});

// node_modules/vxe-table/es/table/module/validator/hook.js
var import_xe_utils34 = __toESM(require_xe_utils());
var { getConfig: getConfig6, validators: validators3, hooks: hooks9 } = VxeUI;
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 
   * 
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var tableValidatorMethodKeys = ["fullValidate", "validate", "fullValidateField", "validateField", "clearValidate"];
hooks9.add("tableValidatorModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refValidTooltip } = $xeTable.getRefMaps();
    const { computeValidOpts, computeTreeOpts, computeEditOpts } = $xeTable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    const handleValidError = (params) => {
      return new Promise((resolve) => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xeTable.dispatchEvent("valid-error", params, null);
          resolve();
        } else {
          $xeTable.handleEdit(params, { type: "valid-error", trigger: "call" }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = (validErrMaps) => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === "single") {
        const keys = Object.keys(validErrMaps);
        const resMaps = {};
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    const beginValidate = (rows, cols, cb2, isFull) => {
      const validRest = {};
      const { editRules, treeConfig } = props;
      const { afterFullData, visibleColumn } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (import_xe_utils34.default.isFunction(rows)) {
          cb2 = rows;
        } else {
          validList = import_xe_utils34.default.isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xeTable.getInsertRecords) {
          validList = $xeTable.getInsertRecords().concat($xeTable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false;
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = cols && cols.length ? cols : $xeTable.getColumns();
        const handleVaild = (row) => {
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach((column) => {
              const field = import_xe_utils34.default.isString(column) ? column : column.field;
              if ((isFull || !validRuleErr) && import_xe_utils34.default.has(editRules, field)) {
                colVailds.push(validatorPrivateMethods.validCellRules("all", row, column).catch(({ rule, rules }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xeTable.getRowIndex(row),
                    row,
                    columnIndex: $xeTable.getColumnIndex(column),
                    column,
                    field,
                    $table: $xeTable
                  };
                  if (!validRest[field]) {
                    validRest[field] = [];
                  }
                  validErrMaps[`${getRowid($xeTable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[field].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (treeConfig) {
          import_xe_utils34.default.eachTree(validList, handleVaild, { children: childrenField });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return nextTick().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb2) {
              cb2();
            }
          });
        }).catch((firstErrParams) => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              nextTick(() => {
                if (cb2) {
                  cb2(validRest);
                  resolve();
                } else {
                  if (getConfig6().validToReject === "obsolete") {
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xeTable.getCellElement(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              const rowIndex = afterFullData.indexOf(row);
              const columnIndex = visibleColumn.indexOf(column);
              const targetRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;
              const targetColumn = columnIndex > 0 ? visibleColumn[columnIndex - 1] : column;
              $xeTable.scrollToRow(targetRow, targetColumn).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return nextTick().then(() => {
        if (cb2) {
          cb2();
        }
      });
    };
    validatorMethods = {
      /**
       *  validate 
       */
      fullValidate(rows, cb2) {
        if (true) {
          if (import_xe_utils34.default.isFunction(cb2)) {
            warnLog("vxe.error.notValidators", ["fullValidate(rows, callback)", "fullValidate(rows)"]);
          }
        }
        return beginValidate(rows, null, cb2, true);
      },
      /**
       * 
       */
      validate(rows, cb2) {
        return beginValidate(rows, null, cb2);
      },
      /**
       *  validateField 
       */
      fullValidateField(rows, fieldOrColumn) {
        const colList = (import_xe_utils34.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null, true);
        }
        return nextTick();
      },
      /**
       * 
       */
      validateField(rows, fieldOrColumn) {
        const colList = (import_xe_utils34.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null);
        }
        return nextTick();
      },
      clearValidate(rows, fieldOrColumn) {
        const { validErrorMaps } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = import_xe_utils34.default.isArray(rows) ? rows : rows ? [rows] : [];
        const colList = (import_xe_utils34.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
          return nextTick();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach((row) => {
            colList.forEach((column) => {
              const validKey = `${getRowid($xeTable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map((row) => `${getRowid($xeTable, row)}`);
          import_xe_utils34.default.each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(":")[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map((column) => `${column.id}`);
          import_xe_utils34.default.each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(":")[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return nextTick();
      }
    };
    const validErrorRuleValue2 = (rule, val) => {
      const { type, min, max, pattern } = rule;
      const isNumType = type === "number";
      const numVal = isNumType ? import_xe_utils34.default.toNumber(val) : import_xe_utils34.default.getSize(val);
      if (isNumType && isNaN(val)) {
        return true;
      }
      if (!import_xe_utils34.default.eqNull(min) && numVal < import_xe_utils34.default.toNumber(min)) {
        return true;
      }
      if (!import_xe_utils34.default.eqNull(max) && numVal > import_xe_utils34.default.toNumber(max)) {
        return true;
      }
      if (pattern && !(import_xe_utils34.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
        return true;
      }
      return false;
    };
    validatorPrivateMethods = {
      /**
       * 
       * 
       * 
       * Promise<>
       * 
       *
       * rule 
       *  required=Boolean 
       *  min=Number 
       *  max=Number 
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex })  Promise
       *  trigger=blur|change 
       */
      validCellRules(validType, row, column, val) {
        const { editRules } = props;
        const { field } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = import_xe_utils34.default.get(editRules, field);
          if (rules) {
            const cellValue = import_xe_utils34.default.isUndefined(val) ? import_xe_utils34.default.get(row, field) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xeTable.getRowIndex(row),
                    column,
                    columnIndex: $xeTable.getColumnIndex(column),
                    field: column.field,
                    $table: $xeTable,
                    $grid: $xeTable.xegrid
                  };
                  let customValid;
                  if (import_xe_utils34.default.isString(validator)) {
                    const gvItem = validators3.get(validator);
                    if (gvItem) {
                      const tcvMethod = gvItem.tableCellValidatorMethod || gvItem.cellValidatorMethod;
                      if (tcvMethod) {
                        customValid = tcvMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils34.default.isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncValidList.push(customValid.catch((e16) => {
                        validRuleErr = true;
                        errorRules.push(new Rule({ type: "custom", trigger, content: e16 && e16.message ? e16.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils34.default.isArray(cellValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !cellValue.length;
                  } else if (import_xe_utils34.default.isString(cellValue)) {
                    hasEmpty = eqEmptyValue(cellValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(cellValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue2(rule, cellValue) : !hasEmpty && validErrorRuleValue2(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = { rules: errorRules, rule: errorRules[0] };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const { editRules } = props;
        const { field } = column;
        if (field && editRules) {
          const rules = import_xe_utils34.default.get(editRules, field);
          return rules && !!import_xe_utils34.default.find(rules, (rule) => type === "all" || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 
       */
      triggerValidate(type) {
        const { editConfig, editRules } = props;
        const { editStore } = reactData;
        const { actived } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        if (editRules && validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
        }
        if (editConfig && editRules && actived.row) {
          const { row, column, cell } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === "row") {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({ rule }) => {
              if (!rule.trigger || type === rule.trigger) {
                const rest = { rule, row, column, cell };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 
       */
      showValidTooltip(params) {
        const { height } = props;
        const { tableData, validStore, validErrorMaps } = reactData;
        const { rule, row, column, cell } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xeTable.dispatchEvent("valid-error", params, null);
        if (validTip) {
          if (validTip && (validOpts.message === "tooltip" || validOpts.message === "default" && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, validatorMethods), validatorPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableValidatorMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/custom/hook.js
var import_xe_utils35 = __toESM(require_xe_utils());
var tableCustomMethodKeys = ["openCustom", "closeCustom", "saveCustom", "cancelCustom", "resetCustom", "toggleCustomAllCheckbox", "setCustomAllCheckbox"];
VxeUI.hooks.add("tableCustomModule", {
  setupTable($xeTable) {
    const { reactData, internalData } = $xeTable;
    const { computeCustomOpts } = $xeTable.getComputeMaps();
    const { refElem } = $xeTable.getRefMaps();
    const $xeGrid = $xeTable.xegrid;
    const calcMaxHeight = () => {
      const { customStore } = reactData;
      const el2 = refElem.value;
      let tableHeight = 0;
      if (el2) {
        tableHeight = el2.clientHeight - 28;
      }
      customStore.maxHeight = Math.max(88, tableHeight);
    };
    const openCustom = () => {
      const { initStore, customStore } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      handleUpdateCustomColumn();
      checkCustomStatus();
      calcMaxHeight();
      return nextTick().then(() => calcMaxHeight());
    };
    const handleUpdateCustomColumn = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      if (customStore.visible) {
        const sortMaps = {};
        const fixedMaps = {};
        const visibleMaps = {};
        import_xe_utils35.default.eachTree(collectColumn, (column) => {
          const colid = column.getKey();
          column.renderFixed = column.fixed;
          column.renderVisible = column.visible;
          column.renderResizeWidth = column.renderWidth;
          sortMaps[colid] = column.renderSortNumber;
          fixedMaps[colid] = column.fixed;
          visibleMaps[colid] = column.visible;
        });
        customStore.oldSortMaps = sortMaps;
        customStore.oldFixedMaps = fixedMaps;
        customStore.oldVisibleMaps = visibleMaps;
        reactData.customColumnList = collectColumn.slice(0);
      }
    };
    const closeCustom = () => {
      const { customStore } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xeTable.handleCustom();
        }
      }
      return nextTick();
    };
    const saveCustom = () => {
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { allowVisible, allowSort, allowFixed, allowResizable } = customOpts;
      import_xe_utils35.default.eachTree(customColumnList, (column, index2, items, path, parent) => {
        if (parent) {
          column.fixed = parent.fixed;
        } else {
          if (allowSort) {
            const sortIndex = index2 + 1;
            column.renderSortNumber = sortIndex;
          }
          if (allowFixed) {
            column.fixed = column.renderFixed;
          }
        }
        if (allowResizable) {
          if (column.renderVisible && (!column.children || column.children.length)) {
            if (column.renderResizeWidth !== column.renderWidth) {
              column.resizeWidth = column.renderResizeWidth;
              column.renderWidth = column.renderResizeWidth;
            }
          }
        }
        if (allowVisible) {
          column.visible = column.renderVisible;
        }
      });
      reactData.isCustomStatus = true;
      reactData.isDragColMove = true;
      setTimeout(() => {
        reactData.isDragColMove = false;
      }, 1e3);
      return $xeTable.saveCustomStore("confirm");
    };
    const cancelCustom = () => {
      const { customColumnList, customStore } = reactData;
      const { oldSortMaps, oldFixedMaps, oldVisibleMaps } = customStore;
      const customOpts = computeCustomOpts.value;
      const { allowVisible, allowSort, allowFixed, allowResizable } = customOpts;
      import_xe_utils35.default.eachTree(customColumnList, (column) => {
        const colid = column.getKey();
        const visible = !!oldVisibleMaps[colid];
        const fixed = oldFixedMaps[colid] || "";
        if (allowVisible) {
          column.renderVisible = visible;
          column.visible = visible;
        }
        if (allowFixed) {
          column.renderFixed = fixed;
          column.fixed = fixed;
        }
        if (allowSort) {
          column.renderSortNumber = oldSortMaps[colid] || 0;
        }
        if (allowResizable) {
          column.renderResizeWidth = column.renderWidth;
        }
      }, { children: "children" });
      return nextTick();
    };
    const setCustomAllCheckbox = (checked) => {
      const { customStore } = reactData;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod, visibleMethod } = customOpts;
      const isAll = !!checked;
      if (customOpts.immediate) {
        import_xe_utils35.default.eachTree(customColumnList, (column) => {
          if (visibleMethod && !visibleMethod({ column })) {
            return;
          }
          if (checkMethod && !checkMethod({ column })) {
            return;
          }
          column.visible = isAll;
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils35.default.eachTree(customColumnList, (column) => {
          if (visibleMethod && !visibleMethod({ column })) {
            return;
          }
          if (checkMethod && !checkMethod({ column })) {
            return;
          }
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
      }
      $xeTable.checkCustomStatus();
      return nextTick();
    };
    const customMethods = {
      openCustom,
      closeCustom,
      saveCustom,
      cancelCustom,
      resetCustom(options) {
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { checkMethod } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true
        }, options);
        import_xe_utils35.default.eachTree(collectColumn, (column) => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
          }
          if (!checkMethod || checkMethod({ column })) {
            column.visible = column.defaultVisible;
          }
          column.renderResizeWidth = column.renderWidth;
        });
        reactData.isCustomStatus = false;
        $xeTable.saveCustomStore("reset");
        return $xeTable.handleCustom();
      },
      toggleCustomAllCheckbox() {
        const { customStore } = reactData;
        const isAll = !customStore.isAll;
        return setCustomAllCheckbox(isAll);
      },
      setCustomAllCheckbox
    };
    const checkCustomStatus = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod } = customOpts;
      customStore.isAll = collectColumn.every((column) => (checkMethod ? !checkMethod({ column }) : false) || column.renderVisible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some((column) => (!checkMethod || checkMethod({ column })) && (column.renderVisible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      const comp = $xeGrid || $xeTable;
      comp.dispatchEvent("custom", { type }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const { customStore } = $xeTable.reactData;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent("close", evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent("open", evnt);
        }
      },
      customOpenEvent(evnt) {
        const { customStore } = reactData;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xeTable.openCustom();
          $xeTable.emitCustomEvent("open", evnt);
        }
      },
      customCloseEvent(evnt) {
        const { customStore } = reactData;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xeTable.closeCustom();
          $xeTable.emitCustomEvent("close", evnt);
        }
      },
      handleUpdateCustomColumn
    };
    return Object.assign(Object.assign({}, customMethods), customPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableCustomMethodKeys);
  }
});

// node_modules/vxe-table/es/table/render/index.js
var import_xe_utils36 = __toESM(require_xe_utils());
var { getConfig: getConfig7, renderer: renderer12, getI18n: getI18n13 } = VxeUI;
var componentDefaultModelProp = "modelValue";
var defaultCompProps = {};
function parseDate(value, props) {
  return value && props.valueFormat ? import_xe_utils36.default.toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const { dateConfig = {} } = props;
  return import_xe_utils36.default.toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, getI18n13(`vxe.input.date.labelFormat.${props.type || "date"}`));
}
function getOldComponentName(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent({ name }) {
  return resolveComponent(name);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function handleConfirmFilter(params, checked, option2) {
  const { $panel } = params;
  $panel.changeOption({}, checked, option2);
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const { name, immediate, props } = renderOpts;
  if (!immediate) {
    if (name === "VxeInput" || name === "$input") {
      const { type } = props || {};
      return !(!type || type === "text" || type === "number" || type === "integer" || type === "float");
    }
    if (name === "input" || name === "textarea" || name === "$textarea") {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils36.default.assign({ immediate: getInputImmediateModel(renderOpts) }, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils36.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === "cell" || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel) {
  const { placeholder } = renderOpts;
  return [
    h("span", {
      class: "vxe-cell--label"
    }, placeholder && isEmptyValue(cellLabel) ? [
      h("span", {
        class: "vxe-cell--placeholder"
      }, formatText(getFuncText(placeholder), 1))
    ] : formatText(cellLabel, 1))
  ];
}
function getNativeElementOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils36.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const ons = {};
  import_xe_utils36.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (true) {
        if (!import_xe_utils36.default.isFunction(func)) {
          errLog("vxe.error.errFunc", [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { name } = renderOpts;
  const { model } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, (cellValue) => {
    model.update = true;
    model.value = cellValue;
    if (isImmediate) {
      setCellValue(row, column, cellValue);
    }
  }, (eventParams) => {
    if (!isImmediate && ["VxeInput", "VxeNumberInput", "VxeTextarea", "$input", "$textarea"].includes(name)) {
      const cellValue = eventParams.value;
      model.update = true;
      model.value = cellValue;
      $table.updateStatus(params, cellValue);
    } else {
      $table.updateStatus(params);
    }
  });
}
function getFilterOns(renderOpts, params, option2) {
  return getComponentOns(renderOpts, params, (value) => {
    option2.data = value;
  }, () => {
    handleConfirmFilter(params, !import_xe_utils36.default.eqNull(option2.data), option2);
  });
}
function getNativeEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { model } = column;
  return getNativeElementOns(renderOpts, params, (evnt) => {
    const cellValue = evnt.target.value;
    if (isImmediateCell(renderOpts, params)) {
      setCellValue(row, column, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, (evnt) => {
    const cellValue = evnt.target.value;
    $table.updateStatus(params, cellValue);
  });
}
function getNativeFilterOns(renderOpts, params, option2) {
  return getNativeElementOns(renderOpts, params, (evnt) => {
    option2.data = evnt.target.value;
  }, () => {
    handleConfirmFilter(params, !import_xe_utils36.default.eqNull(option2.data), option2);
  });
}
function nativeEditRender(renderOpts, params) {
  const { row, column } = params;
  const { name } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, getNativeAttrs(renderOpts)), { value: cellValue }), getNativeEditOns(renderOpts, params)))
  ];
}
function buttonCellRender(renderOpts, params) {
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function defaultEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function radioAndCheckboxEditRender(renderOpts, params) {
  const { options } = renderOpts;
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldButtonEditRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsEditRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonEditRender(childRenderOpts, params)[0]);
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function renderNativeOptions(options, renderOpts, params) {
  const { optionProps = {} } = renderOpts;
  const { row, column } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return options.map((option2, oIndex) => {
    return h("option", {
      key: oIndex,
      value: option2[valueProp],
      disabled: option2[disabledProp],
      /* eslint-disable eqeqeq */
      selected: option2[valueProp] == cellValue
    }, option2[labelProp]);
  });
}
function nativeFilterRender(renderOpts, params) {
  const { column } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option2, oIndex) => {
    return h(name, Object.assign(Object.assign(Object.assign({ key: oIndex, class: `vxe-default-${name}` }, attrs), { value: option2.data }), getNativeFilterOns(renderOpts, params, option2)));
  });
}
function defaultFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option2, oIndex) => {
    const optionValue = option2.data;
    return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option2)));
  });
}
function oldFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option2, oIndex) => {
    const optionValue = option2.data;
    return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option2)));
  });
}
function handleFilterMethod({ option: option2, row, column }) {
  const { data } = option2;
  const cellValue = import_xe_utils36.default.get(row, column.field);
  return cellValue == data;
}
function handleInputFilterMethod({ option: option2, row, column }) {
  const { data } = option2;
  const cellValue = import_xe_utils36.default.get(row, column.field);
  return import_xe_utils36.default.toValueString(cellValue).indexOf(data) > -1;
}
function nativeSelectEditRender(renderOpts, params) {
  return [
    h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeEditOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))
  ];
}
function defaultSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function defaultTreeSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps })), getEditOns(renderOpts, params)))
  ];
}
function oldSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function getSelectCellValue(renderOpts, { row, column }) {
  const { options, optionGroups, optionProps = {}, optionGroupProps = {} } = renderOpts;
  const cellValue = import_xe_utils36.default.get(row, column.field);
  let selectItem;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  if (!(cellValue === null || cellValue === void 0)) {
    return import_xe_utils36.default.map(import_xe_utils36.default.isArray(cellValue) ? cellValue : [cellValue], optionGroups ? (value) => {
      const groupOptions = optionGroupProps.options || "options";
      for (let index2 = 0; index2 < optionGroups.length; index2++) {
        selectItem = import_xe_utils36.default.find(optionGroups[index2][groupOptions], (item) => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : (value) => {
      selectItem = import_xe_utils36.default.find(options, (item) => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(", ");
  }
  return "";
}
function handleExportSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function getTreeSelectCellValue(renderOpts, { row, column }) {
  const { options, optionProps = {} } = renderOpts;
  const cellValue = import_xe_utils36.default.get(row, column.field);
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const childrenProp = optionProps.children || "children";
  if (!(cellValue === null || cellValue === void 0)) {
    const keyMaps = {};
    import_xe_utils36.default.eachTree(options, (item) => {
      keyMaps[import_xe_utils36.default.get(item, valueProp)] = item;
    }, { children: childrenProp });
    return import_xe_utils36.default.map(import_xe_utils36.default.isArray(cellValue) ? cellValue : [cellValue], (value) => {
      const item = keyMaps[value];
      return item ? import_xe_utils36.default.get(item, labelProp) : item;
    }).join(", ");
  }
  return "";
}
function handleExportTreeSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getTreeSelectCellValue(column.editRender || column.cellRender, params);
}
renderer12.mixin({
  input: {
    tableAutoFocus: "input",
    renderTableEdit: nativeEditRender,
    renderTableDefault: nativeEditRender,
    renderTableFilter: nativeFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  textarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: nativeEditRender
  },
  select: {
    renderTableEdit: nativeSelectEditRender,
    renderTableDefault: nativeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      return column.filters.map((option2, oIndex) => {
        return h("select", Object.assign(Object.assign({ key: oIndex, class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeFilterOns(renderOpts, params, option2)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeInput: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      var _a2;
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || ((_a2 = getConfig7().input) === null || _a2 === void 0 ? void 0 : _a2.digits) || 2;
      let cellValue = import_xe_utils36.default.get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "quarter":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils36.default.toFixed(import_xe_utils36.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  VxeNumberInput: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const { type } = props;
      let cellValue = import_xe_utils36.default.get(row, column.field);
      if (cellValue) {
        if (type === "float") {
          const digits = props.digits || getConfig7().numberInput.digits || 1;
          cellValue = import_xe_utils36.default.toFixed(import_xe_utils36.default.floor(cellValue, digits), digits);
        } else if (type === "amount") {
          const digits = props.digits || getConfig7().numberInput.digits || 2;
          cellValue = import_xe_utils36.default.commafy(import_xe_utils36.default.toNumber(cellValue), { digits });
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableFooter(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column, _columnIndex } = params;
      const { type } = props;
      const cellValue = import_xe_utils36.default.isArray(row) ? row[_columnIndex] : import_xe_utils36.default.get(row, column.field);
      if (import_xe_utils36.default.isNumber(cellValue)) {
        if (type === "float") {
          const digits = props.digits || getConfig7().numberInput.digits || 1;
          return import_xe_utils36.default.toFixed(import_xe_utils36.default.floor(cellValue, digits), digits);
        } else if (type === "amount") {
          const digits = props.digits || getConfig7().numberInput.digits || 2;
          return import_xe_utils36.default.commafy(import_xe_utils36.default.toNumber(cellValue), { digits });
        }
      }
      return getFuncText(cellValue, 1);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  VxeDatePicker: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      let cellValue = import_xe_utils36.default.get(row, column.field);
      if (cellValue) {
        cellValue = getLabelFormatDate(cellValue, props);
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleFilterMethod
  },
  VxeTextarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils36.default.get(row, column.field);
      return getCellLabelVNs(renderOpts, params, cellValue);
    }
  },
  VxeButton: {
    renderTableDefault: buttonCellRender
  },
  VxeButtonGroup: {
    renderTableDefault(renderOpts, params) {
      const { options } = renderOpts;
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultSelectEditRender,
    renderTableDefault: defaultSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option2, oIndex) => {
        const optionValue = option2.data;
        return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option2)));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeTreeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeTableSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeIconPicker: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils36.default.get(row, column.field);
      return h("i", {
        class: cellValue
      });
    }
  },
  VxeRadioGroup: {
    renderTableDefault: radioAndCheckboxEditRender
  },
  VxeCheckboxGroup: {
    renderTableDefault: radioAndCheckboxEditRender
  },
  VxeSwitch: {
    tableAutoFocus: "button",
    renderTableEdit: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeUpload: {
    renderTableEdit: defaultEditRender,
    renderTableCell: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeImage: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeTextEllipsis: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { content: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeRate: {
    renderTableDefault: defaultEditRender
  },
  VxeSlider: {
    renderTableDefault: defaultEditRender
  },
  // 
  $input: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: oldEditRender,
    renderTableCell(renderOpts, params) {
      var _a2;
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || ((_a2 = getConfig7().input) === null || _a2 === void 0 ? void 0 : _a2.digits) || 2;
      let cellValue = import_xe_utils36.default.get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils36.default.toFixed(import_xe_utils36.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: oldEditRender,
    renderTableFilter: oldFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  $textarea: {
    tableAutoFocus: ".vxe-textarea--inner"
  },
  $button: {
    renderTableDefault: oldButtonEditRender
  },
  $buttons: {
    renderTableDefault: oldButtonsEditRender
  },
  $select: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: oldSelectEditRender,
    renderTableDefault: oldSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option2, oIndex) => {
        const optionValue = option2.data;
        return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option2)));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  $radio: {
    tableAutoFocus: ".vxe-radio--input"
  },
  $checkbox: {
    tableAutoFocus: ".vxe-checkbox--input"
  },
  $switch: {
    tableAutoFocus: ".vxe-switch--button",
    renderTableEdit: oldEditRender,
    renderTableDefault: oldEditRender
  }
  // 
});

// node_modules/vxe-table/es/table/index.js
var VxeTable = Object.assign({}, table_default, {
  install(app) {
    app.component(table_default.name, table_default);
  }
});
var tableHandle = {
  useCellView
};
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(table_default.name, table_default);
}
VxeUI.component(table_default);
VxeUI.tableHandle = tableHandle;
var Table = VxeTable;
var table_default2 = VxeTable;

// node_modules/vxe-table/es/toolbar/src/toolbar.js
var import_xe_utils37 = __toESM(require_xe_utils());
var { getConfig: getConfig8, getIcon: getIcon10, getI18n: getI18n14, renderer: renderer13, commands: commands3, createEvent: createEvent3, useFns: useFns3 } = VxeUI;
var toolbar_default = defineComponent({
  name: "VxeToolbar",
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: {
      type: Array,
      default: () => getConfig8().toolbar.buttons
    },
    tools: {
      type: Array,
      default: () => getConfig8().toolbar.tools
    },
    perfect: {
      type: Boolean,
      default: () => getConfig8().toolbar.perfect
    },
    size: {
      type: String,
      default: () => getConfig8().toolbar.size || getConfig8().size
    },
    className: [String, Function]
  },
  emits: [
    "button-click",
    "tool-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils37.default.uniqueId();
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const { computeSize } = useFns3.useSize(props);
    const reactData = reactive({
      isRefresh: false,
      connectFlag: 0,
      columns: []
    });
    const internalData = {
      connectTable: null
    };
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeToolbar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let toolbarMethods = {};
    const $xeGrid = inject("$xeGrid", null);
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.refresh, true), props.refresh);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.import, true), props.import);
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.export, true), props.export);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.print, true), props.print);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.zoom, true), props.zoom);
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.custom, true), props.custom);
    });
    const computeTableCustomOpts = computed(() => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if (reactData.connectFlag || $table) {
        if ($table) {
          const { computeCustomOpts: computeCustomOpts2 } = $table.getComputeMaps();
          return computeCustomOpts2.value;
        }
      }
      return { trigger: "" };
    });
    const computeTrigger = computed(() => {
      const tableCustomOpts = computeTableCustomOpts.value;
      return tableCustomOpts.trigger;
    });
    const checkTable = () => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if ($table) {
        return true;
      }
      errLog("vxe.error.barUnableLink");
    };
    const handleClickSettingEvent = ({ $event }) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if ($table) {
        if ($table.triggerCustomEvent) {
          $table.triggerCustomEvent($event);
        } else {
          errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
        }
      }
    };
    const handleMouseenterSettingEvent = ({ $event }) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if ($table) {
        $table.customOpenEvent($event);
      } else {
        errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
      }
    };
    const handleMouseleaveSettingEvent = ({ $event }) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if ($table) {
        const { customStore } = $table.reactData;
        customStore.activeBtn = false;
        setTimeout(() => {
          if (!customStore.activeBtn && !customStore.activeWrapper) {
            $table.customCloseEvent($event);
          }
        }, 350);
      }
    };
    const refreshEvent = ({ $event }) => {
      const { isRefresh } = reactData;
      const refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch((e16) => e16).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e16) {
            reactData.isRefresh = false;
          }
        } else if ($xeGrid) {
          reactData.isRefresh = true;
          $xeGrid.triggerToolbarCommitEvent({ code: refreshOpts.code || "reload" }, $event).catch((e16) => e16).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    };
    const zoomEvent = ({ $event }) => {
      if ($xeGrid) {
        $xeGrid.triggerZoomEvent($event);
      }
    };
    const btnEvent = (evnt, item) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      const { code: code3 } = item;
      if (code3) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          const gCommandOpts = commands3.get(code3);
          const params = { code: code3, button: item, $table, $grid: $xeGrid, $event: evnt };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code3]);
              }
            }
          }
          $xeToolbar.dispatchEvent("button-click", params, evnt);
        }
      }
    };
    const tolEvent = (evnt, item) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      const { code: code3 } = item;
      if (code3) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarTolEvent(item, evnt);
        } else {
          const gCommandOpts = commands3.get(code3);
          const params = { code: code3, tool: item, $table, $grid: $xeGrid, $event: evnt };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code3]);
              }
            }
          }
          $xeToolbar.dispatchEvent("tool-click", params, evnt);
        }
      }
    };
    const importEvent = () => {
      if (checkTable()) {
        const { connectTable } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openImport();
        }
      }
    };
    const exportEvent = () => {
      if (checkTable()) {
        const { connectTable } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openExport();
        }
      }
    };
    const printEvent = () => {
      if (checkTable()) {
        const { connectTable } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openPrint();
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent3(evnt, { $toolbar: $xeToolbar }, params));
    };
    toolbarMethods = {
      dispatchEvent: dispatchEvent2,
      syncUpdate(params) {
        internalData.connectTable = params.$table;
        reactData.columns = params.collectColumn;
        reactData.connectFlag++;
      }
    };
    Object.assign($xeToolbar, toolbarMethods);
    const renderDropdowns = (item, isBtn) => {
      const { dropdowns } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index2) => {
          if (child.visible === false) {
            return createCommentVNode();
          }
          return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
            key: index2,
            disabled: child.disabled,
            loading: child.loading,
            type: child.type,
            mode: child.mode,
            icon: child.icon,
            circle: child.circle,
            round: child.round,
            status: child.status,
            content: child.name,
            title: child.title,
            routerLink: child.routerLink,
            permissionCode: child.permissionCode,
            prefixTooltip: child.prefixTooltip,
            suffixTooltip: child.suffixTooltip,
            onClick: ({ $event }) => isBtn ? btnEvent($event, child) : tolEvent($event, child)
          }) : createCommentVNode();
        });
      }
      return downVNs;
    };
    const renderBtns = () => {
      const { buttons } = props;
      const { connectTable } = internalData;
      const $table = connectTable;
      const btnVNs = [];
      if (buttons) {
        buttons.forEach((item) => {
          const { dropdowns, buttonRender } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? renderer13.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = { $grid: $xeGrid, $table, button: item };
              btnVNs.push(h("span", {
                class: ["vxe-button--item", toolbarButtonClassName ? import_xe_utils37.default.isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : ""]
              }, getSlotVNs(compConf.renderToolbarButton(buttonRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push(h(VxeUIButtonComponent, {
                  disabled: item.disabled,
                  loading: item.loading,
                  type: item.type,
                  mode: item.mode,
                  icon: item.icon,
                  circle: item.circle,
                  round: item.round,
                  status: item.status,
                  content: item.name,
                  title: item.title,
                  routerLink: item.routerLink,
                  permissionCode: item.permissionCode,
                  prefixTooltip: item.prefixTooltip,
                  suffixTooltip: item.suffixTooltip,
                  destroyOnClose: item.destroyOnClose,
                  placement: item.placement,
                  transfer: item.transfer,
                  onClick: ({ $event }) => btnEvent($event, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, true)
                } : {}));
              }
            }
          }
        });
      }
      return btnVNs;
    };
    const renderRightTools = () => {
      const { tools } = props;
      const { connectTable } = internalData;
      const $table = connectTable;
      const btnVNs = [];
      if (tools) {
        tools.forEach((item, tIndex) => {
          const { dropdowns, toolRender } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? renderer13.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = { $grid: $xeGrid, $table, tool: item };
              btnVNs.push(h("span", {
                key: rdName,
                class: ["vxe-tool--item", toolbarToolClassName ? import_xe_utils37.default.isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : ""]
              }, getSlotVNs(compConf.renderToolbarTool(toolRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push(h(VxeUIButtonComponent, {
                  key: tIndex,
                  disabled: item.disabled,
                  loading: item.loading,
                  type: item.type,
                  mode: item.mode,
                  icon: item.icon,
                  circle: item.circle,
                  round: item.round,
                  status: item.status,
                  content: item.name,
                  title: item.title,
                  routerLink: item.routerLink,
                  permissionCode: item.permissionCode,
                  prefixTooltip: item.prefixTooltip,
                  suffixTooltip: item.suffixTooltip,
                  destroyOnClose: item.destroyOnClose,
                  placement: item.placement,
                  transfer: item.transfer,
                  onClick: ({ $event }) => tolEvent($event, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, false)
                } : {}));
              }
            }
          }
        });
      }
      return btnVNs;
    };
    const renderToolImport = () => {
      const importOpts = computeImportOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "import",
        circle: true,
        icon: importOpts.icon || getIcon10().TOOLBAR_TOOLS_IMPORT,
        title: getI18n14("vxe.toolbar.import"),
        onClick: importEvent
      }) : createCommentVNode();
    };
    const renderToolExport = () => {
      const exportOpts = computeExportOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "export",
        circle: true,
        icon: exportOpts.icon || getIcon10().TOOLBAR_TOOLS_EXPORT,
        title: getI18n14("vxe.toolbar.export"),
        onClick: exportEvent
      }) : createCommentVNode();
    };
    const renderToolPrint = () => {
      const printOpts = computePrintOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "print",
        circle: true,
        icon: printOpts.icon || getIcon10().TOOLBAR_TOOLS_PRINT,
        title: getI18n14("vxe.toolbar.print"),
        onClick: printEvent
      }) : createCommentVNode();
    };
    const renderToolRefresh = () => {
      const refreshOpts = computeRefreshOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "refresh",
        circle: true,
        icon: reactData.isRefresh ? refreshOpts.iconLoading || getIcon10().TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || getIcon10().TOOLBAR_TOOLS_REFRESH,
        title: getI18n14("vxe.toolbar.refresh"),
        onClick: refreshEvent
      }) : createCommentVNode();
    };
    const renderToolZoom = () => {
      const zoomOpts = computeZoomOpts.value;
      return $xeGrid && VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "zoom",
        circle: true,
        icon: $xeGrid.isMaximized() ? zoomOpts.iconOut || getIcon10().TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || getIcon10().TOOLBAR_TOOLS_FULLSCREEN,
        title: getI18n14(`vxe.toolbar.zoom${$xeGrid.isMaximized() ? "Out" : "In"}`),
        onClick: zoomEvent
      }) : createCommentVNode();
    };
    const renderToolCustom = () => {
      const customOpts = computeCustomOpts.value;
      const btnTrigger = computeTrigger.value;
      const customBtnOns = {};
      if (btnTrigger === "manual") {
      } else if (btnTrigger === "hover") {
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
      } else {
        customBtnOns.onClick = handleClickSettingEvent;
      }
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, Object.assign({ key: "custom", circle: true, icon: customOpts.icon || getIcon10().TOOLBAR_TOOLS_CUSTOM, title: getI18n14("vxe.toolbar.custom"), className: "vxe-toolbar-custom-target" }, customBtnOns)) : createCommentVNode();
    };
    const renderVN = () => {
      const { perfect, loading: loading2, refresh, zoom, custom, className } = props;
      const { connectTable } = internalData;
      const vSize = computeSize.value;
      const toolsSlot = slots.tools;
      const buttonsSlot = slots.buttons;
      const $table = connectTable;
      return h("div", {
        ref: refElem,
        class: ["vxe-toolbar", className ? import_xe_utils37.default.isFunction(className) ? className({ $toolbar: $xeToolbar }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--perfect": perfect,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          class: "vxe-buttons--wrapper"
        }, buttonsSlot ? buttonsSlot({ $grid: $xeGrid, $table }) : renderBtns()),
        h("div", {
          class: "vxe-tools--wrapper"
        }, toolsSlot ? toolsSlot({ $grid: $xeGrid, $table }) : renderRightTools()),
        h("div", {
          class: "vxe-tools--operate"
        }, [
          props.import ? renderToolImport() : createCommentVNode(),
          props.export ? renderToolExport() : createCommentVNode(),
          props.print ? renderToolPrint() : createCommentVNode(),
          refresh ? renderToolRefresh() : createCommentVNode(),
          zoom && $xeGrid ? renderToolZoom() : createCommentVNode(),
          custom ? renderToolCustom() : createCommentVNode()
        ])
      ]);
    };
    $xeToolbar.renderVN = renderVN;
    nextTick(() => {
      const { refresh } = props;
      const refreshOpts = computeRefreshOpts.value;
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xeGrid && !queryMethod) {
        warnLog("vxe.error.notFunc", ["queryMethod"]);
      }
      const customOpts = computeCustomOpts.value;
      if (true) {
        if (customOpts.isFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.isFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.showFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.showFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.immediate) {
          warnLog("vxe.error.delProp", ["toolbar.custom.immediate", "table.custom-config.immediate"]);
        }
        if (customOpts.trigger) {
          warnLog("vxe.error.delProp", ["toolbar.custom.trigger", "table.custom-config.trigger"]);
        }
      }
      if (true) {
        if (props.refresh || props.import || props.export || props.print || props.zoom) {
          if (!VxeUIButtonComponent) {
            errLog("vxe.error.reqComp", ["vxe-button"]);
          }
        }
      }
    });
    return $xeToolbar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/toolbar/index.js
var VxeToolbar = Object.assign({}, toolbar_default, {
  install(app) {
    app.component(toolbar_default.name, toolbar_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(toolbar_default.name, toolbar_default);
}
VxeUI.component(toolbar_default);
var Toolbar = VxeToolbar;
var toolbar_default2 = VxeToolbar;

// node_modules/vxe-table/es/grid/src/grid.js
var { getConfig: getConfig9, getI18n: getI18n15, commands: commands4, hooks: hooks10, useFns: useFns4, createEvent: createEvent4, globalEvents: globalEvents5, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS4 } = VxeUI;
var tableComponentPropKeys = Object.keys(props_default);
var tableComponentMethodKeys = ["clearAll", "syncData", "updateData", "loadData", "reloadData", "reloadRow", "loadColumn", "reloadColumn", "getRowNode", "getColumnNode", "getRowIndex", "getVTRowIndex", "getVMRowIndex", "getColumnIndex", "getVTColumnIndex", "getVMColumnIndex", "setRow", "createData", "createRow", "revertData", "clearData", "isInsertByRow", "isUpdateByRow", "getColumns", "getColumnById", "getColumnByField", "getTableColumn", "getFullColumns", "getData", "getCheckboxRecords", "getParentRow", "getTreeParentRow", "getRowSeq", "getRowById", "getRowid", "getTableData", "getFullData", "setColumnFixed", "clearColumnFixed", "setColumnWidth", "getColumnWidth", "hideColumn", "showColumn", "resetColumn", "refreshColumn", "refreshScroll", "recalculate", "closeTooltip", "isAllCheckboxChecked", "isAllCheckboxIndeterminate", "getCheckboxIndeterminateRecords", "setCheckboxRow", "isCheckedByCheckboxRow", "isIndeterminateByCheckboxRow", "toggleCheckboxRow", "setAllCheckboxRow", "getRadioReserveRecord", "clearRadioReserve", "getCheckboxReserveRecords", "clearCheckboxReserve", "toggleAllCheckboxRow", "clearCheckboxRow", "setCurrentRow", "isCheckedByRadioRow", "setRadioRow", "clearCurrentRow", "clearRadioRow", "getCurrentRecord", "getRadioRecord", "getCurrentColumn", "setCurrentColumn", "clearCurrentColumn", "setPendingRow", "togglePendingRow", "getPendingRecords", "clearPendingRow", "sort", "setSort", "clearSort", "isSort", "getSortColumns", "closeFilter", "isFilter", "isActiveFilterByColumn", "isRowExpandLoaded", "clearRowExpandLoaded", "reloadRowExpand", "reloadRowExpand", "toggleRowExpand", "setAllRowExpand", "setRowExpand", "isExpandByRow", "isRowExpandByRow", "clearRowExpand", "clearRowExpandReserve", "getRowExpandRecords", "getTreeExpandRecords", "isTreeExpandLoaded", "clearTreeExpandLoaded", "reloadTreeExpand", "reloadTreeChilds", "toggleTreeExpand", "setAllTreeExpand", "setTreeExpand", "isTreeExpandByRow", "clearTreeExpand", "clearTreeExpandReserve", "getScroll", "scrollTo", "scrollToRow", "scrollToColumn", "clearScroll", "updateFooter", "updateStatus", "setMergeCells", "removeInsertRow", "removeMergeCells", "getMergeCells", "clearMergeCells", "setMergeFooterItems", "removeMergeFooterItems", "getMergeFooterItems", "clearMergeFooterItems", "getCustomStoreData", "openTooltip", "getCellLabel", "getCellElement", "focus", "blur", "connect"];
var gridComponentEmits = [
  ...emits_default,
  "page-change",
  "form-submit",
  "form-submit-invalid",
  "form-reset",
  "form-collapse",
  "form-toggle-collapse",
  "proxy-query",
  "proxy-delete",
  "proxy-save",
  "toolbar-button-click",
  "toolbar-tool-click",
  "zoom"
];
var grid_default = defineComponent({
  name: "VxeGrid",
  props: Object.assign(Object.assign({}, props_default), { layouts: Array, columns: Array, pagerConfig: Object, proxyConfig: Object, toolbarConfig: Object, formConfig: Object, zoomConfig: Object, size: {
    type: String,
    default: () => getConfig9().grid.size || getConfig9().size
  } }),
  emits: gridComponentEmits,
  setup(props, context) {
    var _a2;
    const { slots, emit } = context;
    const xID = import_xe_utils38.default.uniqueId();
    const VxeUIFormComponent = VxeUI.getComponent("VxeForm");
    const VxeUIPagerComponent = VxeUI.getComponent("VxePager");
    const { computeSize } = useFns4.useSize(props);
    const reactData = reactive({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: ((_a2 = getConfig9().pager) === null || _a2 === void 0 ? void 0 : _a2.pageSize) || 10,
        currentPage: 1
      }
    });
    const refElem = ref();
    const refTable = ref();
    const refForm = ref();
    const refToolbar = ref();
    const refPager = ref();
    const refFormWrapper = ref();
    const refToolbarWrapper = ref();
    const refTopWrapper = ref();
    const refBottomWrapper = ref();
    const refPagerWrapper = ref();
    const extendTableMethods = (methodKeys) => {
      const funcs = {};
      methodKeys.forEach((name) => {
        funcs[name] = (...args) => {
          const $xeTable = refTable.value;
          if ($xeTable && $xeTable[name]) {
            return $xeTable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach((name) => {
      gridExtendTableMethods[name] = (...args) => {
        const $xeTable = refTable.value;
        if ($xeTable && $xeTable[name]) {
          return $xeTable && $xeTable[name](...args);
        }
      };
    });
    const computeProxyOpts = computed(() => {
      return import_xe_utils38.default.merge({}, import_xe_utils38.default.clone(getConfig9().grid.proxyConfig, true), props.proxyConfig);
    });
    const computeIsRespMsg = computed(() => {
      const proxyOpts = computeProxyOpts.value;
      return import_xe_utils38.default.isBoolean(proxyOpts.message) ? proxyOpts.message : proxyOpts.showResponseMsg;
    });
    const computeIsActiveMsg = computed(() => {
      const proxyOpts = computeProxyOpts.value;
      return proxyOpts.showActiveMsg;
    });
    const computePagerOpts = computed(() => {
      return Object.assign({}, getConfig9().grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = computed(() => {
      return Object.assign({}, getConfig9().grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = computed(() => {
      return Object.assign({}, getConfig9().grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, getConfig9().grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = computed(() => {
      return reactData.isZMax ? { zIndex: reactData.tZindex } : null;
    });
    const computeTableExtendProps = computed(() => {
      const rest = {};
      const gridProps = props;
      tableComponentPropKeys.forEach((key) => {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    const computeTableProps = computed(() => {
      const { seqConfig, pagerConfig, loading: loading2, editConfig, proxyConfig } = props;
      const { isZMax, tableLoading, tablePage, tableData } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const tableProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tableProps.maxHeight = "100%";
        } else {
          tableProps.height = "100%";
        }
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        tableProps.loading = loading2 || tableLoading;
        tableProps.data = tableData;
        if (pagerConfig && proxyOpts.seq && isEnableConf(pagerOpts)) {
          tableProps.seqConfig = Object.assign({}, seqConfig, { startIndex: (tablePage.currentPage - 1) * tablePage.pageSize });
        }
      }
      if (editConfig) {
        tableProps.editConfig = Object.assign({}, editConfig);
      }
      return tableProps;
    });
    const computeCurrLayout = computed(() => {
      const { layouts } = props;
      if (layouts && layouts.length) {
        return layouts;
      }
      return getConfig9().grid.layouts || ["Form", "Toolbar", "Top", "Table", "Bottom", "Pager"];
    });
    const computePageConfFlag = computed(() => {
      const pagerOpts = computePagerOpts.value;
      return `${pagerOpts.currentPage}${pagerOpts.pageSize}`;
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xeGrid = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && isEnableConf(toolbarOpts)) {
        nextTick(() => {
          const $xeTable = refTable.value;
          const $xeToolbar = refToolbar.value;
          if ($xeTable && $xeToolbar) {
            $xeTable.connect($xeToolbar);
          }
        });
      }
    };
    const getFormData = () => {
      const { proxyConfig } = props;
      const { formData } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      return proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data;
    };
    const initPages = () => {
      const { tablePage } = reactData;
      const { pagerConfig } = props;
      const pagerOpts = computePagerOpts.value;
      const { currentPage, pageSize } = pagerOpts;
      if (pagerConfig && isEnableConf(pagerOpts)) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    const triggerPendingEvent = (code3) => {
      const isActiveMsg = computeIsActiveMsg.value;
      const $xeTable = refTable.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      if (selectRecords.length) {
        $xeTable.togglePendingRow(selectRecords);
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isActiveMsg) {
          if (VxeUI.modal) {
            VxeUI.modal.message({ id: code3, content: getI18n15("vxe.grid.selectOneRecord"), status: "warning" });
          }
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      let msg;
      if (rest && messageProp) {
        msg = import_xe_utils38.default.isFunction(messageProp) ? messageProp({ data: rest, $grid: $xeGrid }) : import_xe_utils38.default.get(rest, messageProp);
      }
      return msg || getI18n15(defaultMsg);
    };
    const handleDeleteRow = (code3, alertKey, callback) => {
      const isActiveMsg = computeIsActiveMsg.value;
      const selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isActiveMsg) {
        if (selectRecords.length) {
          if (VxeUI.modal) {
            return VxeUI.modal.confirm({ id: `cfm_${code3}`, content: getI18n15(alertKey), escClosable: true }).then((type) => {
              if (type === "confirm") {
                return callback();
              }
            });
          }
        } else {
          if (VxeUI.modal) {
            VxeUI.modal.message({ id: `msg_${code3}`, content: getI18n15("vxe.grid.selectOneRecord"), status: "warning" });
          }
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = (params) => {
      const { proxyConfig } = props;
      const { tablePage } = reactData;
      const { $event, currentPage, pageSize } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      gridMethods.dispatchEvent("page-change", params, $event);
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("query").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", rest, $event);
        });
      }
    };
    const sortChangeEvent = (params) => {
      const $xeTable = refTable.value;
      const { proxyConfig } = props;
      const { computeSortOpts } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("sort-change", params, params.$event);
    };
    const filterChangeEvent = (params) => {
      const $xeTable = refTable.value;
      const { proxyConfig } = props;
      const { computeFilterOpts } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("filter-change", params, params.$event);
    };
    const submitFormEvent = (params) => {
      const { proxyConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), params.$event);
        });
      }
      gridMethods.dispatchEvent("form-submit", params, params.$event);
    };
    const resetFormEvent = (params) => {
      const { proxyConfig } = props;
      const { $event } = params;
      const proxyOpts = computeProxyOpts.value;
      const $xeTable = refTable.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        $xeTable.clearScroll();
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), $event);
        });
      }
      gridMethods.dispatchEvent("form-reset", params, $event);
    };
    const submitInvalidEvent = (params) => {
      gridMethods.dispatchEvent("form-submit-invalid", params, params.$event);
    };
    const collapseEvent = (params) => {
      const { $event } = params;
      nextTick(() => gridExtendTableMethods.recalculate(true));
      gridMethods.dispatchEvent("form-toggle-collapse", params, $event);
      gridMethods.dispatchEvent("form-collapse", params, $event);
    };
    const handleZoom = (isMax) => {
      const { isZMax } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return nextTick().then(() => gridExtendTableMethods.recalculate(true)).then(() => reactData.isZMax);
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (import_xe_utils38.default.isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            if (true) {
              errLog("vxe.error.notSlot", [funcSlot]);
            }
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    const renderForm = () => {
      const { formConfig, proxyConfig } = props;
      const { formData } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (formConfig && isEnableConf(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({ $grid: $xeGrid });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach((item) => {
                  beforeItem({ $grid: $xeGrid, item });
                });
              }
            }
            formOpts.items.forEach((item) => {
              import_xe_utils38.default.each(item.slots, (func) => {
                if (!import_xe_utils38.default.isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            if (VxeUIFormComponent) {
              slotVNs.push(h(VxeUIFormComponent, Object.assign(Object.assign({ ref: refForm }, Object.assign({}, formOpts, {
                data: proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data
              })), { onSubmit: submitFormEvent, onReset: resetFormEvent, onSubmitInvalid: submitInvalidEvent, onCollapse: collapseEvent }), formSlots));
            }
          }
        }
        return h("div", {
          ref: refFormWrapper,
          key: "form",
          class: "vxe-grid--form-wrapper"
        }, slotVNs);
      }
      return createCommentVNode();
    };
    const renderToolbar = () => {
      const { toolbarConfig } = props;
      const toolbarOpts = computeToolbarOpts.value;
      if (toolbarConfig && isEnableConf(toolbarOpts) || slots.toolbar) {
        let slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({ $grid: $xeGrid });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          let buttonsSlot;
          let toolsSlot;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, "buttons");
            toolsSlot = getFuncSlot(toolbarOptSlots, "tools");
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push(h(toolbar_default2, Object.assign({ ref: refToolbar }, toolbarOpts), toolbarSlots));
        }
        return h("div", {
          ref: refToolbarWrapper,
          key: "toolbar",
          class: "vxe-grid--toolbar-wrapper"
        }, slotVNs);
      }
      return createCommentVNode();
    };
    const renderTop = () => {
      if (slots.top) {
        return h("div", {
          ref: refTopWrapper,
          key: "top",
          class: "vxe-grid--top-wrapper"
        }, slots.top({ $grid: $xeGrid }));
      }
      return createCommentVNode();
    };
    const renderTableLeft = () => {
      const leftSlot = slots.left;
      if (leftSlot) {
        return h("div", {
          class: "vxe-grid--left-wrapper"
        }, leftSlot({ $grid: $xeGrid }));
      }
      return createCommentVNode();
    };
    const renderTableRight = () => {
      const rightSlot = slots.right;
      if (rightSlot) {
        return h("div", {
          class: "vxe-grid--right-wrapper"
        }, rightSlot({ $grid: $xeGrid }));
      }
      return createCommentVNode();
    };
    const renderTable = () => {
      const { proxyConfig } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = () => emptySlot({ $grid: $xeGrid });
      }
      if (loadingSlot) {
        slotObj.loading = () => loadingSlot({ $grid: $xeGrid });
      }
      return h("div", {
        class: "vxe-grid--table-wrapper"
      }, [
        h(table_default2, Object.assign(Object.assign({ ref: refTable }, tableProps), tableOns), slotObj)
      ]);
    };
    const renderBottom = () => {
      if (slots.bottom) {
        return h("div", {
          ref: refBottomWrapper,
          key: "bottom",
          class: "vxe-grid--bottom-wrapper"
        }, slots.bottom({ $grid: $xeGrid }));
      }
      return createCommentVNode();
    };
    const renderPager = () => {
      const { proxyConfig, pagerConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
        let slotVNs = [];
        if (slots.pager) {
          slotVNs = slots.pager({ $grid: $xeGrid });
        } else {
          const pagerOptSlots = pagerOpts.slots;
          const pagerSlots = {};
          let leftSlot;
          let rightSlot;
          if (pagerOptSlots) {
            leftSlot = getFuncSlot(pagerOptSlots, "left");
            rightSlot = getFuncSlot(pagerOptSlots, "right");
            if (leftSlot) {
              pagerSlots.left = leftSlot;
            }
            if (rightSlot) {
              pagerSlots.right = rightSlot;
            }
          }
          if (VxeUIPagerComponent) {
            slotVNs.push(h(VxeUIPagerComponent, Object.assign(Object.assign(Object.assign({ ref: refPager }, pagerOpts), proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {}), { onPageChange: pageChangeEvent }), pagerSlots));
          }
        }
        return h("div", {
          ref: refPagerWrapper,
          key: "pager",
          class: "vxe-grid--pager-wrapper"
        }, slotVNs);
      }
      return createCommentVNode();
    };
    const renderLayout = () => {
      const vns = [];
      const currLayouts = computeCurrLayout.value;
      currLayouts.forEach((name) => {
        switch (name) {
          case "Form":
            vns.push(renderForm());
            break;
          case "Toolbar":
            vns.push(renderToolbar());
            break;
          case "Top":
            vns.push(renderTop());
            break;
          case "Table":
            vns.push(h("div", {
              key: "table",
              class: "vxe-grid--table-container"
            }, [
              renderTableLeft(),
              renderTable(),
              renderTableRight()
            ]));
            break;
          case "Bottom":
            vns.push(renderBottom());
            break;
          case "Pager":
            vns.push(renderPager());
            break;
          default:
            if (true) {
              errLog("vxe.error.notProp", [`layouts -> ${name}`]);
            }
            break;
        }
      });
      return vns;
    };
    const tableCompEvents = {};
    emits_default.forEach((name) => {
      const type = import_xe_utils38.default.camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    const initProxy = () => {
      const { proxyConfig, formConfig } = props;
      const { proxyInited } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (formConfig && isEnableConf(formOpts) && proxyOpts.form && formOpts.items) {
          const fData = {};
          formOpts.items.forEach((item) => {
            const { field, itemRender } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const { defaultValue } = itemRender;
                if (import_xe_utils38.default.isFunction(defaultValue)) {
                  itemValue = defaultValue({ item });
                } else if (!import_xe_utils38.default.isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              fData[field] = itemValue;
            }
          });
          reactData.formData = fData;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            nextTick().then(() => gridMethods.commitProxy("_init")).then((rest) => {
              gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isInited: true }), new Event("init"));
            });
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = globalEvents5.hasKey(evnt, GLOBAL_EVENT_KEYS4.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent4(evnt, { $grid: $xeGrid }, params));
    };
    const gridMethods = {
      dispatchEvent: dispatchEvent2,
      /**
       *  code  button
       * @param {String/Object} code 
       */
      commitProxy(proxyTarget, ...args) {
        const { toolbarConfig, pagerConfig, editRules, validConfig } = props;
        const { tablePage } = reactData;
        const isActiveMsg = computeIsActiveMsg.value;
        const isRespMsg = computeIsRespMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const { beforeQuery, afterQuery, beforeDelete, afterDelete, beforeSave, afterSave, ajax = {} } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xeTable = refTable.value;
        const formData = getFormData();
        let button = null;
        let code3 = null;
        if (import_xe_utils38.default.isString(proxyTarget)) {
          const { buttons } = toolbarOpts;
          const matchObj = toolbarConfig && isEnableConf(toolbarOpts) && buttons ? import_xe_utils38.default.findTree(buttons, (item) => item.code === proxyTarget, { children: "dropdowns" }) : null;
          button = matchObj ? matchObj.item : null;
          code3 = proxyTarget;
        } else {
          button = proxyTarget;
          code3 = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code3) {
          case "insert":
            return $xeTable.insert({});
          case "insert_edit":
            return $xeTable.insert({}).then(({ row }) => $xeTable.setEditRow(row));
          case "insert_actived":
            return $xeTable.insert({}).then(({ row }) => $xeTable.setEditRow(row));
          case "mark_cancel":
            triggerPendingEvent(code3);
            break;
          case "remove":
            return handleDeleteRow(code3, "vxe.grid.removeSelectRecord", () => $xeTable.removeCheckboxRow());
          case "import":
            $xeTable.importData(btnParams);
            break;
          case "open_import":
            $xeTable.openImport(btnParams);
            break;
          case "export":
            $xeTable.exportData(btnParams);
            break;
          case "open_export":
            $xeTable.openExport(btnParams);
            break;
          case "reset_custom":
            return $xeTable.resetCustom(true);
          case "_init":
          case "reload":
          case "query": {
            const ajaxMethods = ajax.query;
            const querySuccessMethods = ajax.querySuccess;
            const queryErrorMethods = ajax.queryError;
            if (ajaxMethods) {
              const isInited = code3 === "_init";
              const isReload = code3 === "reload";
              let sortList = [];
              let filterList = [];
              let pageParams = {};
              if (pagerConfig) {
                if (isInited || isReload) {
                  tablePage.currentPage = 1;
                }
                if (isEnableConf(pagerOpts)) {
                  pageParams = Object.assign({}, tablePage);
                }
              }
              if (isInited) {
                let defaultSort = null;
                if ($xeTable) {
                  const { computeSortOpts } = $xeTable.getComputeMaps();
                  const sortOpts = computeSortOpts.value;
                  defaultSort = sortOpts.defaultSort;
                }
                if (defaultSort) {
                  if (!import_xe_utils38.default.isArray(defaultSort)) {
                    defaultSort = [defaultSort];
                  }
                  sortList = defaultSort.map((item) => {
                    return {
                      field: item.field,
                      property: item.field,
                      order: item.order
                    };
                  });
                }
                if ($xeTable) {
                  filterList = $xeTable.getCheckedFilters();
                }
              } else {
                if ($xeTable) {
                  if (isReload) {
                    $xeTable.clearAll();
                  } else {
                    sortList = $xeTable.getSortColumns();
                    filterList = $xeTable.getCheckedFilters();
                  }
                }
              }
              const commitParams = {
                code: code3,
                button,
                isInited,
                isReload,
                $grid: $xeGrid,
                page: pageParams,
                sort: sortList.length ? sortList[0] : {},
                sorts: sortList,
                filters: filterList,
                form: formData,
                options: ajaxMethods
              };
              reactData.sortData = sortList;
              reactData.filterData = filterList;
              reactData.tableLoading = true;
              return Promise.resolve((beforeQuery || ajaxMethods)(commitParams, ...args)).then((rest) => {
                reactData.tableLoading = false;
                if (rest) {
                  if (pagerConfig && isEnableConf(pagerOpts)) {
                    const totalProp = resConfigs.total;
                    const total = (import_xe_utils38.default.isFunction(totalProp) ? totalProp({ data: rest, $grid: $xeGrid }) : import_xe_utils38.default.get(rest, totalProp || "page.total")) || 0;
                    tablePage.total = import_xe_utils38.default.toNumber(total);
                    const resultProp = resConfigs.result;
                    reactData.tableData = (import_xe_utils38.default.isFunction(resultProp) ? resultProp({ data: rest, $grid: $xeGrid }) : import_xe_utils38.default.get(rest, resultProp || "result")) || [];
                    const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                    if (tablePage.currentPage > pageCount) {
                      tablePage.currentPage = pageCount;
                    }
                  } else {
                    const listProp = resConfigs.list;
                    reactData.tableData = (listProp ? import_xe_utils38.default.isFunction(listProp) ? listProp({ data: rest, $grid: $xeGrid }) : import_xe_utils38.default.get(rest, listProp) : rest) || [];
                  }
                } else {
                  reactData.tableData = [];
                }
                if (afterQuery) {
                  afterQuery(commitParams, ...args);
                }
                if (querySuccessMethods) {
                  querySuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                }
                return { status: true };
              }).catch((rest) => {
                reactData.tableLoading = false;
                if (queryErrorMethods) {
                  queryErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                }
                return { status: false };
              });
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.query"]);
              }
            }
            break;
          }
          case "delete": {
            const ajaxMethods = ajax.delete;
            const deleteSuccessMethods = ajax.deleteSuccess;
            const deleteErrorMethods = ajax.deleteError;
            if (ajaxMethods) {
              const selectRecords = gridExtendTableMethods.getCheckboxRecords();
              const removeRecords = selectRecords.filter((row) => !$xeTable.isInsertByRow(row));
              const body = { removeRecords };
              const commitParams = { $grid: $xeGrid, code: code3, button, body, form: formData, options: ajaxMethods };
              if (selectRecords.length) {
                return handleDeleteRow(code3, "vxe.grid.deleteSelectRecord", () => {
                  if (!removeRecords.length) {
                    return $xeTable.remove(selectRecords);
                  }
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeDelete || ajaxMethods)(commitParams, ...args)).then((rest) => {
                    reactData.tableLoading = false;
                    $xeTable.setPendingRow(removeRecords, false);
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ content: getRespMsg(rest, "vxe.grid.delSuccess"), status: "success" });
                      }
                    }
                    if (afterDelete) {
                      afterDelete(commitParams, ...args);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    if (deleteSuccessMethods) {
                      deleteSuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ id: code3, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                      }
                    }
                    if (deleteErrorMethods) {
                      deleteErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: false };
                  });
                });
              } else {
                if (isActiveMsg) {
                  if (VxeUI.modal) {
                    VxeUI.modal.message({ id: code3, content: getI18n15("vxe.grid.selectOneRecord"), status: "warning" });
                  }
                }
              }
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.delete"]);
              }
            }
            break;
          }
          case "save": {
            const ajaxMethods = ajax.save;
            const saveSuccessMethods = ajax.saveSuccess;
            const saveErrorMethods = ajax.saveError;
            if (ajaxMethods) {
              const body = $xeTable.getRecordset();
              const { insertRecords, removeRecords, updateRecords, pendingRecords } = body;
              const commitParams = { $grid: $xeGrid, code: code3, button, body, form: formData, options: ajaxMethods };
              if (insertRecords.length) {
                body.pendingRecords = pendingRecords.filter((row) => $xeTable.findRowIndexOf(insertRecords, row) === -1);
              }
              if (pendingRecords.length) {
                body.insertRecords = insertRecords.filter((row) => $xeTable.findRowIndexOf(pendingRecords, row) === -1);
              }
              let restPromise = Promise.resolve();
              if (editRules) {
                restPromise = $xeTable[validConfig && validConfig.msgMode === "full" ? "fullValidate" : "validate"](body.insertRecords.concat(updateRecords));
              }
              return restPromise.then((errMap) => {
                if (errMap) {
                  return;
                }
                if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeSave || ajaxMethods)(commitParams, ...args)).then((rest) => {
                    reactData.tableLoading = false;
                    $xeTable.clearPendingRow();
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ content: getRespMsg(rest, "vxe.grid.saveSuccess"), status: "success" });
                      }
                    }
                    if (afterSave) {
                      afterSave(commitParams, ...args);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    if (saveSuccessMethods) {
                      saveSuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ id: code3, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                      }
                    }
                    if (saveErrorMethods) {
                      saveErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: false };
                  });
                } else {
                  if (isActiveMsg) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({ id: code3, content: getI18n15("vxe.grid.dataUnchanged"), status: "info" });
                    }
                  }
                }
              });
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.save"]);
              }
            }
            break;
          }
          default: {
            const gCommandOpts = commands4.get(code3);
            if (gCommandOpts) {
              const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
              if (tCommandMethod) {
                tCommandMethod({ code: code3, button, $grid: $xeGrid, $table: $xeTable }, ...args);
              } else {
                if (true) {
                  errLog("vxe.error.notCommands", [code3]);
                }
              }
            }
          }
        }
        return nextTick();
      },
      zoom() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormData,
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const { formConfig } = props;
        const { items } = formOpts;
        const itemList = [];
        import_xe_utils38.default.eachTree(formConfig && isEnableConf(formOpts) && items ? items : [], (item) => {
          itemList.push(item);
        }, { children: "children" });
        return import_xe_utils38.default.isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getProxyInfo() {
        const $xeTable = refTable.value;
        if (props.proxyConfig) {
          const { sortData } = reactData;
          return {
            data: reactData.tableData,
            filter: reactData.filterData,
            form: getFormData(),
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xeTable ? $xeTable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    if (true) {
      gridMethods.loadColumn = (columns) => {
        const $xeTable = refTable.value;
        import_xe_utils38.default.eachTree(columns, (column) => {
          if (column.slots) {
            import_xe_utils38.default.each(column.slots, (func) => {
              if (!import_xe_utils38.default.isFunction(func)) {
                if (!slots[func]) {
                  errLog("vxe.error.notSlot", [func]);
                }
              }
            });
          }
        });
        if ($xeTable) {
          return $xeTable.loadColumn(columns);
        }
        return nextTick();
      };
      gridMethods.reloadColumn = (columns) => {
        gridExtendTableMethods.clearAll();
        return gridMethods.loadColumn(columns);
      };
    }
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (import_xe_utils38.default.isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (import_xe_utils38.default.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 
       */
      getExcludeHeight() {
        const { height } = props;
        const { isZMax } = reactData;
        const el2 = refElem.value;
        const formWrapper = refFormWrapper.value;
        const toolbarWrapper = refToolbarWrapper.value;
        const topWrapper = refTopWrapper.value;
        const bottomWrapper = refBottomWrapper.value;
        const pagerWrapper = refPagerWrapper.value;
        const parentPaddingSize = isZMax || !(height === "auto" || height === "100%") ? 0 : getPaddingTopBottomSize(el2.parentNode);
        return parentPaddingSize + getPaddingTopBottomSize(el2) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
      },
      getParentHeight() {
        const el2 = refElem.value;
        if (el2) {
          return (reactData.isZMax ? getDomNode().visibleHeight : import_xe_utils38.default.toNumber(getComputedStyle(el2.parentNode).height)) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const { code: code3 } = params;
        return gridMethods.commitProxy(params, evnt).then((rest) => {
          if (code3 && rest && rest.status && ["query", "reload", "delete", "save"].includes(code3)) {
            gridMethods.dispatchEvent(code3 === "delete" || code3 === "save" ? `proxy-${code3}` : "proxy-query", Object.assign(Object.assign({}, rest), { isReload: code3 === "reload" }), evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(button, evnt);
        gridMethods.dispatchEvent("toolbar-button-click", { code: button.code, button }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(tool, evnt);
        gridMethods.dispatchEvent("toolbar-tool-click", { code: tool.code, tool }, evnt);
      },
      triggerZoomEvent(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent("zoom", { type: reactData.isZMax ? "max" : "revert" }, evnt);
      }
    };
    Object.assign($xeGrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    const columnFlag = ref(0);
    watch(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    watch(() => props.columns, () => {
      columnFlag.value++;
    });
    watch(columnFlag, () => {
      nextTick(() => $xeGrid.loadColumn(props.columns || []));
    });
    watch(() => props.toolbarConfig, () => {
      initToolbar();
    });
    watch(computePageConfFlag, () => {
      initPages();
    });
    watch(() => props.proxyConfig, () => {
      initProxy();
    });
    hooks10.forEach((options) => {
      const { setupGrid } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xeGrid);
        if (hookRest && import_xe_utils38.default.isObject(hookRest)) {
          Object.assign($xeGrid, hookRest);
        }
      }
    });
    initPages();
    onMounted(() => {
      if (true) {
        nextTick(() => {
          if (props.formConfig) {
            if (!VxeUIFormComponent) {
              errLog("vxe.error.reqComp", ["vxe-form"]);
            }
          }
          if (props.pagerConfig) {
            if (!VxeUIPagerComponent) {
              errLog("vxe.error.reqComp", ["vxe-pager"]);
            }
          }
        });
      }
      nextTick(() => {
        const { columns } = props;
        if (columns && columns.length) {
          $xeGrid.loadColumn(columns);
        }
        initToolbar();
        initProxy();
      });
      globalEvents5.on($xeGrid, "keydown", handleGlobalKeydownEvent);
    });
    onUnmounted(() => {
      globalEvents5.off($xeGrid, "keydown");
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-grid", {
          [`size--${vSize}`]: vSize,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--maximize": reactData.isZMax,
          "is--loading": props.loading || reactData.tableLoading
        }],
        style: styles
      }, renderLayout());
    };
    $xeGrid.renderVN = renderVN;
    provide("$xeGrid", $xeGrid);
    return $xeGrid;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/grid/index.js
var VxeGrid = Object.assign({}, grid_default, {
  install(app) {
    app.component(grid_default.name, grid_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(grid_default.name, grid_default);
}
VxeUI.component(grid_default);
var Grid = VxeGrid;

// node_modules/vxe-table/es/locale/lang/zh-CN.js
var zh_CN_default = {
  vxe: {
    base: {
      pleaseInput: "",
      pleaseSelect: "",
      comma: "",
      fullStop: ""
    },
    loading: {
      text: "..."
    },
    error: {
      downErr: "",
      groupFixed: "",
      groupMouseRange: ' "{0}" ',
      groupTag: ' "{0}"  "{1}"',
      scrollErrProp: ' "{0}"',
      errConflicts: ' "{0}"  "{1}" ',
      unableInsert: "",
      useErr: ' "{0}"  Table ',
      barUnableLink: "",
      expandContent: ' "content"',
      reqComp: ' "{0}"  https://vxeui.com/#/start/useGlobal',
      reqModule: ' "{0}" ',
      reqProp: ' "{0}" ',
      emptyProp: ' "{0}" ',
      errProp: ' "{0}" "{1}"',
      colRepet: 'column.{0}="{1}" ',
      notFunc: ' "{0}" ',
      errFunc: ' "{0}" ',
      notValidators: ' "{0}" ',
      notFormats: ' "{0}" ',
      notCommands: ' "{0}" ',
      notSlot: ' "{0}" ',
      noTree: ' "{0}"',
      notProp: ' "{0}"',
      checkProp: ' "{0}" ',
      coverProp: '"{0}"  "{1}" ',
      uniField: ' "{0}" ',
      repeatKey: ' {0}="{1}"',
      delFunc: ' "{0}"  "{1}"',
      delProp: ' "{0}"  "{1}"',
      delEvent: ' "{0}"  "{1}"',
      removeProp: ' "{0}" ',
      errFormat: ' "VXETable.formats"  "formatter={0}" ',
      notType: ' "{0}"',
      notExp: "/",
      impFields: "",
      treeNotImp: "",
      treeCrossDrag: "",
      treeDragChild: "",
      reqPlugin: ' "{1}" https://vxeui.com/other{0}/#/{1}/install'
    },
    table: {
      emptyText: "",
      allTitle: "/",
      seqTitle: "",
      actionTitle: "",
      confirmFilter: "",
      resetFilter: "",
      allFilter: "",
      sortAsc: "",
      sortDesc: "",
      filter: "",
      impSuccess: " {0} ",
      expLoading: "",
      expSuccess: "",
      expError: "",
      expFilename: "_{0}",
      expOriginFilename: "__{0}",
      customTitle: "",
      customAll: "",
      customConfirm: "",
      customClose: "",
      customCancel: "",
      customRestore: "",
      maxFixedCol: " {0} ",
      dragTip: "{0}"
    },
    grid: {
      selectOneRecord: "",
      deleteSelectRecord: "",
      removeSelectRecord: "",
      dataUnchanged: "",
      delSuccess: "",
      saveSuccess: "",
      operError: ""
    },
    select: {
      search: "",
      loadingText: "",
      emptyText: ""
    },
    pager: {
      goto: "",
      gotoTitle: "",
      pagesize: "{0}/",
      total: " {0} ",
      pageClassifier: "",
      homePage: "",
      homePageTitle: "",
      prevPage: "",
      prevPageTitle: "",
      nextPage: "",
      nextPageTitle: "",
      prevJump: "",
      prevJumpTitle: "",
      nextJump: "",
      nextJumpTitle: "",
      endPage: "",
      endPageTitle: ""
    },
    alert: {
      title: ""
    },
    button: {
      confirm: "",
      cancel: ""
    },
    filter: {
      search: ""
    },
    custom: {
      cstmTitle: "",
      cstmRestore: "",
      cstmCancel: "",
      cstmConfirm: "",
      cstmConfirmRestore: "",
      cstmDragTarget: "{0}",
      setting: {
        colSort: "",
        sortHelpTip: "",
        colTitle: "",
        colResizable: "",
        colVisible: "",
        colFixed: "",
        colFixedMax: " {0} ",
        fixedLeft: "",
        fixedUnset: "",
        fixedRight: ""
      }
    },
    import: {
      modes: {
        covering: "",
        insert: "",
        insertTop: "",
        insertBottom: ""
      },
      impTitle: "",
      impFile: "",
      impSelect: "",
      impType: "",
      impOpts: "",
      impMode: "",
      impConfirm: "",
      impCancel: ""
    },
    export: {
      types: {
        csv: "CSV ()(*.csv)",
        html: "(*.html)",
        xml: "XML (*.xml)",
        txt: "()(*.txt)",
        xls: "Excel 97-2003 (*.xls)",
        xlsx: "Excel (*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "",
        selected: "",
        all: ""
      },
      printTitle: "",
      expTitle: "",
      expName: "",
      expNamePlaceholder: "",
      expSheetName: "",
      expSheetNamePlaceholder: "",
      expType: "",
      expMode: "",
      expCurrentColumn: "",
      expColumn: "",
      expOpts: "",
      expOptHeader: "",
      expHeaderTitle: "",
      expOptFooter: "",
      expFooterTitle: "",
      expOptColgroup: "",
      expColgroupTitle: "",
      expOptMerge: "",
      expMergeTitle: "",
      expOptAllExpand: "",
      expAllExpandTitle: "",
      expOptUseStyle: "",
      expUseStyleTitle: "",
      expOptOriginal: "",
      expOriginalTitle: "",
      expPrint: "",
      expConfirm: "",
      expCancel: ""
    },
    modal: {
      errTitle: "",
      zoomMin: "",
      zoomIn: "",
      zoomOut: "",
      close: "",
      miniMaxSize: " {0} ",
      footPropErr: "show-footer  show-confirm-button | show-cancel-button | "
    },
    drawer: {
      close: ""
    },
    form: {
      folding: "",
      unfolding: ""
    },
    toolbar: {
      import: "",
      export: "",
      print: "",
      refresh: "",
      zoomIn: "",
      zoomOut: "",
      custom: "",
      customAll: "",
      customConfirm: "",
      customRestore: "",
      fixedLeft: "",
      fixedRight: "",
      cancelFixed: ""
    },
    input: {
      date: {
        m1: "01 ",
        m2: "02 ",
        m3: "03 ",
        m4: "04 ",
        m5: "05 ",
        m6: "06 ",
        m7: "07 ",
        m8: "08 ",
        m9: "09 ",
        m10: "10 ",
        m11: "11 ",
        m12: "12 ",
        quarterLabel: "{0} ",
        monthLabel: "{0} ",
        dayLabel: "{0}  {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy  WW ",
          month: "yyyy-MM",
          quarter: "yyyy  q ",
          year: "yyyy"
        },
        weeks: {
          w: "",
          w0: "",
          w1: "",
          w2: "",
          w3: "",
          w4: "",
          w5: "",
          w6: ""
        },
        months: {
          m0: "",
          m1: "",
          m2: "",
          m3: "",
          m4: "",
          m5: "",
          m6: "",
          m7: "",
          m8: "",
          m9: "",
          m10: "",
          m11: ""
        },
        quarters: {
          q1: "",
          q2: "",
          q3: "",
          q4: ""
        }
      }
    },
    imagePreview: {
      popupTitle: "",
      operBtn: {
        zoomOut: "",
        zoomIn: "",
        pctFull: "",
        pct11: "",
        rotateLeft: "",
        rotateRight: "",
        print: "",
        download: ""
      }
    },
    upload: {
      fileBtnText: "",
      imgBtnText: "",
      dragPlaceholder: "",
      imgSizeHint: "{0}",
      imgCountHint: "{0}",
      fileTypeHint: " {0} ",
      fileSizeHint: "{0}",
      fileCountHint: "{0}",
      uploadTypeErr: "",
      overCountErr: "{0}",
      overCountExtraErr: "{0}{1}",
      overSizeErr: "{0}",
      reUpload: "",
      uploadProgress: " {0}%",
      uploadErr: "",
      uploadSuccess: "",
      moreBtnText: "{0}",
      viewItemTitle: "",
      morePopup: {
        readTitle: "",
        imageTitle: "",
        fileTitle: ""
      }
    },
    empty: {
      defText: ""
    },
    formDesign: {
      formName: "",
      defFormTitle: "",
      widgetPropTab: "",
      widgetFormTab: "",
      error: {
        wdFormUni: "",
        wdSubUni: ""
      },
      styleSetting: {
        btn: "",
        title: "",
        layoutTitle: "",
        verticalLayout: "",
        horizontalLayout: "",
        styleTitle: "",
        boldTitle: "",
        fontBold: "",
        fontNormal: "",
        colonTitle: "",
        colonVisible: "",
        colonHidden: "",
        alignTitle: "",
        widthTitle: "",
        alignLeft: "",
        alignRight: "",
        unitPx: "",
        unitPct: ""
      },
      widget: {
        group: {
          base: "",
          layout: "",
          system: "",
          module: "",
          chart: "",
          advanced: ""
        },
        copyTitle: "_{0}",
        component: {
          input: "",
          textarea: "",
          select: "",
          row: "",
          title: "",
          text: "",
          subtable: "",
          VxeSwitch: "/",
          VxeInput: "",
          VxeNumberInput: "",
          VxeDatePicker: "",
          VxeTextarea: "",
          VxeSelect: "",
          VxeTreeSelect: "",
          VxeRadioGroup: "",
          VxeCheckboxGroup: "",
          VxeUploadFile: "",
          VxeUploadImage: "",
          VxeRate: "",
          VxeSlider: ""
        }
      },
      widgetProp: {
        name: "",
        placeholder: "",
        required: "",
        multiple: "",
        displaySetting: {
          name: "",
          pc: "",
          mobile: "",
          visible: "",
          hidden: ""
        },
        dataSource: {
          name: "",
          defValue: "{0}",
          addOption: "",
          batchEditOption: "",
          batchEditTip: "ExcelWPS ",
          batchEditSubTip: "ExcelWPS ",
          buildOption: ""
        },
        rowProp: {
          colSize: "",
          col2: "",
          col3: "",
          col4: "",
          col6: "",
          layout: ""
        },
        textProp: {
          name: "",
          alignTitle: "",
          alignLeft: "",
          alignCenter: "",
          alignRight: "",
          colorTitle: "",
          sizeTitle: "",
          boldTitle: "",
          fontNormal: "",
          fontBold: ""
        },
        subtableProp: {
          seqTitle: "",
          showSeq: "",
          showCheckbox: "",
          errSubDrag: "",
          colPlace: ""
        },
        uploadProp: {
          limitFileCount: "",
          limitFileSize: "",
          multiFile: "",
          limitImgCount: "",
          limitImgSize: "",
          multiImg: ""
        }
      }
    },
    listDesign: {
      fieldSettingTab: "",
      listSettingTab: "",
      searchTitle: "",
      listTitle: "",
      searchField: "",
      listField: "",
      activeBtn: {
        ActionButtonUpdate: "",
        ActionButtonDelete: ""
      },
      search: {
        addBtn: "",
        emptyText: "",
        editPopupTitle: ""
      },
      searchPopup: {
        colTitle: "",
        saveBtn: ""
      }
    },
    text: {
      copySuccess: "",
      copyError: ""
    },
    countdown: {
      formats: {
        yyyy: "",
        MM: "",
        dd: "",
        HH: "",
        mm: "",
        ss: ""
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "",
          multiErr: "",
          selectErr: "",
          extendErr: "",
          pasteMultiErr: "",
          cpInvalidErr: "{0}"
        },
        fnr: {
          title: "",
          findLabel: "",
          replaceLabel: "",
          findTitle: "",
          replaceTitle: "",
          tabs: {
            find: "",
            replace: ""
          },
          filter: {
            re: "",
            whole: "",
            sensitive: ""
          },
          btns: {
            findNext: "",
            findAll: "",
            replace: "",
            replaceAll: "",
            cancel: ""
          },
          header: {
            seq: "#",
            cell: "",
            value: ""
          },
          empty: "()",
          reError: "",
          recordCount: " {0} ",
          notCell: "",
          replaceSuccess: " {0} "
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: ""
        },
        cases: {
          equal: "",
          gt: "",
          lt: "",
          begin: "",
          endin: "",
          include: "",
          isSensitive: ""
        }
      },
      filterCombination: {
        menus: {
          clearSort: "",
          sortAsc: "",
          sortDesc: "",
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: "",
          clearFilter: "",
          textOption: "",
          numberOption: ""
        },
        popup: {
          title: "",
          currColumnTitle: "",
          and: "",
          or: "",
          describeHtml: " ? <br/> * "
        },
        cases: {
          equal: "",
          unequal: "",
          gt: "",
          ge: "",
          lt: "",
          le: "",
          begin: "",
          notbegin: "",
          endin: "",
          notendin: "",
          include: "",
          exclude: "",
          between: "",
          custom: "",
          insensitive: "",
          isSensitive: ""
        },
        empty: "()",
        notData: ""
      }
    },
    pro: {
      area: {
        mergeErr: "",
        multiErr: "",
        extendErr: "",
        pasteMultiErr: ""
      },
      fnr: {
        title: "",
        findLabel: "",
        replaceLabel: "",
        findTitle: "",
        replaceTitle: "",
        tabs: {
          find: "",
          replace: ""
        },
        filter: {
          re: "",
          whole: "",
          sensitive: ""
        },
        btns: {
          findNext: "",
          findAll: "",
          replace: "",
          replaceAll: "",
          cancel: ""
        },
        header: {
          seq: "#",
          cell: "",
          value: ""
        },
        empty: "()",
        reError: "",
        recordCount: " {0} ",
        notCell: "",
        replaceSuccess: " {0} "
      }
    },
    renderer: {
      search: "",
      cases: {
        equal: "",
        unequal: "",
        gt: "",
        ge: "",
        lt: "",
        le: "",
        begin: "",
        notbegin: "",
        endin: "",
        notendin: "",
        include: "",
        exclude: "",
        between: "",
        custom: "",
        insensitive: "",
        isSensitive: ""
      },
      combination: {
        menus: {
          clearSort: "",
          sortAsc: "",
          sortDesc: "",
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: "",
          clearFilter: "",
          textOption: "",
          numberOption: ""
        },
        popup: {
          title: "",
          currColumnTitle: "",
          and: "",
          or: "",
          describeHtml: " ? <br/> * "
        },
        empty: "()",
        notData: ""
      }
    }
  }
};

// node_modules/vxe-table/es/components.js
var components2 = [
  VxeColumn,
  VxeColgroup,
  VxeGrid,
  VxeTable,
  VxeToolbar
];
function install(app, options) {
  VxeUI.setConfig(options);
  components2.forEach((component2) => component2.install(app));
}
if (!VxeUI.hasLanguage("zh-CN")) {
  const defaultLanguage2 = "zh-CN";
  VxeUI.setI18n(defaultLanguage2, zh_CN_default);
  VxeUI.setLanguage(defaultLanguage2);
}
VxeUI.setTheme("light");

// node_modules/vxe-table/es/index.esm.js
var index_esm_default2 = components_exports;

// node_modules/@ksware/ksw-ux/kingsware-ui/index.js
var import_chinese_lunar_calendar = __toESM(require_lunar_calendar());

// node_modules/vxe-pc-ui/es/components.js
var components_exports2 = {};
__export(components_exports2, {
  Alert: () => Alert,
  Anchor: () => Anchor,
  AnchorLink: () => AnchorLink,
  Avatar: () => Avatar,
  Badge: () => Badge,
  Breadcrumb: () => Breadcrumb,
  BreadcrumbItem: () => BreadcrumbItem,
  Button: () => Button,
  ButtonGroup: () => ButtonGroup,
  Calendar: () => Calendar,
  Card: () => Card,
  Carousel: () => Carousel,
  CarouselItem: () => CarouselItem,
  Checkbox: () => Checkbox,
  CheckboxGroup: () => CheckboxGroup,
  Col: () => Col,
  Collapse: () => Collapse,
  CollapsePane: () => CollapsePane,
  ColorPicker: () => ColorPicker,
  Countdown: () => Countdown,
  DatePicker: () => DatePicker,
  Drawer: () => Drawer,
  DrawerController: () => DrawerController,
  Empty: () => Empty,
  Form: () => Form,
  FormDesign: () => FormDesign,
  FormGather: () => FormGather,
  FormGroup: () => FormGroup,
  FormItem: () => FormItem,
  FormView: () => FormView,
  GLOBAL_EVENT_KEYS: () => GLOBAL_EVENT_KEYS,
  Icon: () => Icon,
  IconPicker: () => IconPicker,
  Image: () => Image2,
  ImageGroup: () => ImageGroup,
  ImagePreview: () => ImagePreview,
  Input: () => Input,
  LayoutAside: () => LayoutAside,
  LayoutBody: () => LayoutBody,
  LayoutContainer: () => LayoutContainer,
  LayoutFooter: () => LayoutFooter,
  LayoutHeader: () => LayoutHeader,
  Link: () => Link,
  List: () => List,
  ListDesign: () => ListDesign,
  ListView: () => ListView,
  Loading: () => Loading2,
  LoadingController: () => LoadingController,
  Menu: () => Menu,
  Modal: () => Modal,
  ModalController: () => ModalController,
  NoticeBar: () => NoticeBar,
  NumberInput: () => NumberInput,
  Optgroup: () => Optgroup,
  Option: () => Option2,
  Pager: () => Pager,
  PasswordInput: () => PasswordInput,
  Print: () => Print,
  PrintPageBreak: () => PrintPageBreak,
  Pulldown: () => Pulldown,
  Radio: () => Radio,
  RadioButton: () => RadioButton,
  RadioGroup: () => RadioGroup,
  Rate: () => Rate,
  Result: () => Result,
  Row: () => Row,
  Select: () => Select,
  Slider: () => Slider,
  Steps: () => Steps,
  Switch: () => Switch,
  TabPane: () => TabPane,
  TableSelect: () => TableSelect,
  Tabs: () => Tabs,
  Tag: () => Tag,
  Text: () => Text2,
  TextEllipsis: () => TextEllipsis,
  Textarea: () => Textarea,
  Tip: () => Tip,
  Tips: () => Tips,
  Tooltip: () => Tooltip,
  Tree: () => Tree,
  TreeSelect: () => TreeSelect,
  Upload: () => Upload,
  VxeAlert: () => VxeAlert,
  VxeAnchor: () => VxeAnchor,
  VxeAnchorLink: () => VxeAnchorLink,
  VxeAvatar: () => VxeAvatar,
  VxeBadge: () => VxeBadge,
  VxeBreadcrumb: () => VxeBreadcrumb,
  VxeBreadcrumbItem: () => VxeBreadcrumbItem,
  VxeButton: () => VxeButton,
  VxeButtonGroup: () => VxeButtonGroup,
  VxeCalendar: () => VxeCalendar,
  VxeCard: () => VxeCard,
  VxeCarousel: () => VxeCarousel,
  VxeCarouselItem: () => VxeCarouselItem,
  VxeCheckbox: () => VxeCheckbox,
  VxeCheckboxGroup: () => VxeCheckboxGroup,
  VxeCol: () => VxeCol,
  VxeCollapse: () => VxeCollapse,
  VxeCollapsePane: () => VxeCollapsePane,
  VxeColorPicker: () => VxeColorPicker,
  VxeCore: () => VxeCore,
  VxeCountdown: () => VxeCountdown,
  VxeDatePicker: () => VxeDatePicker,
  VxeDrawer: () => VxeDrawer,
  VxeEmpty: () => VxeEmpty,
  VxeForm: () => VxeForm,
  VxeFormDesign: () => VxeFormDesign,
  VxeFormGather: () => VxeFormGather,
  VxeFormGroup: () => VxeFormGroup,
  VxeFormItem: () => VxeFormItem,
  VxeFormView: () => VxeFormView,
  VxeIcon: () => VxeIcon,
  VxeIconPicker: () => VxeIconPicker,
  VxeImage: () => VxeImage,
  VxeImageGroup: () => VxeImageGroup,
  VxeImagePreview: () => VxeImagePreview,
  VxeInput: () => VxeInput,
  VxeLayoutAside: () => VxeLayoutAside,
  VxeLayoutBody: () => VxeLayoutBody,
  VxeLayoutContainer: () => VxeLayoutContainer,
  VxeLayoutFooter: () => VxeLayoutFooter,
  VxeLayoutHeader: () => VxeLayoutHeader,
  VxeLink: () => VxeLink,
  VxeList: () => VxeList,
  VxeListDesign: () => VxeListDesign,
  VxeListView: () => VxeListView,
  VxeLoading: () => VxeLoading,
  VxeMenu: () => VxeMenu,
  VxeModal: () => VxeModal,
  VxeNoticeBar: () => VxeNoticeBar,
  VxeNumberInput: () => VxeNumberInput,
  VxeOptgroup: () => VxeOptgroup,
  VxeOption: () => VxeOption,
  VxePager: () => VxePager,
  VxePasswordInput: () => VxePasswordInput,
  VxePrint: () => VxePrint,
  VxePrintPageBreak: () => VxePrintPageBreak,
  VxePulldown: () => VxePulldown,
  VxeRadio: () => VxeRadio,
  VxeRadioButton: () => VxeRadioButton,
  VxeRadioGroup: () => VxeRadioGroup,
  VxeRate: () => VxeRate,
  VxeResult: () => VxeResult,
  VxeRow: () => VxeRow,
  VxeSelect: () => VxeSelect,
  VxeSlider: () => VxeSlider,
  VxeSteps: () => VxeSteps,
  VxeSwitch: () => VxeSwitch,
  VxeTabPane: () => VxeTabPane,
  VxeTableSelect: () => VxeTableSelect,
  VxeTabs: () => VxeTabs,
  VxeTag: () => VxeTag,
  VxeText: () => VxeText,
  VxeTextEllipsis: () => VxeTextEllipsis,
  VxeTextarea: () => VxeTextarea,
  VxeTip: () => VxeTip,
  VxeTooltip: () => VxeTooltip,
  VxeTree: () => VxeTree,
  VxeTreeSelect: () => VxeTreeSelect,
  VxeUI: () => VxeUI,
  VxeUpload: () => VxeUpload,
  VxeWatermark: () => VxeWatermark,
  Watermark: () => Watermark,
  WatermarkController: () => WatermarkController,
  clipboard: () => clipboard,
  commands: () => commands,
  component: () => component,
  config: () => config2,
  coreVersion: () => coreVersion,
  createEvent: () => createEvent,
  drawer: () => drawer,
  formats: () => formats,
  getComponent: () => getComponent,
  getConfig: () => getConfig,
  getI18n: () => getI18n,
  getIcon: () => getIcon,
  getLanguage: () => getLanguage,
  getTheme: () => getTheme,
  globalEvents: () => globalEvents,
  globalResize: () => globalResize,
  globalStore: () => globalStore,
  handleCheckInfo: () => handleCheckInfo,
  hasLanguage: () => hasLanguage,
  hooks: () => hooks,
  install: () => install2,
  interceptor: () => interceptor,
  loading: () => loading,
  log: () => log,
  menus: () => menus,
  modal: () => modal2,
  permission: () => permission,
  print: () => print2,
  readFile: () => readFile2,
  renderEmptyElement: () => renderEmptyElement,
  renderer: () => renderer,
  saveFile: () => saveFile2,
  setConfig: () => setConfig,
  setI18n: () => setI18n,
  setIcon: () => setIcon,
  setLanguage: () => setLanguage,
  setTheme: () => setTheme,
  setup: () => setup2,
  use: () => use,
  useFns: () => useFns,
  usePermission: () => usePermission,
  useSize: () => useSize,
  validators: () => validators,
  version: () => version6,
  watermark: () => watermark
});

// node_modules/vxe-pc-ui/es/language/zh-CN.js
var zh_CN_default2 = {
  vxe: {
    base: {
      pleaseInput: "",
      pleaseSelect: "",
      comma: "",
      fullStop: ""
    },
    loading: {
      text: "..."
    },
    error: {
      downErr: "",
      groupFixed: "",
      groupMouseRange: ' "{0}" ',
      groupTag: ' "{0}"  "{1}"',
      scrollErrProp: ' "{0}"',
      errConflicts: ' "{0}"  "{1}" ',
      unableInsert: "",
      useErr: ' "{0}"  Table ',
      barUnableLink: "",
      expandContent: ' "content"',
      reqComp: ' "{0}"  https://vxeui.com/#/start/useGlobal',
      reqModule: ' "{0}" ',
      reqProp: ' "{0}" ',
      emptyProp: ' "{0}" ',
      errProp: ' "{0}" "{1}"',
      colRepet: 'column.{0}="{1}" ',
      notFunc: ' "{0}" ',
      errFunc: ' "{0}" ',
      notValidators: ' "{0}" ',
      notFormats: ' "{0}" ',
      notCommands: ' "{0}" ',
      notSlot: ' "{0}" ',
      noTree: ' "{0}"',
      notProp: ' "{0}"',
      checkProp: ' "{0}" ',
      coverProp: '"{0}"  "{1}" ',
      uniField: ' "{0}" ',
      repeatKey: ' {0}="{1}"',
      delFunc: ' "{0}"  "{1}"',
      delProp: ' "{0}"  "{1}"',
      delEvent: ' "{0}"  "{1}"',
      removeProp: ' "{0}" ',
      errFormat: ' "VXETable.formats"  "formatter={0}" ',
      notType: ' "{0}"',
      notExp: "/",
      impFields: "",
      treeNotImp: "",
      treeCrossDrag: "",
      treeDragChild: "",
      reqPlugin: ' "{1}" https://vxeui.com/other{0}/#/{1}/install'
    },
    table: {
      emptyText: "",
      allTitle: "/",
      seqTitle: "",
      actionTitle: "",
      confirmFilter: "",
      resetFilter: "",
      allFilter: "",
      sortAsc: "",
      sortDesc: "",
      filter: "",
      impSuccess: " {0} ",
      expLoading: "",
      expSuccess: "",
      expError: "",
      expFilename: "_{0}",
      expOriginFilename: "__{0}",
      customTitle: "",
      customAll: "",
      customConfirm: "",
      customClose: "",
      customCancel: "",
      customRestore: "",
      maxFixedCol: " {0} ",
      dragTip: "{0}"
    },
    grid: {
      selectOneRecord: "",
      deleteSelectRecord: "",
      removeSelectRecord: "",
      dataUnchanged: "",
      delSuccess: "",
      saveSuccess: "",
      operError: ""
    },
    select: {
      search: "",
      loadingText: "",
      emptyText: ""
    },
    pager: {
      goto: "",
      gotoTitle: "",
      pagesize: "{0}/",
      total: " {0} ",
      pageClassifier: "",
      homePage: "",
      homePageTitle: "",
      prevPage: "",
      prevPageTitle: "",
      nextPage: "",
      nextPageTitle: "",
      prevJump: "",
      prevJumpTitle: "",
      nextJump: "",
      nextJumpTitle: "",
      endPage: "",
      endPageTitle: ""
    },
    alert: {
      title: ""
    },
    button: {
      confirm: "",
      cancel: ""
    },
    filter: {
      search: ""
    },
    custom: {
      cstmTitle: "",
      cstmRestore: "",
      cstmCancel: "",
      cstmConfirm: "",
      cstmConfirmRestore: "",
      cstmDragTarget: "{0}",
      setting: {
        colSort: "",
        sortHelpTip: "",
        colTitle: "",
        colResizable: "",
        colVisible: "",
        colFixed: "",
        colFixedMax: " {0} ",
        fixedLeft: "",
        fixedUnset: "",
        fixedRight: ""
      }
    },
    import: {
      modes: {
        covering: "",
        insert: "",
        insertTop: "",
        insertBottom: ""
      },
      impTitle: "",
      impFile: "",
      impSelect: "",
      impType: "",
      impOpts: "",
      impMode: "",
      impConfirm: "",
      impCancel: ""
    },
    export: {
      types: {
        csv: "CSV ()(*.csv)",
        html: "(*.html)",
        xml: "XML (*.xml)",
        txt: "()(*.txt)",
        xls: "Excel 97-2003 (*.xls)",
        xlsx: "Excel (*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "",
        selected: "",
        all: ""
      },
      printTitle: "",
      expTitle: "",
      expName: "",
      expNamePlaceholder: "",
      expSheetName: "",
      expSheetNamePlaceholder: "",
      expType: "",
      expMode: "",
      expCurrentColumn: "",
      expColumn: "",
      expOpts: "",
      expOptHeader: "",
      expHeaderTitle: "",
      expOptFooter: "",
      expFooterTitle: "",
      expOptColgroup: "",
      expColgroupTitle: "",
      expOptMerge: "",
      expMergeTitle: "",
      expOptAllExpand: "",
      expAllExpandTitle: "",
      expOptUseStyle: "",
      expUseStyleTitle: "",
      expOptOriginal: "",
      expOriginalTitle: "",
      expPrint: "",
      expConfirm: "",
      expCancel: ""
    },
    modal: {
      errTitle: "",
      zoomMin: "",
      zoomIn: "",
      zoomOut: "",
      close: "",
      miniMaxSize: " {0} ",
      footPropErr: "show-footer  show-confirm-button | show-cancel-button | "
    },
    drawer: {
      close: ""
    },
    form: {
      folding: "",
      unfolding: ""
    },
    toolbar: {
      import: "",
      export: "",
      print: "",
      refresh: "",
      zoomIn: "",
      zoomOut: "",
      custom: "",
      customAll: "",
      customConfirm: "",
      customRestore: "",
      fixedLeft: "",
      fixedRight: "",
      cancelFixed: ""
    },
    input: {
      date: {
        m1: "01 ",
        m2: "02 ",
        m3: "03 ",
        m4: "04 ",
        m5: "05 ",
        m6: "06 ",
        m7: "07 ",
        m8: "08 ",
        m9: "09 ",
        m10: "10 ",
        m11: "11 ",
        m12: "12 ",
        quarterLabel: "{0} ",
        monthLabel: "{0} ",
        dayLabel: "{0}  {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy  WW ",
          month: "yyyy-MM",
          quarter: "yyyy  q ",
          year: "yyyy"
        },
        weeks: {
          w: "",
          w0: "",
          w1: "",
          w2: "",
          w3: "",
          w4: "",
          w5: "",
          w6: ""
        },
        months: {
          m0: "",
          m1: "",
          m2: "",
          m3: "",
          m4: "",
          m5: "",
          m6: "",
          m7: "",
          m8: "",
          m9: "",
          m10: "",
          m11: ""
        },
        quarters: {
          q1: "",
          q2: "",
          q3: "",
          q4: ""
        }
      }
    },
    numberInput: {
      currencySymbol: ""
    },
    imagePreview: {
      popupTitle: "",
      operBtn: {
        zoomOut: "",
        zoomIn: "",
        pctFull: "",
        pct11: "",
        rotateLeft: "",
        rotateRight: "",
        print: "",
        download: ""
      }
    },
    upload: {
      fileBtnText: "",
      imgBtnText: "",
      dragPlaceholder: "",
      imgSizeHint: "{0}",
      imgCountHint: "{0}",
      fileTypeHint: " {0} ",
      fileSizeHint: "{0}",
      fileCountHint: "{0}",
      uploadTypeErr: "",
      overCountErr: "{0}",
      overCountExtraErr: "{0}{1}",
      overSizeErr: "{0}",
      reUpload: "",
      uploadProgress: " {0}%",
      uploadErr: "",
      uploadSuccess: "",
      moreBtnText: "{0}",
      viewItemTitle: "",
      morePopup: {
        readTitle: "",
        imageTitle: "",
        fileTitle: ""
      }
    },
    empty: {
      defText: ""
    },
    formDesign: {
      formName: "",
      defFormTitle: "",
      widgetPropTab: "",
      widgetFormTab: "",
      error: {
        wdFormUni: "",
        wdSubUni: ""
      },
      styleSetting: {
        btn: "",
        title: "",
        layoutTitle: "",
        verticalLayout: "",
        horizontalLayout: "",
        styleTitle: "",
        boldTitle: "",
        fontBold: "",
        fontNormal: "",
        colonTitle: "",
        colonVisible: "",
        colonHidden: "",
        alignTitle: "",
        widthTitle: "",
        alignLeft: "",
        alignRight: "",
        unitPx: "",
        unitPct: ""
      },
      widget: {
        group: {
          base: "",
          layout: "",
          system: "",
          module: "",
          chart: "",
          advanced: ""
        },
        copyTitle: "_{0}",
        component: {
          input: "",
          textarea: "",
          select: "",
          row: "",
          title: "",
          text: "",
          subtable: "",
          VxeSwitch: "/",
          VxeInput: "",
          VxeNumberInput: "",
          VxeDatePicker: "",
          VxeTextarea: "",
          VxeSelect: "",
          VxeTreeSelect: "",
          VxeRadioGroup: "",
          VxeCheckboxGroup: "",
          VxeUploadFile: "",
          VxeUploadImage: "",
          VxeRate: "",
          VxeSlider: ""
        }
      },
      widgetProp: {
        name: "",
        placeholder: "",
        required: "",
        multiple: "",
        displaySetting: {
          name: "",
          pc: "",
          mobile: "",
          visible: "",
          hidden: ""
        },
        dataSource: {
          name: "",
          defValue: "{0}",
          addOption: "",
          batchEditOption: "",
          batchEditTip: "ExcelWPS ",
          batchEditSubTip: "ExcelWPS ",
          buildOption: ""
        },
        rowProp: {
          colSize: "",
          col2: "",
          col3: "",
          col4: "",
          col6: "",
          layout: ""
        },
        textProp: {
          name: "",
          alignTitle: "",
          alignLeft: "",
          alignCenter: "",
          alignRight: "",
          colorTitle: "",
          sizeTitle: "",
          boldTitle: "",
          fontNormal: "",
          fontBold: ""
        },
        subtableProp: {
          seqTitle: "",
          showSeq: "",
          showCheckbox: "",
          errSubDrag: "",
          colPlace: ""
        },
        uploadProp: {
          limitFileCount: "",
          limitFileSize: "",
          multiFile: "",
          limitImgCount: "",
          limitImgSize: "",
          multiImg: ""
        }
      }
    },
    listDesign: {
      fieldSettingTab: "",
      listSettingTab: "",
      searchTitle: "",
      listTitle: "",
      searchField: "",
      listField: "",
      activeBtn: {
        ActionButtonUpdate: "",
        ActionButtonDelete: ""
      },
      search: {
        addBtn: "",
        emptyText: "",
        editPopupTitle: ""
      },
      searchPopup: {
        colTitle: "",
        saveBtn: ""
      }
    },
    text: {
      copySuccess: "",
      copyError: ""
    },
    countdown: {
      formats: {
        yyyy: "",
        MM: "",
        dd: "",
        HH: "",
        mm: "",
        ss: ""
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "",
          multiErr: "",
          selectErr: "",
          extendErr: "",
          pasteMultiErr: "",
          cpInvalidErr: "{0}"
        },
        fnr: {
          title: "",
          findLabel: "",
          replaceLabel: "",
          findTitle: "",
          replaceTitle: "",
          tabs: {
            find: "",
            replace: ""
          },
          filter: {
            re: "",
            whole: "",
            sensitive: ""
          },
          btns: {
            findNext: "",
            findAll: "",
            replace: "",
            replaceAll: "",
            cancel: ""
          },
          header: {
            seq: "#",
            cell: "",
            value: ""
          },
          empty: "()",
          reError: "",
          recordCount: " {0} ",
          notCell: "",
          replaceSuccess: " {0} "
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: ""
        },
        cases: {
          equal: "",
          gt: "",
          lt: "",
          begin: "",
          endin: "",
          include: "",
          isSensitive: ""
        }
      },
      filterCombination: {
        menus: {
          clearSort: "",
          sortAsc: "",
          sortDesc: "",
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: "",
          clearFilter: "",
          textOption: "",
          numberOption: ""
        },
        popup: {
          title: "",
          currColumnTitle: "",
          and: "",
          or: "",
          describeHtml: " ? <br/> * "
        },
        cases: {
          equal: "",
          unequal: "",
          gt: "",
          ge: "",
          lt: "",
          le: "",
          begin: "",
          notbegin: "",
          endin: "",
          notendin: "",
          include: "",
          exclude: "",
          between: "",
          custom: "",
          insensitive: "",
          isSensitive: ""
        },
        empty: "()",
        notData: ""
      }
    },
    pro: {
      area: {
        mergeErr: "",
        multiErr: "",
        extendErr: "",
        pasteMultiErr: ""
      },
      fnr: {
        title: "",
        findLabel: "",
        replaceLabel: "",
        findTitle: "",
        replaceTitle: "",
        tabs: {
          find: "",
          replace: ""
        },
        filter: {
          re: "",
          whole: "",
          sensitive: ""
        },
        btns: {
          findNext: "",
          findAll: "",
          replace: "",
          replaceAll: "",
          cancel: ""
        },
        header: {
          seq: "#",
          cell: "",
          value: ""
        },
        empty: "()",
        reError: "",
        recordCount: " {0} ",
        notCell: "",
        replaceSuccess: " {0} "
      }
    },
    renderer: {
      search: "",
      cases: {
        equal: "",
        unequal: "",
        gt: "",
        ge: "",
        lt: "",
        le: "",
        begin: "",
        notbegin: "",
        endin: "",
        notendin: "",
        include: "",
        exclude: "",
        between: "",
        custom: "",
        insensitive: "",
        isSensitive: ""
      },
      combination: {
        menus: {
          clearSort: "",
          sortAsc: "",
          sortDesc: "",
          fixedColumn: "",
          fixedGroup: "",
          cancelFixed: "",
          fixedLeft: "",
          fixedRight: "",
          clearFilter: "",
          textOption: "",
          numberOption: ""
        },
        popup: {
          title: "",
          currColumnTitle: "",
          and: "",
          or: "",
          describeHtml: " ? <br/> * "
        },
        empty: "()",
        notData: ""
      }
    }
  }
};

// node_modules/vxe-pc-ui/es/alert/src/alert.js
var import_xe_utils41 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/dynamics/index.js
var dynamicContainerElem;
var dynamicStore = reactive({
  modals: [],
  drawers: [],
  globalLoading: null,
  globalWatermark: null
});
var VxeDynamics = defineComponent({
  setup() {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIDrawerComponent = VxeUI.getComponent("VxeDrawer");
    const VxeUILoadingComponent = VxeUI.getComponent("VxeLoading");
    const VxeUIWatermarkComponent = VxeUI.getComponent("VxeWatermark");
    return () => {
      const { modals, drawers, globalWatermark, globalLoading } = dynamicStore;
      return [
        modals.length ? h("div", {
          key: 1,
          class: "vxe-dynamics--modal"
        }, modals.map((item) => h(VxeUIModalComponent, item))) : createCommentVNode(),
        drawers.length ? h("div", {
          key: 2,
          class: "vxe-dynamics--drawer"
        }, drawers.map((item) => h(VxeUIDrawerComponent, item))) : createCommentVNode(),
        globalWatermark ? h(VxeUIWatermarkComponent, globalWatermark) : createCommentVNode(),
        globalLoading ? h(VxeUILoadingComponent, globalLoading) : createCommentVNode()
      ];
    };
  }
});
var dynamicApp = createApp(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement("div");
    dynamicContainerElem.className = "vxe-dynamics";
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}

// node_modules/vxe-pc-ui/es/ui/src/utils.js
var import_xe_utils39 = __toESM(require_xe_utils());
function isEnableConf2(conf) {
  return conf && conf.enabled !== false;
}
function nextZIndex2() {
  return index_esm_default.getNext();
}
function getLastZIndex2() {
  return index_esm_default.getCurrent();
}
function getFuncText2(content, args) {
  if (content) {
    const translate2 = getConfig().translate;
    return import_xe_utils39.default.toValueString(translate2 ? translate2("" + content, args) : content);
  }
  return "";
}
function eqEmptyValue2(cellValue) {
  return cellValue === null || cellValue === void 0 || cellValue === "";
}
function handleBooleanDefaultValue(value) {
  return import_xe_utils39.default.isBoolean(value) ? value : null;
}

// node_modules/vxe-pc-ui/es/ui/src/log.js
var version5 = `ui v${"4.3.36"}`;
var warnLog2 = log.create("warn", version5);
var errLog2 = log.create("error", version5);

// node_modules/vxe-pc-ui/es/ui/index.js
var version6 = "4.3.36";
VxeUI.version = version6;
VxeUI.uiVersion = version6;
VxeUI.tableVersion = "";
VxeUI.t = VxeUI.getI18n;
VxeUI._t = getFuncText2;
VxeUI.dynamicApp = dynamicApp;
function config2(options) {
  if (true) {
    warnLog2("vxe.error.delFunc", ["config", "setConfig"]);
  }
  return setConfig(options);
}
function setup2(options) {
  if (true) {
    warnLog2("vxe.error.delFunc", ["setup", "setConfig"]);
  }
  return setConfig(options);
}
VxeUI.config = config2;
VxeUI.setup = setup2;
setConfig({
  alert: {},
  anchor: {},
  anchorLink: {},
  avatar: {},
  badge: {},
  breadcrumb: {
    separator: "/"
  },
  breadcrumbItem: {},
  button: {
    trigger: "hover",
    prefixTooltip: {
      enterable: true
    },
    suffixTooltip: {
      enterable: true
    }
  },
  buttonGroup: {},
  calendar: {
    minDate: new Date(1900, 0, 1),
    maxDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  card: {
    border: true,
    padding: true
  },
  carousel: {
    height: 200,
    loop: true,
    interval: 5e3
  },
  carouselItem: {},
  checkbox: {},
  checkboxGroup: {},
  col: {},
  collapse: {
    padding: true,
    expandConfig: {
      showIcon: true
    }
  },
  collapsePane: {},
  countdown: {},
  datePicker: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  drawer: {
    // size: null,
    position: "right",
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true,
    padding: true,
    cancelClosable: true,
    confirmClosable: true
  },
  empty: {},
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: true,
      autoPos: true,
      theme: "beautify"
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true,
    titleOverflow: false,
    padding: true
  },
  formDesign: {
    height: 400,
    showHeader: true,
    showPc: true
  },
  formGather: {},
  formGroup: {},
  formItem: {},
  formView: {},
  icon: {},
  iconPicker: {
    icons: ["home", "company", "comment", "setting", "send", "envelope", "envelope-open", "bell", "search", "print", "pc", "goods", "chart-line", "edit", "delete", "save", "folder", "microphone", "flag", "link", "location", "sunny", "rmb", "usd", "user", "add-user", "add-users", "star", "unlock", "time", "text", "feedback", "calendar", "association-form", "cloud-download", "cloud-upload", "file", "subtable", "chart-bar-x", "chart-bar-y", "chart-line", "chart-pie", "chart-radar"]
  },
  image: {
    showPreview: true,
    showPrintButton: true,
    maskClosable: true
  },
  imageGroup: {
    showPreview: true,
    showPrintButton: true
  },
  imagePreview: {
    showPrintButton: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  layoutAside: {},
  layoutBody: {},
  layoutContainer: {},
  layoutFooter: {},
  layoutHeader: {},
  link: {
    underline: true
  },
  listDesign: {
    height: 400,
    showPc: true
  },
  listView: {},
  list: {
    // size: null,
    scrollY: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  loading: {
    showIcon: true,
    showText: true
  },
  modal: {
    // size: null,
    top: 16,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3e3,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    padding: true,
    draggable: true,
    showConfirmButton: null,
    cancelClosable: true,
    confirmClosable: true,
    zoomConfig: {
      minimizeMaxSize: 10,
      minimizeVerticalOffset: {
        top: -24,
        left: 0
      },
      minimizeHorizontalOffset: {
        top: 0,
        left: 32
      }
    },
    // storage: false,
    storageKey: "VXE_MODAL_POSITION"
  },
  noticeBar: {},
  numberInput: {
    // size: null,
    // transfer: false
    digits: 2,
    controls: true
  },
  optgroup: {},
  option: {},
  pager: {
    pageSizePlacement: "top"
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  print: {},
  passwordInput: {
    controls: true
  },
  printPageBreak: {},
  pulldown: {
    destroyOnClose: true
  },
  radio: {
    strict: true
  },
  radioButton: {
    strict: true
  },
  radioGroup: {
    strict: true
  },
  rate: {},
  result: {},
  row: {},
  select: {
    multiCharOverflow: 8,
    scrollY: {
      enabled: true,
      gt: 100,
      oSize: 2
    }
  },
  slider: {
    max: 100,
    min: 0
  },
  steps: {},
  switch: {},
  tabPane: {},
  tableSelect: {
    gridConfig: {
      showOverflow: true,
      showHeaderOverflow: true,
      showFooterOverflow: true,
      rowConfig: {
        isHover: true
      },
      scrollX: {
        enabled: true,
        gt: 0
      },
      scrollY: {
        mode: "wheel",
        enabled: true,
        gt: 0
      }
    }
  },
  tabs: {},
  tag: {},
  textEllipsis: {},
  text: {},
  textarea: {
    resize: "none"
  },
  tip: {},
  tooltip: {
    // size: null,
    // enterable: false,
    trigger: "hover",
    theme: "dark",
    enterDelay: 500,
    leaveDelay: 300,
    isArrow: true
  },
  tree: {
    indent: 20,
    minHeight: 60,
    radioConfig: {
      strict: true
    }
  },
  treeSelect: {
    treeConfig: {
      radioConfig: {},
      checkboxConfig: {}
    }
  },
  upload: {
    mode: "all",
    imageTypes: ["jpg", "jpeg", "png", "gif"],
    showList: true,
    showUploadButton: true,
    showButtonText: true,
    showRemoveButton: true,
    showButtonIcon: true,
    showPreview: true,
    dragToUpload: true
    // imageConfig: {}
  },
  watermark: {
    rotate: -30,
    gap: [100, 100]
  },
  table: {},
  colgroup: {},
  column: {},
  toolbar: {},
  grid: {}
});
var iconPrefix2 = "vxe-icon-";
setIcon({
  // loading
  LOADING: iconPrefix2 + "spinner roll vxe-loading--default-icon",
  // button
  BUTTON_DROPDOWN: iconPrefix2 + "arrow-down",
  BUTTON_LOADING: iconPrefix2 + "spinner roll",
  BUTTON_TOOLTIP_ICON: iconPrefix2 + "question-circle-fill",
  // menu
  MENU_ITEM_EXPAND_OPEN: iconPrefix2 + "arrow-down rotate180",
  MENU_ITEM_EXPAND_CLOSE: iconPrefix2 + "arrow-down",
  // select
  SELECT_LOADED: iconPrefix2 + "spinner roll",
  SELECT_OPEN: iconPrefix2 + "caret-down rotate180",
  SELECT_CLOSE: iconPrefix2 + "caret-down",
  // icon-picker
  ICON_PICKER_OPEN: iconPrefix2 + "caret-down rotate180",
  ICON_PICKER_CLOSE: iconPrefix2 + "caret-down",
  // pager
  PAGER_HOME: iconPrefix2 + "home-page",
  PAGER_END: iconPrefix2 + "end-page",
  PAGER_JUMP_PREV: iconPrefix2 + "arrow-double-left",
  PAGER_JUMP_NEXT: iconPrefix2 + "arrow-double-right",
  PAGER_PREV_PAGE: iconPrefix2 + "arrow-left",
  PAGER_NEXT_PAGE: iconPrefix2 + "arrow-right",
  PAGER_JUMP_MORE: iconPrefix2 + "ellipsis-h",
  // radio
  RADIO_CHECKED: iconPrefix2 + "radio-checked-fill",
  RADIO_UNCHECKED: iconPrefix2 + "radio-unchecked",
  // checkbox
  CHECKBOX_INDETERMINATE: iconPrefix2 + "checkbox-indeterminate-fill",
  CHECKBOX_CHECKED: iconPrefix2 + "checkbox-checked-fill",
  CHECKBOX_UNCHECKED: iconPrefix2 + "checkbox-unchecked",
  // input
  INPUT_CLEAR: iconPrefix2 + "error-circle-fill",
  INPUT_SEARCH: iconPrefix2 + "search",
  // number-picker
  NUMBER_INPUT_PREV_NUM: iconPrefix2 + "caret-up",
  NUMBER_INPUT_NEXT_NUM: iconPrefix2 + "caret-down",
  // date-picker
  DATE_PICKER_DATE: iconPrefix2 + "calendar",
  // password-input
  PASSWORD_INPUT_SHOW_PWD: iconPrefix2 + "eye-fill-close",
  PASSWORD_INPUT_HIDE_PWD: iconPrefix2 + "eye-fill",
  // modal
  MODAL_ZOOM_MIN: iconPrefix2 + "minus",
  MODAL_ZOOM_REVERT: iconPrefix2 + "recover",
  MODAL_ZOOM_IN: iconPrefix2 + "square",
  MODAL_ZOOM_OUT: iconPrefix2 + "maximize",
  MODAL_CLOSE: iconPrefix2 + "close",
  MODAL_INFO: iconPrefix2 + "info-circle-fill",
  MODAL_SUCCESS: iconPrefix2 + "success-circle-fill",
  MODAL_WARNING: iconPrefix2 + "warning-circle-fill",
  MODAL_ERROR: iconPrefix2 + "error-circle-fill",
  MODAL_QUESTION: iconPrefix2 + "question-circle-fill",
  MODAL_LOADING: iconPrefix2 + "spinner roll",
  // drawer
  DRAWER_CLOSE: iconPrefix2 + "close",
  // form
  FORM_PREFIX: iconPrefix2 + "question-circle-fill",
  FORM_SUFFIX: iconPrefix2 + "question-circle-fill",
  FORM_FOLDING: iconPrefix2 + "arrow-up rotate180",
  FORM_UNFOLDING: iconPrefix2 + "arrow-up",
  // form-design
  FORM_DESIGN_STYLE_SETTING: iconPrefix2 + "layout",
  FORM_DESIGN_PROPS_PC: iconPrefix2 + "pc",
  FORM_DESIGN_PROPS_MOBILE: iconPrefix2 + "mobile",
  FORM_DESIGN_PROPS_ADD: iconPrefix2 + "add",
  FORM_DESIGN_PROPS_EDIT: iconPrefix2 + "edit",
  FORM_DESIGN_WIDGET_ADD: iconPrefix2 + "square-plus-fill",
  FORM_DESIGN_WIDGET_COPY: iconPrefix2 + "copy",
  FORM_DESIGN_WIDGET_DELETE: iconPrefix2 + "delete",
  FORM_DESIGN_WIDGET_SWAP_LR: iconPrefix2 + "swap",
  FORM_DESIGN_WIDGET_OPTION_DELETE: iconPrefix2 + "delete",
  FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN: iconPrefix2 + "square-plus",
  FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE: iconPrefix2 + "square-minus",
  // list-design
  LIST_DESIGN_FIELD_SETTING: iconPrefix2 + "custom-column",
  LIST_DESIGN_LIST_SETTING: iconPrefix2 + "menu",
  LIST_DESIGN_LIST_SETTING_SEARCH_DELETE: iconPrefix2 + "delete",
  LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE: iconPrefix2 + "delete",
  // upload
  UPLOAD_FILE_ERROR: iconPrefix2 + "warning-circle-fill",
  UPLOAD_FILE_ADD: iconPrefix2 + "upload",
  UPLOAD_FILE_REMOVE: iconPrefix2 + "delete",
  UPLOAD_FILE_DOWNLOAD: iconPrefix2 + "download",
  UPLOAD_IMAGE_RE_UPLOAD: iconPrefix2 + "repeat",
  UPLOAD_IMAGE_ADD: iconPrefix2 + "add",
  UPLOAD_IMAGE_REMOVE: iconPrefix2 + "close",
  UPLOAD_LOADING: iconPrefix2 + "spinner roll vxe-loading--default-icon",
  UPLOAD_FILE_TYPE_DEFAULT: iconPrefix2 + "file",
  UPLOAD_FILE_TYPE_XLSX: iconPrefix2 + "file-excel",
  UPLOAD_FILE_TYPE_XLS: iconPrefix2 + "file-excel",
  UPLOAD_FILE_TYPE_PDF: iconPrefix2 + "file-pdf",
  UPLOAD_FILE_TYPE_PNG: iconPrefix2 + "file-image",
  UPLOAD_FILE_TYPE_GIF: iconPrefix2 + "file-image",
  UPLOAD_FILE_TYPE_JPG: iconPrefix2 + "file-image",
  UPLOAD_FILE_TYPE_JPEG: iconPrefix2 + "file-image",
  UPLOAD_FILE_TYPE_MD: iconPrefix2 + "file-markdown",
  UPLOAD_FILE_TYPE_PPD: iconPrefix2 + "file-ppt",
  UPLOAD_FILE_TYPE_DOCX: iconPrefix2 + "file-word",
  UPLOAD_FILE_TYPE_DOC: iconPrefix2 + "file-word",
  UPLOAD_FILE_TYPE_ZIP: iconPrefix2 + "file-zip",
  UPLOAD_FILE_TYPE_TXT: iconPrefix2 + "file-txt",
  // image-preview
  IMAGE_PREVIEW_CLOSE: iconPrefix2 + "close",
  IMAGE_PREVIEW_PREVIOUS: iconPrefix2 + "arrow-left",
  IMAGE_PREVIEW_NEXT: iconPrefix2 + "arrow-right",
  IMAGE_PREVIEW_PCT_FULL: iconPrefix2 + "pct-full",
  IMAGE_PREVIEW_PCT_1_1: iconPrefix2 + "pct-1-1",
  IMAGE_PREVIEW_ZOOM_OUT: iconPrefix2 + "search-zoom-out",
  IMAGE_PREVIEW_ZOOM_IN: iconPrefix2 + "search-zoom-in",
  IMAGE_PREVIEW_ROTATE_LEFT: iconPrefix2 + "rotate-left",
  IMAGE_PREVIEW_ROTATE_RIGHT: iconPrefix2 + "rotate-right",
  IMAGE_PREVIEW_PRINT: iconPrefix2 + "print",
  IMAGE_PREVIEW_DOWNLOAD: iconPrefix2 + "download",
  // alert
  ALERT_CLOSE: iconPrefix2 + "close",
  ALERT_INFO: iconPrefix2 + "info-circle-fill",
  ALERT_SUCCESS: iconPrefix2 + "success-circle-fill",
  ALERT_WARNING: iconPrefix2 + "warning-circle-fill",
  ALERT_ERROR: iconPrefix2 + "error-circle-fill",
  // tree
  TREE_NODE_OPEN: iconPrefix2 + "caret-right rotate90",
  TREE_NODE_CLOSE: iconPrefix2 + "caret-right",
  TREE_NODE_LOADED: iconPrefix2 + "spinner roll",
  // tree-select
  TREE_SELECT_LOADED: iconPrefix2 + "spinner roll",
  TREE_SELECT_OPEN: iconPrefix2 + "caret-down rotate180",
  TREE_SELECT_CLOSE: iconPrefix2 + "caret-down",
  // table-select
  TABLE_SELECT_LOADED: iconPrefix2 + "spinner roll",
  TABLE_SELECT_OPEN: iconPrefix2 + "caret-down rotate180",
  TABLE_SELECT_CLOSE: iconPrefix2 + "caret-down",
  // tabs
  TABS_TAB_BUTTON_LEFT: iconPrefix2 + "arrow-left",
  TABS_TAB_BUTTON_RIGHT: iconPrefix2 + "arrow-right",
  TABS_TAB_CLOSE: iconPrefix2 + "close",
  TABS_TAB_REFRESH: iconPrefix2 + "refresh",
  TABS_TAB_REFRESH_LOADING: iconPrefix2 + "refresh roll",
  // text
  TEXT_COPY: iconPrefix2 + "copy",
  TEXT_LOADING: iconPrefix2 + "spinner roll",
  // carousel
  CAROUSEL_HORIZONTAL_PREVIOUS: iconPrefix2 + "arrow-left",
  CAROUSEL_HORIZONTAL_NEXT: iconPrefix2 + "arrow-right",
  CAROUSEL_VERTICAL_PREVIOUS: iconPrefix2 + "arrow-up",
  CAROUSEL_VERTICAL_NEXT: iconPrefix2 + "arrow-down",
  // collapse
  COLLAPSE_OPEN: iconPrefix2 + "arrow-right rotate90",
  COLLAPSE_CLOSE: iconPrefix2 + "arrow-right",
  // empty
  EMPTY_DEFAULT: iconPrefix2 + "empty",
  // result
  RESULT_INFO: iconPrefix2 + "info-circle-fill",
  RESULT_SUCCESS: iconPrefix2 + "success-circle-fill",
  RESULT_WARNING: iconPrefix2 + "warning-circle-fill",
  RESULT_ERROR: iconPrefix2 + "error-circle-fill",
  RESULT_QUESTION: iconPrefix2 + "question-circle-fill",
  RESULT_LOADING: iconPrefix2 + "spinner roll",
  // rate
  RATE_CHECKED: iconPrefix2 + "star-fill",
  RATE_UNCHECKED: iconPrefix2 + "star"
});

// node_modules/vxe-pc-ui/es/ui/src/vn.js
var import_xe_utils40 = __toESM(require_xe_utils());
function getOnName2(type) {
  return "on" + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent2(name) {
  switch (name) {
    case "input":
    case "textarea":
      return "input";
    case "select":
      return "change";
  }
  return "update:modelValue";
}
function getChangeEvent2(name) {
  switch (name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function getSlotVNs2(vns) {
  if (import_xe_utils40.default.isArray(vns)) {
    return vns;
  }
  return vns ? [vns] : [];
}

// node_modules/vxe-pc-ui/es/alert/src/alert.js
var alert_default = defineComponent({
  name: "VxeAlert",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => getConfig().alert.icon
    }
  },
  emits: [
    "close"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils41.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeAlert = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const alertMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $alert: $xeAlert }, params));
      }
    };
    const closeEvent = (evnt) => {
      alertMethods.dispatchEvent("close", {}, evnt);
    };
    const alertPrivateMethods = {};
    Object.assign($xeAlert, alertMethods, alertPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title, showIcon, showClose } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      return h("div", {
        ref: refElem,
        class: ["vxe-alert", {
          [`theme--${status}`]: status
        }]
      }, [
        iconSlot || showIcon && status || icon ? h("div", {
          class: "vxe-alert--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon || getIcon()[`ALERT_${status === null || status === void 0 ? void 0 : status.toUpperCase()}`]
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-alert--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-alert--title"
          }, titleSlot ? getSlotVNs2(titleSlot({})) : import_xe_utils41.default.toValueString(title)) : createCommentVNode(),
          h("div", {
            class: "vxe-alert--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : import_xe_utils41.default.toValueString(content))
        ]),
        showClose ? h("div", {
          class: "vxe-alert--close-btn",
          onClick: closeEvent
        }, [
          h("i", {
            class: getIcon().ALERT_CLOSE
          })
        ]) : createCommentVNode()
      ]);
    };
    $xeAlert.renderVN = renderVN;
    return $xeAlert;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/alert/index.js
var VxeAlert = Object.assign({}, alert_default, {
  install(app) {
    app.component(alert_default.name, alert_default);
  }
});
dynamicApp.use(VxeAlert);
VxeUI.component(alert_default);
var Alert = VxeAlert;
var alert_default2 = VxeAlert;

// node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var import_xe_utils45 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/ui/src/dom.js
var import_xe_utils42 = __toESM(require_xe_utils());
var browse3 = import_xe_utils42.default.browse();
var tpImg2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";
var reClsMap2 = {};
function getClsRE2(cls) {
  if (!reClsMap2[cls]) {
    reClsMap2[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, "g");
  }
  return reClsMap2[cls];
}
function getNodeOffset2(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset2(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function hasClass2(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE2(cls));
}
function removeClass2(elem, cls) {
  if (elem && hasClass2(elem, cls)) {
    elem.className = elem.className.replace(getClsRE2(cls), "");
  }
}
function addClass2(elem, cls) {
  if (elem && !hasClass2(elem, cls)) {
    removeClass2(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function toCssUnit(val, unit = "px") {
  if (import_xe_utils42.default.isNumber(val) || /^\d+$/.test(`${val}`)) {
    return `${val}${unit}`;
  }
  return `${val || ""}`;
}
function getDomNode2() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getEventTargetNode2(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass2(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos2(elem, container) {
  return getNodeOffset2(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos2(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode2();
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
var scrollIntoViewIfNeeded2 = "scrollIntoViewIfNeeded";
var scrollIntoView2 = "scrollIntoView";
function scrollToView2(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded2]) {
      elem[scrollIntoViewIfNeeded2]();
    } else if (elem[scrollIntoView2]) {
      elem[scrollIntoView2]();
    }
  }
}

// node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var import_xe_utils44 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/anchor/src/util.js
var import_xe_utils43 = __toESM(require_xe_utils());
function assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const parentElem = elem.parentNode;
  const parentLinkConfig = $xeParentAnchorLink ? $xeParentAnchorLink.linkConfig : null;
  const parentLinks = parentLinkConfig ? parentLinkConfig.children : staticLinks;
  if (parentElem && parentLinks) {
    parentLinks.splice(import_xe_utils43.default.arrayIndexOf(parentElem.children, elem), 0, linkConfig);
    $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
  }
}
function destroyAnchorLink($xeAnchor, linkConfig) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const matchObj = import_xe_utils43.default.findTree(staticLinks, (item) => item.id === linkConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
}

// node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var anchor_link_default = defineComponent({
  name: "VxeAnchorLink",
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const $xeAnchor = inject("$xeAnchor", null);
    const $xeParentAnchorLink = inject("$xeAnchorLink", null);
    const xID = import_xe_utils44.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const linkConfig = reactive({
      id: xID,
      href: props.href,
      children: []
    });
    const refMaps = {
      refElem
    };
    const computeIsActive = computed(() => {
      const { href } = props;
      if ($xeAnchor) {
        return $xeAnchor.reactData.activeHref === href;
      }
      return null;
    });
    const computeMaps = {};
    const $xeAnchorLink = {
      xID,
      props,
      context,
      reactData,
      linkConfig,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (event) => {
      const { href } = props;
      if ($xeAnchor) {
        $xeAnchor.handleClickLink(event, href);
      }
    };
    watch(() => props.href, (val) => {
      linkConfig.href = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeAnchor && elem) {
        assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink);
      }
    });
    onUnmounted(() => {
      if ($xeAnchor) {
        destroyAnchorLink($xeAnchor, linkConfig);
      }
    });
    const renderVN = () => {
      const { href, content, title } = props;
      const defaultSlot = slots.default;
      const subSlot = slots.sub;
      const isActive = computeIsActive.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor-link", {
          "is--active": isActive
        }]
      }, [
        h("a", {
          class: "vxe-anchor-link--item",
          href,
          title,
          onClick: clickEvent
        }, defaultSlot ? defaultSlot({}) : import_xe_utils44.default.toValueString(content)),
        subSlot ? h("div", {
          class: "vxe-anchor-link--sub-items"
        }, subSlot({})) : createCommentVNode()
      ]);
    };
    provide("$xeAnchorLink", $xeAnchorLink);
    $xeAnchorLink.renderVN = renderVN;
    return $xeAnchorLink;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var anchor_default = defineComponent({
  name: "VxeAnchor",
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils45.default.uniqueId();
    const refElem = ref();
    const refMarkerElem = ref();
    const reactData = reactive({
      activeHref: null,
      staticLinks: [],
      containerElem: null
    });
    const refMaps = {
      refElem
    };
    const computeAllHrefList = computed(() => {
      const list = [];
      import_xe_utils45.default.eachTree(reactData.staticLinks, (item) => {
        list.push(item.href || "");
      }, { children: "children" });
      return list;
    });
    const computeMaps = {};
    const $xeAnchor = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const anchorMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $anchor: $xeAnchor }, params));
      }
    };
    const getContainerElem = () => {
      const { container } = props;
      if (container) {
        if (import_xe_utils45.default.isElement(container)) {
          return container;
        }
        if (import_xe_utils45.default.isString(container)) {
          return document.querySelector(container);
        }
        if (import_xe_utils45.default.isFunction(container)) {
          return container({ $anchor: $xeAnchor });
        }
      }
      return null;
    };
    const emitEvent = (value) => {
      reactData.activeHref = value;
      emit("update:modelValue", value);
    };
    const handleContainerScrollEvent = () => {
      const allHrefList = computeAllHrefList.value;
      const { containerElem } = reactData;
      if (containerElem) {
        const wrapperElList = containerElem.querySelectorAll(allHrefList.map((href) => `${href}`).join(","));
        for (let i = 0; i < wrapperElList.length; i++) {
          const wrapperEl = wrapperElList[i];
          const wrapperRect = wrapperEl.getBoundingClientRect();
          if (wrapperRect.top > 0) {
            const href = wrapperEl.id;
            reactData.activeHref = `#${href}`;
            break;
          }
        }
      }
    };
    const removeContainerElemScroll = () => {
      const { containerElem } = reactData;
      if (containerElem) {
        containerElem.removeEventListener("scroll", handleContainerScrollEvent);
      }
    };
    const updateContainerElem = () => {
      const containerElem = getContainerElem();
      reactData.containerElem = containerElem;
      if (containerElem) {
        containerElem.addEventListener("scroll", handleContainerScrollEvent, {
          passive: false
        });
      }
    };
    const updateMarkerPos = () => {
      nextTick(() => {
        const { activeHref } = reactData;
        const elem = refElem.value;
        const markerEl = refMarkerElem.value;
        if (elem && markerEl) {
          if (activeHref) {
            const linkEl = elem.querySelector(`[href="${activeHref}"]`);
            if (linkEl) {
              const { top } = getOffsetPos2(linkEl, elem);
              markerEl.style.top = `${top}px`;
            }
          }
        }
      });
    };
    const anchorPrivateMethods = {
      handleClickLink(evnt, href) {
        evnt.preventDefault();
        const targetEl = document.getElementById(`${href}`.replace("#", ""));
        if (targetEl) {
          targetEl.scrollIntoView({
            behavior: "smooth"
          });
        }
        emitEvent(href);
        anchorMethods.dispatchEvent("click", { href }, evnt);
      }
    };
    Object.assign($xeAnchor, anchorMethods, anchorPrivateMethods);
    const renderSubItems = (options) => {
      const itemVNs = [];
      if (options) {
        options.forEach((item) => {
          const subItems = item.children;
          if (subItems && subItems.length) {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }, {
              sub: () => renderSubItems(subItems)
            }));
          } else {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }));
          }
        });
      }
      return itemVNs;
    };
    const renderVN = () => {
      const { options, showMarker } = props;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor", {
          "is--marker": showMarker
        }]
      }, [
        h("div", {
          class: "vxe-anchor--list"
        }, defaultSlot ? defaultSlot({}) : renderSubItems(options)),
        showMarker ? h("div", {
          ref: refMarkerElem,
          class: "vxe-anchor--marker"
        }) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeHref = val;
    });
    watch(() => reactData.activeHref, () => {
      updateMarkerPos();
    });
    watch(() => props.container, () => {
      removeContainerElemScroll();
      updateContainerElem();
    });
    onMounted(() => {
      nextTick(() => {
        updateContainerElem();
      });
    });
    onBeforeUnmount(() => {
      removeContainerElemScroll();
    });
    provide("$xeAnchor", $xeAnchor);
    $xeAnchor.renderVN = renderVN;
    return $xeAnchor;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/anchor/index.js
var VxeAnchor = Object.assign({}, anchor_default, {
  install(app) {
    app.component(anchor_default.name, anchor_default);
  }
});
dynamicApp.use(VxeAnchor);
VxeUI.component(anchor_default);
var Anchor = VxeAnchor;
var anchor_default2 = VxeAnchor;

// node_modules/vxe-pc-ui/es/anchor-link/index.js
var VxeAnchorLink = Object.assign({}, anchor_link_default, {
  install(app) {
    app.component(anchor_link_default.name, anchor_link_default);
  }
});
dynamicApp.use(VxeAnchorLink);
VxeUI.component(anchor_link_default);
var AnchorLink = VxeAnchorLink;
var anchor_link_default2 = VxeAnchorLink;

// node_modules/vxe-pc-ui/es/avatar/src/avatar.js
var import_xe_utils46 = __toESM(require_xe_utils());
var avatar_default = defineComponent({
  name: "VxeAvatar",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    icon: String,
    src: String,
    width: [String, Number],
    height: [String, Number],
    circle: {
      type: Boolean,
      default: () => getConfig().avatar.circle
    },
    status: {
      type: String,
      default: () => getConfig().avatar.status
    },
    size: {
      type: String,
      default: () => getConfig().avatar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils46.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeAvatarStyle = computed(() => {
      const { width, height } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCountNum = computed(() => {
      const { count } = props;
      return count ? import_xe_utils46.default.toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeAvatar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $avatar: $xeAvatar }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeAvatar, collapsePaneMethods, collapsePanePrivateMethods);
    const renderContent = () => {
      const { icon, content, src } = props;
      if (icon) {
        return h("span", {
          class: "vxe-avatar--icon"
        }, [
          h("i", {
            class: icon
          })
        ]);
      }
      if (content) {
        return h("span", {
          class: "vxe-avatar--content"
        }, `${content}`);
      }
      if (src) {
        return h("img", {
          class: "vxe-avatar--img",
          src
        });
      }
      return renderEmptyElement($xeAvatar);
    };
    const renderVN = () => {
      const { circle, dot, status } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const avatarStyle = computeAvatarStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-avatar", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--circle": circle,
          "is--dot": dot
        }],
        style: avatarStyle
      }, [
        renderContent(),
        countNum ? h("span", {
          class: "vxe-avatar--count"
        }, countNum > 99 ? "99+" : `${countNum}`) : renderEmptyElement($xeAvatar)
      ]);
    };
    $xeAvatar.renderVN = renderVN;
    return $xeAvatar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/avatar/index.js
var VxeAvatar = Object.assign({}, avatar_default, {
  install(app) {
    app.component(avatar_default.name, avatar_default);
  }
});
dynamicApp.use(VxeAvatar);
VxeUI.component(avatar_default);
var Avatar = VxeAvatar;
var avatar_default2 = VxeAvatar;

// node_modules/vxe-pc-ui/es/badge/src/badge.js
var import_xe_utils47 = __toESM(require_xe_utils());
var badge_default = defineComponent({
  name: "VxeBadge",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().badge.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils47.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCountNum = computed(() => {
      const { count } = props;
      return count ? import_xe_utils47.default.toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeBadge = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $badge: $xeBadge }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeBadge, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { dot, content } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-badge", {
          [`size--${vSize}`]: vSize,
          "is--dot": dot
        }]
      }, [
        defaultSlot || content ? h("div", {
          class: "vxe-badge--content"
        }, defaultSlot ? defaultSlot({}) : `${content || ""}`) : [],
        countNum ? h("span", {
          class: "vxe-badge--count"
        }, countNum > 99 ? "99+" : `${countNum}`) : renderEmptyElement($xeBadge)
      ]);
    };
    $xeBadge.renderVN = renderVN;
    return $xeBadge;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/badge/index.js
var VxeBadge = Object.assign({}, badge_default, {
  install(app) {
    app.component(badge_default.name, badge_default);
  }
});
dynamicApp.use(VxeBadge);
VxeUI.component(badge_default);
var Badge = VxeBadge;
var badge_default2 = VxeBadge;

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var import_xe_utils49 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb-item.js
var import_xe_utils48 = __toESM(require_xe_utils());
var breadcrumb_item_default = defineComponent({
  name: "VxeBreadcrumbItem",
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils48.default.uniqueId();
    const refElem = ref();
    const $xeBreadcrumb = inject("$xeBreadcrumb", null);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeSeparator = computed(() => {
      if ($xeBreadcrumb) {
        return $xeBreadcrumb.props.separator;
      }
      return "";
    });
    const clickEvent = (evnt) => {
      if ($xeBreadcrumb) {
        const item = {
          title: props.title,
          routerLink: props.routerLink
        };
        $xeBreadcrumb.handleClickLink(evnt, item);
      }
    };
    const computeMaps = {};
    const $xeBreadcrumbItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { title, routerLink } = props;
      const separator = computeSeparator.value;
      const defaultSlot = slots.default;
      return h("span", {
        ref: refElem,
        class: "vxe-breadcrumb-item",
        onClick: clickEvent
      }, [
        h("span", {
          class: "vxe-breadcrumb-item--content"
        }, [
          routerLink ? h(resolveComponent("router-link"), {
            class: "vxe-breadcrumb-item--content-link",
            title,
            to: routerLink
          }, {
            default() {
              return h("span", {
                class: "vxe-breadcrumb-item--content-text"
              }, defaultSlot ? defaultSlot({}) : `${title || ""}`);
            }
          }) : h("span", {
            class: "vxe-breadcrumb-item--content-text"
          }, defaultSlot ? defaultSlot({}) : `${title || ""}`)
        ]),
        separator ? h("span", {
          class: "vxe-breadcrumb-item--separator"
        }, `${separator}`) : createCommentVNode()
      ]);
    };
    $xeBreadcrumbItem.renderVN = renderVN;
    return $xeBreadcrumbItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var breadcrumb_default = defineComponent({
  name: "VxeBreadcrumb",
  props: {
    separator: {
      type: String,
      default: () => getConfig().breadcrumb.separator
    },
    options: Array
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils49.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeBreadcrumb = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const breadcrumbMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $breadcrumb: $xeBreadcrumb }, params));
      }
    };
    const breadcrumbPrivateMethods = {
      handleClickLink(evnt, option2) {
        breadcrumbMethods.dispatchEvent("click", { option: option2 }, evnt);
      }
    };
    Object.assign($xeBreadcrumb, breadcrumbMethods, breadcrumbPrivateMethods);
    const renderItems = () => {
      const { options } = props;
      if (options && options.length) {
        return options.map((item) => {
          return h(breadcrumb_item_default, {
            title: item.title,
            routerLink: item.routerLink
          });
        });
      }
      return [];
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: "vxe-breadcrumb"
      }, defaultSlot ? defaultSlot({}) : renderItems());
    };
    provide("$xeBreadcrumb", $xeBreadcrumb);
    $xeBreadcrumb.renderVN = renderVN;
    return $xeBreadcrumb;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/breadcrumb/index.js
var VxeBreadcrumb = Object.assign({}, breadcrumb_default, {
  install(app) {
    app.component(breadcrumb_default.name, breadcrumb_default);
  }
});
dynamicApp.use(VxeBreadcrumb);
VxeUI.component(breadcrumb_default);
var Breadcrumb = VxeBreadcrumb;
var breadcrumb_default2 = VxeBreadcrumb;

// node_modules/vxe-pc-ui/es/breadcrumb-item/index.js
var VxeBreadcrumbItem = Object.assign({}, breadcrumb_item_default, {
  install(app) {
    app.component(breadcrumb_item_default.name, breadcrumb_item_default);
  }
});
dynamicApp.use(VxeBreadcrumbItem);
VxeUI.component(breadcrumb_item_default);
var BreadcrumbItem = VxeBreadcrumbItem;
var breadcrumb_item_default2 = VxeBreadcrumbItem;

// node_modules/vxe-pc-ui/es/button/src/button.js
var import_xe_utils51 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/tooltip/src/tooltip.js
var import_xe_utils50 = __toESM(require_xe_utils());
var tooltip_default = defineComponent({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: {
      type: String,
      default: () => getConfig().tooltip.size || getConfig().size
    },
    selector: String,
    trigger: {
      type: String,
      default: () => getConfig().tooltip.trigger || "hover"
    },
    theme: {
      type: String,
      default: () => getConfig().tooltip.theme || "dark"
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: {
      type: Boolean,
      default: () => getConfig().tooltip.isArrow
    },
    enterable: {
      type: Boolean,
      default: () => getConfig().tooltip.enterable
    },
    enterDelay: {
      type: Number,
      default: () => getConfig().tooltip.enterDelay
    },
    leaveDelay: {
      type: Number,
      default: () => getConfig().tooltip.leaveDelay
    }
  },
  emits: [
    "update:modelValue"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils50.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: "",
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    });
    const internalData = {};
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeTooltip = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const { tipTarget, tipStore } = reactData;
      if (tipTarget) {
        const { scrollTop, scrollLeft, visibleWidth } = getDomNode2();
        const { top, left } = getAbsolutePos2(tipTarget);
        const el2 = refElem.value;
        const marginSize = 6;
        const offsetHeight = el2.offsetHeight;
        const offsetWidth = el2.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = "bottom";
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = (value) => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit("update:modelValue", value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex2()) {
        reactData.tipZindex = nextZIndex2();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        handleVisible(reactData.target || getSelectorEl(), props.content);
      }
    };
    const targetMouseenterEvent = () => {
      handleVisible(reactData.target || getSelectorEl(), props.content);
    };
    const targetMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const { tipStore } = reactData;
      const el2 = refElem.value;
      if (el2) {
        const parentNode = el2.parentNode;
        if (!parentNode) {
          document.body.appendChild(el2);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = "top";
      tipStore.style = { width: "auto", left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };
      tipStore.arrowStyle = { left: "50%" };
      return tooltipMethods.updatePlacement();
    };
    const handleDelayFn = () => {
      internalData.showDelayTip = import_xe_utils50.default.debounce(() => {
        if (reactData.tipActive) {
          showTip();
        }
      }, props.enterDelay, { leading: false, trailing: true });
    };
    const handleVisible = (target, content) => {
      const contentSlot = slots.content;
      if (!contentSlot && (content === "" || import_xe_utils50.default.eqNull(content))) {
        return nextTick();
      }
      if (target) {
        const { showDelayTip } = internalData;
        const { trigger, enterDelay } = props;
        reactData.tipActive = true;
        reactData.tipTarget = target;
        reactData.tipContent = content;
        if (enterDelay && trigger === "hover") {
          if (showDelayTip) {
            showDelayTip();
          }
        } else {
          return showTip();
        }
      }
      return nextTick();
    };
    const getSelectorEl = () => {
      const { selector } = props;
      if (selector) {
        if (import_xe_utils50.default.isElement(selector)) {
          return selector;
        }
        if (import_xe_utils50.default.isString(selector)) {
          return document.querySelector(selector);
        }
      }
      return null;
    };
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $tooltip: $xeTooltip }, params));
      },
      open(target, content) {
        return handleVisible(target || reactData.target || getSelectorEl(), content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        });
        updateValue(false);
        return nextTick();
      },
      toVisible(target, content) {
        return handleVisible(target, content);
      },
      updatePlacement() {
        return nextTick().then(() => {
          const { tipTarget } = reactData;
          const el2 = refElem.value;
          if (tipTarget && el2) {
            updateTipStyle();
            return nextTick().then(() => {
              updateTipStyle();
            });
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(active) {
        reactData.tipActive = !!active;
      }
    };
    Object.assign($xeTooltip, tooltipMethods);
    const renderContent = () => {
      const { useHTML } = props;
      const { tipContent } = reactData;
      const contentSlot = slots.content;
      if (contentSlot) {
        return h("div", {
          key: 1,
          class: "vxe-table--tooltip-content"
        }, getSlotVNs2(contentSlot({})));
      }
      if (useHTML) {
        return h("div", {
          key: 2,
          class: "vxe-table--tooltip-content",
          innerHTML: tipContent
        });
      }
      return h("div", {
        key: 3,
        class: "vxe-table--tooltip-content"
      }, `${tipContent}`);
    };
    const renderVN = () => {
      const { popupClassName, theme, isArrow, enterable } = props;
      const { tipActive, visible, tipStore } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--tooltip-wrapper", `theme--${theme}`, popupClassName ? import_xe_utils50.default.isFunction(popupClassName) ? popupClassName({ $tooltip: $xeTooltip }) : popupClassName : "", {
        [`size--${vSize}`]: vSize,
        [`placement--${tipStore.placement}`]: tipStore.placement,
        "is--enterable": enterable,
        "is--visible": visible,
        "is--arrow": isArrow,
        "is--active": tipActive
      }], style: tipStore.style }, ons), [
        renderContent(),
        h("div", {
          class: "vxe-table--tooltip-arrow",
          style: tipStore.arrowStyle
        }),
        ...defaultSlot ? getSlotVNs2(defaultSlot({})) : []
      ]);
    };
    watch(() => props.enterDelay, () => {
      handleDelayFn();
    });
    watch(() => props.content, (val) => {
      reactData.tipContent = val;
    });
    watch(() => props.modelValue, (val) => {
      if (!reactData.isUpdate) {
        if (val) {
          handleVisible(reactData.target || getSelectorEl(), props.content);
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    onMounted(() => {
      nextTick(() => {
        const { trigger, content } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex2();
            import_xe_utils50.default.arrayEach(wrapperElem.children, (elem, index2) => {
              if (index2 > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const { target } = reactData;
            if (target) {
              if (trigger === "hover") {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === "click") {
                target.onclick = clickEvent;
              }
            }
            if (props.modelValue) {
              handleVisible(target || getSelectorEl(), content);
            }
          }
        }
      });
    });
    onBeforeUnmount(() => {
      const { target } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        target.onmouseenter = null;
        target.onmouseleave = null;
        target.onclick = null;
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    handleDelayFn();
    $xeTooltip.renderVN = renderVN;
    return $xeTooltip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/button/src/button.js
var button_default = defineComponent({
  name: "VxeButton",
  props: {
    /**
     * 
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 
     */
    size: {
      type: String,
      default: () => getConfig().button.size || getConfig().size
    },
    /**
     * 
     */
    name: [String, Number],
    routerLink: Object,
    /**
     * 
     */
    permissionCode: [String, Number],
    /**
     * 
     */
    content: String,
    /**
     * 
     */
    placement: String,
    /**
     * 
     */
    status: String,
    /**
     * 
     */
    title: String,
    /**
     * 
     */
    icon: String,
    /**
     * 
     */
    round: Boolean,
    /**
     * 
     */
    circle: Boolean,
    /**
     * 
     */
    disabled: Boolean,
    /**
     * 
     */
    loading: Boolean,
    trigger: {
      type: String,
      default: () => getConfig().button.trigger
    },
    align: String,
    prefixTooltip: Object,
    suffixTooltip: Object,
    /**
     * 
     */
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().button.destroyOnClose
    },
    /**
     *  body 
     */
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "click",
    "mouseenter",
    "mouseleave",
    "dropdown-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const $xeButtonGroup = inject("$xeButtonGroup", null);
    const xID = import_xe_utils51.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const reactData = reactive({
      initialized: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    });
    const internalData = {
      showTime: void 0,
      tooltipTimeout: void 0
    };
    const refElem = ref();
    const refButton = ref();
    const refBtnPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeButton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let buttonMethods = {};
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().button.transfer;
        if (import_xe_utils51.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeBtnDisabled = computed(() => {
      const { disabled } = props;
      const permissionInfo = computePermissionInfo.value;
      return disabled || permissionInfo.disabled;
    });
    const computeIsFormBtn = computed(() => {
      const { type } = props;
      if (type) {
        return ["submit", "reset", "button"].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = computed(() => {
      const { type, mode } = props;
      if (mode === "text" || type === "text" || $xeButtonGroup && $xeButtonGroup.props.mode === "text") {
        return "text";
      }
      return "button";
    });
    const computeBtnStatus = computed(() => {
      const { status } = props;
      if (status) {
        return status;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.status;
      }
      return "";
    });
    const computeBtnRound = computed(() => {
      const { round } = props;
      if (round) {
        return round;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = computed(() => {
      const { circle } = props;
      if (circle) {
        return circle;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.circle;
      }
      return false;
    });
    const computePrefixTipOpts = computed(() => {
      return Object.assign({}, props.prefixTooltip);
    });
    const computeSuffixTipOpts = computed(() => {
      return Object.assign({}, props.suffixTooltip);
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refButton.value;
        const panelElem = refBtnPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && targetElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { top, left, boundingTop, visibleHeight, visibleWidth } = getAbsolutePos2(targetElem);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let btnLeft = left + targetWidth - panelWidth;
            let btnTop = top + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              btnTop = top - panelHeight;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                btnTop = top - panelHeight;
              }
              if (btnTop < marginSize) {
                panelPlacement = "bottom";
                btnTop = top + targetHeight;
              }
            }
            if (btnLeft + panelWidth + marginSize > visibleWidth) {
              btnLeft -= btnLeft + panelWidth + marginSize - visibleWidth;
            }
            if (btnLeft < marginSize) {
              btnLeft = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${btnLeft}px`,
              right: "auto",
              top: `${btnTop}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const clickEvent = (evnt) => {
      if ($xeButtonGroup) {
        $xeButtonGroup.handleClick({ name: props.name }, evnt);
      } else {
        dispatchEvent2("click", { $event: evnt }, evnt);
      }
    };
    const mousedownDropdownEvent = (evnt) => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = (evnt) => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const { flag, targetElem } = getEventTargetNode2(evnt, dropdownElem, "vxe-button");
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = "N";
        }
        reactData.visiblePanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== "Y") {
            reactData.isAniVisible = false;
          }
        }, 350);
        dispatchEvent2("dropdown-click", { name: targetElem.getAttribute("name"), $event: evnt }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        reactData.isAniVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            reactData.visiblePanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.visiblePanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = (evnt) => {
      const { loading: loading2 } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading2)) {
        openPanel();
        mouseenterEvent(evnt);
      }
    };
    const mouseleaveTargetEvent = (evnt) => {
      closePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = (evnt) => {
      dispatchEvent2("mouseenter", {}, evnt);
    };
    const mouseleaveEvent = (evnt) => {
      dispatchEvent2("mouseleave", {}, evnt);
    };
    const clickTargetEvent = (evnt) => {
      const { loading: loading2, trigger } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading2)) {
        if (trigger === "click") {
          if (reactData.visiblePanel) {
            closePanel();
          } else {
            openPanel();
          }
        }
        clickEvent(evnt);
      }
    };
    const openPanel = () => {
      const { trigger } = props;
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            mouseenterDropdownEvent();
          } else {
            reactData.isAniVisible = false;
          }
        }, trigger === "click" ? 50 : 250);
      }
      return nextTick();
    };
    const closePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = "N";
        setTimeout(() => {
          if (panelElem.dataset.active !== "Y") {
            reactData.visiblePanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== "Y") {
                reactData.isAniVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.isAniVisible = false;
        reactData.visiblePanel = false;
      }
      return nextTick();
    };
    const mouseleaveDropdownEvent = () => {
      closePanel();
    };
    const renderTooltipIcon = (tipOpts, type) => {
      return h(tooltip_default, {
        useHTML: tipOpts.useHTML,
        content: tipOpts.content,
        enterable: tipOpts.enterable,
        theme: tipOpts.theme
      }, {
        default() {
          return h("i", {
            class: [`vxe-button--tooltip-${type}-icon`, tipOpts.icon || getIcon().BUTTON_TOOLTIP_ICON]
          });
        }
      });
    };
    const renderContent = () => {
      const { content, icon, loading: loading2, prefixTooltip, suffixTooltip } = props;
      const prefixTipOpts = computePrefixTipOpts.value;
      const suffixTipOpts = computeSuffixTipOpts.value;
      const iconSlot = slots.icon;
      const defaultSlot = slots.default;
      const contVNs = [];
      if (prefixTooltip) {
        contVNs.push(renderTooltipIcon(prefixTipOpts, "prefix"));
      }
      if (loading2) {
        contVNs.push(h("i", {
          class: ["vxe-button--loading-icon", getIcon().BUTTON_LOADING]
        }));
      } else if (iconSlot) {
        contVNs.push(h("span", {
          class: "vxe-button--custom-icon"
        }, iconSlot({})));
      } else if (icon) {
        contVNs.push(h("i", {
          class: ["vxe-button--icon", icon]
        }));
      }
      if (defaultSlot) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, defaultSlot({})));
      } else if (content) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, getFuncText2(content)));
      }
      if (suffixTooltip) {
        contVNs.push(renderTooltipIcon(suffixTipOpts, "suffix"));
      }
      return contVNs;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $button: $xeButton }, params));
    };
    buttonMethods = {
      dispatchEvent: dispatchEvent2,
      openPanel,
      closePanel,
      focus() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.focus();
        }
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        return nextTick();
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const panelElem = refBtnPanel.value;
      if (reactData.visiblePanel && !getEventTargetNode2(evnt, panelElem).flag) {
        closePanel();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const btnDisabled = computeBtnDisabled.value;
      const { visiblePanel } = reactData;
      if (!btnDisabled) {
        const el2 = refElem.value;
        const panelElem = refBtnPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          closePanel();
        }
      }
    };
    Object.assign($xeButton, buttonMethods);
    const renderVN = () => {
      const { className, popupClassName, align, trigger, title, routerLink, type, destroyOnClose, name, loading: loading2 } = props;
      const { initialized, isAniVisible, visiblePanel } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnCircle = computeBtnCircle.value;
      const btnTransfer = computeBtnTransfer.value;
      const btnDisabled = computeBtnDisabled.value;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      const downsSlot = slots.dropdowns;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      if (downsSlot) {
        const btnOns = {};
        const panelOns = {};
        if (trigger === "hover") {
          btnOns.onMouseenter = mouseenterTargetEvent;
          btnOns.onMouseleave = mouseleaveTargetEvent;
          panelOns.onMouseenter = mouseenterDropdownEvent;
          panelOns.onMouseleave = mouseleaveDropdownEvent;
        }
        return h("div", {
          ref: refElem,
          class: ["vxe-button--dropdown", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
            [`size--${vSize}`]: vSize,
            "is--active": visiblePanel
          }]
        }, [
          routerLink ? h(resolveComponent("router-link"), Object.assign({
            ref: refButton,
            class: ["vxe-button", "vxe-button--link", `type--${btnMode}`, align ? `align--${align}` : "", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": btnDisabled || loading2,
              "is--loading": loading2
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: btnDisabled || loading2,
            to: routerLink,
            onClick: clickTargetEvent
          }, btnOns), {
            default() {
              return renderContent().concat([
                h("i", {
                  class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
                })
              ]);
            }
          }) : h("button", Object.assign({
            ref: refButton,
            class: ["vxe-button", `type--${btnMode}`, align ? `align--${align}` : "", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": btnDisabled || loading2,
              "is--loading": loading2
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: btnDisabled || loading2,
            onClick: clickTargetEvent
          }, btnOns), renderContent().concat([
            h("i", {
              class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
            })
          ])),
          h(Teleport, {
            to: "body",
            disabled: btnTransfer ? !initialized : true
          }, [
            h("div", Object.assign({ ref: refBtnPanel, class: ["vxe-button--dropdown-panel", popupClassName ? import_xe_utils51.default.isFunction(popupClassName) ? popupClassName({ $button: $xeButton }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }], placement: reactData.panelPlacement, style: reactData.panelStyle }, panelOns), initialized && (visiblePanel || isAniVisible) ? [
              h("div", {
                class: "vxe-button--dropdown-wrapper",
                onMousedown: mousedownDropdownEvent,
                onClick: clickDropdownEvent
              }, destroyOnClose && !visiblePanel ? [] : downsSlot({}))
            ] : [])
          ])
        ]);
      }
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          ref: refButton,
          class: ["vxe-button", "vxe-button--link", `type--${btnMode}`, align ? `align--${align}` : "", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            "is--round": btnRound,
            "is--circle": btnCircle,
            "is--disabled": btnDisabled || loading2,
            "is--loading": loading2
          }],
          title,
          name,
          type: isFormBtn ? type : "button",
          disabled: btnDisabled || loading2,
          to: routerLink,
          onClick: clickEvent,
          onMouseenter: mouseenterEvent,
          onMouseleave: mouseleaveEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("button", {
        ref: refButton,
        class: ["vxe-button", `type--${btnMode}`, align ? `align--${align}` : "", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          "is--round": btnRound,
          "is--circle": btnCircle,
          "is--disabled": btnDisabled || loading2,
          "is--loading": loading2
        }],
        title,
        name,
        type: isFormBtn ? type : "button",
        disabled: btnDisabled || loading2,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xeButton.renderVN = renderVN;
    onMounted(() => {
      if (true) {
        if (props.type === "text") {
          warnLog2("vxe.error.delProp", ["type=text", "mode=text"]);
        }
      }
      globalEvents.on($xeButton, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeButton, "mousedown", handleGlobalMousedownEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeButton, "mousewheel");
      globalEvents.off($xeButton, "mousedown");
    });
    return $xeButton;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/button/index.js
var VxeButton = Object.assign({}, button_default, {
  install(app) {
    app.component(button_default.name, button_default);
  }
});
dynamicApp.use(VxeButton);
VxeUI.component(button_default);
var Button = VxeButton;
var button_default2 = VxeButton;

// node_modules/vxe-pc-ui/es/button/src/button-group.js
var import_xe_utils52 = __toESM(require_xe_utils());
var button_group_default = defineComponent({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().buttonGroup.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils52.default.uniqueId();
    const computeMaps = {};
    const $xeButtonGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $buttonGroup: $xeButtonGroup }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const { options } = props;
        const { name } = params;
        const option2 = options ? options.find((item) => item.name === name) : null;
        buttonGroupMethods.dispatchEvent("click", Object.assign(Object.assign({}, params), { option: option2 }), evnt);
      }
    };
    Object.assign($xeButtonGroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const { className, options } = props;
      const permissionInfo = computePermissionInfo.value;
      const defaultSlot = slots.default;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      return h("div", {
        class: ["vxe-button-group", className ? import_xe_utils52.default.isFunction(className) ? className({ $buttonGroup: $xeButtonGroup }) : className : ""]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index2) => {
        return h(button_default, Object.assign({ key: index2 }, item));
      }) : []);
    };
    $xeButtonGroup.renderVN = renderVN;
    provide("$xeButtonGroup", $xeButtonGroup);
    return $xeButtonGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/button-group/index.js
var VxeButtonGroup = Object.assign({}, button_group_default, {
  install(app) {
    app.component(button_group_default.name, button_group_default);
  }
});
dynamicApp.use(VxeButtonGroup);
VxeUI.component(button_group_default);
var ButtonGroup = VxeButtonGroup;
var button_group_default2 = VxeButtonGroup;

// node_modules/vxe-pc-ui/es/date-picker/src/util.js
var import_xe_utils53 = __toESM(require_xe_utils());
function toStringTimeDate(str) {
  if (str) {
    const rest = /* @__PURE__ */ new Date();
    let h10 = 0;
    let m = 0;
    let s = 0;
    if (import_xe_utils53.default.isDate(str)) {
      h10 = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = import_xe_utils53.default.toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h10 = import_xe_utils53.default.toNumber(parses[1]);
        m = import_xe_utils53.default.toNumber(parses[3]);
        s = import_xe_utils53.default.toNumber(parses[5]);
      }
    }
    rest.setHours(h10);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return /* @__PURE__ */ new Date("");
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}

// node_modules/vxe-pc-ui/es/calendar/src/calendar.js
var import_xe_utils54 = __toESM(require_xe_utils());
var calendar_default = defineComponent({
  name: "VxeCalendar",
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: "date"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().calendar.size || getConfig().size
    },
    multiple: Boolean,
    width: [String, Number],
    height: [String, Number],
    // dateweekmonthquarteryear
    minDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.minDate
    },
    maxDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.maxDate
    },
    startDay: {
      type: [String, Number],
      default: () => getConfig().calendar.startDay
    },
    labelFormat: String,
    valueFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().calendar.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().calendar.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().calendar.selectDay
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils54.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      selectValue: props.modelValue,
      inputValue: props.modelValue,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8
    };
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeCalendar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let calendarMethods = {};
    const computeCalendarStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeIsDisabled = computed(() => {
      return false;
    });
    const computeIsCalendarType = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateStartTime = computed(() => {
      return props.minDate ? import_xe_utils54.default.toStringDate(props.minDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.maxDate ? import_xe_utils54.default.toStringDate(props.maxDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { multiple } = props;
      const { selectValue } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && selectValue && isCalendarType) {
        return import_xe_utils54.default.toValueString(selectValue).split(",").map((item) => {
          const date = parseDate2(item, dateValueFormat);
          if (import_xe_utils54.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils54.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils54.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { selectValue } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (selectValue && isCalendarType) {
        const date = parseDate2(selectValue, dateValueFormat);
        if (import_xe_utils54.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      return dateValue ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isCalendarType) {
        return labelFormat || dateValueFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { yearSize } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index2 = -4; index2 < yearSize + 4; index2++) {
          const date = import_xe_utils54.default.getWhatYear(startYearDate, index2, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index2 < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index2 >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return getI18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return getI18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return getI18n("vxe.input.date.dayLabel", [year, month ? getI18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay } = props;
      return import_xe_utils54.default.toNumber(startDay);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index2 = 0; index2 < 6; index2++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils54.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { quarterSize } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils54.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index2 = -2; index2 < quarterSize - 2; index2++) {
          const date = import_xe_utils54.default.getWhatQuarter(firstYear, index2);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils54.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { monthSize } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils54.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index2 = -4; index2 < monthSize - 4; index2++) {
          const date = import_xe_utils54.default.getWhatYear(selectMonth, 0, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils54.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils54.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index2 = 0; index2 < 42; index2++) {
          const date = import_xe_utils54.default.getWhatDay(startDayDate, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils54.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils54.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const parseDate2 = (value, format4) => {
      return import_xe_utils54.default.toStringDate(value, format4);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils54.default.toValueString(props.modelValue) !== value) {
        calendarMethods.dispatchEvent("change", { value }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate2(value, dateValueFormat);
      }
      if (import_xe_utils54.default.isValidDate(dValue)) {
        dLabel = import_xe_utils54.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils54.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      const { inputValue } = reactData;
      if (isCalendarType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        changeValue();
      }
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils54.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils54.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils54.default.toNumber(props.selectDay);
        date = import_xe_utils54.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      }
      const inpVal = import_xe_utils54.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      reactData.selectValue = date;
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (dateMultipleValue.some((val) => import_xe_utils54.default.isEqual(val, inpVal))) {
          handleChange(dateMultipleValue.filter((val) => !import_xe_utils54.default.isEqual(val, inpVal)).join(","), { type: "update" });
        } else {
          handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
        }
      } else {
        if (!import_xe_utils54.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils54.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils54.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const { yearSize } = internalData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = import_xe_utils54.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        calendarMethods.dispatchEvent("date-prev", { type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
      }
      calendarMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const { yearSize } = internalData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = import_xe_utils54.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        calendarMethods.dispatchEvent("date-next", { type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $calendar: $xeCalendar });
    };
    const dateSelectItem = (date) => {
      const { type } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
        }
      } else if (type === "year") {
        dateChange(date);
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils54.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils54.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils54.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils54.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateConfirmEvent = () => {
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils54.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $calendar: $xeCalendar });
        const festivalItem = festivalRest ? import_xe_utils54.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils54.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-calendar--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label || ""}`),
            h("span", {
              class: ["vxe-calendar--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils54.default.toValueString(extraItem.label))
          ] : [`${label || ""}`])
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils54.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-calendar--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-calendar--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-calendar--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return `${label || ""}`;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tr", dateHeaders.map((item) => {
            return h("th", {
              class: "vxe-calendar--view-th"
            }, item.label);
          })),
          ...dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          })
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tr", weekHeaders.map((item) => {
            return h("td", {
              class: "vxe-calendar--view-th"
            }, item.label);
          })),
          ...weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                }],
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          })
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-calendar--header"
        }, [
          h("div", {
            class: "vxe-calendar--type-wrapper"
          }, [
            h(button_default, {
              disabled: datePanelType === "year",
              content: selectDatePanelLabel,
              onClick: dateToggleTypeEvent
            })
          ]),
          h("div", {
            class: "vxe-calendar--btn-wrapper"
          }, [
            h(button_default, {
              disabled: isDisabledPrevDateBtn,
              icon: "vxe-icon-caret-left",
              onClick: datePrevEvent
            }),
            h(button_default, {
              icon: "vxe-icon-dot",
              onClick: dateTodayMonthEvent
            }),
            h(button_default, {
              disabled: isDisabledNextDateBtn,
              icon: "vxe-icon-caret-right",
              onClick: dateNextEvent
            }),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-calendar--btn vxe-calendar--confirm-btn"
            }, [
              h("button", {
                class: "vxe-calendar--confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-calendar--body"
        }, renderDateTable())
      ];
    };
    calendarMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $input: $xeCalendar }, params));
      }
    };
    Object.assign($xeCalendar, calendarMethods);
    const renderVN = () => {
      const { className, type } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const calendarStyle = computeCalendarStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-calendar", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        style: calendarStyle
      }, [
        renderDatePanel()
      ]);
    };
    $xeCalendar.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        selectValue: null,
        inputValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
      dateOpenPanel();
    });
    watch(computeDateLabelFormat, () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    onMounted(() => {
      dateOpenPanel();
    });
    initValue();
    return $xeCalendar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/calendar/index.js
var VxeCalendar = Object.assign({}, calendar_default, {
  install(app) {
    app.component(calendar_default.name, calendar_default);
  }
});
dynamicApp.use(VxeCalendar);
VxeUI.component(calendar_default);
var Calendar = VxeCalendar;
var calendar_default2 = VxeCalendar;

// node_modules/vxe-pc-ui/es/loading/src/loading.js
var import_xe_utils55 = __toESM(require_xe_utils());
var loading_default = defineComponent({
  name: "VxeLoading",
  props: {
    modelValue: Boolean,
    icon: {
      type: String,
      default: () => getConfig().loading.icon
    },
    showIcon: {
      type: Boolean,
      default: () => getConfig().loading.showIcon
    },
    text: {
      type: String,
      default: () => getConfig().loading.text
    },
    showText: {
      type: Boolean,
      default: () => getConfig().loading.showText
    },
    status: String,
    size: {
      type: String,
      default: () => getConfig().loading.size || getConfig().size
    }
  },
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils55.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false
    });
    const computeMaps = {
      computeSize
    };
    const $xeLoading = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    const computeLoadingIcon = computed(() => {
      return props.icon || getIcon().LOADING;
    });
    const computeLoadingText = computed(() => {
      const { text } = props;
      return import_xe_utils55.default.isString(text) ? text : getI18n("vxe.loading.text");
    });
    const handleInit = () => {
      if (!reactData.initialized) {
        reactData.initialized = !!reactData.initialized;
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $loading: $xeLoading }, params));
    };
    const loadingMethods = {
      dispatchEvent: dispatchEvent2
    };
    const loadingPrivateMethods = {};
    Object.assign($xeLoading, loadingMethods, loadingPrivateMethods);
    const renderVN = () => {
      const { modelValue, showIcon, status } = props;
      const { initialized } = reactData;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const textSlot = slots.text;
      const iconSlot = slots.icon;
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      if (!initialized && !modelValue) {
        return createCommentVNode();
      }
      return h("div", {
        class: ["vxe-loading", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--visible": modelValue
        }]
      }, defaultSlot ? [
        h("div", {
          class: "vxe-loading--wrapper"
        }, getSlotVNs2(defaultSlot({})))
      ] : [
        h("div", {
          class: "vxe-loading--chunk"
        }, [
          showIcon && (iconSlot || loadingIcon) ? h("div", {
            class: "vxe-loading--icon"
          }, iconSlot ? getSlotVNs2(iconSlot({})) : [
            h("i", {
              class: loadingIcon
            })
          ]) : h("div", {
            class: "vxe-loading--spinner"
          }),
          textSlot || loadingText ? h("div", {
            class: "vxe-loading--text"
          }, textSlot ? getSlotVNs2(textSlot({})) : `${loadingText}`) : null
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      handleInit();
    });
    handleInit();
    $xeLoading.renderVN = renderVN;
    return $xeLoading;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/card/src/card.js
var import_xe_utils56 = __toESM(require_xe_utils());
var card_default = defineComponent({
  name: "VxeCard",
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => getConfig().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => getConfig().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => getConfig().card.padding
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils56.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCardStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCard = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $card: $xeCard }, params));
    };
    const cardMethods = {
      dispatchEvent: dispatchEvent2
    };
    const cardPrivateMethods = {};
    Object.assign($xeCard, cardMethods, cardPrivateMethods);
    const renderVN = () => {
      const { title, border, shadow, padding, loading: loading2, showTitleOverflow } = props;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const footerSlot = slots.footer;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const cardStyle = computeCardStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-card", {
          "is--border": border,
          "is--shadow": shadow,
          "is--padding": padding
        }],
        style: cardStyle
      }, [
        title || titleSlot || headerSlot ? h("div", {
          class: "vxe-card--header"
        }, headerSlot ? getSlotVNs2(headerSlot({})) : [
          h("div", {
            class: ["vxe-card--header-title", {
              "is--ellipsis": showTitleOverflow
            }]
          }, titleSlot ? getSlotVNs2(titleSlot({})) : `${title || ""}`),
          extraSlot ? h("div", {
            class: "vxe-card--header-extra"
          }, getSlotVNs2(extraSlot({}))) : createCommentVNode()
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-card--body"
        }, [
          leftSlot ? h("div", {
            class: "vxe-card--body-left"
          }, getSlotVNs2(leftSlot({}))) : createCommentVNode(),
          h("div", {
            class: "vxe-card--body-content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : []),
          rightSlot ? h("div", {
            class: "vxe-card--body-right"
          }, getSlotVNs2(rightSlot({}))) : createCommentVNode()
        ]),
        footerSlot ? h("div", {
          class: "vxe-card--footer"
        }, getSlotVNs2(footerSlot({}))) : createCommentVNode(),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-card--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeCard.renderVN = renderVN;
    return $xeCard;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/card/index.js
var VxeCard = Object.assign({}, card_default, {
  install(app) {
    app.component(card_default.name, card_default);
  }
});
dynamicApp.use(VxeCard);
VxeUI.component(card_default);
var Card = VxeCard;
var card_default2 = VxeCard;

// node_modules/vxe-pc-ui/es/carousel/src/carousel.js
var import_xe_utils57 = __toESM(require_xe_utils());
var carousel_default = defineComponent({
  name: "VxeCarousel",
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: Boolean,
    height: {
      type: [Number, String],
      default: () => getConfig().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => getConfig().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => getConfig().carousel.autoPlay
    },
    interval: {
      type: [Number, String],
      default: () => getConfig().carousel.interval
    },
    loop: {
      type: Boolean,
      default: () => getConfig().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => getConfig().carousel.showIndicators
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils57.default.uniqueId();
    const refElem = ref();
    const refWrapperElem = ref();
    const reactData = reactive({
      activeName: "",
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    });
    const internalData = {
      apTimeout: void 0,
      stopFlag: false
    };
    const refMaps = {
      refElem
    };
    const computeListStyle = computed(() => {
      const { vertical, options } = props;
      const { activeName, itemWidth, itemHeight, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const activeIndex = Math.max(0, import_xe_utils57.default.findIndexOf(list, (item) => item.name === activeName));
      const stys = {};
      if (vertical) {
        stys.transform = `translateY(-${activeIndex * itemHeight}px)`;
      } else {
        stys.width = `${itemWidth * list.length}px`;
        stys.transform = `translateX(-${activeIndex * itemWidth}px)`;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCarousel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateStyle = () => {
      nextTick(() => {
        const wrapperElem = refWrapperElem.value;
        if (wrapperElem) {
          reactData.itemWidth = wrapperElem.clientWidth;
          reactData.itemHeight = wrapperElem.clientHeight;
        }
      });
    };
    const clickItemEvent = (evnt, item) => {
      const value = item.name;
      reactData.activeName = item.name;
      emit("update:modelValue", value);
      emit("change", { value }, evnt);
      updateStyle();
    };
    const initDefaultActive = (list) => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          if (activeName === item.name) {
            validVal = true;
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCarousel }, params));
    };
    const handlePrevNext = (isNext) => {
      const { options, loop } = props;
      const { activeName, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const index2 = Math.max(0, import_xe_utils57.default.findIndexOf(list, (item) => item.name === activeName));
      if (index2 > -1) {
        let item = null;
        if (isNext) {
          if (index2 < list.length - 1) {
            item = list[index2 + 1];
          } else {
            if (loop) {
              item = list[0];
            }
          }
        } else {
          if (index2 > 0) {
            item = list[index2 - 1];
          } else {
            if (loop) {
              item = list[list.length - 1];
            }
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit("update:modelValue", value);
          return true;
        }
      }
      return false;
    };
    const carouselMethods = {
      dispatchEvent: dispatchEvent2,
      prev() {
        if (handlePrevNext(false)) {
          handleAutoPlay();
        }
        return nextTick();
      },
      next() {
        if (handlePrevNext(true)) {
          handleAutoPlay();
        }
        return nextTick();
      }
    };
    const prevEvent = (evnt) => {
      if (handlePrevNext(false)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const nextEvent = (evnt) => {
      if (handlePrevNext(true)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const stopAutoPlay = () => {
      const { apTimeout } = internalData;
      internalData.stopFlag = true;
      if (apTimeout) {
        clearTimeout(apTimeout);
        internalData.apTimeout = void 0;
      }
    };
    const handleAutoPlay = () => {
      const { autoPlay, interval } = props;
      const { stopFlag } = internalData;
      stopAutoPlay();
      if (autoPlay) {
        internalData.stopFlag = false;
        internalData.apTimeout = setTimeout(() => {
          if (!stopFlag) {
            handlePrevNext(true);
          }
        }, import_xe_utils57.default.toNumber(interval) || 300);
      }
    };
    const mouseenterEvent = () => {
      stopAutoPlay();
    };
    const mouseleaveEvent = () => {
      handleAutoPlay();
    };
    const carouselPrivateMethods = {};
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils57.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils57.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    Object.assign($xeCarousel, carouselMethods, carouselPrivateMethods);
    const renderItemWrapper = (list) => {
      const { height } = props;
      const { activeName } = reactData;
      const listStyle = computeListStyle.value;
      return h("div", {
        class: "vxe-carousel--list",
        style: listStyle
      }, list.map((item) => {
        const { name, url, slots: slots2 } = item;
        const defaultSlot = slots2 ? slots2.default : null;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--item-inner", {
            "is--active": activeName === name
          }],
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, defaultSlot ? callSlot(defaultSlot, {}) : [
          h("img", {
            class: "vxe-carousel--item-img",
            src: url
          })
        ]);
      }));
    };
    const renderIndicators = (list) => {
      const { activeName } = reactData;
      return h("div", {
        class: "vxe-carousel--indicators"
      }, list.map((item) => {
        const { name } = item;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--indicators-item", {
            "is--active": activeName === name
          }],
          onClick(evnt) {
            clickItemEvent(evnt, item);
          }
        });
      }));
    };
    const renderVN = () => {
      const { loading: loading2, height, width, showIndicators, vertical, options } = props;
      const { staticItems } = reactData;
      const defaultSlot = slots.default;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      return h("div", {
        ref: refElem,
        class: ["vxe-carousel", `is--${vertical ? "vertical" : "horizontal"}`],
        style: width ? {
          width: toCssUnit(width)
        } : null,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, [
        h("div", {
          class: "vxe-carousel--slots"
        }, defaultSlot ? defaultSlot({}) : []),
        h("div", {
          ref: refWrapperElem,
          class: "vxe-carousel--item-wrapper",
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, [
          renderItemWrapper(list)
        ]),
        showIndicators ? renderIndicators(list) : createCommentVNode(),
        h("div", {
          class: "vxe-carousel--btn-wrapper"
        }, [
          h("div", {
            class: "vxe-carousel--previous-btn",
            onClick: prevEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_PREVIOUS : getIcon().CAROUSEL_HORIZONTAL_PREVIOUS
            })
          ]),
          h("div", {
            class: "vxe-carousel--next-btn",
            onClick: nextEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_NEXT : getIcon().CAROUSEL_HORIZONTAL_NEXT
            })
          ])
        ]),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-carousel--loading",
          modelValue: loading2
        })
      ]);
    };
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultActive(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticItems ? reactData.staticItems.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultActive(reactData.staticItems);
    });
    watch(() => props.autoPlay, () => {
      handleAutoPlay();
    });
    initDefaultActive(reactData.staticItems.length ? reactData.staticItems : props.options);
    onMounted(() => {
      handleAutoPlay();
      updateStyle();
    });
    onUnmounted(() => {
      stopAutoPlay();
    });
    provide("$xeCarousel", $xeCarousel);
    $xeCarousel.renderVN = renderVN;
    return $xeCarousel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/carousel/index.js
var VxeCarousel = Object.assign({}, carousel_default, {
  install(app) {
    app.component(carousel_default.name, carousel_default);
  }
});
dynamicApp.use(VxeCarousel);
VxeUI.component(carousel_default);
var Carousel = VxeCarousel;
var carousel_default2 = VxeCarousel;

// node_modules/vxe-pc-ui/es/carousel/src/util.js
var import_xe_utils58 = __toESM(require_xe_utils());
function assembleCarouselItem($xeCarousel, elem, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(import_xe_utils58.default.arrayIndexOf(parentElem.children, elem), 0, itemConfig);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
function destroyCarouselItem($xeCarousel, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const index2 = import_xe_utils58.default.findIndexOf(staticItems, (item) => item.id === itemConfig.id);
  if (index2 > -1) {
    staticItems.splice(index2, 1);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}

// node_modules/vxe-pc-ui/es/carousel/src/carousel-item.js
var import_xe_utils59 = __toESM(require_xe_utils());
var carousel_item_default = defineComponent({
  name: "VxeCarouselItem",
  props: {
    name: [String, Number],
    className: String,
    url: String
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeCarousel = inject("$xeCarousel", null);
    const xID = import_xe_utils59.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const itemConfig = reactive({
      id: xID,
      name: props.name,
      url: props.url,
      className: props.className,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCarouselItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carouselItem: $xeCarouselItem }, params));
    };
    const carouselItemMethods = {
      dispatchEvent: dispatchEvent2
    };
    const carouselItemPrivateMethods = {};
    Object.assign($xeCarouselItem, carouselItemMethods, carouselItemPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    watch(() => props.name, (val) => {
      itemConfig.name = val;
    });
    watch(() => props.url, (val) => {
      itemConfig.url = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeCarousel && elem) {
        assembleCarouselItem($xeCarousel, elem, itemConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCarousel) {
        destroyCarouselItem($xeCarousel, itemConfig);
      }
    });
    $xeCarouselItem.renderVN = renderVN;
    return $xeCarouselItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/carousel-item/index.js
var VxeCarouselItem = Object.assign({}, carousel_item_default, {
  install(app) {
    app.component(carousel_item_default.name, carousel_item_default);
  }
});
dynamicApp.use(VxeCarouselItem);
VxeUI.component(carousel_item_default);
var CarouselItem = VxeCarouselItem;
var carousel_item_default2 = VxeCarouselItem;

// node_modules/vxe-pc-ui/es/checkbox/src/checkbox.js
var import_xe_utils60 = __toESM(require_xe_utils());
var checkbox_default = defineComponent({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number],
      default: null
    },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkbox.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeCheckboxGroup = inject("$xeCheckboxGroup", null);
    const xID = import_xe_utils60.default.uniqueId();
    const reactData = reactive({});
    const $xeCheckbox = {
      xID,
      props,
      context,
      reactData
    };
    let checkboxMethods = {};
    const { computeSize } = useSize(props);
    const computeIsChecked = computed(() => {
      if ($xeCheckboxGroup) {
        return import_xe_utils60.default.includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      const isChecked = computeIsChecked.value;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const { computeIsDisabled: computeIsGroupDisabled, computeIsMaximize: computeIsGroupMaximize } = $xeCheckboxGroup.getComputeMaps();
          const isGroupDisabled = computeIsGroupDisabled.value;
          const isGroupMaximize = computeIsGroupMaximize.value;
          return isGroupDisabled || isGroupMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = (evnt) => {
      const { checkedValue, uncheckedValue } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = { checked, value, label: props.label };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit("update:modelValue", value);
          checkboxMethods.dispatchEvent("change", params, evnt);
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $checkbox: $xeCheckbox }, params));
    };
    checkboxMethods = {
      dispatchEvent: dispatchEvent2
    };
    Object.assign($xeCheckbox, checkboxMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = !isChecked && props.indeterminate;
      return h("label", {
        class: ["vxe-checkbox", {
          [`size--${vSize}`]: vSize,
          "is--indeterminate": indeterminate,
          "is--disabled": isDisabled,
          "is--checked": isChecked
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: isDisabled,
          checked: isChecked,
          onChange: changeEvent
        }),
        h("span", {
          class: ["vxe-checkbox--icon", indeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
        }),
        h("span", {
          class: "vxe-checkbox--label"
        }, slots.default ? slots.default({}) : getFuncText2(props.content))
      ]);
    };
    $xeCheckbox.renderVN = renderVN;
    return $xeCheckbox;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/checkbox/index.js
var VxeCheckbox = Object.assign(checkbox_default, {
  install(app) {
    app.component(checkbox_default.name, checkbox_default);
  }
});
dynamicApp.use(VxeCheckbox);
VxeUI.component(checkbox_default);
var Checkbox = VxeCheckbox;
var checkbox_default2 = VxeCheckbox;

// node_modules/vxe-pc-ui/es/checkbox/src/group.js
var import_xe_utils61 = __toESM(require_xe_utils());
var group_default2 = defineComponent({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxGroup.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils61.default.uniqueId();
    const reactData = reactive({});
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, max } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils61.default.toNumber(max);
      }
      return false;
    });
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const computeMaps = {
      computeIsMaximize,
      computeIsDisabled
    };
    const $xeCheckboxGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $checkboxGroup: $xeCheckboxGroup }, params));
    };
    const checkboxGroupMethods = {
      dispatchEvent: dispatchEvent2
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const { checked, label } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit("update:modelValue", checklist);
        $xeCheckboxGroup.dispatchEvent("change", Object.assign({ checklist }, params), evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xeCheckboxGroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const { options } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return h("div", {
        class: "vxe-checkbox-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(checkbox_default, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    provide("$xeCheckboxGroup", $xeCheckboxGroup);
    $xeCheckboxGroup.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/checkbox-group/index.js
var VxeCheckboxGroup = Object.assign(group_default2, {
  install(app) {
    app.component(group_default2.name, group_default2);
  }
});
dynamicApp.use(VxeCheckboxGroup);
VxeUI.component(group_default2);
var CheckboxGroup = VxeCheckboxGroup;
var checkbox_group_default = VxeCheckboxGroup;

// node_modules/vxe-pc-ui/es/row/src/col.js
var import_xe_utils62 = __toESM(require_xe_utils());
var col_default = defineComponent({
  name: "VxeCol",
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean,
    size: {
      type: String,
      default: () => getConfig().col.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils62.default.uniqueId();
    useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const $xeRow = inject("$xeRow", null);
    const computeRowGutter = computed(() => {
      if ($xeRow) {
        return $xeRow.props.gutter;
      }
      return null;
    });
    const computeRowVertical = computed(() => {
      if ($xeRow) {
        return $xeRow.props.vertical;
      }
      return null;
    });
    const computeColStyle = computed(() => {
      const { width } = props;
      const rowGutter = computeRowGutter.value;
      const rowVertical = computeRowVertical.value;
      const style = {};
      if (rowGutter) {
        let [lrGutter, tbGutter] = import_xe_utils62.default.isArray(rowGutter) ? rowGutter : [rowGutter];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const padding = import_xe_utils62.default.isNumber(lrGutter) ? toCssUnit(lrGutter / 2) : `calc(${toCssUnit(lrGutter)} / 2)`;
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          const padding = import_xe_utils62.default.isNumber(tbGutter) ? toCssUnit(tbGutter / 2) : `calc(${toCssUnit(tbGutter)} / 2)`;
          style.paddingTop = padding;
          style.paddingBottom = padding;
        }
      }
      if (width) {
        style.width = toCssUnit(width);
      }
      return style;
    });
    const computeMaps = {};
    const $xeCol = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $col: $xeCol }, params));
    };
    const colMethods = {
      dispatchEvent: dispatchEvent2
    };
    const colPrivateMethods = {};
    Object.assign($xeCol, colMethods, colPrivateMethods);
    const renderVN = () => {
      const { span, fill, align, ellipsis } = props;
      const colStyle = computeColStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-col", span ? `span${span}` : "", align ? `align--${align}` : "", {
          "is--span": span,
          "is--fill": fill,
          "is--ellipsis": ellipsis
        }],
        style: colStyle
      }, [
        h("div", {
          class: "vxe-col--inner"
        }, defaultSlot ? defaultSlot({}) : [])
      ]);
    };
    $xeCol.renderVN = renderVN;
    return $xeCol;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/col/index.js
var VxeCol = Object.assign({}, col_default, {
  install(app) {
    app.component(col_default.name, col_default);
  }
});
dynamicApp.use(VxeCol);
VxeUI.component(col_default);
var Col = VxeCol;
var col_default2 = VxeCol;

// node_modules/vxe-pc-ui/es/collapse/src/collapse.js
var import_xe_utils63 = __toESM(require_xe_utils());
var collapse_default = defineComponent({
  name: "VxeCollapse",
  props: {
    modelValue: Array,
    options: Array,
    padding: {
      type: Boolean,
      default: () => getConfig().collapse.padding
    },
    expandConfig: Object,
    size: {
      type: String,
      default: () => getConfig().collapse.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "collapse-load"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils63.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      staticPanes: [],
      activeNames: [],
      initNames: [],
      cachePaneMaps: {}
    });
    const refMaps = {
      refElem
    };
    const computeItemOptions = computed(() => {
      const { options } = props;
      return (options || []).filter((item) => handleFilterItem(item));
    });
    const computeItemStaticOptions = computed(() => {
      const { staticPanes } = reactData;
      return staticPanes.filter((item) => handleFilterItem(item));
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig().collapse.expandConfig, props.expandConfig);
    });
    const computeMaps = {};
    const $xeCollapse = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterItem = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const addInitName = (name) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      const { activeNames } = reactData;
      const nameMaps = {};
      if (list && list.length) {
        list.forEach((item) => {
          const { name, preload } = item || {};
          if (name) {
            const isActive = activeNames.includes(name);
            nameMaps[`${name}`] = {
              loading: false
            };
            if (isActive) {
              addInitName(name);
            }
            if (preload) {
              if (!isActive) {
                activeNames.push(name);
              }
            }
          }
        });
      }
      reactData.activeNames = activeNames ? activeNames.slice(0) : [];
      reactData.cachePaneMaps = nameMaps;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $collapse: $xeCollapse }, params));
    };
    const collapseMethods = {
      dispatchEvent: dispatchEvent2
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils63.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils63.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const handleClickEvent = (evnt, item) => {
      const { activeNames } = reactData;
      const { name } = item;
      if (name) {
        const aIndex = activeNames.indexOf(name);
        if (aIndex === -1) {
          activeNames.push(name);
        } else {
          activeNames.splice(aIndex, 1);
        }
        addInitName(name);
      }
    };
    const collapsePrivateMethods = {};
    Object.assign($xeCollapse, collapseMethods, collapsePrivateMethods);
    const renderList2 = (itemList) => {
      const { activeNames, initNames } = reactData;
      const expandOpts = computeExpandOpts.value;
      return itemList.map((item) => {
        const { icon, name, title, slots: slots2 } = item;
        const titleSlot = slots2 ? slots2.title : null;
        const defaultSlot = slots2 ? slots2.default : null;
        const isActive = name && activeNames.includes(name);
        return h("div", {
          class: "vxe-collapse-item"
        }, [
          h("div", {
            class: "vxe-collapse--item-header",
            onClick(evnt) {
              handleClickEvent(evnt, item);
            }
          }, [
            expandOpts.showIcon ? h("span", {
              class: "vxe-collapse--item-switch"
            }, [
              h("i", {
                class: isActive ? getIcon().COLLAPSE_OPEN : getIcon().COLLAPSE_CLOSE
              })
            ]) : renderEmptyElement($xeCollapse),
            icon ? h("span", {
              class: "vxe-collapse--item-icon"
            }, [
              h("i", {
                class: icon
              })
            ]) : renderEmptyElement($xeCollapse),
            h("span", {
              class: "vxe-collapse--item-name"
            }, titleSlot ? callSlot(titleSlot, { name, title }) : `${title}`)
          ]),
          h("div", {
            class: ["vxe-collapse--item-content", {
              "is--visible": isActive
            }]
          }, [
            name && initNames.includes(name) ? h("div", {
              class: "vxe-collapse--item-inner"
            }, [
              defaultSlot ? callSlot(defaultSlot, { name, title }) : ""
            ]) : renderEmptyElement($xeCollapse)
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { padding } = props;
      const vSize = computeSize.value;
      const itemOptions = computeItemOptions.value;
      const itemStaticOptions = computeItemStaticOptions.value;
      const defaultSlot = slots.default;
      const itemList = defaultSlot ? itemStaticOptions : itemOptions;
      return h("div", {
        ref: refElem,
        class: ["vxe-collapse", {
          [`size--${vSize}`]: vSize,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-collapse-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderList2(itemList)
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeNames = val || [];
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticPanes ? reactData.staticPanes.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticPanes, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticPanes);
    });
    reactData.activeNames = props.modelValue || [];
    initDefaultName(reactData.staticPanes.length ? reactData.staticPanes : props.options);
    provide("$xeCollapse", $xeCollapse);
    $xeCollapse.renderVN = renderVN;
    return $xeCollapse;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/collapse/index.js
var VxeCollapse = Object.assign({}, collapse_default, {
  install(app) {
    app.component(collapse_default.name, collapse_default);
  }
});
dynamicApp.use(VxeCollapse);
VxeUI.component(collapse_default);
var Collapse = VxeCollapse;
var collapse_default2 = VxeCollapse;

// node_modules/vxe-pc-ui/es/collapse/src/collapse-pane.js
var import_xe_utils65 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/collapse/src/util.js
var import_xe_utils64 = __toESM(require_xe_utils());
function assembleCollapseItem($xeCollapse, elem, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticPanes.splice(import_xe_utils64.default.arrayIndexOf(parentElem.children, elem), 0, collapseConfig);
    $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
  }
}
function destroyCollapseItem($xeCollapse, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const matchObj = import_xe_utils64.default.findTree(staticPanes, (item) => item.id === collapseConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
}

// node_modules/vxe-pc-ui/es/collapse/src/collapse-pane.js
var collapse_pane_default = defineComponent({
  name: "VxeCollapsePane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils65.default.uniqueId();
    const $xeCollapse = inject("$xeCollapse", null);
    const refElem = ref();
    const reactData = reactive({});
    const collapseConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapsePane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $collapsePane: $xeCollapsePane }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeCollapsePane, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    watch(() => props.title, (val) => {
      collapseConfig.title = val;
    });
    watch(() => props.name, (val) => {
      collapseConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      collapseConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      collapseConfig.permissionCode = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeCollapse && elem) {
        assembleCollapseItem($xeCollapse, elem, collapseConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCollapse) {
        destroyCollapseItem($xeCollapse, collapseConfig);
      }
    });
    $xeCollapsePane.renderVN = renderVN;
    return $xeCollapsePane;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/collapse-pane/index.js
var VxeCollapsePane = Object.assign({}, collapse_pane_default, {
  install(app) {
    app.component(collapse_pane_default.name, collapse_pane_default);
  }
});
dynamicApp.use(VxeCollapsePane);
VxeUI.component(collapse_pane_default);
var CollapsePane = VxeCollapsePane;
var collapse_pane_default2 = VxeCollapsePane;

// node_modules/vxe-pc-ui/es/color-picker/src/color-picker.js
var import_xe_utils66 = __toESM(require_xe_utils());
var color_picker_default = defineComponent({
  name: "VxeColorPicker",
  props: {},
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils66.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeColorPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $colorPicker: $xeColorPicker }, params));
    };
    const colorPickerMethods = {
      dispatchEvent: dispatchEvent2
    };
    const colorPickerPrivateMethods = {};
    Object.assign($xeColorPicker, colorPickerMethods, colorPickerPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem,
        class: "vxe-color-picker"
      }, []);
    };
    $xeColorPicker.renderVN = renderVN;
    return $xeColorPicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/color-picker/index.js
var VxeColorPicker = Object.assign({}, color_picker_default, {
  install(app) {
    app.component(color_picker_default.name, color_picker_default);
  }
});
dynamicApp.use(VxeColorPicker);
VxeUI.component(color_picker_default);
var ColorPicker = VxeColorPicker;
var color_picker_default2 = VxeColorPicker;

// node_modules/vxe-pc-ui/es/text/src/text.js
var import_xe_utils67 = __toESM(require_xe_utils());
var text_default = defineComponent({
  name: "VxeText",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    loading: Boolean,
    content: [String, Number],
    clickToCopy: Boolean,
    size: {
      type: String,
      default: () => getConfig().text.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils67.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const clickIconEvent = () => {
      const { content, clickToCopy } = props;
      if (clickToCopy) {
        const contentEl = refContentElem.value;
        const copyVal = (contentEl ? contentEl.textContent : "") || content;
        if (copyVal) {
          if (VxeUI.clipboard.copy(copyVal)) {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.text.copySuccess"),
                status: "success"
              });
            }
          } else {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.text.copyError"),
                status: "error"
              });
            }
          }
        }
      }
    };
    const $xeText = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $text: $xeText }, params));
    };
    const textMethods = {
      dispatchEvent: dispatchEvent2
    };
    const clickEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent2("click", {}, evnt);
      }
    };
    const textPrivateMethods = {};
    Object.assign($xeText, textMethods, textPrivateMethods);
    const renderContent = () => {
      const { loading: loading2, icon, content, clickToCopy } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [
        loading2 ? h("span", {
          class: "vxe-text--loading"
        }, [
          h("i", {
            class: getIcon().TEXT_LOADING
          })
        ]) : iconSlot || icon || clickToCopy ? h("span", {
          class: "vxe-text--icon",
          onClick: clickIconEvent
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon || getIcon().TEXT_COPY
          })
        ]) : createCommentVNode(),
        h("span", {
          ref: refContentElem,
          class: "vxe-text--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils67.default.toValueString(content))
      ];
    };
    const renderVN = () => {
      const { loading: loading2, status, title, clickToCopy } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        title,
        class: ["vxe-text", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--copy": clickToCopy,
          "is--loading": loading2
        }],
        onClick: clickEvent
      }, renderContent());
    };
    $xeText.renderVN = renderVN;
    return $xeText;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/countdown/src/countdown.js
var import_xe_utils68 = __toESM(require_xe_utils());
var countdown_default = defineComponent({
  name: "VxeCountdown",
  props: {
    modelValue: [Number, String],
    format: String,
    prefixConfig: Object,
    suffixConfig: Object,
    size: {
      type: String,
      default: () => getConfig().countdown.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "start",
    "end"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils68.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      currNum: 0,
      secondNum: 0
    });
    const internalData = {
      dnTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeTimeFormats = computed(() => {
      const { secondNum } = reactData;
      if (secondNum >= 316224e5) {
        return ["yyyy", "MM", "dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 26784e5) {
        return ["MM", "dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 864e5) {
        return ["dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 36e5) {
        return ["HH", "mm", "ss"];
      }
      if (secondNum >= 6e4) {
        return ["mm", "ss"];
      }
      return ["ss"];
    });
    const computeDiffConf = computed(() => {
      const { currNum } = reactData;
      return import_xe_utils68.default.getDateDiff(Date.now(), Date.now() + currNum);
    });
    const computeFormatLabel = computed(() => {
      const { format: format4 } = props;
      const diffConf = computeDiffConf.value;
      let rest = "";
      if (format4) {
        rest = `${format4}`;
        import_xe_utils68.default.each(diffConf, (val, key) => {
          rest = rest.replace(new RegExp(key, "g"), import_xe_utils68.default.padStart(val, key.length, "0"));
        });
        return rest;
      }
      return rest;
    });
    const computePrefixOpts = computed(() => {
      return Object.assign({}, props.prefixConfig, getConfig().countdown.prefixConfig);
    });
    const computeSuffixOpts = computed(() => {
      return Object.assign({}, props.suffixConfig, getConfig().countdown.suffixConfig);
    });
    const computeMaps = {
      computeSize
    };
    const $xeCountdown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCountdown }, params));
    };
    const updateCount = () => {
      const secondNum = import_xe_utils68.default.toNumber(props.modelValue || 0);
      reactData.secondNum = secondNum;
      reactData.currNum = secondNum;
    };
    const handleTime = () => {
      const { currNum } = reactData;
      if (currNum > 1e3) {
        reactData.currNum -= 1e3;
        internalData.dnTimeout = setTimeout(() => {
          handleTime();
        }, 1e3);
      } else {
        reactData.currNum = 0;
        handleStop();
      }
    };
    const countdownMethods = {
      dispatchEvent: dispatchEvent2
    };
    const handleStart = () => {
      dispatchEvent2("start", {}, null);
      handleTime();
    };
    const handleStop = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
        dispatchEvent2("end", {}, null);
      }
    };
    const countdownPrivateMethods = {};
    Object.assign($xeCountdown, countdownMethods, countdownPrivateMethods);
    const renderDefaultContentVNs = () => {
      const { format: format4 } = props;
      const timeFormats = computeTimeFormats.value;
      const diffConf = computeDiffConf.value;
      const formatLabel = computeFormatLabel.value;
      if (format4) {
        return [
          h("div", {
            key: "format",
            class: "vxe-countdown--content-format"
          }, formatLabel)
        ];
      }
      return timeFormats.map((key, index2) => {
        return h("div", {
          key: index2,
          class: "vxe-countdown--content-item"
        }, [
          h("div", {
            class: "vxe-countdown--content-num"
          }, `${diffConf[key] || 0}`),
          h("div", {
            class: "vxe-countdown--content-unit"
          }, getI18n(`vxe.countdown.formats.${key}`))
        ]);
      });
    };
    const renderVN = () => {
      const { prefixConfig, suffixConfig } = props;
      const { currNum } = reactData;
      const vSize = computeSize.value;
      const diffConf = computeDiffConf.value;
      const prefixOpts = computePrefixOpts.value;
      const suffixOpts = computeSuffixOpts.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-countdown", diffConf.done ? "is--progress" : "is-end", {
          [`size--${vSize}`]: vSize
        }]
      }, [
        prefixSlot || prefixConfig ? h("div", {
          class: "vxe-countdown--prefix"
        }, prefixSlot ? getSlotVNs2(prefixSlot({ currentValue: currNum, diffConf })) : [
          h(text_default, {
            content: prefixOpts.content,
            icon: prefixOpts.icon,
            status: prefixOpts.status
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-countdown--content"
        }, defaultSlot ? getSlotVNs2(defaultSlot({ currentValue: currNum, diffConf })) : renderDefaultContentVNs()),
        suffixSlot || suffixConfig ? h("div", {
          class: "vxe-countdown--suffix"
        }, suffixSlot ? getSlotVNs2(suffixSlot({ currentValue: currNum, diffConf })) : [
          h(text_default, {
            content: suffixOpts.content,
            icon: suffixOpts.icon,
            status: suffixOpts.status
          })
        ]) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, () => {
      updateCount();
      handleStop();
      handleStart();
    });
    onUnmounted(() => {
      handleStop();
    });
    onMounted(() => {
      handleStart();
    });
    updateCount();
    $xeCountdown.renderVN = renderVN;
    return $xeCountdown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/countdown/index.js
var VxeCountdown = Object.assign({}, countdown_default, {
  install(app) {
    app.component(countdown_default.name, countdown_default);
  }
});
dynamicApp.use(VxeCountdown);
VxeUI.component(countdown_default);
var Countdown = VxeCountdown;
var countdown_default2 = VxeCountdown;

// node_modules/vxe-pc-ui/es/date-picker/src/date-picker.js
var import_xe_utils69 = __toESM(require_xe_utils());
var date_picker_default = defineComponent({
  name: "VxeDatePicker",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "date"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().datePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().datePicker.size || getConfig().size
    },
    multiple: Boolean,
    // dateweekmonthquarteryear
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePicker.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    //  startWeek startDay 
    startWeek: Number,
    // 
    maxlength: [String, Number],
    // 
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils69.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: "",
      isActivated: false,
      inputValue: "",
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDatePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let datePickerMethods = {};
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().datePicker.transfer;
        if (import_xe_utils69.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils69.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils69.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils69.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate2(item, dateValueFormat);
          if (import_xe_utils69.default.isValidDate(date)) {
            return date;
          }
          return date;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils69.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils69.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === "time") {
        return "HH:mm:ss";
      }
      if (type === "datetime") {
        return "yyyy-MM-dd HH:mm:ss";
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate2(modelValue, dateValueFormat);
        if (import_xe_utils69.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return import_xe_utils69.default.toDateString(datetimePanelValue, hasTimeSecond ? "HH:mm:ss" : "HH:mm");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { yearSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index2 = -4; index2 < yearSize + 4; index2++) {
          const date = import_xe_utils69.default.getWhatYear(startYearDate, index2, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index2 < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index2 >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return getI18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return getI18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return getI18n("vxe.input.date.dayLabel", [year, month ? getI18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils69.default.toNumber(import_xe_utils69.default.isNumber(startDay) || import_xe_utils69.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index2 = 0; index2 < 6; index2++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils69.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { quarterSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils69.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index2 = -2; index2 < quarterSize - 2; index2++) {
          const date = import_xe_utils69.default.getWhatQuarter(firstYear, index2);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils69.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { monthSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils69.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index2 = -4; index2 < monthSize - 4; index2++) {
          const date = import_xe_utils69.default.getWhatYear(selectMonth, 0, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils69.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils69.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index2 = 0; index2 < 42; index2++) {
          const date = import_xe_utils69.default.getWhatDay(startDayDate, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils69.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils69.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index2 = 0; index2 < 24; index2++) {
          list.push({
            value: index2,
            label: ("" + index2).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index2 = 0; index2 < 60; index2++) {
          list.push({
            value: index2,
            label: ("" + index2).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeDatePickerType = computed(() => {
      return "text";
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().datePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const updateModelValue = (modelValue) => {
      let val = "";
      if (modelValue) {
        if (import_xe_utils69.default.isNumber(modelValue) && /^[0-9]{11,15}$/.test(`${modelValue}`)) {
          val = new Date(modelValue);
        } else {
          val = modelValue;
        }
      }
      reactData.inputValue = val;
    };
    const parseDate2 = (value, format4) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      return import_xe_utils69.default.toStringDate(value, format4);
    };
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      datePickerMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils69.default.toValueString(props.modelValue) !== value) {
        datePickerMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      const inputElem = evnt.target;
      const value = inputElem.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          handleChange(value, evnt);
        } else {
          datePickerMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent3(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent3(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        datePickerMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = window.setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      handleChange("", evnt);
      datePickerMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        datePickerMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate2(value, dateValueFormat);
      }
      if (import_xe_utils69.default.isValidDate(dValue)) {
        dLabel = import_xe_utils69.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils69.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      updateModelValue(props.modelValue);
      if (isDatePickerType) {
        changeValue();
      }
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils69.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils69.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils69.default.toNumber(props.selectDay);
        date = import_xe_utils69.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        if (datetimePanelValue) {
          date.setHours(datetimePanelValue.getHours());
          date.setMinutes(datetimePanelValue.getMinutes());
          date.setSeconds(datetimePanelValue.getSeconds());
        }
      }
      const inpVal = import_xe_utils69.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils69.default.findIndexOf(dateListValue, (val) => import_xe_utils69.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              if (datetimePanelValue) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
              }
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map((date2) => import_xe_utils69.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils69.default.isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter((val) => !import_xe_utils69.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils69.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (inputValue) {
          let inpDateVal = parseDate2(inputValue, dateLabelFormat);
          if (import_xe_utils69.default.isValidDate(inpDateVal)) {
            if (type === "time") {
              inpDateVal = import_xe_utils69.default.toDateString(inpDateVal, dateLabelFormat);
              if (inputValue !== inpDateVal) {
                handleChange(inpDateVal, { type: "check" });
              }
              reactData.inputValue = inpDateVal;
            } else {
              let isChange = false;
              const firstDayOfWeek = computeFirstDayOfWeek.value;
              if (type === "datetime") {
                const dateValue = computeDateValue.value;
                if (inputValue !== import_xe_utils69.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils69.default.toDateString(inpDateVal, dateLabelFormat)) {
                  isChange = true;
                  if (datetimePanelValue) {
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                }
              } else {
                isChange = true;
              }
              reactData.inputValue = import_xe_utils69.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
              if (isChange) {
                dateChange(inpDateVal);
              }
            }
          } else {
            dateRevert();
          }
        } else {
          handleChange("", { type: "check" });
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      datePickerMethods.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const wheelEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils69.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils69.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -1, "first");
          } else {
            viewDate = import_xe_utils69.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        datePickerMethods.dispatchEvent("date-prev", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      datePickerMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils69.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, 1, "first");
          } else {
            viewDate = import_xe_utils69.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        datePickerMethods.dispatchEvent("date-next", { viewType: datePanelType, value, type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const { date } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      if (disabledMethod) {
        return disabledMethod({ type: datePanelType, viewType: datePanelType, date, $datePicker: $xeDatePicker });
      }
      return false;
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils69.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils69.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils69.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils69.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      const { datetimePanelValue } = reactData;
      reactData.datetimePanelValue = datetimePanelValue ? new Date(datetimePanelValue.getTime()) : /* @__PURE__ */ new Date();
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setHours(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                if (datetimePanelValue) {
                  item.setHours(datetimePanelValue.getHours());
                  item.setMinutes(datetimePanelValue.getMinutes());
                  item.setSeconds(datetimePanelValue.getSeconds());
                }
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map((date) => import_xe_utils69.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setMinutes(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setSeconds(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils69.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils69.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils69.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils69.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils69.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils69.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils69.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils69.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils69.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils69.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils69.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils69.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils69.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils69.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils69.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils69.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils69.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils69.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils69.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils69.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils69.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils69.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils69.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), (elem) => {
            updateTimePos(elem);
          });
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(targetElem);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.top = "";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = void 0;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el2 = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode2(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $datePicker: $xeDatePicker }, params));
    };
    datePickerMethods = {
      dispatchEvent: dispatchEvent2,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDatePicker, datePickerMethods);
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $datePicker: $xeDatePicker });
        const festivalItem = festivalRest ? import_xe_utils69.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils69.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-date-picker--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label}`),
            h("span", {
              class: ["vxe-date-picker--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils69.default.toValueString(extraItem.label))
          ] : `${label}`)
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils69.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-date-picker--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-date-picker--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-date-picker--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-date-picker--date-picker-header"
        }, [
          h("div", {
            class: "vxe-date-picker--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-date-picker--date-picker-label"
            }, selectDatePanelLabel) : h("span", {
              class: "vxe-date-picker--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h("div", {
            class: "vxe-date-picker--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-date-picker--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-date-picker--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-date-picker--time-picker-header"
        }, [
          hasTimeMinute ? h("div", {
            class: "vxe-date-picker--time-picker-title"
          }, dateTimeLabel) : createCommentVNode(),
          h("div", {
            class: "vxe-date-picker--time-picker-btn"
          }, [
            h("button", {
              class: "vxe-date-picker--time-picker-confirm",
              type: "button",
              onClick: dateConfirmEvent
            }, getI18n("vxe.button.confirm"))
          ])
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-date-picker--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-date-picker--time-picker-hour-list"
          }, hourList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-date-picker--time-picker-minute-list"
          }, minuteList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode(),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-date-picker--time-picker-second-list"
          }, secondList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode()
        ])
      ];
    };
    const renderPanel = () => {
      const { type } = props;
      const { initialized, isAniVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const btnTransfer = computeBtnTransfer.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-date-picker--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-date-picker--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            key: type || "default",
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-date-picker--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, initialized && (visiblePanel || isAniVisible) ? renders : [])
        ]);
      }
      return createCommentVNode();
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-date-picker--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-date-picker--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-date-picker--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils69.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-date-picker--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-date-picker--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]);
    };
    const renderExtraSuffixIcon = () => {
      return h("div", {
        class: "vxe-date-picker--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-date-picker--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderVN = () => {
      const { className, type, align, name, autocomplete, autoComplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-date-picker--readonly", `type--${type}`, className]
        }, inputValue);
      }
      const inputReadonly = computeInputReadonly.value;
      const inputType = computeDatePickerType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-date-picker", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils69.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-date-picker--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-date-picker--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode(),
        // 
        renderPanel()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      updateModelValue(val);
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: "",
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    nextTick(() => {
      globalEvents.on($xeDatePicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeDatePicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeDatePicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeDatePicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeDatePicker, "mousewheel");
      globalEvents.off($xeDatePicker, "mousedown");
      globalEvents.off($xeDatePicker, "keydown");
      globalEvents.off($xeDatePicker, "blur");
    });
    initValue();
    $xeDatePicker.renderVN = renderVN;
    return $xeDatePicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/date-picker/index.js
var VxeDatePicker = Object.assign({}, date_picker_default, {
  install(app) {
    app.component(date_picker_default.name, date_picker_default);
    app.component("VxeDateInput", date_picker_default);
  }
});
dynamicApp.use(VxeDatePicker);
VxeUI.component(date_picker_default);
var DatePicker = VxeDatePicker;
var date_picker_default2 = VxeDatePicker;

// node_modules/vxe-pc-ui/es/drawer/index.js
var import_xe_utils71 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/drawer/src/drawer.js
var import_xe_utils70 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/loading/index.js
var VxeLoading = Object.assign({}, loading_default, {
  install(app) {
    app.component(loading_default.name, loading_default);
  }
});
var LoadingController = {
  open(options) {
    const opts = Object.assign({}, options);
    dynamicStore.globalLoading = {
      modelValue: true,
      text: opts.text,
      icon: opts.icon
    };
    checkDynamic();
  },
  close() {
    dynamicStore.globalLoading = null;
  }
};
dynamicApp.use(VxeLoading);
VxeUI.component(loading_default);
VxeUI.loading = LoadingController;
var Loading2 = VxeLoading;
var loading_default2 = VxeLoading;

// node_modules/vxe-pc-ui/es/drawer/src/drawer.js
var allActiveDrawers = [];
var drawer_default = defineComponent({
  name: "VxeDrawer",
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: {
      type: [String, Object],
      default: () => getConfig().drawer.position
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().drawer.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().drawer.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().drawer.confirmClosable
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    resize: {
      type: Boolean,
      default: () => getConfig().drawer.resize
    },
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => getConfig().drawer.transfer
    },
    padding: {
      type: Boolean,
      default: () => getConfig().drawer.padding
    },
    size: {
      type: String,
      default: () => getConfig().drawer.size || getConfig().size
    },
    beforeHideMethod: {
      type: Function,
      default: () => getConfig().drawer.beforeHideMethod
    },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "resize"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils70.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refDrawerBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0
    });
    const refMaps = {
      refElem
    };
    const computeDragType = computed(() => {
      switch (props.position) {
        case "top":
          return "sb";
        case "bottom":
          return "st";
        case "left":
          return "wr";
      }
      return "wl";
    });
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = toCssUnit(width);
        boxElem.style.height = toCssUnit(height);
      }
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { drawerZIndex } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex2()) {
        reactData.drawerZIndex = nextZIndex2();
      }
    };
    const closeDrawer2 = (type) => {
      const { beforeHideMethod } = props;
      const { visible } = reactData;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils70.default.isError(rest)) {
            reactData.contentVisible = false;
            import_xe_utils70.default.remove(allActiveDrawers, (item) => item === $xeDrawer);
            dispatchEvent2("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              dispatchEvent2("hide", params, null);
            }, 200);
          }
        }).catch((e16) => e16);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      dispatchEvent2(type, { type }, evnt);
      closeDrawer2(type);
    };
    const confirmEvent = (evnt) => {
      const { confirmClosable } = props;
      const type = "confirm";
      dispatchEvent2(type, { type }, evnt);
      if (confirmClosable) {
        closeDrawer2(type);
      }
    };
    const cancelEvent = (evnt) => {
      const { cancelClosable } = props;
      const type = "cancel";
      dispatchEvent2(type, { type }, evnt);
      if (cancelClosable) {
        closeDrawer2(type);
      }
    };
    const openDrawer2 = () => {
      const { showFooter } = props;
      const { initialized, visible } = reactData;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          recalculate();
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            dispatchEvent2("show", params, null);
          });
        }, 10);
      }
      return nextTick();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $drawer: $xeDrawer }, params));
    };
    const drawerMethods = {
      dispatchEvent: dispatchEvent2,
      open: openDrawer2,
      close() {
        return closeDrawer2("close");
      },
      getBox
    };
    const selfClickEvent = (evnt) => {
      const el2 = refElem.value;
      if (props.maskClosable && evnt.target === el2) {
        const type = "mask";
        closeDrawer2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = import_xe_utils70.default.max(allActiveDrawers, (item) => item.reactData.drawerZIndex);
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              const type = "exit";
              dispatchEvent2("close", { type }, evnt);
              closeDrawer2(type);
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const { drawerZIndex } = reactData;
      if (allActiveDrawers.some((comp) => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { visibleHeight, visibleWidth } = getDomNode2();
      const marginSize = 0;
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = 0;
      const minHeight = 0;
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        dispatchEvent2("resize", params, evnt2);
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, title } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      return [
        h("div", {
          class: "vxe-drawer--header-title"
        }, titleSlot ? getSlotVNs2(titleSlot({ $drawer: $xeDrawer })) : title ? getFuncText2(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-drawer--header-right"
        }, [
          cornerSlot ? h("div", {
            class: "vxe-drawer--corner-wrapper"
          }, getSlotVNs2(cornerSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
          showClose ? h("div", {
            class: ["vxe-drawer--close-btn", "trigger--btn"],
            title: getI18n("vxe.drawer.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().DRAWER_CLOSE
            })
          ]) : renderEmptyElement($xeDrawer)
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showTitleOverflow } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        return h("div", {
          class: ["vxe-drawer--header", {
            "is--ellipsis": showTitleOverflow
          }]
        }, headerSlot ? getSlotVNs2(headerSlot({ $drawer: $xeDrawer })) : renderTitles());
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderBody = () => {
      const { slots: propSlots = {}, content } = props;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      return h("div", {
        class: "vxe-drawer--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-drawer--body-left"
        }, getSlotVNs2(leftSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
        h("div", {
          class: "vxe-drawer--body-default"
        }, [
          h("div", {
            class: "vxe-drawer--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({ $drawer: $xeDrawer })) : getFuncText2(content))
        ]),
        rightSlot ? h("div", {
          class: "vxe-drawer--body-right"
        }, getSlotVNs2(rightSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
        h(loading_default2, {
          class: "vxe-drawer--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton, loading: loading2 } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading2,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-drawer--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-drawer--footer-left"
        }, lfSlot ? getSlotVNs2(lfSlot({ $drawer: $xeDrawer })) : []),
        h("div", {
          class: "vxe-drawer--footer-right"
        }, rfSlot ? getSlotVNs2(rfSlot({ $drawer: $xeDrawer })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-drawer--footer"
        }, footerSlot ? getSlotVNs2(footerSlot({ $drawer: $xeDrawer })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, position, loading: loading2, lockScroll, padding, lockView, mask, resize, destroyOnClose } = props;
      const { initialized, contentVisible, visible } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const dragType = computeDragType.value;
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !initialized : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-drawer--wrapper", `pos--${position}`, className || "", {
            [`size--${vSize}`]: vSize,
            "is--padding": padding,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--resize": resize,
            "is--mask": mask,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading2
          }],
          style: {
            zIndex: reactData.drawerZIndex
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refDrawerBox,
            class: "vxe-drawer--box",
            onMousedown: boxMousedownEvent
          }, [
            asideSlot ? h("div", {
              class: "vxe-drawer--aside"
            }, getSlotVNs2(asideSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
            h("div", {
              class: "vxe-drawer--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter(),
              resize ? h("span", {
                class: "vxe-drawer--resize"
              }, [
                h("span", {
                  class: `${dragType}-resize`,
                  type: dragType,
                  onMousedown: dragEvent
                })
              ]) : renderEmptyElement($xeDrawer)
            ])
          ])
        ])
      ]);
    };
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openDrawer2();
      } else {
        closeDrawer2("model");
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (props.modelValue) {
          openDrawer2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeDrawer, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeDrawer, "keydown");
    });
    provide("$xeDrawer", "$xeDrawer");
    $xeDrawer.renderVN = renderVN;
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/drawer/index.js
function handleDrawer(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveDrawers.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: import_xe_utils71.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter((item) => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id2) {
  return import_xe_utils71.default.find(allActiveDrawers, ($drawer) => $drawer.props.id === id2);
}
function closeDrawer(id2) {
  const drawers = id2 ? [getDrawer(id2)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach(($drawer) => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
function openDrawer(options) {
  return handleDrawer(Object.assign({}, options));
}
var DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
var VxeDrawer = Object.assign(drawer_default, {
  install: function(app) {
    app.component(drawer_default.name, drawer_default);
  }
});
VxeUI.drawer = DrawerController;
dynamicApp.use(VxeDrawer);
VxeUI.component(drawer_default);
var Drawer = VxeDrawer;
var drawer_default2 = VxeDrawer;

// node_modules/vxe-pc-ui/es/empty/src/empty.js
var import_xe_utils72 = __toESM(require_xe_utils());
var empty_default = defineComponent({
  name: "VxeEmpty",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    status: String,
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils72.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeEmpty = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $empty: $xeEmpty }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeEmpty, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { imageUrl, imageStyle, icon, status, content } = props;
      return h("div", {
        ref: refElem,
        class: ["vxe-empty", {
          [`theme--${status}`]: status
        }]
      }, [
        h("div", {
          class: "vxe-empty--inner"
        }, [
          imageUrl ? h("div", {
            class: "vxe-empty--img-wrapper"
          }, [
            h("img", {
              src: imageUrl,
              style: imageStyle
            })
          ]) : h("div", {
            class: "vxe-empty--icon-wrapper"
          }, [
            h("i", {
              class: icon || getIcon().EMPTY_DEFAULT
            })
          ]),
          h("div", {
            class: "vxe-empty--content-wrapper"
          }, `${content || getI18n("vxe.empty.defText")}`)
        ])
      ]);
    };
    $xeEmpty.renderVN = renderVN;
    return $xeEmpty;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/empty/index.js
var VxeEmpty = Object.assign({}, empty_default, {
  install(app) {
    app.component(empty_default.name, empty_default);
  }
});
dynamicApp.use(VxeEmpty);
VxeUI.component(empty_default);
var Empty = VxeEmpty;
var empty_default2 = VxeEmpty;

// node_modules/vxe-pc-ui/es/form/src/form.js
var import_xe_utils78 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form/src/util.js
var import_xe_utils74 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form/src/itemInfo.js
var import_xe_utils73 = __toESM(require_xe_utils());
var ItemInfo = class {
  constructor($xeForm, item) {
    Object.assign(this, {
      id: import_xe_utils73.default.uniqueId("item_"),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      verticalAlign: item.verticalAlign,
      titleBackground: item.titleBackground,
      titleBold: item.titleBold,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      vertical: item.vertical,
      padding: item.padding,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      showContent: item.showContent,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: item.itemRender,
      rules: item.rules,
      // 
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/vxe-pc-ui/es/form/src/util.js
function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeForm, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeForm, _vm);
}
function handleFieldOrItem($xeForm, fieldOrItem) {
  if (fieldOrItem) {
    return import_xe_utils74.default.isString(fieldOrItem) ? $xeForm.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { collapseAll } = reactData;
  const { folding, visible } = formItem;
  return visible === false || folding && collapseAll;
}
function isActiveItem($xeForm, formItem) {
  let { visibleMethod, itemRender, visible, field } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const fiVisibleMethod = compConf ? compConf.formItemVisibleMethod || compConf.itemVisibleMethod : null;
  if (!visibleMethod && fiVisibleMethod) {
    visibleMethod = fiVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const formProps = $xeForm.props;
  const { data } = formProps;
  return visibleMethod({ data, field, property: field, item: formItem, $form: $xeForm, $grid: $xeForm.xegrid });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      formItem.update(name, value);
    });
  });
}
function assembleItem($xeForm, el2, formItem, formGroup) {
  const { reactData } = $xeForm;
  const formProps = $xeForm.props;
  const { customLayout } = formProps;
  const { staticItems } = reactData;
  if (customLayout) {
    if (!staticItems.some((item) => item.id === formItem.id)) {
      staticItems.push(formItem);
    }
  } else {
    if (el2) {
      const parentElem = el2.parentNode;
      const parentItem = formGroup ? formGroup.formItem : null;
      const parentItems = parentItem ? parentItem.children : staticItems;
      if (parentElem) {
        parentItems.splice(import_xe_utils74.default.arrayIndexOf(parentElem.children, el2), 0, formItem);
        reactData.staticItems = staticItems.slice(0);
      }
    }
  }
}
function destroyItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { staticItems } = reactData;
  const index2 = import_xe_utils74.default.findIndexOf(staticItems, (item) => item.id === formItem.id);
  if (index2 > -1) {
    staticItems.splice(index2, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}

// node_modules/vxe-pc-ui/es/icon/src/icon.js
var import_xe_utils75 = __toESM(require_xe_utils());
var icon_default = defineComponent({
  name: "VxeIcon",
  props: {
    name: String,
    className: String,
    roll: Boolean,
    status: String,
    size: {
      type: String,
      default: () => getConfig().icon.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils75.default.uniqueId();
    const { computeSize } = useSize(props);
    const $xeIcon = {
      xID,
      props,
      context
    };
    const clickEvent = (evnt) => {
      emit("click", createEvent(evnt, {}));
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $icon: $xeIcon }, params));
    };
    const iconMethods = {
      dispatchEvent: dispatchEvent2
    };
    const iconPrivateMethods = {};
    Object.assign($xeIcon, iconMethods, iconPrivateMethods);
    const renderVN = () => {
      const { name, roll, status, className } = props;
      const vSize = computeSize.value;
      return h("i", {
        class: ["vxe-icon", `vxe-icon-${name}`, `${className || ""}`, {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          roll
        }],
        onClick: clickEvent
      });
    };
    $xeIcon.renderVN = renderVN;
    return $xeIcon;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/src/render.js
var import_xe_utils76 = __toESM(require_xe_utils());
function renderPrefixIcon(titlePrefix) {
  return h("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    h(icon_default, {
      class: titlePrefix.icon || getIcon().FORM_PREFIX,
      status: titlePrefix.iconStatus
    })
  ]);
}
function renderSuffixIcon(titleSuffix) {
  return h("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    h(icon_default, {
      class: titleSuffix.icon || getIcon().FORM_SUFFIX,
      status: titleSuffix.iconStatus
    })
  ]);
}
var getItemClass = ($xeForm, item, isGroup) => {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const { data, rules, readonly, disabled, span: allSpan, titleBackground: allTitleBackground, titleBold: allTitleBold, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, vertical: allVertical, padding: allPadding } = formProps;
  const { collapseAll } = formReactData;
  const { folding, field, itemRender, showError, className, vertical, padding, children, showContent } = item;
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : "";
  const span = item.span || allSpan;
  const itemPadding = import_xe_utils76.default.eqNull(padding) ? allPadding : padding;
  const itemVertical = import_xe_utils76.default.eqNull(vertical) ? allVertical : vertical;
  const titleBackground = import_xe_utils76.default.eqNull(item.titleBackground) ? allTitleBackground : item.titleBackground;
  const titleBold = import_xe_utils76.default.eqNull(item.titleBold) ? allTitleBold : item.titleBold;
  const titleColon = import_xe_utils76.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
  const titleAsterisk = import_xe_utils76.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  const hasGroup = children && children.length > 0;
  let isRequired = false;
  let isValid = false;
  if (!readonly && rules) {
    const itemRules = rules[field];
    if (itemRules && itemRules.length) {
      isValid = true;
      isRequired = itemRules.some((rule) => rule.required);
    }
  }
  return [
    isGroup || hasGroup ? "vxe-form--group" : "",
    "vxe-form--item",
    item.id,
    span ? `vxe-form--item-col_${span} is--span` : "",
    className ? import_xe_utils76.default.isFunction(className) ? className(params) : className : "",
    itemClassName ? import_xe_utils76.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
    {
      "is--colon": titleColon,
      "is--tbg": titleBackground,
      "is--bold": titleBold,
      "is--padding": itemPadding,
      "is--vertical": itemVertical,
      "is--asterisk": titleAsterisk,
      "hide--content": showContent === false,
      "is--valid": isValid,
      "is--required": isRequired,
      "is--hidden": folding && collapseAll,
      "is--active": isActiveItem($xeForm, item),
      "is--error": showError
    }
  ];
};
var getItemContentClass = ($xeForm, item, isGroup) => {
  const formProps = $xeForm.props;
  const { data, readonly, disabled, align: allAlign, verticalAlign: allVerticalAlign } = formProps;
  const { field, itemRender, contentClassName, children } = item;
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : "";
  const align = import_xe_utils76.default.eqNull(item.align) ? allAlign : item.align;
  const verticalAlign = import_xe_utils76.default.eqNull(item.verticalAlign) ? allVerticalAlign : item.verticalAlign;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  const hasGroup = children && children.length > 0;
  return [
    isGroup || hasGroup ? "vxe-form--group-content vxe-form--item-row" : "",
    "vxe-form--item-content",
    align ? `align--${align}` : "",
    verticalAlign ? `vertical-align--${verticalAlign}` : "",
    itemContentClassName ? import_xe_utils76.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
    contentClassName ? import_xe_utils76.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
  ];
};
function renderTitle($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const { data, readonly, disabled, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleOverflow: allTitleOverflow, vertical: allVertical } = formProps;
  const { slots, title, field, itemRender, titleOverflow, vertical, showTitle, titleClassName, titleStyle, titlePrefix, titleSuffix, children, showContent } = item;
  const { computeTooltipOpts } = $xeForm.getComputeMaps();
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : "";
  const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
  const itemVertical = import_xe_utils76.default.eqNull(vertical) ? allVertical : vertical;
  const titleAlign = import_xe_utils76.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
  const titleWidth = itemVertical ? null : import_xe_utils76.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
  const itemOverflow = import_xe_utils76.default.eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
  const ovEllipsis = itemOverflow === "ellipsis";
  const ovTitle = itemOverflow === "title";
  const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
  const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  const titleSlot = slots ? slots.title : null;
  const extraSlot = slots ? slots.extra : null;
  const isTitle = showTitle !== false && (title || titleSlot);
  const hasGroup = children && children.length > 0;
  const titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titlePrefix), { content: getFuncText2(titlePrefix.content || titlePrefix.message) }), {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  const rftTitle = compConf ? compConf.renderFormItemTitle || compConf.renderItemTitle : null;
  titVNs.push(h("span", {
    class: "vxe-form--item-title-label"
  }, titleSlot ? $xeForm.callSlot(titleSlot, params) : rftTitle ? getSlotVNs2(rftTitle(itemRender, params)) : getFuncText2(item.title)));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titleSuffix), { content: getFuncText2(titleSuffix.content || titleSuffix.message) }), {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  const ons = ovTooltip ? {
    onMouseenter(evnt) {
      $xeForm.triggerTitleTipEvent(evnt, params);
    },
    onMouseleave: $xeForm.handleTitleTipLeaveEvent
  } : {};
  return isTitle ? h("div", Object.assign({ class: [
    isGroup || hasGroup ? "vxe-form--group-title" : "",
    "vxe-form--item-title",
    titleAlign ? `align--${titleAlign}` : "",
    hasEllipsis ? "is--ellipsis" : "",
    itemTitleClassName ? import_xe_utils76.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
    titleClassName ? import_xe_utils76.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
  ], style: Object.assign({}, import_xe_utils76.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils76.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth && showContent !== false ? {
    width: toCssUnit(titleWidth)
  } : null), title: ovTitle ? getFuncText2(title) : null }, ons), [
    h("div", {
      class: "vxe-form--item-title-content"
    }, titVNs),
    h("div", {
      class: "vxe-form--item-title-postfix"
    }, fixVNs),
    extraSlot ? h("div", {
      class: "vxe-form--item-title-extra"
    }, $xeForm.callSlot(extraSlot, params)) : createCommentVNode()
  ]) : createCommentVNode();
}
var renderItemContent = ($xeForm, item) => {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const { computeCollapseOpts, computeValidOpts } = $xeForm.getComputeMaps();
  const { data, readonly, disabled } = formProps;
  const { collapseAll } = formReactData;
  const { slots, field, itemRender, collapseNode, errRule } = item;
  const defaultSlot = slots ? slots.default : null;
  const validSlot = slots ? slots.valid : null;
  const collapseOpts = computeCollapseOpts.value;
  const validOpts = computeValidOpts.value;
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  let contentVNs = [];
  const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
  if (defaultSlot) {
    contentVNs = $xeForm.callSlot(defaultSlot, params);
  } else if (rftContent) {
    contentVNs = getSlotVNs2(rftContent(itemRender, params));
  } else if (field) {
    contentVNs = [`${import_xe_utils76.default.get(data, field)}`];
  }
  if (collapseNode) {
    contentVNs.push(h("div", {
      class: "vxe-form--item-trigger-node",
      onClick: $xeForm.toggleCollapseEvent
    }, [
      h("span", {
        class: "vxe-form--item-trigger-text"
      }, collapseAll ? collapseOpts.unfoldButtonText || getI18n("vxe.form.unfolding") : collapseOpts.foldButtonText || getI18n("vxe.form.folding")),
      h("i", {
        class: ["vxe-form--item-trigger-icon", collapseAll ? collapseOpts.foldIcon || getIcon().FORM_FOLDING : collapseOpts.unfoldIcon || getIcon().FORM_UNFOLDING]
      })
    ]));
  }
  if (errRule && validOpts.showMessage) {
    const validParams = Object.assign(Object.assign({}, params), { rule: errRule });
    contentVNs.push(h("div", {
      class: "vxe-form-item--valid-error-tip",
      style: errRule.maxWidth ? {
        width: toCssUnit(errRule.maxWidth)
      } : null
    }, [
      h("div", {
        class: `vxe-form-item--valid-error-wrapper vxe-form-item--valid-error-theme-${validOpts.theme || "normal"}`
      }, [
        validSlot ? $xeForm.callSlot(validSlot, validParams) : [
          h("span", {
            class: "vxe-form--item--valid-error-msg"
          }, errRule.content || errRule.message)
        ]
      ])
    ]));
  }
  return h("div", {
    class: "vxe-form--item-inner"
  }, contentVNs);
};

// node_modules/vxe-pc-ui/es/form/src/form-config-item.js
var import_xe_utils77 = __toESM(require_xe_utils());
var VxeFormConfigItem = defineComponent({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeForm = inject("$xeForm", {});
    const xeformiteminfo = { itemConfig: props.itemConfig };
    provide("xeFormItemInfo", xeformiteminfo);
    const renderItem = ($xeForm2, item) => {
      const formProps = $xeForm2.props;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle, children, showContent } = item;
      const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeForm2.xegrid };
      const hasGroup = children && children.length > 0;
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        key: item.id,
        class: getItemClass($xeForm2, item),
        style: import_xe_utils77.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm2, item),
        showContent === false ? createCommentVNode() : h("div", {
          class: getItemContentClass($xeForm2, item),
          style: Object.assign({}, import_xe_utils77.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils77.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, hasGroup ? children.map((childItem) => renderItem($xeForm2, childItem)) : [
          renderItemContent($xeForm2, item)
        ])
      ]);
    };
    const renderVN = () => {
      return renderItem($xeForm, props.itemConfig);
    };
    const $xeFormconfigitem = {
      renderVN
    };
    provide("$xeFormGroup", null);
    return $xeFormconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
var form_config_item_default = VxeFormConfigItem;

// node_modules/vxe-pc-ui/es/form/src/form.js
var Rule2 = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText2(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var validErrorRuleValue = (rule, val) => {
  const { type, min, max, pattern } = rule;
  const isNumType = type === "number";
  const numVal = isNumType ? import_xe_utils78.default.toNumber(val) : import_xe_utils78.default.getSize(val);
  if (isNumType && isNaN(val)) {
    return true;
  }
  if (!import_xe_utils78.default.eqNull(min) && numVal < import_xe_utils78.default.toNumber(min)) {
    return true;
  }
  if (!import_xe_utils78.default.eqNull(max) && numVal > import_xe_utils78.default.toNumber(max)) {
    return true;
  }
  if (pattern && !(import_xe_utils78.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
};
var form_default = defineComponent({
  name: "VxeForm",
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => getConfig().form.size || getConfig().size
    },
    span: {
      type: [String, Number],
      default: () => getConfig().form.span
    },
    align: {
      type: String,
      default: () => getConfig().form.align
    },
    verticalAlign: {
      type: String,
      default: () => getConfig().form.verticalAlign
    },
    border: {
      type: Boolean,
      default: () => getConfig().form.border
    },
    titleBackground: {
      type: Boolean,
      default: () => getConfig().form.titleBackground
    },
    titleBold: {
      type: Boolean,
      default: () => getConfig().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => getConfig().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => getConfig().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => getConfig().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => getConfig().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => getConfig().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => getConfig().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => getConfig().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    collapseConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => getConfig().form.customLayout
    }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils78.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    const internalData = reactive({
      meTimeout: void 0,
      stTimeout: void 0,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    provide("xeFormItemInfo", null);
    const $xeGrid = inject("$xeGrid", null);
    const refElem = ref();
    const refTooltip = ref();
    let formMethods = {};
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig().form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig().tooltip, getConfig().form.tooltipConfig, props.tooltipConfig);
    });
    const computeCollapseOpts = computed(() => {
      return Object.assign({}, getConfig().form.collapseConfig, props.collapseConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts,
      computeCollapseOpts
    };
    const $xeForm = {
      xID,
      props,
      context,
      reactData,
      xegrid: $xeGrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils78.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils78.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = (list) => {
      if (list.length) {
        if (true) {
          list.forEach((item) => {
            if (item.slots) {
              import_xe_utils78.default.each(item.slots, (func) => {
                if (!import_xe_utils78.default.isFunction(func)) {
                  if (!slots[func]) {
                    errLog2("vxe.error.notSlot", [func]);
                  }
                }
              });
            }
          });
        }
      }
      reactData.staticItems = import_xe_utils78.default.mapTree(list, (item) => createItem($xeForm, item), { children: "children" });
      return nextTick();
    };
    const getItems = () => {
      const itemList = [];
      import_xe_utils78.default.eachTree(reactData.formItems, (item) => {
        itemList.push(item);
      }, { children: "children" });
      return itemList;
    };
    const getItemByField = (field) => {
      const rest = import_xe_utils78.default.findTree(reactData.formItems, (item) => item.field === field, { children: "children" });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit("update:collapseStatus", status);
      return nextTick();
    };
    const toggleCollapseEvent = (evnt) => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent("toggle-collapse", { status, collapse: status, data: props.data }, evnt);
      formMethods.dispatchEvent("collapse", { status, collapse: status, data: props.data }, evnt);
    };
    const clearValidate = (fieldOrItem) => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!import_xe_utils78.default.isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach((field) => {
          if (field) {
            const item = handleFieldOrItem($xeForm, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach((item) => {
          item.showError = false;
        });
      }
      return nextTick();
    };
    const getResetValue = (item, data) => {
      const { field, resetValue } = item;
      const itemValue = import_xe_utils78.default.get(data, field);
      if (import_xe_utils78.default.isFunction(resetValue)) {
        return resetValue({ field, item, data, $form: $xeForm, $grid: $xeForm.xegrid });
      } else if (resetValue === null) {
        if (import_xe_utils78.default.isArray(itemValue)) {
          return [];
        }
      }
    };
    const reset = () => {
      const { data } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach((item) => {
          const { field, itemRender } = item;
          if (isEnableConf2(itemRender)) {
            const compConf = renderer.get(itemRender.name);
            const fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({ data, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid });
            } else if (field) {
              import_xe_utils78.default.set(data, field, getResetValue(item, data));
            }
          }
        });
      }
      return clearValidate();
    };
    const resetEvent = (evnt) => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent("reset", { data: props.data }, evnt);
    };
    const handleFocus = (fields) => {
      const el2 = refElem.value;
      if (el2) {
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const item = getItemByField(field);
          if (item && isEnableConf2(item.itemRender)) {
            const { itemRender } = item;
            const compConf = renderer.get(itemRender.name);
            if (!i) {
              scrollToView2(el2.querySelector(`.${item.id}`));
            }
            let inputElem = null;
            const autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            if (import_xe_utils78.default.isFunction(autoFocus)) {
              inputElem = autoFocus({ $form: $xeForm, $grid: $xeGrid, item, data: props.data, field });
            } else {
              if (autoFocus === true) {
                inputElem = el2.querySelector(`.${item.id} input,textarea`);
              } else if (autoFocus) {
                inputElem = el2.querySelector(`.${item.id} ${autoFocus}`);
              }
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    };
    const validItemRules = (validType, fields, val) => {
      const { data, rules: formRules } = props;
      const errorMaps = {};
      if (!import_xe_utils78.default.isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map((property) => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = import_xe_utils78.default.get(formRules, property);
          if (rules) {
            const itemValue = import_xe_utils78.default.isUndefined(val) ? import_xe_utils78.default.get(data, property) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeForm
                  };
                  let customValid;
                  if (import_xe_utils78.default.isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog2("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog2("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils78.default.isError(customValid)) {
                      errorRules.push(new Rule2({ type: "custom", trigger, content: customValid.message, rule: new Rule2(rule) }));
                    } else if (customValid.catch) {
                      syncVailds.push(customValid.catch((e16) => {
                        errorRules.push(new Rule2({ type: "custom", trigger, content: e16 ? e16.message : rule.content || rule.message, rule: new Rule2(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils78.default.isArray(itemValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !itemValue.length;
                  } else if (import_xe_utils78.default.isString(itemValue)) {
                    hasEmpty = eqEmptyValue2(itemValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue2(itemValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {
                    errorRules.push(new Rule2(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map((rule) => {
              return {
                $form: $xeForm,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!import_xe_utils78.default.isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    const beginValidate = (itemList, type, callback) => {
      const { data, rules: formRules } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(internalData.meTimeout);
      if (data && formRules) {
        itemList.forEach((item) => {
          const { field } = item;
          if (field && !isHiddenItem($xeForm, item) && isActiveItem($xeForm, item)) {
            itemValids.push(validItemRules(type || "all", field).then(() => {
              item.errRule = null;
            }).catch((errorMaps) => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise((resolve) => {
            internalData.meTimeout = window.setTimeout(() => {
              itemList.forEach((item) => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              nextTick(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = (callback) => {
      const { readonly } = props;
      clearValidate();
      if (readonly) {
        return nextTick();
      }
      return beginValidate(getItems(), "", callback);
    };
    const validateField = (fieldOrItem, callback) => {
      const { readonly } = props;
      if (readonly) {
        return nextTick();
      }
      let fields = [];
      if (fieldOrItem) {
        if (import_xe_utils78.default.isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return beginValidate(fields.map((field) => handleFieldOrItem($xeForm, field)), "", callback);
    };
    const submitEvent = (evnt) => {
      const { readonly } = props;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        if (readonly) {
          formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          return;
        }
        beginValidate(getItems()).then((errMap) => {
          if (errMap) {
            formMethods.dispatchEvent("submit-invalid", { data: props.data, errMap }, evnt);
          } else {
            formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          }
        });
      }
    };
    const closeTooltip = () => {
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return nextTick();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const { item } = params;
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || "").trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.stTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.stTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ["blur"].includes(evnt.type) ? "blur" : "change" : "all", field, itemValue).then(() => {
          clearValidate(field);
        }).catch((errorMaps) => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return nextTick();
    };
    const updateStatus = (scope, itemValue) => {
      const { field } = scope;
      return triggerItemEvent(new Event("change"), field, itemValue);
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $form: $xeForm, $grid: $xeGrid }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeForm, formMethods, formPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, border, className, data, customLayout } = props;
      const { formItems } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return h("form", {
        ref: refElem,
        class: ["vxe-form", className ? import_xe_utils78.default.isFunction(className) ? className({ items: formItems, data, $form: $xeForm }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--border": border,
          "custom--layout": customLayout,
          "is--loading": loading2
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [
        h("div", {
          class: "vxe-form--wrapper vxe-form--item-row"
        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index2) => {
          return h(form_config_item_default, {
            key: index2,
            itemConfig: item
          });
        })),
        h("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-form--loading",
          modelValue: loading2
        }),
        /**
         * 
         */
        h(tooltip_default, Object.assign({ ref: refTooltip }, tooltipOpts))
      ]);
    };
    const staticItemFlag = ref(0);
    watch(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    watch(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
    });
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => props.collapseStatus, (value) => {
      reactData.collapseAll = !!value;
    });
    watch(() => props.readonly, () => {
      clearValidate();
    });
    watch(() => props.disabled, () => {
      clearValidate();
    });
    onMounted(() => {
      nextTick(() => {
        if (true) {
          if (props.customLayout && props.items) {
            errLog2("vxe.error.errConflicts", ["custom-layout", "items"]);
          }
        }
      });
    });
    if (props.items) {
      loadItem(props.items);
    }
    provide("$xeForm", $xeForm);
    provide("$xeFormGroup", null);
    provide("$xeFormItem", null);
    $xeForm.renderVN = renderVN;
    return $xeForm;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/render/index.js
var import_xe_utils79 = __toESM(require_xe_utils());
var componentDefaultModelProp2 = "modelValue";
function getOldComponentName2(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent2({ name }) {
  return resolveComponent(name);
}
function getOldComponent2({ name }) {
  return resolveComponent(getOldComponentName2(name));
}
function getNativeAttrs2(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils79.default.assign({}, defaultProps, renderOpts.props, { [componentDefaultModelProp2]: value });
}
function getNativeElementOns2(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent2(renderOpts.name);
  const changeEvent = getChangeEvent2(renderOpts.name);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils79.default.objectEach(events, (func, key) => {
      ons[getOnName2(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName2(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName2(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns2(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent2(renderOpts.name);
  const changeEvent = getChangeEvent2(renderOpts.name);
  const ons = {};
  import_xe_utils79.default.objectEach(events, (func, key) => {
    ons[getOnName2(key)] = function(...args) {
      if (true) {
        if (!import_xe_utils79.default.isFunction(func)) {
          errLog2("vxe.error.errFunc", [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName2(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName2(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getComponentOns2(renderOpts, params, (value) => {
    import_xe_utils79.default.set(data, field, value);
  }, () => {
    $form.updateStatus(params);
  });
}
function getNativeItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getNativeElementOns2(renderOpts, params, (evnt) => {
    const itemValue = evnt.target.value;
    import_xe_utils79.default.set(data, field, itemValue);
  }, () => {
    $form.updateStatus(params);
  });
}
function renderNativeOptgroup(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function nativeItemRender(renderOpts, params) {
  const { data, field } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs2(renderOpts);
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, attrs), { value: attrs && name === "input" && (attrs.type === "submit" || attrs.type === "reset") ? null : itemValue }), getNativeItemOns(renderOpts, params)))
  ];
}
function defaultItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(getOldComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldButtonItemRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, null)), getComponentOns2(renderOpts, params)))
  ];
}
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonItemRender(childRenderOpts, params)[0]);
}
function renderNativeFormOptions(options, renderOpts, params) {
  const { data, field } = params;
  const { optionProps = {} } = renderOpts;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = import_xe_utils79.default.get(data, field);
  return options.map((item, oIndex) => {
    return h("option", {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      /* eslint-disable eqeqeq */
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
function defaultFormItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const { options, optionProps } = renderOpts;
  const { data, field } = params;
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({
      options,
      optionProps
    }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const { name, options, optionProps = {} } = renderOpts;
  const { data, field } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const itemValue = import_xe_utils79.default.get(data, field);
  const compName = getOldComponentName2(name);
  if (options) {
    return [
      h(resolveComponent(`${compName}-group`), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)), {
        default: () => {
          return options.map((item, index2) => {
            return h(resolveComponent(compName), {
              key: index2,
              label: item[valueProp],
              content: item[labelProp],
              disabled: item[disabledProp]
            });
          });
        }
      })
    ];
  }
  return [
    h(resolveComponent(compName), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
renderer.mixin({
  input: {
    formItemAutoFocus: "input",
    renderFormItemContent: nativeItemRender
  },
  textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: nativeItemRender
  },
  select: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      return [
        h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs2(renderOpts)), getNativeItemOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroup(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))
      ];
    }
  },
  VxeInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeNumberInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxePasswordInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeTextarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: defaultItemRender
  },
  VxeDatePicker: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeButton: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderFormItemContent(renderOpts, params) {
      const { options } = renderOpts;
      const { data, field } = params;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({ options }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTreeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTableSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeIconPicker: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeRadio: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    renderFormItemContent: defaultItemRender
  },
  VxeRate: {
    renderFormItemContent: defaultItemRender
  },
  VxeSlider: {
    renderFormItemContent: defaultItemRender
  },
  VxeImage: {
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeUpload: {
    renderFormItemContent: defaultItemRender
  },
  // 
  $input: {
    formItemAutoFocus: "input",
    renderFormItemContent: oldItemRender
  },
  $textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: oldItemRender
  },
  $button: {
    renderFormItemContent: oldButtonItemRender
  },
  $buttons: {
    renderFormItemContent: oldButtonsItemRender
  },
  $select: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getOldComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  $radio: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    renderFormItemContent: oldItemRender
  }
  // 
});

// node_modules/vxe-pc-ui/es/form/index.js
var VxeForm = Object.assign(form_default, {
  install(app) {
    app.component(form_default.name, form_default);
  }
});
dynamicApp.use(VxeForm);
VxeUI.component(form_default);
var Form = VxeForm;
var form_default2 = VxeForm;

// node_modules/vxe-pc-ui/es/form-design/src/util.js
var import_xe_utils80 = __toESM(require_xe_utils());
var maxWidgetId = 1e5;
function getNewWidgetId(widgetObjList) {
  import_xe_utils80.default.eachTree(widgetObjList, (item) => {
    if (item) {
      maxWidgetId = Math.max(maxWidgetId, item.id);
    }
  }, { children: "children" });
  return ++maxWidgetId;
}
var hasFormDesignLayoutType = (widget) => {
  if (widget) {
    const widgetConf = getWidgetConfig(widget.name);
    return widgetConf.group === "layout";
  }
  return false;
};

// node_modules/vxe-pc-ui/es/form-design/src/widget-info.js
var import_xe_utils81 = __toESM(require_xe_utils());
var refWidgetReactConfigMaps = ref({});
var getWidgetConfig = (name) => {
  const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
  return widgetReactConfigMaps[name] || {};
};
function getWidgetConfigTitle(name, $xeFormDesign) {
  const widgetConf = getWidgetConfig(name);
  if (widgetConf) {
    const configTitle = widgetConf.title;
    const params = { name, $formDesign: $xeFormDesign };
    return import_xe_utils81.default.toValueString(import_xe_utils81.default.isFunction(configTitle) ? configTitle(params) : configTitle);
  }
  return name;
}
function getWidgetConfigCustomGroup(name, $xeFormDesign) {
  const widgetConf = getWidgetConfig(name);
  if (widgetConf) {
    const configCustomGroup = widgetConf.customGroup;
    const params = { name, $formDesign: $xeFormDesign };
    return import_xe_utils81.default.toValueString(import_xe_utils81.default.isFunction(configCustomGroup) ? configCustomGroup(params) : configCustomGroup);
  }
  return name;
}
var validWidgetUniqueField = (field, widgetObjList) => {
  return !import_xe_utils81.default.findTree(widgetObjList, (item) => item.field === field, { children: "children" });
};
var FormDesignWidgetInfo = class {
  constructor($xeFormDesign, name, widgetObjList) {
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "field", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "title", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "required", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "hidden", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "children", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "model", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {
        update: false,
        value: ""
      }
    });
    let customField = "";
    if (name) {
      const compConf = renderer.get(name) || {};
      if (compConf) {
        const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
        const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
        if (createWidgetFormConfig) {
          const params = { name, $formDesign: $xeFormDesign };
          const widgetConfig = createWidgetFormConfig(params) || {};
          const titleConf = widgetConfig.title;
          const fieldConf = widgetConfig.field;
          this.title = import_xe_utils81.default.toValueString(import_xe_utils81.default.isFunction(titleConf) ? titleConf(params) : titleConf);
          this.options = widgetConfig.options || {};
          this.children = widgetConfig.children || [];
          if (fieldConf) {
            if (import_xe_utils81.default.isFunction(fieldConf)) {
              customField = fieldConf({ name, $formDesign: $xeFormDesign });
            } else {
              customField = fieldConf;
            }
          }
          if (!widgetReactConfigMaps[name]) {
            widgetReactConfigMaps[name] = Object.assign({}, widgetConfig);
            refWidgetReactConfigMaps.value = Object.assign({}, widgetReactConfigMaps);
          }
        }
      }
    }
    const widgetId = getNewWidgetId(widgetObjList);
    if (customField) {
      if (!validWidgetUniqueField(customField, widgetObjList)) {
        errLog2("vxe.error.uniField", [customField]);
      }
    }
    this.id = widgetId;
    this.field = customField || `${name}${widgetId}`;
    this.name = name;
  }
};
function configToWidget(conf) {
  const widget = new FormDesignWidgetInfo(null, conf.name, []);
  widget.id = conf.id;
  widget.title = conf.title || "";
  widget.field = conf.field || "";
  widget.required = conf.required || false;
  widget.hidden = conf.hidden || false;
  widget.options = Object.assign({}, widget.options, conf.options);
  widget.children = conf.children ? conf.children.map((item) => configToWidget(item)) : [];
  return widget;
}

// node_modules/vxe-pc-ui/es/form-design/src/form-design.js
var import_xe_utils99 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form-design/src/layout-widget.js
var import_xe_utils82 = __toESM(require_xe_utils());
var layout_widget_default = defineComponent({
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const dragstartEvent = (evnt) => {
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetName = divEl.getAttribute("data-widget-name") || "";
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        if (dataTransfer) {
          dataTransfer.setData("text/plain", widgetName);
        }
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = dragWidget;
      } else {
        evnt.preventDefault();
      }
    };
    const dragendEvent = (evnt) => {
      evnt.preventDefault();
      if (formDesignReactData.dragWidget) {
        const newWidget = formDesignReactData.dragWidget;
        formDesignReactData.activeWidget = newWidget;
        $xeFormDesign.dispatchEvent("add-widget", { newWidget }, evnt);
      }
      formDesignReactData.dragWidget = null;
      formDesignReactData.sortWidget = null;
    };
    const cancelDragoverItem = (evnt, group) => {
      const { widgetObjList, dragWidget } = formDesignReactData;
      if (dragWidget) {
        if (group.children.some((widget) => widget.name === dragWidget.name)) {
          const rest = import_xe_utils82.default.findTree(widgetObjList, (item) => item && item.id === dragWidget.id, { children: "children" });
          if (rest) {
            rest.items.splice(rest.index, 1);
          }
        }
      }
    };
    const addNewWidget = (evnt, widgetName) => {
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const { widgetObjList } = formDesignReactData;
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        widgetObjList.push(dragWidget);
        formDesignReactData.activeWidget = dragWidget;
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = null;
        $xeFormDesign.dispatchEvent("add-widget", { newWidget: dragWidget }, evnt);
      }
    };
    const renderWidgetList = (group) => {
      const widgetVNs = [];
      if (group.children) {
        group.children.forEach((widget, index2) => {
          const { name } = widget;
          const configTitle = getWidgetConfigTitle(name, $xeFormDesign);
          const compConf = renderer.get(name) || {};
          const widgetConf = getWidgetConfig(name);
          const renderWidgetItem = compConf.renderFormDesignWidgetItem;
          widgetVNs.push(h("div", {
            key: index2,
            class: "vxe-form-design--widget-item"
          }, h("div", {
            class: "vxe-form-design--widget-box",
            "data-widget-name": name,
            title: configTitle,
            draggable: true,
            onDragstart: dragstartEvent,
            onDragend: dragendEvent
          }, renderWidgetItem ? getSlotVNs2(renderWidgetItem({}, { $formDesign: $xeFormDesign })) : [
            h("i", {
              class: ["vxe-form-design--widget-item-icon", widgetConf ? widgetConf.icon || "" : ""]
            }),
            h("span", {
              class: "vxe-form-design--widget-item-name"
            }, configTitle),
            h("span", {
              class: "vxe-form-design--widget-item-add",
              onClick(evnt) {
                addNewWidget(evnt, name);
              }
            }, [
              h("i", {
                class: getIcon().FORM_DESIGN_WIDGET_ADD
              })
            ])
          ])));
        });
      }
      return widgetVNs;
    };
    const renderWidgetGroups = () => {
      const { widgetConfigs } = formDesignReactData;
      return widgetConfigs.map((config3, gIndex) => {
        const { title, group } = config3;
        return h("div", {
          key: gIndex,
          class: "vxe-form-design--widget-group"
        }, [
          h("div", {
            class: "vxe-form-design--widget-title"
          }, group ? getI18n(`vxe.formDesign.widget.group.${group}`) : `${title || ""}`),
          h("div", {
            class: "vxe-form-design--widget-list",
            onDragover(evnt) {
              cancelDragoverItem(evnt, config3);
            }
          }, renderWidgetList(config3))
        ]);
      });
    };
    return () => {
      return h("div", {
        class: "vxe-form-design--widget"
      }, renderWidgetGroups());
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/layout-view-item.js
var import_xe_utils83 = __toESM(require_xe_utils());
var ViewItemComponent = defineComponent({
  name: "FormDesignLayoutViewItem",
  props: {
    item: {
      type: Object,
      default: () => ({})
    },
    itemIndex: {
      type: Number,
      default: 0
    },
    items: {
      type: Array,
      default: () => []
    }
  },
  emits: [],
  setup(props, { slots }) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const sortDragstartEvent = (evnt) => {
      const { widgetObjList } = formDesignReactData;
      const divEl = evnt.currentTarget;
      const widgetId = Number(divEl.getAttribute("data-widget-id"));
      const currRest = import_xe_utils83.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
      if (currRest) {
        formDesignReactData.dragWidget = null;
        formDesignReactData.sortWidget = currRest.item;
      }
    };
    const sortDragendEvent = () => {
      formDesignReactData.activeWidget = formDesignReactData.sortWidget;
      formDesignReactData.sortWidget = null;
    };
    const sortDragenterEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      const formDesignInternalData = $xeFormDesign.internalData;
      const { lastDragTime } = formDesignInternalData;
      if (lastDragTime && lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        const divEl = evnt.currentTarget;
        evnt.preventDefault();
        const widgetId = Number(divEl.getAttribute("data-widget-id"));
        if (widgetId !== sortWidget.id) {
          const targetRest = import_xe_utils83.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
          if (targetRest) {
            const currRest = import_xe_utils83.default.findTree(widgetObjList, (item) => item && item.id === sortWidget.id, { children: "children" });
            if (currRest) {
              if (currRest.parent && currRest.parent.name === "row") {
                currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
              } else {
                currRest.items.splice(currRest.index, 1);
              }
              targetRest.items.splice(targetRest.index, 0, currRest.item);
              formDesignInternalData.lastDragTime = Date.now();
              $xeFormDesign.dispatchEvent("drag-widget", { widget: currRest.item }, evnt);
            }
          }
        }
      }
    };
    const handleClickEvent = (evnt, item) => {
      $xeFormDesign.handleClickWidget(evnt, item);
    };
    return () => {
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      const { item } = props;
      const { name } = item;
      const isActive = activeWidget && activeWidget.id === item.id;
      const defaultSlot = slots.default;
      return h("div", {
        key: item.id,
        "data-widget-id": item.id,
        draggable: true,
        class: ["vxe-form-design--preview-item", `widget-${import_xe_utils83.default.kebabCase(name)}`, {
          "is--active": isActive,
          "is--sort": sortWidget && sortWidget.id === item.id,
          "is--drag": dragWidget && dragWidget.id === item.id
        }],
        onDragstart: sortDragstartEvent,
        onDragend: sortDragendEvent,
        onDragenter: sortDragenterEvent,
        // onDragover: dragoverItemEvent,
        onClick(evnt) {
          handleClickEvent(evnt, item);
        }
      }, [
        h("div", {
          class: "vxe-form-design--preview-item-view vxe-form--item-row"
        }, defaultSlot ? defaultSlot({}) : []),
        isActive ? h("div", {
          class: "vxe-form-design--preview-item-operate"
        }, [
          h(button_default, {
            icon: getIcon().FORM_DESIGN_WIDGET_COPY,
            status: "primary",
            size: "mini",
            circle: true,
            onClick(params) {
              $xeFormDesign.handleCopyWidget(params.$event, item);
            }
          }),
          h(button_default, {
            icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
            status: "danger",
            size: "mini",
            circle: true,
            onClick(params) {
              $xeFormDesign.handleRemoveWidget(params.$event, item);
            }
          })
        ]) : createCommentVNode()
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/layout-preview.js
var import_xe_utils84 = __toESM(require_xe_utils());
var layout_preview_default = defineComponent({
  name: "FormDesignLayoutPreview",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const dragenterEvent = (evnt) => {
      const { widgetObjList, dragWidget } = formDesignReactData;
      if (dragWidget) {
        evnt.preventDefault();
        const rest = import_xe_utils84.default.findTree(widgetObjList, (item) => item && item.id === dragWidget.id, { children: "children" });
        if (!rest) {
          formDesignReactData.sortWidget = dragWidget;
          widgetObjList.push(dragWidget);
          $xeFormDesign.dispatchEvent("drag-widget", { widget: dragWidget }, evnt);
        }
      }
    };
    const dragoverEvent = (evnt) => {
      evnt.preventDefault();
    };
    let lastDragTime = Date.now();
    const handleDragenterTopPlaceEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      evnt.stopPropagation();
      if (lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        const currRest = import_xe_utils84.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (currRest) {
          const { item, index: index2, items, parent } = currRest;
          if (parent && parent.name === "row") {
            currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
          } else {
            items.splice(index2, 1);
          }
          widgetObjList.unshift(item);
          lastDragTime = Date.now();
          $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
        }
      }
    };
    const handleDragenterBottomPlaceEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      evnt.stopPropagation();
      if (lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        const currRest = import_xe_utils84.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (currRest) {
          const { item, index: index2, items, parent } = currRest;
          if (parent && parent.name === "row") {
            currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
          } else {
            items.splice(index2, 1);
          }
          widgetObjList.push(item);
          lastDragTime = Date.now();
          $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
        }
      }
    };
    return () => {
      const { widgetObjList } = formDesignReactData;
      return h("div", {
        class: "vxe-form-design--preview",
        onDragenter: dragenterEvent,
        onDragover: dragoverEvent
      }, [
        h("div", {
          class: "vxe-form-design--preview-wrapper"
        }, [
          h("div", {
            class: "vxe-form-design--preview-place-widget",
            onDragenter: handleDragenterTopPlaceEvent
          }),
          h(form_default, {
            customLayout: true,
            span: 24,
            vertical: true
          }, {
            default() {
              return h(TransitionGroup, {
                class: "vxe-form-design--preview-list",
                tag: "div",
                name: "vxe-form-design--preview-list"
              }, {
                default: () => {
                  return widgetObjList.map((widget, widgetIndex) => {
                    return h(ViewItemComponent, {
                      key: widget.id,
                      item: widget,
                      itemIndex: widgetIndex,
                      items: widgetObjList
                    }, {
                      default() {
                        const { name } = widget;
                        const compConf = renderer.get(name) || {};
                        const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
                        const renderOpts = widget;
                        const isEditMode = true;
                        const params = { widget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: null };
                        return renderWidgetDesignView ? getSlotVNs2(renderWidgetDesignView(renderOpts, params)) : [];
                      }
                    });
                  });
                }
              });
            }
          }),
          h("div", {
            class: "vxe-form-design--preview-place-widget",
            onDragenter: handleDragenterBottomPlaceEvent
          })
        ])
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/tabs/src/tabs.js
var import_xe_utils85 = __toESM(require_xe_utils());
var tabs_default = defineComponent({
  name: "VxeTabs",
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: String,
    showClose: Boolean,
    padding: {
      type: Boolean,
      default: () => getConfig().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    closeConfig: Object,
    refreshConfig: Object,
    // 
    beforeCloseMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "tab-change",
    "tab-change-fail",
    "tab-close",
    "tab-close-fail",
    "tab-click",
    "tab-load"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils85.default.uniqueId();
    const $xeParentTabs = inject("$xeTabs", null);
    const refElem = ref();
    const refHeadWrapperElem = ref();
    const reactData = reactive({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintWidth: 0,
      isTabOver: false,
      resizeFlag: 1,
      cacheTabMaps: {}
    });
    const internalData = {
      slTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeCloseOpts = computed(() => {
      return Object.assign({}, getConfig().tabs.closeConfig, props.closeConfig);
    });
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, getConfig().tabs.refreshConfig, props.refreshConfig);
    });
    const computeTabOptions = computed(() => {
      const { options } = props;
      return (options || []).filter((item) => handleFilterTab(item));
    });
    const computeTabStaticOptions = computed(() => {
      const { staticTabs } = reactData;
      return staticTabs.filter((item) => handleFilterTab(item));
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterTab = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils85.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils85.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const updateTabStyle = () => {
      nextTick(() => {
        const { type } = props;
        const { activeName } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        let lintWidth = 0;
        let lintLeft = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index2 = import_xe_utils85.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === activeName);
          const { children, scrollWidth, clientWidth } = headerWrapperEl;
          isOver = scrollWidth !== clientWidth;
          if (index2 > -1) {
            const tabEl = children[index2];
            const tabWidth = tabEl.clientWidth;
            if (type) {
              if (type === "card") {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft;
              } else if (type === "border-card") {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft - 1;
              }
            } else {
              lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
              lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
            }
          }
        }
        reactData.lintLeft = lintLeft;
        reactData.lintWidth = lintWidth;
        reactData.isTabOver = isOver;
      });
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabs: $xeTabs }, params));
    };
    const addInitName = (name, evnt) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent2("tab-load", { name }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      let activeName = null;
      const nameMaps = {};
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          const { name, preload } = item || {};
          if (name) {
            nameMaps[`${name}`] = {
              loading: false
            };
            if (activeName === name) {
              validVal = true;
            }
            if (preload) {
              addInitName(name, null);
            }
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
      reactData.cacheTabMaps = nameMaps;
    };
    const clickEvent = (evnt, item) => {
      const { trigger } = props;
      const beforeMethod = props.beforeChangeMethod || getConfig().tabs.beforeChangeMethod;
      const { activeName } = reactData;
      const { name } = item;
      const value = name;
      dispatchEvent2("tab-click", { name }, evnt);
      if (trigger === "manual") {
        return;
      }
      if (name !== activeName) {
        Promise.resolve(!beforeMethod || beforeMethod({ $tabs: $xeTabs, name, oldName: activeName, newName: name, option: item })).then((status) => {
          if (status) {
            reactData.activeName = name;
            emit("update:modelValue", value);
            addInitName(name, evnt);
            dispatchEvent2("change", { value, name, oldName: activeName, newName: name, option: item }, evnt);
            dispatchEvent2("tab-change", { value, name, oldName: activeName, newName: name, option: item }, evnt);
          } else {
            dispatchEvent2("tab-change-fail", { value, name, oldName: activeName, newName: name, option: item }, evnt);
          }
        }).catch(() => {
          dispatchEvent2("tab-change-fail", { value, name, oldName: activeName, newName: name, option: item }, evnt);
        });
      }
    };
    const handleRefreshTabEvent = (evnt, item) => {
      evnt.stopPropagation();
      const { activeName, cacheTabMaps } = reactData;
      const { name } = item;
      const refreshOpts = computeRefreshOpts.value;
      const { queryMethod } = refreshOpts;
      const cacheItem = name ? cacheTabMaps[`${name}`] : null;
      if (cacheItem) {
        if (queryMethod) {
          cacheItem.loading = true;
          Promise.resolve(queryMethod({ $tabs: $xeTabs, value: activeName, name, option: item })).finally(() => {
            cacheItem.loading = false;
          });
        } else {
          errLog2("vxe.error.notFunc", ["refresh-config.queryMethod"]);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index2, list) => {
      evnt.stopPropagation();
      const { activeName } = reactData;
      const closeOpts = computeCloseOpts.value;
      const beforeMethod = closeOpts.beforeMethod || props.beforeCloseMethod || getConfig().tabs.beforeCloseMethod;
      const { name } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index2 < list.length - 1 ? list[index2 + 1] : list[index2 - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      Promise.resolve(!beforeMethod || beforeMethod({ $tabs: $xeTabs, value, name, nextName, option: item })).then((status) => {
        if (status) {
          dispatchEvent2("tab-close", { value, name, nextName }, evnt);
        } else {
          dispatchEvent2("tab-close-fail", { value, name, nextName }, evnt);
        }
      }).catch(() => {
        dispatchEvent2("tab-close-fail", { value, name, nextName }, evnt);
      });
    };
    const startScrollAnimation = (offsetPos, offsetSize) => {
      const { slTimeout } = internalData;
      let offsetLeft = offsetSize;
      let scrollCount = 6;
      let delayNum = 35;
      if (slTimeout) {
        clearTimeout(slTimeout);
        internalData.slTimeout = void 0;
      }
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const { clientWidth, scrollWidth, scrollLeft } = headerWrapperEl;
            offsetLeft = Math.floor(offsetLeft / 2);
            if (offsetPos > 0) {
              if (clientWidth + scrollLeft < scrollWidth) {
                headerWrapperEl.scrollLeft += offsetLeft;
                delayNum -= 4;
                internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
              }
            } else {
              if (scrollLeft > 0) {
                headerWrapperEl.scrollLeft -= offsetLeft;
                delayNum -= 4;
                internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = (offsetPos) => {
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const offsetSize = Math.floor(headerWrapperEl.clientWidth * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = (name) => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      return nextTick().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index2 = import_xe_utils85.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === name);
          if (index2 > -1) {
            const { scrollLeft, clientWidth, children } = headerWrapperEl;
            const tabEl = children[index2];
            if (tabEl) {
              const tabOffsetLeft = tabEl.offsetLeft;
              const tabClientWidth = tabEl.clientWidth;
              const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
              if (overSize > 0) {
                headerWrapperEl.scrollLeft += overSize;
              }
              if (tabOffsetLeft < scrollLeft) {
                headerWrapperEl.scrollLeft = tabOffsetLeft;
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const handlePrevNext = (isNext) => {
      const { activeName } = reactData;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
      const index2 = import_xe_utils85.default.findIndexOf(list, (item) => item.name === activeName);
      if (index2 > -1) {
        let item = null;
        if (isNext) {
          if (index2 < list.length - 1) {
            item = list[index2 + 1];
          }
        } else {
          if (index2 > 0) {
            item = list[index2 - 1];
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit("update:modelValue", value);
          addInitName(name, null);
        }
      }
      return nextTick();
    };
    const tabsMethods = {
      dispatchEvent: dispatchEvent2,
      scrollToTab,
      prev() {
        return handlePrevNext(false);
      },
      next() {
        return handlePrevNext(true);
      },
      prevTab() {
        if (true) {
          warnLog2("vxe.error.delFunc", ["prevTab", "prev"]);
        }
        return tabsMethods.prev();
      },
      nextTab() {
        if (true) {
          warnLog2("vxe.error.delFunc", ["nextTab", "next"]);
        }
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = (tabList) => {
      const { type, titleWidth: allTitleWidth, titleAlign: allTitleAlign, showClose, closeConfig, refreshConfig } = props;
      const { activeName, lintLeft, lintWidth, isTabOver, cacheTabMaps } = reactData;
      const extraSlot = slots.extra;
      const closeOpts = computeCloseOpts.value;
      const closeVisibleMethod = closeOpts.visibleMethod;
      const refreshOpts = computeRefreshOpts.value;
      const refreshVisibleMethod = refreshOpts.visibleMethod;
      return h("div", {
        class: "vxe-tabs-header"
      }, [
        isTabOver ? h("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--left-bar",
          onClick: scrollLeftEvent
        }, [
          h("span", {
            class: getIcon().TABS_TAB_BUTTON_LEFT
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-tabs-header--wrapper"
        }, [
          h("div", {
            ref: refHeadWrapperElem,
            class: "vxe-tabs-header--item-wrapper"
          }, tabList.map((item, index2) => {
            const { title, titleWidth, titleAlign, icon, name, slots: slots2 } = item;
            const titleSlot = slots2 ? slots2.title || slots2.tab : null;
            const itemWidth = titleWidth || allTitleWidth;
            const itemAlign = titleAlign || allTitleAlign;
            const params = { $tabs: $xeTabs, value: activeName, name, option: item };
            const isActive = activeName === name;
            const cacheItem = name ? cacheTabMaps[`${name}`] : null;
            const isLoading = cacheItem ? cacheItem.loading : false;
            return h("div", {
              key: `${name}`,
              class: ["vxe-tabs-header--item", itemAlign ? `align--${itemAlign}` : "", {
                "is--active": isActive
              }],
              style: itemWidth ? {
                width: toCssUnit(itemWidth)
              } : null,
              onClick(evnt) {
                clickEvent(evnt, item);
              }
            }, [
              h("div", {
                class: "vxe-tabs-header--item-inner"
              }, [
                h("div", {
                  class: "vxe-tabs-header--item-content"
                }, [
                  icon ? h("span", {
                    class: "vxe-tabs-header--item-icon"
                  }, [
                    h("i", {
                      class: icon
                    })
                  ]) : createCommentVNode(),
                  h("span", {
                    class: "vxe-tabs-header--item-name"
                  }, titleSlot ? callSlot(titleSlot, { name, title }) : `${title}`)
                ]),
                (isEnableConf2(refreshConfig) || refreshOpts.enabled) && (refreshVisibleMethod ? refreshVisibleMethod(params) : isActive) ? h("div", {
                  class: "vxe-tabs-header--refresh-btn",
                  onClick(evnt) {
                    handleRefreshTabEvent(evnt, item);
                  }
                }, [
                  h("i", {
                    class: isLoading ? getIcon().TABS_TAB_REFRESH_LOADING : getIcon().TABS_TAB_REFRESH
                  })
                ]) : createCommentVNode(),
                (showClose || (isEnableConf2(closeConfig) || closeOpts.enabled)) && (!closeVisibleMethod || closeVisibleMethod(params)) ? h("div", {
                  class: "vxe-tabs-header--close-btn",
                  onClick(evnt) {
                    handleCloseTabEvent(evnt, item, index2, tabList);
                  }
                }, [
                  h("i", {
                    class: getIcon().TABS_TAB_CLOSE
                  })
                ]) : createCommentVNode()
              ])
            ]);
          }).concat([
            h("span", {
              key: "line",
              class: `vxe-tabs-header--active-line type--${type || "default"}`,
              style: {
                left: `${lintLeft}px`,
                width: `${lintWidth}px`
              }
            })
          ]))
        ]),
        isTabOver ? h("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--right-bar",
          onClick: scrollRightEvent
        }, [
          h("span", {
            class: getIcon().TABS_TAB_BUTTON_RIGHT
          })
        ]) : createCommentVNode(),
        extraSlot ? h("div", {
          class: "vxe-tabs-header--extra"
        }, getSlotVNs2(extraSlot({}))) : createCommentVNode()
      ]);
    };
    const renderTabPane = (item) => {
      const { initNames, activeName } = reactData;
      const { name, slots: slots2 } = item;
      const defaultSlot = slots2 ? slots2.default : null;
      return name && initNames.includes(name) ? h("div", {
        key: `${name}`,
        class: ["vxe-tabs-pane--item", {
          "is--visible": activeName === name,
          "has--content": !!defaultSlot
        }]
      }, defaultSlot ? callSlot(defaultSlot, { name }) : []) : createCommentVNode();
    };
    const renderTabContent = (tabList) => {
      const { destroyOnClose } = props;
      const { activeName } = reactData;
      const activeDefaultTab = tabList.find((item) => item.name === activeName);
      if (destroyOnClose) {
        return [activeDefaultTab ? renderTabPane(activeDefaultTab) : createCommentVNode()];
      }
      return tabList.map((item) => renderTabPane(item));
    };
    const renderVN = () => {
      const { type, height, padding, trigger } = props;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      return h("div", {
        ref: refElem,
        class: ["vxe-tabs", `vxe-tabs--${type || "default"}`, `trigger--${trigger === "manual" ? "trigger" : "default"}`, {
          "is--padding": padding,
          "is--height": height
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-tabs-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderTabHeader(tabList),
        h("div", {
          class: "vxe-tabs-pane"
        }, renderTabContent(tabList)),
        footerSlot ? h("div", {
          class: "vxe-tabs-footer"
        }, callSlot(footerSlot, {})) : renderEmptyElement($xeTabs)
      ]);
    };
    watch(() => props.modelValue, (val) => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, (val) => {
      scrollToTab(val);
      nextTick(() => {
        reactData.resizeFlag++;
      });
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
      updateTabStyle();
    });
    const stFlag = ref(0);
    watch(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      updateTabStyle();
    });
    if ($xeParentTabs) {
      watch(() => $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null, () => {
        reactData.resizeFlag++;
      });
    }
    watch(() => reactData.resizeFlag, () => {
      nextTick(() => {
        updateTabStyle();
      });
    });
    onMounted(() => {
      globalEvents.on($xeTabs, "resize", updateTabStyle);
      updateTabStyle();
    });
    onUnmounted(() => {
      globalEvents.off($xeTabs, "resize");
    });
    provide("$xeTabs", $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    $xeTabs.renderVN = renderVN;
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var import_xe_utils87 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/tabs/src/util.js
var import_xe_utils86 = __toESM(require_xe_utils());
function assembleTabItem($xeTabs, elem, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticTabs.splice(import_xe_utils86.default.arrayIndexOf(parentElem.children, elem), 0, tabConfig);
    $xeTabs.reactData.staticTabs = staticTabs.slice(0);
  }
}
function destroyTabItem($xeTabs, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const matchObj = import_xe_utils86.default.findTree(staticTabs, (item) => item.id === tabConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeTabs.reactData.staticTabs = staticTabs.slice(0);
}

// node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var tab_pane_default = defineComponent({
  name: "VxeTabPane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils87.default.uniqueId();
    const refElem = ref();
    const $xeTabs = inject("$xeTabs", null);
    const reactData = reactive({});
    const tabConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      titleWidth: props.titleWidth,
      titleAlign: props.titleAlign,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTabPane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabPane: $xeTabPane }, params));
    };
    const tabPaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const tabPanePrivateMethods = {};
    Object.assign($xeTabPane, tabPaneMethods, tabPanePrivateMethods);
    watch(() => props.title, (val) => {
      tabConfig.title = val;
    });
    watch(() => props.name, (val) => {
      tabConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      tabConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      tabConfig.permissionCode = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeTabs && elem) {
        assembleTabItem($xeTabs, elem, tabConfig);
      }
    });
    onUnmounted(() => {
      if ($xeTabs) {
        destroyTabItem($xeTabs, tabConfig);
      }
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    $xeTabPane.renderVN = renderVN;
    return $xeTabPane;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/src/form-item.js
var import_xe_utils88 = __toESM(require_xe_utils());
var formItemProps = {
  title: String,
  field: String,
  span: {
    type: [String, Number],
    default: null
  },
  align: {
    type: String,
    default: null
  },
  verticalAlign: {
    type: String,
    default: null
  },
  titleBackground: {
    type: Boolean,
    default: null
  },
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  showContent: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
};
var form_item_default = defineComponent({
  name: "VxeFormItem",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const $xeFormGroup = inject("$xeFormGroup", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    const renderItem = ($xeForm2, item) => {
      const formProps = $xeForm2.props;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle, showContent } = item;
      const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeForm2.xegrid };
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        key: item.id,
        class: getItemClass($xeForm2, item),
        style: import_xe_utils88.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm2, item),
        showContent === false ? createCommentVNode() : h("div", {
          class: getItemContentClass($xeForm2, item),
          style: Object.assign({}, import_xe_utils88.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils88.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, [
          renderItemContent($xeForm2, item)
        ])
      ]);
    };
    const renderVN = () => {
      const customLayout = $xeForm ? $xeForm.props.customLayout : false;
      const item = formItem;
      return customLayout ? renderItem($xeForm, item) : h("div", {
        ref: refElem
      });
    };
    const $xeFormitem = {
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    onMounted(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeFormGroup);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    provide("$xeFormItem", $xeFormitem);
    provide("$xeFormGroup", null);
    return $xeFormitem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/switch/src/switch.js
var import_xe_utils89 = __toESM(require_xe_utils());
var switch_default = defineComponent({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().switch.size || getConfig().size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: true
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: false
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils89.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const internalData = {};
    const $xeSwitch = {
      xID,
      props,
      context,
      reactData,
      internalData
    };
    const refButton = ref();
    let switchMethods = {};
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeOnShowLabel = computed(() => {
      return getFuncText2(props.openLabel);
    });
    const computeOffShowLabel = computed(() => {
      return getFuncText2(props.closeLabel);
    });
    const computeIsChecked = computed(() => {
      return props.modelValue === props.openValue;
    });
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const isChecked = computeIsChecked.value;
        clearTimeout(internalData.atTimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emitModel(value);
        switchMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
        internalData.atTimeout = setTimeout(() => {
          reactData.hasAnimat = false;
          internalData.atTimeout = void 0;
        }, 400);
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $switch: $xeSwitch }, params));
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent("focus", { value: props.modelValue }, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent("blur", { value: props.modelValue }, evnt);
    };
    switchMethods = {
      dispatchEvent: dispatchEvent2,
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        if (btnElem) {
          btnElem.focus();
        }
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeSwitch, switchMethods);
    const renderVN = () => {
      const { openIcon, closeIcon, openActiveIcon, closeActiveIcon } = props;
      const vSize = computeSize.value;
      const isChecked = computeIsChecked.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      return h("div", {
        class: ["vxe-switch", isChecked ? "is--on" : "is--off", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled,
          "is--readonly": isReadonly,
          "is--animat": reactData.hasAnimat
        }]
      }, [
        h("button", {
          ref: refButton,
          class: "vxe-switch--button",
          type: "button",
          disabled: isDisabled || isReadonly,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent
        }, [
          h("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            openIcon ? h("i", {
              class: ["vxe-switch--label-icon", openIcon]
            }) : createCommentVNode(),
            onShowLabel
          ]),
          h("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            closeIcon ? h("i", {
              class: ["vxe-switch--label-icon", closeIcon]
            }) : createCommentVNode(),
            offShowLabel
          ]),
          h("span", {
            class: ["vxe-switch--icon"]
          }, openActiveIcon || closeActiveIcon ? [
            h("i", {
              class: isChecked ? openActiveIcon : closeActiveIcon
            })
          ] : [])
        ])
      ]);
    };
    $xeSwitch.renderVN = renderVN;
    return $xeSwitch;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/default-setting-form.js
var DefaultSettingFormComponent = defineComponent({
  name: "DefaultSettingForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { props: formDesignProps } = $xeFormDesign;
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          const { showPc, showMobile } = formDesignProps;
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.formName"),
              field: "title",
              itemRender: { name: "VxeInput", props: { placeholder: getI18n("vxe.formDesign.defFormTitle") } }
            }),
            showPc && showMobile ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.displaySetting.name")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    h("div", {
                      class: "vxe-form-design--widget-form-item-pc"
                    }, [
                      h(text_default, {
                        icon: getIcon().FORM_DESIGN_PROPS_PC,
                        content: getI18n("vxe.formDesign.widgetProp.displaySetting.pc")
                      }),
                      h(switch_default, {
                        modelValue: formData.pcVisible,
                        openLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(val) {
                          formData.pcVisible = val;
                        }
                      })
                    ]),
                    h("div", {
                      class: "vxe-form-design--widget-form-item-mobile"
                    }, [
                      h(text_default, {
                        icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                        content: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile")
                      }),
                      h(switch_default, {
                        modelValue: formData.mobileVisible,
                        openLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(val) {
                          formData.mobileVisible = val;
                        }
                      })
                    ])
                  ])
                ];
              }
            }) : createCommentVNode()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/layout-setting.js
var layout_setting_default = defineComponent({
  name: "FormDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { props: formDesignProps, reactData: formDesignReactData } = $xeFormDesign;
    const activeTab = ref(1);
    const renderSettingWidgetForm = () => {
      const { activeWidget } = formDesignReactData;
      if (activeWidget) {
        const compConf = renderer.get(activeWidget.name);
        const renderWidgetFormView = compConf ? compConf.renderFormDesignWidgetFormView : null;
        if (renderWidgetFormView) {
          const isEditMode = true;
          return h("div", {
            class: "vxe-form-design--custom-widget-form-view"
          }, getSlotVNs2(renderWidgetFormView(activeWidget, { isEditMode, isViewMode: !isEditMode, widget: activeWidget, $formDesign: $xeFormDesign, $formView: null })));
        }
      }
      return createCommentVNode();
    };
    const renderSettingConfigForm = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingView = compConf ? compConf.renderFormDesignSettingFormView : null;
        if (renderSettingView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-form-view"
          }, getSlotVNs2(renderSettingView({}, { $formDesign: $xeFormDesign })));
        }
      }
      return h(DefaultSettingFormComponent, {
        formData
      });
    };
    watch(() => formDesignReactData.activeWidget, () => {
      activeTab.value = 1;
    });
    return () => {
      return h("div", {
        class: "vxe-form-design--setting"
      }, [
        h("div", {
          class: "vxe-form-design--setting-form"
        }, [
          h(tabs_default, {
            modelValue: activeTab.value,
            titleWidth: "50%",
            titleAlign: "center",
            padding: true,
            class: "vxe-form-design--setting-form-tabs",
            "onUpdate:modelValue"(val) {
              activeTab.value = val;
            }
          }, {
            default() {
              return [
                h(tab_pane_default, {
                  title: getI18n("vxe.formDesign.widgetPropTab"),
                  name: 1
                }, {
                  default() {
                    return renderSettingWidgetForm();
                  }
                }),
                h(tab_pane_default, {
                  title: getI18n("vxe.formDesign.widgetFormTab"),
                  name: 2
                }, {
                  default() {
                    return renderSettingConfigForm();
                  }
                })
              ];
            }
          })
        ])
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/modal/src/modal.js
var import_xe_utils90 = __toESM(require_xe_utils());
var allActiveModals = [];
var msgQueue = [];
var notifyQueue = [];
var lockScrollAttrKey = "data-vxe-lock-scroll";
var lockScrollCssWidthKey = "--vxe-ui-modal-lock-scroll-view-width";
var modal_default = defineComponent({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: {
      type: String,
      default: "modal"
    },
    loading: {
      type: Boolean,
      default: null
    },
    status: String,
    iconStatus: String,
    className: String,
    top: {
      type: [Number, String],
      default: () => getConfig().modal.top
    },
    position: [String, Object],
    title: String,
    duration: {
      type: [Number, String],
      default: () => getConfig().modal.duration
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().modal.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().modal.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().modal.confirmButtonText
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().modal.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().modal.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().modal.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().modal.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().modal.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().modal.confirmClosable
    },
    resize: Boolean,
    showHeader: {
      type: Boolean,
      default: () => getConfig().modal.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().modal.showFooter
    },
    showZoom: Boolean,
    zoomConfig: Object,
    showMaximize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMaximize)
    },
    showMinimize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMinimize)
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().modal.showClose
    },
    dblclickZoom: {
      type: Boolean,
      default: () => getConfig().modal.dblclickZoom
    },
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => getConfig().modal.minWidth
    },
    minHeight: {
      type: [Number, String],
      default: () => getConfig().modal.minHeight
    },
    zIndex: Number,
    marginSize: {
      type: [Number, String],
      default: () => getConfig().modal.marginSize
    },
    fullscreen: Boolean,
    draggable: {
      type: Boolean,
      default: () => getConfig().modal.draggable
    },
    remember: { type: Boolean, default: () => getConfig().modal.remember },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().modal.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().modal.showTitleOverflow
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().modal.transfer
    },
    storage: {
      type: Boolean,
      default: () => getConfig().modal.storage
    },
    storageKey: {
      type: String,
      default: () => getConfig().modal.storageKey
    },
    padding: {
      type: Boolean,
      default: () => getConfig().modal.padding
    },
    size: {
      type: String,
      default: () => getConfig().modal.size || getConfig().size
    },
    beforeHideMethod: Function,
    slots: Object,
    /**
     * 
     * @deprecated
     */
    message: [Number, String],
    /**
     * 
     * @deprecated
     */
    animat: {
      type: Boolean,
      default: () => getConfig().modal.animat
    }
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom",
    "resize",
    "move"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils90.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      prevZoomStatus: "",
      zoomStatus: "",
      revertLocat: null,
      prevLocat: null,
      firstOpen: true
    });
    const internalData = {
      msgTimeout: void 0
    };
    const refElem = ref();
    const refModalBox = ref();
    const refHeaderElem = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const refMaps = {
      refElem
    };
    const computeIsMsg = computed(() => {
      return props.type === "message" || props.type === "notification";
    });
    const computeIsMinimizeStatus = computed(() => {
      return reactData.zoomStatus === "minimize";
    });
    const computeIsMaximizeStatus = computed(() => {
      return reactData.zoomStatus === "maximize";
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, getConfig().modal.zoomConfig, props.zoomConfig);
    });
    const computeMaps = {
      computeSize,
      computeZoomOpts
    };
    const $xeModal = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let modalMethods = {};
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = toCssUnit(width);
        boxElem.style.height = toCssUnit(height);
      }
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { modalZindex } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else if (modalZindex < getLastZIndex2()) {
        reactData.modalZindex = nextZIndex2();
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
        const { position } = props;
        const marginSize = import_xe_utils90.default.toNumber(props.marginSize);
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === "center";
        const { top, left } = import_xe_utils90.default.isString(position) ? { top: position, left: position } : Object.assign({}, position);
        const topCenter = isPosCenter || top === "center";
        const leftCenter = isPosCenter || left === "center";
        let posTop = "";
        let posLeft = "";
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      nextTick(() => {
        const { type } = props;
        const queueList = type === "notification" ? notifyQueue : msgQueue;
        let offsetTop = 0;
        queueList.forEach((comp) => {
          const boxElem = comp.getBox();
          if (boxElem) {
            offsetTop += import_xe_utils90.default.toNumber(comp.props.top);
            comp.reactData.modalTop = offsetTop;
            offsetTop += boxElem.clientHeight;
          }
        });
      });
    };
    const removeMsgQueue = () => {
      const { type } = props;
      const queueList = type === "notification" ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) > -1) {
        import_xe_utils90.default.remove(queueList, (comp) => comp === $xeModal);
      }
      updateStyle();
    };
    const closeModal2 = (type) => {
      const { remember } = props;
      const { visible } = reactData;
      const isMsg = computeIsMsg.value;
      const beforeHideFn = props.beforeHideMethod || getConfig().modal.beforeHideMethod;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideFn ? beforeHideFn(params) : null).then((rest) => {
          if (!import_xe_utils90.default.isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              handleRevert();
            }
            import_xe_utils90.default.remove(allActiveModals, (item) => item === $xeModal);
            dispatchEvent2("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              dispatchEvent2("hide", params, null);
            }, 200);
            removeBodyLockScroll();
          }
        }).catch((e16) => e16);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      dispatchEvent2(type, { type }, evnt);
      closeModal2(type);
    };
    const confirmEvent = (evnt) => {
      const { confirmClosable } = props;
      const type = "confirm";
      dispatchEvent2(type, { type }, evnt);
      if (confirmClosable) {
        closeModal2(type);
      }
    };
    const cancelEvent = (evnt) => {
      const { cancelClosable } = props;
      const type = "cancel";
      dispatchEvent2(type, { type }, evnt);
      if (cancelClosable) {
        closeModal2(type);
      }
    };
    const getStorageMap = (key) => {
      const version7 = getConfig().version;
      const rest = import_xe_utils90.default.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version7 ? rest : { _v: version7 };
    };
    const hasPosStorage = () => {
      const { id: id2, remember, storage, storageKey } = props;
      return !!(id2 && remember && storage && getStorageMap(storageKey)[id2]);
    };
    const restorePosStorage = () => {
      const { id: id2, remember, storage, storageKey } = props;
      if (id2 && remember && storage) {
        const posStorage = getStorageMap(storageKey)[id2];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(",");
          if (boxElem) {
            if (left) {
              boxElem.style.left = `${left}px`;
            }
            if (top) {
              boxElem.style.top = `${top}px`;
            }
            if (width) {
              boxElem.style.width = `${width}px`;
            }
            if (height) {
              boxElem.style.height = `${height}px`;
            }
          }
          if (zoomLeft && zoomTop) {
            reactData.revertLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      const { type } = props;
      const queueList = type === "notification" ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) === -1) {
        queueList.push($xeModal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const { id: id2, remember, storage, storageKey } = props;
      const { revertLocat } = reactData;
      if (id2 && remember && storage) {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id2] = [
          boxElem.style.left,
          boxElem.style.top,
          boxElem.style.width,
          boxElem.style.height
        ].concat(revertLocat ? [
          revertLocat.left,
          revertLocat.top,
          revertLocat.width,
          revertLocat.height
        ] : []).map((val) => val ? import_xe_utils90.default.toNumber(val) : "").join(",");
        localStorage.setItem(storageKey, import_xe_utils90.default.toJSONString(posStorageMap));
      }
    };
    const handleMinimize = () => {
      const zoomOpts = computeZoomOpts.value;
      const { minimizeLayout, minimizeMaxSize, minimizeHorizontalOffset, minimizeVerticalOffset, minimizeOffsetMethod } = zoomOpts;
      const isHorizontalLayout = minimizeLayout === "horizontal";
      const prevZoomStatus = reactData.zoomStatus;
      const hlMList = [];
      const vlMList = [];
      allActiveModals.forEach((item) => {
        if (item.xID !== $xeModal.xID && item.props.type === "modal" && item.reactData.zoomStatus === "minimize") {
          const itemZoomOpts = item.getComputeMaps().computeZoomOpts.value;
          if (itemZoomOpts.minimizeLayout === "horizontal") {
            hlMList.push(item);
          } else {
            vlMList.push(item);
          }
        }
      });
      const mList = isHorizontalLayout ? hlMList : vlMList;
      if (minimizeMaxSize && mList.length >= minimizeMaxSize) {
        if (VxeUI.modal) {
          VxeUI.modal.message({
            status: "error",
            content: getI18n("vxe.modal.miniMaxSize", [minimizeMaxSize])
          });
        }
        return nextTick();
      }
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = "minimize";
      return nextTick().then(() => {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const headerEl = refHeaderElem.value;
        if (!headerEl) {
          return;
        }
        const { visibleHeight } = getDomNode2();
        if (!prevZoomStatus) {
          reactData.revertLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
        }
        const targetModal = import_xe_utils90.default[isHorizontalLayout ? "max" : "min"](mList, ($modal) => {
          const boxElem2 = $modal.getBox();
          return boxElem2 ? import_xe_utils90.default.toNumber(boxElem2.style[isHorizontalLayout ? "left" : "top"]) : 0;
        });
        let targetTop = visibleHeight - headerEl.offsetHeight - 16;
        let targetLeft = 16;
        if (targetModal) {
          const minBoxElem = targetModal.getBox();
          if (minBoxElem) {
            const boxLeft = import_xe_utils90.default.toNumber(minBoxElem.style.left);
            const boxTop = import_xe_utils90.default.toNumber(minBoxElem.style.top);
            let offsetObj = {};
            if (isHorizontalLayout) {
              offsetObj = Object.assign({}, minimizeHorizontalOffset);
            } else {
              offsetObj = Object.assign({}, minimizeVerticalOffset);
            }
            targetLeft = boxLeft + import_xe_utils90.default.toNumber(offsetObj.left);
            targetTop = boxTop + import_xe_utils90.default.toNumber(offsetObj.top);
            if (minimizeOffsetMethod) {
              offsetObj = minimizeOffsetMethod({
                $modal: $xeModal,
                left: targetLeft,
                top: targetTop
              });
              targetLeft = import_xe_utils90.default.toNumber(offsetObj.left);
              targetTop = import_xe_utils90.default.toNumber(offsetObj.top);
            }
          }
        }
        Object.assign(boxElem.style, {
          top: `${targetTop}px`,
          left: `${targetLeft}px`,
          width: "200px",
          height: `${headerEl.offsetHeight}px`
        });
        savePosStorage();
      });
    };
    const handleMaximize = () => {
      const prevZoomStatus = reactData.zoomStatus;
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = "maximize";
      return nextTick().then(() => {
        const boxElem = getBox();
        if (boxElem) {
          if (!prevZoomStatus) {
            reactData.revertLocat = {
              top: boxElem.offsetTop,
              left: boxElem.offsetLeft,
              width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
              height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
            };
          }
          Object.assign(boxElem.style, {
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          });
        }
        savePosStorage();
      });
    };
    const handleMsgAutoClose = () => {
      const { duration } = props;
      if (duration !== -1) {
        internalData.msgTimeout = setTimeout(() => closeModal2("close"), import_xe_utils90.default.toNumber(duration));
      }
    };
    const removeBodyLockScroll = () => {
      const htmlElem = document.documentElement;
      const lockData = htmlElem.getAttribute(lockScrollAttrKey);
      if (lockData) {
        const lockList = lockData.split(",").filter((key) => key !== xID);
        if (lockList.length) {
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(","));
        } else {
          htmlElem.removeAttribute(lockScrollAttrKey);
          htmlElem.style.removeProperty(lockScrollCssWidthKey);
        }
      }
    };
    const addBodyLockScroll = () => {
      const { lockScroll } = props;
      const isMsg = computeIsMsg.value;
      if (lockScroll && !isMsg) {
        const htmlElem = document.documentElement;
        const clientWidth = document.body.clientWidth;
        const lockData = htmlElem.getAttribute(lockScrollAttrKey);
        const lockList = lockData ? lockData.split(",") : [];
        if (!lockList.includes(xID)) {
          lockList.push(xID);
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(","));
        }
        htmlElem.style.setProperty(lockScrollCssWidthKey, `${clientWidth}px`);
      }
    };
    const openModal2 = () => {
      const { remember, showFooter } = props;
      const { initialized, visible } = reactData;
      const isMsg = computeIsMsg.value;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        addBodyLockScroll();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xeModal);
        if (!remember) {
          nextTick(() => {
            recalculate();
          });
        }
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            dispatchEvent2("show", params, null);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          handleMsgAutoClose();
        } else {
          nextTick(() => {
            const { fullscreen } = props;
            const { firstOpen } = reactData;
            if (!remember || firstOpen) {
              updatePosition().then(() => {
                setTimeout(() => updatePosition(), 20);
              });
            }
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else if (fullscreen) {
                nextTick(() => handleMaximize());
              }
            } else {
              if (fullscreen) {
                nextTick(() => handleMaximize());
              }
            }
          });
        }
      }
      return nextTick();
    };
    const selfClickEvent = (evnt) => {
      const el2 = refElem.value;
      if (props.maskClosable && evnt.target === el2) {
        const type = "mask";
        closeModal2(type);
      }
    };
    const selfMouseoverEvent = () => {
      const { msgTimeout } = internalData;
      if (!msgTimeout) {
        return;
      }
      const isMsg = computeIsMsg.value;
      if (isMsg) {
        clearTimeout(msgTimeout);
        internalData.msgTimeout = void 0;
      }
    };
    const selfMouseoutEvent = () => {
      const { msgTimeout } = internalData;
      if (!msgTimeout) {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          handleMsgAutoClose();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = import_xe_utils90.default.max(allActiveModals, (item) => item.reactData.modalZindex);
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xeModal && lastModal.props.escClosable) {
              const type = "exit";
              dispatchEvent2("close", { type }, evnt);
              closeModal2(type);
            }
          }, 10);
        }
      }
    };
    const isMinimized = () => {
      return reactData.zoomStatus === "minimize";
    };
    const isMaximized = () => {
      return reactData.zoomStatus === "maximize";
    };
    const handleRevert = () => {
      reactData.prevZoomStatus = reactData.zoomStatus;
      reactData.zoomStatus = "";
      return nextTick().then(() => {
        const { revertLocat } = reactData;
        if (revertLocat) {
          const boxElem = getBox();
          reactData.revertLocat = null;
          if (boxElem) {
            Object.assign(boxElem.style, {
              top: `${revertLocat.top}px`,
              left: `${revertLocat.left}px`,
              width: `${revertLocat.width}px`,
              height: `${revertLocat.height}px`
            });
          }
          savePosStorage();
          return nextTick();
        }
      });
    };
    const handleZoom = (type) => {
      const { zoomStatus } = reactData;
      return new Promise((resolve) => {
        if (type) {
          if (type === "maximize") {
            resolve(handleMaximize());
            return;
          }
          if (type === "minimize") {
            resolve(handleMinimize());
            return;
          }
          resolve(handleRevert());
          return;
        }
        resolve(zoomStatus ? handleRevert() : handleMaximize());
      }).then(() => {
        return reactData.zoomStatus || "revert";
      });
    };
    const toggleZoomMinEvent = (evnt) => {
      const { zoomStatus, prevZoomStatus } = reactData;
      return handleZoom(zoomStatus === "minimize" ? prevZoomStatus || "revert" : "minimize").then((type) => {
        const params = { type };
        dispatchEvent2("zoom", params, evnt);
      });
    };
    const toggleZoomMaxEvent = (evnt) => {
      return handleZoom().then((type) => {
        const params = { type };
        dispatchEvent2("zoom", params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          if (import_xe_utils90.default.isNumber(top)) {
            boxElem.style.top = `${top}px`;
          }
          if (import_xe_utils90.default.isNumber(left)) {
            boxElem.style.left = `${left}px`;
          }
        }
      }
      return nextTick();
    };
    const boxMousedownEvent = () => {
      const { modalZindex } = reactData;
      if (allActiveModals.some((comp) => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = (evnt) => {
      const { remember, storage } = props;
      const { zoomStatus } = reactData;
      const marginSize = import_xe_utils90.default.toNumber(props.marginSize);
      const boxElem = getBox();
      if (!boxElem) {
        return;
      }
      if (zoomStatus !== "maximize" && evnt.button === 0 && !getEventTargetNode2(evnt, boxElem, "trigger--btn").flag) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const { visibleHeight, visibleWidth } = getDomNode2();
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt2.clientX - disX;
          let top = evnt2.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
          dispatchEvent2("move", { type: "move" }, evnt2);
        };
        document.onmouseup = () => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          if (remember && storage) {
            nextTick(() => {
              savePosStorage();
            });
          }
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { remember, storage } = props;
      const { visibleHeight, visibleWidth } = getDomNode2();
      const marginSize = import_xe_utils90.default.toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = import_xe_utils90.default.toNumber(props.minWidth);
      const minHeight = import_xe_utils90.default.toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case "swst":
            dragLeft = disX - evnt2.clientX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "swlb":
            dragLeft = disX - evnt2.clientX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sest":
            dragLeft = evnt2.clientX - disX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "selb":
            dragLeft = evnt2.clientX - disX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        if (remember && storage) {
          savePosStorage();
        }
        dispatchEvent2("resize", params, evnt2);
      };
      document.onmouseup = () => {
        reactData.revertLocat = null;
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $modal: $xeModal }, params));
    };
    modalMethods = {
      dispatchEvent: dispatchEvent2,
      open: openModal2,
      close() {
        return closeModal2("close");
      },
      getBox,
      getPosition,
      setPosition,
      isMinimized,
      isMaximized,
      zoom: handleZoom,
      minimize: handleMinimize,
      maximize: handleMaximize,
      revert: handleRevert
    };
    Object.assign($xeModal, modalMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, showZoom, showMaximize, showMinimize, title } = props;
      const { zoomStatus } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const isMaximizeStatus = computeIsMaximizeStatus.value;
      return [
        h("div", {
          class: "vxe-modal--header-title"
        }, titleSlot ? getSlotVNs2(titleSlot({
          $modal: $xeModal,
          minimized: isMinimizeStatus,
          maximized: isMaximizeStatus
        })) : title ? getFuncText2(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-modal--header-right"
        }, [
          cornerSlot && !isMinimizeStatus ? h("div", {
            class: "vxe-modal--corner-wrapper"
          }, getSlotVNs2(cornerSlot({ $modal: $xeModal }))) : createCommentVNode(),
          (import_xe_utils90.default.isBoolean(showMinimize) ? showMinimize : showZoom) ? h("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: getI18n(`vxe.modal.zoom${zoomStatus === "minimize" ? "Out" : "Min"}`),
            onClick: toggleZoomMinEvent
          }, [
            h("i", {
              class: zoomStatus === "minimize" ? getIcon().MODAL_ZOOM_REVERT : getIcon().MODAL_ZOOM_MIN
            })
          ]) : createCommentVNode(),
          (import_xe_utils90.default.isBoolean(showMaximize) ? showMaximize : showZoom) && zoomStatus !== "minimize" ? h("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: getI18n(`vxe.modal.zoom${zoomStatus === "maximize" ? "Out" : "In"}`),
            onClick: toggleZoomMaxEvent
          }, [
            h("i", {
              class: zoomStatus === "maximize" ? getIcon().MODAL_ZOOM_OUT : getIcon().MODAL_ZOOM_IN
            })
          ]) : createCommentVNode(),
          showClose ? h("div", {
            class: ["vxe-modal--close-btn", "trigger--btn"],
            title: getI18n("vxe.modal.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().MODAL_CLOSE
            })
          ]) : createCommentVNode()
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showZoom, showMaximize, draggable } = props;
      const isMsg = computeIsMsg.value;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if ((import_xe_utils90.default.isBoolean(showMaximize) ? showMaximize : showZoom) && props.dblclickZoom && props.type === "modal") {
          headerOns.onDblclick = toggleZoomMaxEvent;
        }
        return h("div", Object.assign({ ref: refHeaderElem, class: ["vxe-modal--header", {
          "is--ellipsis": !isMsg && props.showTitleOverflow
        }] }, headerOns), headerSlot ? getSlotVNs2(headerSlot({ $modal: $xeModal })) : renderTitles());
      }
      return createCommentVNode();
    };
    const renderBody = () => {
      const { slots: propSlots = {}, status, message, iconStatus } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      const contVNs = [];
      if (!isMsg && (status || iconStatus)) {
        contVNs.push(h("div", {
          class: "vxe-modal--status-wrapper"
        }, [
          h("i", {
            class: ["vxe-modal--status-icon", iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
          })
        ]));
      }
      contVNs.push(h("div", {
        class: "vxe-modal--content"
      }, defaultSlot ? getSlotVNs2(defaultSlot({ $modal: $xeModal })) : getFuncText2(content)));
      return h("div", {
        class: "vxe-modal--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-modal--body-left"
        }, getSlotVNs2(leftSlot({ $modal: $xeModal }))) : createCommentVNode(),
        h("div", {
          class: "vxe-modal--body-default"
        }, contVNs),
        rightSlot ? h("div", {
          class: "vxe-modal--body-right"
        }, getSlotVNs2(rightSlot({ $modal: $xeModal }))) : createCommentVNode(),
        isMsg ? createCommentVNode() : h(loading_default2, {
          class: "vxe-modal--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton, type, loading: loading2 } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (import_xe_utils90.default.isBoolean(showCancelButton) ? showCancelButton : type === "confirm") {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (import_xe_utils90.default.isBoolean(showConfirmButton) ? showConfirmButton : type === "confirm" || type === "alert") {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading2,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-modal--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-modal--footer-left"
        }, lfSlot ? getSlotVNs2(lfSlot({ $modal: $xeModal })) : []),
        h("div", {
          class: "vxe-modal--footer-right"
        }, rfSlot ? getSlotVNs2(rfSlot({ $modal: $xeModal })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-modal--footer"
        }, footerSlot ? getSlotVNs2(footerSlot({ $modal: $xeModal })) : [renderDefaultFooter()]);
      }
      return createCommentVNode();
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, type, animat, draggable, iconStatus, position, loading: loading2, destroyOnClose, status, lockScroll, padding, lockView, mask, resize } = props;
      const { initialized, modalTop, contentVisible, visible, zoomStatus } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const isMsg = computeIsMsg.value;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const ons = {};
      if (isMsg) {
        ons.onMouseover = selfMouseoverEvent;
        ons.onMouseout = selfMouseoutEvent;
      }
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !initialized : true
      }, [
        h("div", Object.assign({ ref: refElem, class: ["vxe-modal--wrapper", `type--${type}`, `zoom--${zoomStatus || "revert"}`, className || "", position ? `pos--${position}` : "", {
          [`size--${vSize}`]: vSize,
          [`status--${status}`]: status,
          "is--padding": padding,
          "is--animat": animat,
          "lock--scroll": lockScroll,
          "lock--view": lockView,
          "is--draggable": draggable,
          "is--resize": resize,
          "is--mask": mask,
          "is--visible": contentVisible,
          "is--active": visible,
          "is--loading": loading2
        }], style: {
          zIndex: reactData.modalZindex,
          top: modalTop ? `${modalTop}px` : null
        }, onClick: selfClickEvent }, ons), [
          h("div", {
            ref: refModalBox,
            class: "vxe-modal--box",
            onMousedown: boxMousedownEvent
          }, [
            (isMsg || asideSlot) && !isMinimizeStatus ? h("div", {
              class: "vxe-modal--aside"
            }, asideSlot ? getSlotVNs2(asideSlot({ $modal: $xeModal })) : [
              status || iconStatus ? h("div", {
                class: "vxe-modal--status-wrapper"
              }, [
                h("i", {
                  class: ["vxe-modal--status-icon", iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
                })
              ]) : createCommentVNode()
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-modal--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter(),
              !isMsg && resize ? h("span", {
                class: "vxe-modal--resize"
              }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map((type2) => {
                return h("span", {
                  class: `${type2}-resize`,
                  type: type2,
                  onMousedown: dragEvent
                });
              })) : createCommentVNode()
            ])
          ])
        ])
      ]);
    };
    $xeModal.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openModal2();
      } else {
        closeModal2("model");
      }
    });
    onMounted(() => {
      if (true) {
        if (props.type === "modal" && props.showFooter && !(props.showConfirmButton || props.showCancelButton || slots.footer)) {
          warnLog2("vxe.modal.footPropErr");
        }
      }
      nextTick(() => {
        if (props.storage && !props.id) {
          errLog2("vxe.error.reqProp", ["modal.id"]);
        }
        if (props.modelValue) {
          openModal2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeModal, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeModal, "keydown");
      removeMsgQueue();
      removeBodyLockScroll();
    });
    provide("$xeModal", $xeModal);
    return $xeModal;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/form-view.js
var import_xe_utils92 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form-design/src/default-setting-data.js
var getDefaultSettingFormData = (defOpts) => {
  return {
    title: "",
    pcVisible: defOpts ? !!defOpts.pcVisible : true,
    pcVertical: true,
    pcTitleBold: true,
    pcTitleColon: false,
    pcTitleAlign: "",
    pcTitleWidth: "",
    pcTitleWidthUnit: "",
    mobileVisible: defOpts ? !!defOpts.mobileVisible : true,
    mobileVertical: true,
    mobileTitleBold: true,
    mobileTitleColon: false,
    mobileTitleAlign: "",
    mobileTitleWidth: "",
    mobileTitleWidthUnit: ""
  };
};
var createDefaultFormViewPCFormConfig = (params) => {
  const { formConfig } = params;
  return {
    vertical: formConfig.pcVertical,
    titleBold: formConfig.pcTitleBold,
    titleColon: formConfig.pcTitleColon,
    titleAlign: formConfig.pcTitleAlign,
    titleWidth: formConfig.pcTitleWidth
  };
};
var createDefaultFormViewMobileFormConfig = (params) => {
  const { formConfig } = params;
  return {
    vertical: formConfig.mobileVertical,
    titleBold: formConfig.mobileTitleBold,
    titleColon: formConfig.mobileTitleColon,
    titleAlign: formConfig.mobileTitleAlign,
    titleWidth: formConfig.mobileTitleWidth
  };
};

// node_modules/vxe-pc-ui/es/form/src/form-group.js
var import_xe_utils91 = __toESM(require_xe_utils());
var form_group_default = defineComponent({
  name: "VxeFormGroup",
  props: formItemProps,
  setup(props, context) {
    const { slots } = context;
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const $xeParentFormGroup = inject("$xeFormGroup", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    formItem.children = [];
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    const renderVN = () => {
      const formProps = $xeForm.props;
      const item = formItem;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle } = item;
      const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        key: item.id,
        class: getItemClass($xeForm, item, true),
        style: import_xe_utils91.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm, item, true),
        h("div", {
          class: getItemContentClass($xeForm, item, true),
          style: Object.assign({}, import_xe_utils91.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils91.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, defaultSlot ? defaultSlot({}) : [])
      ]);
    };
    const $xeFormGroup = {
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    onMounted(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeParentFormGroup);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    provide("$xeFormGroup", $xeFormGroup);
    provide("$xeFormItem", null);
    return $xeFormGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/form-view.js
var form_view_default = defineComponent({
  name: "VxeFormView",
  props: {
    modelValue: Object,
    config: Object,
    readonly: Boolean,
    disabled: Boolean,
    viewRender: Object,
    formOptions: Object,
    createFormConfig: Function,
    size: {
      type: String,
      default: () => getConfig().formView.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "submit",
    "reset"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils92.default.uniqueId();
    const refElem = ref();
    const formRef = ref();
    const { computeSize } = useSize(props);
    const $xeFormDesignLayoutStyle = inject("$xeFormDesignLayoutStyle", null);
    const reactData = reactive({
      formConfig: {},
      formRules: {},
      widgetObjList: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeFormView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clearConfig = () => {
      return loadConfig({
        formConfig: {},
        widgetData: []
      });
    };
    const loadConfig = (config3) => {
      if (config3) {
        const { formConfig, widgetData } = config3;
        loadFormConfig(formConfig || {});
        loadWidgetData(widgetData || []);
      }
      return nextTick();
    };
    const parseConfig = (config3) => {
      const { formConfig, widgetData } = config3 || {};
      const widgetObjList = parseWidgetData(widgetData || []);
      return Object.assign(Object.assign({}, parseForm(widgetObjList)), { formConfig: parseFormConfig(formConfig || {}), widgetData: widgetObjList });
    };
    const parseFormConfig = (formConfig) => {
      const { viewRender, createFormConfig, formOptions } = props;
      const params = { viewRender, formConfig };
      if (createFormConfig) {
        return createFormConfig(params);
      }
      const { name } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      return Object.assign({}, createPCFormConfig ? createPCFormConfig(params) : createDefaultFormViewPCFormConfig(params), formOptions);
    };
    const loadFormConfig = (formConfig) => {
      reactData.formConfig = parseFormConfig(formConfig);
      return nextTick();
    };
    const parseForm = (widgetObjList) => {
      const formData = {};
      const formRules = {};
      import_xe_utils92.default.eachTree(widgetObjList, (widget) => {
        const { name, field, required } = widget;
        const compConf = renderer.get(name) || {};
        const createWidgetFieldValue = compConf.createFormDesignWidgetFieldValue;
        const createWidgetFieldRules = compConf.createFormDesignWidgetFieldRules;
        formData[field] = createWidgetFieldValue ? createWidgetFieldValue({ widget, $formView: $xeFormView }) : getWidgetDefaultValue(widget);
        if (createWidgetFieldRules) {
          const rules = createWidgetFieldRules({ widget, $formView: $xeFormView });
          if (rules && rules.length) {
            formRules[field] = rules;
          }
        } else if (required) {
          formRules[field] = getWidgetDefaultRule();
        }
      }, { children: "children" });
      return {
        formData,
        formRules
      };
    };
    const parseWidgetData = (widgetData) => {
      return (widgetData || []).map((item) => configToWidget(item));
    };
    const loadWidgetData = (widgetData) => {
      const widgetObjList = parseWidgetData(widgetData);
      reactData.widgetObjList = widgetObjList;
      const { formData, formRules } = parseForm(widgetObjList);
      reactData.formRules = formRules;
      emit("update:modelValue", Object.assign(formData, props.modelValue));
      return nextTick();
    };
    const getWidgetDefaultValue = (widget) => {
      switch (widget.name) {
        case "subtable":
          return [];
      }
      return null;
    };
    const getWidgetDefaultRule = () => {
      return [
        { required: true, content: "" }
      ];
    };
    const updateWidgetStatus = (widget, value) => {
      const { field } = widget;
      const $form = formRef.value;
      if ($form) {
        $form.updateStatus({ field }, value);
      }
      return nextTick();
    };
    const setItemValue = (widget, value) => {
      const { modelValue } = props;
      const { field } = widget;
      const $form = formRef.value;
      if (modelValue) {
        modelValue[field] = value;
      }
      if ($form) {
        $form.updateStatus({ field }, value);
      }
      return nextTick();
    };
    const getItemValue = (widget) => {
      const { modelValue } = props;
      if (modelValue) {
        return modelValue[widget.field];
      }
      return null;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $formView: $xeFormView }, params));
    };
    const toWidgetFields = (widget) => {
      if (widget) {
        if (import_xe_utils92.default.isArray(widget)) {
          return widget.map((item) => item.name);
        } else {
          return [widget.name];
        }
      }
      return null;
    };
    const formViewMethods = {
      dispatchEvent: dispatchEvent2,
      clearConfig,
      loadConfig,
      parseConfig,
      loadFormConfig,
      loadWidgetData,
      updateWidgetStatus,
      setItemValue,
      getItemValue,
      validate() {
        const $form = formRef.value;
        if ($form) {
          return $form.validate();
        }
        return nextTick();
      },
      validateWidget(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.validateField(toWidgetFields(widget));
        }
        return nextTick();
      },
      clearValidate(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.clearValidate(toWidgetFields(widget));
        }
        return nextTick();
      },
      reset() {
        const { widgetObjList } = reactData;
        const { formData } = parseForm(widgetObjList);
        emit("update:modelValue", Object.assign({}, formData));
        return nextTick();
      },
      /**
       * 
       * @deprecated
       */
      updateItemStatus(widget, value) {
        if (true) {
          warnLog2("vxe.error.delFunc", ["updateItemStatus", "updateWidgetStatus"]);
        }
        return updateWidgetStatus(widget, value);
      }
    };
    const handleSubmit = (params) => {
      dispatchEvent2("submit", params, params.$event);
    };
    const handleReset = (params) => {
      dispatchEvent2("reset", params, params.$event);
    };
    const formViewPrivateMethods = {};
    Object.assign($xeFormView, formViewMethods, formViewPrivateMethods);
    const renderVN = () => {
      const { readonly, disabled, modelValue } = props;
      const { formConfig, formRules, widgetObjList } = reactData;
      const vSize = computeSize.value;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: ["vxe-form-view", {
          [`size--${vSize}`]: vSize
        }]
      }, [
        topSlot ? h("div", {
          class: "vxe-form-view--top"
        }, getSlotVNs2(topSlot({ $formView: $xeFormView }))) : createCommentVNode(),
        h(form_default, Object.assign(Object.assign({ ref: formRef }, formConfig), {
          data: modelValue,
          customLayout: true,
          readonly,
          disabled,
          span: 24,
          rules: formRules,
          onSubmit: handleSubmit,
          onReset: handleReset
        }), {
          default() {
            const { readonly: readonly2, disabled: disabled2 } = props;
            return [
              headerSlot ? h(form_item_default, {}, {
                default() {
                  return headerSlot({});
                }
              }) : createCommentVNode(),
              ...widgetObjList.map((widget) => {
                const { name } = widget;
                const compConf = renderer.get(name) || {};
                const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                const renderWidgetDesignPreview = compConf.renderFormDesignWidgetPreview;
                const renderWidgetDesignMobilePreview = compConf.renderFormDesignWidgetMobilePreview;
                const isEditMode = !!$xeFormDesignLayoutStyle;
                const renderOpts = widget;
                const params = { widget, readonly: !!readonly2, disabled: !!disabled2, isEditMode, isViewMode: !isEditMode, $formDesign: null, $formView: $xeFormView };
                return h(form_group_default, {
                  key: widget.id
                }, {
                  default() {
                    if ($xeFormDesignLayoutStyle) {
                      if ($xeFormDesignLayoutStyle.reactData.activeTab === 2) {
                        if (renderWidgetDesignMobilePreview) {
                          return getSlotVNs2(renderWidgetDesignMobilePreview(renderOpts, params));
                        }
                      } else {
                        if (renderWidgetDesignPreview) {
                          return getSlotVNs2(renderWidgetDesignPreview(renderOpts, params));
                        }
                      }
                    }
                    return renderWidgetDesignView ? getSlotVNs2(renderWidgetDesignView(renderOpts, params)) : [];
                  }
                });
              }),
              footerSlot ? h(form_group_default, {
                span: 24
              }, {
                default() {
                  return footerSlot({});
                }
              }) : createCommentVNode()
            ];
          }
        }),
        bottomSlot ? h("div", {
          class: "vxe-form-view--bottom"
        }, getSlotVNs2(bottomSlot({ $formView: $xeFormView }))) : createCommentVNode()
      ]);
    };
    $xeFormView.renderVN = renderVN;
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeFormView", $xeFormView);
    return $xeFormView;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/input/src/input.js
var import_xe_utils94 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/number-input/src/util.js
var import_xe_utils93 = __toESM(require_xe_utils());
function handleNumber(val) {
  return import_xe_utils93.default.isString(val) ? val.replace(/,/g, "") : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test("" + inputValue)) {
    return import_xe_utils93.default.toFixed(import_xe_utils93.default.ceil(inputValue, digitsValue), digitsValue);
  }
  return import_xe_utils93.default.toFixed(import_xe_utils93.default.floor(inputValue, digitsValue), digitsValue);
}

// node_modules/vxe-pc-ui/es/input/src/input.js
var input_default = defineComponent({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "text"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().input.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().input.size || getConfig().size
    },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // numberintegerfloat
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().input.exponential
    },
    // numberintegerfloatpassword
    controls: {
      type: Boolean,
      default: () => getConfig().input.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => getConfig().input.digits
    },
    // dateweekmonthquarteryear
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    //  startWeek startDay 
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => getConfig().input.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().input.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().input.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().input.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 
    maxlength: [String, Number],
    // 
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeSelect = inject("$xeSelect", null);
    const $xeTreeSelect = inject("$xeTreeSelect", null);
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils94.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: "",
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0,
      dnTimeout: void 0
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate2 = (value, format4) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      return import_xe_utils94.default.toStringDate(value, format4);
    };
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().input.transfer;
        if (import_xe_utils94.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      if ($xeForm) {
        return $xeForm.props.readonly;
      }
      return false;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      const maxLen = maxLength || maxlength;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        if (!import_xe_utils94.default.toNumber(maxLen)) {
          return 16;
        }
      }
      return maxLen;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsNumType = computed(() => {
      return ["number", "integer", "float"].indexOf(props.type) > -1;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils94.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils94.default.toNumber(inpMaxLength);
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsPawdType = computed(() => {
      return props.type === "password";
    });
    const computeIsSearchType = computed(() => {
      return props.type === "search";
    });
    const computeDigitsValue = computed(() => {
      return import_xe_utils94.default.toInteger(props.digits) || 1;
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils94.default.toInteger(step) || 1;
      } else if (type === "float") {
        return import_xe_utils94.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils94.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === "text" || type === "search");
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils94.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils94.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils94.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate2(item, dateValueFormat);
          if (import_xe_utils94.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils94.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils94.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === "time") {
        return "HH:mm:ss";
      }
      if (type === "datetime") {
        return "yyyy-MM-dd HH:mm:ss";
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate2(modelValue, dateValueFormat);
        if (import_xe_utils94.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return import_xe_utils94.default.toDateString(datetimePanelValue, hasTimeSecond ? "HH:mm:ss" : "HH:mm");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return "";
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { yearSize } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index2 = -4; index2 < yearSize + 4; index2++) {
          const date = import_xe_utils94.default.getWhatYear(startYearDate, index2, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index2 < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index2 >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return getI18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return getI18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return getI18n("vxe.input.date.dayLabel", [year, month ? getI18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils94.default.toNumber(import_xe_utils94.default.isNumber(startDay) || import_xe_utils94.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index2 = 0; index2 < 6; index2++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils94.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { quarterSize } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils94.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index2 = -2; index2 < quarterSize - 2; index2++) {
          const date = import_xe_utils94.default.getWhatQuarter(firstYear, index2);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils94.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { monthSize } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils94.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index2 = -4; index2 < monthSize - 4; index2++) {
          const date = import_xe_utils94.default.getWhatYear(selectMonth, 0, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils94.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils94.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index2 = 0; index2 < 42; index2++) {
          const date = import_xe_utils94.default.getWhatDay(startDayDate, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils94.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils94.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index2 = 0; index2 < 24; index2++) {
          list.push({
            value: index2,
            label: ("" + index2).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index2 = 0; index2 < 60; index2++) {
          list.push({
            value: index2,
            label: ("" + index2).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const isReadonly = computeIsReadonly.value;
      return isReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeInputType = computed(() => {
      const { type } = props;
      const { showPwd } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === "number") {
        return "text";
      }
      return type;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().input.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpImmediate = computed(() => {
      const { type, immediate } = props;
      return immediate || !(type === "text" || type === "number" || type === "integer" || type === "float");
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === "integer" ? import_xe_utils94.default.toInteger(handleNumber(inputValue)) : import_xe_utils94.default.toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= import_xe_utils94.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= import_xe_utils94.default.toNumber(max);
      }
      return false;
    });
    const getNumberValue = (val) => {
      const { type, exponential } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === "float" ? toFloatValueFixed(val, digitsValue) : import_xe_utils94.default.toValueString(val);
      if (exponential && (val === restVal || import_xe_utils94.default.toValueString(val).toLowerCase() === import_xe_utils94.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      inputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      inputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils94.default.toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent("change", { value }, evnt);
        if (!$xeSelect && !$xeTreeSelect) {
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          handleChange(value, evnt);
        } else {
          inputMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent3(evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent("blur", { value }, evnt);
      if (!$xeSelect && !$xeTreeSelect) {
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent3(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = window.setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (isNumType || ["text", "search", "password"].indexOf(type) > -1) {
        focus();
      }
      handleChange("", evnt);
      inputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate2(value, dateValueFormat);
      }
      if (import_xe_utils94.default.isValidDate(dValue)) {
        dLabel = import_xe_utils94.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils94.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const { type } = props;
      const { inputValue } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === "float") {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            handleChange(validValue, { type: "init" });
          }
        }
      }
    };
    const validMaxNum = (num) => {
      return props.max === null || import_xe_utils94.default.toNumber(num) <= import_xe_utils94.default.toNumber(props.max);
    };
    const validMinNum = (num) => {
      return props.min === null || import_xe_utils94.default.toNumber(num) >= import_xe_utils94.default.toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils94.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils94.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils94.default.toNumber(props.selectDay);
        date = import_xe_utils94.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = import_xe_utils94.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils94.default.findIndexOf(dateListValue, (val) => import_xe_utils94.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map((date2) => import_xe_utils94.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils94.default.isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter((val) => !import_xe_utils94.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils94.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (isNumType) {
          if (inputValue) {
            let inpNumVal = type === "integer" ? import_xe_utils94.default.toInteger(handleNumber(inputValue)) : import_xe_utils94.default.toNumber(handleNumber(inputValue));
            if (!validMinNum(inpNumVal)) {
              inpNumVal = min;
            } else if (!validMaxNum(inpNumVal)) {
              inpNumVal = max;
            }
            if (exponential) {
              const inpStringVal = import_xe_utils94.default.toValueString(inputValue).toLowerCase();
              if (inpStringVal === import_xe_utils94.default.toNumber(inpNumVal).toExponential()) {
                inpNumVal = inpStringVal;
              }
            }
            handleChange(getNumberValue(inpNumVal), { type: "check" });
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate2(inputValue, dateLabelFormat);
            if (import_xe_utils94.default.isValidDate(inpDateVal)) {
              if (type === "time") {
                inpDateVal = import_xe_utils94.default.toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  handleChange(inpDateVal, { type: "check" });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === "datetime") {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== import_xe_utils94.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils94.default.toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = import_xe_utils94.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            handleChange("", { type: "check" });
          }
        }
      }
    };
    const passwordToggleEvent = (evnt) => {
      const { showPwd } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!isDisabled && !isReadonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const searchEvent = (evnt) => {
      inputMethods.dispatchEvent("search-click", {}, evnt);
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils94.default.toInteger(handleNumber(inputValue)) : import_xe_utils94.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils94.default.add(numValue, stepValue) : import_xe_utils94.default.subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberNextEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent("next-number", { value: reactData.inputValue }, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      internalData.dnTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent("prev-number", { value: reactData.inputValue }, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { exponential, controls } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (!isCtrlKey && !isShiftKey && !isAltKey && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (isEsc) {
          afterCheckValue();
        } else if (isUpArrow || isDwArrow) {
          if (controls) {
            numberKeydownEvent(evnt);
          }
        }
      }
      triggerEvent3(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const numberStopDown = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
      }
    };
    const numberDownPrevEvent = (evnt) => {
      internalData.dnTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass2(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        internalData.dnTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent3(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils94.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils94.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -1, "first");
          } else {
            viewDate = import_xe_utils94.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent("date-prev", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils94.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, 1, "first");
          } else {
            viewDate = import_xe_utils94.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent("date-next", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const { date } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      if (disabledMethod) {
        return disabledMethod({ type: datePanelType, viewType: datePanelType, date, $input: $xeInput });
      }
      return false;
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils94.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils94.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils94.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils94.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map((date) => import_xe_utils94.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils94.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils94.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils94.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils94.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils94.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils94.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils94.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils94.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils94.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils94.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils94.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils94.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils94.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils94.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils94.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils94.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils94.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils94.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils94.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils94.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils94.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils94.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils94.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), (elem) => {
            updateTimePos(elem);
          });
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(targetElem);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.top = "";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const isReadonly = computeIsReadonly.value;
      if (!isReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el2 = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode2(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeInput });
        const festivalItem = festivalRest ? import_xe_utils94.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils94.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-input--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label || ""}`),
            h("span", {
              class: ["vxe-input--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils94.default.toValueString(extraItem.label))
          ] : [`${label || ""}`])
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils94.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-input--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-input--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-input--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return [`${label || ""}`];
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-input--date-picker-header"
        }, [
          h("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-input--date-picker-label"
            }, selectDatePanelLabel) : h("span", {
              class: "vxe-input--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-input--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-input--time-picker-header"
        }, [
          hasTimeMinute ? h("span", {
            class: "vxe-input--time-picker-title"
          }, dateTimeLabel) : createCommentVNode(),
          h("div", {
            class: "vxe-input--time-picker-btn"
          }, [
            h("button", {
              class: "vxe-input--time-picker-confirm",
              type: "button",
              onClick: dateConfirmEvent
            }, getI18n("vxe.button.confirm"))
          ])
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-input--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, hourList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, minuteList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode(),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-input--time-picker-second-list"
          }, secondList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode()
        ])
      ];
    };
    const renderPanel = () => {
      const { type } = props;
      const { initialized, isAniVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-input--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-input--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-input--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-input--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            key: type || "default",
            ref: refPanelWrapper,
            class: "vxe-input--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-input--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, visiblePanel || isAniVisible ? renders : [])
        ]);
      }
      return createCommentVNode();
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("div", {
        class: "vxe-input--control-icon"
      }, [
        h("div", {
          class: "vxe-input--number-icon"
        }, [
          h("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": isDisabledAddNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_PREV_NUM
            })
          ]),
          h("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": isDisabledSubtractNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_NEXT_NUM
            })
          ])
        ])
      ]);
    };
    const renderDatePickerIcon = () => {
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-input--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderSearchIcon = () => {
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: searchEvent
      }, [
        h("i", {
          class: ["vxe-input--search-icon", getIcon().INPUT_SEARCH]
        })
      ]);
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      const isClearable = computeIsClearable.value;
      const isExtraBtn = isPawdType || isNumType || isDatePickerType || isSearchType;
      return isClearable || suffixSlot || suffixIcon || isExtraBtn ? h("div", {
        class: ["vxe-input--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils94.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        isExtraBtn ? renderExtraSuffixIcon() : createCommentVNode(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]) : null;
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      if (isPawdType) {
        return renderPasswordIcon();
      }
      if (isNumType) {
        if (controls) {
          return renderNumberIcon();
        }
      }
      if (isDatePickerType) {
        return renderDatePickerIcon();
      }
      if (isSearchType) {
        return renderSearchIcon();
      }
      return createCommentVNode();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $input: $xeInput }, params));
    };
    inputMethods = {
      dispatchEvent: dispatchEvent2,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeInput, inputMethods);
    const renderVN = () => {
      const { className, controls, type, align, showWordCount, countMethod, name, autoComplete, autocomplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-input--readonly", `type--${type}`, className]
        }, inputValue);
      }
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const isWordCount = showWordCount && ["text", "search"].includes(type);
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--count": isWordCount,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils94.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            maxlength: inpMaxLength,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode(),
        // 
        renderPanel(),
        // 
        isWordCount ? h("span", {
          class: ["vxe-input--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ""}`) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    onMounted(() => {
      globalEvents.on($xeInput, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeInput, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeInput, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeInput, "blur", handleGlobalBlurEvent);
    });
    onBeforeUnmount(() => {
      numberStopDown();
      afterCheckValue();
      globalEvents.off($xeInput, "mousewheel");
      globalEvents.off($xeInput, "mousedown");
      globalEvents.off($xeInput, "keydown");
      globalEvents.off($xeInput, "blur");
    });
    initValue();
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/radio/src/group.js
var import_xe_utils97 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/radio/src/radio.js
var import_xe_utils95 = __toESM(require_xe_utils());
var radio_default = defineComponent({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    name: String,
    strict: {
      type: Boolean,
      default: () => getConfig().radio.strict
    },
    size: {
      type: String,
      default: () => getConfig().radio.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeRadioGroup = inject("$xeRadioGroup", null);
    const xID = import_xe_utils95.default.uniqueId();
    const reactData = reactive({});
    const $xeRadio = {
      xID,
      props,
      context,
      reactData
    };
    const { computeSize } = useSize(props);
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const { computeIsDisabled: computeIsDisabled2 } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled2.value;
        }
      }
      return disabled;
    });
    const computeName = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : props.name;
    });
    const computeStrict = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { label } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : props.modelValue === label;
    });
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        dispatchEvent2("change", { label }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $radio: $xeRadio }, params));
    };
    const radioMethods = {
      dispatchEvent: dispatchEvent2
    };
    const radioPrivateMethods = {};
    Object.assign($xeRadio, radioMethods, radioPrivateMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", {
          [`size--${vSize}`]: vSize,
          "is--checked": isChecked,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText2(props.content))
      ]);
    };
    $xeRadio.renderVN = renderVN;
    return $xeRadio;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/radio/src/button.js
var import_xe_utils96 = __toESM(require_xe_utils());
var button_default3 = defineComponent({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    strict: {
      type: Boolean,
      default: () => getConfig().radioButton.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioButton.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeRadioGroup = inject("$xeRadioGroup", null);
    const xID = import_xe_utils96.default.uniqueId();
    const reactData = reactive({});
    const { computeSize } = useSize(props);
    const $xeRadioButton = {
      xID,
      props,
      context,
      reactData
    };
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const { computeIsDisabled: computeIsDisabled2 } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled2.value;
        }
      }
      return disabled;
    });
    const computeName = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : null;
    });
    const computeStrict = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { label } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : props.modelValue === label;
    });
    const radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $radioButton: $xeRadioButton }, params));
      }
    };
    const radioButtonPrivateMethods = {};
    Object.assign($xeRadioButton, radioButtonMethods, radioButtonPrivateMethods);
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioButtonMethods.dispatchEvent("change", { label }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", "vxe-radio-button", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText2(props.content))
      ]);
    };
    $xeRadioButton.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/radio/src/group.js
var group_default3 = defineComponent({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    type: String,
    options: Array,
    optionProps: Object,
    strict: {
      type: Boolean,
      default: () => getConfig().radioGroup.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioGroup.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils97.default.uniqueId();
    useSize(props);
    const reactData = reactive({});
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaps = {
      computeIsDisabled
    };
    const $xeRadioGroup = {
      xID,
      props,
      context,
      reactData,
      name: import_xe_utils97.default.uniqueId("xe_group_"),
      getComputeMaps: () => computeMaps
    };
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $radioGroup: $xeRadioGroup }, params));
    };
    const radioGroupMethods = {
      dispatchEvent: dispatchEvent2
    };
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const value = params.label;
        emit("update:modelValue", value);
        dispatchEvent2("change", params, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRadioGroup, radioGroupMethods, radioGroupPrivateMethods);
    const renderVN = () => {
      const { options, type } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === "button" ? button_default3 : radio_default;
      return h("div", {
        class: "vxe-radio-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(btnComp, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    provide("$xeRadioGroup", $xeRadioGroup);
    $xeRadioGroup.renderVN = renderVN;
    return $xeRadioGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/select/src/select.js
var import_xe_utils98 = __toESM(require_xe_utils());
function isOptionVisible(option2) {
  return option2.visible !== false;
}
function getOptUniqueId() {
  return import_xe_utils98.default.uniqueId("opt_");
}
var select_default = defineComponent({
  name: "VxeSelect",
  props: {
    modelValue: [String, Number, Boolean, Array],
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: () => getConfig().select.multiCharOverflow
    },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    transfer: {
      type: Boolean,
      default: null
    },
    scrollY: Object,
    //  option-config.keyField 
    optionId: {
      type: String,
      default: () => getConfig().select.optionId
    },
    //  option-config.useKey 
    optionKey: Boolean
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils98.default.uniqueId();
    const refElem = ref();
    const refInput = ref();
    const refInpSearch = ref();
    const refVirtualWrapper = ref();
    const refOptionPanel = ref();
    const refVirtualBody = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      optList: [],
      afterVisibleList: [],
      staticOptions: [],
      reactFlag: 0,
      currentOption: null,
      searchValue: "",
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      synchData: [],
      fullData: [],
      optGroupKeyMaps: {},
      optFullValMaps: {},
      remoteValMaps: {},
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      },
      lastScrollTime: 0,
      hpTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const $xeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils98.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeGroupPropsOpts = computed(() => {
      return Object.assign({}, props.optionGroupProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeGroupLabelField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || "label";
    });
    const computeGroupOptionsField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || "options";
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, multiple, max } = props;
      if (multiple && max) {
        return (import_xe_utils98.default.isArray(modelValue) ? modelValue.length : import_xe_utils98.default.eqNull(modelValue) ? 0 : 1) >= import_xe_utils98.default.toNumber(max);
      }
      return false;
    });
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig().select.scrollY, props.scrollY);
    });
    const computeOptionOpts = computed(() => {
      return Object.assign({}, getConfig().select.optionConfig, props.optionConfig);
    });
    const computeMultiMaxCharNum = computed(() => {
      return import_xe_utils98.default.toNumber(props.multiCharOverflow);
    });
    const computeSelectLabel = computed(() => {
      const { modelValue, remote, multiple } = props;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      if (import_xe_utils98.default.eqNull(modelValue)) {
        return "";
      }
      const vals = import_xe_utils98.default.isArray(modelValue) ? modelValue : [modelValue];
      if (remote) {
        return vals.map((val) => getRemoteSelectLabel(val)).join(", ");
      }
      return vals.map((val) => {
        const label = getSelectLabel(val);
        if (multiple && multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
          return `${label.substring(0, multiMaxCharNum)}...`;
        }
        return label;
      }).join(", ");
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils98.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils98.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $select: $xeSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const getOptKey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || "_X_OPTION_KEY";
    };
    const getOptId = (option2) => {
      const optid = option2[getOptKey()];
      return optid ? encodeURIComponent(optid) : "";
    };
    const getRemoteSelectLabel = (value) => {
      const { remoteValMaps } = internalData;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValMaps[value];
      const item = remoteItem ? remoteItem.item : null;
      return import_xe_utils98.default.toValueString(item ? item[labelField] : value);
    };
    const getSelectLabel = (value) => {
      const { optFullValMaps } = internalData;
      const labelField = computeLabelField.value;
      const cacheItem = reactData.reactFlag ? optFullValMaps[value] : null;
      return cacheItem ? cacheItem.item[labelField] : import_xe_utils98.default.toValueString(value);
    };
    const cacheItemMap = (datas) => {
      const groupOptionsField = computeGroupOptionsField.value;
      const valueField = computeValueField.value;
      const key = getOptKey();
      const groupKeyMaps = {};
      const fullKeyMaps = {};
      const list = [];
      const handleOptItem = (item) => {
        list.push(item);
        let optid = getOptId(item);
        if (!optid) {
          optid = getOptUniqueId();
          item[key] = optid;
        }
        fullKeyMaps[item[valueField]] = {
          key: optid,
          item,
          _index: -1
        };
      };
      datas.forEach((group) => {
        handleOptItem(group);
        if (group[groupOptionsField]) {
          groupKeyMaps[group[key]] = group;
          group[groupOptionsField].forEach(handleOptItem);
        }
      });
      internalData.fullData = list;
      internalData.optGroupKeyMaps = groupKeyMaps;
      internalData.optFullValMaps = fullKeyMaps;
      reactData.reactFlag++;
      handleOption();
    };
    const handleOption = () => {
      const { filterable, filterMethod } = props;
      const { searchValue } = reactData;
      const { fullData, optFullValMaps } = internalData;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const searchStr = `${searchValue || ""}`.toLowerCase();
      let avList = [];
      if (filterable && filterMethod) {
        avList = fullData.filter((option2) => isOptionVisible(option2) && filterMethod({ group: null, option: option2, searchValue: searchStr }));
      } else if (filterable) {
        avList = fullData.filter((option2) => isOptionVisible(option2) && (!searchStr || `${option2[labelField]}`.toLowerCase().indexOf(searchStr) > -1));
      } else {
        avList = fullData.filter(isOptionVisible);
      }
      avList.forEach((item, index2) => {
        const cacheItem = optFullValMaps[item[valueField]];
        if (cacheItem) {
          cacheItem._index = index2;
        }
      });
      reactData.afterVisibleList = avList;
      return nextTick();
    };
    const setCurrentOption = (option2) => {
      if (option2) {
        reactData.currentOption = option2;
      }
    };
    const updateZIndex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el2) {
          const targetHeight = el2.offsetHeight;
          const targetWidth = el2.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(el2);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2, filterable } = props;
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          handleOption();
          updateYData();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
          handleFocusSearch();
          recalculate().then(() => refreshScroll());
        }, 10);
        setTimeout(() => {
          recalculate().then(() => refreshScroll());
        }, 100);
        updateZIndex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = "";
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      internalData.hpTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        dispatchEvent2("change", { value: selectValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      internalData.remoteValMaps = {};
      changeEvent(evnt, selectValue);
      dispatchEvent2("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, option2) => {
      const { modelValue, multiple } = props;
      const { remoteValMaps } = internalData;
      const valueField = computeValueField.value;
      const selectValue = option2[valueField];
      const remoteItem = remoteValMaps[selectValue];
      if (remoteItem) {
        remoteItem.item = option2;
      } else {
        remoteValMaps[selectValue] = {
          key: getOptId(option2),
          item: option2,
          _index: -1
        };
      }
      if (multiple) {
        let multipleValue = [];
        const selectVals = import_xe_utils98.default.eqNull(modelValue) ? [] : import_xe_utils98.default.isArray(modelValue) ? modelValue : [modelValue];
        const index2 = import_xe_utils98.default.findIndexOf(selectVals, (val) => val === selectValue);
        if (index2 === -1) {
          multipleValue = selectVals.concat([selectValue]);
        } else {
          multipleValue = selectVals.filter((val) => val !== selectValue);
        }
        changeEvent(evnt, multipleValue);
      } else {
        changeEvent(evnt, selectValue);
        hideOptionPanel();
      }
      reactData.reactFlag++;
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const validOffsetOption = (option2) => {
      const isDisabled = option2.disabled;
      const optid = getOptId(option2);
      if (!isDisabled && !hasOptGroupById(optid)) {
        return true;
      }
      return false;
    };
    const findOffsetOption = (option2, isDwArrow) => {
      const { afterVisibleList } = reactData;
      const { optFullValMaps } = internalData;
      const valueField = computeValueField.value;
      if (!option2) {
        for (let i = 0; i < afterVisibleList.length - 1; i++) {
          const item = afterVisibleList[i];
          if (validOffsetOption(item)) {
            return item;
          }
        }
      }
      const cacheItem = optFullValMaps[option2[valueField]];
      if (cacheItem) {
        const avIndex = cacheItem._index;
        if (avIndex > -1) {
          if (isDwArrow) {
            for (let i = avIndex + 1; i <= afterVisibleList.length - 1; i++) {
              const item = afterVisibleList[i];
              if (validOffsetOption(item)) {
                return item;
              }
            }
          } else {
            if (avIndex > 0) {
              for (let len = avIndex - 1; len >= 0; len--) {
                const item = afterVisibleList[len];
                if (validOffsetOption(item)) {
                  return item;
                }
              }
            }
          }
        }
      }
      return null;
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel, currentOption } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            changeOptionEvent(evnt, currentOption);
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            const offsetOption = findOffsetOption(currentOption, isDwArrow);
            if (offsetOption) {
              setCurrentOption(offsetOption);
              handleScrollToOption(offsetOption, isDwArrow);
            }
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        nextTick(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent2("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent2("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent2("blur", {}, evnt);
    };
    const modelSearchEvent = (value) => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const handleSearchEvent = () => {
      const { remote, remoteMethod } = props;
      const { searchValue } = reactData;
      if (remote && remoteMethod) {
        reactData.searchLoading = true;
        Promise.resolve(remoteMethod({ searchValue })).then(() => nextTick()).catch(() => nextTick()).finally(() => {
          reactData.searchLoading = false;
          handleOption();
          updateYData();
        });
      } else {
        handleOption();
        updateYData();
      }
    };
    const triggerSearchEvent = import_xe_utils98.default.debounce(handleSearchEvent, 350, { trailing: true });
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const checkOptionDisabled = (isSelected, option2, group) => {
      if (option2.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const updateYSpace = () => {
      const { scrollYLoad, afterVisibleList } = reactData;
      const { scrollYStore } = internalData;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad, afterVisibleList } = reactData;
      const { scrollYStore } = internalData;
      reactData.optList = scrollYLoad ? afterVisibleList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : afterVisibleList.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          const offsetYSize = Math.max(0, Math.min(2, import_xe_utils98.default.toNumber(sYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const handleScrollToOption = (option2, isDwArrow) => {
      const { scrollYLoad } = reactData;
      const { optFullValMaps, scrollYStore } = internalData;
      const valueField = computeValueField.value;
      const cacheItem = optFullValMaps[option2[valueField]];
      if (cacheItem) {
        const optid = cacheItem.key;
        const avIndex = cacheItem._index;
        if (avIndex > -1) {
          const optWrapperElem = refVirtualWrapper.value;
          const panelElem = refOptionPanel.value;
          const optElem = panelElem.querySelector(`[optid='${optid}']`);
          if (optWrapperElem) {
            if (optElem) {
              const wrapperHeight = optWrapperElem.offsetHeight;
              const offsetPadding = 1;
              if (isDwArrow) {
                if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                }
              } else {
                if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                }
              }
            } else if (scrollYLoad) {
              if (isDwArrow) {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight - optWrapperElem.clientHeight + scrollYStore.rowHeight;
              } else {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight;
              }
            }
          }
        }
      }
    };
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        if (import_xe_utils98.default.isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (import_xe_utils98.default.isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el2 = refElem.value;
      if (el2 && el2.clientWidth && el2.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const isVMScrollProcess = () => {
      const delayHover = 250;
      const { lastScrollTime } = internalData;
      return !!(lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      internalData.lastScrollTime = Date.now();
      dispatchEvent2("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    const loadData = (datas) => {
      cacheItemMap(datas || []);
      const { fullData, scrollYStore } = internalData;
      const sYOpts = computeSYOpts.value;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.synchData = datas || [];
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      handleData();
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return nextTick();
    };
    const hasOptGroupById = (optid) => {
      const { optGroupKeyMaps } = internalData;
      return !!optGroupKeyMaps[optid];
    };
    const selectMethods = {
      dispatchEvent: dispatchEvent2,
      loadData,
      reloadData(datas) {
        clearScroll();
        return loadData(datas);
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      refreshOption() {
        handleOption();
        updateYData();
        return nextTick();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      recalculate,
      clearScroll
    };
    Object.assign($xeSelect, selectMethods);
    const renderOption = (list, group) => {
      const { optionKey, modelValue } = props;
      const { currentOption } = reactData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const groupLabelField = computeGroupLabelField.value;
      const { useKey } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option2, cIndex) => {
        const { slots: slots2, className } = option2;
        const optid = getOptId(option2);
        const optionValue = option2[valueField];
        const isOptGroup = hasOptGroupById(optid);
        const isSelected = import_xe_utils98.default.isArray(modelValue) ? modelValue.indexOf(optionValue) > -1 : modelValue === optionValue;
        const isVisible = !isOptGroup || isOptionVisible(option2);
        const isDisabled = checkOptionDisabled(isSelected, option2, group);
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option: option2, group: null, $select: $xeSelect };
        return isVisible ? h("div", {
          key: useKey || optionKey ? optid : cIndex,
          class: ["vxe-select-option", className ? import_xe_utils98.default.isFunction(className) ? className(optParams) : className : "", {
            "vxe-select-optgroup": isOptGroup,
            "is--disabled": isDisabled,
            "is--selected": isSelected,
            "is--hover": currentOption && getOptId(currentOption) === optid
          }],
          // attrs
          optid,
          // event
          onMousedown: (evnt) => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: (evnt) => {
            if (!isDisabled && !isOptGroup) {
              changeOptionEvent(evnt, option2);
            }
          },
          onMouseenter: () => {
            if (!isDisabled && !isOptGroup && !isVMScrollProcess()) {
              setCurrentOption(option2);
            }
          }
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText2(option2[isOptGroup ? groupLabelField : labelField])) : createCommentVNode();
      });
    };
    const renderOpts = () => {
      const { optList, searchLoading } = reactData;
      if (searchLoading) {
        return [
          h("div", {
            class: "vxe-select--search-loading"
          }, [
            h("i", {
              class: ["vxe-select--search-icon", getIcon().SELECT_LOADED]
            }),
            h("span", {
              class: "vxe-select--search-text"
            }, getI18n("vxe.select.loadingText"))
          ])
        ];
      }
      if (optList.length) {
        return renderOption(optList);
      }
      return [
        h("div", {
          class: "vxe-select--empty-placeholder"
        }, props.emptyText || getI18n("vxe.select.emptyText"))
      ];
    };
    const renderVN = () => {
      const { className, popupClassName, loading: loading2, filterable } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, bodyHeight, topSpaceHeight } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-select--readonly", className]
        }, [
          h("div", {
            class: "vxe-select-slots",
            ref: "hideOption"
          }, defaultSlot ? defaultSlot({}) : []),
          h("span", {
            class: "vxe-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-select", className ? import_xe_utils98.default.isFunction(className) ? className({ $select: $xeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--filter": filterable,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, defaultSlot ? defaultSlot({}) : []),
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: inpPlaceholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().SELECT_LOADED : visiblePanel ? getIcon().SELECT_OPEN : getIcon().SELECT_CLOSE,
          modelValue: selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-select--panel", popupClassName ? import_xe_utils98.default.isFunction(popupClassName) ? popupClassName({ $select: $xeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized && (visiblePanel || isAniVisible) ? [
            h("div", {
              class: "vxe-select--panel-wrapper"
            }, [
              filterable ? h("div", {
                class: "vxe-select--panel-search"
              }, [
                h(input_default, {
                  ref: refInpSearch,
                  class: "vxe-select-search--input",
                  modelValue: reactData.searchValue,
                  clearable: true,
                  disabled: false,
                  readonly: false,
                  placeholder: getI18n("vxe.select.search"),
                  prefixIcon: getIcon().INPUT_SEARCH,
                  "onUpdate:modelValue": modelSearchEvent,
                  onFocus: focusSearchEvent,
                  onChange: triggerSearchEvent,
                  onSearch: triggerSearchEvent
                })
              ]) : createCommentVNode(),
              headerSlot ? h("div", {
                class: "vxe-select--panel-header"
              }, headerSlot({})) : createCommentVNode(),
              h("div", {
                class: "vxe-select--panel-body"
              }, [
                h("div", {
                  ref: refVirtualWrapper,
                  class: "vxe-select-option--wrapper",
                  onScroll: scrollEvent
                }, [
                  h("div", {
                    class: "vxe-select--y-space",
                    style: {
                      height: bodyHeight ? `${bodyHeight}px` : ""
                    }
                  }),
                  h("div", {
                    ref: refVirtualBody,
                    class: "vxe-select--body",
                    style: {
                      marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
                    }
                  }, renderOpts())
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-select--panel-footer"
              }, footerSlot({})) : createCommentVNode()
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => reactData.staticOptions, (val) => {
      loadData(val);
    });
    watch(() => props.options, (val) => {
      loadData(val || []);
    });
    watch(() => props.optionGroups, (val) => {
      loadData(val || []);
    });
    onMounted(() => {
      nextTick(() => {
        const { options, optionGroups } = props;
        if (optionGroups) {
          loadData(optionGroups);
        } else if (options) {
          loadData(options);
        }
      });
      globalEvents.on($xeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeSelect, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeSelect, "mousewheel");
      globalEvents.off($xeSelect, "mousedown");
      globalEvents.off($xeSelect, "keydown");
      globalEvents.off($xeSelect, "blur");
    });
    provide("$xeSelect", $xeSelect);
    $xeSelect.renderVN = renderVN;
    return $xeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/default-style-form.js
var getBoldOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.fontNormal"), value: false },
    { label: getI18n("vxe.formDesign.styleSetting.fontBold"), value: true }
  ];
};
var getColonOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.colonVisible"), value: true },
    { label: getI18n("vxe.formDesign.styleSetting.colonHidden"), value: false }
  ];
};
var getAlignOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.alignLeft"), value: "" },
    { label: getI18n("vxe.formDesign.styleSetting.alignRight"), value: "right" }
  ];
};
var getWidthUnitOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.unitPx"), value: "" },
    { label: getI18n("vxe.formDesign.styleSetting.unitPct"), value: "%" }
  ];
};
var renderLayoutOption = (formData, field, type, changeEvent) => {
  const isVertical = type === "vertical";
  return h("div", {
    class: ["vxe-form-design--widget-form-item-option", `is--${type}`, {
      "is--active": isVertical ? formData[field] : !formData[field]
    }],
    onClick() {
      formData[field] = isVertical;
      changeEvent();
    }
  }, [
    h("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    h("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    h("div", {}, isVertical ? getI18n("vxe.formDesign.styleSetting.verticalLayout") : getI18n("vxe.formDesign.styleSetting.horizontalLayout"))
  ]);
};
var DefaultPCStyleFormComponent = defineComponent({
  name: "DefaultPCStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const verticalField = "pcVertical";
    const refBoldOpts = ref(getBoldOptions());
    const refColonOpts = ref(getColonOptions());
    const refAlignOpts = ref(getAlignOptions());
    const refWidthUnitOpts = ref(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const { formData } = props;
      if (!formData.pcTitleWidth) {
        formData.pcTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.layoutTitle"),
              field: verticalField
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    renderLayoutOption(formData, verticalField, "vertical", changeLayoutEvent),
                    renderLayoutOption(formData, verticalField, "horizontal", changeLayoutEvent)
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.boldTitle")),
                    h(group_default3, {
                      modelValue: formData.pcTitleBold,
                      options: refBoldOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleBold = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.colonTitle")),
                    h(group_default3, {
                      modelValue: formData.pcTitleColon,
                      options: refColonOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleColon = val;
                      }
                    })
                  ]),
                  formData.pcVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.alignTitle")),
                    h(group_default3, {
                      modelValue: formData.pcTitleAlign,
                      options: refAlignOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleAlign = val;
                      }
                    })
                  ]),
                  formData.pcVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.widthTitle")),
                    h(input_default, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: formData.pcTitleWidth,
                      type: "integer",
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleWidth = val;
                      }
                    }),
                    h(select_default, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: formData.pcTitleWidthUnit,
                      options: refWidthUnitOpts.value,
                      transfer: true,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleWidthUnit = val;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
});
var DefaultMobileStyleFormComponent = defineComponent({
  name: "DefaultMobileStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const verticalField = "mobileVertical";
    const refBoldOpts = ref(getBoldOptions());
    const refColonOpts = ref(getColonOptions());
    const refAlignOpts = ref(getAlignOptions());
    const refWidthUnitOpts = ref(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const { formData } = props;
      if (!formData.mobileTitleWidth) {
        formData.mobileTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.layoutTitle"),
              field: verticalField
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    renderLayoutOption(formData, verticalField, "vertical", changeLayoutEvent),
                    renderLayoutOption(formData, verticalField, "horizontal", changeLayoutEvent)
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.boldTitle")),
                    h(group_default3, {
                      modelValue: formData.mobileTitleBold,
                      options: refBoldOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleBold = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.colonTitle")),
                    h(group_default3, {
                      modelValue: formData.mobileTitleColon,
                      options: refColonOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleColon = val;
                      }
                    })
                  ]),
                  formData.mobileVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.alignTitle")),
                    h(group_default3, {
                      modelValue: formData.mobileTitleAlign,
                      options: refAlignOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleAlign = val;
                      }
                    })
                  ]),
                  formData.mobileVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.widthTitle")),
                    h(input_default, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: formData.mobileTitleWidth,
                      type: "integer",
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleWidth = val;
                      }
                    }),
                    h(select_default, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: formData.mobileTitleWidthUnit,
                      options: refWidthUnitOpts.value,
                      transfer: true,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleWidthUnit = val;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/layout-style.js
var layout_style_default = defineComponent({
  name: "FormDesignLayoutStyle",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const reactData = reactive({
      activeTab: 1
    });
    const $xeFormDesignLayoutStyle = {
      reactData,
      renderVN() {
        return [];
      }
    };
    if (!$xeFormDesign) {
      return $xeFormDesignLayoutStyle;
    }
    const { props: formDesignProps, reactData: formDesignReactData } = $xeFormDesign;
    const settingVisible = ref(false);
    const settingConfig = ref(null);
    const settingFormData = ref({});
    const updatePreviewView = () => {
      settingConfig.value = $xeFormDesign.getConfig();
    };
    const createFormViewFormConfig = (params) => {
      const { viewRender } = params;
      const { activeTab } = reactData;
      const { name } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      const createMobileFormConfig = compConf ? compConf.createFormViewMobileFormConfig : null;
      if (activeTab === 2) {
        if (createMobileFormConfig) {
          return createMobileFormConfig(params);
        }
        return createDefaultFormViewMobileFormConfig(params);
      }
      if (createPCFormConfig) {
        return createPCFormConfig(params);
      }
      return createDefaultFormViewPCFormConfig(params);
    };
    const formDesignLayoutStyleMethod = {
      updatePreviewView,
      openStylePreview() {
        const { showPc } = formDesignProps;
        updatePreviewView();
        reactData.activeTab = showPc ? 1 : 2;
        settingVisible.value = true;
      }
    };
    Object.assign($xeFormDesignLayoutStyle, formDesignLayoutStyleMethod);
    const renderStylePreview = () => {
      const { activeTab } = reactData;
      return h("div", {
        class: ["vxe-form-design--layout-style-preview", `is--${activeTab === 2 ? "mobile" : "pc"}`]
      }, [
        h(form_view_default, {
          modelValue: settingFormData.value,
          config: settingConfig.value,
          createFormConfig: createFormViewFormConfig,
          "onUpdate:modelValue"(val) {
            settingFormData.value = val;
          }
        })
      ]);
    };
    const renderMobileStyle = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingMobileFormView = compConf ? compConf.renderFormDesignMobileStyleFormView : null;
        if (renderSettingMobileFormView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-mobile-form-view"
          }, getSlotVNs2(renderSettingMobileFormView({}, { $formDesign: $xeFormDesign, formConfig: formData })));
        }
      }
      return h(DefaultMobileStyleFormComponent, {
        formData
      });
    };
    const renderPCStyle = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderStylePCFormView = compConf ? compConf.renderFormDesignStyleFormView : null;
        if (renderStylePCFormView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-pc-form-view"
          }, getSlotVNs2(renderStylePCFormView({}, { $formDesign: $xeFormDesign, formConfig: formData })));
        }
      }
      return h(DefaultPCStyleFormComponent, {
        formData
      });
    };
    const renderStyleSetting = () => {
      const { showPc, showMobile } = formDesignProps;
      const { activeTab } = reactData;
      return h("div", {
        class: "vxe-form-design--layout-style-setting"
      }, [
        h(tabs_default, {
          modelValue: activeTab,
          titleWidth: showPc && showMobile ? "50%" : "100%",
          titleAlign: "center",
          padding: true,
          onChange: updatePreviewView,
          "onUpdate:modelValue"(val) {
            reactData.activeTab = val;
          }
        }, {
          default() {
            const tabVNs = [];
            if (showPc) {
              tabVNs.push(h(tab_pane_default, {
                title: getI18n("vxe.formDesign.widgetProp.displaySetting.pc"),
                icon: getIcon().FORM_DESIGN_PROPS_PC,
                k: 1,
                name: 1
              }, {
                default() {
                  return renderPCStyle();
                }
              }));
            }
            if (showMobile) {
              tabVNs.push(h(tab_pane_default, {
                title: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile"),
                icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                key: 2,
                name: 2
              }, {
                default() {
                  return renderMobileStyle();
                }
              }));
            }
            return tabVNs;
          }
        })
      ]);
    };
    const renderVN = () => {
      const { showPc, showMobile } = formDesignProps;
      return h(modal_default, {
        modelValue: settingVisible.value,
        title: getI18n("vxe.formDesign.styleSetting.title"),
        height: "90vh",
        width: "90vw",
        escClosable: true,
        maskClosable: true,
        destroyOnClose: true,
        showMaximize: true,
        transfer: true,
        "onUpdate:modelValue"(val) {
          settingVisible.value = val;
        }
      }, {
        default() {
          return h("div", {
            class: "vxe-form-design--layout-style"
          }, [
            renderStylePreview(),
            showPc || showMobile ? renderStyleSetting() : createCommentVNode()
          ]);
        }
      });
    };
    $xeFormDesignLayoutStyle.renderVN = renderVN;
    provide("$xeFormDesignLayoutStyle", $xeFormDesignLayoutStyle);
    return $xeFormDesignLayoutStyle;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/form-design.js
var form_design_default = defineComponent({
  name: "VxeFormDesign",
  props: {
    size: {
      type: String,
      default: () => getConfig().formDesign.size || getConfig().size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().formDesign.height
    },
    widgets: {
      type: Array,
      default: () => import_xe_utils99.default.clone(getConfig().formDesign.widgets) || []
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().formDesign.showHeader
    },
    showPc: {
      type: Boolean,
      default: () => getConfig().formDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().formDesign.showMobile
    },
    formRender: Object
  },
  emits: [
    "click-widget",
    "add-widget",
    "copy-widget",
    "remove-widget",
    "drag-widget"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils99.default.uniqueId();
    const refElem = ref();
    const refLayoutStyle = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formData: {},
      widgetConfigs: [],
      widgetObjList: [],
      dragWidget: null,
      sortWidget: null,
      activeWidget: null
    });
    const internalData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeFormDesign = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const createWidget = (name) => {
      return new FormDesignWidgetInfo($xeFormDesign, name, reactData.widgetObjList);
    };
    const createEmptyWidget = () => {
      return new FormDesignWidgetInfo($xeFormDesign, "", reactData.widgetObjList);
    };
    const loadConfig = (config3) => {
      if (config3) {
        const { formConfig, widgetData } = config3;
        if (formConfig) {
          loadFormConfig(formConfig);
        }
        if (widgetData) {
          loadWidgetData(widgetData);
        }
      }
      const { activeWidget, widgetObjList } = reactData;
      if (activeWidget) {
        const rest = import_xe_utils99.default.findTree(widgetObjList, (item) => item.id === activeWidget.id, { children: "children" });
        if (rest) {
          reactData.activeWidget = rest.item;
        } else {
          reactData.activeWidget = widgetObjList[0] || null;
        }
      } else {
        reactData.activeWidget = widgetObjList[0] || null;
      }
      return nextTick();
    };
    const reloadConfig = (config3) => {
      clearConfig();
      return loadConfig(config3);
    };
    const getFormConfig = () => {
      return import_xe_utils99.default.clone(reactData.formData, true);
    };
    const loadFormConfig = (data) => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return nextTick();
    };
    const getWidgetById = (id2) => {
      const { widgetObjList } = reactData;
      if (id2) {
        const widgetId = import_xe_utils99.default.toNumber(id2);
        const rest = import_xe_utils99.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
        if (rest) {
          return rest.item;
        }
      }
      return null;
    };
    const getWidgetData = () => {
      const objList = import_xe_utils99.default.clone(reactData.widgetObjList, true);
      import_xe_utils99.default.eachTree(objList, (item) => {
        item.model.value = null;
      }, { children: "children" });
      return objList;
    };
    const loadWidgetData = (widgetData) => {
      reactData.widgetObjList = (widgetData || []).map((item) => configToWidget(item));
      return nextTick();
    };
    const openStyleSetting = () => {
      const $layoutStyle = refLayoutStyle.value;
      if ($layoutStyle) {
        $layoutStyle.openStylePreview();
      }
      return nextTick();
    };
    const clearConfig = () => {
      reactData.widgetObjList = [];
      initSettingForm();
      return nextTick();
    };
    const formDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $xeFormDesign }, params));
      },
      createWidget,
      createEmptyWidget,
      getConfig() {
        return {
          formConfig: getFormConfig(),
          widgetData: getWidgetData()
        };
      },
      clearConfig,
      loadConfig,
      reloadConfig,
      getFormConfig,
      loadFormConfig,
      getWidgetById,
      getFormData() {
        const { widgetObjList } = reactData;
        const formData = {};
        import_xe_utils99.default.eachTree(widgetObjList, (widget) => {
          formData[widget.field] = null;
        }, { children: "children" });
        return formData;
      },
      getWidgetData,
      loadWidgetData,
      refreshPreviewView() {
        const $layoutStyle = refLayoutStyle.value;
        if ($layoutStyle) {
          $layoutStyle.updatePreviewView();
        }
        return nextTick();
      },
      openStyleSetting
    };
    const updateWidgetConfigs = () => {
      const { widgets } = props;
      const widgetConfs = [];
      const baseWidgets = [];
      const layoutWidgets = [];
      const advancedWidgets = [];
      const customGroups = [];
      renderer.forEach((item, name) => {
        const { createFormDesignWidgetConfig } = item;
        if (createFormDesignWidgetConfig) {
          const widthItem = createWidget(name);
          const widgetConf = getWidgetConfig(name);
          const widgetCustomGroup = getWidgetConfigCustomGroup(name, $xeFormDesign);
          if (widgetCustomGroup) {
            const cusGroup = customGroups.find((item2) => item2.title === widgetCustomGroup);
            if (cusGroup) {
              cusGroup.children.push(widthItem);
            } else {
              customGroups.push({
                title: widgetCustomGroup,
                children: [widthItem]
              });
            }
          } else {
            switch (widgetConf.group) {
              case "layout":
                layoutWidgets.push(widthItem);
                break;
              case "advanced":
                advancedWidgets.push(widthItem);
                break;
              default:
                if (!["title"].includes(widthItem.name)) {
                  baseWidgets.push(widthItem);
                }
                break;
            }
          }
        }
      });
      if (baseWidgets.length) {
        widgetConfs.push({
          group: "base",
          children: baseWidgets
        });
      }
      if (layoutWidgets.length) {
        widgetConfs.push({
          group: "layout",
          children: layoutWidgets
        });
      }
      if (advancedWidgets.length) {
        widgetConfs.push({
          group: "advanced",
          children: advancedWidgets
        });
      }
      if (customGroups.length) {
        widgetConfs.push(...customGroups);
      }
      if (widgets && widgets.length) {
        reactData.widgetConfigs = props.widgets.map((config3) => {
          return {
            title: config3.customGroup,
            group: config3.group,
            children: config3.children ? config3.children.map((name) => {
              const widthItem = createWidget(name);
              return widthItem;
            }) : []
          };
        });
      } else {
        reactData.widgetConfigs = widgetConfs;
      }
    };
    const validWidgetUnique = (widgetName) => {
      const { widgetObjList } = reactData;
      const widgetConf = getWidgetConfig(widgetName);
      if (widgetConf.unique) {
        const existWidgetList = [];
        import_xe_utils99.default.eachTree(widgetObjList, (obj) => {
          if (obj.name === widgetName) {
            existWidgetList.push(obj);
          }
        }, { children: "children" });
        const status = existWidgetList.length < 1;
        if (!status) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.formDesign.error.wdFormUni"),
              status: "error",
              id: "wdFormUni"
            });
          }
        }
        return status;
      }
      return true;
    };
    const formDesignPrivateMethods = {
      validWidgetUnique,
      handleClickWidget(evnt, item) {
        if (item && item.name) {
          evnt.stopPropagation();
          reactData.activeWidget = item;
          formDesignMethods.dispatchEvent("click-widget", { widget: item }, evnt);
        }
      },
      handleCopyWidget(evnt, widget) {
        const { widgetObjList } = reactData;
        const rest = import_xe_utils99.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          evnt.stopPropagation();
          if (validWidgetUnique(widget.name)) {
            const { path } = rest;
            const rootIndex = Number(path[0]);
            const newWidget = createWidget(widget.name);
            if (newWidget.title) {
              newWidget.title = getI18n("vxe.formDesign.widget.copyTitle", [`${widget.title}`.replace(getI18n("vxe.formDesign.widget.copyTitle", [""]), "")]);
            }
            if (rootIndex >= widgetObjList.length - 1) {
              widgetObjList.push(newWidget);
            } else {
              widgetObjList.splice(rootIndex + 1, 0, newWidget);
            }
            reactData.activeWidget = newWidget;
            reactData.widgetObjList = [...widgetObjList];
            formDesignMethods.dispatchEvent("copy-widget", { widget, newWidget }, evnt);
          }
        }
      },
      handleRemoveWidget(evnt, widget) {
        const { widgetObjList } = reactData;
        const rest = import_xe_utils99.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          const { index: index2, parent, items } = rest;
          evnt.stopPropagation();
          if (index2 >= items.length - 1) {
            reactData.activeWidget = items[index2 - 1];
          } else {
            reactData.activeWidget = items[index2 + 1] || null;
          }
          if (parent && parent.name === "row") {
            items[index2] = createEmptyWidget();
          } else {
            items.splice(index2, 1);
          }
          reactData.widgetObjList = [...widgetObjList];
          formDesignMethods.dispatchEvent("remove-widget", { widget }, evnt);
        }
      }
    };
    const createSettingForm = () => {
      const { formRender, showPc, showMobile } = props;
      let conf = getDefaultSettingFormData({
        pcVisible: showPc,
        mobileVisible: showMobile
      });
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createFormDesignSettingFormConfig : null;
        conf = (createFormConfig ? createFormConfig({}) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const openStylePreviewEvent = () => {
      openStyleSetting();
    };
    Object.assign($xeFormDesign, formDesignMethods, formDesignPrivateMethods);
    const renderLayoutHeader = () => {
      const extraSlot = slots.extra;
      return h("div", {
        class: "vxe-form-design--header-wrapper"
      }, [
        h("div", {
          class: "vxe-form-design--header-left"
        }),
        h("div", {
          class: "vxe-form-design--header-middle"
        }),
        h("div", {
          class: "vxe-form-design--header-right"
        }, [
          extraSlot ? h("div", {
            class: "vxe-form-design--header-extra"
          }, extraSlot({})) : renderEmptyElement($xeFormDesign),
          h("div", {
            class: "vxe-form-design--header-setting"
          }, [
            h(button_default, {
              mode: "text",
              status: "primary",
              icon: getIcon().FORM_DESIGN_STYLE_SETTING,
              content: getI18n("vxe.formDesign.styleSetting.btn"),
              onClick: openStylePreviewEvent
            })
          ])
        ])
      ]);
    };
    const renderVN = () => {
      const { height, showHeader } = props;
      const vSize = computeSize.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: ["vxe-form-design", {
          [`size--${vSize}`]: vSize
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        showHeader || headerSlot ? h("div", {
          class: "vxe-form-design--header"
        }, headerSlot ? headerSlot({}) : renderLayoutHeader()) : createCommentVNode(),
        h("div", {
          class: "vxe-form-design--body"
        }, [
          h(layout_widget_default),
          h(layout_preview_default),
          h(layout_setting_default),
          h(layout_style_default, {
            ref: refLayoutStyle
          })
        ]),
        footerSlot ? h("div", {
          class: "vxe-form-design--footer"
        }, footerSlot ? footerSlot({}) : []) : createCommentVNode()
      ]);
    };
    $xeFormDesign.renderVN = renderVN;
    watch(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    watch(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    initSettingForm();
    updateWidgetConfigs();
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeFormDesign", $xeFormDesign);
    return $xeFormDesign;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/use/widget-name.js
var import_xe_utils100 = __toESM(require_xe_utils());
function useWidgetName(props) {
  const computeKebabCaseName = computed(() => {
    const { renderOpts } = props;
    return renderOpts ? import_xe_utils100.default.kebabCase(renderOpts.name) : "";
  });
  return {
    computeKebabCaseName
  };
}

// node_modules/vxe-pc-ui/es/form-design/src/use/widget-view.js
function useWidgetView(props) {
  const currWidget = computed(() => {
    const { renderParams } = props;
    return renderParams.widget;
  });
  const isEditMode = computed(() => {
    const { renderParams } = props;
    return renderParams.isEditMode || false;
  });
  const isViewMode = computed(() => {
    const { renderParams } = props;
    return renderParams.isViewMode || false;
  });
  const widgetOptions = computed(() => {
    const { renderParams } = props;
    const { widget } = renderParams;
    return widget ? widget.options : {};
  });
  const widgetModel = computed({
    get() {
      const { renderParams } = props;
      const { $formView, widget } = renderParams;
      return $formView ? $formView.getItemValue(widget) : null;
    },
    set(value) {
      const { renderParams } = props;
      const { $formView, widget } = renderParams;
      if ($formView) {
        $formView.setItemValue(widget, value);
      }
    }
  });
  return {
    currWidget,
    widgetOptions,
    widgetModel,
    isEditMode,
    isViewMode
  };
}

// node_modules/vxe-pc-ui/es/form-design/src/use/widget-subtable-view.js
var import_xe_utils101 = __toESM(require_xe_utils());
function useSubtableView(props) {
  const currWidget = computed(() => {
    const { renderParams } = props;
    return renderParams.widget;
  });
  const currColumn = computed(() => {
    const { renderParams } = props;
    return renderParams.column;
  });
  const currRow = computed(() => {
    const { renderParams } = props;
    return renderParams.row;
  });
  const widgetOptions = computed(() => {
    const { renderParams } = props;
    const { widget } = renderParams;
    return widget ? widget.options : {};
  });
  const cellModel = computed({
    get() {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils101.default.get(row, column.field);
    },
    set(value) {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils101.default.set(row, column.field, value);
    }
  });
  return {
    currColumn,
    currRow,
    currWidget,
    widgetOptions,
    cellModel
  };
}

// node_modules/vxe-pc-ui/es/textarea/src/textarea.js
var import_xe_utils102 = __toESM(require_xe_utils());
var autoTxtElem;
var textarea_default = defineComponent({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: null
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => getConfig().textarea.resize
    },
    size: {
      type: String,
      default: () => getConfig().textarea.size || getConfig().size
    },
    // 
    maxlength: [String, Number]
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils102.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refTextarea = ref();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xeTextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInputReadonly = computed(() => {
      const { editable } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().textarea.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      return maxLength || maxlength;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils102.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils102.default.toNumber(inpMaxLength);
    });
    const computeSizeOpts = computed(() => {
      return Object.assign({ minRows: 1, maxRows: 10 }, getConfig().textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const { size, autosize } = props;
      const { inputValue } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement("div");
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        if (!textElem) {
          return;
        }
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ["vxe-textarea--autosize", size ? `size--${size}` : ""].join(" ");
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ("" + (inputValue || "")).replace(/\n$/, "\n");
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        nextTick(() => {
          const sizeOpts = computeSizeOpts.value;
          const { minRows, maxRows } = sizeOpts;
          const textElem = refTextarea.value;
          if (!textElem) {
            return;
          }
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = import_xe_utils102.default.toNumber(textStyle.lineHeight);
          const paddingTop = import_xe_utils102.default.toNumber(textStyle.paddingTop);
          const paddingBottom = import_xe_utils102.default.toNumber(textStyle.paddingBottom);
          const borderTopWidth = import_xe_utils102.default.toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = import_xe_utils102.default.toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test("" + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent3 = (evnt) => {
      const value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, { value }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils102.default.toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const { immediate } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        handleChange(value, evnt);
      }
      $xeTextarea.dispatchEvent("input", { value }, evnt);
      handleResize();
    };
    const changeEvent = (evnt) => {
      const { immediate } = props;
      if (immediate) {
        triggerEvent3(evnt);
      } else {
        handleChange(reactData.inputValue, evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { immediate } = props;
      const { inputValue } = reactData;
      if (!immediate) {
        handleChange(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $textarea: $xeTextarea }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return nextTick();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return nextTick();
      }
    };
    Object.assign($xeTextarea, textareaMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    watch(computeSizeOpts, () => {
      updateAutoTxt();
      handleResize();
    });
    nextTick(() => {
      const { autosize } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const { className, resize, autosize, showWordCount, countMethod, rows, cols } = props;
      const { inputValue } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const inpMaxLength = computeInpMaxLength.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-textarea--readonly", className]
        }, inputValue);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-textarea", className, {
          [`size--${vSize}`]: vSize,
          "is--autosize": autosize,
          "is--count": showWordCount,
          "is--disabled": isDisabled,
          "is--rows": !import_xe_utils102.default.eqNull(rows),
          "is--cols": !import_xe_utils102.default.eqNull(cols)
        }],
        spellcheck: false
      }, [
        h("textarea", {
          ref: refTextarea,
          class: "vxe-textarea--inner",
          value: inputValue,
          name: props.name,
          placeholder: inpPlaceholder,
          maxlength: inpMaxLength,
          readonly: inputReadonly,
          disabled: isDisabled,
          rows,
          cols,
          style: resize ? {
            resize
          } : null,
          onInput: inputEvent,
          onChange: changeEvent,
          onKeydown: triggerEvent3,
          onKeyup: triggerEvent3,
          onClick: triggerEvent3,
          onFocus: triggerEvent3,
          onBlur: blurEvent
        }),
        showWordCount ? h("span", {
          class: ["vxe-textarea--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ""}`) : null
      ]);
    };
    $xeTextarea.renderVN = renderVN;
    return $xeTextarea;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tip/src/tip.js
var import_xe_utils103 = __toESM(require_xe_utils());
var tip_default = defineComponent({
  name: "VxeTip",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => getConfig().tip.icon
    },
    /**
     * 
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tip.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils103.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tip: $xeTip }, params));
    };
    const tipMethods = {
      dispatchEvent: dispatchEvent2
    };
    const tipPrivateMethods = {};
    Object.assign($xeTip, tipMethods, tipPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tip", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "has--title": !!(titleSlot || title)
        }]
      }, [
        iconSlot || icon ? h("div", {
          class: "vxe-tip--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-tip--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-tip--title"
          }, titleSlot ? getSlotVNs2(titleSlot({})) : import_xe_utils103.default.toValueString(title)) : createCommentVNode(),
          h("div", {
            class: "vxe-tip--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : import_xe_utils103.default.toValueString(content))
        ])
      ]);
    };
    $xeTip.renderVN = renderVN;
    return $xeTip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/use/widget-prop-data-source.js
function useWidgetPropDataSource(props, renderConfig) {
  const renConf = Object.assign({}, renderConfig);
  const isSubOption = renConf.isSubOption;
  const optionsContent = ref("");
  const expandIndexList = ref([]);
  const addOptionEvent = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const options = widget.options.options || [];
    options.push({
      value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [options.length + 1])
    });
    widget.options.options = [...options];
  };
  const subRE = /^(\s|\t)+/;
  const hasSubOption = (str) => {
    return subRE.test(str);
  };
  const expandAllOption = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const options = widget.options.options || [];
    const indexList = [];
    options.forEach((group, gIndex) => {
      const { options: options2 } = group;
      if (options2 && options2.length) {
        indexList.push(gIndex);
      }
    });
    expandIndexList.value = indexList;
  };
  const toggleExpandOption = (item, gIndex) => {
    if (expandIndexList.value.includes(gIndex)) {
      expandIndexList.value = expandIndexList.value.filter((num) => num !== gIndex);
    } else {
      expandIndexList.value.push(gIndex);
    }
  };
  const removeOptionEvent = (item, group) => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const { options } = widget;
    if (group) {
      if (group.options) {
        group.options = group.options.filter((obj) => obj !== item);
      }
    } else {
      options.options = options.options.filter((obj) => obj !== item);
    }
  };
  const confirmBatchAddOptionEvent = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const optList = [];
    const rowList = optionsContent.value.split("\n");
    let prevGroup = null;
    if (isSubOption) {
      rowList.forEach((str, index2) => {
        const nextStr = rowList[index2 + 1];
        const value = str.trim();
        if (!value) {
          return;
        }
        const item = {
          value
        };
        if (prevGroup) {
          if (hasSubOption(str)) {
            prevGroup.options.push(item);
            return;
          }
          prevGroup = null;
          optList.push(item);
        } else {
          optList.push(item);
        }
        if (nextStr) {
          if (hasSubOption(nextStr)) {
            prevGroup = Object.assign(item, { options: [] });
          }
        }
      });
    } else {
      rowList.forEach((str) => {
        optList.push({
          value: str.trim()
        });
      });
    }
    widget.options.options = optList;
    expandAllOption();
  };
  const openPopupEditEvent = () => {
    var _a2;
    const { renderParams } = props;
    const { widget } = renderParams;
    const contList = [];
    (_a2 = widget.options.options) === null || _a2 === void 0 ? void 0 : _a2.forEach((group) => {
      var _a3;
      contList.push(group.value);
      (_a3 = group.options) === null || _a3 === void 0 ? void 0 : _a3.forEach((item) => {
        contList.push(`	${item.value}`);
      });
    });
    optionsContent.value = contList.join("\n");
    VxeUI.modal.open({
      title: `${widget.title} - ${getI18n("vxe.formDesign.widgetProp.dataSource.batchEditOption")}`,
      width: 500,
      height: "50vh ",
      resize: true,
      showFooter: true,
      showCancelButton: true,
      showConfirmButton: true,
      confirmButtonText: getI18n("vxe.formDesign.widgetProp.dataSource.buildOption"),
      onConfirm: confirmBatchAddOptionEvent,
      slots: {
        default() {
          return h("div", {
            class: "vxe-form-design--widget-form-item-data-source-popup"
          }, [
            h(tip_default, {
              status: "primary",
              title: "",
              content: getI18n(`vxe.formDesign.widgetProp.dataSource.${isSubOption ? "batchEditSubTip" : "batchEditTip"}`)
            }),
            h(textarea_default, {
              resize: "none",
              modelValue: optionsContent.value,
              "onUpdate:modelValue"(val) {
                optionsContent.value = val;
              }
            })
          ]);
        }
      }
    });
  };
  const renderOption = (item, group, isExpand, gIndex, hasSub, isFirst, isLast) => {
    const hasFirstLevel = !group;
    return h("div", {
      class: ["vxe-form-design--widget-form-item-data-source-option", {
        "is--first": isFirst,
        "is--last": isLast
      }]
    }, [
      h("div", {
        class: "vxe-form-design--widget-expand-btn"
      }, hasFirstLevel && hasSub ? [
        h("i", {
          class: isExpand ? getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE : getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN,
          onClick() {
            toggleExpandOption(item, gIndex);
          }
        })
      ] : []),
      h("input", {
        class: "vxe-default-input",
        value: item.value,
        onInput(evnt) {
          item.value = evnt.target.value;
        }
      }),
      h(button_default, {
        status: "danger",
        mode: "text",
        icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
        onClick() {
          removeOptionEvent(item, group);
        }
      })
    ]);
  };
  const renderOptions = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const { options } = widget;
    const groups = options.options;
    const optVNs = [];
    if (groups) {
      groups.forEach((group, gIndex) => {
        const { options: options2 } = group;
        const isExpand = expandIndexList.value.includes(gIndex);
        if (options2 && options2.length) {
          optVNs.push(renderOption(group, null, isExpand, gIndex, true, gIndex === 0, gIndex === groups.length - 1));
          if (isExpand) {
            optVNs.push(h("div", {
              class: "vxe-form-design--widget-form-item-data-source-sub-option"
            }, options2.map((item) => renderOption(item, group, isExpand, 0, false, false, false))));
          }
        } else {
          optVNs.push(renderOption(group, null, isExpand, gIndex, false, gIndex === 0, gIndex === groups.length - 1));
        }
      });
    }
    return optVNs;
  };
  watch(() => props.renderParams.widget, () => {
    expandAllOption();
  });
  onMounted(() => {
    expandAllOption();
  });
  const renderDataSourceFormItemContent = () => {
    return [
      h("div", {}, [
        h(button_default, {
          status: "primary",
          mode: "text",
          content: getI18n("vxe.formDesign.widgetProp.dataSource.addOption"),
          onClick: addOptionEvent
        }),
        h(button_default, {
          status: "primary",
          mode: "text",
          content: getI18n("vxe.formDesign.widgetProp.dataSource.batchEditOption"),
          onClick: openPopupEditEvent
        })
      ]),
      h("div", {
        class: "vxe-form-design--widget-form-item-data-source-wrapper"
      }, renderOptions())
    ];
  };
  return {
    renderDataSourceFormItem() {
      return h(form_item_default, {
        title: getI18n("vxe.formDesign.widgetProp.dataSource.name"),
        field: "options"
      }, {
        default() {
          return renderDataSourceFormItemContent();
        }
      });
    },
    renderDataSourceFormItemContent
  };
}

// node_modules/vxe-pc-ui/es/form-design/render/util.js
var getFormDesignWidgetName = (name) => {
  return getI18n(`vxe.formDesign.widget.component.${name}`);
};
var handleGetFormDesignWidgetName = (params) => {
  return getFormDesignWidgetName(params.name);
};

// node_modules/vxe-pc-ui/es/form-design/widget-text/text-data.js
var getWidgetTextConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-text",
    group: "layout",
    options: {
      color: "",
      align: "",
      bold: false,
      fontSize: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-text/text-form.js
var import_xe_utils104 = __toESM(require_xe_utils());
var getFontSizeOptions = () => {
  return import_xe_utils104.default.range(12, 27).map((num) => {
    return { label: `${num}px`, value: `${num}px` };
  });
};
var getAlignOptions2 = () => {
  return [
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignLeft"), value: "" },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignCenter"), value: "center" },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignRight"), value: "right" }
  ];
};
var getBoldOptions2 = () => {
  return [
    { label: getI18n("vxe.formDesign.widgetProp.textProp.fontNormal"), value: false },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.fontBold"), value: true }
  ];
};
var WidgetTextFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const alignOpts = ref(getAlignOptions2());
    const boldOpts = ref(getBoldOptions2());
    const fontSizeOpts = ref(getFontSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.boldTitle"),
              field: "bold",
              itemRender: { name: "VxeRadioGroup", options: boldOpts.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.alignTitle"),
              field: "align",
              itemRender: { name: "VxeRadioGroup", options: alignOpts.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.sizeTitle"),
              field: "fontSize",
              itemRender: { name: "VxeSelect", options: fontSizeOpts.value }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-text/text-view.js
var WidgetTextViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        align: options.align
      }, {
        default() {
          return h("div", {
            style: {
              fontSize: options.fontSize,
              fontWeight: options.bold ? "bold" : ""
            }
          }, widget.title);
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-row/row-data.js
var import_xe_utils105 = __toESM(require_xe_utils());
var getWidgetRowConfig = (params) => {
  const { $formDesign } = params;
  const defaultColSize = 2;
  return {
    title: handleGetFormDesignWidgetName,
    group: "layout",
    icon: "vxe-icon-row-col",
    options: {
      colSize: defaultColSize,
      colSpan: "12,12"
    },
    children: $formDesign ? import_xe_utils105.default.range(0, defaultColSize).map(() => {
      return $formDesign.createEmptyWidget();
    }) : []
  };
};

// node_modules/vxe-pc-ui/es/row/src/row.js
var import_xe_utils106 = __toESM(require_xe_utils());
var row_default = defineComponent({
  name: "VxeRow",
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => getConfig().row.wrap
    },
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().row.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils106.default.uniqueId();
    useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeRowStyle = computed(() => {
      const { gutter, vertical } = props;
      const style = {};
      if (gutter) {
        let [lrGutter, tbGutter] = import_xe_utils106.default.isArray(gutter) ? gutter : [gutter];
        if (vertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const offsetSize = import_xe_utils106.default.isNumber(lrGutter) ? toCssUnit(-(lrGutter / 2)) : `calc(${toCssUnit(lrGutter)} / 2 * -1)`;
          style.marginLeft = offsetSize;
          style.marginRight = offsetSize;
        }
        if (tbGutter) {
          const offsetSize = import_xe_utils106.default.isNumber(tbGutter) ? toCssUnit(-(tbGutter / 2)) : `calc(${toCssUnit(tbGutter)} / 2 * -1)`;
          style.marginTop = offsetSize;
          style.marginBottom = offsetSize;
        }
      }
      return style;
    });
    const computeMaps = {};
    const $xeRow = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (evnt) => {
      dispatchEvent2("click", {}, evnt);
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $row: $xeRow }, params));
    };
    const rowMethods = {
      dispatchEvent: dispatchEvent2
    };
    const rowPrivateMethods = {};
    Object.assign($xeRow, rowMethods, rowPrivateMethods);
    const renderVN = () => {
      const { vertical, wrap } = props;
      const rowStyle = computeRowStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-row", {
          "is--vertical": vertical,
          "is--wrap": wrap
        }],
        style: rowStyle,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : []);
    };
    provide("$xeRow", $xeRow);
    $xeRow.renderVN = renderVN;
    return $xeRow;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-row/row-form.js
var import_xe_utils107 = __toESM(require_xe_utils());
var WidgetRowFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { computeKebabCaseName } = useWidgetName(props);
    const spanOptions = ref([
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col2"),
        value: 2,
        list: [
          { value: "12,12", spans: [12, 12] },
          { value: "8,16", spans: [8, 16] },
          { value: "16,8", spans: [16, 8] },
          { value: "6,18", spans: [6, 18] },
          { value: "18,6", spans: [18, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col3"),
        value: 3,
        list: [
          { value: "8,8,8", spans: [8, 8, 8] },
          { value: "6,6,12", spans: [6, 6, 12] },
          { value: "12,6,6", spans: [12, 6, 6] },
          { value: "6,12,6", spans: [6, 12, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col4"),
        value: 4,
        list: [
          { value: "6,6,6,6", spans: [6, 6, 6, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col6"),
        value: 6,
        list: [
          { value: "4,4,4,4,4,4", spans: [4, 4, 4, 4, 4, 4] }
        ]
      }
    ]);
    const labelMaps = {
      18: "3/4",
      16: "2/3",
      12: "1/2",
      8: "1/3",
      6: "1/4",
      4: "1/6"
    };
    const computeSelectSpanItem = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      return spanOptions.value.find((item) => item.value === options.colSize);
    });
    const changeColSpan = (item) => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { reactData: formDesignReactData } = $xeFormDesign;
      const { widgetObjList } = formDesignReactData;
      const oldChildList = widget.children.filter((item2) => item2.name);
      const overList = oldChildList.slice(options.colSize);
      if (overList.length) {
        const rest = import_xe_utils107.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          const { items, index: index2 } = rest;
          if (index2 >= items.length - 1) {
            items.push(...overList);
          } else {
            items.splice(index2 + 1, 0, ...overList);
          }
        }
      }
      options.colSpan = item.value;
      widget.children = import_xe_utils107.default.range(0, options.colSize).map((num, index2) => {
        return oldChildList[index2] || $xeFormDesign.createEmptyWidget();
      });
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.rowProp.colSize"),
              field: "colSize",
              itemRender: { name: "VxeRadioGroup", options: spanOptions.value, props: { type: "button" } }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.rowProp.layout")
            }, {
              default() {
                const selectSpanItem = computeSelectSpanItem.value;
                if (selectSpanItem) {
                  return selectSpanItem.list.map((item, rIndex) => {
                    return h(row_default, {
                      key: rIndex,
                      class: [`vxe-form-design--widget-${kebabCaseName}-form-row`, {
                        "is--active": item.value === widget.options.colSpan
                      }],
                      onClick() {
                        changeColSpan(item);
                      }
                    }, {
                      default() {
                        return item.spans.map((span, sIndex) => {
                          return h(col_default, {
                            key: `${rIndex}${sIndex}`,
                            class: `vxe-form-design--widget-${kebabCaseName}-form-col`,
                            span
                          }, {
                            default() {
                              return h("div", {}, `${labelMaps[span]}`);
                            }
                          });
                        });
                      }
                    });
                  });
                }
                return [];
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-row/row-view.js
var import_xe_utils108 = __toESM(require_xe_utils());
var ViewColItemComponent = defineComponent({
  name: "ViewColItem",
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    span: Number,
    colItemIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const handleDragstartColItemEvent = (evnt) => {
      evnt.stopPropagation();
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetId = divEl.getAttribute("data-widget-id") || "";
      const dragWidget = $xeFormDesign.getWidgetById(widgetId);
      if (dataTransfer) {
        dataTransfer.setData("text/plain", widgetId);
      }
      formDesignReactData.sortWidget = dragWidget;
      formDesignReactData.dragWidget = null;
    };
    const sortDragenterColItemEvent = (evnt) => {
      const { parentWidget, colItemIndex } = props;
      const { widgetObjList, sortWidget } = formDesignReactData;
      const targetWidget = parentWidget.children[colItemIndex];
      const formDesignInternalData = $xeFormDesign.internalData;
      evnt.stopPropagation();
      if (sortWidget && parentWidget && sortWidget.id !== parentWidget.id) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        if (!hasFormDesignLayoutType(targetWidget)) {
          const currRest = import_xe_utils108.default.findTree(widgetObjList, (item) => item && item.id === sortWidget.id, { children: "children" });
          if (currRest) {
            const { item, index: index2, items, parent } = currRest;
            if (parentWidget.children.length !== parentWidget.options.colSize) {
              parentWidget.children = import_xe_utils108.default.range(0, parentWidget.options.colSize).map((index3) => {
                return parentWidget.children[index3] || $xeFormDesign.createEmptyWidget();
              });
            }
            if (parent && parent.id === parentWidget.id) {
              parentWidget.children[colItemIndex] = item;
              parentWidget.children[index2] = targetWidget;
            } else {
              if (targetWidget && targetWidget.name) {
                return;
              }
              parentWidget.children[colItemIndex] = item;
              items.splice(index2, 1);
            }
            evnt.preventDefault();
            formDesignInternalData.lastDragTime = Date.now();
            $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
          }
        }
      }
    };
    return () => {
      const { widget, span } = props;
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      return h(form_item_default, {
        span,
        padding: false
      }, {
        default() {
          const name = widget ? widget.name : "";
          const compConf = renderer.get(name) || {};
          const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
          const renderOpts = widget || { name };
          const params = { widget, readonly: false, disabled: false, isEditMode: true, isViewMode: false, $formDesign: $xeFormDesign, $formView: null };
          const isActive = activeWidget && widget && activeWidget.id === widget.id;
          const isEmptyWidget = !renderWidgetDesignView;
          return h("div", {
            class: "vxe-form-design--widget-row-view",
            "data-widget-id": widget.id,
            draggable: !isEmptyWidget,
            onDragstart: handleDragstartColItemEvent,
            onDragenter: sortDragenterColItemEvent,
            onClick(evnt) {
              if (widget) {
                $xeFormDesign.handleClickWidget(evnt, widget);
              }
            }
          }, [
            h("div", {
              class: ["vxe-form-design--widget-row-view-item-inner", {
                "is--empty": isEmptyWidget,
                "is--active": isActive,
                "is--sort": sortWidget && widget && sortWidget.id === widget.id,
                "is--drag": dragWidget && widget && dragWidget.id === widget.id
              }]
            }, [
              renderWidgetDesignView ? h("div", {
                class: "vxe-form-design--widget-row-view-item-wrapper"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-row-view-item-box vxe-form--item-row"
                }, getSlotVNs2(renderWidgetDesignView(renderOpts, params))),
                isActive ? h("div", {
                  class: "vxe-form-design--preview-item-operate"
                }, [
                  h(button_default, {
                    icon: getIcon().FORM_DESIGN_WIDGET_COPY,
                    status: "primary",
                    size: "mini",
                    circle: true,
                    onClick(params2) {
                      $xeFormDesign.handleCopyWidget(params2.$event, widget);
                    }
                  }),
                  h(button_default, {
                    icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
                    status: "danger",
                    size: "mini",
                    circle: true,
                    onClick(params2) {
                      $xeFormDesign.handleRemoveWidget(params2.$event, widget);
                    }
                  })
                ]) : createCommentVNode()
              ]) : h("div", {
                class: "vxe-form-design--widget-row-view-empty"
              }, "")
            ])
          ]);
        }
      });
    };
  }
});
var WidgetRowEditComponent = defineComponent({
  name: "WidgetRowEdit",
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const computedColObjList = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { colSpan } = options;
      const colList = colSpan ? `${colSpan}`.split(",") : [];
      const rest = colList.map((span) => Number(span));
      return rest;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      return h(form_group_default, {
        field: widget.field
      }, {
        default() {
          const colObjList = computedColObjList.value;
          return colObjList.map((span, colItemIndex) => {
            return h(ViewColItemComponent, {
              key: colItemIndex,
              parentWidget: widget,
              widget: widget.children[colItemIndex],
              span,
              colItemIndex
            });
          });
        }
      });
    };
  }
});
var WidgetRowViewComponent = defineComponent({
  name: "WidgetRowView",
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const $xeFormView = inject("$xeFormView", null);
    const computedColObjList = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { colSpan } = options;
      const colList = colSpan ? `${colSpan}`.split(",") : [];
      const rest = colList.map((span) => Number(span));
      return rest;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const colObjList = computedColObjList.value;
      return h(row_default, {}, {
        default() {
          return colObjList.map((span, colItemIndex) => {
            return h(col_default, {
              key: colItemIndex,
              class: "vxe-form--item-row",
              span
            }, {
              default() {
                const subWidget = widget.children[colItemIndex];
                if (subWidget) {
                  const { name } = subWidget;
                  const compConf = renderer.get(name) || {};
                  const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                  const renderOpts = subWidget;
                  const isEditMode = !!$xeFormDesign;
                  const params = { widget: subWidget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: $xeFormView };
                  if (renderWidgetDesignView) {
                    return getSlotVNs2(renderWidgetDesignView(renderOpts, params));
                  }
                }
                return createCommentVNode();
              }
            });
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-data.js
var getWidgetSubtableConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    group: "layout",
    icon: "vxe-icon-subtable",
    options: {
      showCheckbox: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-form.js
var WidgetSubtableFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.subtableProp.showCheckbox"),
              field: "showCheckbox"
            }, {
              default() {
                return h(switch_default, {
                  modelValue: options.showCheckbox,
                  "onUpdate:modelValue"(val) {
                    options.showCheckbox = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-view.js
var import_xe_utils109 = __toESM(require_xe_utils());
var ViewSubItemComponent = defineComponent({
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    childIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const $xeFormView = inject("$xeFormView", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const sortDragstartSubItemEvent = (evnt) => {
      evnt.stopPropagation();
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetId = divEl.getAttribute("data-widget-id") || "";
      const dragWidget = $xeFormDesign.getWidgetById(widgetId);
      if (dataTransfer) {
        dataTransfer.setData("text/plain", widgetId);
      }
      formDesignReactData.sortWidget = dragWidget;
      formDesignReactData.dragWidget = null;
    };
    const sortDragenterSubItemEvent = (evnt) => {
      const { parentWidget, childIndex } = props;
      const { widgetObjList, sortWidget } = formDesignReactData;
      const targetWidget = parentWidget.children[childIndex];
      const formDesignInternalData = $xeFormDesign.internalData;
      const { lastDragTime } = formDesignInternalData;
      evnt.stopPropagation();
      if (lastDragTime && lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget && targetWidget && parentWidget) {
        if (sortWidget.id === parentWidget.id) {
          return;
        }
        if (sortWidget.id === targetWidget.id) {
          return;
        }
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        if (targetWidget && !hasFormDesignLayoutType(targetWidget)) {
          const currRest = import_xe_utils109.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
          if (currRest) {
            const { item, index: index2, items, parent } = currRest;
            if (parent && parent.id === parentWidget.id) {
              parentWidget.children[childIndex] = item;
              parentWidget.children[index2] = targetWidget;
            } else {
              parentWidget.children.splice(childIndex, 0, item);
              items.splice(index2, 1);
            }
            formDesignInternalData.lastDragTime = Date.now();
            $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
          }
        }
      }
    };
    return () => {
      const { widget } = props;
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      const name = widget ? widget.name : "";
      const compConf = renderer.get(name) || {};
      const renderSubtableView = compConf.renderFormDesignWidgetSubtableEditView || compConf.renderFormDesignWidgetSubtableCellView || compConf.renderFormDesignWidgetSubtableDefaultView;
      const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
      const renderOpts = widget || { name };
      const isEditMode = !!$xeFormDesign;
      const defParams = { widget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: $xeFormView };
      const isActive = activeWidget && widget && activeWidget.id === widget.id;
      const subOpts = { name };
      const subParams = {
        $table: null,
        $grid: null,
        seq: "",
        column: {
          field: widget.field,
          title: widget.title
        },
        columnIndex: 0,
        $columnIndex: 0,
        _columnIndex: 0,
        rowid: "",
        row: {},
        rowIndex: 0,
        $rowIndex: 0,
        _rowIndex: 0,
        isEdit: false,
        isHidden: false,
        fixed: null,
        type: "",
        level: 1,
        visibleData: [],
        items: [],
        data: [],
        widget
      };
      return h("div", {
        class: ["vxe-form-design--widget-subtable-view-item", {
          "is--active": isActive,
          "is--sort": sortWidget && widget && sortWidget.id === widget.id,
          "is--drag": dragWidget && widget && dragWidget.id === widget.id
        }],
        draggable: true,
        "data-widget-id": widget.id,
        onDragstart: sortDragstartSubItemEvent,
        onDragenter: sortDragenterSubItemEvent,
        onClick(evnt) {
          if (widget) {
            $xeFormDesign.handleClickWidget(evnt, widget);
          }
        }
      }, [
        h("div", {
          class: "vxe-form-design--widget-subtable-view-item-wrapper"
        }, [
          h("div", {
            class: "vxe-form-design--widget-subtable-view-item-box vxe-form--item-row"
          }, renderSubtableView ? h(form_item_default, {
            class: ["vxe-form-design--widget-render-form-item"],
            title: widget.title,
            field: widget.field,
            itemRender: {}
          }, {
            default() {
              return getSlotVNs2(renderSubtableView(subOpts, subParams));
            }
          }) : renderWidgetDesignView ? getSlotVNs2(renderWidgetDesignView(renderOpts, defParams)) : []),
          isActive ? h("div", {
            class: "vxe-form-design--preview-item-operate"
          }, [
            h(button_default, {
              icon: getIcon().FORM_DESIGN_WIDGET_COPY,
              status: "primary",
              size: "mini",
              circle: true,
              onClick(params) {
                $xeFormDesign.handleCopyWidget(params.$event, widget);
              }
            }),
            h(button_default, {
              icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
              status: "danger",
              size: "mini",
              circle: true,
              onClick(params) {
                $xeFormDesign.handleRemoveWidget(params.$event, widget);
              }
            })
          ]) : createCommentVNode()
        ])
      ]);
    };
  }
});
var WidgetSubtableEditComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const handleDragoverWrapperEvent = (evnt) => {
      const { sortWidget, widgetObjList } = formDesignReactData;
      const { renderParams } = props;
      const { widget } = renderParams;
      evnt.stopPropagation();
      if (!sortWidget || !widget || widget.id === sortWidget.id) {
        return;
      }
      if (hasFormDesignLayoutType(sortWidget)) {
        if (VxeUI.modal) {
          VxeUI.modal.message({
            content: getI18n("vxe.formDesign.widgetProp.subtableProp.errSubDrag"),
            status: "error",
            id: "errSubDrag"
          });
        }
        return;
      }
      if (widget.name && !widget.children.some((item) => item.id === sortWidget.id)) {
        const rest = import_xe_utils109.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (rest) {
          const { item, index: index2, items } = rest;
          formDesignReactData.sortWidget = null;
          formDesignReactData.activeWidget = item;
          widget.children.push(item);
          items.splice(index2, 1);
          formDesignReactData.sortWidget = item;
        }
      }
    };
    const handleDragenterWrapperEvent = (evnt) => {
      evnt.stopPropagation();
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { title, children, options } = widget;
      const { showCheckbox } = options;
      return h(form_item_default, {
        title,
        className: "vxe-form-design--widget-subtable-form-item"
      }, {
        default() {
          return h("div", {
            class: "vxe-form-design--widget-subtable-view",
            onDragenter: handleDragenterWrapperEvent,
            onDragover: handleDragoverWrapperEvent
          }, [
            h("div", {
              class: "vxe-form-design--widget-subtable-view-left"
            }, [
              showCheckbox ? h("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, [
                  h(checkbox_default)
                ]),
                h("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, [
                  h(checkbox_default)
                ])
              ]) : createCommentVNode(),
              h("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, getI18n("vxe.formDesign.widgetProp.subtableProp.seqTitle")),
                h("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, "1")
              ])
            ]),
            h("div", {
              class: "vxe-form-design--widget-subtable-view-right"
            }, [
              h("div", {
                class: "vxe-form-design--widget-subtable-view-wrapper"
              }, [
                h(TransitionGroup, {
                  class: "vxe-form-design--widget-subtable-view-list",
                  tag: "div",
                  name: "vxe-form-design--widget-subtable-view-list"
                }, {
                  default: () => {
                    return children ? children.map((childWidget, childIndex) => {
                      return h(ViewSubItemComponent, {
                        key: childWidget.id,
                        parentWidget: widget,
                        widget: childWidget,
                        childIndex
                      });
                    }) : [];
                  }
                }),
                h("div", {
                  key: "empty",
                  class: "vxe-form-design--widget-subtable-view-empty"
                }, getI18n("vxe.formDesign.widgetProp.subtableProp.colPlace"))
              ])
            ])
          ]);
        }
      });
    };
  }
});
var WidgetSubtableViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const refGrid = ref();
    const defaultDataList = ref([
      {}
    ]);
    const computeFormReadonly = computed(() => {
      if ($xeFormView) {
        return $xeFormView.props.readonly;
      }
      return false;
    });
    const computeSubtableColumns = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { children, options } = widget;
      const formReadonly = computeFormReadonly.value;
      const columns = [];
      if (options.showCheckbox) {
        columns.push({
          type: "checkbox",
          width: 60,
          fixed: "left"
        });
      }
      columns.push({
        type: "seq",
        width: 60,
        fixed: "left"
      });
      if (children) {
        children.forEach((childWidget) => {
          const { name } = childWidget;
          const compConf = renderer.get(name) || {};
          const parseSubtableColumn = compConf.parseFormDesignWidgetSubtableColumn;
          let colConf = {
            field: childWidget.field,
            title: childWidget.title
          };
          if (parseSubtableColumn) {
            colConf = Object.assign(colConf, parseSubtableColumn({
              $formView: $xeFormView,
              name: childWidget.name,
              widget: childWidget,
              readonly: !!formReadonly
            }));
          } else {
            if (formReadonly) {
              colConf.cellRender = {
                name: childWidget.name,
                props: childWidget.options
              };
            } else {
              colConf.editRender = {
                name: childWidget.name,
                props: childWidget.options
              };
            }
          }
          const renderSubtableDefaultView = compConf.renderFormDesignWidgetSubtableDefaultView;
          const renderSubtableCellView = compConf.renderFormDesignWidgetSubtableCellView || renderSubtableDefaultView;
          const renderSubtableEditView = compConf.renderFormDesignWidgetSubtableEditView;
          const colSlots = {};
          if (renderSubtableDefaultView || renderSubtableCellView) {
            colSlots.default = (slotParams) => {
              const { isEdit, column } = slotParams;
              const { editRender, cellRender } = column;
              const params = Object.assign({ widget: childWidget }, slotParams);
              if (isEdit && editRender) {
                if (renderSubtableCellView) {
                  return getSlotVNs2(renderSubtableCellView(editRender, params));
                }
              }
              if (renderSubtableDefaultView) {
                return getSlotVNs2(renderSubtableDefaultView(cellRender || {}, params));
              }
              return [];
            };
          }
          if (renderSubtableEditView) {
            colSlots.edit = (slotParams) => {
              const { column } = slotParams;
              const { editRender } = column;
              const params = Object.assign({ widget: childWidget }, slotParams);
              return getSlotVNs2(renderSubtableEditView(editRender, params));
            };
          }
          colConf.slots = colSlots;
          columns.push(colConf);
        });
      }
      if (!formReadonly) {
        columns.push({
          field: "action",
          title: "",
          fixed: "right",
          width: 80,
          slots: {
            default({ row }) {
              return h(button_default, {
                mode: "text",
                icon: "vxe-icon-delete",
                status: "error",
                onClick() {
                  removeSubRow(row);
                }
              });
            }
          }
        });
      }
      return columns;
    });
    const computeGridOptions = computed(() => {
      const { renderParams } = props;
      const { widget, isEditMode } = renderParams;
      const subtableColumns = computeSubtableColumns.value;
      const formReadonly = computeFormReadonly.value;
      const gridConf = {
        border: true,
        showOverflow: true,
        height: 300,
        columnConfig: {
          resizable: true,
          minWidth: 140
        },
        rowConfig: {
          keyField: "_id"
        },
        data: isEditMode ? defaultDataList.value : $xeFormView ? $xeFormView.getItemValue(widget) : null,
        columns: subtableColumns,
        toolbarConfig: {
          zoom: true,
          custom: false,
          slots: {
            buttons: "toolbarButtons"
          }
        }
      };
      if (!formReadonly) {
        gridConf.keepSource = true;
        gridConf.editConfig = {
          mode: "row",
          trigger: "click",
          showStatus: true
        };
      }
      return gridConf;
    });
    const getSubRecord = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const record = {
        _id: Date.now()
      };
      import_xe_utils109.default.each(widget.children, (childWidget) => {
        record[childWidget.field] = null;
      });
      return record;
    };
    const addSubRowEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        let list = $xeFormView.getItemValue(widget);
        if (!import_xe_utils109.default.isArray(list)) {
          list = [];
        }
        const newRow = getSubRecord();
        list.unshift(newRow);
        $xeFormView.setItemValue(widget, list.slice(0)).then(() => {
          return nextTick().then(() => {
            const $grid = refGrid.value;
            if ($grid) {
              $grid.setEditRow(newRow);
            }
          });
        });
      }
    };
    const removeSubRow = (row) => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const list = $xeFormView.getItemValue(widget);
        if (list) {
          $xeFormView.setItemValue(widget, list.filter((item) => item._id !== row._id));
        }
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      const gridOptions = computeGridOptions.value;
      const formReadonly = computeFormReadonly.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        span: 24
      }, {
        default() {
          return VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign(Object.assign({}, gridOptions), { ref: refGrid }), {
            toolbarButtons() {
              return formReadonly ? [] : [
                h(button_default, {
                  content: "",
                  icon: "vxe-icon-add",
                  status: "primary",
                  onClick: addSubRowEvent
                })
              ];
            }
          }) : createCommentVNode();
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-input/input-data.js
var getWidgetInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-input",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-input/input-form.js
var WidgetInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-input/input-view.js
var WidgetInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h("input", {
            class: "vxe-default-input",
            type: "text",
            placeholder: options.placeholder || getI18n("vxe.base.pleaseInput"),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-data.js
var getWidgetTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-textarea",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-form.js
var WidgetTextareaFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-view.js
var WidgetTextareaViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h("textarea", {
            class: "vxe-default-textarea",
            placeholder: options.placeholder || getI18n("vxe.base.pleaseInput"),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-select/select-data.js
var import_xe_utils110 = __toESM(require_xe_utils());
var getWidgetSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-select",
    query: true,
    options: {
      options: import_xe_utils110.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-select/select-form.js
var WidgetSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: true
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-select/select-view.js
var WidgetSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    const renderOptions = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget.options;
      return options ? options.map((group) => {
        if (group.options) {
          return h("optgroup", {
            label: group.value
          }, group.options.map((item) => {
            return h("option", {
              value: item.value
            }, item.value);
          }));
        }
        return h("option", {}, group.value);
      }) : [];
    };
    return () => {
      const { renderParams } = props;
      const { widget, isViewMode } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h("select", {
            class: "vxe-default-select",
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent
          }, isViewMode ? renderOptions() : []);
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-data.js
var getWidgetVxeInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-input",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-form.js
var WidgetVxeInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-view.js
var WidgetVxeInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(input_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-data.js
var getWidgetVxeNumberInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-number",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-form.js
var WidgetVxeNumberInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/number-input/src/number-input.js
var import_xe_utils111 = __toESM(require_xe_utils());
var number_input_default = defineComponent({
  name: "VxeNumberInput",
  props: {
    modelValue: [String, Number],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "number"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().numberInput.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().numberInput.size || getConfig().size
    },
    multiple: Boolean,
    // numberintegerfloat
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().numberInput.exponential
    },
    showCurrency: {
      type: Boolean,
      default: () => getConfig().numberInput.showCurrency
    },
    currencySymbol: {
      type: String,
      default: () => getConfig().numberInput.currencySymbol
    },
    // numberintegerfloat
    controls: {
      type: Boolean,
      default: () => getConfig().numberInput.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: null
    },
    prefixIcon: String,
    suffixIcon: String,
    // 
    maxlength: [String, Number],
    // 
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils111.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isFocus: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const internalData = {
      // dnTimeout: undefined,
      // isUM: undefined
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeNumberInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let numberInputMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeDigitsValue = computed(() => {
      const { type, digits } = props;
      let defDigits = digits;
      if (defDigits === null) {
        defDigits = getConfig().numberInput.digits;
        if (defDigits === null) {
          if (type === "amount") {
            defDigits = 2;
          }
        }
      }
      return import_xe_utils111.default.toInteger(defDigits) || 1;
    });
    const computeDecimalsType = computed(() => {
      const { type } = props;
      return type === "float" || type === "amount";
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils111.default.toInteger(step) || 1;
      } else if (decimalsType) {
        return import_xe_utils111.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils111.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInputReadonly = computed(() => {
      const { multiple } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().numberInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      return import_xe_utils111.default.toNumber(maxLength || maxlength) || 16;
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      return type === "integer" ? import_xe_utils111.default.toInteger(handleNumber(inputValue)) : import_xe_utils111.default.toNumber(handleNumber(inputValue));
    });
    const computeNumLabel = computed(() => {
      const { type, showCurrency, currencySymbol } = props;
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      if (type === "amount") {
        const amountLabel = import_xe_utils111.default.commafy(import_xe_utils111.default.toNumber(inputValue), { digits: digitsValue });
        if (showCurrency) {
          return `${currencySymbol || getI18n("vxe.numberInput.currencySymbol") || ""}${amountLabel}`;
        }
        return amountLabel;
      }
      return import_xe_utils111.default.toString(inputValue);
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && min !== null) {
        return numValue <= import_xe_utils111.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && max !== null) {
        return numValue >= import_xe_utils111.default.toNumber(max);
      }
      return false;
    });
    const handleNumberString = (val) => {
      if (import_xe_utils111.default.eqNull(val)) {
        return "";
      }
      return `${val}`;
    };
    const getNumberValue = (val) => {
      const { exponential } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      const restVal = decimalsType ? toFloatValueFixed(val, digitsValue) : handleNumberString(val);
      if (exponential && (val === restVal || handleNumberString(val).toLowerCase() === import_xe_utils111.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      numberInputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (val, inputValue, evnt) => {
      const value = eqEmptyValue2(val) ? null : Number(val);
      const isChange = value !== props.modelValue;
      internalData.isUM = true;
      if (isChange) {
        emit("update:modelValue", value);
      }
      if (reactData.inputValue !== inputValue) {
        nextTick(() => {
          reactData.inputValue = inputValue || "";
        });
      }
      numberInputMethods.dispatchEvent("input", { value }, evnt);
      if (isChange) {
        numberInputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (inputValue, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue === "" || import_xe_utils111.default.eqNull(inputValue) ? null : import_xe_utils111.default.toNumber(inputValue);
      reactData.inputValue = inputValue;
      if (inpImmediate) {
        handleChange(value, inputValue, evnt);
      } else {
        numberInputMethods.dispatchEvent("input", { value }, evnt);
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent3(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isFocus = true;
      reactData.isActivated = true;
      triggerEvent3(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        numberInputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange(null, "", evnt);
      numberInputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        numberInputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const updateModel = (val) => {
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (decimalsType) {
        if (val) {
          let textValue = "";
          if (val) {
            textValue = toFloatValueFixed(val, digitsValue);
          }
          if (textValue !== inputValue) {
            reactData.inputValue = textValue;
          }
        }
      }
    };
    const initValue = () => {
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (decimalsType) {
        if (inputValue) {
          let textValue = "";
          let validValue = null;
          if (inputValue) {
            textValue = toFloatValueFixed(inputValue, digitsValue);
            validValue = Number(textValue);
          }
          if (inputValue !== validValue) {
            handleChange(validValue, textValue, { type: "init" });
          }
        }
      }
    };
    const validMaxNum = (num) => {
      return props.max === null || import_xe_utils111.default.toNumber(num) <= import_xe_utils111.default.toNumber(props.max);
    };
    const validMinNum = (num) => {
      return props.min === null || import_xe_utils111.default.toNumber(num) >= import_xe_utils111.default.toNumber(props.min);
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue } = reactData;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (eqEmptyValue2(inputValue)) {
          let inpNumVal = null;
          let inpValue = inputValue;
          if (min || min === 0) {
            inpNumVal = import_xe_utils111.default.toNumber(min);
            inpValue = `${inpNumVal}`;
          }
          handleChange(inpNumVal, `${inpValue || ""}`, { type: "check" });
          return;
        }
        if (inputValue || (min || max)) {
          let inpNumVal = type === "integer" ? import_xe_utils111.default.toInteger(handleNumber(inputValue)) : import_xe_utils111.default.toNumber(handleNumber(inputValue));
          if (!validMinNum(inpNumVal)) {
            inpNumVal = min;
          } else if (!validMaxNum(inpNumVal)) {
            inpNumVal = max;
          }
          if (exponential) {
            const inpStringVal = handleNumberString(inputValue).toLowerCase();
            if (inpStringVal === import_xe_utils111.default.toNumber(inpNumVal).toExponential()) {
              inpNumVal = inpStringVal;
            }
          }
          const inpValue = getNumberValue(inpNumVal);
          handleChange(eqEmptyValue2(inpValue) ? null : Number(inpValue), inpValue, { type: "check" });
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? Number(inputValue) : null;
      if (!inpImmediate) {
        handleChange(value, handleNumberString(inputValue), evnt);
      }
      afterCheckValue();
      reactData.isFocus = false;
      reactData.isActivated = false;
      numberInputMethods.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils111.default.toInteger(handleNumber(inputValue)) : import_xe_utils111.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils111.default.add(numValue, stepValue) : import_xe_utils111.default.subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberNextEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      numberStopDown();
      if (!isDisabled && !formReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent("next-number", { value: reactData.inputValue }, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      internalData.dnTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      numberStopDown();
      if (!isDisabled && !formReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent("prev-number", { value: reactData.inputValue }, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { exponential, controls } = props;
      const isCtrlKey = evnt.ctrlKey;
      const isShiftKey = evnt.shiftKey;
      const isAltKey = evnt.altKey;
      const keyCode = evnt.keyCode;
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (!isCtrlKey && !isShiftKey && !isAltKey && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
        evnt.preventDefault();
      }
      if (isEsc) {
        afterCheckValue();
      } else if (isUpArrow || isDwArrow) {
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent3(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const numberStopDown = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
      }
    };
    const numberDownPrevEvent = (evnt) => {
      internalData.dnTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass2(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        internalData.dnTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      if (props.controls) {
        if (reactData.isActivated) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
        }
      }
      triggerEvent3(evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { isActivated } = reactData;
      const el2 = refElem.value;
      const panelElem = refInputPanel.value;
      const isDisabled = computeIsDisabled.value;
      const inpImmediate = computeInpImmediate.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          if (!inpImmediate) {
            const { inputValue } = reactData;
            const value = inputValue ? Number(inputValue) : null;
            handleChange(value, handleNumberString(inputValue), evnt);
          }
          afterCheckValue();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        }
        if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated } = reactData;
      if (isActivated) {
        afterCheckValue();
      }
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("div", {
        class: "vxe-input--control-icon"
      }, [
        h("div", {
          class: "vxe-input--number-icon"
        }, [
          h("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": isDisabledAddNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_PREV_NUM
            })
          ]),
          h("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": isDisabledSubtractNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_NEXT_NUM
            })
          ])
        ])
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-number-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-number-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-number-input--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils111.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-number-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-number-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]);
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      if (controls) {
        return renderNumberIcon();
      }
      return createCommentVNode();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $numberInput: $xeNumberInput }, params));
    };
    numberInputMethods = {
      dispatchEvent: dispatchEvent2,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeNumberInput, numberInputMethods);
    const renderVN = () => {
      const { className, controls, type, align, name, autocomplete, autoComplete } = props;
      const { inputValue, isFocus, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const numLabel = computeNumLabel.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-number-input--readonly", `type--${type}`, className]
        }, numLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-number-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils111.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-number-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-number-input--inner",
            value: !isFocus && type === "amount" ? numLabel : inputValue,
            name,
            type: "text",
            placeholder: inpPlaceholder,
            maxlength: inpMaxLength,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode()
      ]);
    };
    $xeNumberInput.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      if (!internalData.isUM) {
        updateModel(val);
      }
      internalData.isUM = false;
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue
      });
      initValue();
    });
    onMounted(() => {
      globalEvents.on($xeNumberInput, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeNumberInput, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeNumberInput, "blur", handleGlobalBlurEvent);
    });
    onBeforeUnmount(() => {
      reactData.isFocus = false;
      numberStopDown();
      afterCheckValue();
      globalEvents.off($xeNumberInput, "mousedown");
      globalEvents.off($xeNumberInput, "keydown");
      globalEvents.off($xeNumberInput, "blur");
    });
    initValue();
    return $xeNumberInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-view.js
var WidgetVxeNumberInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(number_input_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-data.js
var getWidgetVxeDatePickerConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-calendar",
    options: {
      placeholder: "",
      defaultValue: {
        type: "",
        value: ""
      }
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-form.js
var WidgetVxeDatePickerFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            // renderDefaultValueFormItem(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-view.js
var WidgetVxeDatePickerViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(date_picker_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-data.js
var getWidgetVxeTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-textarea",
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-form.js
var WidgetVxeTextareaFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-view.js
var WidgetVxeTextareaViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(textarea_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            resize: "node",
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-data.js
var getWidgetVxeSwitchConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-switch",
    query: true,
    options: {}
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-form.js
var WidgetVxeSwitchFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-view.js
var WidgetVxeSwitchViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(switch_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-data.js
var import_xe_utils112 = __toESM(require_xe_utils());
var getWidgetVxeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-select",
    query: true,
    options: {
      placeholder: "",
      options: import_xe_utils112.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      }),
      multiple: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-form.js
var WidgetVxeSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            renderDataSourceFormItem(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-view.js
var WidgetVxeSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget, isViewMode } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(select_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || getI18n("vxe.base.pleaseSelect"),
            options: isViewMode ? options.options : [],
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-data.js
var import_xe_utils113 = __toESM(require_xe_utils());
var getWidgetVxeTreeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-tree-select",
    query: true,
    options: {
      placeholder: "",
      options: import_xe_utils113.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      }),
      multiple: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-form.js
var WidgetVxeTreeSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
var import_xe_utils115 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/tree/src/tree.js
var import_xe_utils114 = __toESM(require_xe_utils());
function getNodeUniqueId() {
  return import_xe_utils114.default.uniqueId("node_");
}
var tree_default = defineComponent({
  name: "VxeTree",
  props: {
    data: Array,
    height: [String, Number],
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => getConfig().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => getConfig().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => getConfig().tree.valueField
    },
    keyField: {
      type: String,
      default: () => getConfig().tree.keyField
    },
    parentField: {
      type: String,
      default: () => getConfig().tree.parentField
    },
    titleField: {
      type: String,
      default: () => getConfig().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => getConfig().tree.hasChildField
    },
    // mapChildrenField: {
    //   type: String as PropType<VxeTreePropTypes.MapChildrenField>,
    //   default: () => getConfig().tree.mapChildrenField
    // },
    transform: Boolean,
    // 
    isCurrent: Boolean,
    // 
    isHover: Boolean,
    showLine: {
      type: Boolean,
      default: () => getConfig().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => getConfig().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => getConfig().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => getConfig().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => getConfig().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => getConfig().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    iconOpen: {
      type: String,
      default: () => getConfig().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => getConfig().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => getConfig().tree.iconLoaded
    },
    size: {
      type: String,
      default: () => getConfig().tree.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "update:checkNodeKey",
    "update:checkNodeKeys",
    "node-click",
    "node-dblclick",
    "current-change",
    "radio-change",
    "checkbox-change",
    "load-success",
    "load-error"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils114.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      currentNode: null,
      nodeMaps: {},
      selectRadioKey: props.checkNodeKey,
      treeList: [],
      treeExpandedMaps: {},
      treeExpandLazyLoadedMaps: {},
      selectCheckboxMaps: {},
      indeterminateCheckboxMaps: {}
    });
    const internalData = {};
    const refMaps = {
      refElem
    };
    const computeTitleField = computed(() => {
      return props.titleField || "title";
    });
    const computeKeyField = computed(() => {
      return props.keyField || "id";
    });
    const computeValueField = computed(() => {
      const keyField = computeKeyField.value;
      return props.valueField || keyField;
    });
    const computeParentField = computed(() => {
      return props.parentField || "parentId";
    });
    const computeChildrenField = computed(() => {
      return props.childrenField || "children";
    });
    const computeHasChildField = computed(() => {
      return props.hasChildField || "hasChild";
    });
    const computeIsRowCurrent = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isCurrent } = nodeOpts;
      if (import_xe_utils114.default.isBoolean(isCurrent)) {
        return isCurrent;
      }
      return props.isCurrent;
    });
    const computeIsRowHover = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isHover } = nodeOpts;
      if (import_xe_utils114.default.isBoolean(isHover)) {
        return isHover;
      }
      return props.isHover;
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.checkboxConfig, props.checkboxConfig);
    });
    const computeNodeOpts = computed(() => {
      return Object.assign({}, getConfig().tree.nodeConfig, props.nodeConfig);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig().tree.loadingConfig, props.loadingConfig);
    });
    const computeTreeStyle = computed(() => {
      const { height, minHeight } = props;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (minHeight) {
        stys.minHeight = toCssUnit(minHeight);
      }
      return stys;
    });
    const computeMaps = {
      computeRadioOpts,
      computeCheckboxOpts,
      computeNodeOpts
    };
    const $xeTree = {
      xID,
      props,
      context,
      internalData,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getNodeId = (node) => {
      const valueField = computeValueField.value;
      const nodeid = import_xe_utils114.default.get(node, valueField);
      return import_xe_utils114.default.eqNull(nodeid) ? "" : encodeURIComponent(nodeid);
    };
    const isExpandByNode = (node) => {
      const { treeExpandedMaps } = reactData;
      const nodeid = getNodeId(node);
      return !!treeExpandedMaps[nodeid];
    };
    const isCheckedByRadioNodeId = (nodeid) => {
      const { selectRadioKey } = reactData;
      return selectRadioKey === nodeid;
    };
    const isCheckedByRadioNode = (node) => {
      return isCheckedByRadioNodeId(getNodeId(node));
    };
    const isCheckedByCheckboxNodeId = (nodeid) => {
      const { selectCheckboxMaps } = reactData;
      return !!selectCheckboxMaps[nodeid];
    };
    const isCheckedByCheckboxNode = (node) => {
      return isCheckedByCheckboxNodeId(getNodeId(node));
    };
    const isIndeterminateByCheckboxNodeid = (nodeid) => {
      const { indeterminateCheckboxMaps } = reactData;
      return !!indeterminateCheckboxMaps[nodeid];
    };
    const isIndeterminateByCheckboxNode = (node) => {
      return isIndeterminateByCheckboxNodeid(getNodeId(node));
    };
    const emitCheckboxMode = (value) => {
      emit("update:checkNodeKeys", value);
    };
    const emitRadioMode = (value) => {
      emit("update:checkNodeKey", value);
    };
    const setRadioNode = (node) => {
      if (node) {
        reactData.selectRadioKey = getNodeId(node);
      }
      return nextTick();
    };
    const setCheckboxNode = (nodeList, checked) => {
      if (nodeList) {
        if (!import_xe_utils114.default.isArray(nodeList)) {
          nodeList = [nodeList];
        }
        handleCheckedCheckboxNode(nodeList.map((item) => getNodeId(item)), checked);
      }
      return nextTick();
    };
    const setCheckboxByNodeId = (nodeIds, checked) => {
      if (nodeIds) {
        if (!import_xe_utils114.default.isArray(nodeIds)) {
          nodeIds = [nodeIds];
        }
        handleCheckedCheckboxNode(nodeIds, checked);
      }
      return nextTick();
    };
    const handleCheckedCheckboxNode = (nodeIds, checked) => {
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      nodeIds.forEach((key) => {
        if (checked) {
          selectKeyMaps[key] = true;
        } else if (selectKeyMaps[key]) {
          delete selectKeyMaps[key];
        }
      });
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const updateCheckboxChecked = (nodeIds) => {
      const selectKeyMaps = {};
      if (nodeIds) {
        nodeIds.forEach((key) => {
          selectKeyMaps[key] = true;
        });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const handleSetExpand = (nodeid, expanded, expandedMaps) => {
      if (expanded) {
        if (!expandedMaps[nodeid]) {
          expandedMaps[nodeid] = true;
        }
      } else {
        if (expandedMaps[nodeid]) {
          delete expandedMaps[nodeid];
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tree: $xeTree }, params));
    };
    const createNode = (records) => {
      const valueField = computeValueField.value;
      return Promise.resolve(records.map((obj) => {
        const item = Object.assign({}, obj);
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils114.default.set(item, valueField, nodeid);
        }
        return item;
      }));
    };
    const treeMethods = {
      dispatchEvent: dispatchEvent2,
      clearCurrentNode() {
        reactData.currentNode = null;
        return nextTick();
      },
      getCurrentNodeId() {
        const { currentNode } = reactData;
        if (currentNode) {
          return getNodeId(currentNode);
        }
        return null;
      },
      getCurrentNode() {
        const { currentNode, nodeMaps } = reactData;
        if (currentNode) {
          const nodeItem = nodeMaps[currentNode];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setCurrentNodeId(nodeKey) {
        const { nodeMaps } = reactData;
        const nodeItem = nodeMaps[nodeKey];
        reactData.currentNode = nodeItem ? nodeItem.item : null;
        return nextTick();
      },
      setCurrentNode(node) {
        reactData.currentNode = node;
        return nextTick();
      },
      clearRadioNode() {
        reactData.selectRadioKey = null;
        return nextTick();
      },
      getRadioNodeId() {
        return reactData.selectRadioKey || null;
      },
      getRadioNode() {
        const { selectRadioKey, nodeMaps } = reactData;
        if (selectRadioKey) {
          const nodeItem = nodeMaps[selectRadioKey];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setRadioNodeId(nodeKey) {
        reactData.selectRadioKey = nodeKey;
        return nextTick();
      },
      setRadioNode,
      setCheckboxNode,
      setCheckboxByNodeId,
      getCheckboxNodeIds() {
        const { selectCheckboxMaps } = reactData;
        return Object.keys(selectCheckboxMaps);
      },
      getCheckboxNodes() {
        const { nodeMaps, selectCheckboxMaps } = reactData;
        const list = [];
        import_xe_utils114.default.each(selectCheckboxMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      clearCheckboxNode() {
        reactData.selectCheckboxMaps = {};
        return nextTick();
      },
      setAllCheckboxNode(checked) {
        const selectMaps = {};
        const childrenField = computeChildrenField.value;
        if (checked) {
          import_xe_utils114.default.eachTree(reactData.treeList, (node) => {
            const nodeid = getNodeId(node);
            selectMaps[nodeid] = true;
          }, { children: childrenField });
        }
        reactData.selectCheckboxMaps = selectMaps;
        return nextTick();
      },
      clearExpandNode() {
        return treeMethods.clearAllExpandNode();
      },
      clearAllExpandNode() {
        import_xe_utils114.default.each(reactData.nodeMaps, (nodeItem) => {
          nodeItem.treeLoaded = false;
        });
        reactData.treeExpandedMaps = {};
        return nextTick();
      },
      setExpandByNodeId(nodeids, expanded) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodeids) {
          if (!import_xe_utils114.default.isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach((nodeid) => {
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      getExpandNodeIds() {
        const { treeExpandedMaps } = reactData;
        return Object.keys(treeExpandedMaps);
      },
      getExpandNodes() {
        const { nodeMaps, treeExpandedMaps } = reactData;
        const list = [];
        import_xe_utils114.default.each(treeExpandedMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      setExpandNode(nodes, expanded) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodes) {
          if (!import_xe_utils114.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      toggleExpandByNodeId(nodeids) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodeids) {
          if (!import_xe_utils114.default.isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach((nodeid) => {
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      toggleExpandNode(nodes) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodes) {
          if (!import_xe_utils114.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      setAllExpandNode(expanded) {
        const expandedMaps = {};
        const childrenField = computeChildrenField.value;
        if (expanded) {
          import_xe_utils114.default.eachTree(reactData.treeList, (node) => {
            const childList = import_xe_utils114.default.get(node, childrenField);
            const hasChild = childList && childList.length;
            if (hasChild) {
              const nodeid = getNodeId(node);
              expandedMaps[nodeid] = true;
            }
          }, { children: childrenField });
        }
        reactData.treeExpandedMaps = expandedMaps;
        return nextTick();
      },
      reloadExpandNode(node) {
        const { lazy } = props;
        if (lazy) {
          treeMethods.clearExpandLoaded(node);
          return handleAsyncTreeExpandChilds(node);
        }
        return nextTick();
      },
      clearExpandLoaded(node) {
        const { lazy } = props;
        const { nodeMaps } = reactData;
        if (lazy) {
          const nodeItem = nodeMaps[getNodeId(node)];
          if (nodeItem) {
            nodeItem.treeLoaded = false;
          }
        }
        return nextTick();
      },
      /**
       * 
       */
      loadChildrenNode(node, childRecords) {
        const { lazy, transform: transform2 } = props;
        const { nodeMaps } = reactData;
        if (!lazy) {
          return Promise.resolve([]);
        }
        const childrenField = computeChildrenField.value;
        const parentNodeItem = nodeMaps[getNodeId(node)];
        const parentLevel = parentNodeItem ? parentNodeItem.level : 0;
        const parentNodes = parentNodeItem ? parentNodeItem.nodes : [];
        return createNode(childRecords).then((nodeList) => {
          import_xe_utils114.default.eachTree(nodeList, (childRow, index2, items, path, parent, nodes) => {
            const itemNodeId = getNodeId(childRow);
            nodeMaps[itemNodeId] = {
              item: node,
              itemIndex: -1,
              items,
              parent: parent || parentNodeItem.item,
              nodes: parentNodes.concat(nodes),
              level: parentLevel + nodes.length,
              lineCount: 0,
              treeLoaded: false
            };
          }, { children: childrenField });
          node[childrenField] = nodeList;
          if (transform2) {
            node[childrenField] = nodeList;
          }
          updateNodeLine(node);
          return nodeList;
        });
      },
      isExpandByNode,
      isCheckedByRadioNodeId,
      isCheckedByRadioNode,
      isCheckedByCheckboxNodeId,
      isIndeterminateByCheckboxNode,
      isCheckedByCheckboxNode
    };
    const cacheNodeMap = () => {
      const { treeList } = reactData;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const keyMaps = {};
      import_xe_utils114.default.eachTree(treeList, (item, itemIndex, items, path, parent, nodes) => {
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils114.default.set(item, valueField, nodeid);
        }
        keyMaps[nodeid] = {
          item,
          itemIndex,
          items,
          parent,
          nodes,
          level: nodes.length,
          lineCount: 0,
          treeLoaded: false
        };
      }, { children: childrenField });
      reactData.nodeMaps = keyMaps;
    };
    const updateData = (list) => {
      const { transform: transform2 } = props;
      const keyField = computeKeyField.value;
      const parentField = computeParentField.value;
      const childrenField = computeChildrenField.value;
      if (transform2) {
        reactData.treeList = import_xe_utils114.default.toArrayTree(list, { key: keyField, parentKey: parentField, mapChildren: childrenField });
      } else {
        reactData.treeList = list ? list.slice(0) : [];
      }
      cacheNodeMap();
    };
    const handleCountLine = (item, isRoot, nodeItem) => {
      const { treeExpandedMaps } = reactData;
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(item);
      nodeItem.lineCount++;
      if (treeExpandedMaps[nodeid]) {
        import_xe_utils114.default.arrayEach(item[childrenField], (childItem, childIndex, childList) => {
          if (!isRoot || childIndex < childList.length - 1) {
            handleCountLine(childItem, false, nodeItem);
          }
        });
      }
    };
    const updateNodeLine = (node) => {
      const { nodeMaps } = reactData;
      if (node) {
        const nodeid = getNodeId(node);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          import_xe_utils114.default.lastArrayEach(nodeItem.nodes, (childItem) => {
            const nodeid2 = getNodeId(childItem);
            const nodeItem2 = nodeMaps[nodeid2];
            if (nodeItem2) {
              nodeItem2.lineCount = 0;
              handleCountLine(childItem, true, nodeItem2);
            }
          });
        }
      }
    };
    const handleNodeClickEvent = (evnt, node) => {
      const { showRadio, showCheckbox, trigger } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const isRowCurrent = computeIsRowCurrent.value;
      let triggerCurrent = false;
      let triggerRadio = false;
      let triggerCheckbox = false;
      let triggerExpand = false;
      if (isRowCurrent) {
        triggerCurrent = true;
        changeCurrentEvent(evnt, node);
      } else if (reactData.currentNode) {
        reactData.currentNode = null;
      }
      if (trigger === "node") {
        triggerExpand = true;
        toggleExpandEvent(evnt, node);
      }
      if (showRadio && radioOpts.trigger === "node") {
        triggerRadio = true;
        changeRadioEvent(evnt, node);
      }
      if (showCheckbox && checkboxOpts.trigger === "node") {
        triggerCheckbox = true;
        changeCheckboxEvent(evnt, node);
      }
      dispatchEvent2("node-click", { node, triggerCurrent, triggerRadio, triggerCheckbox, triggerExpand }, evnt);
    };
    const handleNodeDblclickEvent = (evnt, node) => {
      dispatchEvent2("node-dblclick", { node }, evnt);
    };
    const handleAsyncTreeExpandChilds = (node) => {
      const checkboxOpts = computeCheckboxOpts.value;
      const { loadMethod } = props;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const tempExpandLazyLoadedMaps = Object.assign({}, reactData.treeExpandLazyLoadedMaps);
          const { nodeMaps } = reactData;
          const nodeid = getNodeId(node);
          const nodeItem = nodeMaps[nodeid];
          tempExpandLazyLoadedMaps[nodeid] = true;
          reactData.treeExpandLazyLoadedMaps = tempExpandLazyLoadedMaps;
          Promise.resolve(loadMethod({ $tree: $xeTree, node })).then((childRecords) => {
            const { treeExpandLazyLoadedMaps } = reactData;
            nodeItem.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            if (!import_xe_utils114.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return treeMethods.loadChildrenNode(node, childRecords).then((childRows) => {
                const tempExpandedMaps = Object.assign({}, reactData.treeExpandedMaps);
                if (childRows.length && !tempExpandedMaps[nodeid]) {
                  tempExpandedMaps[nodeid] = true;
                }
                reactData.treeExpandedMaps = tempExpandedMaps;
                if (!checkStrictly && treeMethods.isCheckedByCheckboxNodeId(nodeid)) {
                  handleCheckedCheckboxNode(childRows.map((item) => getNodeId(item)), true);
                }
                updateNodeLine(node);
                dispatchEvent2("load-success", { node, data: childRecords }, new Event("load-success"));
                return nextTick();
              });
            } else {
              updateNodeLine(node);
              dispatchEvent2("load-success", { node, data: childRecords }, new Event("load-success"));
            }
          }).catch((e16) => {
            const { treeExpandLazyLoadedMaps } = reactData;
            nodeItem.treeLoaded = false;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            updateNodeLine(node);
            dispatchEvent2("load-error", { node, data: e16 }, new Event("load-error"));
          }).finally(() => {
            return nextTick();
          });
        } else {
          resolve();
        }
      });
    };
    const handleBaseTreeExpand = (nodeList, expanded) => {
      const { lazy, accordion, toggleMethod } = props;
      const { nodeMaps, treeExpandLazyLoadedMaps } = reactData;
      const tempExpandedMaps = Object.assign({}, reactData.treeExpandedMaps);
      const childrenField = computeChildrenField.value;
      const hasChildField = computeHasChildField.value;
      const result = [];
      let validNodes = toggleMethod ? nodeList.filter((node) => toggleMethod({ $tree: $xeTree, expanded, node })) : nodeList;
      if (accordion) {
        validNodes = validNodes.length ? [validNodes[validNodes.length - 1]] : [];
        const nodeid = getNodeId(validNodes[0]);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items.forEach((item) => {
            const itemNodeId = getNodeId(item);
            if (tempExpandedMaps[itemNodeId]) {
              delete tempExpandedMaps[itemNodeId];
            }
          });
        }
      }
      const expandNodes = [];
      if (expanded) {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (!tempExpandedMaps[itemNodeId]) {
            const nodeItem = nodeMaps[itemNodeId];
            const isLoad = lazy && item[hasChildField] && !nodeItem.treeLoaded && !treeExpandLazyLoadedMaps[itemNodeId];
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(item));
            } else {
              if (item[childrenField] && item[childrenField].length) {
                tempExpandedMaps[itemNodeId] = true;
                expandNodes.push(item);
              }
            }
          }
        });
      } else {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (tempExpandedMaps[itemNodeId]) {
            delete tempExpandedMaps[itemNodeId];
            expandNodes.push(item);
          }
        });
      }
      reactData.treeExpandedMaps = tempExpandedMaps;
      expandNodes.forEach(updateNodeLine);
      return Promise.all(result);
    };
    const toggleExpandEvent = (evnt, node) => {
      const { lazy } = props;
      const { treeExpandedMaps, treeExpandLazyLoadedMaps } = reactData;
      const nodeid = getNodeId(node);
      const expanded = !treeExpandedMaps[nodeid];
      evnt.stopPropagation();
      if (!lazy || !treeExpandLazyLoadedMaps[nodeid]) {
        handleBaseTreeExpand([node], expanded);
      }
    };
    const handleNodeCheckboxStatus = (node, selectKeyMaps, indeterminateMaps) => {
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils114.default.get(node, childrenField);
      const nodeid = getNodeId(node);
      if (childList && childList.length) {
        let checkSome = false;
        let checkSize = 0;
        childList.forEach((childNode) => {
          const childNodeid = getNodeId(childNode);
          const isChecked = selectKeyMaps[childNodeid];
          if (isChecked || indeterminateMaps[childNodeid]) {
            if (isChecked) {
              checkSize++;
            }
            checkSome = true;
          }
        });
        const checkAll = checkSize === childList.length;
        if (checkAll) {
          if (!selectKeyMaps[nodeid]) {
            selectKeyMaps[nodeid] = true;
          }
          if (indeterminateMaps[nodeid]) {
            delete indeterminateMaps[nodeid];
          }
        } else {
          if (selectKeyMaps[nodeid]) {
            delete selectKeyMaps[nodeid];
          }
          indeterminateMaps[nodeid] = checkSome;
        }
      } else {
        if (indeterminateMaps[nodeid]) {
          delete indeterminateMaps[nodeid];
        }
      }
    };
    const updateCheckboxStatus = () => {
      const { treeList } = reactData;
      const childrenField = computeChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly } = checkboxOpts;
      if (!checkStrictly) {
        const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
        const indeterminateMaps = {};
        import_xe_utils114.default.eachTree(treeList, (node, index2, items, path, parent, nodes) => {
          const childList = import_xe_utils114.default.get(node, childrenField);
          if (!childList || !childList.length) {
            handleNodeCheckboxStatus(node, selectKeyMaps, indeterminateMaps);
          }
          if (index2 === items.length - 1) {
            for (let len = nodes.length - 2; len >= 0; len--) {
              const parentItem = nodes[len];
              handleNodeCheckboxStatus(parentItem, selectKeyMaps, indeterminateMaps);
            }
          }
        });
        reactData.selectCheckboxMaps = selectKeyMaps;
        reactData.indeterminateCheckboxMaps = indeterminateMaps;
      }
    };
    const changeCheckboxEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly, checkMethod } = checkboxOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(node);
      let isChecked = false;
      if (selectKeyMaps[nodeid]) {
        delete selectKeyMaps[nodeid];
      } else {
        isChecked = true;
        selectKeyMaps[nodeid] = isChecked;
      }
      if (!checkStrictly) {
        import_xe_utils114.default.eachTree(import_xe_utils114.default.get(node, childrenField), (childNode) => {
          const childNodeid = getNodeId(childNode);
          if (isChecked) {
            if (!selectKeyMaps[childNodeid]) {
              selectKeyMaps[childNodeid] = true;
            }
          } else {
            if (selectKeyMaps[childNodeid]) {
              delete selectKeyMaps[childNodeid];
            }
          }
        }, { children: childrenField });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
      updateCheckboxStatus();
      const value = Object.keys(reactData.selectCheckboxMaps);
      emitCheckboxMode(value);
      dispatchEvent2("checkbox-change", { node, value, checked: isChecked }, evnt);
    };
    const changeCurrentEvent = (evnt, node) => {
      evnt.preventDefault();
      const nodeOpts = computeNodeOpts.value;
      const { currentMethod, trigger } = nodeOpts;
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils114.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      let isDisabled = !!currentMethod;
      if (trigger === "child") {
        if (hasChild) {
          return;
        }
      } else if (trigger === "parent") {
        if (!hasChild) {
          return;
        }
      }
      if (currentMethod) {
        isDisabled = !currentMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      reactData.currentNode = node;
      dispatchEvent2("current-change", { node, checked: isChecked }, evnt);
    };
    const changeRadioEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      const value = getNodeId(node);
      reactData.selectRadioKey = value;
      emitRadioMode(value);
      dispatchEvent2("radio-change", { node, value, checked: isChecked }, evnt);
    };
    const treePrivateMethods = {};
    Object.assign($xeTree, treeMethods, treePrivateMethods);
    const renderRadio = (node, nodeid, isChecked) => {
      const { showRadio } = props;
      const radioOpts = computeRadioOpts.value;
      const { showIcon, checkMethod, visibleMethod } = radioOpts;
      const isVisible = !visibleMethod || visibleMethod({ node });
      let isDisabled = !!checkMethod;
      if (showRadio && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ node });
        }
        return h("div", {
          class: ["vxe-tree--radio-option", {
            "is--checked": isChecked,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeRadioEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
          })
        ]);
      }
      return createCommentVNode();
    };
    const renderCheckbox = (node, nodeid, isChecked) => {
      const { showCheckbox } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const { showIcon, checkMethod, visibleMethod } = checkboxOpts;
      const isIndeterminate = isIndeterminateByCheckboxNodeid(nodeid);
      const isVisible = !visibleMethod || visibleMethod({ node });
      let isDisabled = !!checkMethod;
      if (showCheckbox && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ node });
        }
        return h("div", {
          class: ["vxe-tree--checkbox-option", {
            "is--checked": isChecked,
            "is--indeterminate": isIndeterminate,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeCheckboxEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
          })
        ]);
      }
      return createCommentVNode();
    };
    const renderNode = (node) => {
      const { lazy, showRadio, showCheckbox, showLine, indent, iconOpen, iconClose, iconLoaded, showIcon } = props;
      const { nodeMaps, treeExpandedMaps, currentNode, selectRadioKey, treeExpandLazyLoadedMaps } = reactData;
      const childrenField = computeChildrenField.value;
      const titleField = computeTitleField.value;
      const hasChildField = computeHasChildField.value;
      const childList = import_xe_utils114.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const nodeid = getNodeId(node);
      const isExpand = treeExpandedMaps[nodeid];
      const nodeItem = nodeMaps[nodeid];
      const nodeValue = import_xe_utils114.default.get(node, titleField);
      const childVns = [];
      if (hasChild && treeExpandedMaps[nodeid]) {
        if (showLine) {
          childVns.push(h("div", {
            key: "line",
            class: "vxe-tree--node-child-line",
            style: {
              height: `calc(${nodeItem.lineCount} * var(--vxe-ui-tree-node-height) - var(--vxe-ui-tree-node-height) / 2)`,
              left: `${(nodeItem.level + 1) * (indent || 1)}px`
            }
          }));
        }
        childList.forEach((childItem) => {
          childVns.push(renderNode(childItem));
        });
      }
      let isRadioChecked = false;
      if (showRadio) {
        isRadioChecked = nodeid == selectRadioKey;
      }
      let isCheckboxChecked = false;
      if (showCheckbox) {
        isCheckboxChecked = isCheckedByCheckboxNodeId(nodeid);
      }
      let hasLazyChilds = false;
      let isLazyLoading = false;
      let isLazyLoaded = false;
      if (lazy) {
        isLazyLoading = !!treeExpandLazyLoadedMaps[nodeid];
        hasLazyChilds = node[hasChildField];
        isLazyLoaded = !!nodeItem.treeLoaded;
      }
      return h("div", {
        class: ["vxe-tree--node-wrapper", `node--level-${nodeItem.level}`],
        nodeid
      }, [
        h("div", {
          class: ["vxe-tree--node-item", {
            "is--current": currentNode && nodeid === getNodeId(currentNode),
            "is-radio--checked": isRadioChecked,
            "is-checkbox--checked": isCheckboxChecked
          }],
          style: {
            paddingLeft: `${(nodeItem.level - 1) * (indent || 1)}px`
          },
          onClick(evnt) {
            handleNodeClickEvent(evnt, node);
          },
          onDblclick(evnt) {
            handleNodeDblclickEvent(evnt, node);
          }
        }, [
          showIcon || showLine ? h("div", {
            class: "vxe-tree--node-item-switcher"
          }, showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [
            h("div", {
              class: "vxe-tree--node-item-icon",
              onClick(evnt) {
                toggleExpandEvent(evnt, node);
              }
            }, [
              h("i", {
                class: isLazyLoading ? iconLoaded || getIcon().TREE_NODE_LOADED : isExpand ? iconOpen || getIcon().TREE_NODE_OPEN : iconClose || getIcon().TREE_NODE_CLOSE
              })
            ])
          ] : []) : createCommentVNode(),
          renderRadio(node, nodeid, isRadioChecked),
          renderCheckbox(node, nodeid, isCheckboxChecked),
          h("div", {
            class: "vxe-tree--node-item-inner"
          }, [
            h("div", {
              class: "vxe-tree--node-item-title"
            }, titleSlot ? getSlotVNs2(titleSlot({ node })) : `${nodeValue}`),
            extraSlot ? h("div", {
              class: "vxe-tree--node-item-extra"
            }, getSlotVNs2(extraSlot({ node }))) : createCommentVNode()
          ])
        ]),
        hasChild && treeExpandedMaps[nodeid] ? h("div", {
          class: "vxe-tree--node-child-wrapper"
        }, childVns) : createCommentVNode()
      ]);
    };
    const renderNodeList = () => {
      const { treeList } = reactData;
      return h("div", {
        class: "vxe-tree--node-list-wrapper"
      }, treeList.map((node) => renderNode(node)));
    };
    const renderVN = () => {
      const { loading: loading2, trigger, showLine } = props;
      const vSize = computeSize.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeStyle = computeTreeStyle.value;
      const loadingOpts = computeLoadingOpts.value;
      const isRowHover = computeIsRowHover.value;
      const loadingSlot = slots.loading;
      return h("div", {
        ref: refElem,
        class: ["vxe-tree", {
          [`size--${vSize}`]: vSize,
          "show--line": showLine,
          "checkbox--highlight": checkboxOpts.highlight,
          "radio--highlight": radioOpts.highlight,
          "node--hover": isRowHover,
          "node--trigger": trigger === "node",
          "is--loading": loading2
        }],
        style: treeStyle
      }, [
        renderNodeList(),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-tree--loading",
          modelValue: loading2,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => loadingSlot({ $tree: $xeTree })
        } : {})
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : 0, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      updateData(props.data || []);
    });
    watch(() => props.checkNodeKey, (val) => {
      reactData.selectRadioKey = val;
    });
    const checkboxFlag = ref(0);
    watch(() => props.checkNodeKeys ? props.checkNodeKeys.length : 0, () => {
      checkboxFlag.value++;
    });
    watch(() => props.checkNodeKeys, () => {
      checkboxFlag.value++;
    });
    watch(checkboxFlag, () => {
      updateCheckboxChecked(props.checkNodeKeys || []);
    });
    onUnmounted(() => {
      reactData.treeList = [];
      reactData.treeExpandedMaps = {};
      reactData.nodeMaps = {};
    });
    updateData(props.data || []);
    updateCheckboxChecked(props.checkNodeKeys || []);
    $xeTree.renderVN = renderVN;
    return $xeTree;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
function getOptUniqueId2() {
  return import_xe_utils115.default.uniqueId("node_");
}
var tree_select_default = defineComponent({
  name: "VxeTreeSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils115.default.eqNull(getConfig().treeSelect.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().treeSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    remote: Boolean,
    remoteMethod: Function,
    popupConfig: Object,
    treeConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "node-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils115.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refTreeWrapper = ref();
    const refOptionPanel = ref();
    const reactData = reactive({
      initialized: false,
      fullOptionList: [],
      fullNodeMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils115.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePopupOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.popupConfig, props.popupConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.treeConfig, props.treeConfig, { data: void 0 });
    });
    const computeTreeNodeOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({ isHover: true }, treeOpts.nodeConfig);
    });
    const computeTreeCheckboxOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showCheckbox
      }, treeOpts.checkboxConfig, {
        trigger: "node"
      });
    });
    const computeTreeRadioOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showRadio
      }, treeOpts.radioConfig, {
        trigger: "node"
      });
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeNodeKeyField = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return treeOpts.keyField || "id";
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeChildrenField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.children || "children";
    });
    const computeParentField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.parent || "parentField";
    });
    const computeHasChildField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.hasChild || "hasChild";
    });
    const computeSelectLabel = computed(() => {
      const { modelValue } = props;
      const { fullNodeMaps } = reactData;
      const labelField = computeLabelField.value;
      return (import_xe_utils115.default.isArray(modelValue) ? modelValue : [modelValue]).map((val) => {
        const cacheItem = fullNodeMaps[val];
        return cacheItem ? cacheItem.item[labelField] : val;
      }).join(", ");
    });
    const computePopupWrapperStyle = computed(() => {
      const popupOpts = computePopupOpts.value;
      const { height, width } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
        stys.maxHeight = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTreeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $treeSelect: $xeTreeSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const treeSelectMethods = {
      dispatchEvent: dispatchEvent2
    };
    const getNodeid = (option2) => {
      const nodeKeyField = computeNodeKeyField.value;
      const nodeid = option2[nodeKeyField];
      return nodeid ? encodeURIComponent(nodeid) : "";
    };
    const cacheDataMap = () => {
      const { options } = props;
      const nodeKeyField = computeNodeKeyField.value;
      const childrenField = computeChildrenField.value;
      const valueField = computeValueField.value;
      const nodeMaps = {};
      const keyMaps = {};
      import_xe_utils115.default.eachTree(options, (item, index2, items, path, parent, nodes) => {
        let nodeid = getNodeid(item);
        if (!nodeid) {
          nodeid = getOptUniqueId2();
        }
        if (keyMaps[nodeid]) {
          errLog2("vxe.error.repeatKey", [nodeKeyField, nodeid]);
        }
        keyMaps[nodeid] = true;
        const value = item[valueField];
        if (nodeMaps[value]) {
          errLog2("vxe.error.repeatKey", [valueField, value]);
        }
        nodeMaps[value] = { item, index: index2, items, parent, nodes };
      }, { children: childrenField });
      reactData.fullOptionList = options || [];
      reactData.fullNodeMaps = nodeMaps;
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el2) {
          const targetHeight = el2.offsetHeight;
          const targetWidth = el2.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(el2);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2 } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        clearTimeout(internalData.hpTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      const { fullNodeMaps } = reactData;
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        const cacheItem = fullNodeMaps[selectValue];
        dispatchEvent2("change", { value: selectValue, option: cacheItem ? cacheItem.item : null }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent2("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent2("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent2("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent2("blur", {}, evnt);
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const nodeClickEvent = (params) => {
      const { $event } = params;
      dispatchEvent2("node-click", params, $event);
    };
    const radioChangeEvent = (params) => {
      const { value, $event } = params;
      changeEvent($event, value);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { value, $event } = params;
      changeEvent($event, value);
    };
    const loadSuccessEvent = () => {
      cacheDataMap();
    };
    const treeSelectPrivateMethods = {};
    Object.assign($xeTreeSelect, treeSelectMethods, treeSelectPrivateMethods);
    const renderVN = () => {
      const { className, modelValue, multiple, options, loading: loading2 } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      const popupOpts = computePopupOpts.value;
      const popupClassName = popupOpts.className || props.popupClassName;
      const treeOpts = computeTreeOpts.value;
      const treeNodeOpts = computeTreeNodeOpts.value;
      const treeCheckboxOpts = computeTreeCheckboxOpts.value;
      const treeRadioOpts = computeTreeRadioOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const parentField = computeParentField.value;
      const hasChildField = computeHasChildField.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-tree-select--readonly", className]
        }, [
          h("span", {
            class: "vxe-tree-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tree-select", className ? import_xe_utils115.default.isFunction(className) ? className({ $treeSelect: $xeTreeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: loading2 ? getI18n("vxe.select.loadingText") : props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TREE_SELECT_LOADED : visiblePanel ? getIcon().TREE_SELECT_OPEN : getIcon().TREE_SELECT_CLOSE,
          modelValue: loading2 ? "" : selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-tree-select--panel", popupClassName ? import_xe_utils115.default.isFunction(popupClassName) ? popupClassName({ $treeSelect: $xeTreeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-tree-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-tree-select--panel-header"
              }, headerSlot({})) : renderEmptyElement($xeTreeSelect),
              h("div", {
                class: "vxe-tree-select--panel-body"
              }, [
                h("div", {
                  ref: refTreeWrapper,
                  class: "vxe-tree-select-tree--wrapper",
                  style: popupWrapperStyle
                }, [
                  h(tree_default, {
                    class: "vxe-tree-select--tree",
                    data: options,
                    indent: treeOpts.indent,
                    showRadio: !multiple,
                    radioConfig: treeRadioOpts,
                    checkNodeKey: multiple ? null : modelValue,
                    showCheckbox: !!multiple,
                    checkNodeKeys: multiple ? modelValue : null,
                    checkboxConfig: treeCheckboxOpts,
                    titleField: labelField,
                    valueField,
                    keyField: nodeKeyField,
                    childrenField: treeOpts.childrenField || childrenField,
                    parentField: treeOpts.parentField || parentField,
                    hasChildField: treeOpts.hasChildField || hasChildField,
                    accordion: treeOpts.accordion,
                    nodeConfig: treeNodeOpts,
                    lazy: treeOpts.lazy,
                    loadMethod: treeOpts.loadMethod,
                    toggleMethod: treeOpts.toggleMethod,
                    transform: treeOpts.transform,
                    trigger: treeOpts.trigger,
                    showIcon: treeOpts.showIcon,
                    showLine: treeOpts.showLine,
                    iconOpen: treeOpts.iconOpen,
                    iconLoaded: treeOpts.iconLoaded,
                    iconClose: treeOpts.iconClose,
                    onNodeClick: nodeClickEvent,
                    onRadioChange: radioChangeEvent,
                    onCheckboxChange: checkboxChangeEvent,
                    onLoadSuccess: loadSuccessEvent
                  })
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-tree-select--panel-footer"
              }, footerSlot({})) : renderEmptyElement($xeTreeSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => props.options, () => {
      cacheDataMap();
    });
    cacheDataMap();
    onMounted(() => {
      globalEvents.on($xeTreeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTreeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTreeSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTreeSelect, "mousewheel");
      globalEvents.off($xeTreeSelect, "mousedown");
      globalEvents.off($xeTreeSelect, "blur");
    });
    provide("$xeTreeSelect", $xeTreeSelect);
    $xeTreeSelect.renderVN = renderVN;
    return $xeTreeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-view.js
var WidgetVxeTreeSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(tree_select_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || getI18n("vxe.base.pleaseSelect"),
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-data.js
var import_xe_utils116 = __toESM(require_xe_utils());
var getWidgetVxeRadioGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-radio-checked",
    options: {
      options: import_xe_utils116.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-form.js
var WidgetVxeRadioGroupFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-view.js
var WidgetVxeRadioGroupViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(group_default3, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-data.js
var import_xe_utils117 = __toESM(require_xe_utils());
var getWidgetVxeCheckboxGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-checkbox-checked",
    options: {
      options: import_xe_utils117.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-form.js
var WidgetVxeCheckboxGroupFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-view.js
var WidgetVxeCheckboxGroupViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(group_default2, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-data.js
function getLimitSizeOptions() {
  const sizeOpts = [
    { label: "", value: "" }
  ];
  const sizeList = [1, 2, 5, 10, 20, 50, 100, 200, 500];
  sizeList.forEach((num) => {
    sizeOpts.push({ label: `${num}M`, value: num });
  });
  return sizeOpts;
}
var getWidgetVxeUploadFileConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-file",
    options: {
      limitCount: "",
      limitSize: 100,
      multiple: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-form.js
var WidgetVxeUploadFileFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const limitSizeOptions = ref(getLimitSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.multiFile"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            options.multiple ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitFileCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: true } }
            }) : createCommentVNode(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitFileSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: limitSizeOptions.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/upload/src/upload.js
var import_xe_utils119 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/upload/src/util.js
var import_xe_utils118 = __toESM(require_xe_utils());
var fileForm = null;
var fileInput = null;
function parseFile2(file) {
  const name = file.name;
  const tIndex = import_xe_utils118.default.lastIndexOf(name, ".");
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return { filename, type };
}
var readLocalFile = (options) => {
  const opts = Object.assign({}, options);
  return new Promise((resolve, reject) => {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.name = "file";
      fileInput.type = "file";
    }
    if (!fileForm) {
      fileForm = document.createElement("form");
      fileForm.style.display = "none";
      fileForm.appendChild(fileInput);
      document.body.appendChild(fileForm);
    }
    const types = opts.types || [];
    const isAllType = !types.length || types.some((type) => type === "*");
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? "" : `.${types.join(", .")}`;
    fileInput.onchange = (evnt) => {
      const eventTarget = evnt.target;
      const files = Array.from(eventTarget.files || []);
      const file = files[0];
      let errType = "";
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const { type } = parseFile2(files[fIndex]);
          if (!import_xe_utils118.default.includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({ status: true, files, file });
      } else {
        if (opts.message !== false) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.error.notType", [errType]),
              status: "error"
            });
          }
        }
        const params = { status: false, files, file };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function getExportBlobByContent2(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
var saveLocalFile = (options) => {
  const opts = Object.assign({ type: "" }, options);
  const { filename, type, content } = opts;
  const name = type ? `${filename}.${type}` : `${filename}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent2(import_xe_utils118.default.toValueString(content), opts);
    const winNavigator = window.navigator;
    if (winNavigator.msSaveBlob) {
      winNavigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement("a");
      linkElem.target = "_blank";
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getI18n("vxe.error.notExp")));
};

// node_modules/vxe-pc-ui/es/upload/src/upload.js
var upload_default = defineComponent({
  name: "VxeUpload",
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => getConfig().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    mode: {
      type: String,
      default: () => getConfig().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => import_xe_utils119.default.clone(getConfig().upload.imageTypes, true)
    },
    imageConfig: {
      type: Object,
      default: () => import_xe_utils119.default.clone(getConfig().upload.imageConfig, true)
    },
    /**
     *  image-config 
     * @deprecated
     */
    imageStyle: {
      type: Object,
      default: () => import_xe_utils119.default.clone(getConfig().upload.imageStyle, true)
    },
    fileTypes: {
      type: Array,
      default: () => import_xe_utils119.default.clone(getConfig().upload.fileTypes, true)
    },
    dragSort: Boolean,
    dragToUpload: {
      type: Boolean,
      default: () => import_xe_utils119.default.clone(getConfig().upload.dragToUpload, true)
    },
    pasteToUpload: {
      type: Boolean,
      default: () => import_xe_utils119.default.clone(getConfig().upload.pasteToUpload, true)
    },
    keyField: String,
    singleMode: Boolean,
    urlMode: Boolean,
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => getConfig().upload.limitSize
    },
    limitCount: {
      type: [String, Number],
      default: () => getConfig().upload.limitCount
    },
    nameField: {
      type: String,
      default: () => getConfig().upload.nameField
    },
    typeField: {
      type: String,
      default: () => getConfig().upload.typeField
    },
    urlField: {
      type: String,
      default: () => getConfig().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => getConfig().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => getConfig().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => getConfig().upload.showProgress
    },
    progressText: {
      type: String,
      default: () => getConfig().upload.progressText
    },
    autoHiddenButton: {
      type: Boolean,
      default: () => getConfig().upload.autoHiddenButton
    },
    showUploadButton: {
      type: Boolean,
      default: () => getConfig().upload.showUploadButton
    },
    buttonText: {
      type: String,
      default: () => getConfig().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => getConfig().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => getConfig().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => getConfig().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => getConfig().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().upload.showPreview
    },
    tipText: String,
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    beforeRemoveMethod: Function,
    removeMethod: Function,
    beforeDownloadMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: {
      type: String,
      default: () => getConfig().upload.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "add",
    "remove",
    "remove-fail",
    "download",
    "download-fail",
    "upload-success",
    "upload-error",
    "sort-dragend"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils119.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refPopupElem = ref();
    const refDragLineElem = ref();
    const refModalDragLineElem = ref();
    const reactData = reactive({
      isDragUploadStatus: false,
      showMorePopup: false,
      isActivated: false,
      fileList: [],
      fileCacheMaps: {},
      isDragMove: false,
      dragIndex: -1,
      dragTipText: ""
    });
    const internalData = {
      imagePreviewTypes: ["jpg", "jpeg", "png", "gif"],
      prevDragIndex: -1
      // prevDragPos: ''
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeKeyField = computed(() => {
      return props.keyField || "_X_KEY";
    });
    const computeIsImage = computed(() => {
      return props.mode === "image";
    });
    const computeNameProp = computed(() => {
      return props.nameField || "name";
    });
    const computeTypeProp = computed(() => {
      return props.typeField || "type";
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeSizeProp = computed(() => {
      return props.sizeField || "size";
    });
    const computeLimitMaxSizeB = computed(() => {
      return import_xe_utils119.default.toNumber(props.limitSize) * 1024 * 1024;
    });
    const computeLimitMaxCount = computed(() => {
      return props.multiple ? import_xe_utils119.default.toNumber(props.limitCount) : 1;
    });
    const computeOverCount = computed(() => {
      const { multiple } = props;
      const { fileList } = reactData;
      const limitMaxCount = computeLimitMaxCount.value;
      if (multiple) {
        if (limitMaxCount) {
          return fileList.length >= limitMaxCount;
        }
        return true;
      }
      return fileList.length >= 1;
    });
    const computeLimitSizeUnit = computed(() => {
      const limitSize = import_xe_utils119.default.toNumber(props.limitSize);
      if (limitSize) {
        if (limitSize > 1048576) {
          return `${limitSize / 1048576}T`;
        }
        if (limitSize > 1024) {
          return `${limitSize / 1024}G`;
        }
        return `${limitSize}M`;
      }
      return "";
    });
    const computedDefHintText = computed(() => {
      const { limitSize, fileTypes, multiple, limitCount } = props;
      const tipText = props.tipText || props.hintText;
      const isImage = computeIsImage.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      if (import_xe_utils119.default.isString(tipText)) {
        return tipText;
      }
      const defHints = [];
      if (isImage) {
        if (multiple && limitCount) {
          defHints.push(getI18n("vxe.upload.imgCountHint", [limitCount]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push(getI18n("vxe.upload.imgSizeHint", [limitSizeUnit]));
        }
      } else {
        if (fileTypes && fileTypes.length) {
          defHints.push(getI18n("vxe.upload.fileTypeHint", [fileTypes.join("/")]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push(getI18n("vxe.upload.fileSizeHint", [limitSizeUnit]));
        }
        if (multiple && limitCount) {
          defHints.push(getI18n("vxe.upload.fileCountHint", [limitCount]));
        }
      }
      return defHints.join(getI18n("vxe.base.comma"));
    });
    const computeImageOpts = computed(() => {
      return Object.assign({}, props.imageConfig || props.imageStyle);
    });
    const computeImgStyle = computed(() => {
      const imageOpts = computeImageOpts.value;
      const { width, height } = imageOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMoreOpts = computed(() => {
      return Object.assign({ showMoreButton: true }, props.moreConfig);
    });
    const computeMaps = {};
    const $xeUpload = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getUniqueKey = () => {
      return import_xe_utils119.default.uniqueId();
    };
    const getFieldKey = (item) => {
      const keyField = computeKeyField.value;
      return item[keyField];
    };
    const updateFileList = () => {
      const { modelValue, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const fileList = modelValue ? (modelValue ? import_xe_utils119.default.isArray(modelValue) ? modelValue : [modelValue] : []).map((item) => {
        if (!item || import_xe_utils119.default.isString(item)) {
          const url = `${item || ""}`;
          const name2 = parseFileName(url);
          return {
            [nameProp]: name2,
            [typeProp]: parseFileType(name2),
            [urlProp]: url,
            [sizeProp]: 0,
            [keyField]: getUniqueKey()
          };
        }
        const name = item[nameProp] || "";
        item[nameProp] = name;
        item[typeProp] = item[typeProp] || parseFileType(name);
        item[urlProp] = item[urlProp] || "";
        item[sizeProp] = item[sizeProp] || 0;
        item[keyField] = item[keyField] || getUniqueKey();
        return item;
      }) : [];
      reactData.fileList = formReadonly || multiple ? fileList : fileList.slice(0, 1);
    };
    const parseFileName = (url) => {
      return decodeURIComponent(`${url || ""}`).split("/").pop() || "";
    };
    const parseFileType = (name) => {
      const index2 = name ? name.indexOf(".") : -1;
      if (index2 > -1) {
        return name.substring(index2 + 1, name.length).toLowerCase();
      }
      return "";
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $upload: $xeUpload }, params));
    };
    const handleChange = (value) => {
      const { singleMode, urlMode } = props;
      const urlProp = computeUrlProp.value;
      let restList = value ? value.slice(0) : [];
      if (urlMode) {
        restList = restList.map((item) => item[urlProp]);
      }
      emit("update:modelValue", singleMode ? restList[0] || null : restList);
    };
    const getThumbnailFileUrl = (item) => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().upload.getThumbnailUrlMethod;
      if (getThumbnailUrlFn) {
        return getThumbnailUrlFn({
          $upload: $xeUpload,
          option: item
        });
      }
      return getFileUrl(item);
    };
    const getFileUrl = (item) => {
      const getUrlFn = props.getUrlMethod || getConfig().upload.getUrlMethod;
      const urlProp = computeUrlProp.value;
      return getUrlFn ? getUrlFn({
        $upload: $xeUpload,
        option: item
      }) : item[urlProp];
    };
    const handleDefaultFilePreview = (item) => {
      const { imageTypes, showDownloadButton } = props;
      const typeProp = computeTypeProp.value;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const { imagePreviewTypes } = internalData;
      if (imagePreviewTypes.concat(imageTypes || []).some((type) => `${type}`.toLowerCase() === `${item[typeProp]}`.toLowerCase())) {
        if (VxeUI.previewImage) {
          VxeUI.previewImage({
            urlList: [getFileUrl(item)],
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? () => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: item
              });
            } : void 0
          });
        }
      }
    };
    const handlePreviewFileEvent = (evnt, item) => {
      const previewFn = props.previewMethod || getConfig().upload.previewMethod;
      if (props.showPreview) {
        if (previewFn) {
          previewFn({
            $upload: $xeUpload,
            option: item
          });
        } else {
          handleDefaultFilePreview(item);
        }
      }
    };
    const handlePreviewImageEvent = (evnt, item, index2) => {
      const { showDownloadButton } = props;
      const { fileList } = reactData;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      if (props.showPreview) {
        if (VxeUI.previewImage) {
          VxeUI.previewImage({
            urlList: fileList.map((item2) => getFileUrl(item2)),
            activeIndex: index2,
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? ({ index: index3 }) => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: fileList[index3]
              });
            } : void 0
          });
        }
      }
    };
    const handleUploadResult = (item, file) => {
      const { showErrorStatus } = props;
      const fileKey = getFieldKey(item);
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn) {
        return Promise.resolve(uploadFn({
          $upload: $xeUpload,
          file,
          option: item,
          updateProgress(percentNum) {
            const { fileCacheMaps } = reactData;
            const cacheItem = fileCacheMaps[getFieldKey(item)];
            if (cacheItem) {
              cacheItem.percent = Math.max(0, Math.min(99, import_xe_utils119.default.toNumber(percentNum)));
            }
          }
        })).then((res) => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.percent = 100;
          }
          Object.assign(item, res);
          dispatchEvent2("upload-success", { option: item, data: res }, null);
        }).catch((res) => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.status = "error";
          }
          if (showErrorStatus) {
            Object.assign(item, res);
          } else {
            reactData.fileList = reactData.fileList.filter((obj) => getFieldKey(obj) !== fileKey);
          }
          dispatchEvent2("upload-error", { option: item, data: res }, null);
        }).finally(() => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.loading = false;
          }
        });
      } else {
        const { fileCacheMaps } = reactData;
        const cacheItem = fileCacheMaps[fileKey];
        if (cacheItem) {
          cacheItem.loading = false;
        }
      }
      return Promise.resolve();
    };
    const handleReUpload = (item) => {
      const { uploadMethod, urlMode } = props;
      const { fileCacheMaps } = reactData;
      const fileKey = getFieldKey(item);
      const cacheItem = fileCacheMaps[fileKey];
      const uploadFn = uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && cacheItem) {
        const file = cacheItem.file;
        cacheItem.loading = true;
        cacheItem.status = "";
        cacheItem.percent = 0;
        handleUploadResult(item, file).then(() => {
          if (urlMode) {
            handleChange(reactData.fileList);
          }
        });
      }
    };
    const uploadFile = (files, evnt) => {
      const { multiple, urlMode } = props;
      const { fileList } = reactData;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const limitMaxSizeB = computeLimitMaxSizeB.value;
      const limitMaxCount = computeLimitMaxCount.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      let selectFiles = files;
      if (multiple && limitMaxCount) {
        if (fileList.length >= limitMaxCount) {
          if (VxeUI.modal) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              content: getI18n("vxe.upload.overCountErr", [limitMaxCount])
            });
          }
          return;
        }
        const overNum = selectFiles.length - (limitMaxCount - fileList.length);
        if (overNum > 0) {
          const overExtraList = selectFiles.slice(limitMaxCount - fileList.length);
          if (VxeUI.modal) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              slots: {
                default() {
                  return h("div", {
                    class: "vxe-upload--file-message-over-error"
                  }, [
                    h("div", {}, getI18n("vxe.upload.overCountExtraErr", [limitMaxCount, overNum])),
                    h("div", {
                      class: "vxe-upload--file-message-over-extra"
                    }, overExtraList.map((file, index2) => {
                      return h("div", {
                        key: index2,
                        class: "vxe-upload--file-message-over-extra-item"
                      }, file.name);
                    }))
                  ]);
                }
              }
            });
          }
        }
        selectFiles = selectFiles.slice(0, limitMaxCount - fileList.length);
      }
      if (limitMaxSizeB) {
        for (let i = 0; i < files.length; i++) {
          const file = files[0];
          if (file.size > limitMaxSizeB) {
            if (VxeUI.modal) {
              VxeUI.modal.notification({
                title: getI18n("vxe.modal.errTitle"),
                status: "error",
                content: getI18n("vxe.upload.overSizeErr", [limitSizeUnit])
              });
            }
            return;
          }
        }
      }
      const cacheMaps = Object.assign({}, reactData.fileCacheMaps);
      const newFileList = multiple ? fileList : [];
      const uploadPromiseRests = [];
      selectFiles.forEach((file) => {
        const { name } = file;
        const fileKey = getUniqueKey();
        const fileObj = {
          [nameProp]: name,
          [typeProp]: parseFileType(name),
          [sizeProp]: file.size,
          [urlProp]: "",
          [keyField]: fileKey
        };
        if (uploadFn) {
          cacheMaps[fileKey] = {
            file,
            loading: true,
            status: "",
            percent: 0
          };
        }
        const item = reactive(fileObj);
        if (uploadFn) {
          uploadPromiseRests.push(handleUploadResult(item, file));
        }
        newFileList.push(item);
        dispatchEvent2("add", { option: item }, evnt);
      });
      reactData.fileList = newFileList;
      reactData.fileCacheMaps = cacheMaps;
      Promise.all(urlMode ? uploadPromiseRests : []).then(() => {
        handleChange(newFileList);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, newFileList);
        }
      });
    };
    const handleChoose = (evnt) => {
      const { multiple, imageTypes, fileTypes } = props;
      const isDisabled = computeIsDisabled.value;
      const isImage = computeIsImage.value;
      if (isDisabled) {
        return Promise.resolve({
          status: false,
          files: [],
          file: null
        });
      }
      return readLocalFile({
        multiple,
        types: isImage ? imageTypes : fileTypes
      }).then((params) => {
        uploadFile(params.files, evnt);
        return params;
      });
    };
    const clickEvent = (evnt) => {
      handleChoose(evnt).catch(() => {
      });
    };
    const handleRemoveEvent = (evnt, item, index2) => {
      const { fileList } = reactData;
      fileList.splice(index2, 1);
      handleChange(fileList);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, fileList);
      }
      dispatchEvent2("remove", { option: item }, evnt);
    };
    const removeFileEvent = (evnt, item, index2) => {
      const beforeRemoveFn = props.beforeRemoveMethod || getConfig().upload.beforeRemoveMethod;
      const removeFn = props.removeMethod || getConfig().upload.removeMethod;
      Promise.resolve(beforeRemoveFn ? beforeRemoveFn({
        $upload: $xeUpload,
        option: item
      }) : true).then((status) => {
        if (status) {
          if (removeFn) {
            Promise.resolve(removeFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleRemoveEvent(evnt, item, index2);
            }).catch((e16) => e16);
          } else {
            handleRemoveEvent(evnt, item, index2);
          }
        } else {
          dispatchEvent2("remove-fail", { option: item }, evnt);
        }
      });
    };
    const handleDownloadEvent = (evnt, item) => {
      dispatchEvent2("download", { option: item }, evnt);
    };
    const downloadFileEvent = (evnt, item) => {
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || getConfig().upload.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $upload: $xeUpload,
        option: item
      }) : true).then((status) => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleDownloadEvent(evnt, item);
            }).catch((e16) => e16);
          } else {
            handleDownloadEvent(evnt, item);
          }
        } else {
          dispatchEvent2("download-fail", { option: item }, evnt);
        }
      });
    };
    const handleUploadDragleaveEvent = (evnt) => {
      const targetElem = evnt.currentTarget;
      const { clientX, clientY } = evnt;
      if (targetElem) {
        const { x: targetX, y: targetY, height: targetHeight, width: targetWidth } = targetElem.getBoundingClientRect();
        if (clientX < targetX || clientX > targetX + targetWidth || clientY < targetY || clientY > targetY + targetHeight) {
          reactData.isDragUploadStatus = false;
        }
      }
    };
    const handleUploadDragoverEvent = (evnt) => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const { items } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          reactData.isDragUploadStatus = true;
        }
      }
    };
    const uploadTransferFileEvent = (evnt, files) => {
      const { imageTypes } = props;
      const { imagePreviewTypes } = internalData;
      const isImage = computeIsImage.value;
      if (isImage) {
        const pasteImgTypes = imagePreviewTypes.concat(imageTypes && imageTypes.length ? imageTypes : []);
        files = files.filter((file) => {
          const fileType = `${file.type.split("/")[1] || ""}`.toLowerCase();
          if (pasteImgTypes.some((type) => `${type}`.toLowerCase() === fileType)) {
            return true;
          }
          return false;
        });
      }
      if (!files.length) {
        if (VxeUI.modal) {
          VxeUI.modal.notification({
            title: getI18n("vxe.modal.errTitle"),
            status: "error",
            content: getI18n("vxe.upload.uploadTypeErr")
          });
        }
        return;
      }
      uploadFile(files, evnt);
    };
    const handleUploadDropEvent = (evnt) => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const { items } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          const files = handleTransferFiles(items);
          if (files.length) {
            uploadTransferFileEvent(evnt, files);
          }
        }
      }
      reactData.isDragUploadStatus = false;
    };
    const handleTransferFiles = (items) => {
      const files = [];
      import_xe_utils119.default.arrayEach(items, (item) => {
        const file = item.getAsFile();
        if (file) {
          files.push(file);
        }
      });
      return files;
    };
    const handleMoreEvent = () => {
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      if (VxeUI.modal) {
        VxeUI.modal.open({
          title: formReadonly ? getI18n("vxe.upload.morePopup.readTitle") : getI18n(`vxe.upload.morePopup.${isImage ? "imageTitle" : "fileTitle"}`),
          width: 660,
          height: 500,
          escClosable: true,
          showMaximize: true,
          resize: true,
          maskClosable: true,
          slots: {
            default() {
              const { showErrorStatus, dragToUpload, dragSort } = props;
              const { isDragMove, isDragUploadStatus, dragIndex } = reactData;
              const { fileList } = reactData;
              const isDisabled = computeIsDisabled.value;
              const ons = {};
              if (dragToUpload && dragIndex === -1) {
                ons.onDragover = handleUploadDragoverEvent;
                ons.onDragleave = handleUploadDragleaveEvent;
                ons.onDrop = handleUploadDropEvent;
              }
              return h("div", Object.assign({ ref: refPopupElem, class: ["vxe-upload--more-popup", {
                "is--readonly": formReadonly,
                "is--disabled": isDisabled,
                "show--error": showErrorStatus,
                "is--drag": isDragUploadStatus
              }] }, ons), [
                isImage ? dragSort ? h(TransitionGroup, {
                  name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
                  tag: "div",
                  class: "vxe-upload--image-more-list"
                }, {
                  default: () => renderImageItemList(fileList, true).concat(renderImageAction(true))
                }) : h("div", {
                  class: "vxe-upload--image-more-list"
                }, renderImageItemList(fileList, true).concat(renderImageAction(true))) : h("div", {
                  class: "vxe-upload--file-more-list"
                }, [
                  renderFileAction(true),
                  dragSort ? h(TransitionGroup, {
                    name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
                    tag: "div",
                    class: "vxe-upload--file-list"
                  }, {
                    default: () => renderFileItemList(fileList, false)
                  }) : h("div", {
                    class: "vxe-upload--file-list"
                  }, renderFileItemList(fileList, true))
                ]),
                dragSort ? h("div", {
                  ref: refModalDragLineElem,
                  class: "vxe-upload--drag-line"
                }) : renderEmptyElement($xeUpload),
                isDragUploadStatus ? h("div", {
                  class: "vxe-upload--drag-placeholder"
                }, getI18n("vxe.upload.dragPlaceholder")) : renderEmptyElement($xeUpload)
              ]);
            }
          },
          onShow() {
            reactData.showMorePopup = true;
          },
          onHide() {
            reactData.showMorePopup = false;
          }
        });
      }
    };
    const showDropTip = (evnt, dragEl2, dragPos) => {
      const { showMorePopup } = reactData;
      const el2 = refElem.value;
      const popupEl = refPopupElem.value;
      const wrapperEl = showMorePopup ? popupEl : el2;
      if (!wrapperEl) {
        return;
      }
      const wrapperRect = wrapperEl.getBoundingClientRect();
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      const currDLineEl = showMorePopup ? mdLineEl : ddLineEl;
      if (currDLineEl) {
        const dragRect = dragEl2.getBoundingClientRect();
        currDLineEl.style.display = "block";
        currDLineEl.style.top = `${Math.max(1, dragRect.y - wrapperRect.y)}px`;
        currDLineEl.style.left = `${Math.max(1, dragRect.x - wrapperRect.x)}px`;
        currDLineEl.style.height = `${dragRect.height}px`;
        currDLineEl.style.width = `${dragRect.width - 1}px`;
        currDLineEl.setAttribute("drag-pos", dragPos);
      }
    };
    const hideDropTip = () => {
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      if (ddLineEl) {
        ddLineEl.style.display = "";
      }
      if (mdLineEl) {
        mdLineEl.style.display = "";
      }
    };
    const handleDragSortDragstartEvent = (evnt) => {
      if (evnt.dataTransfer) {
        const img = new Image();
        img.src = tpImg2;
        evnt.dataTransfer.setDragImage(img, 0, 0);
      }
      const dragEl2 = evnt.currentTarget;
      const parentEl2 = dragEl2.parentElement;
      const dragIndex = import_xe_utils119.default.findIndexOf(Array.from(parentEl2.children), (item) => dragEl2 === item);
      reactData.isDragMove = true;
      reactData.dragIndex = dragIndex;
      setTimeout(() => {
        reactData.isDragMove = false;
      }, 500);
    };
    const handleDragSortDragoverEvent = (evnt) => {
      evnt.preventDefault();
      const { dragIndex } = reactData;
      if (dragIndex === -1) {
        return;
      }
      const isImage = computeIsImage.value;
      const dragEl2 = evnt.currentTarget;
      const parentEl2 = dragEl2.parentElement;
      const currIndex = import_xe_utils119.default.findIndexOf(Array.from(parentEl2.children), (item) => dragEl2 === item);
      let dragPos = "";
      if (isImage) {
        const offsetX = evnt.clientX - dragEl2.getBoundingClientRect().x;
        dragPos = offsetX < dragEl2.clientWidth / 2 ? "left" : "right";
      } else {
        const offsetY = evnt.clientY - dragEl2.getBoundingClientRect().y;
        dragPos = offsetY < dragEl2.clientHeight / 2 ? "top" : "bottom";
      }
      if (dragIndex === currIndex) {
        showDropTip(evnt, dragEl2, dragPos);
        return;
      }
      showDropTip(evnt, dragEl2, dragPos);
      internalData.prevDragIndex = currIndex;
      internalData.prevDragPos = dragPos;
    };
    const handleDragSortDragendEvent = (evnt) => {
      const { fileList, dragIndex } = reactData;
      const { prevDragIndex, prevDragPos } = internalData;
      const oldIndex2 = dragIndex;
      const targetIndex = prevDragIndex;
      const dragOffsetIndex = prevDragPos === "bottom" || prevDragPos === "right" ? 1 : 0;
      const oldItem = fileList[oldIndex2];
      const newItem = fileList[targetIndex];
      if (oldItem && newItem) {
        fileList.splice(oldIndex2, 1);
        const ptfIndex = import_xe_utils119.default.findIndexOf(fileList, (item) => newItem === item);
        const nIndex = ptfIndex + dragOffsetIndex;
        fileList.splice(nIndex, 0, oldItem);
        dispatchEvent2("sort-dragend", {
          oldItem,
          newItem,
          dragPos: prevDragPos,
          offsetIndex: dragOffsetIndex,
          _index: {
            newIndex: nIndex,
            oldIndex: oldIndex2
          }
        }, evnt);
      }
      hideDropTip();
      reactData.dragIndex = -1;
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { pasteToUpload } = props;
      const { isActivated } = reactData;
      if (!isActivated || !pasteToUpload) {
        return;
      }
      const clipboardData = evnt.clipboardData || evnt.originalEvent.clipboardData;
      if (!clipboardData) {
        return;
      }
      const { items } = clipboardData;
      if (!items) {
        return;
      }
      const files = handleTransferFiles(items);
      if (files.length) {
        evnt.preventDefault();
        uploadTransferFileEvent(evnt, files);
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const el2 = refElem.value;
      const isActivated = getEventTargetNode2(evnt, el2).flag;
      reactData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      reactData.isActivated = false;
    };
    const uploadMethods = {
      dispatchEvent: dispatchEvent2,
      choose() {
        return handleChoose(null);
      }
    };
    const uploadPrivateMethods = {};
    Object.assign($xeUpload, uploadMethods, uploadPrivateMethods);
    const renderFileItemList = (currList, isMoreView) => {
      const { showRemoveButton, showDownloadButton, showProgress, progressText, showPreview, showErrorStatus, dragSort } = props;
      const { fileCacheMaps } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const cornerSlot = slots.corner;
      const ons = {};
      if (dragSort) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index2) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        const isLoading = cacheItem && cacheItem.loading;
        const isError = cacheItem && cacheItem.status === "error";
        return h("div", Object.assign({ key: dragSort ? fileKey : index2, class: ["vxe-upload--file-item", {
          "is--preview": showPreview,
          "is--loading": isLoading,
          "is--error": isError
        }], fileid: fileKey, draggable: dragSort ? true : null }, ons), [
          h("div", {
            class: "vxe-upload--file-item-icon"
          }, [
            h("i", {
              class: getIcon()[`UPLOAD_FILE_TYPE_${`${item[typeProp]}`.toLocaleUpperCase()}`] || getIcon().UPLOAD_FILE_TYPE_DEFAULT
            })
          ]),
          h("div", {
            class: "vxe-upload--file-item-name",
            onClick(evnt) {
              if (!isLoading && !isError) {
                handlePreviewFileEvent(evnt, item);
              }
            }
          }, `${item[nameProp] || ""}`),
          isLoading ? h("div", {
            class: "vxe-upload--file-item-loading-icon"
          }, [
            h("i", {
              class: getIcon().UPLOAD_LOADING
            })
          ]) : createCommentVNode(),
          showProgress && isLoading && cacheItem ? h("div", {
            class: "vxe-upload--file-item-loading-text"
          }, progressText ? import_xe_utils119.default.toFormatString(progressText, { percent: cacheItem.percent }) : getI18n("vxe.upload.uploadProgress", [cacheItem.percent])) : createCommentVNode(),
          showErrorStatus && isError ? h("div", {
            class: "vxe-upload--image-item-error"
          }, [
            h(button_default, {
              icon: getIcon().UPLOAD_IMAGE_RE_UPLOAD,
              mode: "text",
              status: "primary",
              content: getI18n("vxe.upload.reUpload"),
              onClick() {
                handleReUpload(item);
              }
            })
          ]) : createCommentVNode(),
          h("div", {
            class: "vxe-upload--file-item-btn-wrapper"
          }, [
            cornerSlot ? h("div", {
              class: "vxe-upload--file-item-corner"
            }, getSlotVNs2(cornerSlot({ option: item, isMoreView, readonly: formReadonly }))) : createCommentVNode(),
            showDownloadButton && !isLoading ? h("div", {
              class: "vxe-upload--file-item-download-btn",
              onClick(evnt) {
                downloadFileEvent(evnt, item);
              }
            }, [
              h("i", {
                class: getIcon().UPLOAD_FILE_DOWNLOAD
              })
            ]) : createCommentVNode(),
            showRemoveButton && !formReadonly && !isDisabled && !isLoading ? h("div", {
              class: "vxe-upload--file-item-remove-btn",
              onClick(evnt) {
                removeFileEvent(evnt, item, index2);
              }
            }, [
              h("i", {
                class: getIcon().UPLOAD_FILE_REMOVE
              })
            ]) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderFileAction = (isMoreView) => {
      const { showUploadButton, buttonText, buttonIcon, showButtonText, showButtonIcon, autoHiddenButton } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      if (formReadonly || !showUploadButton) {
        return createCommentVNode();
      }
      return h("div", {
        class: "vxe-upload--file-action"
      }, [
        autoHiddenButton && overCount ? createCommentVNode() : h("div", {
          class: "vxe-upload--file-action-btn",
          onClick: clickEvent
        }, defaultSlot ? getSlotVNs2(defaultSlot({ $upload: $xeUpload })) : [
          h(button_default, {
            class: "vxe-upload--file-action-button",
            content: isMoreView || showButtonText ? buttonText ? `${buttonText}` : getI18n("vxe.upload.fileBtnText") : "",
            icon: showButtonIcon ? buttonIcon || getIcon().UPLOAD_FILE_ADD : "",
            disabled: isDisabled
          })
        ]),
        isMoreView && (defHintText || tipSlot) ? h("div", {
          class: "vxe-upload--file-action-tip"
        }, tipSlot ? getSlotVNs2(tipSlot({ $upload: $xeUpload })) : defHintText) : createCommentVNode()
      ]);
    };
    const renderAllMode = () => {
      const { moreConfig, dragSort } = props;
      const { fileList, isDragMove } = reactData;
      const moreOpts = computeMoreOpts.value;
      const { maxCount, showMoreButton, layout } = moreOpts;
      const isHorizontal = layout === "horizontal";
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return h("div", {
        key: "all",
        class: "vxe-upload--file-wrapper"
      }, [
        showMoreButton && moreConfig && isHorizontal ? createCommentVNode() : renderFileAction(true),
        currList.length || showMoreButton && isHorizontal ? h("div", {
          class: ["vxe-upload--file-list-wrapper", {
            "is--horizontal": isHorizontal
          }]
        }, [
          currList.length ? dragSort ? h(TransitionGroup, {
            name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
            tag: "div",
            class: "vxe-upload--file-list"
          }, {
            default: () => renderFileItemList(currList, false)
          }) : h("div", {
            class: "vxe-upload--file-list"
          }, renderFileItemList(currList, false)) : createCommentVNode(),
          showMoreButton && overMaxNum ? h("div", {
            class: "vxe-upload--file-over-more"
          }, [
            h(button_default, {
              mode: "text",
              content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
              status: "primary",
              onClick: handleMoreEvent
            })
          ]) : createCommentVNode(),
          showMoreButton && moreConfig && isHorizontal ? renderFileAction(false) : createCommentVNode()
        ]) : createCommentVNode()
      ]);
    };
    const renderImageItemList = (currList, isMoreView) => {
      const { showRemoveButton, showProgress, progressText, showPreview, showErrorStatus, dragSort } = props;
      const { fileCacheMaps } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const imageOpts = computeImageOpts.value;
      const imgStyle = computeImgStyle.value;
      const cornerSlot = slots.corner;
      const ons = {};
      if (dragSort) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index2) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        const isLoading = cacheItem && cacheItem.loading;
        const isError = cacheItem && cacheItem.status === "error";
        return h("div", Object.assign({ key: dragSort ? fileKey : index2, class: ["vxe-upload--image-item", {
          "is--preview": showPreview,
          "is--circle": imageOpts.circle,
          "is--loading": isLoading,
          "is--error": isError
        }], fileid: fileKey, draggable: dragSort ? true : null }, ons), [
          h("div", {
            class: "vxe-upload--image-item-box",
            style: isMoreView ? null : imgStyle,
            title: getI18n("vxe.upload.viewItemTitle"),
            onClick(evnt) {
              if (!isLoading && !isError) {
                handlePreviewImageEvent(evnt, item, index2);
              }
            }
          }, [
            isLoading && cacheItem ? h("div", {
              class: "vxe-upload--image-item-loading"
            }, [
              h("div", {
                class: "vxe-upload--image-item-loading-icon"
              }, [
                h("i", {
                  class: getIcon().UPLOAD_LOADING
                })
              ]),
              showProgress ? h("div", {
                class: "vxe-upload--image-item-loading-text"
              }, progressText ? import_xe_utils119.default.toFormatString(progressText, { percent: cacheItem.percent }) : getI18n("vxe.upload.uploadProgress", [cacheItem.percent])) : createCommentVNode()
            ]) : createCommentVNode(),
            !isLoading ? isError && showErrorStatus ? h("div", {
              class: "vxe-upload--image-item-error"
            }, [
              h(button_default, {
                icon: getIcon().UPLOAD_IMAGE_RE_UPLOAD,
                mode: "text",
                status: "primary",
                content: getI18n("vxe.upload.reUpload"),
                onClick() {
                  handleReUpload(item);
                }
              })
            ]) : h("div", {
              class: "vxe-upload--image-item-img-wrapper"
            }, [
              h("img", {
                class: "vxe-upload--image-item-img",
                src: getThumbnailFileUrl(item)
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-upload--image-item-btn-wrapper",
              onClick(evnt) {
                evnt.stopPropagation();
              }
            }, [
              cornerSlot ? h("div", {
                class: "vxe-upload--file-item-corner"
              }, getSlotVNs2(cornerSlot({ option: item, isMoreView, readonly: formReadonly }))) : createCommentVNode(),
              showRemoveButton && !formReadonly && !isDisabled && !isLoading ? h("div", {
                class: "vxe-upload--image-item-remove-btn",
                onClick(evnt) {
                  evnt.stopPropagation();
                  removeFileEvent(evnt, item, index2);
                }
              }, [
                h("i", {
                  class: getIcon().UPLOAD_IMAGE_REMOVE
                })
              ]) : createCommentVNode()
            ])
          ])
        ]);
      });
    };
    const renderImageAction = (isMoreView) => {
      const { showUploadButton, buttonText, buttonIcon, showButtonText, showButtonIcon, autoHiddenButton } = props;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const imgStyle = computeImgStyle.value;
      const defaultSlot = slots.default;
      const hintSlot = slots.hint;
      if (formReadonly || !showUploadButton || autoHiddenButton && overCount) {
        return createCommentVNode();
      }
      return h("div", {
        key: "action",
        class: "vxe-upload--image-action"
      }, [
        h("div", {
          class: "vxe-upload--image-action-btn",
          onClick: clickEvent
        }, defaultSlot ? defaultSlot({ $upload: $xeUpload }) : [
          h("div", {
            class: "vxe-upload--image-action-box",
            style: isMoreView ? null : imgStyle
          }, [
            showButtonIcon ? h("div", {
              class: "vxe-upload--image-action-icon"
            }, [
              h("i", {
                class: buttonIcon || getIcon().UPLOAD_IMAGE_ADD
              })
            ]) : createCommentVNode(),
            isMoreView || showButtonText ? h("div", {
              class: "vxe-upload--image-action-content"
            }, buttonText ? `${buttonText}` : getI18n("vxe.upload.imgBtnText")) : createCommentVNode(),
            isMoreView && (defHintText || hintSlot) ? h("div", {
              class: "vxe-upload--image-action-hint"
            }, hintSlot ? getSlotVNs2(hintSlot({ $upload: $xeUpload })) : defHintText) : createCommentVNode()
          ])
        ])
      ]);
    };
    const renderImageMode = () => {
      const { dragSort } = props;
      const { fileList, isDragMove } = reactData;
      const moreOpts = computeMoreOpts.value;
      const { maxCount, showMoreButton } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return h("div", {
        key: "image",
        class: "vxe-upload--image-wrapper"
      }, [
        dragSort ? h(TransitionGroup, {
          name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
          tag: "div",
          class: "vxe-upload--image-list"
        }, {
          default: () => renderImageItemList(currList, false).concat([
            showMoreButton && overMaxNum ? h("div", {
              key: "om",
              class: "vxe-upload--image-over-more"
            }, [
              h(button_default, {
                mode: "text",
                content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
                status: "primary",
                onClick: handleMoreEvent
              })
            ]) : createCommentVNode(),
            renderImageAction(false)
          ])
        }) : h("div", {
          class: "vxe-upload--image-list"
        }, renderImageItemList(currList, false).concat([
          showMoreButton && overMaxNum ? h("div", {
            class: "vxe-upload--image-over-more"
          }, [
            h(button_default, {
              mode: "text",
              content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
              status: "primary",
              onClick: handleMoreEvent
            })
          ]) : createCommentVNode(),
          renderImageAction(false)
        ]))
      ]);
    };
    const renderVN = () => {
      const { showErrorStatus, dragToUpload, pasteToUpload, dragSort } = props;
      const { isDragUploadStatus, showMorePopup, isActivated, dragIndex } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      const ons = {};
      if (dragToUpload && dragIndex === -1) {
        ons.onDragover = handleUploadDragoverEvent;
        ons.onDragleave = handleUploadDragleaveEvent;
        ons.onDrop = handleUploadDropEvent;
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-upload", {
        [`size--${vSize}`]: vSize,
        "is--active": isActivated,
        "is--readonly": formReadonly,
        "is--disabled": isDisabled,
        "is--paste": pasteToUpload,
        "show--error": showErrorStatus,
        "is--drag": isDragUploadStatus
      }] }, ons), [
        isImage ? renderImageMode() : renderAllMode(),
        dragSort ? h("div", {
          ref: refDragLineElem,
          class: "vxe-upload--drag-line"
        }) : renderEmptyElement($xeUpload),
        isDragUploadStatus && !showMorePopup ? h("div", {
          class: "vxe-upload--drag-placeholder"
        }, getI18n("vxe.upload.dragPlaceholder")) : renderEmptyElement($xeUpload)
      ]);
    };
    const listFlag = ref(0);
    watch(() => props.modelValue ? props.modelValue.length : 0, () => {
      listFlag.value++;
    });
    watch(() => props.modelValue, () => {
      listFlag.value++;
    });
    watch(listFlag, () => {
      updateFileList();
    });
    onMounted(() => {
      if (true) {
        if (props.multiple && props.singleMode) {
          errLog2("vxe.error.errConflicts", ["multiple", "single-mode"]);
        }
        if (props.imageStyle) {
          warnLog2("vxe.error.delProp", ["image-style", "image-config"]);
        }
      }
      globalEvents.on($xeUpload, "paste", handleGlobalPasteEvent);
      globalEvents.on($xeUpload, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeUpload, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      reactData.isDragUploadStatus = false;
      globalEvents.off($xeUpload, "paste");
      globalEvents.off($xeUpload, "mousedown");
      globalEvents.off($xeUpload, "blur");
    });
    updateFileList();
    $xeUpload.renderVN = renderVN;
    return $xeUpload;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-view.js
var WidgetVxeUploadFileViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(upload_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: "all",
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-data.js
var getWidgetVxeUploadImageConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-file-image",
    options: {
      limitCount: 9,
      limitSize: 10,
      multiple: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-form.js
var WidgetVxeUploadImageFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const limitSizeOptions = ref(getLimitSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.multiImg"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            options.multiple ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitImgCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: true } }
            }) : createCommentVNode(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitImgSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: limitSizeOptions.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-view.js
var WidgetVxeUploadImageViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(upload_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: "image",
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-data.js
var getWidgetVxeRateConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-star",
    query: true,
    options: {}
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-form.js
var WidgetVxeRateFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/rate/src/rate.js
var import_xe_utils120 = __toESM(require_xe_utils());
var rate_default = defineComponent({
  name: "VxeRate",
  props: {
    modelValue: [Number, String],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().rate.size || getConfig().size
    },
    status: String
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils120.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      activeValue: null
    });
    const refMaps = {
      refElem
    };
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeNumVal = computed(() => {
      const { modelValue } = props;
      const { activeValue } = reactData;
      return import_xe_utils120.default.toNumber(activeValue === null ? modelValue : activeValue);
    });
    const computeItemList = computed(() => {
      return [1, 2, 3, 4, 5].map((num) => {
        return {
          value: num,
          label: num
        };
      });
    });
    const computeMaps = {};
    const $xeRate = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $rate: $xeRate }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const mouseenterEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        reactData.activeValue = value;
      }
    };
    const mouseleaveEvent = () => {
      reactData.activeValue = null;
    };
    const clickEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        emitModel(value);
        dispatchEvent2("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRate, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { status } = props;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const itemList = computeItemList.value;
      const vSize = computeSize.value;
      const numVal = computeNumVal.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-rate", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--disabled": isDisabled,
          "is--readonly": isReadonly
        }]
      }, itemList.map((item) => {
        const isChecked = numVal >= item.value;
        return h("div", {
          class: ["vxe-rte--item", {
            "is--checked": isChecked
          }],
          onMouseenter(evnt) {
            if (!(isDisabled || isReadonly)) {
              mouseenterEvent(evnt, item);
            }
          },
          onMouseleave: mouseleaveEvent,
          onClick(evnt) {
            if (!(isDisabled || isReadonly)) {
              clickEvent(evnt, item);
            }
          }
        }, [
          h("i", {
            class: isChecked ? getIcon().RATE_CHECKED : getIcon().RATE_UNCHECKED
          })
        ]);
      }));
    };
    $xeRate.renderVN = renderVN;
    return $xeRate;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-view.js
var WidgetVxeRateViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(rate_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-data.js
var getWidgetVxeSliderConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-slider",
    query: true,
    options: {}
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-form.js
var WidgetVxeSliderFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/slider/src/slider.js
var import_xe_utils121 = __toESM(require_xe_utils());
var slider_default = defineComponent({
  name: "VxeSlider",
  props: {
    modelValue: [String, Number, Array],
    vertical: Boolean,
    max: {
      type: [String, Number],
      default: () => getConfig().slider.max
    },
    min: {
      type: [String, Number],
      default: () => getConfig().slider.min
    },
    step: {
      type: [String, Number],
      default: () => getConfig().slider.step
    },
    size: {
      type: String,
      default: () => getConfig().slider.size || getConfig().size
    },
    range: {
      type: Boolean,
      default: () => getConfig().slider.range
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils121.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refBarElem = ref();
    const refTrackElem = ref();
    const refStartBtnElem = ref();
    const refEndBtnElem = ref();
    const reactData = reactive({
      startValue: 0,
      endValue: 0
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaxNum = computed(() => {
      return import_xe_utils121.default.toNumber(props.max || 0);
    });
    const computeMinNum = computed(() => {
      return import_xe_utils121.default.toNumber(props.min || 0);
    });
    const computeMaps = {};
    const $xeSlider = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $slider: $xeSlider }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const getStartPercent = (startValue) => {
      const { range } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return range ? import_xe_utils121.default.floor((startValue - minNum) / import_xe_utils121.default.toNumber(maxNum - minNum) * 100) : 0;
    };
    const getEndPercent = (startValue, endValue) => {
      const { range } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return import_xe_utils121.default.floor((endValue - (range ? startValue : 0) - minNum) / import_xe_utils121.default.toNumber(maxNum - minNum) * 100);
    };
    const updateModel = () => {
      const { modelValue } = props;
      if (import_xe_utils121.default.isArray(modelValue)) {
        const [sVal, eVal] = import_xe_utils121.default.clone(modelValue, true).sort();
        reactData.startValue = import_xe_utils121.default.floor(import_xe_utils121.default.toNumber(sVal || 0));
        reactData.endValue = import_xe_utils121.default.floor(import_xe_utils121.default.toNumber(eVal || 0));
      } else {
        reactData.startValue = 0;
        reactData.endValue = import_xe_utils121.default.floor(import_xe_utils121.default.toNumber(modelValue || 0));
      }
    };
    const updateBarStyle = () => {
      const { startValue, endValue } = reactData;
      const trackElem = refTrackElem.value;
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = refEndBtnElem.value;
      let startPercent = 0;
      let endPercent = 0;
      if (startValue > endValue) {
        startPercent = getStartPercent(endValue);
        endPercent = getEndPercent(endValue, startValue);
      } else {
        startPercent = getStartPercent(startValue);
        endPercent = getEndPercent(startValue, endValue);
      }
      if (trackElem) {
        trackElem.style.left = `${startPercent}%`;
        trackElem.style.width = `${endPercent}%`;
      }
      if (startBtnElem) {
        startBtnElem.style.left = `${startPercent}%`;
      }
      if (endBtnElem) {
        endBtnElem.style.left = `${import_xe_utils121.default.floor(startPercent + endPercent)}%`;
      }
    };
    const changeEvent = (evnt) => {
      const { range } = props;
      const { startValue, endValue } = reactData;
      const value = range ? [startValue, endValue].sort() : endValue;
      emitModel(value);
      dispatchEvent2("change", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const handleMousedownEvent = (evnt, isEnd) => {
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      if (!(formReadonly || isDisabled)) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const el2 = refElem.value;
          const barElem = refBarElem.value;
          if (el2 && barElem) {
            const barRect = barElem.getBoundingClientRect();
            const trackWidth = (evnt2.clientX - barRect.left) / barRect.width;
            if (isEnd) {
              reactData.endValue = import_xe_utils121.default.floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum) + minNum)));
            } else {
              reactData.startValue = import_xe_utils121.default.floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum))));
            }
          }
          updateBarStyle();
        };
        document.onmouseup = (evnt2) => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          changeEvent(evnt2);
          updateBarStyle();
        };
      }
    };
    const handleStartMousedownEvent = (evnt) => {
      const endBtnElem = refEndBtnElem.value;
      const startBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, endBtnElem ? endBtnElem.offsetLeft < startBtnElem.offsetLeft : false);
    };
    const handleEndMousedownEvent = (evnt) => {
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, startBtnElem ? endBtnElem.offsetLeft > startBtnElem.offsetLeft : true);
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeSlider, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { vertical, range } = props;
      const vSize = computeSize.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-slider", {
          [`size--${vSize}`]: vSize,
          "is--vertical": vertical,
          "is--readonly": formReadonly,
          "is--disabled": isDisabled
        }]
      }, [
        h("div", {
          class: "vxe-slider--inner"
        }, [
          h("div", {
            ref: refBarElem,
            class: "vxe-slider--bar-wrapper"
          }),
          h("div", {
            ref: refTrackElem,
            class: "vxe-slider--bar-track"
          }),
          formReadonly || !range ? renderEmptyElement($xeSlider) : h("div", {
            ref: refStartBtnElem,
            class: "vxe-slider--bar-btn vxe-slider--start-btn",
            onMousedown: handleStartMousedownEvent
          }),
          formReadonly ? renderEmptyElement($xeSlider) : h("div", {
            ref: refEndBtnElem,
            class: "vxe-slider--bar-btn vxe-slider--end-btn",
            onMousedown: handleEndMousedownEvent
          })
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      updateModel();
    });
    onMounted(() => {
      updateBarStyle();
    });
    updateModel();
    $xeSlider.renderVN = renderVN;
    return $xeSlider;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-view.js
var WidgetVxeSliderViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(slider_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/render/index.js
renderer.mixin({
  text: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextFormComponent, { renderOpts, renderParams });
    }
  },
  /**
   * 
   */
  title: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextFormComponent, { renderOpts, renderParams });
    }
  },
  row: {
    createFormDesignWidgetConfig: getWidgetRowConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return h(WidgetRowEditComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetRowViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetRowFormComponent, { renderOpts, renderParams });
    }
  },
  subtable: {
    createFormDesignWidgetConfig: getWidgetSubtableConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return h(WidgetSubtableEditComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetSubtableViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetSubtableFormComponent, { renderOpts, renderParams });
    }
  },
  input: {
    createFormDesignWidgetConfig: getWidgetInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetInputFormComponent, { renderOpts, renderParams });
    }
  },
  textarea: {
    createFormDesignWidgetConfig: getWidgetTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextareaViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextareaFormComponent, { renderOpts, renderParams });
    }
  },
  select: {
    createFormDesignWidgetConfig: getWidgetSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeInput: {
    createFormDesignWidgetConfig: getWidgetVxeInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeInputFormComponent, { renderOpts, renderParams });
    }
  },
  VxeNumberInput: {
    createFormDesignWidgetConfig: getWidgetVxeNumberInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeNumberInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeNumberInputFormComponent, { renderOpts, renderParams });
    }
  },
  VxeDatePicker: {
    createFormDesignWidgetConfig: getWidgetVxeDatePickerConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeDatePickerViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeDatePickerFormComponent, { renderOpts, renderParams });
    }
  },
  VxeTextarea: {
    createFormDesignWidgetConfig: getWidgetVxeTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeTextareaViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeTextareaFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSwitch: {
    createFormDesignWidgetConfig: getWidgetVxeSwitchConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSwitchViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSwitchFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeTreeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeTreeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeTreeSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeTreeSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeRadioGroup: {
    createFormDesignWidgetConfig: getWidgetVxeRadioGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeRadioGroupViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeRadioGroupFormComponent, { renderOpts, renderParams });
    }
  },
  VxeCheckboxGroup: {
    createFormDesignWidgetConfig: getWidgetVxeCheckboxGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeCheckboxGroupViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeCheckboxGroupFormComponent, { renderOpts, renderParams });
    }
  },
  VxeUploadFile: {
    createFormDesignWidgetConfig: getWidgetVxeUploadFileConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeUploadFileViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeUploadFileFormComponent, { renderOpts, renderParams });
    }
  },
  VxeUploadImage: {
    createFormDesignWidgetConfig: getWidgetVxeUploadImageConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeUploadImageViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeUploadImageFormComponent, { renderOpts, renderParams });
    }
  },
  VxeRate: {
    createFormDesignWidgetConfig: getWidgetVxeRateConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeRateViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeRateFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSlider: {
    createFormDesignWidgetConfig: getWidgetVxeSliderConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSliderViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSliderFormComponent, { renderOpts, renderParams });
    }
  }
});

// node_modules/vxe-pc-ui/es/form-design/index.js
var VxeFormDesign = Object.assign({}, form_design_default, {
  install(app) {
    app.component(form_design_default.name, form_design_default);
  }
});
var formDesignHandle = {
  useWidgetName,
  useWidgetView,
  useSubtableView,
  useWidgetPropDataSource
};
dynamicApp.use(VxeFormDesign);
VxeUI.component(form_design_default);
VxeUI.formDesignHandle = formDesignHandle;
VxeUI.formDesign = formDesignHandle;
var FormDesign = VxeFormDesign;
var form_design_default2 = VxeFormDesign;

// node_modules/vxe-pc-ui/es/form-gather/index.js
var VxeFormGatherComponent = Object.assign({}, form_group_default, { name: "VxeFormGather" });
var VxeFormGather = Object.assign(VxeFormGatherComponent, {
  install(app) {
    app.component(VxeFormGatherComponent.name, VxeFormGatherComponent);
  }
});
dynamicApp.use(VxeFormGather);
VxeUI.component(VxeFormGatherComponent);
var FormGather = VxeFormGather;
var form_gather_default = VxeFormGather;

// node_modules/vxe-pc-ui/es/form-group/index.js
var VxeFormGroup = Object.assign(form_group_default, {
  install(app) {
    app.component(form_group_default.name, form_group_default);
  }
});
dynamicApp.use(VxeFormGroup);
VxeUI.component(form_group_default);
var FormGroup = VxeFormGroup;
var form_group_default2 = VxeFormGroup;

// node_modules/vxe-pc-ui/es/form-item/index.js
var VxeFormItem = Object.assign(form_item_default, {
  install(app) {
    app.component(form_item_default.name, form_item_default);
  }
});
dynamicApp.use(VxeFormItem);
VxeUI.component(form_item_default);
var FormItem = VxeFormItem;
var form_item_default2 = VxeFormItem;

// node_modules/vxe-pc-ui/es/form-view/index.js
var VxeFormView = Object.assign(form_view_default, {
  install: function(app) {
    app.component(form_view_default.name, form_view_default);
  }
});
dynamicApp.use(VxeFormView);
VxeUI.component(form_view_default);
var FormView = VxeFormView;
var form_view_default2 = VxeFormView;

// node_modules/vxe-pc-ui/es/icon/index.js
var VxeIcon = Object.assign({}, icon_default, {
  install(app) {
    app.component(icon_default.name, icon_default);
  }
});
dynamicApp.use(VxeIcon);
VxeUI.component(icon_default);
var Icon = VxeIcon;
var icon_default2 = VxeIcon;

// node_modules/vxe-pc-ui/es/icon-picker/src/icon-picker.js
var import_xe_utils122 = __toESM(require_xe_utils());
var icon_picker_default = defineComponent({
  name: "VxeIconPicker",
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: {
      type: String,
      default: () => getConfig().iconPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => getConfig().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils122.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      selectIcon: `${props.modelValue || ""}`,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refElem = ref();
    const refInput = ref();
    const refOptionPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeIconPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let iconPickerMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().iconPicker.transfer;
        if (import_xe_utils122.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeIconList = computed(() => {
      let { icons } = props;
      if (!icons || !icons.length) {
        icons = getConfig().iconPicker.icons || [];
      }
      return icons.map((name) => {
        return {
          title: name,
          icon: `vxe-icon-${name}`
        };
      });
    });
    const computeIconGroupList = computed(() => {
      const iconList = computeIconList.value;
      return import_xe_utils122.default.chunk(iconList, 4);
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el2) {
          const targetHeight = el2.offsetHeight;
          const targetWidth = el2.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(el2);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      reactData.selectIcon = selectValue;
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        iconPickerMethods.dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      iconPickerMethods.dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const togglePanelEvent = (evnt) => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      iconPickerMethods.dispatchEvent("click", {}, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $iconPicker: $xeIconPicker }, params));
    };
    iconPickerMethods = {
      dispatchEvent: dispatchEvent2,
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    const handleClickIconEvent = (evnt, item) => {
      const value = item.icon;
      changeEvent(evnt, value);
      hideOptionPanel();
    };
    Object.assign($xeIconPicker, iconPickerMethods);
    const renderIconWrapper = () => {
      const { showIconTitle } = props;
      const iconGroupList = computeIconGroupList.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        class: "vxe-ico-picker--list-wrapper"
      }, iconGroupList.map((list) => {
        return h("div", {
          class: "vxe-ico-picker--list"
        }, list.map((item) => {
          return h("div", {
            class: "vxe-ico-picker--item",
            onClick(evnt) {
              if (!isDisabled) {
                handleClickIconEvent(evnt, item);
              }
            }
          }, [
            h("div", {
              class: "vxe-ico-picker--item-icon"
            }, [
              h("i", {
                class: item.icon || ""
              })
            ]),
            showIconTitle ? h("div", {
              class: "vxe-ico-picker--item-title"
            }, `${item.title || ""}`) : createCommentVNode()
          ]);
        }));
      }));
    };
    const renderVN = () => {
      const { className, popupClassName, clearable } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, selectIcon } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-ico-picker--readonly", className]
        }, [
          h("i", {
            class: selectIcon
          })
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-ico-picker", className ? import_xe_utils122.default.isFunction(className) ? className({ $iconPicker: $xeIconPicker }) : className : "", {
          [`size--${vSize}`]: vSize,
          "show--clear": clearable && !isDisabled && !!selectIcon,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-ico-picker--inner",
          onClick: clickEvent
        }, [
          h("input", {
            ref: refInput,
            class: "vxe-ico-picker--input",
            onFocus: focusEvent,
            onBlur: blurEvent
          }),
          selectIcon ? h("div", {
            class: "vxe-ico-picker--icon"
          }, [
            h("i", {
              class: selectIcon
            })
          ]) : h("div", {
            class: "vxe-ico-picker--placeholder"
          }, inpPlaceholder),
          h("div", {
            class: "vxe-ico-picker--suffix"
          }, [
            h("div", {
              class: "vxe-ico-picker--clear-icon",
              onClick: clearEvent
            }, [
              h("i", {
                class: getIcon().INPUT_CLEAR
              })
            ]),
            h("div", {
              class: "vxe-ico-picker--suffix-icon"
            }, [
              h("i", {
                class: visiblePanel ? getIcon().ICON_PICKER_OPEN : getIcon().ICON_PICKER_CLOSE
              })
            ])
          ])
        ]),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-ico-picker--panel", popupClassName ? import_xe_utils122.default.isFunction(popupClassName) ? popupClassName({ $iconPicker: $xeIconPicker }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, [
            initialized && (visiblePanel || isAniVisible) ? h("div", {
              class: "vxe-ico-picker--panel-wrapper"
            }, [
              renderIconWrapper()
            ]) : createCommentVNode()
          ])
        ])
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.selectIcon = `${val || ""}`;
    });
    onMounted(() => {
      globalEvents.on($xeIconPicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeIconPicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeIconPicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeIconPicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeIconPicker, "mousewheel");
      globalEvents.off($xeIconPicker, "mousedown");
      globalEvents.off($xeIconPicker, "keydown");
      globalEvents.off($xeIconPicker, "blur");
    });
    provide("$xeIconPicker", $xeIconPicker);
    $xeIconPicker.renderVN = renderVN;
    return $xeIconPicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/icon-picker/index.js
var VxeIconPicker = Object.assign(icon_picker_default, {
  install: function(app) {
    app.component(icon_picker_default.name, icon_picker_default);
  }
});
dynamicApp.use(VxeIconPicker);
VxeUI.component(icon_picker_default);
var IconPicker = VxeIconPicker;
var icon_picker_default2 = VxeIconPicker;

// node_modules/vxe-pc-ui/es/image/src/image.js
var import_xe_utils125 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/image/src/preview.js
var import_xe_utils123 = __toESM(require_xe_utils());
var preview_default = defineComponent({
  name: "VxeImagePreview",
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => getConfig().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => getConfig().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showDownloadButton
    },
    beforeDownloadMethod: Function,
    downloadMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "download",
    "download-fail",
    "close"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils123.default.uniqueId();
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const reactData = reactive({
      activeIndex: props.modelValue || 0,
      offsetPct11: false,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeMarginSize = computed(() => {
      return import_xe_utils123.default.toNumber(props.marginSize || 0) || 16;
    });
    const computeRotateText = computed(() => {
      const { offsetRotate } = reactData;
      if (offsetRotate) {
        return `${offsetRotate}`;
      }
      return "0";
    });
    const computeScaleText = computed(() => {
      const { offsetScale } = reactData;
      if (offsetScale) {
        return `${import_xe_utils123.default.ceil((1 + offsetScale) * 100)}%`;
      }
      return "100%";
    });
    const computeImgList = computed(() => {
      const { urlList } = props;
      const urlProp = computeUrlProp.value;
      if (urlList && urlList.length) {
        return urlList.map((item) => {
          if (import_xe_utils123.default.isString(item)) {
            return item;
          }
          if (item[urlProp]) {
            return item[urlProp];
          }
          return "";
        });
      }
      return [];
    });
    const computeImgTransform = computed(() => {
      let { offsetScale, offsetRotate, offsetLeft, offsetTop } = reactData;
      const stys = [];
      let targetScale = 1;
      if (offsetScale) {
        targetScale = 1 + offsetScale;
        stys.push(`scale(${targetScale})`);
      }
      if (offsetRotate) {
        stys.push(`rotate(${offsetRotate}deg)`);
      }
      if (offsetLeft || offsetTop) {
        offsetLeft /= targetScale;
        offsetTop /= targetScale;
        let targetOffsetLeft = offsetLeft;
        let targetOffsetTop = offsetTop;
        if (offsetRotate) {
          switch (offsetRotate % 360) {
            case 90:
            case -270:
              targetOffsetLeft = offsetTop;
              targetOffsetTop = -offsetLeft;
              break;
            case 180:
            case -180:
              targetOffsetLeft = -offsetLeft;
              targetOffsetTop = -offsetTop;
              break;
            case 270:
            case -90:
              targetOffsetLeft = -offsetTop;
              targetOffsetTop = offsetLeft;
              break;
          }
        }
        stys.push(`translate(${targetOffsetLeft}px, ${targetOffsetTop}px)`);
      }
      return stys.length ? stys.join(" ") : "";
    });
    const computeMaps = {
      computeImgList
    };
    const $xeImagePreview = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $imagePreview: $xeImagePreview }, params));
    };
    const imagePreviewMethods = {
      dispatchEvent: dispatchEvent2
    };
    const emitModel = (value) => {
      reactData.activeIndex = value;
      emit("update:modelValue", value);
    };
    const handleCloseEvent = (evnt) => {
      dispatchEvent2("close", {}, evnt);
    };
    const imagePreviewPrivateMethods = {};
    const resetStyle = () => {
      const elem = refElem.value;
      removeClass2(elem, "is--move");
      Object.assign(reactData, {
        offsetPct11: false,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    };
    const getOffsetZoomStep = () => {
      const { offsetScale } = reactData;
      let stepNum = 0.02;
      if (offsetScale >= -0.6) {
        stepNum = 0.04;
        if (offsetScale >= -0.4) {
          stepNum = 0.07;
          if (offsetScale >= 0) {
            stepNum = 0.1;
            if (offsetScale >= 3) {
              stepNum = 0.25;
              if (offsetScale >= 8) {
                stepNum = 0.4;
                if (offsetScale >= 16) {
                  stepNum = 0.6;
                  if (offsetScale >= 24) {
                    stepNum = 0.9;
                    if (offsetScale >= 32) {
                      stepNum = 1.3;
                      if (offsetScale >= 39) {
                        stepNum = 1.9;
                        if (offsetScale >= 45) {
                          stepNum = 2.5;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return stepNum;
    };
    const handleZoom = (isAdd) => {
      const { offsetScale } = reactData;
      const stepNum = getOffsetZoomStep();
      if (isAdd) {
        reactData.offsetScale = Number(Math.min(49, offsetScale + stepNum).toFixed(2));
      } else {
        reactData.offsetScale = Number(Math.max(-0.9, offsetScale - stepNum).toFixed(2));
      }
    };
    const handleChange = (isNext) => {
      let activeIndex = reactData.activeIndex || 0;
      const imgList = computeImgList.value;
      if (isNext) {
        if (activeIndex >= imgList.length - 1) {
          activeIndex = 0;
        } else {
          activeIndex++;
        }
      } else {
        if (activeIndex <= 0) {
          activeIndex = imgList.length - 1;
        } else {
          activeIndex--;
        }
      }
      resetStyle();
      reactData.activeIndex = activeIndex;
      emitModel(activeIndex);
    };
    const handleRotateImg = (isRight) => {
      let offsetRotate = reactData.offsetRotate;
      if (isRight) {
        offsetRotate += 90;
      } else {
        offsetRotate -= 90;
      }
      reactData.offsetRotate = offsetRotate;
    };
    const handlePct11 = () => {
      resetStyle();
      reactData.offsetPct11 = true;
    };
    const handlePrintImg = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (VxeUI.print) {
        VxeUI.print({
          align: "center",
          pageBreaks: [
            {
              bodyHtml: `<img src="${imgUrl}" style="max-width:100%;max-height:100%;">`
            }
          ]
        });
      }
    };
    const handleDownloadEvent = (evnt, imgUrl) => {
      dispatchEvent2("download", { url: imgUrl }, evnt);
    };
    const handleDefaultDownload = (evnt, imgUrl) => {
      if (VxeUI.saveFile) {
        fetch(imgUrl).then((res) => {
          return res.blob().then((blob) => {
            VxeUI.saveFile({
              filename: imgUrl,
              content: blob
            });
            handleDownloadEvent(evnt, imgUrl);
          });
        }).catch(() => {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.error.downErr"),
              status: "error"
            });
          }
        });
      }
    };
    const handleDownloadImg = (evnt) => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().imagePreview.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || getConfig().imagePreview.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $imagePreview: $xeImagePreview,
        url: imgUrl,
        index: activeIndex || 0
      }) : true).then((status) => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $imagePreview: $xeImagePreview,
              url: imgUrl,
              index: activeIndex || 0
            })).then(() => {
              handleDownloadEvent(evnt, imgUrl);
            }).catch((e16) => e16);
          } else {
            handleDefaultDownload(evnt, imgUrl);
          }
        }
      });
    };
    const handleOperationBtn = (evnt, code3) => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (imgUrl) {
        switch (code3) {
          case "zoomOut":
            handleZoom(false);
            break;
          case "zoomIn":
            handleZoom(true);
            break;
          case "pctFull":
            resetStyle();
            break;
          case "pct11":
            handlePct11();
            break;
          case "rotateLeft":
            handleRotateImg(false);
            break;
          case "rotateRight":
            handleRotateImg(true);
            break;
          case "print":
            handlePrintImg();
            break;
          case "download":
            handleDownloadImg(evnt);
            break;
        }
      }
    };
    const wheelEvent = (evnt) => {
      const delta = evnt.deltaY;
      if (delta > 0) {
        handleZoom(false);
      } else if (delta < 0) {
        handleZoom(true);
      }
    };
    const moveEvent = (evnt) => {
      const { offsetTop, offsetLeft } = reactData;
      const elem = refElem.value;
      evnt.preventDefault();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const startX = evnt.pageX;
      const startY = evnt.pageY;
      const marginSize = computeMarginSize.value;
      document.onmousemove = (et2) => {
        const { pageX, pageY } = et2;
        const { visibleHeight, visibleWidth } = getDomNode2();
        et2.preventDefault();
        addClass2(elem, "is--move");
        if (pageX > marginSize && pageY > marginSize && pageX < visibleWidth - marginSize && pageY < visibleHeight - marginSize) {
          reactData.offsetLeft = offsetLeft + pageX - startX;
          reactData.offsetTop = offsetTop + pageY - startY;
        }
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        removeClass2(elem, "is--move");
      };
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const hasCtrlKey = evnt.ctrlKey;
      const hasShiftKey = evnt.shiftKey;
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDownArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
      const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
      const isR = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.R);
      const isP = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.P);
      if (isUpArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop -= 1;
        } else {
          handleZoom(true);
        }
      } else if (isDownArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop += 1;
        } else {
          handleZoom(false);
        }
      } else if (isLeftArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft -= 1;
        } else {
          handleChange(false);
        }
      } else if (isRightArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft += 1;
        } else {
          handleChange(true);
        }
      } else if (isR && hasCtrlKey) {
        evnt.preventDefault();
        if (hasShiftKey) {
          handleRotateImg(false);
        } else {
          handleRotateImg(true);
        }
      } else if (isP && hasCtrlKey) {
        evnt.preventDefault();
        handlePrintImg();
      }
    };
    const handleClickMaskEvent = (evnt) => {
      if (props.maskClosable) {
        if (evnt.target === evnt.currentTarget) {
          dispatchEvent2("close", {}, evnt);
        }
      }
    };
    Object.assign($xeImagePreview, imagePreviewMethods, imagePreviewPrivateMethods);
    const renderImgWrapper = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgTransform = computeImgTransform.value;
      return h("div", {
        class: "vxe-image-preview--img-list",
        onClick: handleClickMaskEvent
      }, imgList.map((url, index2) => {
        const isActive = activeIndex === index2;
        return h("img", {
          class: ["vxe-image-preview--img-item", {
            "is--active": isActive
          }],
          src: url,
          style: isActive ? {
            transform: imgTransform
          } : null,
          onMousedown(evnt) {
            moveEvent(evnt);
          }
        });
      }));
    };
    const renderOperationBtn = (code3, icon) => {
      return h("div", {
        class: "vxe-image-preview--operation-btn",
        title: getI18n(`vxe.imagePreview.operBtn.${code3}`),
        onClick(evnt) {
          handleOperationBtn(evnt, code3);
        }
      }, [
        h("i", {
          class: getIcon()[icon]
        })
      ]);
    };
    const renderBtnWrapper = () => {
      const { showPrintButton, showDownloadButton } = props;
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const rotateText = computeRotateText.value;
      const scaleText = computeScaleText.value;
      return h("div", {
        class: "vxe-image-preview--btn-wrapper"
      }, [
        h("div", {
          class: "vxe-image-preview--close-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--close-btn",
            onClick: handleCloseEvent
          }, [
            h("i", {
              class: getIcon().IMAGE_PREVIEW_CLOSE
            })
          ]),
          h("div", {
            class: "vxe-image-preview--close-bg"
          })
        ]),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--previous-btn",
          onClick() {
            handleChange(false);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_PREVIOUS
          })
        ]) : createCommentVNode(),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--next-btn",
          onClick() {
            handleChange(true);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_NEXT
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-image-preview--operation-info"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-deg"
          }, rotateText),
          h("div", {
            class: "vxe-image-preview--operation-pct"
          }, scaleText)
        ]),
        h("div", {
          class: "vxe-image-preview--operation-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-active-count"
          }, [
            h("span", {
              class: "vxe-image-preview--operation-active-current"
            }, `${(activeIndex || 0) + 1}`),
            h("span", {
              class: "vxe-image-preview--operation-active-total"
            }, `/${imgList.length}`)
          ]),
          renderOperationBtn("zoomOut", "IMAGE_PREVIEW_ZOOM_OUT"),
          renderOperationBtn("zoomIn", "IMAGE_PREVIEW_ZOOM_IN"),
          renderOperationBtn("pctFull", "IMAGE_PREVIEW_PCT_FULL"),
          renderOperationBtn("pct11", "IMAGE_PREVIEW_PCT_1_1"),
          renderOperationBtn("rotateLeft", "IMAGE_PREVIEW_ROTATE_LEFT"),
          renderOperationBtn("rotateRight", "IMAGE_PREVIEW_ROTATE_RIGHT"),
          showPrintButton ? renderOperationBtn("print", "IMAGE_PREVIEW_PRINT") : createCommentVNode(),
          showDownloadButton ? renderOperationBtn("download", "IMAGE_PREVIEW_DOWNLOAD") : createCommentVNode()
        ])
      ]);
    };
    const renderVN = () => {
      const { offsetPct11 } = reactData;
      return h("div", {
        ref: refElem,
        class: ["vxe-image-preview", {
          "is--pct11": offsetPct11
        }],
        onWheel: wheelEvent
      }, [
        renderImgWrapper(),
        renderBtnWrapper()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeIndex = val;
      resetStyle();
    });
    onMounted(() => {
      globalEvents.on($xeImagePreview, "keydown", handleGlobalKeydownEvent);
    });
    onBeforeUnmount(() => {
      const elem = refElem.value;
      if (elem) {
        removeClass2(elem, "is--move");
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeImagePreview, "keydown");
    });
    provide("$xeImagePreview", $xeImagePreview);
    $xeImagePreview.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/image/src/util.js
var import_xe_utils124 = __toESM(require_xe_utils());
var openPreviewImage = (options) => {
  if (VxeUI.modal) {
    const opts = Object.assign({
      escClosable: true
    }, options);
    const { urlList, activeIndex } = opts;
    const modalId = import_xe_utils124.default.uniqueId("image-preview");
    VxeUI.modal.open({
      id: modalId,
      title: "",
      width: "100%",
      height: "100%",
      showHeader: false,
      showFooter: false,
      padding: false,
      escClosable: opts.escClosable,
      className: "vxe-image-preview-popup-wrapper",
      slots: {
        default() {
          return h(preview_default, {
            modelValue: activeIndex,
            urlList,
            urlField: opts.urlField,
            marginSize: opts.marginSize,
            maskClosable: opts.maskClosable,
            showPrintButton: opts.showPrintButton,
            showDownloadButton: opts.showDownloadButton,
            beforeDownloadMethod: opts.beforeDownloadMethod,
            downloadMethod: opts.downloadMethod,
            onClose() {
              VxeUI.modal.close(modalId);
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
};

// node_modules/vxe-pc-ui/es/image/src/image.js
var image_default = defineComponent({
  name: "VxeImage",
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    circle: Boolean,
    maskClosable: {
      type: Boolean,
      default: () => getConfig().image.maskClosable
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().image.showPreview
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().image.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().image.showDownloadButton
    },
    size: { type: String, default: () => getConfig().image.size || getConfig().size }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils125.default.uniqueId();
    const $xeImageGroup = inject("$xeImageGroup", null);
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeImgStyle = computed(() => {
      const { width, height } = props;
      const style = {};
      if (width && height) {
        style.maxWidth = toCssUnit(width);
        style.maxHeight = toCssUnit(height);
      } else {
        if (width) {
          style.width = toCssUnit(width);
        }
        if (height) {
          style.height = toCssUnit(height);
        }
      }
      return style;
    });
    const computeImgList = computed(() => {
      const { src } = props;
      if (src) {
        return (import_xe_utils125.default.isArray(src) ? src : [src]).map((item) => {
          if (import_xe_utils125.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgItem = computed(() => {
      const imgList = computeImgList.value;
      return imgList[0];
    });
    const computeImgUrl = computed(() => {
      const imgItem = computeImgItem.value;
      return imgItem ? `${imgItem.url || ""}` : "";
    });
    const computeMaps = {
      computeSize
    };
    const $xeImage = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imageMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $image: $xeImage }, params));
      }
    };
    const clickEvent = (evnt) => {
      const { showPreview, showPrintButton, showDownloadButton, maskClosable } = props;
      const imgList = computeImgList.value;
      const imgUrl = computeImgUrl.value;
      if ($xeImageGroup) {
        $xeImageGroup.handleClickImgEvent(evnt, { url: imgUrl });
      } else {
        if (showPreview && imgUrl) {
          openPreviewImage({
            urlList: imgList,
            showPrintButton,
            showDownloadButton,
            maskClosable
          });
        }
        imageMethods.dispatchEvent("click", { url: imgUrl }, evnt);
      }
    };
    const imagePrivateMethods = {};
    Object.assign($xeImage, imageMethods, imagePrivateMethods);
    const renderVN = () => {
      const { alt, loading: loading2, circle } = props;
      const imgStyle = computeImgStyle.value;
      const imgUrl = computeImgUrl.value;
      const vSize = computeSize.value;
      return h("img", {
        ref: refElem,
        class: ["vxe-image", {
          [`size--${vSize}`]: vSize,
          "is--circle": circle
        }],
        src: imgUrl,
        alt,
        loading: loading2,
        style: imgStyle,
        onClick: clickEvent
      });
    };
    $xeImage.renderVN = renderVN;
    return $xeImage;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/image/index.js
var VxeImage = Object.assign({}, image_default, {
  install(app) {
    app.component(image_default.name, image_default);
  }
});
dynamicApp.use(VxeImage);
VxeUI.component(image_default);
var Image2 = VxeImage;
var image_default2 = VxeImage;

// node_modules/vxe-pc-ui/es/image/src/group.js
var import_xe_utils126 = __toESM(require_xe_utils());
var group_default4 = defineComponent({
  name: "VxeImageGroup",
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPreview
    },
    imageStyle: Object,
    size: { type: String, default: () => getConfig().imageGroup.size || getConfig().size },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showDownloadButton
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils126.default.uniqueId();
    const { computeSize } = useSize(props);
    const computeImgList = computed(() => {
      const { urlList } = props;
      if (urlList) {
        return (import_xe_utils126.default.isArray(urlList) ? urlList : [urlList]).map((item) => {
          if (import_xe_utils126.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgStyleOpts = computed(() => {
      return Object.assign({}, getConfig().imageGroup.imageStyle, props.imageStyle);
    });
    const computeMaps = {
      computeSize
    };
    const $xeImageGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    const imageGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $imageGroup: $xeImageGroup }, params));
      }
    };
    const imageGroupPrivateMethods = {
      handleClickImgEvent(evnt, params) {
        const { showPreview, showPrintButton, showDownloadButton } = props;
        const { url } = params;
        const imgList = computeImgList.value;
        if (showPreview && url) {
          openPreviewImage({
            activeIndex: Math.max(0, import_xe_utils126.default.findIndexOf(imgList, (item) => item.url === url)),
            urlList: imgList,
            showPrintButton,
            showDownloadButton
          });
        }
        imageGroupMethods.dispatchEvent("click", { url, urlList: imgList }, evnt);
      }
    };
    Object.assign($xeImageGroup, imageGroupMethods, imageGroupPrivateMethods);
    const renderVN = () => {
      const imgList = computeImgList.value;
      const vSize = computeSize.value;
      const imgStyleOpts = computeImgStyleOpts.value;
      return h("div", {
        class: ["vxe-image-group", {
          [`size--${vSize}`]: vSize
        }]
      }, imgList ? imgList.map((item, index2) => {
        return h(image_default, {
          key: index2,
          src: item.url,
          alt: item.alt,
          width: imgStyleOpts.width,
          height: imgStyleOpts.height
        });
      }) : []);
    };
    $xeImageGroup.renderVN = renderVN;
    provide("$xeImageGroup", $xeImageGroup);
    return $xeImageGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/image-group/index.js
var VxeImageGroup = Object.assign({}, group_default4, {
  install(app) {
    app.component(group_default4.name, group_default4);
  }
});
dynamicApp.use(VxeImageGroup);
VxeUI.component(group_default4);
var ImageGroup = VxeImageGroup;
var image_group_default = VxeImageGroup;

// node_modules/vxe-pc-ui/es/image-preview/index.js
var VxeImagePreview = Object.assign(preview_default, {
  install(app) {
    app.component(preview_default.name, preview_default);
    VxeUI.previewImage = openPreviewImage;
  }
});
dynamicApp.use(VxeImagePreview);
VxeUI.component(preview_default);
var ImagePreview = VxeImagePreview;
var image_preview_default = VxeImagePreview;

// node_modules/vxe-pc-ui/es/input/index.js
var VxeInput = Object.assign(input_default, {
  install(app) {
    app.component(input_default.name, input_default);
  }
});
dynamicApp.use(VxeInput);
VxeUI.component(input_default);
var Input = VxeInput;
var input_default2 = VxeInput;

// node_modules/vxe-pc-ui/es/layout-aside/src/layout-aside.js
var import_xe_utils127 = __toESM(require_xe_utils());
var layout_aside_default = defineComponent({
  name: "VxeLayoutAside",
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutAside.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils127.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeWrapperWidth = computed(() => {
      const { width, collapsed, collapseWidth } = props;
      if (collapsed) {
        if (collapseWidth) {
          return toCssUnit(collapseWidth);
        }
      } else {
        if (width) {
          return toCssUnit(width);
        }
      }
      return "";
    });
    const computeMaps = {
      computeSize
    };
    const $xeLayoutAside = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutAside: $xeLayoutAside }, params));
    };
    const layoutAsideMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutAsidePrivateMethods = {};
    Object.assign($xeLayoutAside, layoutAsideMethods, layoutAsidePrivateMethods);
    const renderVN = () => {
      const { width, collapsed, loading: loading2, padding } = props;
      const wrapperWidth = computeWrapperWidth.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("aside", {
        ref: refElem,
        class: ["vxe-layout-aside", {
          [`size--${vSize}`]: vSize,
          "is--padding": padding,
          "is--default-width": !width,
          "is--collapse": collapsed,
          "is--loading": loading2
        }],
        style: wrapperWidth ? {
          width: wrapperWidth
        } : null
      }, [
        h("div", {
          class: "vxe-layout-aside--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    provide("$xeLayoutAside", $xeLayoutAside);
    $xeLayoutAside.renderVN = renderVN;
    return $xeLayoutAside;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-aside/index.js
var VxeLayoutAside = Object.assign({}, layout_aside_default, {
  install(app) {
    app.component(layout_aside_default.name, layout_aside_default);
  }
});
dynamicApp.use(VxeLayoutAside);
VxeUI.component(layout_aside_default);
var LayoutAside = VxeLayoutAside;
var layout_aside_default2 = VxeLayoutAside;

// node_modules/vxe-pc-ui/es/layout-body/src/layout-body.js
var import_xe_utils128 = __toESM(require_xe_utils());
var layout_body_default = defineComponent({
  name: "VxeLayoutBody",
  props: {
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutBody.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils128.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutBody = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutBody: $xeLayoutBody }, params));
    };
    const layoutBodyMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutBodyPrivateMethods = {};
    Object.assign($xeLayoutBody, layoutBodyMethods, layoutBodyPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, padding } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-body", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-layout-body--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeLayoutBody.renderVN = renderVN;
    return $xeLayoutBody;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-body/index.js
var VxeLayoutBody = Object.assign({}, layout_body_default, {
  install(app) {
    app.component(layout_body_default.name, layout_body_default);
  }
});
dynamicApp.use(VxeLayoutBody);
VxeUI.component(layout_body_default);
var LayoutBody = VxeLayoutBody;
var layout_body_default2 = VxeLayoutBody;

// node_modules/vxe-pc-ui/es/layout-container/src/layout-container.js
var import_xe_utils129 = __toESM(require_xe_utils());
var layout_container_default = defineComponent({
  name: "VxeLayoutContainer",
  props: {
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutContainer.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils129.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutContainer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutContainer: $xeLayoutContainer }, params));
    };
    const layoutContainerMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutContainerPrivateMethods = {};
    Object.assign($xeLayoutContainer, layoutContainerMethods, layoutContainerPrivateMethods);
    const renderVN = () => {
      const { vertical } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-container", {
          [`size--${vSize}`]: vSize,
          "is--vertical": vertical
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutContainer.renderVN = renderVN;
    return $xeLayoutContainer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-container/index.js
var VxeLayoutContainer = Object.assign({}, layout_container_default, {
  install(app) {
    app.component(layout_container_default.name, layout_container_default);
  }
});
dynamicApp.use(VxeLayoutContainer);
VxeUI.component(layout_container_default);
var LayoutContainer = VxeLayoutContainer;
var layout_container_default2 = VxeLayoutContainer;

// node_modules/vxe-pc-ui/es/layout-footer/src/layout-footer.js
var import_xe_utils130 = __toESM(require_xe_utils());
var layout_footer_default = defineComponent({
  name: "VxeLayoutFooter",
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils130.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutFooter = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutFooter: $xeLayoutFooter }, params));
    };
    const layoutFooterMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutFooterPrivateMethods = {};
    Object.assign($xeLayoutFooter, layoutFooterMethods, layoutFooterPrivateMethods);
    const renderVN = () => {
      const { fixed, align } = props;
      const defaultSlot = slots.default;
      return h("footer", {
        ref: refElem,
        class: ["vxe-layout-footer", align ? `align--${align}` : "", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutFooter.renderVN = renderVN;
    return $xeLayoutFooter;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-footer/index.js
var VxeLayoutFooter = Object.assign({}, layout_footer_default, {
  install(app) {
    app.component(layout_footer_default.name, layout_footer_default);
  }
});
dynamicApp.use(VxeLayoutFooter);
VxeUI.component(layout_footer_default);
var LayoutFooter = VxeLayoutFooter;
var layout_footer_default2 = VxeLayoutFooter;

// node_modules/vxe-pc-ui/es/layout-header/src/layout-header.js
var import_xe_utils131 = __toESM(require_xe_utils());
var layout_header_default = defineComponent({
  name: "VxeLayoutHeader",
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils131.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutHeader = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutHeader: $xeLayoutHeader }, params));
    };
    const layoutHeaderMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutHeaderPrivateMethods = {};
    Object.assign($xeLayoutHeader, layoutHeaderMethods, layoutHeaderPrivateMethods);
    const renderVN = () => {
      const { fixed } = props;
      const defaultSlot = slots.default;
      return h("header", {
        ref: refElem,
        class: ["vxe-layout-header", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutHeader.renderVN = renderVN;
    return $xeLayoutHeader;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-header/index.js
var VxeLayoutHeader = Object.assign({}, layout_header_default, {
  install(app) {
    app.component(layout_header_default.name, layout_header_default);
  }
});
dynamicApp.use(VxeLayoutHeader);
VxeUI.component(layout_header_default);
var LayoutHeader = VxeLayoutHeader;
var layout_header_default2 = VxeLayoutHeader;

// node_modules/vxe-pc-ui/es/link/src/link.js
var import_xe_utils132 = __toESM(require_xe_utils());
var link_default = defineComponent({
  name: "VxeLink",
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().link.underline
    },
    /**
     * 
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().link.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils132.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLink = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $link: $xeLink }, params));
    };
    const linkMethods = {
      dispatchEvent: dispatchEvent2
    };
    const linkPrivateMethods = {};
    const clickEvent = (evnt) => {
      dispatchEvent2("click", {}, evnt);
    };
    Object.assign($xeLink, linkMethods, linkPrivateMethods);
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const textContent = import_xe_utils132.default.toValueString(content);
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-link--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        defaultSlot || textContent ? h("span", {
          class: "vxe-link--content"
        }, defaultSlot ? defaultSlot({}) : textContent) : createCommentVNode()
      ];
    };
    const renderVN = () => {
      const { status, target, href, title, underline, routerLink } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          class: ["vxe-link", {
            [`size--${vSize}`]: vSize,
            [`theme--${status}`]: status,
            "is--underline": underline
          }],
          title,
          target,
          to: routerLink,
          onClick: clickEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("a", {
        ref: refElem,
        class: ["vxe-link", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--underline": underline
        }],
        href,
        target,
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeLink.renderVN = renderVN;
    return $xeLink;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/link/index.js
var VxeLink = Object.assign({}, link_default, {
  install(app) {
    app.component(link_default.name, link_default);
  }
});
dynamicApp.use(VxeLink);
VxeUI.component(link_default);
var Link = VxeLink;
var link_default2 = VxeLink;

// node_modules/vxe-pc-ui/es/list-design/src/list-design.js
var import_xe_utils135 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/list-design/render/util.js
var createListDesignActionButton = (btnObj) => {
  return Object.assign({
    name: "",
    icon: "",
    type: "",
    classify: "",
    code: "",
    status: "",
    permissionCode: ""
  }, btnObj);
};

// node_modules/vxe-pc-ui/es/list-design/src/default-setting-data.js
var getDefaultSettingFormData2 = () => {
  return {
    listView: {
      enabled: true
    },
    ganttView: {
      enabled: false
    },
    chartView: {
      enabled: false
    },
    autoFoldFilter: true,
    showCheckbox: "auto",
    showSeq: true,
    showStatistics: true,
    mobileDefaultView: "list",
    pcDefaultView: "list",
    actionButtonList: []
  };
};

// node_modules/vxe-pc-ui/es/list-design/src/layout-preview.js
var import_xe_utils133 = __toESM(require_xe_utils());
var layout_preview_default2 = defineComponent({
  name: "ListDesignLayoutView",
  props: {},
  emits: [],
  setup() {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { reactData: listDesignReactData } = $xeListDesign;
    const refGrid = ref();
    const tableData = ref([]);
    const computeFormItems = computed(() => {
      const { searchFormItems } = listDesignReactData;
      if (searchFormItems.length) {
        return searchFormItems.concat([
          {
            field: "active",
            title: "",
            folding: false,
            collapseNode: searchFormItems.some((item) => item.folding),
            itemRender: {
              name: "VxeButtonGroup",
              options: [
                { content: "", icon: "vxe-icon-search", status: "primary", type: "submit" },
                { content: "", icon: "vxe-icon-repeat", type: "reset" }
              ]
            }
          }
        ]);
      }
      return searchFormItems;
    });
    const computeTableColumn = computed(() => {
      const { formData, listTableColumns } = listDesignReactData;
      const { showSeq, actionButtonList } = formData;
      const columns = [];
      if (showSeq) {
        columns.push({
          type: "seq",
          field: "_seq",
          width: 70
        });
      }
      listTableColumns.forEach((item) => {
        columns.push({
          field: item.field,
          title: item.title,
          visible: item.visible,
          width: item.width
        });
      });
      if (actionButtonList && actionButtonList.length) {
        columns.push({
          field: "_active",
          title: getI18n("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto",
          cellRender: {
            name: "VxeButtonGroup",
            options: []
          }
        });
      }
      return columns;
    });
    const updateColumnWidthEvent = ({ column, resizeWidth }) => {
      const { listTableColumns } = listDesignReactData;
      const rest = import_xe_utils133.default.findTree(listTableColumns, (item) => item.field === column.field, { children: "children" });
      if (rest) {
        const { item } = rest;
        item.width = resizeWidth;
      }
    };
    const updateTableData = () => {
      const { listTableColumns } = listDesignReactData;
      const data = [{}, {}];
      data.forEach((row) => {
        listTableColumns.forEach((column) => {
          row[column.field] = "-";
        });
      });
      tableData.value = data;
    };
    const dataFlag = ref(0);
    watch(() => listDesignReactData.listTableColumns ? listDesignReactData.listTableColumns.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => listDesignReactData.listTableColumns, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      updateTableData();
    });
    onMounted(() => {
      updateTableData();
    });
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog2("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    return () => {
      const { searchFormData, searchFormItems } = listDesignReactData;
      const formItems = computeFormItems.value;
      const tableColumn = computeTableColumn.value;
      return h("div", {
        class: "vxe-list-design--preview"
      }, [
        h("div", {
          class: "vxe-list-design--preview-wrapper"
        }, [
          h("div", {
            class: "vxe-list-design--preview-search"
          }, [
            h("div", {
              class: "vxe-list-design--preview-title"
            }, getI18n("vxe.listDesign.searchTitle")),
            searchFormItems.length ? h(form_default, {
              data: searchFormData,
              items: formItems
            }) : h("div", {
              class: "vxe-list-design--field-configs-empty-data"
            }, [
              h("span", {}, getI18n("vxe.listDesign.search.emptyText"))
            ])
          ]),
          h("div", {
            class: "vxe-list-design--preview-table"
          }, [
            h("div", {
              class: "vxe-list-design--preview-title"
            }, getI18n("vxe.listDesign.listTitle")),
            VxeTableGridComponent ? h(VxeTableGridComponent, {
              ref: refGrid,
              columns: tableColumn,
              data: tableData.value,
              showOverflow: true,
              border: true,
              columnConfig: {
                minWidth: "auto",
                resizable: true
              },
              rowConfig: {
                isHover: true
              },
              scrollX: {
                enabled: false
              },
              scrollY: {
                enabled: false
              },
              onResizableChange: updateColumnWidthEvent
            }) : createCommentVNode()
          ])
        ])
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/list-design/src/default-setting-form.js
var import_xe_utils134 = __toESM(require_xe_utils());
var refWidgetReactConfigMaps2 = ref({});
var DefaultFieldSettingFormComponent = defineComponent({
  name: "DefaultFieldSettingForm",
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { reactData: listDesignReactData } = $xeListDesign;
    const refIsAllChecked = ref(false);
    const refIsAllIndeterminate = ref(false);
    const changeVisible = (item) => {
      item.visible = !item.visible;
      listDesignReactData.listTableColumns = listDesignReactData.listTableColumns.slice(0);
    };
    const removeSearchItem = (item) => {
      const { searchFormItems } = listDesignReactData;
      listDesignReactData.searchFormItems = searchFormItems.filter((obj) => obj.field !== item.field);
    };
    const addSearchEvent = () => {
      const { listTableColumns, searchFormItems } = listDesignReactData;
      const widgetReactConfigMaps = refWidgetReactConfigMaps2.value;
      const allFormItemList = [];
      listTableColumns.forEach((item) => {
        const { cellRender } = item;
        if (cellRender) {
          const conf = searchFormItems.find((conf2) => conf2.field === item.field);
          const name = cellRender.name || "";
          let widgetConfig = widgetReactConfigMaps[name];
          if (!widgetConfig) {
            const compConf = renderer.get(name);
            if (compConf) {
              const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
              if (createWidgetFormConfig) {
                const params = { name, $formDesign: null };
                widgetConfig = createWidgetFormConfig(params) || {};
                widgetReactConfigMaps[name] = widgetConfig;
              }
            }
          }
          if (widgetConfig.query) {
            allFormItemList.push(Object.assign(Object.assign({}, item), { checked: !!conf, isHalf: false, folding: conf ? !!conf.folding : false }));
          }
        }
      });
      refWidgetReactConfigMaps2.value = Object.assign({}, widgetReactConfigMaps);
      const refAllFormItemList = ref(allFormItemList);
      const checkOptionStatus = () => {
        const allFormItemList2 = refAllFormItemList.value;
        refIsAllChecked.value = allFormItemList2.every((item) => item.checked);
        refIsAllIndeterminate.value = !refIsAllChecked.value && allFormItemList2.some((item) => item.checked || item.isHalf);
      };
      const handleOptionCheck = (item) => {
        const allFormItemList2 = refAllFormItemList.value;
        const matchObj = import_xe_utils134.default.findTree(allFormItemList2, (obj) => obj === item);
        if (matchObj && matchObj.parent) {
          const { parent } = matchObj;
          if (parent.children && parent.children.length) {
            parent.checked = parent.children.every((obj) => obj.checked);
            parent.isHalf = !parent.checked && parent.children.some((obj) => obj.checked || obj.isHalf);
            handleOptionCheck(parent);
          }
        }
      };
      const changeCheckboxOption = (item) => {
        const isChecked = !item.checked;
        import_xe_utils134.default.eachTree([item], (obj) => {
          obj.checked = isChecked;
          obj.isHalf = false;
        });
        handleOptionCheck(item);
        checkOptionStatus();
      };
      const allOptionEvent = () => {
        const allFormItemList2 = refAllFormItemList.value;
        const isAll = !refIsAllChecked.value;
        import_xe_utils134.default.eachTree(allFormItemList2, (item) => {
          item.checked = isAll;
          item.isHalf = false;
        });
        refIsAllChecked.value = isAll;
        checkOptionStatus();
      };
      const confirmEvent = () => {
        const allFormItemList2 = refAllFormItemList.value;
        const searchItems = [];
        allFormItemList2.forEach((item) => {
          if (item.checked) {
            searchItems.push({
              field: item.field,
              title: item.title,
              folding: item.folding,
              itemRender: Object.assign({}, item.cellRender)
            });
          }
        });
        $xeListDesign.setSearchItems(searchItems);
      };
      VxeUI.modal.open({
        title: getI18n("vxe.listDesign.search.editPopupTitle"),
        width: 680,
        height: 500,
        showFooter: true,
        escClosable: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: getI18n("vxe.listDesign.searchPopup.saveBtn"),
        showZoom: true,
        resize: true,
        onConfirm: confirmEvent,
        slots: {
          default() {
            const isAllChecked = refIsAllChecked.value;
            const isAllIndeterminate = refIsAllIndeterminate.value;
            const allFormItemList2 = refAllFormItemList.value;
            return h("div", {
              class: "vxe-list-design--field-search-popup"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  h("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  h("col")
                  // h('col', {
                  //   style: {
                  //     width: '140px'
                  //   }
                  // })
                ]),
                h("thead", {}, [
                  h("th", {}, [
                    h("div", {
                      class: ["vxe-list-design--field-search-checkbox-option", {
                        "is--checked": isAllChecked,
                        "is--indeterminate": isAllIndeterminate
                      }],
                      title: getI18n("vxe.table.allTitle"),
                      onClick: allOptionEvent
                    }, [
                      h("span", {
                        class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
                      }),
                      h("span", {
                        class: "vxe-checkbox--label"
                      }, getI18n("vxe.toolbar.customAll"))
                    ])
                  ]),
                  h("th", {}, getI18n("vxe.listDesign.searchPopup.colTitle"))
                  // h('th', {}, '/')
                ]),
                h("tbody", {}, allFormItemList2.map((item) => {
                  const isChecked = item.checked;
                  const isIndeterminate = item.isHalf;
                  return h("tr", {}, [
                    h("td", {
                      class: "vxe-list-design--field-search-option-item col--visible"
                    }, [
                      h("div", {
                        class: ["vxe-list-design--field-search-checkbox-option", {
                          "is--checked": isChecked,
                          "is--indeterminate": isIndeterminate
                        }],
                        title: getI18n("vxe.custom.setting.colVisible"),
                        onClick: () => {
                          changeCheckboxOption(item);
                        }
                      }, [
                        h("span", {
                          class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
                        })
                      ])
                    ]),
                    h("td", {
                      class: "vxe-list-design--field-search-option-item"
                    }, `${item.title || ""}`)
                    // h('td', {}, [
                    //   h(VxeRadioGroupComponent, {
                    //     modelValue: item.folding,
                    //     type: 'button',
                    //     options: foldOptions.value,
                    //     size: 'mini',
                    //     'onUpdate:modelValue' (val) {
                    //       item.folding = val
                    //     }
                    //   })
                    // ])
                  ]);
                }))
              ])
            ]);
          }
        }
      });
    };
    const renderChildOptions = (item) => {
      const { children } = item;
      if (children && children.length) {
        return h("div", {
          class: "vxe-list-design--field-option-inner"
        }, [
          h("div", {
            class: "vxe-list-design--field-sub-option",
            onClick() {
              changeVisible(item);
            }
          }, children.map((child) => {
            const { title, visible: isChecked } = child;
            return h("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": isChecked
              }],
              onClick() {
                changeVisible(child);
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, `${title}`)
            ]);
          }))
        ]);
      }
      return createCommentVNode();
    };
    const renderFieldOptions = () => {
      const { listTableColumns } = listDesignReactData;
      return listTableColumns.map((item) => {
        const { title, visible: isChecked } = item;
        return h("div", {
          class: "vxe-list-design--field-option"
        }, [
          h("div", {
            class: "vxe-list-design--field-option-inner"
          }, [
            h("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": isChecked
              }],
              onClick() {
                changeVisible(item);
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, `${title}`)
            ])
          ]),
          renderChildOptions(item)
        ]);
      });
    };
    return () => {
      return h(form_default, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.listDesign.searchField")
            }, {
              extra() {
                return h(button_default, {
                  mode: "text",
                  status: "primary",
                  icon: getIcon().FORM_DESIGN_PROPS_EDIT,
                  content: getI18n("vxe.listDesign.search.addBtn"),
                  onClick: addSearchEvent
                });
              },
              default() {
                const { searchFormItems } = listDesignReactData;
                return [
                  searchFormItems.length ? h("div", {
                    class: "vxe-list-design--search-item-wrapper"
                  }, [
                    h("div", {
                      class: "vxe-list-design--search-item-list"
                    }, searchFormItems.map((item) => {
                      return h("div", {
                        key: item.field,
                        class: "vxe-list-design--search-item"
                      }, [
                        h("div", {
                          class: "vxe-list-design--search-item-title"
                        }, `${item.title || ""}`),
                        h("div", {
                          class: "vxe-list-design--search-item-btn"
                        }, [
                          h(button_default, {
                            icon: getIcon().LIST_DESIGN_LIST_SETTING_SEARCH_DELETE,
                            mode: "text",
                            status: "error",
                            onClick() {
                              removeSearchItem(item);
                            }
                          })
                        ])
                      ]);
                    }))
                  ]) : h("div", {
                    class: "vxe-list-design--field-configs-empty-data"
                  }, [
                    h("span", {}, getI18n("vxe.listDesign.search.emptyText"))
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.listDesign.listField")
            }, {
              default() {
                return renderFieldOptions();
              }
            })
          ];
        }
      });
    };
  }
});
var DefaultParameterSettingFormComponent = defineComponent({
  name: "DefaultListSettingTabComponent",
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { props: listDesignProps, reactData: listDesignReactData } = $xeListDesign;
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const renderViewList = ref([
      { label: "", value: "list", isExpand: false }
    ]);
    const refSeqOpts = ref([
      { label: "", value: true },
      { label: "", value: false }
    ]);
    const refCheckboxOpts = ref([
      { label: "", value: "auto" },
      { label: "", value: true },
      { label: "", value: false }
    ]);
    const disableView = computed(() => {
      const { formData } = listDesignReactData;
      return [formData.listView.enabled, formData.ganttView.enabled, formData.chartView.enabled].filter((enabled) => enabled).length <= 1;
    });
    const openActiveBtnPopup = (activeBtnObj) => {
      const { formData } = listDesignReactData;
      const { actionCodes } = listDesignProps;
      let btnList = formData.actionButtonList;
      if (!btnList) {
        btnList = [];
      }
      const activeBtnItem = reactive(createListDesignActionButton(activeBtnObj));
      const systemBtnList = systemConfigList.filter((item) => {
        if (actionCodes && actionCodes.length) {
          if (!actionCodes.some((conf) => import_xe_utils134.default.isString(conf) ? item.code === conf : conf.code === item.code)) {
            return false;
          }
        }
        return !btnList.some((obj) => obj.code === item.code);
      });
      const customBtnList = customConfigList.filter((item) => !btnList.some((obj) => obj.code === item.code));
      const btOptions = [];
      if (systemBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = "";
        }
        btOptions.push({ value: "", label: "" });
      }
      if (customBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = "custom";
        }
        btOptions.push({ value: "custom", label: "" });
      }
      const refSystemConfigOptions = computed(() => {
        return systemBtnList.map((item) => {
          const nameConfig = item.name;
          return {
            label: import_xe_utils134.default.toValueString(import_xe_utils134.default.isFunction(nameConfig) ? nameConfig({ name: item.code || "" }) : nameConfig),
            value: item.code
          };
        });
      });
      const refBtnTypeOptions = ref(btOptions);
      VxeUI.modal.open({
        title: "",
        width: 600,
        height: 400,
        showFooter: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: "",
        onConfirm() {
          if (activeBtnItem.type === "custom") {
            btnList.push(activeBtnItem);
          } else {
            btnList.push(activeBtnItem);
          }
          formData.actionButtonList = [...btnList];
        },
        slots: {
          default() {
            return h(form_default, {
              vertical: true,
              titleBold: true
            }, {
              default() {
                return [
                  h(form_item_default, {
                    title: "",
                    span: 24
                  }, {
                    default() {
                      return h(select_default, {
                        modelValue: activeBtnItem.type,
                        options: refBtnTypeOptions.value,
                        "onUpdate:modelValue"(val) {
                          activeBtnItem.type = val;
                        }
                      });
                    }
                  }),
                  h(form_item_default, {
                    title: "",
                    span: 24
                  }, {
                    default() {
                      return h(select_default, {
                        modelValue: activeBtnItem.code,
                        options: refSystemConfigOptions.value,
                        "onUpdate:modelValue"(val) {
                          activeBtnItem.code = val;
                        }
                      });
                    }
                  })
                  // h(VxeFormItemComponent, {
                  //   title: '',
                  //   span: 24
                  // }, {
                  //   default () {
                  //     return h(VxeSelectComponent, {
                  //       modelValue: activeBtnItem.classify,
                  //       options: refBtnClassifyOptions.value,
                  //       'onUpdate:modelValue' (val) {
                  //         activeBtnItem.classify = val
                  //       }
                  //     })
                  //   }
                  // })
                ];
              }
            });
          }
        }
      });
    };
    const renderDefaultCellActionButton = () => {
      return h(form_item_default, {
        title: ""
      }, {
        extra() {
          return h(button_default, {
            mode: "text",
            status: "primary",
            icon: getIcon().FORM_DESIGN_PROPS_ADD,
            content: "",
            onClick() {
              openActiveBtnPopup();
            }
          });
        },
        default() {
          const { formData } = listDesignReactData;
          const btnList = formData.actionButtonList;
          return btnList && btnList.length ? h("div", {
            class: "vxe-list-design--field-configs-wrapper"
          }, btnList.map((btnItem) => {
            let btnIcon = "";
            let btnName = "";
            if (btnItem.type === "custom") {
              btnIcon = btnItem.icon;
              btnName = btnItem.name;
            } else {
              const btnConfig = systemConfigList.find((item) => item.code === btnItem.code);
              if (btnConfig) {
                const nameConfig = btnConfig.name;
                btnIcon = btnConfig.icon || "";
                btnName = import_xe_utils134.default.toValueString(import_xe_utils134.default.isFunction(nameConfig) ? nameConfig({ name: btnConfig.code || "" }) : nameConfig);
              }
            }
            return h("div", {
              class: "vxe-list-design--field-configs-item"
            }, [
              btnIcon ? h("div", {
                class: "vxe-list-design--field-configs-item-icon"
              }, [
                h("i", {
                  class: btnIcon
                })
              ]) : createCommentVNode(),
              h("div", {
                class: "vxe-list-design--field-configs-item-title"
              }, `${btnName || ""}`),
              h("div", {
                class: "vxe-list-design--field-configs-item-btn"
              }, [
                h(button_default, {
                  icon: getIcon().LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE,
                  mode: "text",
                  status: "error",
                  onClick() {
                    formData.actionButtonList = btnList.filter((item) => item !== btnItem);
                  }
                })
              ])
            ]);
          })) : h("div", {
            class: "vxe-list-design--field-configs-empty-data"
          }, [
            h("span", {}, "")
          ]);
        }
      });
    };
    return () => {
      const { showPc, showMobile } = listDesignProps;
      const { formData } = listDesignReactData;
      return h(form_default, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: ""
            }, {
              default() {
                return h("div", {
                  class: "vxe-form-design--widget-form-item-render-view"
                }, renderViewList.value.map((item) => {
                  return h("div", {
                    key: item.value,
                    class: "vxe-form-design--widget-form-item-render-view-item"
                  }, [
                    h(switch_default, {
                      modelValue: formData.listView.enabled,
                      disabled: disableView.value,
                      "onUpdate:modelValue"(val) {
                        formData.listView.enabled = val;
                      }
                    }),
                    h(text_default, {
                      content: item.label,
                      icon: "vxe-icon-table"
                    })
                  ]);
                }));
              }
            }),
            h(form_item_default, {
              title: ""
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    showPc ? h("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      h("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        h(text_default, {
                          icon: getIcon().FORM_DESIGN_PROPS_PC,
                          content: getI18n("vxe.formDesign.widgetProp.displaySetting.pc")
                        })
                      ]),
                      h(select_default, {
                        modelValue: formData.pcDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: renderViewList.value,
                        "onUpdate:modelValue"(val) {
                          formData.pcDefaultView = val;
                        }
                      })
                    ]) : createCommentVNode(),
                    showMobile ? h("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      h("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        h(text_default, {
                          icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                          content: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile")
                        })
                      ]),
                      h(select_default, {
                        modelValue: formData.mobileDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: renderViewList.value,
                        "onUpdate:modelValue"(val) {
                          formData.mobileDefaultView = val;
                        }
                      })
                    ]) : createCommentVNode()
                  ])
                ];
              }
            }),
            // h(VxeFormItemComponent, {
            //   title: ''
            // }, {
            //   default () {
            //     const { formData } = listDesignReactData
            //     return [
            //       h('div', {
            //         class: 'vxe-list-design--widget-form-item-prop-list'
            //       }, [
            //         h('span', {}, ''),
            //         h(VxeRadioGroupComponent, {
            //           modelValue: formData.autoFoldFilter,
            //           options: refFoldOpts.value,
            //           'onUpdate:modelValue' (val) {
            //             formData.autoFoldFilter = val
            //           }
            //         })
            //       ])
            //     ]
            //   }
            // }),
            h(form_item_default, {
              title: ""
            }, {
              default() {
                const { formData: formData2 } = listDesignReactData;
                return [
                  h("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, ""),
                    h(group_default3, {
                      modelValue: formData2.showSeq,
                      options: refSeqOpts.value,
                      "onUpdate:modelValue"(val) {
                        formData2.showSeq = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, ""),
                    h(group_default3, {
                      modelValue: formData2.showStatistics,
                      options: refSeqOpts.value,
                      "onUpdate:modelValue"(val) {
                        formData2.showStatistics = val;
                      }
                    })
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: ""
            }, {
              default() {
                const { formData: formData2 } = listDesignReactData;
                return h(group_default3, {
                  modelValue: formData2.showCheckbox,
                  options: refCheckboxOpts.value,
                  "onUpdate:modelValue"(val) {
                    formData2.showCheckbox = val;
                  }
                });
              }
            }),
            systemConfigList.length || customConfigList.length ? renderDefaultCellActionButton() : createCommentVNode()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/list-design/src/layout-setting.js
var layout_setting_default2 = defineComponent({
  name: "ListDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const activeTab = ref(1);
    return () => {
      return h("div", {
        class: "vxe-list-design--setting"
      }, [
        h("div", {
          class: "vxe-list-design--setting-form"
        }, [
          h(tabs_default, {
            modelValue: activeTab.value,
            titleWidth: "50%",
            titleAlign: "center",
            padding: true,
            class: "vxe-list-design--setting-form-tabs",
            "onUpdate:modelValue"(val) {
              activeTab.value = val;
            }
          }, {
            default() {
              return [
                h(tab_pane_default, {
                  title: getI18n("vxe.listDesign.fieldSettingTab"),
                  icon: getIcon().LIST_DESIGN_FIELD_SETTING,
                  name: 1
                }, {
                  default() {
                    return h(DefaultFieldSettingFormComponent);
                  }
                }),
                h(tab_pane_default, {
                  title: getI18n("vxe.listDesign.listSettingTab"),
                  icon: getIcon().LIST_DESIGN_LIST_SETTING,
                  name: 2
                }, {
                  default() {
                    return h(DefaultParameterSettingFormComponent);
                  }
                })
              ];
            }
          })
        ])
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/list-design/src/list-design.js
var list_design_default = defineComponent({
  name: "VxeListDesign",
  props: {
    size: {
      type: String,
      default: () => getConfig().listDesign.size || getConfig().size
    },
    height: {
      type: [String, Number],
      default: () => getConfig().listDesign.height
    },
    config: Object,
    showPc: {
      type: Boolean,
      default: () => getConfig().listDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().listDesign.showMobile
    },
    actionCodes: Array,
    formRender: Object
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils135.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formData: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeListDesign = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const parseWidgetColumn = (widget) => {
      return {
        title: widget.title,
        field: widget.field,
        visible: !widget.hidden,
        width: "",
        cellRender: {
          name: widget.name,
          props: widget.options
        }
      };
    };
    const parseFormDesignColumns = (config3) => {
      const tableColumns = [];
      if (config3) {
        const { widgetData } = config3;
        if (widgetData) {
          widgetData.forEach((item) => {
            const { name } = item;
            if (name) {
              if (name === "row") {
                item.children.forEach((childItem) => {
                  if (childItem.name) {
                    tableColumns.push(parseWidgetColumn(childItem));
                  }
                });
              } else if (name === "subtable") {
              } else {
                tableColumns.push(parseWidgetColumn(item));
              }
            }
          });
        }
      }
      return tableColumns;
    };
    const configToSearchItems = (searchItems) => {
      if (searchItems) {
        const data = {};
        const items = searchItems.map((item) => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        return {
          items,
          data
        };
      }
      return { items: [], data: {} };
    };
    const configToListColumns = (listColumns) => {
      if (listColumns) {
        return listColumns.map((item) => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: import_xe_utils135.default.clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const loadConfig = (config3) => {
      const { formConfig, searchItems, listColumns } = config3;
      if (formConfig) {
        loadFormConfig(formConfig);
      }
      if (searchItems) {
        setSearchItems(searchItems);
      }
      if (listColumns) {
        reactData.listTableColumns = parseColumnConfigs(listColumns);
      }
      return nextTick();
    };
    const parseColumnConfigs = (listColumns) => {
      return configToListColumns(listColumns);
    };
    const loadFormConfig = (data) => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return nextTick();
    };
    const getSearchItems = () => {
      return reactData.searchFormItems;
    };
    const setSearchItems = (searchItems) => {
      const { data, items } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      return nextTick();
    };
    const getListColumns = () => {
      return reactData.listTableColumns;
    };
    const setListColumns = (listColumns) => {
      reactData.listTableColumns = parseColumnConfigs(listColumns);
      return nextTick();
    };
    const createSettingForm = () => {
      const { actionCodes, formRender } = props;
      let conf = getDefaultSettingFormData2();
      if (actionCodes && actionCodes.length) {
        if (!conf.actionButtonList || !conf.actionButtonList.length) {
          const defActionBtnList = [];
          actionCodes.forEach((item) => {
            if (import_xe_utils135.default.isObject(item) && item.default) {
              const sysItem = systemConfigList.find((obj) => obj.code === item.code);
              if (sysItem) {
                defActionBtnList.push(createListDesignActionButton({
                  type: sysItem.type,
                  code: sysItem.code
                }));
              }
            }
          });
          conf.actionButtonList = defActionBtnList;
        }
      }
      if (formRender && formRender.name) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createListDesignSettingFormConfig : null;
        const params = { name: formRender.name };
        conf = (createFormConfig ? createFormConfig(params) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const clearConfig = () => {
      loadConfig({
        searchItems: [],
        listColumns: []
      });
      initSettingForm();
      return nextTick();
    };
    const listDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $listDesign: $xeListDesign }, params));
      },
      loadFormDesignConfig(config3) {
        const { listTableColumns } = reactData;
        const oldMaps = {};
        import_xe_utils135.default.eachTree(listTableColumns, (item) => {
          oldMaps[item.field] = item;
        }, { children: "children" });
        const columns = parseFormDesignColumns(config3);
        import_xe_utils135.default.eachTree(columns, (item) => {
          const oldItem = oldMaps[item.field];
          if (oldItem) {
            if (oldItem.width) {
              item.width = oldItem.width;
            }
            item.visible = oldItem.visible;
          }
        }, { children: "children" });
        reactData.listTableColumns = columns;
        return nextTick();
      },
      reloadFormDesignConfig(config3) {
        reactData.listTableColumns = parseFormDesignColumns(config3);
        return nextTick();
      },
      getSearchItems,
      setSearchItems,
      getListColumns,
      setListColumns,
      getConfig() {
        return {
          formConfig: reactData.formData,
          searchItems: getSearchItems(),
          listColumns: getListColumns()
        };
      },
      loadConfig,
      reloadConfig(config3) {
        clearConfig();
        return loadConfig(config3);
      },
      clearConfig
    };
    const listDesignPrivateMethods = {};
    Object.assign($xeListDesign, listDesignMethods, listDesignPrivateMethods);
    const renderVN = () => {
      const { height } = props;
      const vSize = computeSize.value;
      const headerSlot = slots.header;
      return h("div", {
        ref: refElem,
        class: ["vxe-list-design", {
          [`size--${vSize}`]: vSize
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-list-design--header"
        }, headerSlot ? headerSlot({}) : []),
        h("div", {
          class: "vxe-list-design--body"
        }, [
          h(layout_preview_default2),
          h(layout_setting_default2)
        ])
      ]);
    };
    provide("$xeListDesign", $xeListDesign);
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    initSettingForm();
    if (props.config) {
      loadConfig(props.config);
    }
    $xeListDesign.renderVN = renderVN;
    return $xeListDesign;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/list-design/render/index.js
renderer.mixin({
  // ActionButtonUpdate: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-edit',
  //       status: 'primary'
  //     }
  //   }
  // },
  // ActionButtonDelete: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-delete',
  //       status: 'error'
  //     }
  //   }
  // }
});

// node_modules/vxe-pc-ui/es/list-design/index.js
var VxeListDesign = Object.assign({}, list_design_default, {
  install(app) {
    app.component(list_design_default.name, list_design_default);
  }
});
var listDesignHandle = {};
dynamicApp.use(VxeListDesign);
VxeUI.component(list_design_default);
VxeUI.listDesignHandle = listDesignHandle;
var ListDesign = VxeListDesign;
var list_design_default2 = VxeListDesign;

// node_modules/vxe-pc-ui/es/list-design/src/list-view.js
var import_xe_utils136 = __toESM(require_xe_utils());
var list_view_default = defineComponent({
  name: "VxeListView",
  props: {
    size: {
      type: String,
      default: () => getConfig().listView.size || getConfig().size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().listView.height
    },
    loading: Boolean,
    formData: Object,
    actionButtons: Array,
    gridOptions: Object,
    gridEvents: Object,
    viewRender: Object
  },
  emits: [
    "cell-action",
    "update:formData",
    "update:actionButtons"
  ],
  setup(props, context) {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const { emit, slots } = context;
    const xID = import_xe_utils136.default.uniqueId();
    const refElem = ref();
    const refGrid = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formConfig: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: [],
      tableColumns: [],
      footerData: [
        {}
        // 
      ]
    });
    const computeGridOptions = computed(() => {
      const { gridOptions } = props;
      const { formConfig, tableColumns, searchFormData, searchFormItems, footerData } = reactData;
      const { showStatistics } = formConfig;
      const gridOpts = gridOptions || {};
      const columnOpts = Object.assign({
        minWidth: 120
      }, gridOpts.columnConfig);
      let proxyOpts;
      if (gridOpts.proxyConfig) {
        proxyOpts = Object.assign({ autoLoad: false }, gridOpts.proxyConfig);
      }
      return Object.assign({}, gridOpts, {
        columns: tableColumns,
        columnConfig: columnOpts,
        showFooter: showStatistics,
        footerData: showStatistics ? footerData : null,
        formConfig: {
          data: searchFormData,
          items: searchFormItems
        },
        proxyConfig: proxyOpts
      });
    });
    const computeGridEvents = computed(() => {
      const { gridEvents } = props;
      const ons = {};
      import_xe_utils136.default.each(gridEvents, (fn2, key) => {
        ons[import_xe_utils136.default.camelCase(`on-${key}`)] = fn2;
      });
      return ons;
    });
    const refMaps = {
      refElem,
      refGrid
    };
    const computeMaps = {
      computeSize
    };
    const $xeListView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const configToSearchItems = (searchItems) => {
      if (searchItems && searchItems.length) {
        const data = {};
        const items = searchItems.map((item) => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        items.push({
          field: "active",
          title: "",
          folding: false,
          collapseNode: searchItems.some((item) => item.folding),
          itemRender: {
            name: "VxeButtonGroup",
            options: [
              { content: "", icon: "vxe-icon-search", status: "primary", type: "submit" },
              { content: "", icon: "vxe-icon-repeat", type: "reset" }
            ]
          }
        });
        return {
          items,
          data
        };
      }
      return { items: [], data: {} };
    };
    const configToListColumns = (listColumns) => {
      if (listColumns) {
        return listColumns.map((item) => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: import_xe_utils136.default.clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const clearConfig = () => {
      emit("update:formData", {});
      Object.assign(reactData, {
        formConfig: {},
        searchFormData: {},
        searchFormItems: [],
        listTableColumns: [],
        tableColumns: [],
        footerData: [
          {}
          // 
        ]
      });
      return nextTick();
    };
    const loadConfig = (config3) => {
      if (config3) {
        const { formConfig, searchItems, listColumns } = config3;
        reactData.formConfig = formConfig || {};
        setSearchItems(searchItems || []);
        loadListColumns(listColumns || []);
      }
      return nextTick();
    };
    const parseForm = (searchItems) => {
      return configToSearchItems(searchItems || []);
    };
    const parseTableColumn = (listColumns, formConfig) => {
      const formOpts = Object.assign({}, formConfig);
      const { showSeq, actionButtonList } = formOpts;
      const columns = [];
      const rowRecord = {};
      const cellActionSlot = slots.cellAction;
      const footerCellSlot = slots.footerCell;
      if (showSeq) {
        columns.push({
          type: "seq",
          field: "_seq",
          fixed: "left",
          width: 70
        });
      }
      configToListColumns(listColumns || []).forEach((conf) => {
        const columnConf = Object.assign({}, conf);
        if (formOpts.showStatistics && footerCellSlot) {
          columnConf.slots = {
            footer: (params) => {
              return footerCellSlot(Object.assign({}, params));
            }
          };
        }
        if (columnConf.field) {
          rowRecord[columnConf.field] = null;
        }
        columns.push(columnConf);
      });
      if (actionButtonList && actionButtonList.length) {
        const actionColumn = {
          field: "_active",
          title: getI18n("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto"
        };
        const btnOptions = [];
        actionButtonList.forEach((btnItem) => {
          if (btnItem.type === "custom") {
            return {
              content: btnItem.name,
              name: btnItem.code,
              icon: btnItem.icon
            };
          }
          const btnConfig = systemConfigList.find((item) => item.code === btnItem.code);
          let btnName = btnItem.name;
          let btnIcon = btnItem.icon;
          let btnStatus = btnItem.status;
          let btnPermissionCode = btnItem.permissionCode;
          let btnClassify = btnItem.classify;
          if (btnConfig) {
            const nameConfig = btnConfig.name;
            btnIcon = btnConfig.icon || "";
            btnStatus = btnConfig.status || "";
            btnPermissionCode = btnConfig.permissionCode || "";
            btnClassify = btnConfig.classify || "";
            btnName = import_xe_utils136.default.toValueString(import_xe_utils136.default.isFunction(nameConfig) ? nameConfig({ name: btnConfig.code || "" }) : nameConfig);
          }
          if (!btnClassify || btnClassify === "cellButton") {
            btnOptions.push({
              content: btnName,
              name: btnItem.code,
              icon: btnIcon,
              status: btnStatus,
              permissionCode: btnPermissionCode
            });
          }
        });
        if (cellActionSlot) {
          actionColumn.slots = {
            default(params) {
              return cellActionSlot(Object.assign(Object.assign({}, params), { buttons: btnOptions }));
            }
          };
        } else {
          actionColumn.cellRender = {
            name: "VxeButtonGroup",
            props: {
              mode: "text"
            },
            options: btnOptions,
            events: {
              click(params, btnParams) {
                const { option: option2 } = btnParams;
                dispatchEvent2("cell-action", Object.assign(Object.assign({}, params), { button: option2 }), btnParams.$event);
              }
            }
          };
        }
        columns.push(actionColumn);
      }
      return { rowRecord, columns, actionButtons: actionButtonList };
    };
    const parseConfig = (config3) => {
      const { formConfig, searchItems, listColumns } = config3 || {};
      const { columns, rowRecord, actionButtons } = parseTableColumn(listColumns || [], formConfig || reactData.formConfig);
      const { data, items } = parseForm(searchItems || []);
      return {
        formData: data,
        formItems: items,
        tableColumns: columns,
        tableRecord: rowRecord,
        actionButtons
      };
    };
    const getTableRecord = (configOrListColumns) => {
      if (import_xe_utils136.default.isArray(configOrListColumns)) {
        const { rowRecord } = parseTableColumn(configOrListColumns, reactData.formConfig);
        return rowRecord;
      }
      if (configOrListColumns) {
        const { formConfig, listColumns } = configOrListColumns;
        const { rowRecord } = parseTableColumn(listColumns || [], formConfig || reactData.formConfig);
        return rowRecord;
      }
      return {};
    };
    const getQueryFilter = () => {
      const { searchFormData, searchFormItems } = reactData;
      const items = [];
      const rest = {
        items,
        type: "and"
      };
      const $grid = refGrid.value;
      if (!$grid) {
        return rest;
      }
      searchFormItems.forEach((item) => {
        const { field } = item;
        const itemValue = searchFormData[field];
        if (itemValue) {
          const condition = [];
          condition.push({
            field,
            value: itemValue,
            match: "exact",
            type: import_xe_utils136.default.isArray(itemValue) ? "array" : ""
          });
          items.push({
            condition,
            type: "and"
          });
        }
      });
      return rest;
    };
    const commitProxy = (code3, ...args) => {
      const $grid = refGrid.value;
      if ($grid) {
        return $grid.commitProxy(code3, ...args);
      }
      return Promise.resolve();
    };
    const loadListColumns = (listColumns) => {
      const { formConfig } = reactData;
      const listTableColumns = listColumns || [];
      const { columns, actionButtons } = parseTableColumn(listTableColumns, formConfig);
      reactData.listTableColumns = listTableColumns;
      reactData.tableColumns = columns;
      emit("update:actionButtons", actionButtons);
      nextTick(() => {
        const gridOptions = computeGridOptions.value;
        if (gridOptions.proxyConfig) {
          commitProxy("reload");
        }
      });
    };
    const setSearchItems = (searchItems) => {
      const { data, items } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      emit("update:formData", data);
      return nextTick();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $listView: $xeListView }, params));
    };
    const listViewMethods = {
      dispatchEvent: dispatchEvent2,
      clearConfig,
      loadConfig,
      parseConfig,
      getTableRecord,
      getQueryFilter,
      commitProxy
    };
    const listViewPrivateMethods = {};
    Object.assign($xeListView, listViewMethods, listViewPrivateMethods);
    const renderVN = () => {
      const { height, loading: loading2 } = props;
      const vSize = computeSize.value;
      const gridSlot = slots.grid;
      const gridOptions = computeGridOptions.value;
      const gridEvents = computeGridEvents.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list-view", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-list-view--body"
        }, [
          gridSlot ? h("div", {
            class: "vxe-list-view--grid-wrapper"
          }, getSlotVNs2(gridSlot({ $listView: $xeListView }))) : VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign({}, gridOptions, gridEvents, {
            ref: refGrid
          }), Object.assign({}, slots, {
            default: void 0
          })) : createCommentVNode()
        ]),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeListView", $xeListView);
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog2("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    $xeListView.renderVN = renderVN;
    return $xeListView;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/list-view/index.js
var VxeListView = Object.assign(list_view_default, {
  install: function(app) {
    app.component(list_view_default.name, list_view_default);
  }
});
dynamicApp.use(VxeListView);
VxeUI.component(list_view_default);
var ListView = VxeListView;
var list_view_default2 = VxeListView;

// node_modules/vxe-pc-ui/es/list/src/list.js
var import_xe_utils137 = __toESM(require_xe_utils());
var list_default = defineComponent({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: () => getConfig().list.size || getConfig().size },
    autoResize: { type: Boolean, default: () => getConfig().list.autoResize },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils137.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const internalData = {
      resizeObserver: void 0,
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    const refElem = ref();
    const refVirtualWrapper = ref();
    const refVirtualBody = ref();
    const refMaps = {
      refElem
    };
    const $xeList = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig().list.scrollY, props.scrollY);
    });
    const computeStyles = computed(() => {
      const { height, maxHeight } = props;
      const style = {};
      if (height) {
        style.height = `${isNaN(height) ? height : `${height}px`}`;
      } else if (maxHeight) {
        style.height = "auto";
        style.maxHeight = `${isNaN(maxHeight) ? maxHeight : `${maxHeight}px`}`;
      }
      return style;
    });
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $list: $xeList }, params));
    };
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, fullData } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad } = reactData;
      const { fullData, scrollYStore } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? import_xe_utils137.default.toNumber(sYOpts.oSize) : browse3.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return nextTick();
    };
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (import_xe_utils137.default.isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (import_xe_utils137.default.isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el2 = refElem.value;
      if (el2.clientWidth && el2.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      dispatchEvent2("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    const loadData = (datas) => {
      const { scrollYStore } = internalData;
      const sYOpts = computeSYOpts.value;
      const fullData = datas || [];
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.fullData = fullData;
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      handleData();
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const listMethods = {
      dispatchEvent: dispatchEvent2,
      loadData,
      /**
       * 
       * @param {Array} datas 
       */
      reloadData(datas) {
        clearScroll();
        return loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xeList, listMethods);
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      loadData(props.data || []);
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        recalculate();
        nextTick(() => setTimeout(() => recalculate()));
      }
    });
    onActivated(() => {
      recalculate().then(() => refreshScroll());
    });
    nextTick(() => {
      globalEvents.on($xeList, "resize", () => {
        recalculate();
      });
      if (props.autoResize) {
        const el2 = refElem.value;
        const resizeObserver = globalResize.create(() => recalculate());
        resizeObserver.observe(el2);
        internalData.resizeObserver = resizeObserver;
      }
      loadData(props.data || []);
    });
    onUnmounted(() => {
      const { resizeObserver } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeList, "resize");
    });
    const renderVN = () => {
      const { className, loading: loading2 } = props;
      const { bodyHeight, topSpaceHeight, items } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list", className ? import_xe_utils137.default.isFunction(className) ? className({ $list: $xeList }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          ref: refVirtualWrapper,
          class: "vxe-list--virtual-wrapper",
          style: styles,
          onScroll: scrollEvent
        }, [
          h("div", {
            class: "vxe-list--y-space",
            style: {
              height: bodyHeight ? `${bodyHeight}px` : ""
            }
          }),
          h("div", {
            ref: refVirtualBody,
            class: "vxe-list--body",
            style: {
              marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
            }
          }, defaultSlot ? defaultSlot({ items, $list: $xeList }) : [])
        ]),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-list--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeList.renderVN = renderVN;
    return $xeList;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/list/index.js
var VxeList = Object.assign(list_default, {
  install(app) {
    app.component(list_default.name, list_default);
  }
});
dynamicApp.use(VxeList);
VxeUI.component(list_default);
var List = VxeList;
var list_default2 = VxeList;

// node_modules/vxe-pc-ui/es/menu/src/menu.js
var import_xe_utils138 = __toESM(require_xe_utils());
var menu_default = defineComponent({
  name: "VxeMenu",
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    collapsed: {
      type: Boolean,
      default: null
    },
    collapseFixed: Boolean,
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    },
    size: {
      type: String,
      default: () => getConfig().image.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils138.default.uniqueId();
    const $xeLayoutAside = inject("$xeLayoutAside", null);
    const refElem = ref();
    const refCollapseElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: !!props.collapsed,
      isEnterCollapse: false,
      collapseStyle: {},
      collapseZindex: 0,
      activeName: props.modelValue,
      menuList: [],
      itemHeight: 1
    });
    const refMaps = {
      refElem
    };
    const computeIsCollapsed = computed(() => {
      const { collapsed } = props;
      if (import_xe_utils138.default.isBoolean(collapsed)) {
        return collapsed;
      }
      if ($xeLayoutAside) {
        return $xeLayoutAside.props.collapsed;
      }
      return false;
    });
    const computeCollapseWidth = computed(() => {
      let collapseWidth = "";
      if ($xeLayoutAside) {
        collapseWidth = $xeLayoutAside.props.collapseWidth || "";
      }
      return collapseWidth;
    });
    const computeCollapseEnterWidth = computed(() => {
      let width = "";
      if ($xeLayoutAside) {
        width = $xeLayoutAside.props.width || "";
      }
      return width;
    });
    const computeMaps = {
      computeSize
    };
    const $xeMenu = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getMenuTitle = (item) => {
      return `${item.title || item.name}`;
    };
    const updateZindex = () => {
      if (reactData.collapseZindex < getLastZIndex2()) {
        reactData.collapseZindex = nextZIndex2();
      }
    };
    const updateActiveMenu = (isDefExpand) => {
      const { activeName } = reactData;
      import_xe_utils138.default.eachTree(reactData.menuList, (item, index2, items, path, parent, nodes) => {
        if (item.itemKey === activeName) {
          nodes.forEach((obj) => {
            obj.isActive = true;
            if (isDefExpand) {
              obj.isExpand = true;
            }
          });
          item.isExactActive = true;
        } else {
          item.isExactActive = false;
          item.isActive = false;
        }
      }, { children: "childList" });
    };
    const updateMenuConfig = () => {
      const { options, expandAll } = props;
      reactData.menuList = import_xe_utils138.default.mapTree(options, (item, index2, items, path, parent) => {
        const objItem = Object.assign(Object.assign({}, item), { parentKey: parent ? parent.name || path.slice(0, path.length - 1).join(",") : "", level: path.length, itemKey: item.name || path.join(","), isExactActive: false, isActive: false, isExpand: import_xe_utils138.default.isBoolean(item.expanded) ? item.expanded : !!expandAll, hasChild: item.children && item.children.length > 0 });
        return objItem;
      }, { children: "children", mapChildren: "childList" });
    };
    const updateCollapseStyle = () => {
      const { collapseFixed } = props;
      if (collapseFixed) {
        nextTick(() => {
          const { isEnterCollapse } = reactData;
          const isCollapsed = computeIsCollapsed.value;
          const collapseEnterWidth = computeCollapseEnterWidth.value;
          const collapseWidth = computeCollapseWidth.value;
          const el2 = refElem.value;
          if (el2) {
            const clientRect = el2.getBoundingClientRect();
            const parentNode = el2.parentNode;
            reactData.collapseStyle = isCollapsed ? {
              top: toCssUnit(clientRect.top),
              left: toCssUnit(clientRect.left),
              height: toCssUnit(parentNode.clientHeight),
              width: isEnterCollapse ? collapseEnterWidth ? toCssUnit(collapseEnterWidth) : "" : collapseWidth ? toCssUnit(collapseWidth) : "",
              zIndex: reactData.collapseZindex
            } : {};
          }
        });
      }
    };
    const handleCollapseMenu = () => {
      const { collapseFixed } = props;
      if (collapseFixed) {
        const { initialized } = reactData;
        const isCollapsed = computeIsCollapsed.value;
        if (isCollapsed) {
          if (!initialized) {
            reactData.initialized = true;
            nextTick(() => {
              const collapseEl = refCollapseElem.value;
              if (collapseEl) {
                document.body.appendChild(collapseEl);
              }
            });
          }
        }
        reactData.isEnterCollapse = false;
        updateZindex();
        updateCollapseStyle();
      }
    };
    const handleClickIconCollapse = (evnt, item) => {
      const { hasChild, isExpand } = item;
      if (hasChild) {
        evnt.stopPropagation();
        evnt.preventDefault();
        item.isExpand = !isExpand;
      }
    };
    const emitModel = (value) => {
      reactData.activeName = value;
      emit("update:modelValue", value);
    };
    const handleClickMenu = (evnt, item) => {
      const { itemKey, routerLink, hasChild } = item;
      if (routerLink) {
        emitModel(itemKey);
        handleMenuMouseleave();
      } else {
        if (hasChild) {
          handleClickIconCollapse(evnt, item);
        } else {
          emitModel(itemKey);
          handleMenuMouseleave();
        }
      }
      dispatchEvent2("click", { menu: item }, evnt);
    };
    const handleMenuMouseenter = () => {
      const { collapseStyle } = reactData;
      const collapseEnterWidth = computeCollapseEnterWidth.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: collapseEnterWidth ? toCssUnit(collapseEnterWidth) : ""
      });
      reactData.isEnterCollapse = true;
    };
    const handleMenuMouseleave = () => {
      const { collapseStyle } = reactData;
      const el2 = refElem.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: el2 ? toCssUnit(el2.offsetWidth) : ""
      });
      reactData.isEnterCollapse = false;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $menu: $xeMenu }, params));
    };
    const menuMethods = {
      dispatchEvent: dispatchEvent2
    };
    const menuPrivateMethods = {};
    Object.assign($xeMenu, menuMethods, menuPrivateMethods);
    const renderMenuTitle = (item) => {
      const { icon, isExpand, hasChild } = item;
      const title = getMenuTitle(item);
      return [
        h("span", {
          class: "vxe-menu--item-link-icon"
        }, icon ? [
          h("i", {
            class: icon
          })
        ] : []),
        h("span", {
          class: "vxe-menu--item-link-title",
          title
        }, title),
        hasChild ? h("span", {
          class: "vxe-menu--item-link-collapse",
          onClick(evnt) {
            handleClickIconCollapse(evnt, item);
          }
        }, [
          h("i", {
            class: isExpand ? getIcon().MENU_ITEM_EXPAND_OPEN : getIcon().MENU_ITEM_EXPAND_CLOSE
          })
        ]) : createCommentVNode()
      ];
    };
    const renderDefaultChildren = (item) => {
      const { itemKey, level, hasChild, isActive, isExactActive, isExpand, routerLink, childList } = item;
      const { isEnterCollapse } = reactData;
      const isCollapsed = computeIsCollapsed.value;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return createCommentVNode();
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive,
          "is--expand": (!isCollapsed || isEnterCollapse) && isExpand
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, {
          default: () => renderMenuTitle(item)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, renderMenuTitle(item)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group"
        }, childList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
      ]);
    };
    const renderCollapseChildren = (item) => {
      const { itemKey, level, hasChild, isActive, isExactActive, routerLink, childList } = item;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return createCommentVNode();
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, {
          default: () => renderMenuTitle(item)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, renderMenuTitle(item)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group"
        }, childList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
      ]);
    };
    const renderVN = () => {
      const { loading: loading2 } = props;
      const { initialized, menuList, collapseStyle, isEnterCollapse } = reactData;
      const vSize = computeSize.value;
      const isCollapsed = computeIsCollapsed.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-menu", {
          [`size--${vSize}`]: vSize,
          "is--collapsed": isCollapsed,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          class: "vxe-menu--item-list"
        }, menuList.map((child) => isCollapsed ? renderCollapseChildren(child) : renderDefaultChildren(child))),
        initialized ? h("div", {
          ref: refCollapseElem,
          class: ["vxe-menu--collapse-wrapper", {
            [`size--${vSize}`]: vSize,
            "is--collapsed": isCollapsed,
            "is--enter": isEnterCollapse,
            "is--loading": loading2
          }],
          style: collapseStyle,
          onMouseenter: handleMenuMouseenter,
          onMouseleave: handleMenuMouseleave
        }, [
          isCollapsed ? h("div", {
            class: "vxe-menu--item-list"
          }, menuList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
        ]) : createCommentVNode(),
        /**
         * 
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    const optFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optFlag.value++;
    });
    watch(() => props.options, () => {
      optFlag.value++;
    });
    watch(optFlag, () => {
      updateMenuConfig();
      updateActiveMenu(true);
    });
    watch(() => props.modelValue, (val) => {
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, () => {
      updateActiveMenu(true);
    });
    watch(computeIsCollapsed, () => {
      handleCollapseMenu();
    });
    onMounted(() => {
      globalEvents.on($xeMenu, "resize", updateCollapseStyle);
      updateCollapseStyle();
    });
    onBeforeUnmount(() => {
      globalEvents.off($xeMenu, "resize");
      const collapseEl = refCollapseElem.value;
      if (collapseEl) {
        const parentNode = collapseEl.parentNode;
        if (parentNode) {
          parentNode.removeChild(collapseEl);
        }
      }
    });
    updateMenuConfig();
    updateActiveMenu(true);
    $xeMenu.renderVN = renderVN;
    return $xeMenu;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/menu/index.js
var VxeMenu = Object.assign({}, menu_default, {
  install(app) {
    app.component(menu_default.name, menu_default);
  }
});
dynamicApp.use(VxeMenu);
VxeUI.component(menu_default);
var Menu = VxeMenu;
var menu_default2 = VxeMenu;

// node_modules/vxe-pc-ui/es/modal/index.js
var import_xe_utils139 = __toESM(require_xe_utils());
function handleModal(options) {
  checkDynamic();
  return new Promise((resolve) => {
    const opts = Object.assign({}, options);
    if (opts.id && allActiveModals.some((comp) => comp.props.id === opts.id)) {
      resolve("exist");
    } else {
      const _onHide = opts.onHide;
      const modalOpts = Object.assign(opts, {
        key: import_xe_utils139.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter((item) => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id2) {
  return import_xe_utils139.default.find(allActiveModals, ($modal) => $modal.props.id === id2);
}
function closeModal(id2) {
  const modals = id2 ? [getModal(id2)] : allActiveModals;
  const restPromises = [];
  modals.forEach(($modal) => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (import_xe_utils139.default.isObject(content)) {
    opts = content;
  } else {
    opts = { content: import_xe_utils139.default.toValueString(content), title };
  }
  return handleModal(Object.assign(Object.assign(Object.assign({}, defOpts), options), opts));
}
function openModal(options) {
  return handleOpen({
    type: "modal"
  }, options);
}
function openAlert(content, title, options) {
  return handleOpen({
    type: "alert",
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: "confirm",
    status: "question",
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: "message",
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: false
  }, content, "", options);
}
function openNotification(content, title, options) {
  return handleOpen({
    type: "notification",
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: true,
    draggable: false,
    position: "top-right",
    width: 320
  }, content, title, options);
}
var ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage,
  notification: openNotification
};
var VxeModal = Object.assign(modal_default, {
  install: function(app) {
    app.component(modal_default.name, modal_default);
  }
});
VxeUI.modal = ModalController;
dynamicApp.use(VxeModal);
VxeUI.component(modal_default);
var Modal = VxeModal;
var modal_default2 = VxeModal;

// node_modules/vxe-pc-ui/es/notice-bar/src/notice-bar.js
var import_xe_utils140 = __toESM(require_xe_utils());
var notice_bar_default = defineComponent({
  name: "VxeNoticeBar",
  props: {
    duration: [String, Number],
    direction: {
      type: String,
      default: () => getConfig().noticeBar.direction
    },
    speed: {
      type: String,
      default: () => getConfig().noticeBar.speed
    },
    content: String,
    vertical: Boolean,
    loop: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => getConfig().noticeBar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils140.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({
      animationDuration: 0
    });
    const refMaps = {
      refElem
    };
    const computeNoticeText = computed(() => {
      const { content } = props;
      return `${content || ""}`;
    });
    const computeMaps = {};
    const $xeNoticeBar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $noticeBar: $xeNoticeBar }, params));
    };
    const noticeBarMethods = {
      dispatchEvent: dispatchEvent2
    };
    const noticeBarPrivateMethods = {};
    const updateAnimationStyle = () => {
      const { speed } = props;
      const contEl = refContentElem.value;
      if (contEl) {
        let sRate = 46;
        if (speed === "fast") {
          sRate = 118;
        } else if (speed === "slow") {
          sRate = 18;
        }
        reactData.animationDuration = Math.ceil(contEl.scrollWidth / sRate);
      }
    };
    Object.assign($xeNoticeBar, noticeBarMethods, noticeBarPrivateMethods);
    const renderVN = () => {
      const { vertical, duration, direction } = props;
      const { animationDuration } = reactData;
      const vSize = computeSize.value;
      const noticeText = computeNoticeText.value;
      const defaultSlot = slots.default;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      return h("div", {
        ref: refElem,
        class: ["vxe-notice-bar", `is--${vertical ? "vertical" : "horizontal"}`, `dir--${direction || "left"}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [
        prefixSlot ? h("div", {
          class: "vxe-notice-bar--prefix"
        }, prefixSlot({})) : renderEmptyElement($xeNoticeBar),
        h("div", {
          class: "vxe-notice-bar--content"
        }, [
          h("div", {
            ref: refContentElem,
            class: "vxe-notice-bar--inner"
          }, [
            h("div", {
              class: "vxe-notice-bar--wrapper",
              style: {
                animationDuration: `${duration ? toCssUnit(duration, "s") : animationDuration}s`
              }
            }, defaultSlot ? defaultSlot({}) : noticeText)
          ])
        ]),
        suffixSlot ? h("div", {
          class: "vxe-notice-bar--suffix"
        }, suffixSlot({})) : renderEmptyElement($xeNoticeBar)
      ]);
    };
    $xeNoticeBar.renderVN = renderVN;
    onMounted(() => {
      globalEvents.on($xeNoticeBar, "resize", updateAnimationStyle);
      updateAnimationStyle();
    });
    onBeforeUnmount(() => {
      globalEvents.off($xeNoticeBar, "resize");
    });
    return $xeNoticeBar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/notice-bar/index.js
var VxeNoticeBar = Object.assign({}, notice_bar_default, {
  install(app) {
    app.component(notice_bar_default.name, notice_bar_default);
  }
});
dynamicApp.use(VxeNoticeBar);
VxeUI.component(notice_bar_default);
var NoticeBar = VxeNoticeBar;
var notice_bar_default2 = VxeNoticeBar;

// node_modules/vxe-pc-ui/es/number-input/index.js
var VxeNumberInput = Object.assign({}, number_input_default, {
  install(app) {
    app.component(number_input_default.name, number_input_default);
  }
});
dynamicApp.use(VxeNumberInput);
VxeUI.component(number_input_default);
var NumberInput = VxeNumberInput;
var number_input_default2 = VxeNumberInput;

// node_modules/vxe-pc-ui/es/select/src/util.js
var import_xe_utils142 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/select/src/option-info.js
var import_xe_utils141 = __toESM(require_xe_utils());
var OptionInfo = class {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: import_xe_utils141.default.uniqueId("option_"),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/vxe-pc-ui/es/select/src/util.js
function isOption(option2) {
  return option2 instanceof OptionInfo;
}
function createOption($xeSelect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeSelect, _vm);
}
function watchOption(props, option2) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      option2.update(name, value);
    });
  });
}
function assembleOption($xeSelect, el2, option2, $xeOptgroup) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const parentElem = el2.parentNode;
  const parentOption = $xeOptgroup ? $xeOptgroup.optionConfig : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils142.default.arrayIndexOf(parentElem.children, el2), 0, option2);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeSelect, option2) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const matchObj = import_xe_utils142.default.findTree(staticOptions, (item) => item.id === option2.id, { children: "options" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}

// node_modules/vxe-pc-ui/es/select/src/optgroup.js
var optgroup_default = defineComponent({
  name: "VxeOptgroup",
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const optionConfig = createOption($xeSelect, props);
    const $xeOptgroup = { optionConfig };
    optionConfig.options = [];
    provide("$xeOptgroup", $xeOptgroup);
    watchOption(props, optionConfig);
    onMounted(() => {
      const el2 = elem.value;
      assembleOption($xeSelect, el2, optionConfig);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: elem
      }, defaultSlot ? defaultSlot({}) : []);
    };
  }
});

// node_modules/vxe-pc-ui/es/optgroup/index.js
var VxeOptgroup = Object.assign(optgroup_default, {
  install: function(app) {
    app.component(optgroup_default.name, optgroup_default);
  }
});
dynamicApp.use(VxeOptgroup);
VxeUI.component(optgroup_default);
var Optgroup = VxeOptgroup;
var optgroup_default2 = VxeOptgroup;

// node_modules/vxe-pc-ui/es/select/src/option.js
var option_default = defineComponent({
  name: "VxeOption",
  props: {
    value: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const $xeOptgroup = inject("$xeOptgroup", null);
    const optionConfig = createOption($xeSelect, props);
    optionConfig.slots = slots;
    watchOption(props, optionConfig);
    onMounted(() => {
      const el2 = elem.value;
      assembleOption($xeSelect, el2, optionConfig, $xeOptgroup);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      return h("div", {
        ref: elem
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/option/index.js
var VxeOption = Object.assign(option_default, {
  install: function(app) {
    app.component(option_default.name, option_default);
  }
});
dynamicApp.use(VxeOption);
VxeUI.component(option_default);
var Option2 = VxeOption;
var option_default2 = VxeOption;

// node_modules/vxe-pc-ui/es/pager/src/pager.js
var import_xe_utils143 = __toESM(require_xe_utils());
var pager_default = defineComponent({
  name: "VxePager",
  props: {
    size: {
      type: String,
      default: () => getConfig().pager.size || getConfig().size
    },
    // 
    layouts: {
      type: Array,
      default: () => getConfig().pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"]
    },
    // 
    currentPage: {
      type: Number,
      default: 1
    },
    // 
    loading: Boolean,
    // 
    pageSize: {
      type: Number,
      default: () => getConfig().pager.pageSize || 10
    },
    // 
    total: { type: Number, default: 0 },
    // 
    pagerCount: {
      type: Number,
      default: () => getConfig().pager.pagerCount || 7
    },
    // 
    pageSizes: {
      type: Array,
      default: () => getConfig().pager.pageSizes || [10, 15, 20, 50, 100]
    },
    // 
    align: {
      type: String,
      default: () => getConfig().pager.align
    },
    // 
    border: {
      type: Boolean,
      default: () => getConfig().pager.border
    },
    // 
    background: {
      type: Boolean,
      default: () => getConfig().pager.background
    },
    // 
    perfect: {
      type: Boolean,
      default: () => getConfig().pager.perfect
    },
    // 
    autoHidden: {
      type: Boolean,
      default: () => getConfig().pager.autoHidden
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().pager.transfer
    },
    className: [String, Function],
    pageSizePlacement: {
      type: String,
      default: () => getConfig().pager.pageSizePlacement
    },
    // 
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils143.default.uniqueId();
    const { computeSize } = useSize(props);
    const $xeGrid = inject("$xeGrid", null);
    const reactData = reactive({
      inpCurrPage: props.currentPage
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const computePageCount = computed(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const computeNumList = computed(() => {
      const { pagerCount } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index2 = 0; index2 < len; index2++) {
        rest.push(index2);
      }
      return rest;
    });
    const computeOffsetNumber = computed(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = computed(() => {
      return props.pageSizes.map((item) => {
        if (import_xe_utils143.default.isNumber(item)) {
          return {
            value: item,
            label: `${getI18n("vxe.pager.pagesize", [item])}`
          };
        }
        return Object.assign({ value: "", label: "" }, item);
      });
    });
    const $xePager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    let pagerMethods = {};
    let pagerPrivateMethods = {};
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const jumpPageEvent = (evnt, currentPage) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const changeCurrentPage = (currentPage, evnt) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const triggerJumpEvent = (params) => {
      const { $event } = params;
      const inputElem = $event.target;
      const inpValue = import_xe_utils143.default.toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = import_xe_utils143.default.toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      changeCurrentPage(current, $event);
    };
    const handleHomePage = (evnt) => {
      const { currentPage } = props;
      if (currentPage > 1) {
        changeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        changeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = (evnt) => {
      const numList = computeNumList.value;
      changeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = (evnt) => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      changeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = (params) => {
      const { value } = params;
      const pageSize = import_xe_utils143.default.toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit("update:currentPage", pageCount);
      }
      emit("update:pageSize", pageSize);
      pagerMethods.dispatchEvent("page-change", { type: "size", pageSize, currentPage }, params.$event);
    };
    const jumpKeydownEvent = (params) => {
      const { $event } = params;
      if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ENTER)) {
        triggerJumpEvent(params);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_UP)) {
        $event.preventDefault();
        handleNextPage($event);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
        $event.preventDefault();
        handlePrevPage($event);
      }
    };
    const renderHomePage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.homePageTitle"),
        onClick: handleHomePage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconHomePage || getIcon().PAGER_HOME]
        })
      ]);
    };
    const renderPrevPage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.prevPageTitle"),
        onClick: handlePrevPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconPrevPage || getIcon().PAGER_PREV_PAGE]
        })
      ]);
    };
    const renderPrevJump = (tagName) => {
      return h(tagName || "button", {
        class: ["vxe-pager--jump-prev", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.prevJumpTitle"),
        onClick: handlePrevJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpPrev || getIcon().PAGER_JUMP_PREV]
        })
      ]);
    };
    const renderNextJump = (tagName) => {
      const pageCount = computePageCount.value;
      return h(tagName || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.nextJumpTitle"),
        onClick: handleNextJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpNext || getIcon().PAGER_JUMP_NEXT]
        })
      ]);
    };
    const renderNextPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.nextPageTitle"),
        onClick: handleNextPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconNextPage || getIcon().PAGER_NEXT_PAGE]
        })
      ]);
    };
    const renderEndPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.endPageTitle"),
        onClick: handleEndPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconEndPage || getIcon().PAGER_END]
        })
      ]);
    };
    const renderNumber = (showJump) => {
      const { currentPage, pagerCount } = props;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        nums.push(h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, 1)
        }, "1"), renderPrevJump("span"));
      }
      numList.forEach((item, index2) => {
        const number2 = startNumber + index2;
        if (number2 <= pageCount) {
          nums.push(h("button", {
            key: number2,
            class: ["vxe-pager--num-btn", {
              "is--active": currentPage === number2
            }],
            type: "button",
            onClick: (evnt) => jumpPageEvent(evnt, number2)
          }, `${number2}`));
        }
      });
      if (showJump && isGt) {
        nums.push(renderNextJump("button"), h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      return h("span", {
        class: "vxe-pager--btn-wrapper"
      }, nums);
    };
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    const renderSizes = () => {
      const sizeList = computeSizeList.value;
      return h(select_default, {
        class: "vxe-pager--sizes",
        modelValue: props.pageSize,
        placement: props.pageSizePlacement,
        transfer: props.transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    const renderJump = (isFull) => {
      const pageCount = computePageCount.value;
      return h("span", {
        class: "vxe-pager--jump"
      }, [
        isFull ? h("span", {
          class: "vxe-pager--goto-text"
        }, getI18n("vxe.pager.goto")) : null,
        h(input_default, {
          class: "vxe-pager--goto",
          modelValue: reactData.inpCurrPage,
          placeholder: getI18n("vxe.pager.gotoTitle"),
          align: "center",
          type: "integer",
          max: pageCount,
          min: 1,
          controls: false,
          onKeydown: jumpKeydownEvent,
          onBlur: triggerJumpEvent,
          "onUpdate:modelValue"(val) {
            reactData.inpCurrPage = val;
          }
        }),
        isFull ? h("span", {
          class: "vxe-pager--classifier-text"
        }, getI18n("vxe.pager.pageClassifier")) : null
      ]);
    };
    const renderFullJump = () => {
      return renderJump(true);
    };
    const renderPageCount = () => {
      const pageCount = computePageCount.value;
      return h("span", {
        class: "vxe-pager--count"
      }, [
        h("span", {
          class: "vxe-pager--separator"
        }),
        h("span", pageCount)
      ]);
    };
    const renderTotal = () => {
      return h("span", {
        class: "vxe-pager--total"
      }, getI18n("vxe.pager.total", [props.total]));
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $pager: $xePager }, params));
    };
    pagerMethods = {
      dispatchEvent: dispatchEvent2,
      homePage() {
        handleHomePage();
        return nextTick();
      },
      endPage() {
        handleEndPage();
        return nextTick();
      },
      prevPage() {
        handlePrevPage();
        return nextTick();
      },
      nextPage() {
        handleNextPage();
        return nextTick();
      },
      prevJump() {
        handlePrevJump();
        return nextTick();
      },
      nextJump() {
        handleNextJump();
        return nextTick();
      }
    };
    pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xePager, pagerMethods, pagerPrivateMethods);
    watch(() => props.currentPage, (value) => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const { align, layouts, className } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push(h("span", {
          class: "vxe-pager--left-wrapper"
        }, slots.left({ $grid: $xeGrid })));
      }
      layouts.forEach((name) => {
        let renderFn;
        switch (name) {
          case "Home":
            renderFn = renderHomePage;
            break;
          case "PrevJump":
            renderFn = renderPrevJump;
            break;
          case "PrevPage":
            renderFn = renderPrevPage;
            break;
          case "Number":
            renderFn = renderNumber;
            break;
          case "JumpNumber":
            renderFn = renderJumpNumber;
            break;
          case "NextPage":
            renderFn = renderNextPage;
            break;
          case "NextJump":
            renderFn = renderNextJump;
            break;
          case "End":
            renderFn = renderEndPage;
            break;
          case "Sizes":
            renderFn = renderSizes;
            break;
          case "FullJump":
            renderFn = renderFullJump;
            break;
          case "Jump":
            renderFn = renderJump;
            break;
          case "PageCount":
            renderFn = renderPageCount;
            break;
          case "Total":
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          if (true) {
            errLog2("vxe.error.notProp", [`layouts -> ${name}`]);
          }
        }
      });
      if (slots.right) {
        childNodes.push(h("span", {
          class: "vxe-pager--right-wrapper"
        }, slots.right({ $grid: $xeGrid })));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-pager", className ? import_xe_utils143.default.isFunction(className) ? className({ $pager: $xePager }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          "is--border": props.border,
          "is--background": props.background,
          "is--perfect": props.perfect,
          "is--hidden": props.autoHidden && pageCount === 1,
          "is--loading": props.loading
        }]
      }, [
        h("div", {
          class: "vxe-pager--wrapper"
        }, childNodes)
      ]);
    };
    $xePager.renderVN = renderVN;
    return $xePager;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/pager/index.js
var VxePager = Object.assign(pager_default, {
  install: function(app) {
    app.component(pager_default.name, pager_default);
  }
});
dynamicApp.use(VxePager);
VxeUI.component(pager_default);
var Pager = VxePager;
var pager_default2 = VxePager;

// node_modules/vxe-pc-ui/es/password-input/src/password-input.js
var import_xe_utils144 = __toESM(require_xe_utils());
var password_input_default = defineComponent({
  name: "VxePasswordInput",
  props: {
    modelValue: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().passwordInput.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: "off"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().passwordInput.size || getConfig().size
    },
    prefixIcon: String,
    suffixIcon: String,
    controls: {
      type: Boolean,
      default: () => getConfig().passwordInput.controls
    },
    // 
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "click",
    "focus",
    "blur",
    "clear",
    "toggle-visible",
    "prefix-click",
    "suffix-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils144.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      showPwd: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xePasswordInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let passwordInputMethods = {};
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInpReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().passwordInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInputType = computed(() => {
      const { showPwd } = reactData;
      if (showPwd) {
        return "text";
      }
      return "password";
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      passwordInputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitInputEvent = (value, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (inpImmediate) {
        handleChange(value, evnt);
      } else {
        passwordInputMethods.dispatchEvent("input", { value }, evnt);
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      passwordInputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils144.default.toValueString(props.modelValue) !== value) {
        passwordInputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = (evnt) => {
      triggerEvent3(evnt);
      const { inputValue } = reactData;
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, inputValue);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      triggerEvent3(evnt);
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const value = inputValue;
      passwordInputMethods.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const passwordToggleEvent = (evnt) => {
      const { readonly, disabled } = props;
      const { showPwd } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      passwordInputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange("", evnt);
      passwordInputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        passwordInputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const clickPrefixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        passwordInputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "vxe-password-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-password-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-password-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-password-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { disabled, suffixIcon, controls } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      return isClearable || controls || suffixSlot || suffixIcon ? h("div", {
        class: ["vxe-password-input--suffix", {
          "is--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils144.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-password-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        controls ? renderPasswordIcon() : createCommentVNode(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-password-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]) : null;
    };
    passwordInputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $passwordInput: $xePasswordInput }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xePasswordInput, passwordInputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
    });
    const renderVN = () => {
      const { className, name, disabled, readonly, autocomplete, autoComplete, maxLength } = props;
      const { inputValue, isActivated } = reactData;
      const vSize = computeSize.value;
      const inpReadonly = computeInpReadonly.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-password-input", className, {
          [`size--${vSize}`]: vSize,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--readonly": readonly,
          "is--disabled": disabled,
          "is--active": isActivated,
          "show--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils144.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-password-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-password-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inpReadonly,
            disabled,
            autocomplete: autocomplete || autoComplete,
            maxlength: maxLength,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode()
      ]);
    };
    $xePasswordInput.renderVN = renderVN;
    return $xePasswordInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/password-input/index.js
var VxePasswordInput = Object.assign({}, password_input_default, {
  install(app) {
    app.component(password_input_default.name, password_input_default);
  }
});
dynamicApp.use(VxePasswordInput);
VxeUI.component(password_input_default);
var PasswordInput = VxePasswordInput;
var password_input_default2 = VxePasswordInput;

// node_modules/vxe-pc-ui/es/print/src/page-break.js
var import_xe_utils146 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/print/src/util.js
var import_xe_utils145 = __toESM(require_xe_utils());
var printFrame;
var defaultHtmlStyle2 = 'body{margin:0;padding:0;color:#000000;font-size:14px;font-family:"Microsoft YaHei",,"MicrosoftJhengHei",,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function createPrintFrame() {
  const frame = document.createElement("iframe");
  frame.className = "vxe-table--print-frame";
  return frame;
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removeFrame);
}
function removeFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write("");
      } catch (e16) {
      }
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function getExportBlobByString(str, type) {
  return new Blob([str], { type: `text/${type};charset=utf-8;` });
}
var printMargin = 80;
function createHtmlPage2(opts, printHtml2) {
  const { customStyle } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.title}</title>`,
    opts._pageBreaks || opts.pageBreaks && opts.pageBreaks.length ? '<style media="print">@page {size: auto;margin: 0mm;}</style>' : "",
    `<style>.vxe-print-slots{display: none;}.vxe-print-page-break.align--center{text-align:center;}.vxe-print-page-break.align--left{text-align:left;}.vxe-print-page-break.align--right{text-align:right;}.vxe-print-page-break--header-title{font-size:1.8em;text-align:center;line-height:${printMargin}px;}.vxe-print-page-break{page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}.vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow: hidden;}.vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;width:${printMargin}px;height:100%;}.vxe-print-page-break--header,.vxe-print-page-break--footer{flex-shrink:0;height:${printMargin}px;width:100%;}.vxe-print-page-break--content{flex-grow: 1;overflow: hidden;}.vxe-print-page-break--footer-page-number{line-height:${printMargin}px;text-align:center;}</style>`,
    "<style>.vxe-table{white-space:pre;}</style>",
    `<style>${defaultHtmlStyle2}</style>`,
    customStyle ? `<style>${customStyle}</style>` : "",
    "</head>",
    "<body>",
    `${printHtml2}`,
    "</body>",
    "</html>"
  ].join("");
}
function handlePrint(opts, printHtml2 = "") {
  const { beforeMethod } = opts;
  if (beforeMethod) {
    printHtml2 = beforeMethod({ content: printHtml2, html: printHtml2, options: opts }) || "";
  }
  printHtml2 = createHtmlPage2(opts, printHtml2);
  const blob = getExportBlobByString(printHtml2, "html");
  return new Promise((resolve) => {
    if (import_xe_utils145.default.browse().msie) {
      removeFrame();
      printFrame = createPrintFrame();
      appendPrintFrame();
      printFrame.contentDocument.write(printHtml2);
      printFrame.contentDocument.execCommand("print");
      setTimeout(() => {
        resolve({
          status: true
        });
      }, 300);
    } else {
      if (!printFrame) {
        printFrame = createPrintFrame();
        printFrame.onload = (evnt) => {
          if (evnt.target.src) {
            evnt.target.contentWindow.onafterprint = afterPrintEvent;
            evnt.target.contentWindow.print();
          }
          resolve({
            status: true
          });
        };
        printFrame.onerror = () => {
          resolve({
            status: false
          });
        };
      }
      appendPrintFrame();
      printFrame.src = URL.createObjectURL(blob);
    }
  });
}
function createPageBreak(opts) {
  const { title, showPageNumber, align, headerAlign, footerAlign, showAllPageTitle } = opts;
  const pageBreaks = opts.pageBreaks || [];
  const pageCount = pageBreaks.length;
  return pageBreaks.map((item, index2) => {
    const bodyHtml = item.bodyHtml;
    const headerHtml = item.headerHtml || opts.headerHtml;
    const footerHtml = item.footerHtml || opts.footerHtml;
    const leftHtml = item.leftHtml || opts.leftHtml;
    const rightHtml = item.rightHtml || opts.rightHtml;
    const currentPage = index2 + 1;
    const params = {
      currentPage,
      pageCount
    };
    return [
      `<div class="${["vxe-print-page-break", align ? `align--${align}` : ""].join(" ")}">`,
      `<div class="${["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""].join(" ")}">`,
      headerHtml ? `${import_xe_utils145.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : title && (showAllPageTitle || !index2) ? `<div class="vxe-print-page-break--header-title">${title || ""}</div>` : "",
      "</div>",
      '<div class="vxe-print-page-break--body">',
      `<div class="vxe-print-page-break--left">${import_xe_utils145.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}</div>`,
      `<div class="vxe-print-page-break--content">${import_xe_utils145.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}</div>`,
      `<div class="vxe-print-page-break--right">${import_xe_utils145.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}</div>`,
      "</div>",
      `<div class="${["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""].join(" ")}">`,
      footerHtml ? `${import_xe_utils145.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : showPageNumber ? `<div class="vxe-print-page-break--footer-page-number">${currentPage}/${pageCount}</div>` : "",
      "</div>",
      "</div>"
    ].join("");
  }).join("");
}
var printHtml = (options) => {
  const opts = Object.assign({ _pageBreaks: false, customLayout: true }, options);
  if (opts.sheetName) {
    opts.title = opts.title || opts.sheetName;
  }
  if (opts.style) {
    opts.customStyle = opts.customStyle || opts.style;
  }
  if (opts.beforePrintMethod) {
    opts.beforeMethod = opts.beforeMethod || opts.beforePrintMethod;
  }
  if (opts.pageBreaks && opts.pageBreaks.length) {
    return handlePrint(opts, createPageBreak(opts));
  }
  const printHtml2 = opts.html || opts.content;
  return handlePrint(opts, printHtml2);
};
function assemblePageBreak($xePageBreak, elem, pageBreakConfig) {
  const staticPageBreaks = $xePageBreak.reactData.staticPageBreaks;
  const parentElem = elem.parentNode;
  if (parentElem && staticPageBreaks) {
    staticPageBreaks.splice(import_xe_utils145.default.arrayIndexOf(parentElem.children, elem), 0, pageBreakConfig);
    $xePageBreak.reactData.staticPageBreaks = staticPageBreaks.slice(0);
  }
}
function destroyPageBreak($xePageBreak, pageBreakConfig) {
  $xePageBreak.reactData.staticPageBreaks = $xePageBreak.reactData.staticPageBreaks.filter((item) => item.id !== pageBreakConfig.id);
}

// node_modules/vxe-pc-ui/es/print/src/page-break.js
var page_break_default = defineComponent({
  name: "VxePrintPageBreak",
  props: {},
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils146.default.uniqueId();
    const $xePrint = inject("$xePrint", null);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const pageBreakConfig = reactive({
      id: xID,
      slots
    });
    const $xePrintPageBreak = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $print: $xePrint }, params));
    };
    const printPageBreakMethods = {
      dispatchEvent: dispatchEvent2
    };
    const printPageBreakPrivateMethods = {};
    Object.assign($xePrintPageBreak, printPageBreakMethods, printPageBreakPrivateMethods);
    if (!$xePrint) {
      $xePrintPageBreak.renderVN = () => {
        return createCommentVNode();
      };
      return $xePrintPageBreak;
    }
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    onMounted(() => {
      const elem = refElem.value;
      if ($xePrint && elem) {
        assemblePageBreak($xePrint, elem, pageBreakConfig);
      }
    });
    onUnmounted(() => {
      if ($xePrint) {
        destroyPageBreak($xePrint, pageBreakConfig);
      }
    });
    $xePrintPageBreak.renderVN = renderVN;
    return $xePrintPageBreak;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/print-page-break/index.js
var VxePrintPageBreak = Object.assign({}, page_break_default, {
  install(app) {
    app.component(page_break_default.name, page_break_default);
  }
});
dynamicApp.use(VxePrintPageBreak);
VxeUI.component(page_break_default);
var PrintPageBreak = VxePrintPageBreak;
var print_page_break_default = VxePrintPageBreak;

// node_modules/vxe-pc-ui/es/print/src/print.js
var import_xe_utils147 = __toESM(require_xe_utils());
var print_default = defineComponent({
  name: "VxePrint",
  props: {
    align: {
      type: String,
      default: () => getConfig().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => getConfig().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => getConfig().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => getConfig().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      type: Boolean,
      default: () => getConfig().print.showAllPageTitle
    },
    customStyle: {
      type: String,
      default: () => getConfig().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils147.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      staticPageBreaks: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xePrint = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $print: $xePrint }, params));
    };
    const printMethods = {
      dispatchEvent: dispatchEvent2,
      print() {
        const elem = refElem.value;
        return printHtml(Object.assign({}, props, {
          _pageBreaks: !!reactData.staticPageBreaks.length,
          html: (elem ? elem.outerHTML : "") || props.html || props.content || ""
        }));
      }
    };
    const printPrivateMethods = {};
    Object.assign($xePrint, printMethods, printPrivateMethods);
    const renderPageConfigLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const pageBreaks = props.pageBreaks || [];
      const pageCount = pageBreaks.length;
      return pageBreaks.map((item, index2) => {
        const bodyHtml = item.bodyHtml;
        const headerHtml = item.headerHtml || props.headerHtml;
        const footerHtml = item.footerHtml || props.footerHtml;
        const leftHtml = item.leftHtml || props.leftHtml;
        const rightHtml = item.rightHtml || props.rightHtml;
        const currentPage = index2 + 1;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerHtml ? `${import_xe_utils147.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : [
            title && (showAllPageTitle || !index2) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, `${import_xe_utils147.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--content"
            }, `${import_xe_utils147.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--right"
            }, `${import_xe_utils147.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}`)
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerHtml ? `${import_xe_utils147.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderPageStaticLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const { staticPageBreaks } = reactData;
      const pageCount = staticPageBreaks.length;
      return staticPageBreaks.map((item, index2) => {
        const itemSlots = item.slots || {};
        const currentPage = index2 + 1;
        const defaultSlot = itemSlots.default;
        const headerSlot = itemSlots.header || slots.header;
        const footerSlot = itemSlots.footer || slots.footer;
        const leftSlot = itemSlots.left || slots.left;
        const rightSlot = itemSlots.right || slots.right;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerSlot ? getSlotVNs2(headerSlot(params)) : [
            title && (showAllPageTitle || !index2) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, leftSlot ? getSlotVNs2(leftSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--content"
            }, defaultSlot ? getSlotVNs2(defaultSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--right"
            }, rightSlot ? getSlotVNs2(rightSlot(params)) : [])
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerSlot ? getSlotVNs2(footerSlot(params)) : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { customLayout } = props;
      const { staticPageBreaks } = reactData;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-print"]
      }, customLayout ? defaultSlot ? getSlotVNs2(defaultSlot({})) : [] : [
        h("div", {
          key: "slot",
          class: "vxe-print-slots"
        }, defaultSlot ? getSlotVNs2(defaultSlot({})) : [])
      ].concat(staticPageBreaks.length ? renderPageStaticLayouts() : renderPageConfigLayouts()));
    };
    $xePrint.renderVN = renderVN;
    provide("$xePrint", $xePrint);
    return $xePrint;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/print/index.js
var VxePrint = Object.assign({}, print_default, {
  install(app) {
    app.component(print_default.name, print_default);
  }
});
dynamicApp.use(VxePrint);
VxeUI.component(print_default);
VxeUI.print = printHtml;
var Print = VxePrint;
var print_default2 = VxePrint;

// node_modules/vxe-pc-ui/es/pulldown/src/pulldown.js
var import_xe_utils148 = __toESM(require_xe_utils());
var pulldown_default = defineComponent({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: getConfig().pulldown.trigger
    },
    size: { type: String, default: () => getConfig().size },
    options: Array,
    className: {
      type: [String, Function],
      default: getConfig().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: getConfig().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "click",
    "option-click",
    "show-panel",
    "hide-panel",
    "visible-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const xID = import_xe_utils148.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refElem = ref();
    const refPulldownContent = ref();
    const refPulldownPanel = ref();
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().pulldown.transfer;
        if (import_xe_utils148.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const refMaps = {
      refElem
    };
    const $xePulldown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex, visiblePanel } = reactData;
        const btnTransfer = computeBtnTransfer.value;
        if (visiblePanel) {
          const targetElem = refPulldownContent.value;
          const panelElem = refPulldownPanel.value;
          if (panelElem && targetElem) {
            const targetHeight = targetElem.offsetHeight;
            const targetWidth = targetElem.offsetWidth;
            const panelHeight = panelElem.offsetHeight;
            const panelWidth = panelElem.offsetWidth;
            const marginSize = 5;
            const panelStyle = {
              zIndex: panelIndex
            };
            const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(targetElem);
            let panelPlacement = "bottom";
            if (btnTransfer) {
              let left = boundingLeft;
              let top = boundingTop + targetHeight;
              if (placement === "top") {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              } else if (!placement) {
                if (top + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = "top";
                  top = boundingTop - panelHeight;
                }
                if (top < marginSize) {
                  panelPlacement = "bottom";
                  top = boundingTop + targetHeight;
                }
              }
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: `${left}px`,
                top: `${top}px`,
                minWidth: `${targetWidth}px`
              });
            } else {
              if (placement === "top") {
                panelPlacement = "top";
                panelStyle.bottom = `${targetHeight}px`;
              } else if (!placement) {
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = "top";
                    panelStyle.bottom = `${targetHeight}px`;
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return nextTick();
      });
    };
    const showPanel = () => {
      if (!reactData.initialized) {
        reactData.initialized = true;
      }
      return new Promise((resolve) => {
        if (!props.disabled) {
          if (internalData.hpTimeout) {
            clearTimeout(internalData.hpTimeout);
          }
          reactData.isActivated = true;
          reactData.isAniVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit("update:modelValue", true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
          dispatchEvent2("visible-change", { visible: true }, null);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const hidePanel = () => {
      reactData.visiblePanel = false;
      dispatchEvent2("visible-change", { visible: false }, null);
      emit("update:modelValue", false);
      return new Promise((resolve) => {
        if (reactData.isAniVisible) {
          internalData.hpTimeout = window.setTimeout(() => {
            reactData.isAniVisible = false;
            nextTick(() => {
              resolve();
            });
          }, 350);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    const handleOptionEvent = (evnt, option2) => {
      if (!option2.disabled) {
        if (reactData.visiblePanel) {
          hidePanel();
          dispatchEvent2("hide-panel", {}, evnt);
        }
        dispatchEvent2("option-click", { option: option2 }, evnt);
      }
    };
    const clickTargetEvent = (evnt) => {
      const { trigger } = props;
      if (trigger === "click") {
        if (reactData.visiblePanel) {
          hidePanel();
          dispatchEvent2("hide-panel", {}, evnt);
        } else {
          showPanel();
          dispatchEvent2("show-panel", {}, evnt);
        }
      }
      dispatchEvent2("click", { $pulldown: $xePulldown }, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            dispatchEvent2("hide-panel", {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const el2 = refElem.value;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          dispatchEvent2("hide-panel", {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = (evnt) => {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        dispatchEvent2("hide-panel", {}, evnt);
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $pulldown: $xePulldown }, params));
    };
    pulldownMethods = {
      dispatchEvent: dispatchEvent2,
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xePulldown, pulldownMethods);
    watch(() => props.modelValue, (value) => {
      reactData.isActivated = !!value;
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    nextTick(() => {
      if (props.modelValue) {
        showPanel();
      }
      globalEvents.on($xePulldown, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xePulldown, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xePulldown, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xePulldown, "mousewheel");
      globalEvents.off($xePulldown, "mousedown");
      globalEvents.off($xePulldown, "blur");
    });
    const renderDefaultPanel = (options) => {
      const optionSlot = slots.option;
      return h("div", {
        class: "vxe-pulldown--panel-list"
      }, options ? options.map((item) => {
        return h("div", {
          class: "vxe-pulldown--panel-item",
          onClick(evnt) {
            handleOptionEvent(evnt, item);
          }
        }, optionSlot ? optionSlot({ $pulldown: $xePulldown, option: item }) : `${item.label || ""}`);
      }) : []);
    };
    const renderVN = () => {
      const { className, options, popupClassName, showPopupShadow, destroyOnClose, disabled } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, panelStyle, panelPlacement } = reactData;
      const btnTransfer = computeBtnTransfer.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return h("div", {
        ref: refElem,
        class: ["vxe-pulldown", className ? import_xe_utils148.default.isFunction(className) ? className({ $pulldown: $xePulldown }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          ref: refPulldownContent,
          class: "vxe-pulldown--content",
          onClick: clickTargetEvent
        }, defaultSlot ? defaultSlot({ $pulldown: $xePulldown }) : []),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refPulldownPanel,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", popupClassName ? import_xe_utils148.default.isFunction(popupClassName) ? popupClassName({ $pulldown: $xePulldown }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--shadow": showPopupShadow,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, [
            h("div", {
              class: "vxe-pulldown--panel-wrapper"
            }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? [
              headerSlot ? h("div", {
                class: "vxe-pulldown--panel-header"
              }, headerSlot({ $pulldown: $xePulldown })) : createCommentVNode(),
              h("div", {
                class: "vxe-pulldown--panel-body"
              }, dropdownSlot ? dropdownSlot({ $pulldown: $xePulldown }) : [
                renderDefaultPanel(options)
              ]),
              footerSlot ? h("div", {
                class: "vxe-pulldown--panel-footer"
              }, footerSlot({ $pulldown: $xePulldown })) : createCommentVNode()
            ] : [])
          ])
        ])
      ]);
    };
    $xePulldown.renderVN = renderVN;
    return $xePulldown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/pulldown/index.js
var VxePulldown = Object.assign(pulldown_default, {
  install: function(app) {
    app.component(pulldown_default.name, pulldown_default);
  }
});
dynamicApp.use(VxePulldown);
VxeUI.component(pulldown_default);
var Pulldown = VxePulldown;
var pulldown_default2 = VxePulldown;

// node_modules/vxe-pc-ui/es/radio/index.js
var VxeRadio = Object.assign(radio_default, {
  install: function(app) {
    app.component(radio_default.name, radio_default);
  }
});
dynamicApp.use(VxeRadio);
VxeUI.component(radio_default);
var Radio = VxeRadio;
var radio_default2 = VxeRadio;

// node_modules/vxe-pc-ui/es/radio-button/index.js
var VxeRadioButton = Object.assign(button_default3, {
  install: function(app) {
    app.component(button_default3.name, button_default3);
  }
});
dynamicApp.use(VxeRadioButton);
VxeUI.component(button_default3);
var RadioButton = VxeRadioButton;
var radio_button_default = VxeRadioButton;

// node_modules/vxe-pc-ui/es/radio-group/index.js
var VxeRadioGroup = Object.assign(group_default3, {
  install: function(app) {
    app.component(group_default3.name, group_default3);
  }
});
dynamicApp.use(VxeRadioGroup);
VxeUI.component(group_default3);
var RadioGroup = VxeRadioGroup;
var radio_group_default = VxeRadioGroup;

// node_modules/vxe-pc-ui/es/rate/index.js
var VxeRate = Object.assign({}, rate_default, {
  install(app) {
    app.component(rate_default.name, rate_default);
  }
});
dynamicApp.use(VxeRate);
VxeUI.component(rate_default);
var Rate = VxeRate;
var rate_default2 = VxeRate;

// node_modules/vxe-pc-ui/es/result/src/result.js
var import_xe_utils149 = __toESM(require_xe_utils());
var result_default = defineComponent({
  name: "VxeResult",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    type: [String, Number],
    status: [String, Number],
    title: [String, Number],
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils149.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeResult = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $result: $xeResult }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeResult, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { imageUrl, imageStyle, icon, title, type, content } = props;
      const status = props.status || type;
      const slotExtra = slots.extra;
      return h("div", {
        ref: "refElem",
        class: ["vxe-result", {
          [`theme--${status}`]: status
        }]
      }, [
        h("div", {
          class: "vxe-result--inner"
        }, [
          imageUrl ? h("div", {
            class: "vxe-result--img-wrapper"
          }, [
            h("img", {
              src: imageUrl,
              style: imageStyle
            })
          ]) : h("div", {
            class: "vxe-result--icon-wrapper"
          }, [
            h("i", {
              class: [icon, type ? getIcon()[`RESULT_${type}`.toLocaleUpperCase()] : ""]
            })
          ]),
          h("div", {
            class: "vxe-result--title-wrapper"
          }, `${title || ""}`),
          h("div", {
            class: "vxe-result--content-wrapper"
          }, `${content || ""}`),
          slotExtra ? h("div", {
            class: "vxe-result--extra-wrapper"
          }, slotExtra({})) : renderEmptyElement($xeResult)
        ])
      ]);
    };
    $xeResult.renderVN = renderVN;
    return $xeResult;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/result/index.js
var VxeResult = Object.assign({}, result_default, {
  install(app) {
    app.component(result_default.name, result_default);
  }
});
dynamicApp.use(VxeResult);
VxeUI.component(result_default);
var Result = VxeResult;
var result_default2 = VxeResult;

// node_modules/vxe-pc-ui/es/row/index.js
var VxeRow = Object.assign({}, row_default, {
  install(app) {
    app.component(row_default.name, row_default);
  }
});
dynamicApp.use(VxeRow);
VxeUI.component(row_default);
var Row = VxeRow;
var row_default2 = VxeRow;

// node_modules/vxe-pc-ui/es/select/index.js
var VxeSelect = Object.assign(select_default, {
  install: function(app) {
    app.component(select_default.name, select_default);
  }
});
dynamicApp.use(VxeSelect);
VxeUI.component(select_default);
var Select = VxeSelect;
var select_default2 = VxeSelect;

// node_modules/vxe-pc-ui/es/slider/index.js
var VxeSlider = Object.assign({}, slider_default, {
  install(app) {
    app.component(slider_default.name, slider_default);
  }
});
dynamicApp.use(VxeSlider);
VxeUI.component(slider_default);
var Slider = VxeSlider;
var slider_default2 = VxeSlider;

// node_modules/vxe-pc-ui/es/steps/src/steps.js
var import_xe_utils150 = __toESM(require_xe_utils());
var steps_default = defineComponent({
  name: "VxeSteps",
  props: {},
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils150.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeSteps = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $steps: $xeSteps }, params));
    };
    const stepsMethods = {
      dispatchEvent: dispatchEvent2
    };
    const stepsPrivateMethods = {};
    Object.assign($xeSteps, stepsMethods, stepsPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem,
        class: "vxe-steps"
      }, []);
    };
    $xeSteps.renderVN = renderVN;
    return $xeSteps;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/steps/index.js
var VxeSteps = Object.assign({}, steps_default, {
  install(app) {
    app.component(steps_default.name, steps_default);
  }
});
dynamicApp.use(VxeSteps);
VxeUI.component(steps_default);
var Steps = VxeSteps;
var steps_default2 = VxeSteps;

// node_modules/vxe-pc-ui/es/switch/index.js
var VxeSwitch = Object.assign(switch_default, {
  install: function(app) {
    app.component(switch_default.name, switch_default);
  }
});
dynamicApp.use(VxeSwitch);
VxeUI.component(switch_default);
var Switch = VxeSwitch;
var switch_default2 = VxeSwitch;

// node_modules/vxe-pc-ui/es/tab-pane/index.js
var VxeTabPane = Object.assign({}, tab_pane_default, {
  install(app) {
    app.component(tab_pane_default.name, tab_pane_default);
  }
});
dynamicApp.use(VxeTabPane);
VxeUI.component(tab_pane_default);
var TabPane = VxeTabPane;
var tab_pane_default2 = VxeTabPane;

// node_modules/vxe-pc-ui/es/table-select/src/table-select.js
var import_xe_utils151 = __toESM(require_xe_utils());
function getRowUniqueId2() {
  return import_xe_utils151.default.uniqueId("row_");
}
var table_select_default = defineComponent({
  name: "VxeTableSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils151.default.eqNull(getConfig().tableSelect.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().tableSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    prefixIcon: String,
    placement: String,
    columns: Array,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    popupConfig: Object,
    gridConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils151.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refGridWrapper = ref();
    const refOptionPanel = ref();
    const refGrid = ref();
    const reactData = reactive({
      initialized: false,
      tableColumns: [],
      fullOptionList: [],
      fullRowMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined,
      // vpTimeout: undefined
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils151.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeRowOpts = computed(() => {
      const gridOpts = computeGridOpts.value;
      return Object.assign({}, gridOpts.rowConfig, {
        isCurrent: true
      });
    });
    const computeRowKeyField = computed(() => {
      const rowOpts = computeRowOpts.value;
      return rowOpts.keyField || "_X_ROW_KEY";
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computePopupOpts = computed(() => {
      return Object.assign({}, getConfig().tableSelect.popupConfig, props.popupConfig);
    });
    const computeGridOpts = computed(() => {
      return Object.assign({}, getConfig().tableSelect.gridConfig, props.gridConfig, { data: void 0, columns: void 0 });
    });
    const computeSelectLabel = computed(() => {
      const { modelValue } = props;
      const { fullRowMaps } = reactData;
      const labelField = computeLabelField.value;
      return (import_xe_utils151.default.isArray(modelValue) ? modelValue : [modelValue]).map((val) => {
        const cacheItem = fullRowMaps[val];
        return cacheItem ? cacheItem.item[labelField] : val;
      }).join(", ");
    });
    const computePopupWrapperStyle = computed(() => {
      const popupOpts = computePopupOpts.value;
      const { height, width } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTableSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tableSelect: $xeTableSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const tableSelectMethods = {
      dispatchEvent: dispatchEvent2
    };
    const tableSelectPrivateMethods = {};
    const getRowid2 = (option2) => {
      const nodeKeyField = computeRowKeyField.value;
      const rowid = option2[nodeKeyField];
      return rowid ? encodeURIComponent(rowid) : "";
    };
    const getRowsByValue = (modelValue) => {
      const { fullRowMaps } = reactData;
      const rows = [];
      const vals = import_xe_utils151.default.eqNull(modelValue) ? [] : import_xe_utils151.default.isArray(modelValue) ? modelValue : [modelValue];
      vals.forEach((val) => {
        const cacheItem = fullRowMaps[val];
        if (cacheItem) {
          rows.push(cacheItem.item);
        }
      });
      return rows;
    };
    const updateModel = (modelValue) => {
      const { multiple } = props;
      nextTick(() => {
        const $grid = refGrid.value;
        if ($grid) {
          const selectList = getRowsByValue(modelValue);
          if (selectList.length) {
            if (multiple) {
              $grid.setCheckboxRow(selectList, true);
            } else {
              $grid.setRadioRow(selectList[0]);
            }
          }
        }
      });
    };
    const loadTableColumn = (columns) => {
      const { multiple } = props;
      const tableCols = [];
      if (multiple) {
        tableCols.push({
          type: "checkbox",
          width: 70
        });
      } else {
        tableCols.push({
          type: "radio",
          width: 70
        });
      }
      reactData.tableColumns = tableCols.concat(columns || []);
    };
    const cacheDataMap = () => {
      const { options } = props;
      const rowKeyField = computeRowKeyField.value;
      const valueField = computeValueField.value;
      const gridOpts = computeGridOpts.value;
      const { treeConfig } = gridOpts;
      const rowMaps = {};
      const keyMaps = {};
      if (treeConfig) {
      } else {
        import_xe_utils151.default.arrayEach(options || [], (item, index2, items) => {
          let rowid = getRowid2(item);
          if (!rowid) {
            rowid = getRowUniqueId2();
          }
          if (keyMaps[rowid]) {
            errLog2("vxe.error.repeatKey", [rowKeyField, rowid]);
          }
          keyMaps[rowid] = true;
          const value = item[valueField];
          if (rowMaps[value]) {
            errLog2("vxe.error.repeatKey", [valueField, value]);
          }
          rowMaps[value] = { item, index: index2, items, parent: null, nodes: [] };
        });
      }
      reactData.fullOptionList = options || [];
      reactData.fullRowMaps = rowMaps;
      updateModel(props.modelValue);
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el2) {
          const targetHeight = el2.offsetHeight;
          const targetWidth = el2.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(el2);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2 } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        if (internalData.vpTimeout) {
          clearTimeout(internalData.vpTimeout);
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        internalData.vpTimeout = setTimeout(() => {
          reactData.visiblePanel = true;
          updateModel(props.modelValue);
          internalData.vpTimeout = void 0;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      if (internalData.vpTimeout) {
        clearTimeout(internalData.vpTimeout);
      }
      if (internalData.hpTimeout) {
        clearTimeout(internalData.hpTimeout);
      }
      internalData.hpTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
        internalData.hpTimeout = void 0;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      const { fullRowMaps } = reactData;
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        const cacheItem = fullRowMaps[selectValue];
        dispatchEvent2("change", { value: selectValue, row: cacheItem ? cacheItem.item : null }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent2("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent2("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent2("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent2("blur", {}, evnt);
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const radioChangeEvent = (params) => {
      const { $event, row } = params;
      const valueField = computeValueField.value;
      const value = row[valueField];
      changeEvent($event, value);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { $grid, $event } = params;
      const valueField = computeValueField.value;
      const checkboxRecords = $grid.getCheckboxRecords();
      const value = checkboxRecords.map((row) => {
        return row[valueField];
      });
      changeEvent($event, value);
    };
    const checkboxAllEvent = (params) => {
      checkboxChangeEvent(params);
    };
    Object.assign($xeTableSelect, tableSelectMethods, tableSelectPrivateMethods);
    const renderVN = () => {
      const { className, options, loading: loading2 } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, tableColumns } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupOpts = computePopupOpts.value;
      const { className: popupClassName } = popupOpts;
      const gridOpts = computeGridOpts.value;
      const rowOpts = computeRowOpts.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-table-select--readonly", className]
        }, [
          h("span", {
            class: "vxe-table-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table-select", className ? import_xe_utils151.default.isFunction(className) ? className({ $tableSelect: $xeTableSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: loading2 ? getI18n("vxe.select.loadingText") : props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TABLE_SELECT_LOADED : visiblePanel ? getIcon().TABLE_SELECT_OPEN : getIcon().TABLE_SELECT_CLOSE,
          modelValue: loading2 ? "" : selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-table-select--panel", popupClassName ? import_xe_utils151.default.isFunction(popupClassName) ? popupClassName({ $tableSelect: $xeTableSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-table-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-table-select--panel-header"
              }, headerSlot({})) : renderEmptyElement($xeTableSelect),
              h("div", {
                class: "vxe-table-select--panel-body"
              }, [
                h("div", {
                  ref: refGridWrapper,
                  class: "vxe-table-select-grid--wrapper",
                  style: popupWrapperStyle
                }, [
                  VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign(Object.assign({}, gridOpts), { class: "vxe-table-select--grid", ref: refGrid, rowConfig: rowOpts, data: options, columns: tableColumns, height: "100%", autoResize: true, onRadioChange: radioChangeEvent, onCheckboxChange: checkboxChangeEvent, onCheckboxAll: checkboxAllEvent }), Object.assign({}, slots, {
                    header: void 0,
                    footer: void 0,
                    prefixSlot: void 0
                  })) : renderEmptyElement($xeTableSelect)
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-table-select--panel-footer"
              }, footerSlot({})) : renderEmptyElement($xeTableSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => props.options, () => {
      cacheDataMap();
    });
    watch(() => props.columns, (val) => {
      loadTableColumn(val || []);
    });
    watch(() => props.modelValue, (val) => {
      updateModel(val);
    });
    loadTableColumn(props.columns || []);
    cacheDataMap();
    onMounted(() => {
      globalEvents.on($xeTableSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTableSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTableSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTableSelect, "mousewheel");
      globalEvents.off($xeTableSelect, "mousedown");
      globalEvents.off($xeTableSelect, "blur");
    });
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog2("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    provide("$xeTableSelect", $xeTableSelect);
    $xeTableSelect.renderVN = renderVN;
    return $xeTableSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/table-select/index.js
var VxeTableSelect = Object.assign({}, table_select_default, {
  install(app) {
    app.component(table_select_default.name, table_select_default);
  }
});
dynamicApp.use(VxeTableSelect);
VxeUI.component(table_select_default);
var TableSelect = VxeTableSelect;
var table_select_default2 = VxeTableSelect;

// node_modules/vxe-pc-ui/es/tabs/index.js
var VxeTabs = Object.assign({}, tabs_default, {
  install(app) {
    app.component(tabs_default.name, tabs_default);
  }
});
dynamicApp.use(VxeTabs);
VxeUI.component(tabs_default);
var Tabs = VxeTabs;
var tabs_default2 = VxeTabs;

// node_modules/vxe-pc-ui/es/tag/src/tag.js
var import_xe_utils152 = __toESM(require_xe_utils());
var tag_default = defineComponent({
  name: "VxeTag",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tag.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils152.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTag = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tag: $xeTag }, params));
    };
    const tagMethods = {
      dispatchEvent: dispatchEvent2
    };
    const tagPrivateMethods = {};
    const clickEvent = (evnt) => {
      dispatchEvent2("click", {}, evnt);
    };
    Object.assign($xeTag, tagMethods, tagPrivateMethods);
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-tag--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        h("span", {
          class: "vxe-tag--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils152.default.toValueString(content))
      ];
    };
    const renderVN = () => {
      const { status, title } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        class: ["vxe-tag", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status
        }],
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeTag.renderVN = renderVN;
    return $xeTag;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tag/index.js
var VxeTag = Object.assign({}, tag_default, {
  install(app) {
    app.component(tag_default.name, tag_default);
  }
});
dynamicApp.use(VxeTag);
VxeUI.component(tag_default);
var Tag = VxeTag;
var tag_default2 = VxeTag;

// node_modules/vxe-pc-ui/es/text-ellipsis/src/text-ellipsis.js
var import_xe_utils153 = __toESM(require_xe_utils());
var text_ellipsis_default = defineComponent({
  name: "VxeTextEllipsis",
  props: {
    content: [String, Number],
    lineClamp: [String, Number],
    status: String,
    title: [String, Number],
    loading: Boolean,
    offsetLength: [String, Number],
    size: {
      type: String,
      default: () => getConfig().textEllipsis.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils153.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const realityElem = ref();
    const reactData = reactive({
      resizeObserver: null,
      visibleLen: 0
    });
    const refMaps = {
      refElem
    };
    const computeTextLineClamp = computed(() => {
      return import_xe_utils153.default.toNumber(props.lineClamp);
    });
    const computeTextContent = computed(() => {
      return import_xe_utils153.default.toValueString(props.content);
    });
    const computeTextOffsetLength = computed(() => {
      return props.offsetLength ? import_xe_utils153.default.toNumber(props.offsetLength) : 0;
    });
    const computeVisibleContent = computed(() => {
      const { visibleLen } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      const textContent = computeTextContent.value;
      const textOffsetLength = computeTextOffsetLength.value;
      if (textLineClamp > 1) {
        if (textContent.length > visibleLen) {
          return `${textContent.slice(0, Math.max(1, visibleLen - 3 + textOffsetLength))}...`;
        }
        return textContent;
      }
      return textContent;
    });
    const computeMaps = {};
    const $xeTextEllipsis = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $textEllipsis: $xeTextEllipsis }, params));
    };
    const calculateFont = (targetWidth) => {
      const el2 = refElem.value;
      const ryEl = realityElem.value;
      if (el2 && ryEl) {
        let fontSize = 12;
        try {
          fontSize = Math.max(10, import_xe_utils153.default.toNumber(getComputedStyle(ryEl).fontSize));
        } catch (e16) {
        }
        const textContent = computeTextContent.value;
        let currIndex = Math.floor(targetWidth / fontSize);
        let currStr = textContent.slice(0, currIndex);
        ryEl.textContent = currStr;
        reactData.visibleLen = currStr.length;
        let maxCount = 0;
        while (targetWidth > ryEl.clientWidth && maxCount < 30) {
          maxCount++;
          const offsetIndex = Math.floor((targetWidth - ryEl.clientWidth) / fontSize);
          if (offsetIndex) {
            currIndex += offsetIndex;
            currStr = textContent.slice(0, currIndex);
            ryEl.textContent = currStr;
            reactData.visibleLen = currStr.length;
          } else {
            break;
          }
        }
        ryEl.textContent = "";
        ryEl.style.display = "";
        ryEl.style.position = "";
        ryEl.style.top = "";
        ryEl.style.left = "";
      }
    };
    const updateStyle = () => {
      const el2 = refElem.value;
      const ryEl = realityElem.value;
      const textContent = computeTextContent.value;
      const textLineClamp = computeTextLineClamp.value;
      if (el2 && ryEl) {
        const cWidth = el2.clientWidth;
        ryEl.style.display = "block";
        ryEl.style.position = "absolute";
        ryEl.style.top = "-3000px";
        ryEl.style.left = "-3000px";
        ryEl.textContent = textContent;
        const sWidth = ryEl.offsetWidth;
        const targetWidth = Math.floor(cWidth * textLineClamp);
        if (targetWidth > sWidth) {
          reactData.visibleLen = textContent.length;
        } else {
          calculateFont(targetWidth);
        }
      } else {
        reactData.visibleLen = textContent.length;
      }
    };
    const textEllipsisMethods = {
      dispatchEvent: dispatchEvent2
    };
    const clickEvent = () => {
      emit("click", {});
    };
    const initObserver = () => {
      const { resizeObserver } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      if (!resizeObserver) {
        const el2 = refElem.value;
        if (el2 && textLineClamp > 1) {
          if (window.ResizeObserver) {
            const observerObj = new window.ResizeObserver(import_xe_utils153.default.throttle(() => {
              updateStyle();
            }, 300, { leading: true, trailing: true }));
            observerObj.observe(el2);
            reactData.resizeObserver = observerObj;
          }
        }
      }
    };
    const textEllipsisPrivateMethods = {};
    Object.assign($xeTextEllipsis, textEllipsisMethods, textEllipsisPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, status, title } = props;
      const vSize = computeSize.value;
      const visibleContent = computeVisibleContent.value;
      const textLineClamp = computeTextLineClamp.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-text-ellipsis", textLineClamp > 1 ? "is--multi" : "is--single", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--loading": loading2
        }],
        title,
        onClick: clickEvent
      }, [
        h("span", {
          ref: realityElem,
          class: "vxe-text-ellipsis-reality"
        }),
        h("span", {
          class: "vxe-text-ellipsis-content"
        }, visibleContent)
      ]);
    };
    watch(() => props.content, () => {
      updateStyle();
    });
    watch(() => props.lineClamp, () => {
      initObserver();
      updateStyle();
    });
    onMounted(() => {
      initObserver();
      updateStyle();
    });
    onBeforeUnmount(() => {
      const { resizeObserver } = reactData;
      const el2 = refElem.value;
      const ryEl = realityElem.value;
      if (ryEl) {
        ryEl.textContent = "";
      }
      if (resizeObserver) {
        if (el2) {
          resizeObserver.unobserve(el2);
        }
        resizeObserver.disconnect();
        reactData.resizeObserver = null;
      }
    });
    $xeTextEllipsis.renderVN = renderVN;
    return $xeTextEllipsis;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/text-ellipsis/index.js
var VxeTextEllipsis = Object.assign({}, text_ellipsis_default, {
  install(app) {
    app.component(text_ellipsis_default.name, text_ellipsis_default);
  }
});
dynamicApp.use(VxeTextEllipsis);
VxeUI.component(text_ellipsis_default);
var TextEllipsis = VxeTextEllipsis;
var text_ellipsis_default2 = VxeTextEllipsis;

// node_modules/vxe-pc-ui/es/text/index.js
var VxeText = Object.assign({}, text_default, {
  install(app) {
    app.component(text_default.name, text_default);
  }
});
dynamicApp.use(VxeText);
VxeUI.component(text_default);
var Text2 = VxeText;
var text_default2 = VxeText;

// node_modules/vxe-pc-ui/es/textarea/index.js
var VxeTextarea = Object.assign(textarea_default, {
  install: function(app) {
    app.component(textarea_default.name, textarea_default);
  }
});
dynamicApp.use(VxeTextarea);
VxeUI.component(textarea_default);
var Textarea = VxeTextarea;
var textarea_default2 = VxeTextarea;

// node_modules/vxe-pc-ui/es/tip/index.js
var VxeTip = Object.assign({}, tip_default, {
  install(app) {
    app.component(tip_default.name, tip_default);
    app.component("VxeTipsComponent", tip_default);
  }
});
dynamicApp.use(VxeTip);
VxeUI.component(tip_default);
var Tips = VxeTip;
var Tip = VxeTip;
var tip_default2 = VxeTip;

// node_modules/vxe-pc-ui/es/tooltip/index.js
var VxeTooltip = Object.assign({}, tooltip_default, {
  install(app) {
    app.component(tooltip_default.name, tooltip_default);
  }
});
dynamicApp.use(VxeTooltip);
VxeUI.component(tooltip_default);
var Tooltip = VxeTooltip;
var tooltip_default2 = VxeTooltip;

// node_modules/vxe-pc-ui/es/tree/index.js
var VxeTree = Object.assign({}, tree_default, {
  install(app) {
    app.component(tree_default.name, tree_default);
  }
});
dynamicApp.use(VxeTree);
VxeUI.component(tree_default);
var Tree = VxeTree;
var tree_default2 = VxeTree;

// node_modules/vxe-pc-ui/es/tree-select/index.js
var VxeTreeSelect = Object.assign({}, tree_select_default, {
  install(app) {
    app.component(tree_select_default.name, tree_select_default);
  }
});
dynamicApp.use(VxeTreeSelect);
VxeUI.component(tree_select_default);
var TreeSelect = VxeTreeSelect;
var tree_select_default2 = VxeTreeSelect;

// node_modules/vxe-pc-ui/es/upload/index.js
var VxeUpload = Object.assign({}, upload_default, {
  install(app) {
    app.component(upload_default.name, upload_default);
  }
});
dynamicApp.use(VxeUpload);
VxeUI.component(upload_default);
VxeUI.saveFile = saveLocalFile;
VxeUI.readFile = readLocalFile;
var Upload = VxeUpload;
var upload_default2 = VxeUpload;

// node_modules/vxe-pc-ui/es/watermark/src/watermark.js
var import_xe_utils155 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/watermark/src/util.js
var import_xe_utils154 = __toESM(require_xe_utils());
var canvasEl = null;
var fontEl = null;
var fontCacheMaps = {};
function getMarkCanvas() {
  if (!canvasEl) {
    canvasEl = document.createElement("canvas");
    canvasEl.style.position = "absolute";
    canvasEl.style.top = "0";
    canvasEl.style.left = "0";
  }
  return canvasEl;
}
function removeMarkElement(elem) {
  if (elem) {
    const parentEl2 = elem.parentNode;
    if (parentEl2) {
      parentEl2.removeChild(elem);
    }
  }
}
function calcFontWH(text, fontSize) {
  const fKey = `${fontSize}_${text}`;
  if (!fontCacheMaps[fKey]) {
    if (!fontEl) {
      fontEl = document.createElement("span");
    }
    if (!fontEl.parentNode) {
      document.body.append(fontEl);
    }
    fontEl.textContent = text;
    fontEl.style.fontSize = toCssUnit(fontSize);
    const width = fontEl.offsetWidth;
    const height = fontEl.offsetHeight;
    fontCacheMaps[fKey] = {
      width,
      height
    };
  }
  return fontCacheMaps[fKey];
}
function calcContentWH(contList) {
  let contentWidth = 0;
  let contentHeight = 0;
  contList.forEach((item) => {
    contentWidth = Math.max(item.width, contentWidth);
    contentHeight = Math.max(item.height, contentHeight);
  });
  return {
    contentWidth,
    contentHeight
  };
}
function calcCanvasWH(contentWidth, opts) {
  const { gap } = opts;
  const [gapX = 0, gapY = 0] = gap ? import_xe_utils154.default.isArray(gap) ? gap : [gap, gap] : [];
  const canvasWidth = contentWidth + import_xe_utils154.default.toNumber(gapX);
  const canvasHeight = contentWidth + import_xe_utils154.default.toNumber(gapY);
  return {
    canvasWidth,
    canvasHeight
  };
}
function getFontConf(item, key, opts) {
  return (item.font ? item.font[key] : "") || (opts.font ? opts.font[key] : "");
}
function createMarkFont(contConf, defaultFontSize, opts) {
  const { offset } = opts;
  const text = import_xe_utils154.default.toValueString(contConf.textContent);
  const fontSize = import_xe_utils154.default.toNumber(getFontConf(contConf, "fontSize", opts) || defaultFontSize) || 14;
  const [offsetX = 0, offsetY = 0] = offset ? import_xe_utils154.default.isArray(offset) ? offset : [offset, offset] : [];
  const { width, height } = calcFontWH(text, fontSize);
  return {
    text,
    fontSize,
    font: contConf.font,
    width: width + import_xe_utils154.default.toNumber(offsetX),
    height: height + import_xe_utils154.default.toNumber(offsetY)
  };
}
function drayFont(ctx, item, opts) {
  const fontWeight = getFontConf(item, "fontWeight", opts);
  ctx.fillStyle = `${getFontConf(item, "color", opts) || "rgba(0, 0, 0, 0.15)"}`;
  ctx.font = [
    getFontConf(item, "fontStyle", opts) || "normal",
    fontWeight === "bold" || fontWeight === "bolder" ? "bold" : "",
    toCssUnit(item.fontSize),
    getFontConf(item, "fontFamily", opts) || "sans-serif"
  ].join(" ");
}
function getContentUrl(content, defaultFontSize, options) {
  const opts = Object.assign({}, options);
  const { rotate } = opts;
  const deg = import_xe_utils154.default.toNumber(rotate);
  const contList = (import_xe_utils154.default.isArray(content) ? content : [content]).map((item) => {
    if (item) {
      if (item.textContent) {
        return createMarkFont(item, defaultFontSize, opts);
      }
      return createMarkFont({
        textContent: `${item}`
      }, defaultFontSize, opts);
    }
    return createMarkFont({
      textContent: ""
    }, defaultFontSize, opts);
  });
  removeMarkElement(fontEl);
  return new Promise((resolve) => {
    const canvasEl2 = getMarkCanvas();
    if (!canvasEl2.parentNode) {
      document.body.append(canvasEl2);
    }
    const ctx = canvasEl2.getContext("2d");
    if (ctx && contList.length) {
      const { contentWidth, contentHeight } = calcContentWH(contList);
      const { canvasWidth, canvasHeight } = calcCanvasWH(contentWidth, opts);
      canvasEl2.width = canvasWidth;
      canvasEl2.height = canvasHeight;
      const x = (canvasWidth - contentWidth) / 2;
      const y = (canvasHeight - contentHeight) / 2;
      const drayX = x + contentWidth / 2;
      const drayY = y + contentHeight / 2;
      ctx.save();
      ctx.translate(drayX, drayY);
      ctx.rotate(deg * Math.PI / 180);
      ctx.translate(-drayX, -drayY);
      let offsetHeight = 0;
      contList.forEach((item) => {
        const align = getFontConf(item, "align", opts);
        drayFont(ctx, item, opts);
        ctx.fillText(item.text, x + (align === "center" ? (contentWidth - item.width) / 2 : 0), y + (contentHeight + contentHeight) / 2 + offsetHeight, contentWidth);
        offsetHeight += item.height;
      });
      ctx.restore();
      resolve(canvasEl2.toDataURL());
      removeMarkElement(canvasEl2);
    } else {
      resolve("");
      removeMarkElement(canvasEl2);
    }
  });
}

// node_modules/vxe-pc-ui/es/watermark/src/watermark.js
var watermark_default = defineComponent({
  name: "VxeWatermark",
  props: {
    width: String,
    height: String,
    imageUrl: String,
    rotate: {
      type: [Number, String],
      default: () => getConfig().watermark.rotate
    },
    gap: {
      type: [Array, Number, String],
      default: () => import_xe_utils155.default.clone(getConfig().watermark.gap, true)
    },
    content: [String, Array],
    font: Object,
    offset: Object,
    zIndex: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils155.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      markUrl: ""
    });
    const refMaps = {
      refElem
    };
    const computeFontOpts = computed(() => {
      return import_xe_utils155.default.assign({}, import_xe_utils155.default.clone(getConfig().watermark.font, true), props.font);
    });
    const computeWrapperStyle = computed(() => {
      const { width, height, zIndex } = props;
      const { markUrl } = reactData;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (markUrl) {
        stys.backgroundImage = `url(${markUrl})`;
      }
      if (zIndex) {
        stys.zIndex = zIndex;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeWatermark = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $watermark: $xeWatermark }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const updateMarkStyle = () => {
      const { content, gap, rotate, offset } = props;
      const el2 = refElem.value;
      const fontOpts = computeFontOpts.value;
      if (el2) {
        if (content) {
          getContentUrl(content, getComputedStyle(el2).fontSize, {
            font: fontOpts,
            rotate,
            gap,
            offset
          }).then((url) => {
            reactData.markUrl = url;
          });
        }
      }
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeWatermark, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const wrapperStyle = computeWrapperStyle.value;
      return h("div", {
        ref: refElem,
        class: "vxe-watermark",
        style: wrapperStyle
      });
    };
    watch(() => props.imageUrl, () => {
      updateMarkStyle();
    });
    watch(() => props.content, () => {
      updateMarkStyle();
    });
    watch(() => props.gap, () => {
      updateMarkStyle();
    });
    watch(() => props.rotate, () => {
      updateMarkStyle();
    });
    watch(() => props.width, () => {
      updateMarkStyle();
    });
    watch(() => props.height, () => {
      updateMarkStyle();
    });
    watch(() => props.font, () => {
      updateMarkStyle();
    });
    onMounted(() => {
      updateMarkStyle();
      globalEvents.on($xeWatermark, "resize", import_xe_utils155.default.throttle(() => {
        updateMarkStyle();
      }, 300, { trailing: true, leading: true }));
    });
    onUnmounted(() => {
      globalEvents.off($xeWatermark, "resize");
    });
    $xeWatermark.renderVN = renderVN;
    return $xeWatermark;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/watermark/index.js
var VxeWatermark = Object.assign({}, watermark_default, {
  install(app) {
    app.component(watermark_default.name, watermark_default);
  }
});
dynamicApp.use(VxeWatermark);
VxeUI.component(watermark_default);
var WatermarkController = {
  load(options) {
    checkDynamic();
    dynamicStore.globalWatermark = Object.assign({}, options);
    return Promise.resolve();
  },
  clear() {
    dynamicStore.globalWatermark = null;
    return Promise.resolve();
  }
};
VxeUI.watermark = WatermarkController;
var Watermark = VxeWatermark;
var watermark_default2 = VxeWatermark;

// node_modules/vxe-pc-ui/es/components.js
var components3 = [
  alert_default2,
  anchor_default2,
  anchor_link_default2,
  avatar_default2,
  badge_default2,
  breadcrumb_default2,
  breadcrumb_item_default2,
  button_default2,
  button_group_default2,
  calendar_default2,
  card_default2,
  carousel_default2,
  carousel_item_default2,
  checkbox_default2,
  checkbox_group_default,
  col_default2,
  collapse_default2,
  collapse_pane_default2,
  color_picker_default2,
  countdown_default2,
  date_picker_default2,
  drawer_default2,
  empty_default2,
  form_default2,
  form_design_default2,
  form_gather_default,
  form_group_default2,
  form_item_default2,
  form_view_default2,
  icon_default2,
  icon_picker_default2,
  image_default2,
  image_group_default,
  image_preview_default,
  input_default2,
  layout_aside_default2,
  layout_body_default2,
  layout_container_default2,
  layout_footer_default2,
  layout_header_default2,
  link_default2,
  list_design_default2,
  list_view_default2,
  list_default2,
  loading_default2,
  menu_default2,
  modal_default2,
  notice_bar_default2,
  number_input_default2,
  optgroup_default2,
  option_default2,
  pager_default2,
  password_input_default2,
  print_page_break_default,
  print_default2,
  pulldown_default2,
  radio_default2,
  radio_button_default,
  radio_group_default,
  rate_default2,
  result_default2,
  row_default2,
  select_default2,
  slider_default2,
  steps_default2,
  switch_default2,
  tab_pane_default2,
  table_select_default2,
  tabs_default2,
  tag_default2,
  text_ellipsis_default2,
  text_default2,
  textarea_default2,
  tip_default2,
  tooltip_default2,
  tree_default2,
  tree_select_default2,
  upload_default2,
  watermark_default2
];
function install2(app, options) {
  setConfig(options);
  components3.forEach((component2) => app.use(component2));
}
var defaultLanguage = "zh-CN";
setI18n(defaultLanguage, zh_CN_default2);
setLanguage(defaultLanguage);
setTheme("light");
var loading = LoadingController;
var modal2 = ModalController;
var drawer = DrawerController;
var watermark = WatermarkController;
var print2 = printHtml;
var saveFile2 = saveLocalFile;
var readFile2 = readLocalFile;

// node_modules/vxe-pc-ui/es/index.esm.js
var index_esm_default3 = components_exports2;

// node_modules/@intlify/shared/dist/shared.mjs
var inBrowser = typeof window !== "undefined";
var mark;
var measure;
if (true) {
  const perf2 = inBrowser && window.performance;
  if (perf2 && perf2.mark && perf2.measure && perf2.clearMarks && // @ts-ignore browser compat
  perf2.clearMeasures) {
    mark = (tag) => {
      perf2.mark(tag);
    };
    measure = (name, startTag, endTag) => {
      perf2.measure(name, startTag, endTag);
      perf2.clearMarks(startTag);
      perf2.clearMarks(endTag);
    };
  }
}
var RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format(message, ...args) {
  if (args.length === 1 && isObject(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
var makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
var generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
var friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
var isNumber = (val) => typeof val === "number" && isFinite(val);
var isDate = (val) => toTypeString(val) === "[object Date]";
var isRegExp = (val) => toTypeString(val) === "[object RegExp]";
var isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
var assign = Object.assign;
var _create = Object.create;
var create = (obj = null) => _create(obj);
var _globalThis;
var getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : create());
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
var isArray = Array.isArray;
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isBoolean = (val) => typeof val === "boolean";
var isObject = (val) => val !== null && typeof val === "object";
var isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var isPlainObject = (val) => {
  if (!isObject(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
var toDisplayString2 = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join(items, separator = "") {
  return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
var RANGE = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (let j = i - RANGE; j <= i + RANGE || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        if (j === i) {
          const pad = start - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function incrementer(code3) {
  let current = code3;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
var hasWarned = {};
function warnOnce(msg) {
  if (!hasWarned[msg]) {
    hasWarned[msg] = true;
    warn(msg);
  }
}
function createEmitter() {
  const events = /* @__PURE__ */ new Map();
  const emitter = {
    events,
    on(event, handler) {
      const handlers = events.get(event);
      const added = handlers && handlers.push(handler);
      if (!added) {
        events.set(event, [handler]);
      }
    },
    off(event, handler) {
      const handlers = events.get(event);
      if (handlers) {
        handlers.splice(handlers.indexOf(handler) >>> 0, 1);
      }
    },
    emit(event, payload) {
      (events.get(event) || []).slice().map((handler) => handler(payload));
      (events.get("*") || []).slice().map((handler) => handler(event, payload));
    }
  };
  return emitter;
}
var isNotObjectOrIsArray = (val) => !isObject(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack = [{ src, des }];
  while (stack.length) {
    const { src: src2, des: des2 } = stack.pop();
    Object.keys(src2).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isObject(src2[key]) && !isObject(des2[key])) {
        des2[key] = Array.isArray(src2[key]) ? [] : create();
      }
      if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
        des2[key] = src2[key];
      } else {
        stack.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}

// node_modules/@intlify/message-compiler/dist/message-compiler.esm-browser.js
function createPosition(line, column, offset) {
  return { line, column, offset };
}
function createLocation(start, end, source) {
  const loc = { start, end };
  if (source != null) {
    loc.source = source;
  }
  return loc;
}
var RE_ARGS2 = /\{([0-9a-zA-Z]+)\}/g;
function format2(message, ...args) {
  if (args.length === 1 && isObject2(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS2, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
var assign2 = Object.assign;
var isString2 = (val) => typeof val === "string";
var isObject2 = (val) => val !== null && typeof val === "object";
function join2(items, separator = "") {
  return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
var CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
var warnMessages = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code3, loc, ...args) {
  const msg = format2(warnMessages[code3] || "", ...args || []);
  const message = { message: String(msg), code: code3 };
  if (loc) {
    message.location = loc;
  }
  return message;
}
var CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
var errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code3, loc, options = {}) {
  const { domain, messages, args } = options;
  const msg = format2((messages || errorMessages)[code3] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code3;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
var RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
var detectHtmlTag = (source) => RE_HTML_TAG.test(source);
var CHAR_SP = " ";
var CHAR_CR = "\r";
var CHAR_LF = "\n";
var CHAR_LS = String.fromCharCode(8232);
var CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
  const isLF = (index3) => _buf[index3] === CHAR_LF;
  const isPS = (index3) => _buf[index3] === CHAR_PS;
  const isLS = (index3) => _buf[index3] === CHAR_LS;
  const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
  const index2 = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index: index2,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
var EOF = void 0;
var DOT = ".";
var LITERAL_DELIMITER = "'";
var ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location2 = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code3, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code3, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location2) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token.value = value;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch2) {
    if (scnr.currentChar() === ch2) {
      scnr.next();
      return ch2;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch2);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch2) {
    if (ch2 === EOF) {
      return false;
    }
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 97 && cc2 <= 122 || // a-z
    cc2 >= 65 && cc2 <= 90 || // A-Z
    cc2 === 95;
  }
  function isNumberStart(ch2) {
    if (ch2 === EOF) {
      return false;
    }
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 48 && cc2 <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch2 = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch2);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn2 = () => {
      const ch2 = scnr.currentPeek();
      if (ch2 === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch2 === "@" || ch2 === "%" || ch2 === "|" || ch2 === ":" || ch2 === "." || ch2 === CHAR_SP || !ch2) {
        return false;
      } else if (ch2 === CHAR_LF) {
        scnr.peek();
        return fn2();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn2();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn2 = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch2 = scnr.currentPeek();
      if (ch2 === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch2 === "@" || !ch2) {
        return prev === "%" ? true : hasSpace;
      } else if (ch2 === "%") {
        scnr.peek();
        return fn2(hasSpace, "%", true);
      } else if (ch2 === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch2 === CHAR_SP) {
        scnr.peek();
        return fn2(true, CHAR_SP, detectModulo);
      } else if (ch2 === CHAR_LF) {
        scnr.peek();
        return fn2(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn2();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn2) {
    const ch2 = scnr.currentChar();
    if (ch2 === EOF) {
      return EOF;
    }
    if (fn2(ch2)) {
      scnr.next();
      return ch2;
    }
    return null;
  }
  function isIdentifier(ch2) {
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 97 && cc2 <= 122 || // a-z
    cc2 >= 65 && cc2 <= 90 || // A-Z
    cc2 >= 48 && cc2 <= 57 || // 0-9
    cc2 === 95 || // _
    cc2 === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch2) {
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 97 && cc2 <= 122 || // a-z
    cc2 >= 65 && cc2 <= 90 || // A-Z
    cc2 >= 48 && cc2 <= 57 || // 0-9
    cc2 === 95 || // _
    cc2 === 36 || // $
    cc2 === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch2) {
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 48 && cc2 <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch2) {
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 48 && cc2 <= 57 || // 0-9
    cc2 >= 65 && cc2 <= 70 || // A-F
    cc2 >= 97 && cc2 <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch2 = "";
    let num = "";
    while (ch2 = takeDigit(scnr)) {
      num += ch2;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch2 = scnr.currentChar();
    if (ch2 !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch2);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch2 = scnr.currentChar();
      if (ch2 === "{" || ch2 === "}" || ch2 === "@" || ch2 === "|" || !ch2) {
        break;
      } else if (ch2 === "%") {
        if (isTextStart(scnr)) {
          buf += ch2;
          scnr.next();
        } else {
          break;
        }
      } else if (ch2 === CHAR_SP || ch2 === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch2;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch2;
          scnr.next();
        }
      } else {
        buf += ch2;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch2 = "";
    let name = "";
    while (ch2 = takeNamedIdentifierChar(scnr)) {
      name += ch2;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function isLiteral2(ch2) {
    return ch2 !== LITERAL_DELIMITER && ch2 !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch2 = "";
    let literal = "";
    while (ch2 = takeChar(scnr, isLiteral2)) {
      if (ch2 === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch2;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch2}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch2, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch2, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch2);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch2 = takeHexDigit(scnr);
      if (!ch2) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch2;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch2) {
    return ch2 !== "{" && ch2 !== "}" && ch2 !== CHAR_SP && ch2 !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch2 = "";
    let identifiers = "";
    while (ch2 = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch2;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch2 = "";
    let name = "";
    while (ch2 = takeIdentifierChar(scnr)) {
      name += ch2;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn2 = (buf) => {
      const ch2 = scnr.currentChar();
      if (ch2 === "{" || ch2 === "%" || ch2 === "@" || ch2 === "|" || ch2 === "(" || ch2 === ")" || !ch2) {
        return buf;
      } else if (ch2 === CHAR_SP) {
        return buf;
      } else if (ch2 === CHAR_LF || ch2 === DOT) {
        buf += ch2;
        scnr.next();
        return fn2(buf);
      } else {
        buf += ch2;
        scnr.next();
        return fn2(buf);
      }
    };
    return fn2("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch2 = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch2 === CHAR_LF || ch2 === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch2) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch2 === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
var ERROR_DOMAIN$2 = "parser";
var KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "";
    }
  }
}
function createParser(options = {}) {
  const location2 = options.location !== false;
  const { onError, onWarn } = options;
  function emitError(tokenzer, code3, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location2 ? createLocation(start, end) : null;
      const err = createCompileError(code3, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function emitWarn(tokenzer, code3, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onWarn) {
      const loc = location2 ? createLocation(start, end) : null;
      onWarn(createCompileWarn(code3, loc, args));
    }
  }
  function startNode(type, offset, loc) {
    const node = { type };
    if (location2) {
      node.start = offset;
      node.end = offset;
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset, pos, type) {
    if (type) {
      node.type = type;
    }
    if (location2) {
      node.end = offset;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseList(tokenizer, index2) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(5, offset, loc);
    node.index = parseInt(index2, 10);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseNamed(tokenizer, key, modulo) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(4, offset, loc);
    node.key = key;
    if (modulo === true) {
      node.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer, value) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(9, offset, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign2({}, options));
    const context = tokenizer.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location2 && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer);
    if (options.onCacheKey) {
      node.cacheKey = options.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "" : name;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}
function traverseNode(node, transformer) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c) => optimizeMessageNode(c));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i = 0; i < message.items.length; i++) {
      const item = message.items[i];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message.items.length) {
      message.static = join2(values);
      for (let i = 0; i < message.items.length; i++) {
        const item = message.items[i];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
var ERROR_DOMAIN$1 = "minifier";
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i = 0; i < cases.length; i++) {
        minify(cases[i]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message = node;
      const items = message.items;
      for (let i = 0; i < items.length; i++) {
        minify(items[i]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node.type]
      });
    }
  }
  delete node.type;
}
var ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
  const location2 = options.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code3, node) {
    _context.code += code3;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;
  for (let i = 0; i < length; i++) {
    generateNode(generator, node.items[i]);
    if (i === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator, node.cases[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node.type]
      });
    }
  }
}
var generate = (ast, options = {}) => {
  const mode = isString2(options.mode) ? options.mode : "normal";
  const filename = isString2(options.filename) ? options.filename : "message.intl";
  const sourceMap = !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join2(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code3, map } = generator.context();
  return {
    ast,
    code: code3,
    map: map ? map.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile(source, options = {}) {
  const assignedOptions = assign2({}, options);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}

// node_modules/@intlify/core-base/dist/core-base.mjs
function initFeatureFlags() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
var pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
var literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch2) {
  if (ch2 === void 0 || ch2 === null) {
    return "o";
  }
  const code3 = ch2.charCodeAt(0);
  switch (code3) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch2;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys = [];
  let index2 = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index2++;
    c = path[index2];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
var cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject(obj) ? obj[path] : null;
}
function resolveValue$1(obj, path) {
  if (!isObject(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
var DEFAULT_MODIFIER = (str) => str;
var DEFAULT_MESSAGE = (ctx) => "";
var DEFAULT_MESSAGE_DATA_TYPE = "text";
var DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join(values);
var DEFAULT_INTERPOLATE = toDisplayString2;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index2) => _list[index2];
  const _named = options.named || create();
  isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction(options.messages) ? options.messages(key) : isObject(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign(create(), _list, _named)
  };
  return ctx;
}
var devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n, version7, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n,
    version: version7,
    meta
  });
}
var translateDevTools = createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
var code$1 = CompileWarnCodes.__EXTEND_POINT__;
var inc$1 = incrementer(code$1);
var CoreWarnCodes = {
  NOT_FOUND_KEY: code$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1(),
  // 8
  __EXTEND_POINT__: inc$1()
  // 9
};
var warnMessages2 = {
  [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
  [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
  [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
  [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: `This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.`
};
function getWarnMessage(code3, ...args) {
  return format(warnMessages2[code3], ...args);
}
var code = CompileErrorCodes.__EXTEND_POINT__;
var inc = incrementer(code);
var CoreErrorCodes = {
  INVALID_ARGUMENT: code,
  // 17
  INVALID_DATE_ARGUMENT: inc(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc(),
  // 23
  __EXTEND_POINT__: inc()
  // 24
};
function createCoreError(code3) {
  return createCompileError(code3, null, true ? { messages: errorMessages2 } : void 0);
}
var errorMessages2 = {
  [CoreErrorCodes.INVALID_ARGUMENT]: "Invalid arguments",
  [CoreErrorCodes.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function getLocale(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
var _resolveLocale;
function resolveLocale(locale) {
  if (isString(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve = locale();
        if (isPromise(resolve)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults2 = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString(defaults2) ? [defaults2] : defaults2;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
var VERSION = "9.14.2";
var NOT_REOSLVED = -1;
var DEFAULT_LOCALE = "en-US";
var MISSING_RESOLVE_VALUE = "";
var capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString(val) ? val.toUpperCase() : type === "vnode" && isObject(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString(val) ? val.toLowerCase() : type === "vnode" && isObject(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString(val) ? capitalize(val) : type === "vnode" && isObject(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
var _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
var _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
var _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
var _additionalMeta = null;
var setAdditionalMeta = (meta) => {
  _additionalMeta = meta;
};
var getAdditionalMeta = () => _additionalMeta;
var _fallbackContext = null;
var setFallbackContext = (context) => {
  _fallbackContext = context;
};
var getFallbackContext = () => _fallbackContext;
var _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const version7 = isString(options.version) ? options.version : VERSION;
  const locale = isString(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages = isPlainObject(options.messages) ? options.messages : createResources(_locale);
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : createResources(_locale);
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : createResources(_locale);
  const modifiers = assign(create(), options.modifiers, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || create();
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  if (isFunction(options.messageCompiler)) {
    warnOnce(getWarnMessage(CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  }
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version7,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (true) {
    context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : void 0;
  }
  if (true) {
    initI18nDevTools(context, version7, __meta);
  }
  return context;
}
var createResources = (locale) => ({ [locale]: create() });
function isTranslateFallbackWarn(fallback, key) {
  return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
function isTranslateMissingWarn(missing, key) {
  return missing instanceof RegExp ? missing.test(key) : missing;
}
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (true) {
    const emitter = context.__v_emitter;
    if (emitter) {
      emitter.emit("missing", {
        locale,
        key,
        type,
        groupId: `${type}:${key}`
      });
    }
  }
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString(ret) ? ret : key;
  } else {
    if (isTranslateMissingWarn(missingWarn, key)) {
      onWarn(getWarnMessage(CoreWarnCodes.NOT_FOUND_KEY, { key, locale }));
    }
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index2 = locales.indexOf(targetLocale);
  if (index2 === -1) {
    return false;
  }
  for (let i = index2 + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function format3(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = resolveBody(ast);
  if (body == null) {
    throw createUnhandleNodeError(
      0
      /* NodeTypes.Resource */
    );
  }
  const type = resolveType(body);
  if (type === 1) {
    const plural = body;
    const cases = resolveCases(plural);
    return ctx.plural(cases.reduce((messages, c) => [
      ...messages,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
var PROPS_BODY = ["b", "body"];
function resolveBody(node) {
  return resolveProps(node, PROPS_BODY);
}
var PROPS_CASES = ["c", "cases"];
function resolveCases(node) {
  return resolveProps(node, PROPS_CASES, []);
}
function formatMessageParts(ctx, node) {
  const static_ = resolveStatic(node);
  if (static_ != null) {
    return ctx.type === "text" ? static_ : ctx.normalize([static_]);
  } else {
    const messages = resolveItems(node).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages);
  }
}
var PROPS_STATIC = ["s", "static"];
function resolveStatic(node) {
  return resolveProps(node, PROPS_STATIC);
}
var PROPS_ITEMS = ["i", "items"];
function resolveItems(node) {
  return resolveProps(node, PROPS_ITEMS, []);
}
function formatMessagePart(ctx, node) {
  const type = resolveType(node);
  switch (type) {
    case 3: {
      return resolveValue(node, type);
    }
    case 9: {
      return resolveValue(node, type);
    }
    case 4: {
      const named = node;
      if (hasOwn(named, "k") && named.k) {
        return ctx.interpolate(ctx.named(named.k));
      }
      if (hasOwn(named, "key") && named.key) {
        return ctx.interpolate(ctx.named(named.key));
      }
      throw createUnhandleNodeError(type);
    }
    case 5: {
      const list = node;
      if (hasOwn(list, "i") && isNumber(list.i)) {
        return ctx.interpolate(ctx.list(list.i));
      }
      if (hasOwn(list, "index") && isNumber(list.index)) {
        return ctx.interpolate(ctx.list(list.index));
      }
      throw createUnhandleNodeError(type);
    }
    case 6: {
      const linked = node;
      const modifier = resolveLinkedModifier(linked);
      const key = resolveLinkedKey(linked);
      return ctx.linked(formatMessagePart(ctx, key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      return resolveValue(node, type);
    }
    case 8: {
      return resolveValue(node, type);
    }
    default:
      throw new Error(`unhandled node on format message part: ${type}`);
  }
}
var PROPS_TYPE = ["t", "type"];
function resolveType(node) {
  return resolveProps(node, PROPS_TYPE);
}
var PROPS_VALUE = ["v", "value"];
function resolveValue(node, type) {
  const resolved = resolveProps(node, PROPS_VALUE);
  if (resolved) {
    return resolved;
  } else {
    throw createUnhandleNodeError(type);
  }
}
var PROPS_MODIFIER = ["m", "modifier"];
function resolveLinkedModifier(node) {
  return resolveProps(node, PROPS_MODIFIER);
}
var PROPS_KEY = ["k", "key"];
function resolveLinkedKey(node) {
  const resolved = resolveProps(node, PROPS_KEY);
  if (resolved) {
    return resolved;
  } else {
    throw createUnhandleNodeError(
      6
      /* NodeTypes.Linked */
    );
  }
}
function resolveProps(node, props, defaultValue) {
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (hasOwn(node, prop) && node[prop] != null) {
      return node[prop];
    }
  }
  return defaultValue;
}
function createUnhandleNodeError(type) {
  return new Error(`unhandled node type: ${type}`);
}
var WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;
function checkHtmlMessage(source, warnHtmlMessage) {
  if (warnHtmlMessage && detectHtmlTag(source)) {
    warn(format(WARN_MESSAGE, { source }));
  }
}
var defaultOnCacheKey = (message) => message;
var compileCache = create();
function onCompileWarn(_warn) {
  if (_warn.code === CompileWarnCodes.USE_MODULO_SYNTAX) {
    warn(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${_warn.message})`);
  }
}
function isMessageAST(val) {
  return isObject(val) && resolveType(val) === 0 && (hasOwn(val, "b") || hasOwn(val, "body"));
}
function baseCompile2(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile(message, options), detectError };
}
var compileToFunction = (message, context) => {
  if (!isString(message)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  if (true) {
    context.onWarn = onCompileWarn;
  }
  {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    checkHtmlMessage(message, warnHtmlMessage);
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code3, detectError } = baseCompile2(message, context);
    const msg = new Function(`return ${code3}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile(message, context) {
  if (true) {
    context.onWarn = onCompileWarn;
  }
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString(message)) {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    checkHtmlMessage(message, warnHtmlMessage);
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile2(message, {
      ...context,
      location: true,
      jit: true
    });
    const msg = format3(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    if (!isMessageAST(message)) {
      warn(`the message that is resolve with key '${context.key}' is not supported for jit compilation`);
      return () => message;
    }
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format3(message);
    } else {
      return format3(message);
    }
  }
}
var NOOP_MESSAGE_FUNCTION = () => "";
var isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || create()
  ];
  let format4 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString(format4) || isMessageAST(format4) || isMessageFunction(format4))) {
    if (enableDefaultMsg) {
      format4 = defaultMsgOrKey;
      cacheBaseKey = format4;
    }
  }
  if (!resolvedMessage && (!(isString(format4) || isMessageAST(format4) || isMessageFunction(format4)) || !isString(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  if (isString(format4) && context.messageCompiler == null) {
    warn(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${key}'.`);
    return key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format4) ? compileMessageFormat(context, key, targetLocale, format4, cacheBaseKey, onError) : format4;
  if (occurred) {
    return format4;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (true) {
    const payloads = {
      timestamp: Date.now(),
      key: isString(key) ? key : isMessageFunction(format4) ? format4.key : "",
      locale: targetLocale || (isMessageFunction(format4) ? format4.locale : ""),
      format: isString(format4) ? format4 : isMessageFunction(format4) ? format4.source : "",
      message: ret
    };
    payloads.meta = assign({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString(item) ? escapeHtml(item) : item);
  } else if (isObject(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = create();
  let targetLocale;
  let format4 = null;
  let from = locale;
  let to2 = null;
  const type = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = to2 = locales[i];
    if (locale !== targetLocale && !isAlmostSameLocale(locale, targetLocale) && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to: to2,
          groupId: `${type}:${key}`
        });
      }
    }
    message = messages[targetLocale] || create();
    let start = null;
    let startTag;
    let endTag;
    if (inBrowser) {
      start = window.performance.now();
      startTag = "intlify-message-resolve-start";
      endTag = "intlify-message-resolve-end";
      mark && mark(startTag);
    }
    if ((format4 = resolveValue2(message, key)) === null) {
      format4 = message[key];
    }
    if (inBrowser) {
      const end = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start && format4) {
        emitter.emit("message-resolve", {
          type: "message-resolve",
          key,
          message: format4,
          time: end - start,
          groupId: `${type}:${key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message resolve", startTag, endTag);
      }
    }
    if (isString(format4) || isMessageAST(format4) || isMessageFunction(format4)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format4 = missingRet;
      }
    }
    from = to2;
  }
  return [format4, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format4, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format4)) {
    const msg2 = format4;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format4;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  let start = null;
  let startTag;
  let endTag;
  if (inBrowser) {
    start = window.performance.now();
    startTag = "intlify-message-compilation-start";
    endTag = "intlify-message-compilation-end";
    mark && mark(startTag);
  }
  const msg = messageCompiler(format4, getCompileContext(context, targetLocale, cacheBaseKey, format4, warnHtmlMessage, onError));
  if (inBrowser) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start) {
      emitter.emit("message-compilation", {
        type: "message-compilation",
        message: format4,
        time: end - start,
        groupId: `${"translate"}:${key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message compilation", startTag, endTag);
    }
  }
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format4;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  let start = null;
  let startTag;
  let endTag;
  if (inBrowser) {
    start = window.performance.now();
    startTag = "intlify-message-evaluation-start";
    endTag = "intlify-message-evaluation-end";
    mark && mark(startTag);
  }
  const messaged = msg(msgCtx);
  if (inBrowser) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start) {
      emitter.emit("message-evaluation", {
        type: "message-evaluation",
        value: messaged,
        time: end - start,
        groupId: `${"translate"}:${msg.key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message evaluation", startTag, endTag);
    }
  }
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = create();
  if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options.plural = arg2;
  } else if (isString(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber(arg3)) {
    options.plural = arg3;
  } else if (isString(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      if (true) {
        const _source = getSourceForCodeFrame(source);
        const message = `Message compilation error: ${err.message}`;
        const codeFrame = err.location && _source && generateCodeFrame(_source, err.location.start.offset, err.location.end.offset);
        const emitter = context.__v_emitter;
        if (emitter && _source) {
          emitter.emit("compile-error", {
            message: _source,
            error: err.message,
            start: err.location && err.location.start.offset,
            end: err.location && err.location.end.offset,
            groupId: `${"translate"}:${key}`
          });
        }
        console.error(codeFrame ? `${message}
${codeFrame}` : message);
      } else {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getSourceForCodeFrame(source) {
  if (isString(source)) {
    return source;
  } else {
    if (source.loc && source.loc.source) {
      return source.loc.source;
    }
  }
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
var intlDefined = typeof Intl !== "undefined";
var Availabilities = {
  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
  numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
};
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  if (!Availabilities.dateTimeFormat) {
    onWarn(getWarnMessage(CoreWarnCodes.CANNOT_FORMAT_DATE));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format4 = null;
  let from = locale;
  let to2 = null;
  const type = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = to2 = locales[i];
    if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to: to2,
          groupId: `${type}:${key}`
        });
      }
    }
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format4 = datetimeFormat[key];
    if (isPlainObject(format4))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to2;
  }
  if (!isPlainObject(format4) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign({}, format4, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
var DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  let value;
  if (isString(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e16) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format4) {
  const context = ctx;
  for (const key in format4) {
    const id2 = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id2)) {
      continue;
    }
    context.__datetimeFormatters.delete(id2);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  if (!Availabilities.numberFormat) {
    onWarn(getWarnMessage(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format4 = null;
  let from = locale;
  let to2 = null;
  const type = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = to2 = locales[i];
    if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to: to2,
          groupId: `${type}:${key}`
        });
      }
    }
    numberFormat = numberFormats[targetLocale] || {};
    format4 = numberFormat[key];
    if (isPlainObject(format4))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to2;
  }
  if (!isPlainObject(format4) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign({}, format4, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
var NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format4) {
  const context = ctx;
  for (const key in format4) {
    const id2 = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id2)) {
      continue;
    }
    context.__numberFormatters.delete(id2);
  }
}
{
  initFeatureFlags();
}

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/env.js
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
var isProxyAvailable = typeof Proxy === "function";

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/const.js
var HOOK_SETUP = "devtools-plugin:setup";
var HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/time.js
var supported;
var perf;
function isPerformanceSupported() {
  var _a2;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof globalThis !== "undefined" && ((_a2 = globalThis.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
    supported = true;
    perf = globalThis.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/proxy.js
var ApiProxy = class {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id2 in plugin.settings) {
        const item = plugin.settings[id2];
        defaultSettings[id2] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e16) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e16) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
};

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/index.js
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) {
      setupFn(proxy.proxiedTarget);
    }
  }
}

// node_modules/vue-i18n/dist/vue-i18n.mjs
var VERSION2 = "9.14.2";
function initFeatureFlags2() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
var code$12 = CoreWarnCodes.__EXTEND_POINT__;
var inc$12 = incrementer(code$12);
var I18nWarnCodes = {
  FALLBACK_TO_ROOT: code$12,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$12(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$12(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$12(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$12(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$12(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$12(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$12(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$12(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$12()
  // 18
};
var warnMessages3 = {
  [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
  [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
  [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
  [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
  [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,
  [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`,
  [I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION]: `'allowComposition' option will be dropped in the next major version. For more information, please see  https://tinyurl.com/2p97mcze`,
  [I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: `'translateExistCompatible' option will be dropped in the next major version.`
};
function getWarnMessage2(code3, ...args) {
  return format(warnMessages3[code3], ...args);
}
var code2 = CoreErrorCodes.__EXTEND_POINT__;
var inc2 = incrementer(code2);
var I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code2,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc2(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc2(),
  // 26
  NOT_INSTALLED: inc2(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc2(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc2(),
  // 29
  INVALID_VALUE: inc2(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc2(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc2(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc2(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc2(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc2(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc2(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc2(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc2()
  // 38
};
function createI18nError(code3, ...args) {
  return createCompileError(code3, null, true ? { messages: errorMessages3, args } : void 0);
}
var errorMessages3 = {
  [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [I18nErrorCodes.INVALID_ARGUMENT]: "Invalid argument",
  [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [I18nErrorCodes.NOT_INSTALLED]: "Need to install with `app.use` function",
  [I18nErrorCodes.UNEXPECTED_ERROR]: "Unexpected error",
  [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
  [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
  [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
  [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define i18n option or custom block in Composition API with using local scope in Legacy API mode",
  [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
};
var TranslateVNodeSymbol = makeSymbol("__translateVNode");
var DatetimePartsSymbol = makeSymbol("__datetimeParts");
var NumberPartsSymbol = makeSymbol("__numberParts");
var EnableEmitter = makeSymbol("__enableEmitter");
var DisableEmitter = makeSymbol("__disableEmitter");
var SetPluralRulesSymbol = makeSymbol("__setPluralRules");
makeSymbol("__intlifyMeta");
var InejctWithOptionSymbol = makeSymbol("__injectWithOption");
var DisposeSymbol = makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = create();
        }
        if (!isObject(currentObj[subKeys[i]])) {
          warn(getWarnMessage2(I18nWarnCodes.IGNORE_OBJ_FLATTEN, {
            key: subKeys[i]
          }));
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages) ? messages : isArray(__i18n) ? create() : { [locale]: create() };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || create();
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages = isObject(options.messages) ? options.messages : create();
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
var DEVTOOLS_META = "__INTLIFY_META__";
var NOOP_RETURN_ARRAY = () => [];
var NOOP_RETURN_FALSE = () => false;
var composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  };
}
var getMetaInfo = () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  if (true) {
    if (translateExistCompatible && true) {
      warnOnce(getWarnMessage2(I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
    }
  }
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION2,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    if (true) {
      ctxOptions.__v_emitter = isPlainObject(_context) ? _context.__v_emitter : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  function isResolvedTranslateMessage(type, arg) {
    return type !== "translate" || !arg.resolvedMessage;
  }
  const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (true) {
        setAdditionalMeta(getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn2(_context);
    } finally {
      if (true) {
        setAdditionalMeta(null);
      }
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      if (__root && isString(key) && isResolvedTranslateMessage(warnType, arg2)) {
        if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
          warn(getWarnMessage2(I18nWarnCodes.FALLBACK_TO_ROOT, {
            key,
            type: warnType
          }));
        }
        if (true) {
          const { __v_emitter: emitter } = _context;
          if (emitter && _fallbackRoot) {
            emitter.emit("fallback", {
              type: warnType,
              key,
              to: "global",
              groupId: `${warnType}:${key}`
            });
          }
        }
      }
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t10(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t10(...[arg1, arg2, assign({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
  }
  function normalize(values) {
    return values.map((val) => isString(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString(resolved) : resolved != null;
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm2(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format4) {
    _datetimeFormats.value[locale2] = format4;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format4);
  }
  function mergeDateTimeFormat(locale2, format4) {
    _datetimeFormats.value[locale2] = assign(_datetimeFormats.value[locale2] || {}, format4);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format4);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format4) {
    _numberFormats.value[locale2] = format4;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format4);
  }
  function mergeNumberFormat(locale2, format4) {
    _numberFormats.value[locale2] = assign(_numberFormats.value[locale2] || {}, format4);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format4);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t10,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm2;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  if (true) {
    composer[EnableEmitter] = (emitter) => {
      _context.__v_emitter = emitter;
    };
    composer[DisableEmitter] = () => {
      _context.__v_emitter = void 0;
    };
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  if (options.formatter) {
    warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
  }
  if (options.preserveDirectiveContent) {
    warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  }
  let messages = options.messages;
  if (isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages2, locale2) => {
      const message = messages2[locale2] || (messages2[locale2] = {});
      assign(message, sharedMessages[locale2]);
      return messages2;
    }, messages || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  const translateExistCompatible = options.translateExistCompatible;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
        return true;
      },
      set preserveDirectiveContent(val) {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isNumber(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format4) {
        composer.setDateTimeFormat(locale, format4);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format4) {
        composer.mergeDateTimeFormat(locale, format4);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format4) {
        composer.setNumberFormat(locale, format4);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format4) {
        composer.mergeNumberFormat(locale, format4);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX));
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    if (true) {
      vueI18n.__enableEmitter = (emitter) => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };
      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }
    return vueI18n;
  }
}
var baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, create());
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
var TranslationImpl = defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = create();
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign(create(), attrs);
      const tag = isString(props.tag) || isObject(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
var Translation = TranslationImpl;
function isVNode2(target) {
  return isArray(target) && !isString(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = create();
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString(props.format)) {
      options.key = props.format;
    } else if (isObject(props.format)) {
      if (isString(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign(create(), options2, { [prop]: props.format[prop] }) : options2;
      }, create());
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index2) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
        if (isVNode2(node)) {
          node[0].key = `${part.type}-${index2}`;
        }
        return node;
      });
    } else if (isString(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign(create(), attrs);
    const tag = isString(props.tag) || isObject(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
var NumberFormatImpl = defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[NumberPartsSymbol](...args)
    ));
  }
});
var NumberFormat = NumberFormatImpl;
var DatetimeFormatImpl = defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[DatetimePartsSymbol](...args)
    ));
  }
});
var DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const _process = (binding) => {
    const { instance, modifiers, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n, instance.$);
    if (modifiers.preserve) {
      warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_PRESERVE));
    }
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el2, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n.global === composer) {
      el2.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el2.__composer = composer;
    el2.textContent = textContent;
  };
  const unregister = (el2) => {
    if (inBrowser && el2.__i18nWatcher) {
      el2.__i18nWatcher();
      el2.__i18nWatcher = void 0;
      delete el2.__i18nWatcher;
    }
    if (el2.__composer) {
      el2.__composer = void 0;
      delete el2.__composer;
    }
  };
  const update = (el2, { value }) => {
    if (el2.__composer) {
      const composer = el2.__composer;
      const parsedValue = parseValue(value);
      el2.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString(locale)) {
    options.locale = locale;
  }
  if (isNumber(choice)) {
    options.plural = choice;
  }
  if (isNumber(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app, i18n, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall && useI18nComponentName) {
    warn(getWarnMessage2(I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE, {
      name: Translation.name
    }));
  }
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app.component(name, DatetimeFormat));
  }
  {
    app.directive("t", vTDirective(i18n));
  }
}
var VueDevToolsLabels = {
  [
    "vue-devtools-plugin-vue-i18n"
    /* VueDevToolsIDs.PLUGIN */
  ]: "Vue I18n devtools",
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "I18n Resources",
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: "Vue I18n"
};
var VueDevToolsPlaceholders = {
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "Search for scopes ..."
};
var VueDevToolsTimelineColors = {
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: 16764185
};
var VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
var devtoolsApi;
async function enableDevTools(app, i18n) {
  return new Promise((resolve, reject) => {
    try {
      setupDevtoolsPlugin({
        id: "vue-devtools-plugin-vue-i18n",
        label: VueDevToolsLabels[
          "vue-devtools-plugin-vue-i18n"
          /* VueDevToolsIDs.PLUGIN */
        ],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
        app
        // eslint-disable-line @typescript-eslint/no-explicit-any
      }, (api) => {
        devtoolsApi = api;
        api.on.visitComponentTree(({ componentInstance, treeNode }) => {
          updateComponentTreeTags(componentInstance, treeNode, i18n);
        });
        api.on.inspectComponent(({ componentInstance, instanceData }) => {
          if (componentInstance.vnode.el && componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
            if (i18n.mode === "legacy") {
              if (componentInstance.vnode.el.__VUE_I18N__ !== i18n.global.__composer) {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            } else {
              inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
            }
          }
        });
        api.addInspector({
          id: "vue-i18n-resource-inspector",
          label: VueDevToolsLabels[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ],
          icon: "language",
          treeFilterPlaceholder: VueDevToolsPlaceholders[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ]
        });
        api.on.getInspectorTree((payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            registerScope(payload, i18n);
          }
        });
        const roots = /* @__PURE__ */ new Map();
        api.on.getInspectorState(async (payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            api.unhighlightElement();
            inspectScope(payload, i18n);
            if (payload.nodeId === "global") {
              if (!roots.has(payload.app)) {
                const [root] = await api.getComponentInstances(payload.app);
                roots.set(payload.app, root);
              }
              api.highlightElement(roots.get(payload.app));
            } else {
              const instance = getComponentInstance(payload.nodeId, i18n);
              instance && api.highlightElement(instance);
            }
          }
        });
        api.on.editInspectorState((payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            editScope(payload, i18n);
          }
        });
        api.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: VueDevToolsLabels[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ],
          color: VueDevToolsTimelineColors[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ]
        });
        resolve(true);
      });
    } catch (e16) {
      console.error(e16);
      reject(false);
    }
  });
}
function getI18nScopeLable(instance) {
  return instance.type.name || instance.type.displayName || instance.type.__file || "Anonymous";
}
function updateComponentTreeTags(instance, treeNode, i18n) {
  const global2 = i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {
    if (instance.vnode.el.__VUE_I18N__ !== global2) {
      const tag = {
        label: `i18n (${getI18nScopeLable(instance)} Scope)`,
        textColor: 0,
        backgroundColor: 16764185
      };
      treeNode.tags.push(tag);
    }
  }
}
function inspectComposer(instanceData, composer) {
  const type = VUE_I18N_COMPONENT_TYPES;
  instanceData.state.push({
    type,
    key: "locale",
    editable: true,
    value: composer.locale.value
  });
  instanceData.state.push({
    type,
    key: "availableLocales",
    editable: false,
    value: composer.availableLocales
  });
  instanceData.state.push({
    type,
    key: "fallbackLocale",
    editable: true,
    value: composer.fallbackLocale.value
  });
  instanceData.state.push({
    type,
    key: "inheritLocale",
    editable: true,
    value: composer.inheritLocale
  });
  instanceData.state.push({
    type,
    key: "messages",
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  });
  {
    instanceData.state.push({
      type,
      key: "datetimeFormats",
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: "numberFormats",
      editable: false,
      value: composer.numberFormats.value
    });
  }
}
function getLocaleMessageValue(messages) {
  const value = {};
  Object.keys(messages).forEach((key) => {
    const v = messages[key];
    if (isFunction(v) && "source" in v) {
      value[key] = getMessageFunctionDetails(v);
    } else if (isMessageAST(v) && v.loc && v.loc.source) {
      value[key] = v.loc.source;
    } else if (isObject(v)) {
      value[key] = getLocaleMessageValue(v);
    } else {
      value[key] = v;
    }
  });
  return value;
}
var ESC = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function escape(s) {
  return s.replace(/[<>"&]/g, escapeChar);
}
function escapeChar(a) {
  return ESC[a] || a;
}
function getMessageFunctionDetails(func) {
  const argString = func.source ? `("${escape(func.source)}")` : `(?)`;
  return {
    _custom: {
      type: "function",
      display: `<span></span> ${argString}`
    }
  };
}
function registerScope(payload, i18n) {
  payload.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const global2 = i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  for (const [keyInstance, instance] of i18n.__instances) {
    const composer = i18n.mode === "composition" ? instance : instance.__composer;
    if (global2 === composer) {
      continue;
    }
    payload.rootNodes.push({
      id: composer.id.toString(),
      label: `${getI18nScopeLable(keyInstance)} Scope`
    });
  }
}
function getComponentInstance(nodeId, i18n) {
  let instance = null;
  if (nodeId !== "global") {
    for (const [component2, composer] of i18n.__instances.entries()) {
      if (composer.id.toString() === nodeId) {
        instance = component2;
        break;
      }
    }
  }
  return instance;
}
function getComposer$1(nodeId, i18n) {
  if (nodeId === "global") {
    return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  } else {
    const instance = Array.from(i18n.__instances.values()).find((item) => item.id.toString() === nodeId);
    if (instance) {
      return i18n.mode === "composition" ? instance : instance.__composer;
    } else {
      return null;
    }
  }
}
function inspectScope(payload, i18n) {
  const composer = getComposer$1(payload.nodeId, i18n);
  if (composer) {
    payload.state = makeScopeInspectState(composer);
  }
  return null;
}
function makeScopeInspectState(composer) {
  const state = {};
  const localeType = "Locale related info";
  const localeStates = [
    {
      type: localeType,
      key: "locale",
      editable: true,
      value: composer.locale.value
    },
    {
      type: localeType,
      key: "fallbackLocale",
      editable: true,
      value: composer.fallbackLocale.value
    },
    {
      type: localeType,
      key: "availableLocales",
      editable: false,
      value: composer.availableLocales
    },
    {
      type: localeType,
      key: "inheritLocale",
      editable: true,
      value: composer.inheritLocale
    }
  ];
  state[localeType] = localeStates;
  const localeMessagesType = "Locale messages info";
  const localeMessagesStates = [
    {
      type: localeMessagesType,
      key: "messages",
      editable: false,
      value: getLocaleMessageValue(composer.messages.value)
    }
  ];
  state[localeMessagesType] = localeMessagesStates;
  {
    const datetimeFormatsType = "Datetime formats info";
    const datetimeFormatsStates = [
      {
        type: datetimeFormatsType,
        key: "datetimeFormats",
        editable: false,
        value: composer.datetimeFormats.value
      }
    ];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = "Datetime formats info";
    const numberFormatsStates = [
      {
        type: numberFormatsType,
        key: "numberFormats",
        editable: false,
        value: composer.numberFormats.value
      }
    ];
    state[numberFormatsType] = numberFormatsStates;
  }
  return state;
}
function addTimelineEvent(event, payload) {
  if (devtoolsApi) {
    let groupId;
    if (payload && "groupId" in payload) {
      groupId = payload.groupId;
      delete payload.groupId;
    }
    devtoolsApi.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: event,
        groupId,
        time: Date.now(),
        meta: {},
        data: payload || {},
        logType: event === "compile-error" ? "error" : event === "fallback" || event === "missing" ? "warning" : "default"
      }
    });
  }
}
function editScope(payload, i18n) {
  const composer = getComposer$1(payload.nodeId, i18n);
  if (composer) {
    const [field] = payload.path;
    if (field === "locale" && isString(payload.state.value)) {
      composer.locale.value = payload.state.value;
    } else if (field === "fallbackLocale" && (isString(payload.state.value) || isArray(payload.state.value) || isObject(payload.state.value))) {
      composer.fallbackLocale.value = payload.state.value;
    } else if (field === "inheritLocale" && isBoolean(payload.state.value)) {
      composer.inheritLocale = payload.state.value;
    }
  }
}
function defineMixin(vuei18n, composer, i18n) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __extender: i18n.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n.__setInstance(instance, this.$i18n);
    },
    mounted() {
      if (this.$el && this.$i18n) {
        const _vueI18n = this.$i18n;
        this.$el.__VUE_I18N__ = _vueI18n.__composer;
        const emitter = this.__v_emitter = createEmitter();
        _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
        emitter.on("*", addTimelineEvent);
      }
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      if (this.$el && this.$el.__VUE_I18N__) {
        if (this.__v_emitter) {
          this.__v_emitter.off("*", addTimelineEvent);
          delete this.__v_emitter;
        }
        if (this.$i18n) {
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
      }
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g, options) {
  g.locale = options.locale || g.locale;
  g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
  g.missing = options.missing || g.missing;
  g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
  const messages = getLocaleMessages(g.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach((locale) => g.mergeLocaleMessage(locale, messages[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => g.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return g;
}
var I18nInjectionKey = makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = makeSymbol(true ? "vue-i18n" : "");
  if (true) {
    if (__legacyMode && __allowComposition && true) {
      warn(getWarnMessage2(I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION));
    }
  }
  function __getInstance(component2) {
    return __instances.get(component2) || null;
  }
  function __setInstance(component2, instance) {
    __instances.set(component2, instance);
  }
  function __deleteInstance(component2) {
    __instances.delete(component2);
  }
  {
    const i18n = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app, ...options2) {
        if (true) {
          app.__VUE_I18N__ = i18n;
        }
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n);
        if (isPlainObject(options2[0])) {
          const opts = options2[0];
          i18n.__composerExtend = opts.__composerExtend;
          i18n.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app, i18n.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n));
        }
        const unmountApp = app.unmount;
        app.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n.dispose();
          unmountApp();
        };
        if (true) {
          const ret = await enableDevTools(app, i18n);
          if (!ret) {
            throw createI18nError(I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
          }
          const emitter = createEmitter();
          if (__legacyMode) {
            const _vueI18n = __global;
            _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          } else {
            const _composer = __global;
            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
          }
          emitter.on("*", addTimelineEvent);
        }
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n.mode === "legacy" && !options.__useComponent) {
      if (!i18n.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options.__useComponent);
    if (composer2 == null) {
      if (true) {
        warn(getWarnMessage2(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
      }
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n) {
  return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
}
function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n, target, composer) {
  let emitter = null;
  {
    onMounted(() => {
      if (target.vnode.el) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter();
        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on("*", addTimelineEvent);
      }
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      if (target.vnode.el && target.vnode.el.__VUE_I18N__) {
        emitter && emitter.off("*", addTimelineEvent);
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }
      i18n.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root, options = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString(options.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction(options.missing) ? options.missing : null;
  const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocalScope ? root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocalScope && root.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn2) {
    trackReactivityValues();
    return fn2();
  }
  function t10(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm2(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format4) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format4);
      _datetimeFormats.value[locale2] = format4;
    }
  }
  function mergeDateTimeFormat(locale2, format4) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format4);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format4) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format4);
      _numberFormats.value[locale2] = format4;
    }
  }
  function mergeNumberFormat(locale2, format4) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format4);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t: t10,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm: tm2,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
var globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
var globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app, composer) {
  const i18n = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags2();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue$1);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (true) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
if (true) ;

// node_modules/@ksware/ksw-ux/kingsware-ui/index.js
var pm = Object.defineProperty;
var hm = (e16, t10, n) => t10 in e16 ? pm(e16, t10, { enumerable: true, configurable: true, writable: true, value: n }) : e16[t10] = n;
var mr = (e16, t10, n) => hm(e16, typeof t10 != "symbol" ? t10 + "" : t10, n);
var fo = { size: "1em", color: "currentColor", spin: false, prefix: "ksw" };
function Ye(e16, t10, n) {
  return { name: "Icon" + e16, props: { size: { type: [String, Number], default: fo.size }, color: { type: String, default: fo.color }, rotate: { type: Number }, spin: { type: Boolean, default: t10 || fo.spin }, grayscale: { type: Boolean, default: false } }, setup(o) {
    return () => {
      const { spin: r, grayscale: a } = o, i = [`${fo.prefix}-icon`, `${fo.prefix}-icon-${e16}`];
      return r && i.push(`${fo.prefix}-icon-spin`), a && i.push(`${fo.prefix}-icon-grayscale`), createVNode("span", { class: i.join(" ") }, [n(o)]);
    };
  } };
}
var _p = Ye("Add", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M11.25 4.5q0-.074.014-.146.015-.073.043-.141t.07-.13q.04-.061.093-.113.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043T12 3.75t.146.014.141.043.13.07.113.093q.053.052.094.113.04.062.069.13.028.068.043.14t.014.147v6.75h6.75q.074 0 .146.014.073.015.141.043t.13.07q.061.04.113.093.053.052.094.113.04.062.069.13.028.068.043.14t.014.147-.014.146-.043.141-.07.13-.093.113q-.052.053-.113.094-.062.04-.13.069-.068.028-.14.043t-.147.014h-6.75v6.75q0 .074-.014.146-.015.073-.043.141t-.07.13q-.04.061-.093.113-.052.053-.113.094-.062.04-.13.069-.068.028-.14.043T12 20.25t-.146-.014-.141-.043-.13-.07-.113-.093q-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14t-.014-.147v-6.75H4.5q-.074 0-.146-.014-.073-.015-.141-.043t-.13-.07q-.061-.04-.113-.093-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14T3.75 12t.014-.146.043-.141.07-.13.093-.113q.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043t.147-.014h6.75z" }, null)]);
});
var wp = Ye("ArrowLeft", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "m7.477 12 6.363-6.976a.6.6 0 0 0 .16-.409.624.624 0 0 0-.632-.615.64.64 0 0 0-.472.207L6.16 11.59a.604.604 0 0 0 0 .818l6.736 7.384a.64.64 0 0 0 .472.207.624.624 0 0 0 .632-.615.6.6 0 0 0-.16-.41z" }, null)]);
});
var vl = Ye("ArrowRight", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "m16.523 12-6.363 6.976a.6.6 0 0 0-.16.409c0 .34.283.615.632.615.18 0 .352-.075.472-.207l6.736-7.384a.604.604 0 0 0 0-.818l-6.736-7.384A.64.64 0 0 0 10.632 4a.624.624 0 0 0-.632.615c0 .151.057.297.16.41z" }, null)]);
});
var Tp = Ye("Check", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M20 6.075 8.657 19 4 14.283l1.173-1.145 3.413 3.457L18.76 5z" }, null)]);
});
var Cp = Ye("Clear", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M2 12C2 6.5 6.5 2 12 2s10 4.5 10 10-4.5 10-10 10S2 17.5 2 12m14.535-3.536q0 .2-.076.383-.076.184-.216.325L13.414 12l2.829 2.828q.07.07.124.152.055.082.092.173.038.09.057.187t.02.196-.02.195q-.019.096-.057.187-.037.091-.092.173t-.124.152q-.07.07-.152.124-.082.055-.173.092-.09.038-.187.057t-.195.02q-.099 0-.196-.02-.096-.019-.187-.057-.091-.037-.173-.092t-.152-.124L12 13.414l-2.829 2.829q-.14.14-.324.216t-.383.076-.382-.076-.325-.216q-.07-.07-.124-.152-.055-.082-.093-.173-.037-.09-.056-.187t-.02-.195q0-.099.02-.196.019-.096.056-.187t.093-.173.124-.152L10.586 12 7.757 9.172q-.07-.07-.124-.152-.055-.082-.092-.173-.038-.09-.057-.187t-.02-.196.02-.195q.019-.096.057-.187.037-.091.092-.173t.124-.152q.07-.07.152-.124.082-.055.173-.092.09-.038.187-.057t.195-.02q.099 0 .196.02.096.019.187.057.091.037.173.092t.152.124L12 10.586l2.828-2.829q.141-.14.325-.216.183-.077.382-.077.2 0 .383.077.184.076.325.216.14.141.216.325t.076.382" }, null)]);
});
var h0 = Ye("ClearDate", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "m13.163 12.346 6.393-7.922a.75.75 0 1 0-1.167-.941l-6.393 7.921a.75.75 0 1 0 1.167.942" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M2.292 21.375q0-4.604 2.251-7.528 2.48-3.222 6.832-3.222 1.001 0 1.709.708t.708 1.709l-.004.071q-.045.476-.207.925l-.023.056q-.755 1.667-.663 3.494t1.01 3.41a.75.75 0 0 1-.648 1.127H3.042a.75.75 0 0 1-.75-.75m9.76-.75H3.809q.164-3.578 1.923-5.863 2.03-2.637 5.643-2.637.38 0 .648.268.257.257.268.615-.029.254-.113.496-.89 1.985-.781 4.16.078 1.554.655 2.961M21.375 13.833h-4.167a.75.75 0 1 0 0 1.5h4.167a.75.75 0 0 0 0-1.5M21.375 17.167h-5a.75.75 0 1 0 0 1.5h5a.75.75 0 0 0 0-1.5M21.375 20.5h-3.333a.75.75 0 1 0 0 1.5h3.333a.75.75 0 1 0 0-1.5" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M12.307 14.782h-.017q-.055.001-.123.01-1.172.023-1.94-.87-.774-.9-.565-2.07a1 1 0 0 0 .012-.131v-.013a.75.75 0 0 0-.75-.737H8.92a.75.75 0 0 0-.734.618q-.335 1.87.904 3.311 1.237 1.44 3.133 1.392.064-.002.14-.012a.75.75 0 0 0 .695-.748v-.019a.75.75 0 0 0-.75-.731zM7.285 18.683q-.252 1.31-.162 2.641l.002.05a.75.75 0 0 1-.75.751.75.75 0 0 1-.748-.7q-.103-1.524.185-3.025a.75.75 0 0 1 1.473.283M10.223 18.661q-.267 1.65.153 2.312a.75.75 0 0 1 .117.374v.028a.75.75 0 0 1-.731.75h-.019a.75.75 0 0 1-.633-.348q-.726-1.143-.368-3.355a.75.75 0 0 1 .724-.63h.016a.75.75 0 0 1 .75.733v.017a1 1 0 0 1-.01.12" }, null)]);
});
var yl = Ye("Close", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M20 5.468 5.468 20 4 18.532 18.532 4z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M5.468 4 20 18.532 18.532 20 4 5.468z" }, null)]);
});
var kp = Ye("Delete", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { fill: "none", stroke: e16.color, "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "1.5", d: "m14.413 9.99-.27 7M9.856 16.99l-.269-7" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m5.52 5.733 1.068 13.882q.045.586.476.986.432.399 1.02.399h7.832q.588 0 1.02-.4.431-.399.476-.984L18.48 5.733q.006-.07.024-.137.018-.068.049-.131.03-.064.072-.12.042-.057.093-.104.052-.048.111-.085t.125-.063.135-.039.139-.013q.074 0 .146.014.073.015.141.043t.13.07q.061.04.113.093.053.052.094.113.04.062.069.13.028.068.043.14t.014.147l-.002.058-1.068 13.881q-.09 1.173-.953 1.971-.863.799-2.039.799H8.084q-1.176 0-2.039-.799-.863-.798-.953-1.97L4.024 5.847l-.002-.058q0-.074.014-.146.015-.073.043-.141t.07-.13q.04-.061.093-.113.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043t.147-.014q.07 0 .14.013.068.013.134.039.065.025.125.063.06.037.11.085.052.047.094.104t.072.12q.03.063.05.13.017.068.023.138" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M7.5 4.477v.916q0 .074.014.146.015.073.043.141t.07.13q.04.061.093.113.052.053.113.094.062.04.13.069.068.028.14.043t.147.014.146-.014.141-.043.13-.07.113-.093q.053-.052.094-.113.04-.062.069-.13.028-.068.043-.14T9 5.392v-.916q0-.591.399-1.015.394-.418.965-.436 1.636-.052 3.272 0 .571.018.966.436.398.423.398 1.015v.916q0 .074.014.146.015.073.043.141t.07.13q.04.061.093.113.052.053.113.094.062.04.13.069.068.028.14.043t.147.014.146-.014.141-.043.13-.07.113-.093q.053-.052.094-.113.04-.062.069-.13.028-.068.043-.14t.014-.147v-.916q0-1.187-.807-2.043-.819-.87-2.01-.908-1.683-.053-3.367 0-1.19.038-2.01.908-.806.857-.806 2.043" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M12 5.998q4.103 0 8.122.697.063.011.128.011.074 0 .146-.014.073-.015.141-.043t.13-.07q.061-.04.113-.093.053-.052.094-.113.04-.062.069-.13.028-.068.043-.14T21 5.955q0-.066-.011-.13-.012-.065-.034-.127t-.056-.119-.075-.107-.093-.092q-.05-.043-.107-.075-.057-.033-.12-.055-.061-.023-.126-.034-4.145-.72-8.378-.72-4.227.001-8.377.719-.066.011-.128.034-.061.022-.118.055-.057.032-.108.074-.05.043-.093.093t-.075.107-.056.119q-.022.062-.034.126Q3 5.89 3 5.955q0 .074.014.146.015.073.043.141t.07.13q.04.061.093.113.052.053.113.094.062.04.13.069.068.028.14.043t.147.014q.064 0 .128-.011Q7.9 5.998 12 5.998" }, null)]);
});
var bl = Ye("Drag", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { d: "M6 5q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T8 3t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178q.037.09.066.184.028.094.048.19.019.097.028.195T10 5t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117-.168.1q-.087.047-.178.085-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T8 7t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.094-.048-.19-.019-.097-.028-.195T6 5m0 7q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T8 10t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178q.037.09.066.184.028.094.048.19.019.097.028.195T10 12t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117q-.082.054-.168.1t-.178.085q-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T8 14t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.094-.048-.19-.019-.097-.028-.195T6 12m0 7q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T8 17t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178.066.184q.028.095.048.19.019.097.028.195T10 19t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117-.168.1q-.087.047-.178.085-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T8 21t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.095-.048-.19-.019-.097-.028-.195T6 19m7-14q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T15 3t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178q.037.09.066.184.028.094.048.19.019.097.028.195T17 5t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117-.168.1q-.087.047-.178.085-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T15 7t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.094-.048-.19-.019-.097-.028-.195T13 5m0 7q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T15 10t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178q.037.09.066.184.028.094.048.19.019.097.028.195T17 12t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117q-.082.054-.168.1t-.178.085q-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T15 14t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.094-.048-.19-.019-.097-.028-.195T13 12m0 7q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T15 17t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178.066.184q.028.095.048.19.019.097.028.195T17 19t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117-.168.1q-.087.047-.178.085-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T15 21t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.095-.048-.19-.019-.097-.028-.195T13 19" }, null)]);
});
var Sp = Ye("Edit", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { d: "M20.25 19.5H3.75a.75.75 0 1 0 0 1.5h16.5a.75.75 0 1 0 0-1.5" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M5.487 17.961a.7.7 0 0 1-.237.04.75.75 0 0 1-.705-.982l1.5-4.5a.75.75 0 0 1 .18-.3l9-8.999a.75.75 0 0 1 1.062 0l3 3a.75.75 0 0 1 0 1.062l-9 9a.75.75 0 0 1-.3.18zm.959-1.9 2.91-.97 8.34-8.34-1.94-1.94-8.34 8.34zm1.022-3.068.008-.023zm2.025 2.052.02-.007zm-4.48 1.493L5 16.543z" }, null)]);
});
var Np = Ye("EmptyBox", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M8.667 11.375h-5a.625.625 0 1 0 0 1.25h4.375V14.5c0 .345.28.625.625.625h6.666c.345 0 .625-.28.625-.625v-1.875h4.375a.625.625 0 0 0 0-1.25h-5a.625.625 0 0 0-.625.625v1.875H9.292V12a.625.625 0 0 0-.625-.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M20.919 11.78q.04.106.04.22v5q0 .95-.672 1.62-.671.672-1.62.672H5.333q-.949 0-1.62-.672-.671-.67-.671-1.62v-5q0-.114.04-.22l2.094-5.585q.251-.67.84-1.079.59-.408 1.306-.408h9.356q.717 0 1.306.408.589.409.84 1.08zm-3.265-5.146 2.054 5.48V17q0 .431-.305.737-.305.305-.736.305H5.333q-.431 0-.736-.305-.305-.306-.305-.737v-4.887l2.054-5.479q.254-.676.976-.676h9.356q.722 0 .976.676" }, null)]);
});
var Mp = Ye("File", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M16.375 15.75h-8.75a.625.625 0 1 0 0 1.25h8.75a.625.625 0 1 0 0-1.25M16.375 12h-8.75a.625.625 0 1 0 0 1.25h8.75a.625.625 0 1 0 0-1.25M10.125 8.25h-2.5a.625.625 0 1 0 0 1.25h2.5a.625.625 0 1 0 0-1.25" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M20.567 8.433a.63.63 0 0 1 .183.442v12.5c0 .345-.28.625-.625.625H3.875a.625.625 0 0 1-.625-.625V2.625c0-.345.28-.625.625-.625h10c.166 0 .325.066.442.183zm-6.95-5.183L19.5 9.134V20.75h-15V3.25z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M20.125 9.5h-6.25a.625.625 0 0 1-.625-.625v-6.25a.625.625 0 1 1 1.25 0V8.25h5.625a.625.625 0 1 1 0 1.25" }, null)]);
});
var Ir = Ye("FilterFill", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { d: "M4 4h16l-5.818 9.273v4.636L9.818 21v-7.727z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M8.818 13.56V21q0 .155.047.303t.137.275q.057.08.129.148.071.068.154.12.084.053.176.088t.189.052q.097.016.195.014.099-.003.195-.025t.186-.062.17-.097l4.364-3.09q.098-.07.176-.16.079-.091.134-.198.055-.106.083-.223.029-.116.029-.236V13.56l5.665-9.029Q21 4.288 21 4q0-.098-.02-.195-.018-.097-.056-.188-.038-.09-.093-.173-.054-.081-.124-.151t-.151-.124q-.082-.055-.173-.093t-.188-.057T20 3H4q-.288 0-.531.153-.084.052-.156.12-.071.068-.128.148t-.098.17-.062.186T3 3.97t.014.196.052.189.087.175zm2-.287q0-.288-.153-.532L5.808 5h12.384l-4.857 7.741q-.153.244-.153.532v4.119l-2.364 1.674z" }, null)]);
});
var La = Ye("Filter", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M9.068 21v-7.511l-5.703-9.09A.75.75 0 0 1 4 3.25h16a.75.75 0 0 1 .635 1.149l-5.703 9.09v4.42a.75.75 0 0 1-.317.612l-4.363 3.091A.75.75 0 0 1 9.068 21m1.385-8.126a.75.75 0 0 1 .115.399v6.277l2.864-2.029v-4.248c0-.141.04-.28.114-.399l5.098-8.124H5.356z" }, null)]);
});
var $p = Ye("Fold", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M13.628 13.1h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625h-7.714a.634.634 0 0 0-.643.625c0 .345.288.625.643.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m17.94 9.167-3.403 3.308 3.402 3.308a.617.617 0 0 1 0 .884.65.65 0 0 1-.423.182l-.03.001a.65.65 0 0 1-.455-.183l-3.858-3.75a.616.616 0 0 1 0-.884l3.858-3.75a.65.65 0 0 1 .909 0 .616.616 0 0 1 0 .884M10.342 11.85H2.628a.634.634 0 0 0-.643.625c0 .345.288.625.643.625h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m6.03 15.783 3.403-3.308-3.402-3.308a.617.617 0 0 1 0-.884.65.65 0 0 1 .423-.182l.031-.001c.17 0 .334.066.455.183l3.857 3.75a.616.616 0 0 1 0 .884l-3.857 3.75a.65.65 0 0 1-.91 0 .616.616 0 0 1 0-.884" }, null)]);
});
var xp = Ye("Hide", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M12.016 19.508q-3.089 0-6.019-2.305-1.892-1.488-3.449-3.693-.448-.64-.448-1.419 0-.778.446-1.415 1.56-2.208 3.451-3.696 2.93-2.305 6.02-2.305 3.088 0 6.018 2.305 1.893 1.488 3.45 3.693.448.64.448 1.418t-.446 1.416q-1.56 2.208-3.452 3.696-2.93 2.305-6.019 2.305m0-1.5q2.57 0 5.092-1.984 1.72-1.353 3.15-3.377.388-.556.002-1.109-1.432-2.026-3.152-3.38-2.522-1.983-5.092-1.983T6.925 8.159q-1.72 1.353-3.15 3.376-.389.556-.002 1.11 1.431 2.026 3.152 3.38 2.522 1.983 5.091 1.983" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M14.904 14.979Q16.1 13.783 16.1 12.09t-1.196-2.887-2.888-1.196T9.13 9.204t-1.196 2.887 1.196 2.888 2.887 1.196 2.888-1.196m-1.061-4.714q.757.756.757 1.826t-.757 1.827-1.827.757-1.826-.757-.757-1.827.757-1.826q.756-.757 1.826-.757t1.827.757" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M19.73 3.14 3.065 19.805a.75.75 0 1 0 1.06 1.06L20.793 4.2a.75.75 0 0 0-1.061-1.06" }, null)]);
});
var Ip = Ye("LeftMenuDisplay", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { d: "M3 4.25v-.5A.75.75 0 0 1 3.75 3h16.5a.75.75 0 0 1 .75.75v.5a.75.75 0 0 1-.75.75H3.75A.75.75 0 0 1 3 4.25M3 20.25v-.5a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 .75.75v.5a.75.75 0 0 1-.75.75H3.75a.75.75 0 0 1-.75-.75M11 9.5V9a.75.75 0 0 1 .75-.75h8.5A.75.75 0 0 1 21 9v.5a.75.75 0 0 1-.75.75h-8.5A.75.75 0 0 1 11 9.5M11 15v-.5a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 .75.75v.5a.75.75 0 0 1-.75.75h-8.5A.75.75 0 0 1 11 15M3 15.138a.5.5 0 0 0 .748.435l5.492-3.139a.5.5 0 0 0 0-.868L3.748 8.427A.5.5 0 0 0 3 8.862z" }, null)]);
});
var Dp = Ye("Loading", true, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M21.298 15.68Q22 13.908 22 12t-.702-3.68q-.762-1.927-2.227-3.391-1.464-1.465-3.39-2.227Q13.907 2 12 2t-3.68.702q-1.927.762-3.391 2.227-1.465 1.464-2.227 3.39Q2 10.093 2 12t.702 3.68q.762 1.927 2.227 3.391t3.39 2.227Q10.093 22 12 22t3.68-.702q1.927-.762 3.391-2.227t2.227-3.39m-1.86-6.625Q20 10.475 20 12q0 1.526-.562 2.945-.61 1.54-1.781 2.712-1.172 1.171-2.712 1.781Q13.525 20 12 20q-1.526 0-2.945-.562-1.54-.61-2.712-1.781-1.171-1.172-1.781-2.712Q4 13.525 4 12q0-1.526.562-2.945.61-1.54 1.781-2.712 1.172-1.171 2.712-1.781Q10.475 4 12 4q1.526 0 2.945.562 1.54.61 2.712 1.781 1.171 1.172 1.781 2.712", style: "opacity:.4000000059604645" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M12 4h-1V2h1q2.034 0 3.893.786 1.795.76 3.178 2.143t2.143 3.178Q22 9.967 22 12v1h-2v-1q0-3.314-2.343-5.657T12 4" }, null)]);
});
var oi = Ye("More", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("rect", { width: "4", height: "4", x: "3", y: "10", rx: "2" }, null), createVNode("rect", { width: "4", height: "4", x: "10", y: "10", rx: "2" }, null), createVNode("rect", { width: "4", height: "4", x: "17", y: "10", rx: "2" }, null)]);
});
var g0 = Ye("Refresh", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M18.592 7.487q-1.715-2.693-4.797-3.49-3.137-.81-5.963.833-1.665.968-2.714 2.57-1.006 1.534-1.276 3.376-.27 1.843.25 3.612.545 1.847 1.86 3.273 1.312 1.421 3.11 2.086 1.72.636 3.57.471 1.85-.164 3.434-1.094 1.655-.972 2.702-2.605v-.001a.75.75 0 0 1 1.264.809q-1.24 1.937-3.207 3.09-1.874 1.102-4.061 1.296t-4.223-.56q-2.135-.789-3.69-2.475-1.554-1.683-2.197-3.866-.615-2.085-.296-4.254.318-2.17 1.505-3.98Q5.107 4.68 7.078 3.532q3.358-1.953 7.093-.988 1.74.45 3.202 1.504 1.493 1.077 2.484 2.632a.75.75 0 1 1-1.265.806" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M15 7.25h4.25V2.5h1.5v6.25H15z" }, null)]);
});
var Dr = Ye("Search", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M15.426 15.401a.745.745 0 0 1 1.058 0l4.794 4.817a.755.755 0 0 1 0 1.064.745.745 0 0 1-1.056 0l-4.795-4.817a.755.755 0 0 1 0-1.064" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M18.17 13.537q.58-1.463.58-3.037t-.58-3.037q-.628-1.588-1.836-2.797-1.209-1.208-2.797-1.837-1.463-.579-3.037-.579t-3.037.58q-1.588.628-2.797 1.836Q3.458 5.875 2.83 7.463 2.25 8.926 2.25 10.5t.58 3.037q.628 1.588 1.836 2.797 1.209 1.208 2.797 1.837 1.463.579 3.037.579t3.037-.58q1.588-.628 2.797-1.836 1.208-1.209 1.837-2.797m-2.897-7.81Q17.25 7.704 17.25 10.5t-1.977 4.773T10.5 17.25t-4.773-1.977T3.75 10.5t1.977-4.773T10.5 3.75t4.773 1.977" }, null)]);
});
function Dn(e16) {
  if (e16 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e16;
}
function v0(e16, t10) {
  e16.prototype = Object.create(t10.prototype), e16.prototype.constructor = e16, e16.__proto__ = t10;
}
var Qt = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } };
var ra = { duration: 0.5, overwrite: false, delay: 0 };
var _l;
var Kt;
var dt;
var an = 1e8;
var at = 1 / an;
var Ns = Math.PI * 2;
var Ap = Ns / 4;
var Ep = 0;
var y0 = Math.sqrt;
var Kp = Math.cos;
var zp = Math.sin;
var It = function(e16) {
  return typeof e16 == "string";
};
var yt = function(e16) {
  return typeof e16 == "function";
};
var Pn = function(e16) {
  return typeof e16 == "number";
};
var wl = function(e16) {
  return typeof e16 > "u";
};
var $n = function(e16) {
  return typeof e16 == "object";
};
var jt = function(e16) {
  return e16 !== false;
};
var Tl = function() {
  return typeof window < "u";
};
var pr = function(e16) {
  return yt(e16) || It(e16);
};
var b0 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
};
var zt = Array.isArray;
var Ms = /(?:-?\.?\d|\.)+/gi;
var _0 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
var Ho = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
var Li = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
var w0 = /[+-]=-?[.\d]+/;
var T0 = /[^,'"\[\]\s]+/gi;
var Pp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
var mt;
var yn;
var $s;
var Cl;
var en = {};
var Ar = {};
var C0;
var k0 = function(e16) {
  return (Ar = Mo(e16, en)) && Wt;
};
var kl = function(e16, t10) {
  return console.warn("Invalid property", e16, "set to", t10, "Missing plugin? gsap.registerPlugin()");
};
var Fa = function(e16, t10) {
  return !t10 && console.warn(e16);
};
var S0 = function(e16, t10) {
  return e16 && (en[e16] = t10) && Ar && (Ar[e16] = t10) || en;
};
var ja = function() {
  return 0;
};
var Rp = { suppressEvents: true, isStart: true, kill: false };
var wr = { suppressEvents: true, kill: false };
var Lp = { suppressEvents: true };
var Sl = {};
var Gn = [];
var xs = {};
var N0;
var Ht = {};
var Fi = {};
var Tc = 30;
var Tr = [];
var Nl = "";
var Ml = function(e16) {
  var t10 = e16[0], n, o;
  if ($n(t10) || yt(t10) || (e16 = [e16]), !(n = (t10._gsap || {}).harness)) {
    for (o = Tr.length; o-- && !Tr[o].targetTest(t10); ) ;
    n = Tr[o];
  }
  for (o = e16.length; o--; ) e16[o] && (e16[o]._gsap || (e16[o]._gsap = new X0(e16[o], n))) || e16.splice(o, 1);
  return e16;
};
var _o = function(e16) {
  return e16._gsap || Ml(rn(e16))[0]._gsap;
};
var M0 = function(e16, t10, n) {
  return (n = e16[t10]) && yt(n) ? e16[t10]() : wl(n) && e16.getAttribute && e16.getAttribute(t10) || n;
};
var Ot = function(e16, t10) {
  return (e16 = e16.split(",")).forEach(t10) || e16;
};
var _t2 = function(e16) {
  return Math.round(e16 * 1e5) / 1e5 || 0;
};
var $t = function(e16) {
  return Math.round(e16 * 1e7) / 1e7 || 0;
};
var Qo = function(e16, t10) {
  var n = t10.charAt(0), o = parseFloat(t10.substr(2));
  return e16 = parseFloat(e16), n === "+" ? e16 + o : n === "-" ? e16 - o : n === "*" ? e16 * o : e16 / o;
};
var Fp = function(e16, t10) {
  for (var n = t10.length, o = 0; e16.indexOf(t10[o]) < 0 && ++o < n; ) ;
  return o < n;
};
var Er = function() {
  var e16 = Gn.length, t10 = Gn.slice(0), n, o;
  for (xs = {}, Gn.length = 0, n = 0; n < e16; n++) o = t10[n], o && o._lazy && (o.render(o._lazy[0], o._lazy[1], true)._lazy = 0);
};
var $0 = function(e16, t10, n, o) {
  Gn.length && !Kt && Er(), e16.render(t10, n, Kt && t10 < 0 && (e16._initted || e16._startAt)), Gn.length && !Kt && Er();
};
var x0 = function(e16) {
  var t10 = parseFloat(e16);
  return (t10 || t10 === 0) && (e16 + "").match(T0).length < 2 ? t10 : It(e16) ? e16.trim() : e16;
};
var I0 = function(e16) {
  return e16;
};
var sn = function(e16, t10) {
  for (var n in t10) n in e16 || (e16[n] = t10[n]);
  return e16;
};
var jp = function(e16) {
  return function(t10, n) {
    for (var o in n) o in t10 || o === "duration" && e16 || o === "ease" || (t10[o] = n[o]);
  };
};
var Mo = function(e16, t10) {
  for (var n in t10) e16[n] = t10[n];
  return e16;
};
var Cc = function e(t10, n) {
  for (var o in n) o !== "__proto__" && o !== "constructor" && o !== "prototype" && (t10[o] = $n(n[o]) ? e(t10[o] || (t10[o] = {}), n[o]) : n[o]);
  return t10;
};
var Kr = function(e16, t10) {
  var n = {}, o;
  for (o in e16) o in t10 || (n[o] = e16[o]);
  return n;
};
var Ea = function(e16) {
  var t10 = e16.parent || mt, n = e16.keyframes ? jp(zt(e16.keyframes)) : sn;
  if (jt(e16.inherit)) for (; t10; ) n(e16, t10.vars.defaults), t10 = t10.parent || t10._dp;
  return e16;
};
var Op = function(e16, t10) {
  for (var n = e16.length, o = n === t10.length; o && n-- && e16[n] === t10[n]; ) ;
  return n < 0;
};
var D0 = function(e16, t10, n, o, r) {
  var a = e16[o], i;
  if (r) for (i = t10[r]; a && a[r] > i; ) a = a._prev;
  return a ? (t10._next = a._next, a._next = t10) : (t10._next = e16[n], e16[n] = t10), t10._next ? t10._next._prev = t10 : e16[o] = t10, t10._prev = a, t10.parent = t10._dp = e16, t10;
};
var ai = function(e16, t10, n, o) {
  n === void 0 && (n = "_first"), o === void 0 && (o = "_last");
  var r = t10._prev, a = t10._next;
  r ? r._next = a : e16[n] === t10 && (e16[n] = a), a ? a._prev = r : e16[o] === t10 && (e16[o] = r), t10._next = t10._prev = t10.parent = null;
};
var Jn = function(e16, t10) {
  e16.parent && (!t10 || e16.parent.autoRemoveChildren) && e16.parent.remove && e16.parent.remove(e16), e16._act = 0;
};
var wo = function(e16, t10) {
  if (e16 && (!t10 || t10._end > e16._dur || t10._start < 0)) for (var n = e16; n; ) n._dirty = 1, n = n.parent;
  return e16;
};
var Bp = function(e16) {
  for (var t10 = e16.parent; t10 && t10.parent; ) t10._dirty = 1, t10.totalDuration(), t10 = t10.parent;
  return e16;
};
var Is = function(e16, t10, n, o) {
  return e16._startAt && (Kt ? e16._startAt.revert(wr) : e16.vars.immediateRender && !e16.vars.autoRevert || e16._startAt.render(t10, true, o));
};
var Zp = function e2(t10) {
  return !t10 || t10._ts && e2(t10.parent);
};
var kc = function(e16) {
  return e16._repeat ? ia(e16._tTime, e16 = e16.duration() + e16._rDelay) * e16 : 0;
};
var ia = function(e16, t10) {
  var n = Math.floor(e16 /= t10);
  return e16 && n === e16 ? n - 1 : n;
};
var zr = function(e16, t10) {
  return (e16 - t10._start) * t10._ts + (t10._ts >= 0 ? 0 : t10._dirty ? t10.totalDuration() : t10._tDur);
};
var ri = function(e16) {
  return e16._end = $t(e16._start + (e16._tDur / Math.abs(e16._ts || e16._rts || at) || 0));
};
var ii = function(e16, t10) {
  var n = e16._dp;
  return n && n.smoothChildTiming && e16._ts && (e16._start = $t(n._time - (e16._ts > 0 ? t10 / e16._ts : ((e16._dirty ? e16.totalDuration() : e16._tDur) - t10) / -e16._ts)), ri(e16), n._dirty || wo(n, e16)), e16;
};
var A0 = function(e16, t10) {
  var n;
  if ((t10._time || !t10._dur && t10._initted || t10._start < e16._time && (t10._dur || !t10.add)) && (n = zr(e16.rawTime(), t10), (!t10._dur || er(0, t10.totalDuration(), n) - t10._tTime > at) && t10.render(n, true)), wo(e16, t10)._dp && e16._initted && e16._time >= e16._dur && e16._ts) {
    if (e16._dur < e16.duration()) for (n = e16; n._dp; ) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
    e16._zTime = -at;
  }
};
var _n = function(e16, t10, n, o) {
  return t10.parent && Jn(t10), t10._start = $t((Pn(n) ? n : n || e16 !== mt ? on2(e16, n, t10) : e16._time) + t10._delay), t10._end = $t(t10._start + (t10.totalDuration() / Math.abs(t10.timeScale()) || 0)), D0(e16, t10, "_first", "_last", e16._sort ? "_start" : 0), Ds(t10) || (e16._recent = t10), o || A0(e16, t10), e16._ts < 0 && ii(e16, e16._tTime), e16;
};
var E0 = function(e16, t10) {
  return (en.ScrollTrigger || kl("scrollTrigger", t10)) && en.ScrollTrigger.create(t10, e16);
};
var K0 = function(e16, t10, n, o, r) {
  if (xl(e16, t10, r), !e16._initted) return 1;
  if (!n && e16._pt && !Kt && (e16._dur && e16.vars.lazy !== false || !e16._dur && e16.vars.lazy) && N0 !== Ut.frame) return Gn.push(e16), e16._lazy = [r, o], 1;
};
var Wp = function e3(t10) {
  var n = t10.parent;
  return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e3(n));
};
var Ds = function(e16) {
  var t10 = e16.data;
  return t10 === "isFromStart" || t10 === "isStart";
};
var qp = function(e16, t10, n, o) {
  var r = e16.ratio, a = t10 < 0 || !t10 && (!e16._start && Wp(e16) && !(!e16._initted && Ds(e16)) || (e16._ts < 0 || e16._dp._ts < 0) && !Ds(e16)) ? 0 : 1, i = e16._rDelay, s = 0, l, c, u;
  if (i && e16._repeat && (s = er(0, e16._tDur, t10), c = ia(s, i), e16._yoyo && c & 1 && (a = 1 - a), c !== ia(e16._tTime, i) && (r = 1 - a, e16.vars.repeatRefresh && e16._initted && e16.invalidate())), a !== r || Kt || o || e16._zTime === at || !t10 && e16._zTime) {
    if (!e16._initted && K0(e16, t10, o, n, s)) return;
    for (u = e16._zTime, e16._zTime = t10 || (n ? at : 0), n || (n = t10 && !u), e16.ratio = a, e16._from && (a = 1 - a), e16._time = 0, e16._tTime = s, l = e16._pt; l; ) l.r(a, l.d), l = l._next;
    t10 < 0 && Is(e16, t10, n, true), e16._onUpdate && !n && Yt(e16, "onUpdate"), s && e16._repeat && !n && e16.parent && Yt(e16, "onRepeat"), (t10 >= e16._tDur || t10 < 0) && e16.ratio === a && (a && Jn(e16, 1), !n && !Kt && (Yt(e16, a ? "onComplete" : "onReverseComplete", true), e16._prom && e16._prom()));
  } else e16._zTime || (e16._zTime = t10);
};
var Vp = function(e16, t10, n) {
  var o;
  if (n > t10) for (o = e16._first; o && o._start <= n; ) {
    if (o.data === "isPause" && o._start > t10) return o;
    o = o._next;
  }
  else for (o = e16._last; o && o._start >= n; ) {
    if (o.data === "isPause" && o._start < t10) return o;
    o = o._prev;
  }
};
var sa = function(e16, t10, n, o) {
  var r = e16._repeat, a = $t(t10) || 0, i = e16._tTime / e16._tDur;
  return i && !o && (e16._time *= a / e16._dur), e16._dur = a, e16._tDur = r ? r < 0 ? 1e10 : $t(a * (r + 1) + e16._rDelay * r) : a, i > 0 && !o && ii(e16, e16._tTime = e16._tDur * i), e16.parent && ri(e16), n || wo(e16.parent, e16), e16;
};
var Sc = function(e16) {
  return e16 instanceof Pt ? wo(e16) : sa(e16, e16._dur);
};
var Hp = { _start: 0, endTime: ja, totalDuration: ja };
var on2 = function e4(t10, n, o) {
  var r = t10.labels, a = t10._recent || Hp, i = t10.duration() >= an ? a.endTime(false) : t10._dur, s, l, c;
  return It(n) && (isNaN(n) || n in r) ? (l = n.charAt(0), c = n.substr(-1) === "%", s = n.indexOf("="), l === "<" || l === ">" ? (s >= 0 && (n = n.replace(/=/, "")), (l === "<" ? a._start : a.endTime(a._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (c ? (s < 0 ? a : o).totalDuration() / 100 : 1)) : s < 0 ? (n in r || (r[n] = i), r[n]) : (l = parseFloat(n.charAt(s - 1) + n.substr(s + 1)), c && o && (l = l / 100 * (zt(o) ? o[0] : o).totalDuration()), s > 1 ? e4(t10, n.substr(0, s - 1), o) + l : i + l)) : n == null ? i : +n;
};
var Ka = function(e16, t10, n) {
  var o = Pn(t10[1]), r = (o ? 2 : 1) + (e16 < 2 ? 0 : 1), a = t10[r], i, s;
  if (o && (a.duration = t10[1]), a.parent = n, e16) {
    for (i = a, s = n; s && !("immediateRender" in i); ) i = s.vars.defaults || {}, s = jt(s.vars.inherit) && s.parent;
    a.immediateRender = jt(i.immediateRender), e16 < 2 ? a.runBackwards = 1 : a.startAt = t10[r - 1];
  }
  return new Tt(t10[0], a, t10[r + 1]);
};
var io = function(e16, t10) {
  return e16 || e16 === 0 ? t10(e16) : t10;
};
var er = function(e16, t10, n) {
  return n < e16 ? e16 : n > t10 ? t10 : n;
};
var Et = function(e16, t10) {
  return !It(e16) || !(t10 = Pp.exec(e16)) ? "" : t10[1];
};
var Up = function(e16, t10, n) {
  return io(n, function(o) {
    return er(e16, t10, o);
  });
};
var As = [].slice;
var z0 = function(e16, t10) {
  return e16 && $n(e16) && "length" in e16 && (!t10 && !e16.length || e16.length - 1 in e16 && $n(e16[0])) && !e16.nodeType && e16 !== yn;
};
var Gp = function(e16, t10, n) {
  return n === void 0 && (n = []), e16.forEach(function(o) {
    var r;
    return It(o) && !t10 || z0(o, 1) ? (r = n).push.apply(r, rn(o)) : n.push(o);
  }) || n;
};
var rn = function(e16, t10, n) {
  return dt && !t10 && dt.selector ? dt.selector(e16) : It(e16) && !n && ($s || !la()) ? As.call((t10 || Cl).querySelectorAll(e16), 0) : zt(e16) ? Gp(e16, n) : z0(e16) ? As.call(e16, 0) : e16 ? [e16] : [];
};
var Es = function(e16) {
  return e16 = rn(e16)[0] || Fa("Invalid scope") || {}, function(t10) {
    var n = e16.current || e16.nativeElement || e16;
    return rn(t10, n.querySelectorAll ? n : n === e16 ? Fa("Invalid scope") || Cl.createElement("div") : e16);
  };
};
var P0 = function(e16) {
  return e16.sort(function() {
    return 0.5 - Math.random();
  });
};
var R0 = function(e16) {
  if (yt(e16)) return e16;
  var t10 = $n(e16) ? e16 : { each: e16 }, n = To(t10.ease), o = t10.from || 0, r = parseFloat(t10.base) || 0, a = {}, i = o > 0 && o < 1, s = isNaN(o) || i, l = t10.axis, c = o, u = o;
  return It(o) ? c = u = { center: 0.5, edges: 0.5, end: 1 }[o] || 0 : !i && s && (c = o[0], u = o[1]), function(d, m, p) {
    var f = (p || t10).length, h10 = a[f], g, v, y, k, T, w, _, M, x;
    if (!h10) {
      if (x = t10.grid === "auto" ? 0 : (t10.grid || [1, an])[1], !x) {
        for (_ = -an; _ < (_ = p[x++].getBoundingClientRect().left) && x < f; ) ;
        x < f && x--;
      }
      for (h10 = a[f] = [], g = s ? Math.min(x, f) * c - 0.5 : o % x, v = x === an ? 0 : s ? f * u / x - 0.5 : o / x | 0, _ = 0, M = an, w = 0; w < f; w++) y = w % x - g, k = v - (w / x | 0), h10[w] = T = l ? Math.abs(l === "y" ? k : y) : y0(y * y + k * k), T > _ && (_ = T), T < M && (M = T);
      o === "random" && P0(h10), h10.max = _ - M, h10.min = M, h10.v = f = (parseFloat(t10.amount) || parseFloat(t10.each) * (x > f ? f - 1 : l ? l === "y" ? f / x : x : Math.max(x, f / x)) || 0) * (o === "edges" ? -1 : 1), h10.b = f < 0 ? r - f : r, h10.u = Et(t10.amount || t10.each) || 0, n = n && f < 0 ? H0(n) : n;
    }
    return f = (h10[d] - h10.min) / h10.max || 0, $t(h10.b + (n ? n(f) : f) * h10.v) + h10.u;
  };
};
var Ks = function(e16) {
  var t10 = Math.pow(10, ((e16 + "").split(".")[1] || "").length);
  return function(n) {
    var o = $t(Math.round(parseFloat(n) / e16) * e16 * t10);
    return (o - o % 1) / t10 + (Pn(n) ? 0 : Et(n));
  };
};
var L0 = function(e16, t10) {
  var n = zt(e16), o, r;
  return !n && $n(e16) && (o = n = e16.radius || an, e16.values ? (e16 = rn(e16.values), (r = !Pn(e16[0])) && (o *= o)) : e16 = Ks(e16.increment)), io(t10, n ? yt(e16) ? function(a) {
    return r = e16(a), Math.abs(r - a) <= o ? r : a;
  } : function(a) {
    for (var i = parseFloat(r ? a.x : a), s = parseFloat(r ? a.y : 0), l = an, c = 0, u = e16.length, d, m; u--; ) r ? (d = e16[u].x - i, m = e16[u].y - s, d = d * d + m * m) : d = Math.abs(e16[u] - i), d < l && (l = d, c = u);
    return c = !o || l <= o ? e16[c] : a, r || c === a || Pn(a) ? c : c + Et(a);
  } : Ks(e16));
};
var F0 = function(e16, t10, n, o) {
  return io(zt(e16) ? !t10 : n === true ? !!(n = 0) : !o, function() {
    return zt(e16) ? e16[~~(Math.random() * e16.length)] : (n = n || 1e-5) && (o = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e16 - n / 2 + Math.random() * (t10 - e16 + n * 0.99)) / n) * n * o) / o;
  });
};
var Xp = function() {
  for (var e16 = arguments.length, t10 = new Array(e16), n = 0; n < e16; n++) t10[n] = arguments[n];
  return function(o) {
    return t10.reduce(function(r, a) {
      return a(r);
    }, o);
  };
};
var Yp = function(e16, t10) {
  return function(n) {
    return e16(parseFloat(n)) + (t10 || Et(n));
  };
};
var Qp = function(e16, t10, n) {
  return O0(e16, t10, 0, 1, n);
};
var j0 = function(e16, t10, n) {
  return io(n, function(o) {
    return e16[~~t10(o)];
  });
};
var Jp = function e5(t10, n, o) {
  var r = n - t10;
  return zt(t10) ? j0(t10, e5(0, t10.length), n) : io(o, function(a) {
    return (r + (a - t10) % r) % r + t10;
  });
};
var eh = function e6(t10, n, o) {
  var r = n - t10, a = r * 2;
  return zt(t10) ? j0(t10, e6(0, t10.length - 1), n) : io(o, function(i) {
    return i = (a + (i - t10) % a) % a || 0, t10 + (i > r ? a - i : i);
  });
};
var Oa = function(e16) {
  for (var t10 = 0, n = "", o, r, a, i; ~(o = e16.indexOf("random(", t10)); ) a = e16.indexOf(")", o), i = e16.charAt(o + 7) === "[", r = e16.substr(o + 7, a - o - 7).match(i ? T0 : Ms), n += e16.substr(t10, o - t10) + F0(i ? r : +r[0], i ? 0 : +r[1], +r[2] || 1e-5), t10 = a + 1;
  return n + e16.substr(t10, e16.length - t10);
};
var O0 = function(e16, t10, n, o, r) {
  var a = t10 - e16, i = o - n;
  return io(r, function(s) {
    return n + ((s - e16) / a * i || 0);
  });
};
var th = function e7(t10, n, o, r) {
  var a = isNaN(t10 + n) ? 0 : function(p) {
    return (1 - p) * t10 + p * n;
  };
  if (!a) {
    var i = It(t10), s = {}, l, c, u, d, m;
    if (o === true && (r = 1) && (o = null), i) t10 = { p: t10 }, n = { p: n };
    else if (zt(t10) && !zt(n)) {
      for (u = [], d = t10.length, m = d - 2, c = 1; c < d; c++) u.push(e7(t10[c - 1], t10[c]));
      d--, a = function(p) {
        p *= d;
        var f = Math.min(m, ~~p);
        return u[f](p - f);
      }, o = n;
    } else r || (t10 = Mo(zt(t10) ? [] : {}, t10));
    if (!u) {
      for (l in n) $l.call(s, t10, l, "get", n[l]);
      a = function(p) {
        return Al(p, s) || (i ? t10.p : t10);
      };
    }
  }
  return io(o, a);
};
var Nc = function(e16, t10, n) {
  var o = e16.labels, r = an, a, i, s;
  for (a in o) i = o[a] - t10, i < 0 == !!n && i && r > (i = Math.abs(i)) && (s = a, r = i);
  return s;
};
var Yt = function(e16, t10, n) {
  var o = e16.vars, r = o[t10], a = dt, i = e16._ctx, s, l, c;
  if (r) return s = o[t10 + "Params"], l = o.callbackScope || e16, n && Gn.length && Er(), i && (dt = i), c = s ? r.apply(l, s) : r.call(l), dt = a, c;
};
var Da = function(e16) {
  return Jn(e16), e16.scrollTrigger && e16.scrollTrigger.kill(!!Kt), e16.progress() < 1 && Yt(e16, "onInterrupt"), e16;
};
var Uo;
var B0 = [];
var Z0 = function(e16) {
  if (e16) if (e16 = !e16.name && e16.default || e16, Tl() || e16.headless) {
    var t10 = e16.name, n = yt(e16), o = t10 && !n && e16.init ? function() {
      this._props = [];
    } : e16, r = { init: ja, render: Al, add: $l, kill: vh, modifier: gh, rawVars: 0 }, a = { targetTest: 0, get: 0, getSetter: Dl, aliases: {}, register: 0 };
    if (la(), e16 !== o) {
      if (Ht[t10]) return;
      sn(o, sn(Kr(e16, r), a)), Mo(o.prototype, Mo(r, Kr(e16, a))), Ht[o.prop = t10] = o, e16.targetTest && (Tr.push(o), Sl[t10] = 1), t10 = (t10 === "css" ? "CSS" : t10.charAt(0).toUpperCase() + t10.substr(1)) + "Plugin";
    }
    S0(t10, o), e16.register && e16.register(Wt, o, Bt);
  } else B0.push(e16);
};
var nt = 255;
var Aa = { aqua: [0, nt, nt], lime: [0, nt, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, nt], navy: [0, 0, 128], white: [nt, nt, nt], olive: [128, 128, 0], yellow: [nt, nt, 0], orange: [nt, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [nt, 0, 0], pink: [nt, 192, 203], cyan: [0, nt, nt], transparent: [nt, nt, nt, 0] };
var ji = function(e16, t10, n) {
  return e16 += e16 < 0 ? 1 : e16 > 1 ? -1 : 0, (e16 * 6 < 1 ? t10 + (n - t10) * e16 * 6 : e16 < 0.5 ? n : e16 * 3 < 2 ? t10 + (n - t10) * (2 / 3 - e16) * 6 : t10) * nt + 0.5 | 0;
};
var W0 = function(e16, t10, n) {
  var o = e16 ? Pn(e16) ? [e16 >> 16, e16 >> 8 & nt, e16 & nt] : 0 : Aa.black, r, a, i, s, l, c, u, d, m, p;
  if (!o) {
    if (e16.substr(-1) === "," && (e16 = e16.substr(0, e16.length - 1)), Aa[e16]) o = Aa[e16];
    else if (e16.charAt(0) === "#") {
      if (e16.length < 6 && (r = e16.charAt(1), a = e16.charAt(2), i = e16.charAt(3), e16 = "#" + r + r + a + a + i + i + (e16.length === 5 ? e16.charAt(4) + e16.charAt(4) : "")), e16.length === 9) return o = parseInt(e16.substr(1, 6), 16), [o >> 16, o >> 8 & nt, o & nt, parseInt(e16.substr(7), 16) / 255];
      e16 = parseInt(e16.substr(1), 16), o = [e16 >> 16, e16 >> 8 & nt, e16 & nt];
    } else if (e16.substr(0, 3) === "hsl") {
      if (o = p = e16.match(Ms), !t10) s = +o[0] % 360 / 360, l = +o[1] / 100, c = +o[2] / 100, a = c <= 0.5 ? c * (l + 1) : c + l - c * l, r = c * 2 - a, o.length > 3 && (o[3] *= 1), o[0] = ji(s + 1 / 3, r, a), o[1] = ji(s, r, a), o[2] = ji(s - 1 / 3, r, a);
      else if (~e16.indexOf("=")) return o = e16.match(_0), n && o.length < 4 && (o[3] = 1), o;
    } else o = e16.match(Ms) || Aa.transparent;
    o = o.map(Number);
  }
  return t10 && !p && (r = o[0] / nt, a = o[1] / nt, i = o[2] / nt, u = Math.max(r, a, i), d = Math.min(r, a, i), c = (u + d) / 2, u === d ? s = l = 0 : (m = u - d, l = c > 0.5 ? m / (2 - u - d) : m / (u + d), s = u === r ? (a - i) / m + (a < i ? 6 : 0) : u === a ? (i - r) / m + 2 : (r - a) / m + 4, s *= 60), o[0] = ~~(s + 0.5), o[1] = ~~(l * 100 + 0.5), o[2] = ~~(c * 100 + 0.5)), n && o.length < 4 && (o[3] = 1), o;
};
var q0 = function(e16) {
  var t10 = [], n = [], o = -1;
  return e16.split(Xn).forEach(function(r) {
    var a = r.match(Ho) || [];
    t10.push.apply(t10, a), n.push(o += a.length + 1);
  }), t10.c = n, t10;
};
var Mc = function(e16, t10, n) {
  var o = "", r = (e16 + o).match(Xn), a = t10 ? "hsla(" : "rgba(", i = 0, s, l, c, u;
  if (!r) return e16;
  if (r = r.map(function(d) {
    return (d = W0(d, t10, 1)) && a + (t10 ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")";
  }), n && (c = q0(e16), s = n.c, s.join(o) !== c.c.join(o))) for (l = e16.replace(Xn, "1").split(Ho), u = l.length - 1; i < u; i++) o += l[i] + (~s.indexOf(i) ? r.shift() || a + "0,0,0,0)" : (c.length ? c : r.length ? r : n).shift());
  if (!l) for (l = e16.split(Xn), u = l.length - 1; i < u; i++) o += l[i] + r[i];
  return o + l[u];
};
var Xn = function() {
  var e16 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", t10;
  for (t10 in Aa) e16 += "|" + t10 + "\\b";
  return new RegExp(e16 + ")", "gi");
}();
var nh = /hsl[a]?\(/;
var V0 = function(e16) {
  var t10 = e16.join(" "), n;
  if (Xn.lastIndex = 0, Xn.test(t10)) return n = nh.test(t10), e16[1] = Mc(e16[1], n), e16[0] = Mc(e16[0], n, q0(e16[1])), true;
};
var Ba;
var Ut = function() {
  var e16 = Date.now, t10 = 500, n = 33, o = e16(), r = o, a = 1e3 / 240, i = a, s = [], l, c, u, d, m, p, f = function h10(g) {
    var v = e16() - r, y = g === true, k, T, w, _;
    if ((v > t10 || v < 0) && (o += v - n), r += v, w = r - o, k = w - i, (k > 0 || y) && (_ = ++d.frame, m = w - d.time * 1e3, d.time = w = w / 1e3, i += k + (k >= a ? 4 : a - k), T = 1), y || (l = c(h10)), T) for (p = 0; p < s.length; p++) s[p](w, m, _, g);
  };
  return d = { time: 0, frame: 0, tick: function() {
    f(true);
  }, deltaRatio: function(h10) {
    return m / (1e3 / (h10 || 60));
  }, wake: function() {
    C0 && (!$s && Tl() && (yn = $s = window, Cl = yn.document || {}, en.gsap = Wt, (yn.gsapVersions || (yn.gsapVersions = [])).push(Wt.version), k0(Ar || yn.GreenSockGlobals || !yn.gsap && yn || {}), B0.forEach(Z0)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && d.sleep(), c = u || function(h10) {
      return setTimeout(h10, i - d.time * 1e3 + 1 | 0);
    }, Ba = 1, f(2));
  }, sleep: function() {
    (u ? cancelAnimationFrame : clearTimeout)(l), Ba = 0, c = ja;
  }, lagSmoothing: function(h10, g) {
    t10 = h10 || 1 / 0, n = Math.min(g || 33, t10);
  }, fps: function(h10) {
    a = 1e3 / (h10 || 240), i = d.time * 1e3 + a;
  }, add: function(h10, g, v) {
    var y = g ? function(k, T, w, _) {
      h10(k, T, w, _), d.remove(y);
    } : h10;
    return d.remove(h10), s[v ? "unshift" : "push"](y), la(), y;
  }, remove: function(h10, g) {
    ~(g = s.indexOf(h10)) && s.splice(g, 1) && p >= g && p--;
  }, _listeners: s }, d;
}();
var la = function() {
  return !Ba && Ut.wake();
};
var Oe = {};
var oh = /^[\d.\-M][\d.\-,\s]/;
var ah = /["']/g;
var rh = function(e16) {
  for (var t10 = {}, n = e16.substr(1, e16.length - 3).split(":"), o = n[0], r = 1, a = n.length, i, s, l; r < a; r++) s = n[r], i = r !== a - 1 ? s.lastIndexOf(",") : s.length, l = s.substr(0, i), t10[o] = isNaN(l) ? l.replace(ah, "").trim() : +l, o = s.substr(i + 1).trim();
  return t10;
};
var ih = function(e16) {
  var t10 = e16.indexOf("(") + 1, n = e16.indexOf(")"), o = e16.indexOf("(", t10);
  return e16.substring(t10, ~o && o < n ? e16.indexOf(")", n + 1) : n);
};
var sh = function(e16) {
  var t10 = (e16 + "").split("("), n = Oe[t10[0]];
  return n && t10.length > 1 && n.config ? n.config.apply(null, ~e16.indexOf("{") ? [rh(t10[1])] : ih(e16).split(",").map(x0)) : Oe._CE && oh.test(e16) ? Oe._CE("", e16) : n;
};
var H0 = function(e16) {
  return function(t10) {
    return 1 - e16(1 - t10);
  };
};
var U0 = function e8(t10, n) {
  for (var o = t10._first, r; o; ) o instanceof Pt ? e8(o, n) : o.vars.yoyoEase && (!o._yoyo || !o._repeat) && o._yoyo !== n && (o.timeline ? e8(o.timeline, n) : (r = o._ease, o._ease = o._yEase, o._yEase = r, o._yoyo = n)), o = o._next;
};
var To = function(e16, t10) {
  return e16 && (yt(e16) ? e16 : Oe[e16] || sh(e16)) || t10;
};
var Eo = function(e16, t10, n, o) {
  n === void 0 && (n = function(i) {
    return 1 - t10(1 - i);
  }), o === void 0 && (o = function(i) {
    return i < 0.5 ? t10(i * 2) / 2 : 1 - t10((1 - i) * 2) / 2;
  });
  var r = { easeIn: t10, easeOut: n, easeInOut: o }, a;
  return Ot(e16, function(i) {
    Oe[i] = en[i] = r, Oe[a = i.toLowerCase()] = n;
    for (var s in r) Oe[a + (s === "easeIn" ? ".in" : s === "easeOut" ? ".out" : ".inOut")] = Oe[i + "." + s] = r[s];
  }), r;
};
var G0 = function(e16) {
  return function(t10) {
    return t10 < 0.5 ? (1 - e16(1 - t10 * 2)) / 2 : 0.5 + e16((t10 - 0.5) * 2) / 2;
  };
};
var Oi = function e9(t10, n, o) {
  var r = n >= 1 ? n : 1, a = (o || (t10 ? 0.3 : 0.45)) / (n < 1 ? n : 1), i = a / Ns * (Math.asin(1 / r) || 0), s = function(c) {
    return c === 1 ? 1 : r * Math.pow(2, -10 * c) * zp((c - i) * a) + 1;
  }, l = t10 === "out" ? s : t10 === "in" ? function(c) {
    return 1 - s(1 - c);
  } : G0(s);
  return a = Ns / a, l.config = function(c, u) {
    return e9(t10, c, u);
  }, l;
};
var Bi = function e10(t10, n) {
  n === void 0 && (n = 1.70158);
  var o = function(a) {
    return a ? --a * a * ((n + 1) * a + n) + 1 : 0;
  }, r = t10 === "out" ? o : t10 === "in" ? function(a) {
    return 1 - o(1 - a);
  } : G0(o);
  return r.config = function(a) {
    return e10(t10, a);
  }, r;
};
Ot("Linear,Quad,Cubic,Quart,Quint,Strong", function(e16, t10) {
  var n = t10 < 5 ? t10 + 1 : t10;
  Eo(e16 + ",Power" + (n - 1), t10 ? function(o) {
    return Math.pow(o, n);
  } : function(o) {
    return o;
  }, function(o) {
    return 1 - Math.pow(1 - o, n);
  }, function(o) {
    return o < 0.5 ? Math.pow(o * 2, n) / 2 : 1 - Math.pow((1 - o) * 2, n) / 2;
  });
});
Oe.Linear.easeNone = Oe.none = Oe.Linear.easeIn;
Eo("Elastic", Oi("in"), Oi("out"), Oi());
(function(e16, t10) {
  var n = 1 / t10, o = 2 * n, r = 2.5 * n, a = function(i) {
    return i < n ? e16 * i * i : i < o ? e16 * Math.pow(i - 1.5 / t10, 2) + 0.75 : i < r ? e16 * (i -= 2.25 / t10) * i + 0.9375 : e16 * Math.pow(i - 2.625 / t10, 2) + 0.984375;
  };
  Eo("Bounce", function(i) {
    return 1 - a(1 - i);
  }, a);
})(7.5625, 2.75);
Eo("Expo", function(e16) {
  return e16 ? Math.pow(2, 10 * (e16 - 1)) : 0;
});
Eo("Circ", function(e16) {
  return -(y0(1 - e16 * e16) - 1);
});
Eo("Sine", function(e16) {
  return e16 === 1 ? 1 : -Kp(e16 * Ap) + 1;
});
Eo("Back", Bi("in"), Bi("out"), Bi());
Oe.SteppedEase = Oe.steps = en.SteppedEase = { config: function(e16, t10) {
  e16 === void 0 && (e16 = 1);
  var n = 1 / e16, o = e16 + (t10 ? 0 : 1), r = t10 ? 1 : 0, a = 1 - at;
  return function(i) {
    return ((o * er(0, a, i) | 0) + r) * n;
  };
} };
ra.ease = Oe["quad.out"];
Ot("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(e16) {
  return Nl += e16 + "," + e16 + "Params,";
});
var X0 = function(e16, t10) {
  this.id = Ep++, e16._gsap = this, this.target = e16, this.harness = t10, this.get = t10 ? t10.get : M0, this.set = t10 ? t10.getSetter : Dl;
};
var Za = function() {
  function e16(n) {
    this.vars = n, this._delay = +n.delay || 0, (this._repeat = n.repeat === 1 / 0 ? -2 : n.repeat || 0) && (this._rDelay = n.repeatDelay || 0, this._yoyo = !!n.yoyo || !!n.yoyoEase), this._ts = 1, sa(this, +n.duration, 1, 1), this.data = n.data, dt && (this._ctx = dt, dt.data.push(this)), Ba || Ut.wake();
  }
  var t10 = e16.prototype;
  return t10.delay = function(n) {
    return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay;
  }, t10.duration = function(n) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur;
  }, t10.totalDuration = function(n) {
    return arguments.length ? (this._dirty = 0, sa(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, t10.totalTime = function(n, o) {
    if (la(), !arguments.length) return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (ii(this, n), !r._dp || r.parent || A0(r, this); r && r.parent; ) r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, true), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && _n(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== n || !this._dur && !o || this._initted && Math.abs(this._zTime) === at || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), $0(this, n, o)), this;
  }, t10.time = function(n, o) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + kc(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), o) : this._time;
  }, t10.totalProgress = function(n, o) {
    return arguments.length ? this.totalTime(this.totalDuration() * n, o) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  }, t10.progress = function(n, o) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + kc(this), o) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, t10.iteration = function(n, o) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (n - 1) * r, o) : this._repeat ? ia(this._tTime, r) + 1 : 1;
  }, t10.timeScale = function(n, o) {
    if (!arguments.length) return this._rts === -at ? 0 : this._rts;
    if (this._rts === n) return this;
    var r = this.parent && this._ts ? zr(this.parent._time, this) : this._tTime;
    return this._rts = +n || 0, this._ts = this._ps || n === -at ? 0 : this._rts, this.totalTime(er(-Math.abs(this._delay), this._tDur, r), o !== false), ri(this), Bp(this);
  }, t10.paused = function(n) {
    return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (la(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== at && (this._tTime -= at)))), this) : this._ps;
  }, t10.startTime = function(n) {
    if (arguments.length) {
      this._start = n;
      var o = this.parent || this._dp;
      return o && (o._sort || !this.parent) && _n(o, this, n - this._delay), this;
    }
    return this._start;
  }, t10.endTime = function(n) {
    return this._start + (jt(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, t10.rawTime = function(n) {
    var o = this.parent || this._dp;
    return o ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? zr(o.rawTime(n), this) : this._tTime : this._tTime;
  }, t10.revert = function(n) {
    n === void 0 && (n = Lp);
    var o = Kt;
    return Kt = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)), this.data !== "nested" && n.kill !== false && this.kill(), Kt = o, this;
  }, t10.globalTime = function(n) {
    for (var o = this, r = arguments.length ? n : o.rawTime(); o; ) r = o._start + r / (Math.abs(o._ts) || 1), o = o._dp;
    return !this.parent && this._sat ? this._sat.globalTime(n) : r;
  }, t10.repeat = function(n) {
    return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, Sc(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, t10.repeatDelay = function(n) {
    if (arguments.length) {
      var o = this._time;
      return this._rDelay = n, Sc(this), o ? this.time(o) : this;
    }
    return this._rDelay;
  }, t10.yoyo = function(n) {
    return arguments.length ? (this._yoyo = n, this) : this._yoyo;
  }, t10.seek = function(n, o) {
    return this.totalTime(on2(this, n), jt(o));
  }, t10.restart = function(n, o) {
    return this.play().totalTime(n ? -this._delay : 0, jt(o));
  }, t10.play = function(n, o) {
    return n != null && this.seek(n, o), this.reversed(false).paused(false);
  }, t10.reverse = function(n, o) {
    return n != null && this.seek(n || this.totalDuration(), o), this.reversed(true).paused(false);
  }, t10.pause = function(n, o) {
    return n != null && this.seek(n, o), this.paused(true);
  }, t10.resume = function() {
    return this.paused(false);
  }, t10.reversed = function(n) {
    return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -at : 0)), this) : this._rts < 0;
  }, t10.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -at, this;
  }, t10.isActive = function() {
    var n = this.parent || this._dp, o = this._start, r;
    return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(true)) >= o && r < this.endTime(true) - at);
  }, t10.eventCallback = function(n, o, r) {
    var a = this.vars;
    return arguments.length > 1 ? (o ? (a[n] = o, r && (a[n + "Params"] = r), n === "onUpdate" && (this._onUpdate = o)) : delete a[n], this) : a[n];
  }, t10.then = function(n) {
    var o = this;
    return new Promise(function(r) {
      var a = yt(n) ? n : I0, i = function() {
        var s = o.then;
        o.then = null, yt(a) && (a = a(o)) && (a.then || a === o) && (o.then = s), r(a), o.then = s;
      };
      o._initted && o.totalProgress() === 1 && o._ts >= 0 || !o._tTime && o._ts < 0 ? i() : o._prom = i;
    });
  }, t10.kill = function() {
    Da(this);
  }, e16;
}();
sn(Za.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: false, parent: null, _initted: false, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -at, _prom: 0, _ps: false, _rts: 1 });
var Pt = function(e16) {
  v0(t10, e16);
  function t10(o, r) {
    var a;
    return o === void 0 && (o = {}), a = e16.call(this, o) || this, a.labels = {}, a.smoothChildTiming = !!o.smoothChildTiming, a.autoRemoveChildren = !!o.autoRemoveChildren, a._sort = jt(o.sortChildren), mt && _n(o.parent || mt, Dn(a), r), o.reversed && a.reverse(), o.paused && a.paused(true), o.scrollTrigger && E0(Dn(a), o.scrollTrigger), a;
  }
  var n = t10.prototype;
  return n.to = function(o, r, a) {
    return Ka(0, arguments, this), this;
  }, n.from = function(o, r, a) {
    return Ka(1, arguments, this), this;
  }, n.fromTo = function(o, r, a, i) {
    return Ka(2, arguments, this), this;
  }, n.set = function(o, r, a) {
    return r.duration = 0, r.parent = this, Ea(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new Tt(o, r, on2(this, a), 1), this;
  }, n.call = function(o, r, a) {
    return _n(this, Tt.delayedCall(0, o, r), a);
  }, n.staggerTo = function(o, r, a, i, s, l, c) {
    return a.duration = r, a.stagger = a.stagger || i, a.onComplete = l, a.onCompleteParams = c, a.parent = this, new Tt(o, a, on2(this, s)), this;
  }, n.staggerFrom = function(o, r, a, i, s, l, c) {
    return a.runBackwards = 1, Ea(a).immediateRender = jt(a.immediateRender), this.staggerTo(o, r, a, i, s, l, c);
  }, n.staggerFromTo = function(o, r, a, i, s, l, c, u) {
    return i.startAt = a, Ea(i).immediateRender = jt(i.immediateRender), this.staggerTo(o, r, i, s, l, c, u);
  }, n.render = function(o, r, a) {
    var i = this._time, s = this._dirty ? this.totalDuration() : this._tDur, l = this._dur, c = o <= 0 ? 0 : $t(o), u = this._zTime < 0 != o < 0 && (this._initted || !l), d, m, p, f, h10, g, v, y, k, T, w, _;
    if (this !== mt && c > s && o >= 0 && (c = s), c !== this._tTime || a || u) {
      if (i !== this._time && l && (c += this._time - i, o += this._time - i), d = c, k = this._start, y = this._ts, g = !y, u && (l || (i = this._zTime), (o || !r) && (this._zTime = o)), this._repeat) {
        if (w = this._yoyo, h10 = l + this._rDelay, this._repeat < -1 && o < 0) return this.totalTime(h10 * 100 + o, r, a);
        if (d = $t(c % h10), c === s ? (f = this._repeat, d = l) : (f = ~~(c / h10), f && f === c / h10 && (d = l, f--), d > l && (d = l)), T = ia(this._tTime, h10), !i && this._tTime && T !== f && this._tTime - T * h10 - this._dur <= 0 && (T = f), w && f & 1 && (d = l - d, _ = 1), f !== T && !this._lock) {
          var M = w && T & 1, x = M === (w && f & 1);
          if (f < T && (M = !M), i = M ? 0 : c % l ? l : c, this._lock = 1, this.render(i || (_ ? 0 : $t(f * h10)), r, !l)._lock = 0, this._tTime = c, !r && this.parent && Yt(this, "onRepeat"), this.vars.repeatRefresh && !_ && (this.invalidate()._lock = 1), i && i !== this._time || g !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
          if (l = this._dur, s = this._tDur, x && (this._lock = 2, i = M ? l : -1e-4, this.render(i, true), this.vars.repeatRefresh && !_ && this.invalidate()), this._lock = 0, !this._ts && !g) return this;
          U0(this, _);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (v = Vp(this, $t(i), $t(d)), v && (c -= d - (d = v._start))), this._tTime = c, this._time = d, this._act = !y, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = o, i = 0), !i && d && !r && !f && (Yt(this, "onStart"), this._tTime !== c)) return this;
      if (d >= i && o >= 0) for (m = this._first; m; ) {
        if (p = m._next, (m._act || d >= m._start) && m._ts && v !== m) {
          if (m.parent !== this) return this.render(o, r, a);
          if (m.render(m._ts > 0 ? (d - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (d - m._start) * m._ts, r, a), d !== this._time || !this._ts && !g) {
            v = 0, p && (c += this._zTime = -at);
            break;
          }
        }
        m = p;
      }
      else {
        m = this._last;
        for (var R = o < 0 ? o : d; m; ) {
          if (p = m._prev, (m._act || R <= m._end) && m._ts && v !== m) {
            if (m.parent !== this) return this.render(o, r, a);
            if (m.render(m._ts > 0 ? (R - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (R - m._start) * m._ts, r, a || Kt && (m._initted || m._startAt)), d !== this._time || !this._ts && !g) {
              v = 0, p && (c += this._zTime = R ? -at : at);
              break;
            }
          }
          m = p;
        }
      }
      if (v && !r && (this.pause(), v.render(d >= i ? 0 : -at)._zTime = d >= i ? 1 : -1, this._ts)) return this._start = k, ri(this), this.render(o, r, a);
      this._onUpdate && !r && Yt(this, "onUpdate", true), (c === s && this._tTime >= this.totalDuration() || !c && i) && (k === this._start || Math.abs(y) !== Math.abs(this._ts)) && (this._lock || ((o || !l) && (c === s && this._ts > 0 || !c && this._ts < 0) && Jn(this, 1), !r && !(o < 0 && !i) && (c || i || !s) && (Yt(this, c === s && o >= 0 ? "onComplete" : "onReverseComplete", true), this._prom && !(c < s && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, n.add = function(o, r) {
    var a = this;
    if (Pn(r) || (r = on2(this, r, o)), !(o instanceof Za)) {
      if (zt(o)) return o.forEach(function(i) {
        return a.add(i, r);
      }), this;
      if (It(o)) return this.addLabel(o, r);
      if (yt(o)) o = Tt.delayedCall(0, o);
      else return this;
    }
    return this !== o ? _n(this, o, r) : this;
  }, n.getChildren = function(o, r, a, i) {
    o === void 0 && (o = true), r === void 0 && (r = true), a === void 0 && (a = true), i === void 0 && (i = -an);
    for (var s = [], l = this._first; l; ) l._start >= i && (l instanceof Tt ? r && s.push(l) : (a && s.push(l), o && s.push.apply(s, l.getChildren(true, r, a)))), l = l._next;
    return s;
  }, n.getById = function(o) {
    for (var r = this.getChildren(1, 1, 1), a = r.length; a--; ) if (r[a].vars.id === o) return r[a];
  }, n.remove = function(o) {
    return It(o) ? this.removeLabel(o) : yt(o) ? this.killTweensOf(o) : (ai(this, o), o === this._recent && (this._recent = this._last), wo(this));
  }, n.totalTime = function(o, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = $t(Ut.time - (this._ts > 0 ? o / this._ts : (this.totalDuration() - o) / -this._ts))), e16.prototype.totalTime.call(this, o, r), this._forcing = 0, this) : this._tTime;
  }, n.addLabel = function(o, r) {
    return this.labels[o] = on2(this, r), this;
  }, n.removeLabel = function(o) {
    return delete this.labels[o], this;
  }, n.addPause = function(o, r, a) {
    var i = Tt.delayedCall(0, r || ja, a);
    return i.data = "isPause", this._hasPause = 1, _n(this, i, on2(this, o));
  }, n.removePause = function(o) {
    var r = this._first;
    for (o = on2(this, o); r; ) r._start === o && r.data === "isPause" && Jn(r), r = r._next;
  }, n.killTweensOf = function(o, r, a) {
    for (var i = this.getTweensOf(o, a), s = i.length; s--; ) Vn !== i[s] && i[s].kill(o, r);
    return this;
  }, n.getTweensOf = function(o, r) {
    for (var a = [], i = rn(o), s = this._first, l = Pn(r), c; s; ) s instanceof Tt ? Fp(s._targets, i) && (l ? (!Vn || s._initted && s._ts) && s.globalTime(0) <= r && s.globalTime(s.totalDuration()) > r : !r || s.isActive()) && a.push(s) : (c = s.getTweensOf(i, r)).length && a.push.apply(a, c), s = s._next;
    return a;
  }, n.tweenTo = function(o, r) {
    r = r || {};
    var a = this, i = on2(a, o), s = r, l = s.startAt, c = s.onStart, u = s.onStartParams, d = s.immediateRender, m, p = Tt.to(a, sn({ ease: r.ease || "none", lazy: false, immediateRender: false, time: i, overwrite: "auto", duration: r.duration || Math.abs((i - (l && "time" in l ? l.time : a._time)) / a.timeScale()) || at, onStart: function() {
      if (a.pause(), !m) {
        var f = r.duration || Math.abs((i - (l && "time" in l ? l.time : a._time)) / a.timeScale());
        p._dur !== f && sa(p, f, 0, 1).render(p._time, true, true), m = 1;
      }
      c && c.apply(p, u || []);
    } }, r));
    return d ? p.render(0) : p;
  }, n.tweenFromTo = function(o, r, a) {
    return this.tweenTo(r, sn({ startAt: { time: on2(this, o) } }, a));
  }, n.recent = function() {
    return this._recent;
  }, n.nextLabel = function(o) {
    return o === void 0 && (o = this._time), Nc(this, on2(this, o));
  }, n.previousLabel = function(o) {
    return o === void 0 && (o = this._time), Nc(this, on2(this, o), 1);
  }, n.currentLabel = function(o) {
    return arguments.length ? this.seek(o, true) : this.previousLabel(this._time + at);
  }, n.shiftChildren = function(o, r, a) {
    a === void 0 && (a = 0);
    for (var i = this._first, s = this.labels, l; i; ) i._start >= a && (i._start += o, i._end += o), i = i._next;
    if (r) for (l in s) s[l] >= a && (s[l] += o);
    return wo(this);
  }, n.invalidate = function(o) {
    var r = this._first;
    for (this._lock = 0; r; ) r.invalidate(o), r = r._next;
    return e16.prototype.invalidate.call(this, o);
  }, n.clear = function(o) {
    o === void 0 && (o = true);
    for (var r = this._first, a; r; ) a = r._next, this.remove(r), r = a;
    return this._dp && (this._time = this._tTime = this._pTime = 0), o && (this.labels = {}), wo(this);
  }, n.totalDuration = function(o) {
    var r = 0, a = this, i = a._last, s = an, l, c, u;
    if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -o : o));
    if (a._dirty) {
      for (u = a.parent; i; ) l = i._prev, i._dirty && i.totalDuration(), c = i._start, c > s && a._sort && i._ts && !a._lock ? (a._lock = 1, _n(a, i, c - i._delay, 1)._lock = 0) : s = c, c < 0 && i._ts && (r -= c, (!u && !a._dp || u && u.smoothChildTiming) && (a._start += c / a._ts, a._time -= c, a._tTime -= c), a.shiftChildren(-c, false, -1 / 0), s = 0), i._end > r && i._ts && (r = i._end), i = l;
      sa(a, a === mt && a._time > r ? a._time : r, 1, 1), a._dirty = 0;
    }
    return a._tDur;
  }, t10.updateRoot = function(o) {
    if (mt._ts && ($0(mt, zr(o, mt)), N0 = Ut.frame), Ut.frame >= Tc) {
      Tc += Qt.autoSleep || 120;
      var r = mt._first;
      if ((!r || !r._ts) && Qt.autoSleep && Ut._listeners.length < 2) {
        for (; r && !r._ts; ) r = r._next;
        r || Ut.sleep();
      }
    }
  }, t10;
}(Za);
sn(Pt.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var lh = function(e16, t10, n, o, r, a, i) {
  var s = new Bt(this._pt, e16, t10, 0, 1, nd, null, r), l = 0, c = 0, u, d, m, p, f, h10, g, v;
  for (s.b = n, s.e = o, n += "", o += "", (g = ~o.indexOf("random(")) && (o = Oa(o)), a && (v = [n, o], a(v, e16, t10), n = v[0], o = v[1]), d = n.match(Li) || []; u = Li.exec(o); ) p = u[0], f = o.substring(l, u.index), m ? m = (m + 1) % 5 : f.substr(-5) === "rgba(" && (m = 1), p !== d[c++] && (h10 = parseFloat(d[c - 1]) || 0, s._pt = { _next: s._pt, p: f || c === 1 ? f : ",", s: h10, c: p.charAt(1) === "=" ? Qo(h10, p) - h10 : parseFloat(p) - h10, m: m && m < 4 ? Math.round : 0 }, l = Li.lastIndex);
  return s.c = l < o.length ? o.substring(l, o.length) : "", s.fp = i, (w0.test(o) || g) && (s.e = 0), this._pt = s, s;
};
var $l = function(e16, t10, n, o, r, a, i, s, l, c) {
  yt(o) && (o = o(r || 0, e16, a));
  var u = e16[t10], d = n !== "get" ? n : yt(u) ? l ? e16[t10.indexOf("set") || !yt(e16["get" + t10.substr(3)]) ? t10 : "get" + t10.substr(3)](l) : e16[t10]() : u, m = yt(u) ? l ? mh : ed : Il, p;
  if (It(o) && (~o.indexOf("random(") && (o = Oa(o)), o.charAt(1) === "=" && (p = Qo(d, o) + (Et(d) || 0), (p || p === 0) && (o = p))), !c || d !== o || zs) return !isNaN(d * o) && o !== "" ? (p = new Bt(this._pt, e16, t10, +d || 0, o - (d || 0), typeof u == "boolean" ? hh : td, 0, m), l && (p.fp = l), i && p.modifier(i, this, e16), this._pt = p) : (!u && !(t10 in e16) && kl(t10, o), lh.call(this, e16, t10, d, o, m, s || Qt.stringFilter, l));
};
var ch = function(e16, t10, n, o, r) {
  if (yt(e16) && (e16 = za(e16, r, t10, n, o)), !$n(e16) || e16.style && e16.nodeType || zt(e16) || b0(e16)) return It(e16) ? za(e16, r, t10, n, o) : e16;
  var a = {}, i;
  for (i in e16) a[i] = za(e16[i], r, t10, n, o);
  return a;
};
var Y0 = function(e16, t10, n, o, r, a) {
  var i, s, l, c;
  if (Ht[e16] && (i = new Ht[e16]()).init(r, i.rawVars ? t10[e16] : ch(t10[e16], o, r, a, n), n, o, a) !== false && (n._pt = s = new Bt(n._pt, r, e16, 0, 1, i.render, i, 0, i.priority), n !== Uo)) for (l = n._ptLookup[n._targets.indexOf(r)], c = i._props.length; c--; ) l[i._props[c]] = s;
  return i;
};
var Vn;
var zs;
var xl = function e11(t10, n, o) {
  var r = t10.vars, a = r.ease, i = r.startAt, s = r.immediateRender, l = r.lazy, c = r.onUpdate, u = r.runBackwards, d = r.yoyoEase, m = r.keyframes, p = r.autoRevert, f = t10._dur, h10 = t10._startAt, g = t10._targets, v = t10.parent, y = v && v.data === "nested" ? v.vars.targets : g, k = t10._overwrite === "auto" && !_l, T = t10.timeline, w, _, M, x, R, I, P, F, N, j, z, A, B;
  if (T && (!m || !a) && (a = "none"), t10._ease = To(a, ra.ease), t10._yEase = d ? H0(To(d === true ? a : d, ra.ease)) : 0, d && t10._yoyo && !t10._repeat && (d = t10._yEase, t10._yEase = t10._ease, t10._ease = d), t10._from = !T && !!r.runBackwards, !T || m && !r.stagger) {
    if (F = g[0] ? _o(g[0]).harness : 0, A = F && r[F.prop], w = Kr(r, Sl), h10 && (h10._zTime < 0 && h10.progress(1), n < 0 && u && s && !p ? h10.render(-1, true) : h10.revert(u && f ? wr : Rp), h10._lazy = 0), i) {
      if (Jn(t10._startAt = Tt.set(g, sn({ data: "isStart", overwrite: false, parent: v, immediateRender: true, lazy: !h10 && jt(l), startAt: null, delay: 0, onUpdate: c && function() {
        return Yt(t10, "onUpdate");
      }, stagger: 0 }, i))), t10._startAt._dp = 0, t10._startAt._sat = t10, n < 0 && (Kt || !s && !p) && t10._startAt.revert(wr), s && f && n <= 0 && o <= 0) {
        n && (t10._zTime = n);
        return;
      }
    } else if (u && f && !h10) {
      if (n && (s = false), M = sn({ overwrite: false, data: "isFromStart", lazy: s && !h10 && jt(l), immediateRender: s, stagger: 0, parent: v }, w), A && (M[F.prop] = A), Jn(t10._startAt = Tt.set(g, M)), t10._startAt._dp = 0, t10._startAt._sat = t10, n < 0 && (Kt ? t10._startAt.revert(wr) : t10._startAt.render(-1, true)), t10._zTime = n, !s) e11(t10._startAt, at, at);
      else if (!n) return;
    }
    for (t10._pt = t10._ptCache = 0, l = f && jt(l) || l && !f, _ = 0; _ < g.length; _++) {
      if (R = g[_], P = R._gsap || Ml(g)[_]._gsap, t10._ptLookup[_] = j = {}, xs[P.id] && Gn.length && Er(), z = y === g ? _ : y.indexOf(R), F && (N = new F()).init(R, A || w, t10, z, y) !== false && (t10._pt = x = new Bt(t10._pt, R, N.name, 0, 1, N.render, N, 0, N.priority), N._props.forEach(function(D) {
        j[D] = x;
      }), N.priority && (I = 1)), !F || A) for (M in w) Ht[M] && (N = Y0(M, w, t10, z, R, y)) ? N.priority && (I = 1) : j[M] = x = $l.call(t10, R, M, "get", w[M], z, y, 0, r.stringFilter);
      t10._op && t10._op[_] && t10.kill(R, t10._op[_]), k && t10._pt && (Vn = t10, mt.killTweensOf(R, j, t10.globalTime(n)), B = !t10.parent, Vn = 0), t10._pt && l && (xs[P.id] = 1);
    }
    I && od(t10), t10._onInit && t10._onInit(t10);
  }
  t10._onUpdate = c, t10._initted = (!t10._op || t10._pt) && !B, m && n <= 0 && T.render(an, true, true);
};
var uh = function(e16, t10, n, o, r, a, i, s) {
  var l = (e16._pt && e16._ptCache || (e16._ptCache = {}))[t10], c, u, d, m;
  if (!l) for (l = e16._ptCache[t10] = [], d = e16._ptLookup, m = e16._targets.length; m--; ) {
    if (c = d[m][t10], c && c.d && c.d._pt) for (c = c.d._pt; c && c.p !== t10 && c.fp !== t10; ) c = c._next;
    if (!c) return zs = 1, e16.vars[t10] = "+=0", xl(e16, i), zs = 0, s ? Fa(t10 + " not eligible for reset") : 1;
    l.push(c);
  }
  for (m = l.length; m--; ) u = l[m], c = u._pt || u, c.s = (o || o === 0) && !r ? o : c.s + (o || 0) + a * c.c, c.c = n - c.s, u.e && (u.e = _t2(n) + Et(u.e)), u.b && (u.b = c.s + Et(u.b));
};
var dh = function(e16, t10) {
  var n = e16[0] ? _o(e16[0]).harness : 0, o = n && n.aliases, r, a, i, s;
  if (!o) return t10;
  r = Mo({}, t10);
  for (a in o) if (a in r) for (s = o[a].split(","), i = s.length; i--; ) r[s[i]] = r[a];
  return r;
};
var fh = function(e16, t10, n, o) {
  var r = t10.ease || o || "power1.inOut", a, i;
  if (zt(t10)) i = n[e16] || (n[e16] = []), t10.forEach(function(s, l) {
    return i.push({ t: l / (t10.length - 1) * 100, v: s, e: r });
  });
  else for (a in t10) i = n[a] || (n[a] = []), a === "ease" || i.push({ t: parseFloat(e16), v: t10[a], e: r });
};
var za = function(e16, t10, n, o, r) {
  return yt(e16) ? e16.call(t10, n, o, r) : It(e16) && ~e16.indexOf("random(") ? Oa(e16) : e16;
};
var Q0 = Nl + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
var J0 = {};
Ot(Q0 + ",id,stagger,delay,duration,paused,scrollTrigger", function(e16) {
  return J0[e16] = 1;
});
var Tt = function(e16) {
  v0(t10, e16);
  function t10(o, r, a, i) {
    var s;
    typeof r == "number" && (a.duration = r, r = a, a = null), s = e16.call(this, i ? r : Ea(r)) || this;
    var l = s.vars, c = l.duration, u = l.delay, d = l.immediateRender, m = l.stagger, p = l.overwrite, f = l.keyframes, h10 = l.defaults, g = l.scrollTrigger, v = l.yoyoEase, y = r.parent || mt, k = (zt(o) || b0(o) ? Pn(o[0]) : "length" in r) ? [o] : rn(o), T, w, _, M, x, R, I, P;
    if (s._targets = k.length ? Ml(k) : Fa("GSAP target " + o + " not found. https://gsap.com", !Qt.nullTargetWarn) || [], s._ptLookup = [], s._overwrite = p, f || m || pr(c) || pr(u)) {
      if (r = s.vars, T = s.timeline = new Pt({ data: "nested", defaults: h10 || {}, targets: y && y.data === "nested" ? y.vars.targets : k }), T.kill(), T.parent = T._dp = Dn(s), T._start = 0, m || pr(c) || pr(u)) {
        if (M = k.length, I = m && R0(m), $n(m)) for (x in m) ~Q0.indexOf(x) && (P || (P = {}), P[x] = m[x]);
        for (w = 0; w < M; w++) _ = Kr(r, J0), _.stagger = 0, v && (_.yoyoEase = v), P && Mo(_, P), R = k[w], _.duration = +za(c, Dn(s), w, R, k), _.delay = (+za(u, Dn(s), w, R, k) || 0) - s._delay, !m && M === 1 && _.delay && (s._delay = u = _.delay, s._start += u, _.delay = 0), T.to(R, _, I ? I(w, R, k) : 0), T._ease = Oe.none;
        T.duration() ? c = u = 0 : s.timeline = 0;
      } else if (f) {
        Ea(sn(T.vars.defaults, { ease: "none" })), T._ease = To(f.ease || r.ease || "none");
        var F = 0, N, j, z;
        if (zt(f)) f.forEach(function(A) {
          return T.to(k, A, ">");
        }), T.duration();
        else {
          _ = {};
          for (x in f) x === "ease" || x === "easeEach" || fh(x, f[x], _, f.easeEach);
          for (x in _) for (N = _[x].sort(function(A, B) {
            return A.t - B.t;
          }), F = 0, w = 0; w < N.length; w++) j = N[w], z = { ease: j.e, duration: (j.t - (w ? N[w - 1].t : 0)) / 100 * c }, z[x] = j.v, T.to(k, z, F), F += z.duration;
          T.duration() < c && T.to({}, { duration: c - T.duration() });
        }
      }
      c || s.duration(c = T.duration());
    } else s.timeline = 0;
    return p === true && !_l && (Vn = Dn(s), mt.killTweensOf(k), Vn = 0), _n(y, Dn(s), a), r.reversed && s.reverse(), r.paused && s.paused(true), (d || !c && !f && s._start === $t(y._time) && jt(d) && Zp(Dn(s)) && y.data !== "nested") && (s._tTime = -at, s.render(Math.max(0, -u) || 0)), g && E0(Dn(s), g), s;
  }
  var n = t10.prototype;
  return n.render = function(o, r, a) {
    var i = this._time, s = this._tDur, l = this._dur, c = o < 0, u = o > s - at && !c ? s : o < at ? 0 : o, d, m, p, f, h10, g, v, y, k;
    if (!l) qp(this, o, r, a);
    else if (u !== this._tTime || !o || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== c) {
      if (d = u, y = this.timeline, this._repeat) {
        if (f = l + this._rDelay, this._repeat < -1 && c) return this.totalTime(f * 100 + o, r, a);
        if (d = $t(u % f), u === s ? (p = this._repeat, d = l) : (p = ~~(u / f), p && p === $t(u / f) && (d = l, p--), d > l && (d = l)), g = this._yoyo && p & 1, g && (k = this._yEase, d = l - d), h10 = ia(this._tTime, f), d === i && !a && this._initted && p === h10) return this._tTime = u, this;
        p !== h10 && (y && this._yEase && U0(y, g), this.vars.repeatRefresh && !g && !this._lock && this._time !== f && this._initted && (this._lock = a = 1, this.render($t(f * p), true).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (K0(this, c ? o : d, a, r, u)) return this._tTime = 0, this;
        if (i !== this._time && !(a && this.vars.repeatRefresh && p !== h10)) return this;
        if (l !== this._dur) return this.render(o, r, a);
      }
      if (this._tTime = u, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = v = (k || this._ease)(d / l), this._from && (this.ratio = v = 1 - v), d && !i && !r && !p && (Yt(this, "onStart"), this._tTime !== u)) return this;
      for (m = this._pt; m; ) m.r(v, m.d), m = m._next;
      y && y.render(o < 0 ? o : y._dur * y._ease(d / this._dur), r, a) || this._startAt && (this._zTime = o), this._onUpdate && !r && (c && Is(this, o, r, a), Yt(this, "onUpdate")), this._repeat && p !== h10 && this.vars.onRepeat && !r && this.parent && Yt(this, "onRepeat"), (u === this._tDur || !u) && this._tTime === u && (c && !this._onUpdate && Is(this, o, true, true), (o || !l) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && Jn(this, 1), !r && !(c && !i) && (u || i || g) && (Yt(this, u === s ? "onComplete" : "onReverseComplete", true), this._prom && !(u < s && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, n.targets = function() {
    return this._targets;
  }, n.invalidate = function(o) {
    return (!o || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(o), e16.prototype.invalidate.call(this, o);
  }, n.resetTo = function(o, r, a, i, s) {
    Ba || Ut.wake(), this._ts || this.play();
    var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), c;
    return this._initted || xl(this, l), c = this._ease(l / this._dur), uh(this, o, r, a, i, c, l, s) ? this.resetTo(o, r, a, i, 1) : (ii(this, 0), this.parent || D0(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, n.kill = function(o, r) {
    if (r === void 0 && (r = "all"), !o && (!r || r === "all")) return this._lazy = this._pt = 0, this.parent ? Da(this) : this;
    if (this.timeline) {
      var a = this.timeline.totalDuration();
      return this.timeline.killTweensOf(o, r, Vn && Vn.vars.overwrite !== true)._first || Da(this), this.parent && a !== this.timeline.totalDuration() && sa(this, this._dur * this.timeline._tDur / a, 0, 1), this;
    }
    var i = this._targets, s = o ? rn(o) : i, l = this._ptLookup, c = this._pt, u, d, m, p, f, h10, g;
    if ((!r || r === "all") && Op(i, s)) return r === "all" && (this._pt = 0), Da(this);
    for (u = this._op = this._op || [], r !== "all" && (It(r) && (f = {}, Ot(r, function(v) {
      return f[v] = 1;
    }), r = f), r = dh(i, r)), g = i.length; g--; ) if (~s.indexOf(i[g])) {
      d = l[g], r === "all" ? (u[g] = r, p = d, m = {}) : (m = u[g] = u[g] || {}, p = r);
      for (f in p) h10 = d && d[f], h10 && ((!("kill" in h10.d) || h10.d.kill(f) === true) && ai(this, h10, "_pt"), delete d[f]), m !== "all" && (m[f] = 1);
    }
    return this._initted && !this._pt && c && Da(this), this;
  }, t10.to = function(o, r) {
    return new t10(o, r, arguments[2]);
  }, t10.from = function(o, r) {
    return Ka(1, arguments);
  }, t10.delayedCall = function(o, r, a, i) {
    return new t10(r, 0, { immediateRender: false, lazy: false, overwrite: false, delay: o, onComplete: r, onReverseComplete: r, onCompleteParams: a, onReverseCompleteParams: a, callbackScope: i });
  }, t10.fromTo = function(o, r, a) {
    return Ka(2, arguments);
  }, t10.set = function(o, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new t10(o, r);
  }, t10.killTweensOf = function(o, r, a) {
    return mt.killTweensOf(o, r, a);
  }, t10;
}(Za);
sn(Tt.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
Ot("staggerTo,staggerFrom,staggerFromTo", function(e16) {
  Tt[e16] = function() {
    var t10 = new Pt(), n = As.call(arguments, 0);
    return n.splice(e16 === "staggerFromTo" ? 5 : 4, 0, 0), t10[e16].apply(t10, n);
  };
});
var Il = function(e16, t10, n) {
  return e16[t10] = n;
};
var ed = function(e16, t10, n) {
  return e16[t10](n);
};
var mh = function(e16, t10, n, o) {
  return e16[t10](o.fp, n);
};
var ph = function(e16, t10, n) {
  return e16.setAttribute(t10, n);
};
var Dl = function(e16, t10) {
  return yt(e16[t10]) ? ed : wl(e16[t10]) && e16.setAttribute ? ph : Il;
};
var td = function(e16, t10) {
  return t10.set(t10.t, t10.p, Math.round((t10.s + t10.c * e16) * 1e6) / 1e6, t10);
};
var hh = function(e16, t10) {
  return t10.set(t10.t, t10.p, !!(t10.s + t10.c * e16), t10);
};
var nd = function(e16, t10) {
  var n = t10._pt, o = "";
  if (!e16 && t10.b) o = t10.b;
  else if (e16 === 1 && t10.e) o = t10.e;
  else {
    for (; n; ) o = n.p + (n.m ? n.m(n.s + n.c * e16) : Math.round((n.s + n.c * e16) * 1e4) / 1e4) + o, n = n._next;
    o += t10.c;
  }
  t10.set(t10.t, t10.p, o, t10);
};
var Al = function(e16, t10) {
  for (var n = t10._pt; n; ) n.r(e16, n.d), n = n._next;
};
var gh = function(e16, t10, n, o) {
  for (var r = this._pt, a; r; ) a = r._next, r.p === o && r.modifier(e16, t10, n), r = a;
};
var vh = function(e16) {
  for (var t10 = this._pt, n, o; t10; ) o = t10._next, t10.p === e16 && !t10.op || t10.op === e16 ? ai(this, t10, "_pt") : t10.dep || (n = 1), t10 = o;
  return !n;
};
var yh = function(e16, t10, n, o) {
  o.mSet(e16, t10, o.m.call(o.tween, n, o.mt), o);
};
var od = function(e16) {
  for (var t10 = e16._pt, n, o, r, a; t10; ) {
    for (n = t10._next, o = r; o && o.pr > t10.pr; ) o = o._next;
    (t10._prev = o ? o._prev : a) ? t10._prev._next = t10 : r = t10, (t10._next = o) ? o._prev = t10 : a = t10, t10 = n;
  }
  e16._pt = r;
};
var Bt = function() {
  function e16(n, o, r, a, i, s, l, c, u) {
    this.t = o, this.s = a, this.c = i, this.p = r, this.r = s || td, this.d = l || this, this.set = c || Il, this.pr = u || 0, this._next = n, n && (n._prev = this);
  }
  var t10 = e16.prototype;
  return t10.modifier = function(n, o, r) {
    this.mSet = this.mSet || this.set, this.set = yh, this.m = n, this.mt = r, this.tween = o;
  }, e16;
}();
Ot(Nl + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(e16) {
  return Sl[e16] = 1;
});
en.TweenMax = en.TweenLite = Tt;
en.TimelineLite = en.TimelineMax = Pt;
mt = new Pt({ sortChildren: false, defaults: ra, autoRemoveChildren: true, id: "root", smoothChildTiming: true });
Qt.stringFilter = V0;
var Co = [];
var Cr = {};
var bh = [];
var $c = 0;
var _h = 0;
var Zi = function(e16) {
  return (Cr[e16] || bh).map(function(t10) {
    return t10();
  });
};
var Ps = function() {
  var e16 = Date.now(), t10 = [];
  e16 - $c > 2 && (Zi("matchMediaInit"), Co.forEach(function(n) {
    var o = n.queries, r = n.conditions, a, i, s, l;
    for (i in o) a = yn.matchMedia(o[i]).matches, a && (s = 1), a !== r[i] && (r[i] = a, l = 1);
    l && (n.revert(), s && t10.push(n));
  }), Zi("matchMediaRevert"), t10.forEach(function(n) {
    return n.onMatch(n, function(o) {
      return n.add(null, o);
    });
  }), $c = e16, Zi("matchMedia"));
};
var ad = function() {
  function e16(n, o) {
    this.selector = o && Es(o), this.data = [], this._r = [], this.isReverted = false, this.id = _h++, n && this.add(n);
  }
  var t10 = e16.prototype;
  return t10.add = function(n, o, r) {
    yt(n) && (r = o, o = n, n = yt);
    var a = this, i = function() {
      var s = dt, l = a.selector, c;
      return s && s !== a && s.data.push(a), r && (a.selector = Es(r)), dt = a, c = o.apply(a, arguments), yt(c) && a._r.push(c), dt = s, a.selector = l, a.isReverted = false, c;
    };
    return a.last = i, n === yt ? i(a, function(s) {
      return a.add(null, s);
    }) : n ? a[n] = i : i;
  }, t10.ignore = function(n) {
    var o = dt;
    dt = null, n(this), dt = o;
  }, t10.getTweens = function() {
    var n = [];
    return this.data.forEach(function(o) {
      return o instanceof e16 ? n.push.apply(n, o.getTweens()) : o instanceof Tt && !(o.parent && o.parent.data === "nested") && n.push(o);
    }), n;
  }, t10.clear = function() {
    this._r.length = this.data.length = 0;
  }, t10.kill = function(n, o) {
    var r = this;
    if (n ? function() {
      for (var i = r.getTweens(), s = r.data.length, l; s--; ) l = r.data[s], l.data === "isFlip" && (l.revert(), l.getChildren(true, true, false).forEach(function(c) {
        return i.splice(i.indexOf(c), 1);
      }));
      for (i.map(function(c) {
        return { g: c._dur || c._delay || c._sat && !c._sat.vars.immediateRender ? c.globalTime(0) : -1 / 0, t: c };
      }).sort(function(c, u) {
        return u.g - c.g || -1 / 0;
      }).forEach(function(c) {
        return c.t.revert(n);
      }), s = r.data.length; s--; ) l = r.data[s], l instanceof Pt ? l.data !== "nested" && (l.scrollTrigger && l.scrollTrigger.revert(), l.kill()) : !(l instanceof Tt) && l.revert && l.revert(n);
      r._r.forEach(function(c) {
        return c(n, r);
      }), r.isReverted = true;
    }() : this.data.forEach(function(i) {
      return i.kill && i.kill();
    }), this.clear(), o) for (var a = Co.length; a--; ) Co[a].id === this.id && Co.splice(a, 1);
  }, t10.revert = function(n) {
    this.kill(n || {});
  }, e16;
}();
var wh = function() {
  function e16(n) {
    this.contexts = [], this.scope = n, dt && dt.data.push(this);
  }
  var t10 = e16.prototype;
  return t10.add = function(n, o, r) {
    $n(n) || (n = { matches: n });
    var a = new ad(0, r || this.scope), i = a.conditions = {}, s, l, c;
    dt && !a.selector && (a.selector = dt.selector), this.contexts.push(a), o = a.add("onMatch", o), a.queries = n;
    for (l in n) l === "all" ? c = 1 : (s = yn.matchMedia(n[l]), s && (Co.indexOf(a) < 0 && Co.push(a), (i[l] = s.matches) && (c = 1), s.addListener ? s.addListener(Ps) : s.addEventListener("change", Ps)));
    return c && o(a, function(u) {
      return a.add(null, u);
    }), this;
  }, t10.revert = function(n) {
    this.kill(n || {});
  }, t10.kill = function(n) {
    this.contexts.forEach(function(o) {
      return o.kill(n, true);
    });
  }, e16;
}();
var Pr = { registerPlugin: function() {
  for (var e16 = arguments.length, t10 = new Array(e16), n = 0; n < e16; n++) t10[n] = arguments[n];
  t10.forEach(function(o) {
    return Z0(o);
  });
}, timeline: function(e16) {
  return new Pt(e16);
}, getTweensOf: function(e16, t10) {
  return mt.getTweensOf(e16, t10);
}, getProperty: function(e16, t10, n, o) {
  It(e16) && (e16 = rn(e16)[0]);
  var r = _o(e16 || {}).get, a = n ? I0 : x0;
  return n === "native" && (n = ""), e16 && (t10 ? a((Ht[t10] && Ht[t10].get || r)(e16, t10, n, o)) : function(i, s, l) {
    return a((Ht[i] && Ht[i].get || r)(e16, i, s, l));
  });
}, quickSetter: function(e16, t10, n) {
  if (e16 = rn(e16), e16.length > 1) {
    var o = e16.map(function(c) {
      return Wt.quickSetter(c, t10, n);
    }), r = o.length;
    return function(c) {
      for (var u = r; u--; ) o[u](c);
    };
  }
  e16 = e16[0] || {};
  var a = Ht[t10], i = _o(e16), s = i.harness && (i.harness.aliases || {})[t10] || t10, l = a ? function(c) {
    var u = new a();
    Uo._pt = 0, u.init(e16, n ? c + n : c, Uo, 0, [e16]), u.render(1, u), Uo._pt && Al(1, Uo);
  } : i.set(e16, s);
  return a ? l : function(c) {
    return l(e16, s, n ? c + n : c, i, 1);
  };
}, quickTo: function(e16, t10, n) {
  var o, r = Wt.to(e16, Mo((o = {}, o[t10] = "+=0.1", o.paused = true, o), n || {})), a = function(i, s, l) {
    return r.resetTo(t10, i, s, l);
  };
  return a.tween = r, a;
}, isTweening: function(e16) {
  return mt.getTweensOf(e16, true).length > 0;
}, defaults: function(e16) {
  return e16 && e16.ease && (e16.ease = To(e16.ease, ra.ease)), Cc(ra, e16 || {});
}, config: function(e16) {
  return Cc(Qt, e16 || {});
}, registerEffect: function(e16) {
  var t10 = e16.name, n = e16.effect, o = e16.plugins, r = e16.defaults, a = e16.extendTimeline;
  (o || "").split(",").forEach(function(i) {
    return i && !Ht[i] && !en[i] && Fa(t10 + " effect requires " + i + " plugin.");
  }), Fi[t10] = function(i, s, l) {
    return n(rn(i), sn(s || {}, r), l);
  }, a && (Pt.prototype[t10] = function(i, s, l) {
    return this.add(Fi[t10](i, $n(s) ? s : (l = s) && {}, this), l);
  });
}, registerEase: function(e16, t10) {
  Oe[e16] = To(t10);
}, parseEase: function(e16, t10) {
  return arguments.length ? To(e16, t10) : Oe;
}, getById: function(e16) {
  return mt.getById(e16);
}, exportRoot: function(e16, t10) {
  e16 === void 0 && (e16 = {});
  var n = new Pt(e16), o, r;
  for (n.smoothChildTiming = jt(e16.smoothChildTiming), mt.remove(n), n._dp = 0, n._time = n._tTime = mt._time, o = mt._first; o; ) r = o._next, (t10 || !(!o._dur && o instanceof Tt && o.vars.onComplete === o._targets[0])) && _n(n, o, o._start - o._delay), o = r;
  return _n(mt, n, 0), n;
}, context: function(e16, t10) {
  return e16 ? new ad(e16, t10) : dt;
}, matchMedia: function(e16) {
  return new wh(e16);
}, matchMediaRefresh: function() {
  return Co.forEach(function(e16) {
    var t10 = e16.conditions, n, o;
    for (o in t10) t10[o] && (t10[o] = false, n = 1);
    n && e16.revert();
  }) || Ps();
}, addEventListener: function(e16, t10) {
  var n = Cr[e16] || (Cr[e16] = []);
  ~n.indexOf(t10) || n.push(t10);
}, removeEventListener: function(e16, t10) {
  var n = Cr[e16], o = n && n.indexOf(t10);
  o >= 0 && n.splice(o, 1);
}, utils: { wrap: Jp, wrapYoyo: eh, distribute: R0, random: F0, snap: L0, normalize: Qp, getUnit: Et, clamp: Up, splitColor: W0, toArray: rn, selector: Es, mapRange: O0, pipe: Xp, unitize: Yp, interpolate: th, shuffle: P0 }, install: k0, effects: Fi, ticker: Ut, updateRoot: Pt.updateRoot, plugins: Ht, globalTimeline: mt, core: { PropTween: Bt, globals: S0, Tween: Tt, Timeline: Pt, Animation: Za, getCache: _o, _removeLinkedListItem: ai, reverting: function() {
  return Kt;
}, context: function(e16) {
  return e16 && dt && (dt.data.push(e16), e16._ctx = dt), dt;
}, suppressOverwrites: function(e16) {
  return _l = e16;
} } };
Ot("to,from,fromTo,delayedCall,set,killTweensOf", function(e16) {
  return Pr[e16] = Tt[e16];
});
Ut.add(Pt.updateRoot);
Uo = Pr.to({}, { duration: 0 });
var Th = function(e16, t10) {
  for (var n = e16._pt; n && n.p !== t10 && n.op !== t10 && n.fp !== t10; ) n = n._next;
  return n;
};
var Ch = function(e16, t10) {
  var n = e16._targets, o, r, a;
  for (o in t10) for (r = n.length; r--; ) a = e16._ptLookup[r][o], a && (a = a.d) && (a._pt && (a = Th(a, o)), a && a.modifier && a.modifier(t10[o], e16, n[r], o));
};
var Wi = function(e16, t10) {
  return { name: e16, rawVars: 1, init: function(n, o, r) {
    r._onInit = function(a) {
      var i, s;
      if (It(o) && (i = {}, Ot(o, function(l) {
        return i[l] = 1;
      }), o = i), t10) {
        i = {};
        for (s in o) i[s] = t10(o[s]);
        o = i;
      }
      Ch(a, o);
    };
  } };
};
var Wt = Pr.registerPlugin({ name: "attr", init: function(e16, t10, n, o, r) {
  var a, i, s;
  this.tween = n;
  for (a in t10) s = e16.getAttribute(a) || "", i = this.add(e16, "setAttribute", (s || 0) + "", t10[a], o, r, 0, 0, a), i.op = a, i.b = s, this._props.push(a);
}, render: function(e16, t10) {
  for (var n = t10._pt; n; ) Kt ? n.set(n.t, n.p, n.b, n) : n.r(e16, n.d), n = n._next;
} }, { name: "endArray", init: function(e16, t10) {
  for (var n = t10.length; n--; ) this.add(e16, n, e16[n] || 0, t10[n], 0, 0, 0, 0, 0, 1);
} }, Wi("roundProps", Ks), Wi("modifiers"), Wi("snap", L0)) || Pr;
Tt.version = Pt.version = Wt.version = "3.12.5";
C0 = 1;
Tl() && la();
Oe.Power0;
Oe.Power1;
Oe.Power2;
Oe.Power3;
Oe.Power4;
Oe.Linear;
Oe.Quad;
Oe.Cubic;
Oe.Quart;
Oe.Quint;
Oe.Strong;
Oe.Elastic;
Oe.Back;
Oe.SteppedEase;
Oe.Bounce;
Oe.Sine;
Oe.Expo;
Oe.Circ;
var xc;
var Hn;
var Jo;
var El;
var yo;
var Ic;
var Kl;
var kh = function() {
  return typeof window < "u";
};
var Rn = {};
var go = 180 / Math.PI;
var ea = Math.PI / 180;
var qo = Math.atan2;
var Dc = 1e8;
var zl = /([A-Z])/g;
var Sh = /(left|right|width|margin|padding|x)/i;
var Nh = /[\s,\(]\S/;
var Tn = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" };
var Rs = function(e16, t10) {
  return t10.set(t10.t, t10.p, Math.round((t10.s + t10.c * e16) * 1e4) / 1e4 + t10.u, t10);
};
var Mh = function(e16, t10) {
  return t10.set(t10.t, t10.p, e16 === 1 ? t10.e : Math.round((t10.s + t10.c * e16) * 1e4) / 1e4 + t10.u, t10);
};
var $h = function(e16, t10) {
  return t10.set(t10.t, t10.p, e16 ? Math.round((t10.s + t10.c * e16) * 1e4) / 1e4 + t10.u : t10.b, t10);
};
var xh = function(e16, t10) {
  var n = t10.s + t10.c * e16;
  t10.set(t10.t, t10.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t10.u, t10);
};
var rd = function(e16, t10) {
  return t10.set(t10.t, t10.p, e16 ? t10.e : t10.b, t10);
};
var id = function(e16, t10) {
  return t10.set(t10.t, t10.p, e16 !== 1 ? t10.b : t10.e, t10);
};
var Ih = function(e16, t10, n) {
  return e16.style[t10] = n;
};
var Dh = function(e16, t10, n) {
  return e16.style.setProperty(t10, n);
};
var Ah = function(e16, t10, n) {
  return e16._gsap[t10] = n;
};
var Eh = function(e16, t10, n) {
  return e16._gsap.scaleX = e16._gsap.scaleY = n;
};
var Kh = function(e16, t10, n, o, r) {
  var a = e16._gsap;
  a.scaleX = a.scaleY = n, a.renderTransform(r, a);
};
var zh = function(e16, t10, n, o, r) {
  var a = e16._gsap;
  a[t10] = n, a.renderTransform(r, a);
};
var pt = "transform";
var Zt = pt + "Origin";
var Ph = function e12(t10, n) {
  var o = this, r = this.target, a = r.style, i = r._gsap;
  if (t10 in Rn && a) {
    if (this.tfm = this.tfm || {}, t10 !== "transform") t10 = Tn[t10] || t10, ~t10.indexOf(",") ? t10.split(",").forEach(function(s) {
      return o.tfm[s] = Kn(r, s);
    }) : this.tfm[t10] = i.x ? i[t10] : Kn(r, t10), t10 === Zt && (this.tfm.zOrigin = i.zOrigin);
    else return Tn.transform.split(",").forEach(function(s) {
      return e12.call(o, s, n);
    });
    if (this.props.indexOf(pt) >= 0) return;
    i.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(Zt, n, "")), t10 = pt;
  }
  (a || n) && this.props.push(t10, n, a[t10]);
};
var sd = function(e16) {
  e16.translate && (e16.removeProperty("translate"), e16.removeProperty("scale"), e16.removeProperty("rotate"));
};
var Rh = function() {
  var e16 = this.props, t10 = this.target, n = t10.style, o = t10._gsap, r, a;
  for (r = 0; r < e16.length; r += 3) e16[r + 1] ? t10[e16[r]] = e16[r + 2] : e16[r + 2] ? n[e16[r]] = e16[r + 2] : n.removeProperty(e16[r].substr(0, 2) === "--" ? e16[r] : e16[r].replace(zl, "-$1").toLowerCase());
  if (this.tfm) {
    for (a in this.tfm) o[a] = this.tfm[a];
    o.svg && (o.renderTransform(), t10.setAttribute("data-svg-origin", this.svgo || "")), r = Kl(), (!r || !r.isStart) && !n[pt] && (sd(n), o.zOrigin && n[Zt] && (n[Zt] += " " + o.zOrigin + "px", o.zOrigin = 0, o.renderTransform()), o.uncache = 1);
  }
};
var ld = function(e16, t10) {
  var n = { target: e16, props: [], revert: Rh, save: Ph };
  return e16._gsap || Wt.core.getCache(e16), t10 && t10.split(",").forEach(function(o) {
    return n.save(o);
  }), n;
};
var cd;
var Ls = function(e16, t10) {
  var n = Hn.createElementNS ? Hn.createElementNS((t10 || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e16) : Hn.createElement(e16);
  return n && n.style ? n : Hn.createElement(e16);
};
var Sn = function e13(t10, n, o) {
  var r = getComputedStyle(t10);
  return r[n] || r.getPropertyValue(n.replace(zl, "-$1").toLowerCase()) || r.getPropertyValue(n) || !o && e13(t10, ca(n) || n, 1) || "";
};
var Ac = "O,Moz,ms,Ms,Webkit".split(",");
var ca = function(e16, t10, n) {
  var o = t10 || yo, r = o.style, a = 5;
  if (e16 in r && !n) return e16;
  for (e16 = e16.charAt(0).toUpperCase() + e16.substr(1); a-- && !(Ac[a] + e16 in r); ) ;
  return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? Ac[a] : "") + e16;
};
var Fs = function() {
  kh() && window.document && (xc = window, Hn = xc.document, Jo = Hn.documentElement, yo = Ls("div") || { style: {} }, Ls("div"), pt = ca(pt), Zt = pt + "Origin", yo.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", cd = !!ca("perspective"), Kl = Wt.core.reverting, El = 1);
};
var qi = function e14(t10) {
  var n = Ls("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), o = this.parentNode, r = this.nextSibling, a = this.style.cssText, i;
  if (Jo.appendChild(n), n.appendChild(this), this.style.display = "block", t10) try {
    i = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e14;
  } catch {
  }
  else this._gsapBBox && (i = this._gsapBBox());
  return o && (r ? o.insertBefore(this, r) : o.appendChild(this)), Jo.removeChild(n), this.style.cssText = a, i;
};
var Ec = function(e16, t10) {
  for (var n = t10.length; n--; ) if (e16.hasAttribute(t10[n])) return e16.getAttribute(t10[n]);
};
var ud = function(e16) {
  var t10;
  try {
    t10 = e16.getBBox();
  } catch {
    t10 = qi.call(e16, true);
  }
  return t10 && (t10.width || t10.height) || e16.getBBox === qi || (t10 = qi.call(e16, true)), t10 && !t10.width && !t10.x && !t10.y ? { x: +Ec(e16, ["x", "cx", "x1"]) || 0, y: +Ec(e16, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : t10;
};
var dd = function(e16) {
  return !!(e16.getCTM && (!e16.parentNode || e16.ownerSVGElement) && ud(e16));
};
var $o = function(e16, t10) {
  if (t10) {
    var n = e16.style, o;
    t10 in Rn && t10 !== Zt && (t10 = pt), n.removeProperty ? (o = t10.substr(0, 2), (o === "ms" || t10.substr(0, 6) === "webkit") && (t10 = "-" + t10), n.removeProperty(o === "--" ? t10 : t10.replace(zl, "-$1").toLowerCase())) : n.removeAttribute(t10);
  }
};
var Un = function(e16, t10, n, o, r, a) {
  var i = new Bt(e16._pt, t10, n, 0, 1, a ? id : rd);
  return e16._pt = i, i.b = o, i.e = r, e16._props.push(n), i;
};
var Kc = { deg: 1, rad: 1, turn: 1 };
var Lh = { grid: 1, flex: 1 };
var eo = function e15(t10, n, o, r) {
  var a = parseFloat(o) || 0, i = (o + "").trim().substr((a + "").length) || "px", s = yo.style, l = Sh.test(n), c = t10.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), d = 100, m = r === "px", p = r === "%", f, h10, g, v;
  if (r === i || !a || Kc[r] || Kc[i]) return a;
  if (i !== "px" && !m && (a = e15(t10, n, o, "px")), v = t10.getCTM && dd(t10), (p || i === "%") && (Rn[n] || ~n.indexOf("adius"))) return f = v ? t10.getBBox()[l ? "width" : "height"] : t10[u], _t2(p ? a / f * d : a / 100 * f);
  if (s[l ? "width" : "height"] = d + (m ? i : r), h10 = ~n.indexOf("adius") || r === "em" && t10.appendChild && !c ? t10 : t10.parentNode, v && (h10 = (t10.ownerSVGElement || {}).parentNode), (!h10 || h10 === Hn || !h10.appendChild) && (h10 = Hn.body), g = h10._gsap, g && p && g.width && l && g.time === Ut.time && !g.uncache) return _t2(a / g.width * d);
  if (p && (n === "height" || n === "width")) {
    var y = t10.style[n];
    t10.style[n] = d + r, f = t10[u], y ? t10.style[n] = y : $o(t10, n);
  } else (p || i === "%") && !Lh[Sn(h10, "display")] && (s.position = Sn(t10, "position")), h10 === t10 && (s.position = "static"), h10.appendChild(yo), f = yo[u], h10.removeChild(yo), s.position = "absolute";
  return l && p && (g = _o(h10), g.time = Ut.time, g.width = h10[u]), _t2(m ? f * a / d : f && a ? d / f * a : 0);
};
var Kn = function(e16, t10, n, o) {
  var r;
  return El || Fs(), t10 in Tn && t10 !== "transform" && (t10 = Tn[t10], ~t10.indexOf(",") && (t10 = t10.split(",")[0])), Rn[t10] && t10 !== "transform" ? (r = qa(e16, o), r = t10 !== "transformOrigin" ? r[t10] : r.svg ? r.origin : Lr(Sn(e16, Zt)) + " " + r.zOrigin + "px") : (r = e16.style[t10], (!r || r === "auto" || o || ~(r + "").indexOf("calc(")) && (r = Rr[t10] && Rr[t10](e16, t10, n) || Sn(e16, t10) || M0(e16, t10) || (t10 === "opacity" ? 1 : 0))), n && !~(r + "").trim().indexOf(" ") ? eo(e16, t10, r, n) + n : r;
};
var Fh = function(e16, t10, n, o) {
  if (!n || n === "none") {
    var r = ca(t10, e16, 1), a = r && Sn(e16, r, 1);
    a && a !== n ? (t10 = r, n = a) : t10 === "borderColor" && (n = Sn(e16, "borderTopColor"));
  }
  var i = new Bt(this._pt, e16.style, t10, 0, 1, nd), s = 0, l = 0, c, u, d, m, p, f, h10, g, v, y, k, T;
  if (i.b = n, i.e = o, n += "", o += "", o === "auto" && (f = e16.style[t10], e16.style[t10] = o, o = Sn(e16, t10) || o, f ? e16.style[t10] = f : $o(e16, t10)), c = [n, o], V0(c), n = c[0], o = c[1], d = n.match(Ho) || [], T = o.match(Ho) || [], T.length) {
    for (; u = Ho.exec(o); ) h10 = u[0], v = o.substring(s, u.index), p ? p = (p + 1) % 5 : (v.substr(-5) === "rgba(" || v.substr(-5) === "hsla(") && (p = 1), h10 !== (f = d[l++] || "") && (m = parseFloat(f) || 0, k = f.substr((m + "").length), h10.charAt(1) === "=" && (h10 = Qo(m, h10) + k), g = parseFloat(h10), y = h10.substr((g + "").length), s = Ho.lastIndex - y.length, y || (y = y || Qt.units[t10] || k, s === o.length && (o += y, i.e += y)), k !== y && (m = eo(e16, t10, f, y) || 0), i._pt = { _next: i._pt, p: v || l === 1 ? v : ",", s: m, c: g - m, m: p && p < 4 || t10 === "zIndex" ? Math.round : 0 });
    i.c = s < o.length ? o.substring(s, o.length) : "";
  } else i.r = t10 === "display" && o === "none" ? id : rd;
  return w0.test(o) && (i.e = 0), this._pt = i, i;
};
var zc = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" };
var jh = function(e16) {
  var t10 = e16.split(" "), n = t10[0], o = t10[1] || "50%";
  return (n === "top" || n === "bottom" || o === "left" || o === "right") && (e16 = n, n = o, o = e16), t10[0] = zc[n] || n, t10[1] = zc[o] || o, t10.join(" ");
};
var Oh = function(e16, t10) {
  if (t10.tween && t10.tween._time === t10.tween._dur) {
    var n = t10.t, o = n.style, r = t10.u, a = n._gsap, i, s, l;
    if (r === "all" || r === true) o.cssText = "", s = 1;
    else for (r = r.split(","), l = r.length; --l > -1; ) i = r[l], Rn[i] && (s = 1, i = i === "transformOrigin" ? Zt : pt), $o(n, i);
    s && ($o(n, pt), a && (a.svg && n.removeAttribute("transform"), qa(n, 1), a.uncache = 1, sd(o)));
  }
};
var Rr = { clearProps: function(e16, t10, n, o, r) {
  if (r.data !== "isFromStart") {
    var a = e16._pt = new Bt(e16._pt, t10, n, 0, 0, Oh);
    return a.u = o, a.pr = -10, a.tween = r, e16._props.push(n), 1;
  }
} };
var Wa = [1, 0, 0, 1, 0, 0];
var fd = {};
var md = function(e16) {
  return e16 === "matrix(1, 0, 0, 1, 0, 0)" || e16 === "none" || !e16;
};
var Pc = function(e16) {
  var t10 = Sn(e16, pt);
  return md(t10) ? Wa : t10.substr(7).match(_0).map(_t2);
};
var Pl = function(e16, t10) {
  var n = e16._gsap || _o(e16), o = e16.style, r = Pc(e16), a, i, s, l;
  return n.svg && e16.getAttribute("transform") ? (s = e16.transform.baseVal.consolidate().matrix, r = [s.a, s.b, s.c, s.d, s.e, s.f], r.join(",") === "1,0,0,1,0,0" ? Wa : r) : (r === Wa && !e16.offsetParent && e16 !== Jo && !n.svg && (s = o.display, o.display = "block", a = e16.parentNode, (!a || !e16.offsetParent) && (l = 1, i = e16.nextElementSibling, Jo.appendChild(e16)), r = Pc(e16), s ? o.display = s : $o(e16, "display"), l && (i ? a.insertBefore(e16, i) : a ? a.appendChild(e16) : Jo.removeChild(e16))), t10 && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
};
var js = function(e16, t10, n, o, r, a) {
  var i = e16._gsap, s = r || Pl(e16, true), l = i.xOrigin || 0, c = i.yOrigin || 0, u = i.xOffset || 0, d = i.yOffset || 0, m = s[0], p = s[1], f = s[2], h10 = s[3], g = s[4], v = s[5], y = t10.split(" "), k = parseFloat(y[0]) || 0, T = parseFloat(y[1]) || 0, w, _, M, x;
  n ? s !== Wa && (_ = m * h10 - p * f) && (M = k * (h10 / _) + T * (-f / _) + (f * v - h10 * g) / _, x = k * (-p / _) + T * (m / _) - (m * v - p * g) / _, k = M, T = x) : (w = ud(e16), k = w.x + (~y[0].indexOf("%") ? k / 100 * w.width : k), T = w.y + (~(y[1] || y[0]).indexOf("%") ? T / 100 * w.height : T)), o || o !== false && i.smooth ? (g = k - l, v = T - c, i.xOffset = u + (g * m + v * f) - g, i.yOffset = d + (g * p + v * h10) - v) : i.xOffset = i.yOffset = 0, i.xOrigin = k, i.yOrigin = T, i.smooth = !!o, i.origin = t10, i.originIsAbsolute = !!n, e16.style[Zt] = "0px 0px", a && (Un(a, i, "xOrigin", l, k), Un(a, i, "yOrigin", c, T), Un(a, i, "xOffset", u, i.xOffset), Un(a, i, "yOffset", d, i.yOffset)), e16.setAttribute("data-svg-origin", k + " " + T);
};
var qa = function(e16, t10) {
  var n = e16._gsap || new X0(e16);
  if ("x" in n && !t10 && !n.uncache) return n;
  var o = e16.style, r = n.scaleX < 0, a = "px", i = "deg", s = getComputedStyle(e16), l = Sn(e16, Zt) || "0", c, u, d, m, p, f, h10, g, v, y, k, T, w, _, M, x, R, I, P, F, N, j, z, A, B, D, te, ie, U, oe, se, E;
  return c = u = d = f = h10 = g = v = y = k = 0, m = p = 1, n.svg = !!(e16.getCTM && dd(e16)), s.translate && ((s.translate !== "none" || s.scale !== "none" || s.rotate !== "none") && (o[pt] = (s.translate !== "none" ? "translate3d(" + (s.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (s.rotate !== "none" ? "rotate(" + s.rotate + ") " : "") + (s.scale !== "none" ? "scale(" + s.scale.split(" ").join(",") + ") " : "") + (s[pt] !== "none" ? s[pt] : "")), o.scale = o.rotate = o.translate = "none"), _ = Pl(e16, n.svg), n.svg && (n.uncache ? (B = e16.getBBox(), l = n.xOrigin - B.x + "px " + (n.yOrigin - B.y) + "px", A = "") : A = !t10 && e16.getAttribute("data-svg-origin"), js(e16, A || l, !!A || n.originIsAbsolute, n.smooth !== false, _)), T = n.xOrigin || 0, w = n.yOrigin || 0, _ !== Wa && (I = _[0], P = _[1], F = _[2], N = _[3], c = j = _[4], u = z = _[5], _.length === 6 ? (m = Math.sqrt(I * I + P * P), p = Math.sqrt(N * N + F * F), f = I || P ? qo(P, I) * go : 0, v = F || N ? qo(F, N) * go + f : 0, v && (p *= Math.abs(Math.cos(v * ea))), n.svg && (c -= T - (T * I + w * F), u -= w - (T * P + w * N))) : (E = _[6], oe = _[7], te = _[8], ie = _[9], U = _[10], se = _[11], c = _[12], u = _[13], d = _[14], M = qo(E, U), h10 = M * go, M && (x = Math.cos(-M), R = Math.sin(-M), A = j * x + te * R, B = z * x + ie * R, D = E * x + U * R, te = j * -R + te * x, ie = z * -R + ie * x, U = E * -R + U * x, se = oe * -R + se * x, j = A, z = B, E = D), M = qo(-F, U), g = M * go, M && (x = Math.cos(-M), R = Math.sin(-M), A = I * x - te * R, B = P * x - ie * R, D = F * x - U * R, se = N * R + se * x, I = A, P = B, F = D), M = qo(P, I), f = M * go, M && (x = Math.cos(M), R = Math.sin(M), A = I * x + P * R, B = j * x + z * R, P = P * x - I * R, z = z * x - j * R, I = A, j = B), h10 && Math.abs(h10) + Math.abs(f) > 359.9 && (h10 = f = 0, g = 180 - g), m = _t2(Math.sqrt(I * I + P * P + F * F)), p = _t2(Math.sqrt(z * z + E * E)), M = qo(j, z), v = Math.abs(M) > 2e-4 ? M * go : 0, k = se ? 1 / (se < 0 ? -se : se) : 0), n.svg && (A = e16.getAttribute("transform"), n.forceCSS = e16.setAttribute("transform", "") || !md(Sn(e16, pt)), A && e16.setAttribute("transform", A))), Math.abs(v) > 90 && Math.abs(v) < 270 && (r ? (m *= -1, v += f <= 0 ? 180 : -180, f += f <= 0 ? 180 : -180) : (p *= -1, v += v <= 0 ? 180 : -180)), t10 = t10 || n.uncache, n.x = c - ((n.xPercent = c && (!t10 && n.xPercent || (Math.round(e16.offsetWidth / 2) === Math.round(-c) ? -50 : 0))) ? e16.offsetWidth * n.xPercent / 100 : 0) + a, n.y = u - ((n.yPercent = u && (!t10 && n.yPercent || (Math.round(e16.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? e16.offsetHeight * n.yPercent / 100 : 0) + a, n.z = d + a, n.scaleX = _t2(m), n.scaleY = _t2(p), n.rotation = _t2(f) + i, n.rotationX = _t2(h10) + i, n.rotationY = _t2(g) + i, n.skewX = v + i, n.skewY = y + i, n.transformPerspective = k + a, (n.zOrigin = parseFloat(l.split(" ")[2]) || !t10 && n.zOrigin || 0) && (o[Zt] = Lr(l)), n.xOffset = n.yOffset = 0, n.force3D = Qt.force3D, n.renderTransform = n.svg ? Zh : cd ? pd : Bh, n.uncache = 0, n;
};
var Lr = function(e16) {
  return (e16 = e16.split(" "))[0] + " " + e16[1];
};
var Vi = function(e16, t10, n) {
  var o = Et(t10);
  return _t2(parseFloat(t10) + parseFloat(eo(e16, "x", n + "px", o))) + o;
};
var Bh = function(e16, t10) {
  t10.z = "0px", t10.rotationY = t10.rotationX = "0deg", t10.force3D = 0, pd(e16, t10);
};
var mo = "0deg";
var Na = "0px";
var po = ") ";
var pd = function(e16, t10) {
  var n = t10 || this, o = n.xPercent, r = n.yPercent, a = n.x, i = n.y, s = n.z, l = n.rotation, c = n.rotationY, u = n.rotationX, d = n.skewX, m = n.skewY, p = n.scaleX, f = n.scaleY, h10 = n.transformPerspective, g = n.force3D, v = n.target, y = n.zOrigin, k = "", T = g === "auto" && e16 && e16 !== 1 || g === true;
  if (y && (u !== mo || c !== mo)) {
    var w = parseFloat(c) * ea, _ = Math.sin(w), M = Math.cos(w), x;
    w = parseFloat(u) * ea, x = Math.cos(w), a = Vi(v, a, _ * x * -y), i = Vi(v, i, -Math.sin(w) * -y), s = Vi(v, s, M * x * -y + y);
  }
  h10 !== Na && (k += "perspective(" + h10 + po), (o || r) && (k += "translate(" + o + "%, " + r + "%) "), (T || a !== Na || i !== Na || s !== Na) && (k += s !== Na || T ? "translate3d(" + a + ", " + i + ", " + s + ") " : "translate(" + a + ", " + i + po), l !== mo && (k += "rotate(" + l + po), c !== mo && (k += "rotateY(" + c + po), u !== mo && (k += "rotateX(" + u + po), (d !== mo || m !== mo) && (k += "skew(" + d + ", " + m + po), (p !== 1 || f !== 1) && (k += "scale(" + p + ", " + f + po), v.style[pt] = k || "translate(0, 0)";
};
var Zh = function(e16, t10) {
  var n = t10 || this, o = n.xPercent, r = n.yPercent, a = n.x, i = n.y, s = n.rotation, l = n.skewX, c = n.skewY, u = n.scaleX, d = n.scaleY, m = n.target, p = n.xOrigin, f = n.yOrigin, h10 = n.xOffset, g = n.yOffset, v = n.forceCSS, y = parseFloat(a), k = parseFloat(i), T, w, _, M, x;
  s = parseFloat(s), l = parseFloat(l), c = parseFloat(c), c && (c = parseFloat(c), l += c, s += c), s || l ? (s *= ea, l *= ea, T = Math.cos(s) * u, w = Math.sin(s) * u, _ = Math.sin(s - l) * -d, M = Math.cos(s - l) * d, l && (c *= ea, x = Math.tan(l - c), x = Math.sqrt(1 + x * x), _ *= x, M *= x, c && (x = Math.tan(c), x = Math.sqrt(1 + x * x), T *= x, w *= x)), T = _t2(T), w = _t2(w), _ = _t2(_), M = _t2(M)) : (T = u, M = d, w = _ = 0), (y && !~(a + "").indexOf("px") || k && !~(i + "").indexOf("px")) && (y = eo(m, "x", a, "px"), k = eo(m, "y", i, "px")), (p || f || h10 || g) && (y = _t2(y + p - (p * T + f * _) + h10), k = _t2(k + f - (p * w + f * M) + g)), (o || r) && (x = m.getBBox(), y = _t2(y + o / 100 * x.width), k = _t2(k + r / 100 * x.height)), x = "matrix(" + T + "," + w + "," + _ + "," + M + "," + y + "," + k + ")", m.setAttribute("transform", x), v && (m.style[pt] = x);
};
var Wh = function(e16, t10, n, o, r) {
  var a = 360, i = It(r), s = parseFloat(r) * (i && ~r.indexOf("rad") ? go : 1), l = s - o, c = o + l + "deg", u, d;
  return i && (u = r.split("_")[1], u === "short" && (l %= a, l !== l % (a / 2) && (l += l < 0 ? a : -a)), u === "cw" && l < 0 ? l = (l + a * Dc) % a - ~~(l / a) * a : u === "ccw" && l > 0 && (l = (l - a * Dc) % a - ~~(l / a) * a)), e16._pt = d = new Bt(e16._pt, t10, n, o, l, Mh), d.e = c, d.u = "deg", e16._props.push(n), d;
};
var Rc = function(e16, t10) {
  for (var n in t10) e16[n] = t10[n];
  return e16;
};
var qh = function(e16, t10, n) {
  var o = Rc({}, n._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", a = n.style, i, s, l, c, u, d, m, p;
  o.svg ? (l = n.getAttribute("transform"), n.setAttribute("transform", ""), a[pt] = t10, i = qa(n, 1), $o(n, pt), n.setAttribute("transform", l)) : (l = getComputedStyle(n)[pt], a[pt] = t10, i = qa(n, 1), a[pt] = l);
  for (s in Rn) l = o[s], c = i[s], l !== c && r.indexOf(s) < 0 && (m = Et(l), p = Et(c), u = m !== p ? eo(n, s, l, p) : parseFloat(l), d = parseFloat(c), e16._pt = new Bt(e16._pt, i, s, u, d - u, Rs), e16._pt.u = p || 0, e16._props.push(s));
  Rc(i, o);
};
Ot("padding,margin,Width,Radius", function(e16, t10) {
  var n = "Top", o = "Right", r = "Bottom", a = "Left", i = (t10 < 3 ? [n, o, r, a] : [n + a, n + o, r + o, r + a]).map(function(s) {
    return t10 < 2 ? e16 + s : "border" + s + e16;
  });
  Rr[t10 > 1 ? "border" + e16 : e16] = function(s, l, c, u, d) {
    var m, p;
    if (arguments.length < 4) return m = i.map(function(f) {
      return Kn(s, f, c);
    }), p = m.join(" "), p.split(m[0]).length === 5 ? m[0] : p;
    m = (u + "").split(" "), p = {}, i.forEach(function(f, h10) {
      return p[f] = m[h10] = m[h10] || m[(h10 - 1) / 2 | 0];
    }), s.init(l, p, d);
  };
});
var hd = { name: "css", register: Fs, targetTest: function(e16) {
  return e16.style && e16.nodeType;
}, init: function(e16, t10, n, o, r) {
  var a = this._props, i = e16.style, s = n.vars.startAt, l, c, u, d, m, p, f, h10, g, v, y, k, T, w, _, M;
  El || Fs(), this.styles = this.styles || ld(e16), M = this.styles.props, this.tween = n;
  for (f in t10) if (f !== "autoRound" && (c = t10[f], !(Ht[f] && Y0(f, t10, n, o, e16, r)))) {
    if (m = typeof c, p = Rr[f], m === "function" && (c = c.call(n, o, e16, r), m = typeof c), m === "string" && ~c.indexOf("random(") && (c = Oa(c)), p) p(this, e16, f, c, n) && (_ = 1);
    else if (f.substr(0, 2) === "--") l = (getComputedStyle(e16).getPropertyValue(f) + "").trim(), c += "", Xn.lastIndex = 0, Xn.test(l) || (h10 = Et(l), g = Et(c)), g ? h10 !== g && (l = eo(e16, f, l, g) + g) : h10 && (c += h10), this.add(i, "setProperty", l, c, o, r, 0, 0, f), a.push(f), M.push(f, 0, i[f]);
    else if (m !== "undefined") {
      if (s && f in s ? (l = typeof s[f] == "function" ? s[f].call(n, o, e16, r) : s[f], It(l) && ~l.indexOf("random(") && (l = Oa(l)), Et(l + "") || l === "auto" || (l += Qt.units[f] || Et(Kn(e16, f)) || ""), (l + "").charAt(1) === "=" && (l = Kn(e16, f))) : l = Kn(e16, f), d = parseFloat(l), v = m === "string" && c.charAt(1) === "=" && c.substr(0, 2), v && (c = c.substr(2)), u = parseFloat(c), f in Tn && (f === "autoAlpha" && (d === 1 && Kn(e16, "visibility") === "hidden" && u && (d = 0), M.push("visibility", 0, i.visibility), Un(this, i, "visibility", d ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), f !== "scale" && f !== "transform" && (f = Tn[f], ~f.indexOf(",") && (f = f.split(",")[0]))), y = f in Rn, y) {
        if (this.styles.save(f), k || (T = e16._gsap, T.renderTransform && !t10.parseTransform || qa(e16, t10.parseTransform), w = t10.smoothOrigin !== false && T.smooth, k = this._pt = new Bt(this._pt, i, pt, 0, 1, T.renderTransform, T, 0, -1), k.dep = 1), f === "scale") this._pt = new Bt(this._pt, T, "scaleY", T.scaleY, (v ? Qo(T.scaleY, v + u) : u) - T.scaleY || 0, Rs), this._pt.u = 0, a.push("scaleY", f), f += "X";
        else if (f === "transformOrigin") {
          M.push(Zt, 0, i[Zt]), c = jh(c), T.svg ? js(e16, c, 0, w, 0, this) : (g = parseFloat(c.split(" ")[2]) || 0, g !== T.zOrigin && Un(this, T, "zOrigin", T.zOrigin, g), Un(this, i, f, Lr(l), Lr(c)));
          continue;
        } else if (f === "svgOrigin") {
          js(e16, c, 1, w, 0, this);
          continue;
        } else if (f in fd) {
          Wh(this, T, f, d, v ? Qo(d, v + c) : c);
          continue;
        } else if (f === "smoothOrigin") {
          Un(this, T, "smooth", T.smooth, c);
          continue;
        } else if (f === "force3D") {
          T[f] = c;
          continue;
        } else if (f === "transform") {
          qh(this, c, e16);
          continue;
        }
      } else f in i || (f = ca(f) || f);
      if (y || (u || u === 0) && (d || d === 0) && !Nh.test(c) && f in i) h10 = (l + "").substr((d + "").length), u || (u = 0), g = Et(c) || (f in Qt.units ? Qt.units[f] : h10), h10 !== g && (d = eo(e16, f, l, g)), this._pt = new Bt(this._pt, y ? T : i, f, d, (v ? Qo(d, v + u) : u) - d, !y && (g === "px" || f === "zIndex") && t10.autoRound !== false ? xh : Rs), this._pt.u = g || 0, h10 !== g && g !== "%" && (this._pt.b = l, this._pt.r = $h);
      else if (f in i) Fh.call(this, e16, f, l, v ? v + c : c);
      else if (f in e16) this.add(e16, f, l || e16[f], v ? v + c : c, o, r);
      else if (f !== "parseTransform") {
        kl(f, c);
        continue;
      }
      y || (f in i ? M.push(f, 0, i[f]) : M.push(f, 1, l || e16[f])), a.push(f);
    }
  }
  _ && od(this);
}, render: function(e16, t10) {
  if (t10.tween._time || !Kl()) for (var n = t10._pt; n; ) n.r(e16, n.d), n = n._next;
  else t10.styles.revert();
}, get: Kn, aliases: Tn, getSetter: function(e16, t10, n) {
  var o = Tn[t10];
  return o && o.indexOf(",") < 0 && (t10 = o), t10 in Rn && t10 !== Zt && (e16._gsap.x || Kn(e16, "x")) ? n && Ic === n ? t10 === "scale" ? Eh : Ah : (Ic = n || {}) && (t10 === "scale" ? Kh : zh) : e16.style && !wl(e16.style[t10]) ? Ih : ~t10.indexOf("-") ? Dh : Dl(e16, t10);
}, core: { _removeProperty: $o, _getMatrix: Pl } };
Wt.utils.checkPrefix = ca;
Wt.core.getStyleSaver = ld;
(function(e16, t10, n, o) {
  var r = Ot(e16 + "," + t10 + "," + n, function(a) {
    Rn[a] = 1;
  });
  Ot(t10, function(a) {
    Qt.units[a] = "deg", fd[a] = 1;
  }), Tn[r[13]] = e16 + "," + t10, Ot(o, function(a) {
    var i = a.split(":");
    Tn[i[1]] = r[i[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Ot("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(e16) {
  Qt.units[e16] = "px";
});
Wt.registerPlugin(hd);
var Vh = Wt.registerPlugin(hd) || Wt;
Vh.core.Tween;
var Hh = Ye("Setting", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M8.854 3.816 8.64 5.097v.001q-.034.207-.274.34-.159.09-.237.138-.229.137-.426.064l-1.215-.456q-1.489-.56-2.284.818L2.907 8.25q-.792 1.375.433 2.383l1.004.826q.162.134.157.4-.002.142 0 .283.005.265-.157.398l-1.003.827q-1.227 1.009-.434 2.385l1.298 2.247q.795 1.375 2.281.817l1.216-.455q.198-.074.426.063.122.073.244.141.234.13.268.337l.213 1.282q.263 1.566 1.85 1.566h2.594q1.59 0 1.85-1.567l.213-1.28q.035-.208.268-.337.124-.07.242-.141.23-.138.427-.065l1.217.456q1.487.558 2.281-.818l1.299-2.247q.791-1.373-.433-2.384l-1.005-.827q-.162-.134-.156-.4.002-.14 0-.283-.006-.263.157-.397l1.002-.827q1.227-1.009.434-2.385l-1.297-2.247q-.795-1.377-2.282-.817l-1.217.456q-.197.073-.425-.064-.145-.088-.243-.141-.234-.13-.27-.337l-.212-1.28q-.26-1.568-1.85-1.568h-2.593q-1.59 0-1.85 1.566m1.266 1.529v-.001l.214-1.28q.052-.314.37-.314h2.593q.318 0 .37.313l.213 1.281q.156.923 1.021 1.403.082.044.197.113.85.513 1.725.184l1.217-.456q.299-.112.458.163l1.295 2.247q.16.275-.086.477l-1.004.827q-.724.596-.703 1.587.002.112 0 .227-.02.986.704 1.582l1.003.827q.245.202.087.476l-1.297 2.247q-.16.275-.457.164l-1.217-.456q-.875-.328-1.725.183-.1.06-.198.115-.864.478-1.02 1.4l-.213 1.283q-.052.313-.37.313h-2.594q-.318 0-.37-.314l-.213-1.28q-.153-.922-1.02-1.403-.1-.055-.196-.113-.85-.512-1.726-.185l-1.218.457q-.298.111-.457-.163l-1.296-2.247q-.159-.275.086-.477l1.005-.827q.721-.593.703-1.584-.002-.114 0-.227.018-.99-.703-1.584l-1.004-.828q-.245-.202-.087-.477l1.297-2.246q.159-.276.456-.164l1.217.456q.877.328 1.726-.184.066-.04.203-.118.86-.474 1.014-1.397" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M14.652 9.348Q13.553 8.25 12 8.25T9.348 9.348Q8.25 10.447 8.25 12t1.098 2.652T12 15.75t2.652-1.098Q15.75 13.553 15.75 12t-1.098-2.652m-4.243 1.061Q11.068 9.75 12 9.75t1.591.659T14.25 12t-.659 1.591T12 14.25t-1.591-.659T9.75 12t.659-1.591" }, null)]);
});
var Uh = Ye("SizeControls", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("rect", { width: "16", height: "1.5", x: "4", y: "2.5", rx: ".75" }, null), createVNode("rect", { width: "16", height: "1.5", x: "4", y: "20", rx: ".75" }, null), createVNode("path", { d: "M9 8h6l-3-3zM9 16h6l-3 3z" }, null), createVNode("rect", { width: "1.5", height: "8", x: "11.25", y: "8", rx: "0" }, null)]);
});
var Gh = Ye("TableSortDownColor", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, fill: "none", "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0 }, [createVNode("path", { fill: "#2882FF", d: "M6.375 13.25h11.25L12 19.5z" }, null), createVNode("path", { fill: "#CDCACF", d: "m12 4.5 5.625 6.25H6.375z" }, null)]);
});
var Xh = Ye("TableSortNormalColor", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, fill: "none", "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0 }, [createVNode("path", { fill: "#CDCACF", d: "m12 4.5 5.625 6.25H6.375zm-5.625 8.75h11.25L12 19.5z" }, null)]);
});
var Yh = Ye("TableSortUpColor", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, fill: "none", "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0 }, [createVNode("path", { fill: "#CDCACF", d: "M6.375 13.25h11.25L12 19.5z" }, null), createVNode("path", { fill: "#2882FF", d: "m12 4.5 5.625 6.25H6.375z" }, null)]);
});
var gd = Ye("Tips", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M2.095 16.185Q2.911 18.114 4.4 19.6q1.487 1.488 3.416 2.304 1.998.845 4.185.845t4.185-.845q1.929-.816 3.416-2.304 1.488-1.487 2.304-3.416.845-1.998.845-4.185t-.845-4.185Q21.089 5.886 19.6 4.4q-1.487-1.488-3.416-2.304Q14.187 1.25 12 1.25t-4.185.845Q5.886 2.911 4.4 4.4 2.91 5.886 2.095 7.815 1.25 9.813 1.25 12t.845 4.185M8.4 20.523q-1.66-.702-2.94-1.982T3.476 15.6Q2.75 13.881 2.75 12t.727-3.6q.702-1.66 1.982-2.94T8.4 3.476Q10.119 2.75 12 2.75t3.6.727q1.66.702 2.94 1.982t1.983 2.94q.727 1.719.727 3.601t-.727 3.6q-.702 1.66-1.982 2.94t-2.94 1.983q-1.719.727-3.601.727t-3.6-.727" }, null), createVNode("path", { d: "M13.25 6.75q0 .061-.006.123-.006.06-.018.12-.012.061-.03.12t-.041.115-.053.111-.063.105-.073.099-.082.09-.091.083q-.047.04-.099.073-.05.034-.105.063-.054.03-.11.053-.057.023-.116.041t-.12.03-.12.018Q12.06 8 12 8t-.123-.006q-.06-.006-.12-.018-.061-.012-.12-.03t-.115-.041-.111-.053-.105-.063-.099-.073-.09-.082-.083-.091q-.04-.047-.073-.099-.034-.05-.063-.105-.03-.054-.053-.11-.023-.057-.041-.116t-.03-.12-.018-.12q-.006-.062-.006-.123t.006-.123q.006-.06.018-.12.012-.061.03-.12t.041-.115.053-.111.063-.105.073-.099.082-.09.091-.083q.047-.04.099-.073.05-.034.105-.063.054-.03.11-.053.057-.023.116-.041t.12-.03.12-.018Q11.94 5.5 12 5.5t.123.006q.06.006.12.018.061.012.12.03t.115.041.111.053.105.063.099.073.09.082.083.091q.04.047.073.099.034.05.063.105.03.054.053.11.023.057.041.116t.03.12.018.12q.006.062.006.123" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M11.5 10.75h-.25q-.074 0-.146-.014-.073-.015-.141-.043t-.13-.07q-.061-.04-.113-.093-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14T10.5 10t.014-.146.043-.141.07-.13.093-.113q.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043t.147-.014h1q.074 0 .146.014.073.015.141.043t.13.07q.061.04.113.093.053.052.094.113.04.062.069.13.028.068.043.14T13 10v7q0 .074-.014.146-.015.073-.043.141t-.07.13q-.04.061-.093.113-.052.053-.113.094-.062.04-.13.069-.068.028-.14.043t-.147.014-.146-.014-.141-.043-.13-.07-.113-.093q-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14T11.5 17z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M10.5 16.25H14q.074 0 .146.014.073.015.141.043t.13.07q.061.04.113.093.053.052.094.113.04.062.069.13.028.068.043.14t.014.147-.014.146-.043.141-.07.13-.093.113q-.052.053-.113.094-.062.04-.13.069-.068.028-.14.043T14 17.75h-3.5q-.074 0-.146-.014-.073-.015-.141-.043t-.13-.07q-.061-.04-.113-.093-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14T9.75 17t.014-.146.043-.141.07-.13.093-.113q.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043t.147-.014" }, null)]);
});
var Qh = Ye("Unfold", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M2.643 13h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625H2.643a.634.634 0 0 0-.643.625c0 .345.288.625.643.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m6.955 9.067-3.403 3.308 3.402 3.308a.617.617 0 0 1 0 .884.65.65 0 0 1-.423.182l-.031.001a.65.65 0 0 1-.455-.183l-3.857-3.75a.616.616 0 0 1 0-.884l3.857-3.75a.65.65 0 0 1 .91 0 .616.616 0 0 1 0 .884M21.357 11.8h-7.714a.634.634 0 0 0-.643.625c0 .345.288.625.643.625h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m17.045 15.733 3.403-3.308-3.402-3.308a.617.617 0 0 1 0-.884.65.65 0 0 1 .423-.182l.031-.001c.17 0 .334.066.455.183l3.857 3.75a.616.616 0 0 1 0 .884l-3.857 3.75a.65.65 0 0 1-.91 0 .616.616 0 0 1 0-.884" }, null)]);
});
var Rl = Ye("Warning", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M4.58 21.083h-.003q-1.402.005-2.13-1.194-.729-1.201-.075-2.444L9.797 3.408q.324-.612.918-.97.594-.357 1.287-.357t1.286.357.918.97l7.424 14.036q.656 1.245-.075 2.447-.73 1.201-2.136 1.192zm-.003-1.5h14.851q.557.004.846-.472.289-.475.03-.966L12.88 4.11q-.28-.53-.878-.53-.6 0-.88.53L3.7 18.143q-.26.492.03.968.287.475.843.472z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M13.167 8.667v5a1 1 0 0 1-2 0v-5a1 1 0 0 1 2 0" }, null), createVNode("circle", { cx: "12", cy: "16.583", r: "1.25" }, null)]);
});
function Dt(e16) {
  let t10 = "";
  const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", o = n.length;
  for (let r = 0; r < e16; r++)
    t10 += n.charAt(Math.floor(Math.random() * o));
  return t10;
}
function vd(e16) {
  return e16 != null && e16 !== "";
}
function Jh(e16) {
  if (!e16)
    return false;
  const t10 = new Option().style;
  return t10.color = e16, !!t10.color;
}
function yd(e16, t10, n = "id") {
  const o = new Map(e16.map((c, u) => [c[n], u])), r = new Map(e16.map((c) => [c[n], c])), a = [], i = [];
  for (const c of t10) {
    const u = o.get(c) ?? -1;
    u >= 0 && (a.push(u), i.push(c));
  }
  a.sort((c, u) => c - u);
  for (const c in a)
    o.set(i[c], a[c]);
  const s = [];
  for (const [c, u] of o)
    s[u] = c;
  const l = [];
  for (const c of s)
    l.push(r.get(c));
  return l;
}
function Fr(e16, t10) {
  if (!Array.isArray(e16) || e16.length === 0)
    return [];
  let n = [];
  for (const o of e16)
    o[t10] ? n = n.concat(Fr(o[t10], t10)) : n.push(o);
  return n;
}
function bd(e16, t10) {
  if (!Array.isArray(e16) || e16.length === 0)
    return [];
  let n = [];
  for (const o of e16)
    n.push(o), Array.isArray(o[t10]) && (n = n.concat(bd(o[t10], t10)));
  return n;
}
function _d(e16, t10, n) {
  if (!Array.isArray(e16) || e16.length === 0)
    return [];
  for (let o = 0; o < e16.length; o++) {
    const r = e16[o];
    if (!n(r)) {
      e16.splice(o, 1), o--;
      continue;
    }
    Array.isArray(r[t10]) && _d(r[t10], t10, n);
  }
  return e16;
}
function wd(e16, t10, n, o) {
  const r = new Map(n.map((a) => [a[o], a]));
  for (let a = 0; a < e16.length; a++) {
    const i = e16[a];
    if (r.has(i[o])) {
      e16[a] = r.get(i[o]);
      continue;
    }
    Array.isArray(i[t10]) && wd(i[t10], t10, n, o);
  }
  return e16;
}
function Ae(e16, t10) {
  return new Proxy(e16, {
    get(o, r) {
      var a;
      return Object.hasOwnProperty.call(o, r) ? o[r] : (a = t10.value) == null ? void 0 : a[r];
    },
    has(o, r) {
      const a = isRef(t10) ? t10.value : t10;
      return Reflect.has(e16, r) || Reflect.has(a, r);
    }
  });
}
function eg(e16, t10) {
  return e16.sort((n, o) => {
    for (let r = 0; r < t10.length; r++) {
      const { field: a, order: i } = t10[r];
      let s = 0;
      if (typeof n[a] == "string" ? s = n[a].localeCompare(o[a]) : s = n[a] - o[a], i === "desc" && (s = -s), s !== 0)
        return s;
    }
    return 0;
  });
}
function hr(e16, t10) {
  if (typeof t10 != "string")
    return e16;
  const n = Array.isArray(e16) ? e16 : [e16], o = [];
  for (const r of n) {
    if (!(r instanceof Date)) {
      o.push(r);
      continue;
    }
    const a = r.getFullYear(), i = r.getMonth() + 1, s = r.getDate(), l = r.getHours(), c = r.getMinutes(), u = r.getSeconds(), d = t10.replace("YYYY", Vo(a, 4)).replace("MM", Vo(i, 2)).replace("DD", Vo(s, 2)).replace("HH", Vo(l, 2)).replace("mm", Vo(c, 2)).replace("ss", Vo(u, 2));
    o.push(d);
  }
  return o.length === 1 ? o[0] : o;
}
function Vo(e16, t10) {
  let n = `${e16}`;
  for (; n.length < t10; )
    n = `0${n}`;
  return n;
}
var tg = class {
  constructor() {
    mr(this, "events");
    this.events = /* @__PURE__ */ new Map();
  }
  on(t10, n, o) {
    const r = this.events.get(n);
    if (!r) {
      this.events.set(n, { [t10]: o });
      return;
    }
    r[t10] || (r[t10] = o);
  }
  emit(t10, n, ...o) {
    var a;
    const r = (a = this.events.get(n)) == null ? void 0 : a[t10];
    typeof r == "function" && r.call(null, ...o);
  }
  remove(t10, n) {
    const o = this.events.get(n);
    o && (o[t10] && delete o[t10], Object.keys(o).length === 0 && this.events.delete(n));
  }
};
var Hi = "data-observer-key";
var ng = class {
  constructor() {
    mr(this, "resizeObserver");
    mr(this, "actions");
    this.actions = {}, typeof ResizeObserver < "u" ? this.resizeObserver = new ResizeObserver((t10) => {
      t10.forEach((n) => {
        const r = n.target.getAttribute(Hi);
        r && this.actions[r] && this.actions[r](n);
      });
    }) : this.resizeObserver = null;
  }
  observe(t10, n) {
    var r;
    if (!(t10 instanceof HTMLElement) && !(t10 instanceof Element))
      return;
    const o = t10.getAttribute(Hi) ?? "";
    this.actions[o] = n, (r = this.resizeObserver) == null || r.observe(t10);
  }
  unobserve(t10) {
    var o;
    if (!(t10 instanceof HTMLElement) && !(t10 instanceof Element))
      return;
    const n = t10.getAttribute(Hi) ?? "";
    delete this.actions[n], (o = this.resizeObserver) == null || o.unobserve(t10);
  }
};
var og = (e16) => {
  const t10 = /* @__PURE__ */ Object.create(null);
  return (n) => {
    const o = t10[n];
    return o || (t10[n] = e16(n), t10[n]);
  };
};
var ag = /-(\w)/g;
var Td = og((e16) => e16.replace(ag, (t10, n) => n ? n.toUpperCase() : ""));
var rg = Symbol("skipFlatten");
var jr = (e16 = [], t10 = true) => {
  const n = Array.isArray(e16) ? e16 : [e16], o = [];
  return n.forEach((r) => {
    Array.isArray(r) ? o.push(...jr(r, t10)) : r && r.type === Fragment ? r.key === rg ? o.push(r) : o.push(...jr(r.children, t10)) : r && isVNode(r) ? t10 && !ig(r) ? o.push(r) : t10 || o.push(r) : vd(r) && o.push(r);
  }), o;
};
function ig(e16) {
  return e16 && (e16.type === Comment || e16.type === Fragment && e16.children.length === 0 || e16.type === Text && e16.children.trim() === "");
}
function Cd(e16) {
  return Array.isArray(e16) && e16.length === 1 && (e16 = e16[0]), e16 && e16.__v_isVNode && typeof e16.type != "symbol";
}
var kd = (e16, t10) => {
  if (typeof e16 == "number") {
    if (t10 === 3)
      return {
        mode: "rgb",
        r: (e16 >> 8 & 15 | e16 >> 4 & 240) / 255,
        g: (e16 >> 4 & 15 | e16 & 240) / 255,
        b: (e16 & 15 | e16 << 4 & 240) / 255
      };
    if (t10 === 4)
      return {
        mode: "rgb",
        r: (e16 >> 12 & 15 | e16 >> 8 & 240) / 255,
        g: (e16 >> 8 & 15 | e16 >> 4 & 240) / 255,
        b: (e16 >> 4 & 15 | e16 & 240) / 255,
        alpha: (e16 & 15 | e16 << 4 & 240) / 255
      };
    if (t10 === 6)
      return {
        mode: "rgb",
        r: (e16 >> 16 & 255) / 255,
        g: (e16 >> 8 & 255) / 255,
        b: (e16 & 255) / 255
      };
    if (t10 === 8)
      return {
        mode: "rgb",
        r: (e16 >> 24 & 255) / 255,
        g: (e16 >> 16 & 255) / 255,
        b: (e16 >> 8 & 255) / 255,
        alpha: (e16 & 255) / 255
      };
  }
};
var sg = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  // Added in CSS Colors Level 4:
  // https://drafts.csswg.org/css-color/#changes-from-3
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var lg = (e16) => kd(sg[e16.toLowerCase()], 6);
var cg = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
var ug = (e16) => {
  let t10;
  return (t10 = e16.match(cg)) ? kd(parseInt(t10[1], 16), t10[1].length) : void 0;
};
var Yn = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)";
var Pa = `${Yn}%`;
var Ll = `(?:${Yn}%|${Yn})`;
var dg = `(?:${Yn}(deg|grad|rad|turn)|${Yn})`;
var ua = "\\s*,\\s*";
var fg = new RegExp(
  `^rgba?\\(\\s*${Yn}${ua}${Yn}${ua}${Yn}\\s*(?:,\\s*${Ll}\\s*)?\\)$`
);
var mg = new RegExp(
  `^rgba?\\(\\s*${Pa}${ua}${Pa}${ua}${Pa}\\s*(?:,\\s*${Ll}\\s*)?\\)$`
);
var pg = (e16) => {
  let t10 = { mode: "rgb" }, n;
  if (n = e16.match(fg))
    n[1] !== void 0 && (t10.r = n[1] / 255), n[2] !== void 0 && (t10.g = n[2] / 255), n[3] !== void 0 && (t10.b = n[3] / 255);
  else if (n = e16.match(mg))
    n[1] !== void 0 && (t10.r = n[1] / 100), n[2] !== void 0 && (t10.g = n[2] / 100), n[3] !== void 0 && (t10.b = n[3] / 100);
  else
    return;
  return n[4] !== void 0 ? t10.alpha = Math.max(0, Math.min(1, n[4] / 100)) : n[5] !== void 0 && (t10.alpha = Math.max(0, Math.min(1, +n[5]))), t10;
};
var hg = (e16, t10) => e16 === void 0 ? void 0 : typeof e16 != "object" ? $d(e16) : e16.mode !== void 0 ? e16 : t10 ? { ...e16, mode: t10 } : void 0;
var Os = (e16 = "rgb") => (t10) => (t10 = hg(t10, e16)) !== void 0 ? (
  // if the color's mode corresponds to our target mode
  t10.mode === e16 ? (
    // then just return the color
    t10
  ) : (
    // otherwise check to see if we have a dedicated
    // converter for the target mode
    wn[t10.mode][e16] ? (
      // and return its result...
      wn[t10.mode][e16](t10)
    ) : (
      // ...otherwise pass through RGB as an intermediary step.
      // if the target mode is RGB...
      e16 === "rgb" ? (
        // just return the RGB
        wn[t10.mode].rgb(t10)
      ) : (
        // otherwise convert color.mode -> RGB -> target_mode
        wn.rgb[e16](wn[t10.mode].rgb(t10))
      )
    )
  )
) : void 0;
var wn = {};
var Sd = {};
var Or = [];
var Nd = {};
var gg = (e16) => e16;
var Ge = (e16) => (wn[e16.mode] = {
  ...wn[e16.mode],
  ...e16.toMode
}, Object.keys(e16.fromMode || {}).forEach((t10) => {
  wn[t10] || (wn[t10] = {}), wn[t10][e16.mode] = e16.fromMode[t10];
}), e16.ranges || (e16.ranges = {}), e16.difference || (e16.difference = {}), e16.channels.forEach((t10) => {
  if (e16.ranges[t10] === void 0 && (e16.ranges[t10] = [0, 1]), !e16.interpolate[t10])
    throw new Error(`Missing interpolator for: ${t10}`);
  typeof e16.interpolate[t10] == "function" && (e16.interpolate[t10] = {
    use: e16.interpolate[t10]
  }), e16.interpolate[t10].fixup || (e16.interpolate[t10].fixup = gg);
}), Sd[e16.mode] = e16, (e16.parse || []).forEach((t10) => {
  yg(t10, e16.mode);
}), Os(e16.mode));
var vg = (e16) => Sd[e16];
var yg = (e16, t10) => {
  if (typeof e16 == "string") {
    if (!t10)
      throw new Error("'mode' required when 'parser' is a string");
    Nd[e16] = t10;
  } else typeof e16 == "function" && Or.indexOf(e16) < 0 && Or.push(e16);
};
var Bs = /[^\x00-\x7F]|[a-zA-Z_]/;
var bg = /[^\x00-\x7F]|[-\w]/;
var ce = {
  Function: "function",
  Ident: "ident",
  Number: "number",
  Percentage: "percentage",
  ParenClose: ")",
  None: "none",
  Hue: "hue",
  Alpha: "alpha"
};
var Se = 0;
function gr(e16) {
  let t10 = e16[Se], n = e16[Se + 1];
  return t10 === "-" || t10 === "+" ? /\d/.test(n) || n === "." && /\d/.test(e16[Se + 2]) : t10 === "." ? /\d/.test(n) : /\d/.test(t10);
}
function Zs(e16) {
  if (Se >= e16.length)
    return false;
  let t10 = e16[Se];
  if (Bs.test(t10))
    return true;
  if (t10 === "-") {
    if (e16.length - Se < 2)
      return false;
    let n = e16[Se + 1];
    return !!(n === "-" || Bs.test(n));
  }
  return false;
}
var _g = {
  deg: 1,
  rad: 180 / Math.PI,
  grad: 9 / 10,
  turn: 360
};
function Ma(e16) {
  let t10 = "";
  if ((e16[Se] === "-" || e16[Se] === "+") && (t10 += e16[Se++]), t10 += vr(e16), e16[Se] === "." && /\d/.test(e16[Se + 1]) && (t10 += e16[Se++] + vr(e16)), (e16[Se] === "e" || e16[Se] === "E") && ((e16[Se + 1] === "-" || e16[Se + 1] === "+") && /\d/.test(e16[Se + 2]) ? t10 += e16[Se++] + e16[Se++] + vr(e16) : /\d/.test(e16[Se + 1]) && (t10 += e16[Se++] + vr(e16))), Zs(e16)) {
    let n = Br(e16);
    return n === "deg" || n === "rad" || n === "turn" || n === "grad" ? { type: ce.Hue, value: t10 * _g[n] } : void 0;
  }
  return e16[Se] === "%" ? (Se++, { type: ce.Percentage, value: +t10 }) : { type: ce.Number, value: +t10 };
}
function vr(e16) {
  let t10 = "";
  for (; /\d/.test(e16[Se]); )
    t10 += e16[Se++];
  return t10;
}
function Br(e16) {
  let t10 = "";
  for (; Se < e16.length && bg.test(e16[Se]); )
    t10 += e16[Se++];
  return t10;
}
function wg(e16) {
  let t10 = Br(e16);
  return e16[Se] === "(" ? (Se++, { type: ce.Function, value: t10 }) : t10 === "none" ? { type: ce.None, value: void 0 } : { type: ce.Ident, value: t10 };
}
function Tg(e16 = "") {
  let t10 = e16.trim(), n = [], o;
  for (Se = 0; Se < t10.length; ) {
    if (o = t10[Se++], o === `
` || o === "	" || o === " ") {
      for (; Se < t10.length && (t10[Se] === `
` || t10[Se] === "	" || t10[Se] === " "); )
        Se++;
      continue;
    }
    if (o === ",")
      return;
    if (o === ")") {
      n.push({ type: ce.ParenClose });
      continue;
    }
    if (o === "+") {
      if (Se--, gr(t10)) {
        n.push(Ma(t10));
        continue;
      }
      return;
    }
    if (o === "-") {
      if (Se--, gr(t10)) {
        n.push(Ma(t10));
        continue;
      }
      if (Zs(t10)) {
        n.push({ type: ce.Ident, value: Br(t10) });
        continue;
      }
      return;
    }
    if (o === ".") {
      if (Se--, gr(t10)) {
        n.push(Ma(t10));
        continue;
      }
      return;
    }
    if (o === "/") {
      for (; Se < t10.length && (t10[Se] === `
` || t10[Se] === "	" || t10[Se] === " "); )
        Se++;
      let r;
      if (gr(t10) && (r = Ma(t10), r.type !== ce.Hue)) {
        n.push({ type: ce.Alpha, value: r });
        continue;
      }
      if (Zs(t10) && Br(t10) === "none") {
        n.push({
          type: ce.Alpha,
          value: { type: ce.None, value: void 0 }
        });
        continue;
      }
      return;
    }
    if (/\d/.test(o)) {
      Se--, n.push(Ma(t10));
      continue;
    }
    if (Bs.test(o)) {
      Se--, n.push(wg(t10));
      continue;
    }
    return;
  }
  return n;
}
function Cg(e16) {
  e16._i = 0;
  let t10 = e16[e16._i++];
  if (!t10 || t10.type !== ce.Function || t10.value !== "color" || (t10 = e16[e16._i++], t10.type !== ce.Ident))
    return;
  const n = Nd[t10.value];
  if (!n)
    return;
  const o = { mode: n }, r = Md(e16, false);
  if (!r)
    return;
  const a = vg(n).channels;
  for (let i = 0, s, l; i < a.length; i++)
    s = r[i], l = a[i], s.type !== ce.None && (o[l] = s.type === ce.Number ? s.value : s.value / 100, l === "alpha" && (o[l] = Math.max(0, Math.min(1, o[l]))));
  return o;
}
function Md(e16, t10) {
  const n = [];
  let o;
  for (; e16._i < e16.length; ) {
    if (o = e16[e16._i++], o.type === ce.None || o.type === ce.Number || o.type === ce.Alpha || o.type === ce.Percentage || t10 && o.type === ce.Hue) {
      n.push(o);
      continue;
    }
    if (o.type === ce.ParenClose) {
      if (e16._i < e16.length)
        return;
      continue;
    }
    return;
  }
  if (!(n.length < 3 || n.length > 4)) {
    if (n.length === 4) {
      if (n[3].type !== ce.Alpha)
        return;
      n[3] = n[3].value;
    }
    return n.length === 3 && n.push({ type: ce.None, value: void 0 }), n.every((r) => r.type !== ce.Alpha) ? n : void 0;
  }
}
function kg(e16, t10) {
  e16._i = 0;
  let n = e16[e16._i++];
  if (!n || n.type !== ce.Function)
    return;
  let o = Md(e16, t10);
  if (o)
    return o.unshift(n.value), o;
}
var $d = (e16) => {
  if (typeof e16 != "string")
    return;
  const t10 = Tg(e16), n = t10 ? kg(t10, true) : void 0;
  let o, r = 0, a = Or.length;
  for (; r < a; )
    if ((o = Or[r++](e16, n)) !== void 0)
      return o;
  return t10 ? Cg(t10) : void 0;
};
function Sg(e16, t10) {
  if (!t10 || t10[0] !== "rgb" && t10[0] !== "rgba")
    return;
  const n = { mode: "rgb" }, [, o, r, a, i] = t10;
  if (!(o.type === ce.Hue || r.type === ce.Hue || a.type === ce.Hue))
    return o.type !== ce.None && (n.r = o.type === ce.Number ? o.value / 255 : o.value / 100), r.type !== ce.None && (n.g = r.type === ce.Number ? r.value / 255 : r.value / 100), a.type !== ce.None && (n.b = a.type === ce.Number ? a.value / 255 : a.value / 100), i.type !== ce.None && (n.alpha = Math.min(
      1,
      Math.max(
        0,
        i.type === ce.Number ? i.value : i.value / 100
      )
    )), n;
}
var Ng = (e16) => e16 === "transparent" ? { mode: "rgb", r: 0, g: 0, b: 0, alpha: 0 } : void 0;
var Mg = (e16, t10, n) => e16 + n * (t10 - e16);
var $g = (e16) => {
  let t10 = [];
  for (let n = 0; n < e16.length - 1; n++) {
    let o = e16[n], r = e16[n + 1];
    o === void 0 && r === void 0 ? t10.push(void 0) : o !== void 0 && r !== void 0 ? t10.push([o, r]) : t10.push(o !== void 0 ? [o, o] : [r, r]);
  }
  return t10;
};
var xg = (e16) => (t10) => {
  let n = $g(t10);
  return (o) => {
    let r = o * n.length, a = o >= 1 ? n.length - 1 : Math.max(Math.floor(r), 0), i = n[a];
    return i === void 0 ? void 0 : e16(i[0], i[1], r - a);
  };
};
var ve = xg(Mg);
var Mt = (e16) => {
  let t10 = false, n = e16.map((o) => o !== void 0 ? (t10 = true, o) : 1);
  return t10 ? n : e16;
};
var ga = {
  mode: "rgb",
  channels: ["r", "g", "b", "alpha"],
  parse: [
    Sg,
    ug,
    pg,
    lg,
    Ng,
    "srgb"
  ],
  serialize: "srgb",
  interpolate: {
    r: ve,
    g: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  },
  gamut: true,
  white: { r: 1, g: 1, b: 1 },
  black: { r: 0, g: 0, b: 0 }
};
var Ui = (e16 = 0) => Math.pow(Math.abs(e16), 563 / 256) * Math.sign(e16);
var Lc = (e16) => {
  let t10 = Ui(e16.r), n = Ui(e16.g), o = Ui(e16.b), r = {
    mode: "xyz65",
    x: 0.5766690429101305 * t10 + 0.1855582379065463 * n + 0.1882286462349947 * o,
    y: 0.297344975250536 * t10 + 0.6273635662554661 * n + 0.0752914584939979 * o,
    z: 0.0270313613864123 * t10 + 0.0706888525358272 * n + 0.9913375368376386 * o
  };
  return e16.alpha !== void 0 && (r.alpha = e16.alpha), r;
};
var Gi = (e16) => Math.pow(Math.abs(e16), 256 / 563) * Math.sign(e16);
var Fc = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = {
    mode: "a98",
    r: Gi(
      e16 * 2.0415879038107465 - t10 * 0.5650069742788597 - 0.3447313507783297 * n
    ),
    g: Gi(
      e16 * -0.9692436362808798 + t10 * 1.8759675015077206 + 0.0415550574071756 * n
    ),
    b: Gi(
      e16 * 0.0134442806320312 - t10 * 0.1183623922310184 + 1.0151749943912058 * n
    )
  };
  return o !== void 0 && (r.alpha = o), r;
};
var Xi = (e16 = 0) => {
  const t10 = Math.abs(e16);
  return t10 <= 0.04045 ? e16 / 12.92 : (Math.sign(e16) || 1) * Math.pow((t10 + 0.055) / 1.055, 2.4);
};
var va = ({ r: e16, g: t10, b: n, alpha: o }) => {
  let r = {
    mode: "lrgb",
    r: Xi(e16),
    g: Xi(t10),
    b: Xi(n)
  };
  return o !== void 0 && (r.alpha = o), r;
};
var Ko = (e16) => {
  let { r: t10, g: n, b: o, alpha: r } = va(e16), a = {
    mode: "xyz65",
    x: 0.4123907992659593 * t10 + 0.357584339383878 * n + 0.1804807884018343 * o,
    y: 0.2126390058715102 * t10 + 0.715168678767756 * n + 0.0721923153607337 * o,
    z: 0.0193308187155918 * t10 + 0.119194779794626 * n + 0.9505321522496607 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var Yi = (e16 = 0) => {
  const t10 = Math.abs(e16);
  return t10 > 31308e-7 ? (Math.sign(e16) || 1) * (1.055 * Math.pow(t10, 1 / 2.4) - 0.055) : e16 * 12.92;
};
var ya = ({ r: e16, g: t10, b: n, alpha: o }, r = "rgb") => {
  let a = {
    mode: r,
    r: Yi(e16),
    g: Yi(t10),
    b: Yi(n)
  };
  return o !== void 0 && (a.alpha = o), a;
};
var zo = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = ya({
    r: e16 * 3.2409699419045226 - t10 * 1.537383177570094 - 0.4986107602930034 * n,
    g: e16 * -0.9692436362808796 + t10 * 1.8759675015077204 + 0.0415550574071756 * n,
    b: e16 * 0.0556300796969936 - t10 * 0.2039769588889765 + 1.0569715142428784 * n
  });
  return o !== void 0 && (r.alpha = o), r;
};
var Ig = {
  ...ga,
  mode: "a98",
  parse: ["a98-rgb"],
  serialize: "a98-rgb",
  fromMode: {
    rgb: (e16) => Fc(Ko(e16)),
    xyz65: Fc
  },
  toMode: {
    rgb: (e16) => zo(Lc(e16)),
    xyz65: Lc
  }
};
var At = (e16) => (e16 = e16 % 360) < 0 ? e16 + 360 : e16;
var Dg = (e16, t10) => e16.map((n, o, r) => {
  if (n === void 0)
    return n;
  let a = At(n);
  return o === 0 || e16[o - 1] === void 0 ? a : t10(a - At(r[o - 1]));
}).reduce((n, o) => !n.length || o === void 0 || n[n.length - 1] === void 0 ? (n.push(o), n) : (n.push(o + n[n.length - 1]), n), []);
var Fn = (e16) => Dg(e16, (t10) => Math.abs(t10) <= 180 ? t10 : t10 - 360 * Math.sign(t10));
var xt = [-0.14861, 1.78277, -0.29227, -0.90649, 1.97294, 0];
var Ag = Math.PI / 180;
var Eg = 180 / Math.PI;
var jc = xt[3] * xt[4];
var Oc = xt[1] * xt[4];
var Bc = xt[1] * xt[2] - xt[0] * xt[3];
var Kg = ({ r: e16, g: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = (Bc * n + e16 * jc - t10 * Oc) / (Bc + jc - Oc), a = n - r, i = (xt[4] * (t10 - r) - xt[2] * a) / xt[3], s = {
    mode: "cubehelix",
    l: r,
    s: r === 0 || r === 1 ? void 0 : Math.sqrt(a * a + i * i) / (xt[4] * r * (1 - r))
  };
  return s.s && (s.h = Math.atan2(i, a) * Eg - 120), o !== void 0 && (s.alpha = o), s;
};
var zg = ({ h: e16, s: t10, l: n, alpha: o }) => {
  let r = { mode: "rgb" };
  e16 = (e16 === void 0 ? 0 : e16 + 120) * Ag, n === void 0 && (n = 0);
  let a = t10 === void 0 ? 0 : t10 * n * (1 - n), i = Math.cos(e16), s = Math.sin(e16);
  return r.r = n + a * (xt[0] * i + xt[1] * s), r.g = n + a * (xt[2] * i + xt[3] * s), r.b = n + a * (xt[4] * i + xt[5] * s), o !== void 0 && (r.alpha = o), r;
};
var si = (e16, t10) => {
  if (e16.h === void 0 || t10.h === void 0 || !e16.s || !t10.s)
    return 0;
  let n = At(e16.h), o = At(t10.h), r = Math.sin((o - n + 360) / 2 * Math.PI / 180);
  return 2 * Math.sqrt(e16.s * t10.s) * r;
};
var Pg = (e16, t10) => {
  if (e16.h === void 0 || t10.h === void 0)
    return 0;
  let n = At(e16.h), o = At(t10.h);
  return Math.abs(o - n) > 180 ? n - (o - 360 * Math.sign(o - n)) : o - n;
};
var li = (e16, t10) => {
  if (e16.h === void 0 || t10.h === void 0 || !e16.c || !t10.c)
    return 0;
  let n = At(e16.h), o = At(t10.h), r = Math.sin((o - n + 360) / 2 * Math.PI / 180);
  return 2 * Math.sqrt(e16.c * t10.c) * r;
};
var jn = (e16) => {
  let t10 = e16.reduce(
    (o, r) => {
      if (r !== void 0) {
        let a = r * Math.PI / 180;
        o.sin += Math.sin(a), o.cos += Math.cos(a);
      }
      return o;
    },
    { sin: 0, cos: 0 }
  ), n = Math.atan2(t10.sin, t10.cos) * 180 / Math.PI;
  return n < 0 ? 360 + n : n;
};
var Rg = {
  mode: "cubehelix",
  channels: ["h", "s", "l", "alpha"],
  parse: ["--cubehelix"],
  serialize: "--cubehelix",
  ranges: {
    h: [0, 360],
    s: [0, 4.614],
    l: [0, 1]
  },
  fromMode: {
    rgb: Kg
  },
  toMode: {
    rgb: zg
  },
  interpolate: {
    h: {
      use: ve,
      fixup: Fn
    },
    s: ve,
    l: ve,
    alpha: {
      use: ve,
      fixup: Mt
    }
  },
  difference: {
    h: si
  },
  average: {
    h: jn
  }
};
var to = ({ l: e16, a: t10, b: n, alpha: o }, r = "lch") => {
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let a = Math.sqrt(t10 * t10 + n * n), i = { mode: r, l: e16, c: a };
  return a && (i.h = At(Math.atan2(n, t10) * 180 / Math.PI)), o !== void 0 && (i.alpha = o), i;
};
var no = ({ l: e16, c: t10, h: n, alpha: o }, r = "lab") => {
  n === void 0 && (n = 0);
  let a = {
    mode: r,
    l: e16,
    a: t10 ? t10 * Math.cos(n / 180 * Math.PI) : 0,
    b: t10 ? t10 * Math.sin(n / 180 * Math.PI) : 0
  };
  return o !== void 0 && (a.alpha = o), a;
};
var xd = Math.pow(29, 3) / Math.pow(3, 3);
var Id = Math.pow(6, 3) / Math.pow(29, 3);
var Ct = {
  X: 0.3457 / 0.3585,
  Y: 1,
  Z: (1 - 0.3457 - 0.3585) / 0.3585
};
var ta = {
  X: 0.3127 / 0.329,
  Y: 1,
  Z: (1 - 0.3127 - 0.329) / 0.329
};
var Qi = (e16) => Math.pow(e16, 3) > Id ? Math.pow(e16, 3) : (116 * e16 - 16) / xd;
var Dd = ({ l: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = (e16 + 16) / 116, a = t10 / 500 + r, i = r - n / 200, s = {
    mode: "xyz65",
    x: Qi(a) * ta.X,
    y: Qi(r) * ta.Y,
    z: Qi(i) * ta.Z
  };
  return o !== void 0 && (s.alpha = o), s;
};
var ci = (e16) => zo(Dd(e16));
var Ji = (e16) => e16 > Id ? Math.cbrt(e16) : (xd * e16 + 16) / 116;
var Ad = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Ji(e16 / ta.X), a = Ji(t10 / ta.Y), i = Ji(n / ta.Z), s = {
    mode: "lab65",
    l: 116 * a - 16,
    a: 500 * (r - a),
    b: 200 * (a - i)
  };
  return o !== void 0 && (s.alpha = o), s;
};
var ui = (e16) => {
  let t10 = Ad(Ko(e16));
  return e16.r === e16.b && e16.b === e16.g && (t10.a = t10.b = 0), t10;
};
var Zr = 1;
var Ed = 1;
var Va = 26 / 180 * Math.PI;
var Wr = Math.cos(Va);
var qr = Math.sin(Va);
var Kd = 100 / Math.log(139 / 100);
var Ws = ({ l: e16, c: t10, h: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = {
    mode: "lab65",
    l: (Math.exp(e16 * Zr / Kd) - 1) / 39e-4
  }, a = (Math.exp(0.0435 * t10 * Ed * Zr) - 1) / 0.075, i = a * Math.cos(n / 180 * Math.PI - Va), s = a * Math.sin(n / 180 * Math.PI - Va);
  return r.a = i * Wr - s / 0.83 * qr, r.b = i * qr + s / 0.83 * Wr, o !== void 0 && (r.alpha = o), r;
};
var qs = ({ l: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = t10 * Wr + n * qr, a = 0.83 * (n * Wr - t10 * qr), i = Math.sqrt(r * r + a * a), s = {
    mode: "dlch",
    l: Kd / Zr * Math.log(1 + 39e-4 * e16),
    c: Math.log(1 + 0.075 * i) / (0.0435 * Ed * Zr)
  };
  return s.c && (s.h = At((Math.atan2(a, r) + Va) / Math.PI * 180)), o !== void 0 && (s.alpha = o), s;
};
var Zc = (e16) => Ws(to(e16, "dlch"));
var Wc = (e16) => no(qs(e16), "dlab");
var Lg = {
  mode: "dlab",
  parse: ["--din99o-lab"],
  serialize: "--din99o-lab",
  toMode: {
    lab65: Zc,
    rgb: (e16) => ci(Zc(e16))
  },
  fromMode: {
    lab65: Wc,
    rgb: (e16) => Wc(ui(e16))
  },
  channels: ["l", "a", "b", "alpha"],
  ranges: {
    l: [0, 100],
    a: [-40.09, 45.501],
    b: [-40.469, 44.344]
  },
  interpolate: {
    l: ve,
    a: ve,
    b: ve,
    alpha: {
      use: ve,
      fixup: Mt
    }
  }
};
var Fg = {
  mode: "dlch",
  parse: ["--din99o-lch"],
  serialize: "--din99o-lch",
  toMode: {
    lab65: Ws,
    dlab: (e16) => no(e16, "dlab"),
    rgb: (e16) => ci(Ws(e16))
  },
  fromMode: {
    lab65: qs,
    dlab: (e16) => to(e16, "dlch"),
    rgb: (e16) => qs(ui(e16))
  },
  channels: ["l", "c", "h", "alpha"],
  ranges: {
    l: [0, 100],
    c: [0, 51.484],
    h: [0, 360]
  },
  interpolate: {
    l: ve,
    c: ve,
    h: {
      use: ve,
      fixup: Fn
    },
    alpha: {
      use: ve,
      fixup: Mt
    }
  },
  difference: {
    h: li
  },
  average: {
    h: jn
  }
};
function jg({ h: e16, s: t10, i: n, alpha: o }) {
  e16 = At(e16 !== void 0 ? e16 : 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.abs(e16 / 60 % 2 - 1), a;
  switch (Math.floor(e16 / 60)) {
    case 0:
      a = {
        r: n * (1 + t10 * (3 / (2 - r) - 1)),
        g: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1)),
        b: n * (1 - t10)
      };
      break;
    case 1:
      a = {
        r: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1)),
        g: n * (1 + t10 * (3 / (2 - r) - 1)),
        b: n * (1 - t10)
      };
      break;
    case 2:
      a = {
        r: n * (1 - t10),
        g: n * (1 + t10 * (3 / (2 - r) - 1)),
        b: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1))
      };
      break;
    case 3:
      a = {
        r: n * (1 - t10),
        g: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1)),
        b: n * (1 + t10 * (3 / (2 - r) - 1))
      };
      break;
    case 4:
      a = {
        r: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1)),
        g: n * (1 - t10),
        b: n * (1 + t10 * (3 / (2 - r) - 1))
      };
      break;
    case 5:
      a = {
        r: n * (1 + t10 * (3 / (2 - r) - 1)),
        g: n * (1 - t10),
        b: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1))
      };
      break;
    default:
      a = { r: n * (1 - t10), g: n * (1 - t10), b: n * (1 - t10) };
  }
  return a.mode = "rgb", o !== void 0 && (a.alpha = o), a;
}
function Og({ r: e16, g: t10, b: n, alpha: o }) {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.max(e16, t10, n), a = Math.min(e16, t10, n), i = {
    mode: "hsi",
    s: e16 + t10 + n === 0 ? 0 : 1 - 3 * a / (e16 + t10 + n),
    i: (e16 + t10 + n) / 3
  };
  return r - a !== 0 && (i.h = (r === e16 ? (t10 - n) / (r - a) + (t10 < n) * 6 : r === t10 ? (n - e16) / (r - a) + 2 : (e16 - t10) / (r - a) + 4) * 60), o !== void 0 && (i.alpha = o), i;
}
var Bg = {
  mode: "hsi",
  toMode: {
    rgb: jg
  },
  parse: ["--hsi"],
  serialize: "--hsi",
  fromMode: {
    rgb: Og
  },
  channels: ["h", "s", "i", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  interpolate: {
    h: { use: ve, fixup: Fn },
    s: ve,
    i: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: si
  },
  average: {
    h: jn
  }
};
function Zg({ h: e16, s: t10, l: n, alpha: o }) {
  e16 = At(e16 !== void 0 ? e16 : 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = n + t10 * (n < 0.5 ? n : 1 - n), a = r - (r - n) * 2 * Math.abs(e16 / 60 % 2 - 1), i;
  switch (Math.floor(e16 / 60)) {
    case 0:
      i = { r, g: a, b: 2 * n - r };
      break;
    case 1:
      i = { r: a, g: r, b: 2 * n - r };
      break;
    case 2:
      i = { r: 2 * n - r, g: r, b: a };
      break;
    case 3:
      i = { r: 2 * n - r, g: a, b: r };
      break;
    case 4:
      i = { r: a, g: 2 * n - r, b: r };
      break;
    case 5:
      i = { r, g: 2 * n - r, b: a };
      break;
    default:
      i = { r: 2 * n - r, g: 2 * n - r, b: 2 * n - r };
  }
  return i.mode = "rgb", o !== void 0 && (i.alpha = o), i;
}
function Wg({ r: e16, g: t10, b: n, alpha: o }) {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.max(e16, t10, n), a = Math.min(e16, t10, n), i = {
    mode: "hsl",
    s: r === a ? 0 : (r - a) / (1 - Math.abs(r + a - 1)),
    l: 0.5 * (r + a)
  };
  return r - a !== 0 && (i.h = (r === e16 ? (t10 - n) / (r - a) + (t10 < n) * 6 : r === t10 ? (n - e16) / (r - a) + 2 : (e16 - t10) / (r - a) + 4) * 60), o !== void 0 && (i.alpha = o), i;
}
var qg = (e16, t10) => {
  switch (t10) {
    case "deg":
      return +e16;
    case "rad":
      return e16 / Math.PI * 180;
    case "grad":
      return e16 / 10 * 9;
    case "turn":
      return e16 * 360;
  }
};
var Vg = new RegExp(
  `^hsla?\\(\\s*${dg}${ua}${Pa}${ua}${Pa}\\s*(?:,\\s*${Ll}\\s*)?\\)$`
);
var Hg = (e16) => {
  let t10 = e16.match(Vg);
  if (!t10) return;
  let n = { mode: "hsl" };
  return t10[3] !== void 0 ? n.h = +t10[3] : t10[1] !== void 0 && t10[2] !== void 0 && (n.h = qg(t10[1], t10[2])), t10[4] !== void 0 && (n.s = Math.min(Math.max(0, t10[4] / 100), 1)), t10[5] !== void 0 && (n.l = Math.min(Math.max(0, t10[5] / 100), 1)), t10[6] !== void 0 ? n.alpha = Math.max(0, Math.min(1, t10[6] / 100)) : t10[7] !== void 0 && (n.alpha = Math.max(0, Math.min(1, +t10[7]))), n;
};
function Ug(e16, t10) {
  if (!t10 || t10[0] !== "hsl" && t10[0] !== "hsla")
    return;
  const n = { mode: "hsl" }, [, o, r, a, i] = t10;
  if (o.type !== ce.None) {
    if (o.type === ce.Percentage)
      return;
    n.h = o.value;
  }
  if (r.type !== ce.None) {
    if (r.type === ce.Hue)
      return;
    n.s = r.value / 100;
  }
  if (a.type !== ce.None) {
    if (a.type === ce.Hue)
      return;
    n.l = a.value / 100;
  }
  return i.type !== ce.None && (n.alpha = Math.min(
    1,
    Math.max(
      0,
      i.type === ce.Number ? i.value : i.value / 100
    )
  )), n;
}
var zd = {
  mode: "hsl",
  toMode: {
    rgb: Zg
  },
  fromMode: {
    rgb: Wg
  },
  channels: ["h", "s", "l", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  parse: [Ug, Hg],
  serialize: (e16) => `hsl(${e16.h !== void 0 ? e16.h : "none"} ${e16.s !== void 0 ? e16.s * 100 + "%" : "none"} ${e16.l !== void 0 ? e16.l * 100 + "%" : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  interpolate: {
    h: { use: ve, fixup: Fn },
    s: ve,
    l: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: si
  },
  average: {
    h: jn
  }
};
function Pd({ h: e16, s: t10, v: n, alpha: o }) {
  e16 = At(e16 !== void 0 ? e16 : 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.abs(e16 / 60 % 2 - 1), a;
  switch (Math.floor(e16 / 60)) {
    case 0:
      a = { r: n, g: n * (1 - t10 * r), b: n * (1 - t10) };
      break;
    case 1:
      a = { r: n * (1 - t10 * r), g: n, b: n * (1 - t10) };
      break;
    case 2:
      a = { r: n * (1 - t10), g: n, b: n * (1 - t10 * r) };
      break;
    case 3:
      a = { r: n * (1 - t10), g: n * (1 - t10 * r), b: n };
      break;
    case 4:
      a = { r: n * (1 - t10 * r), g: n * (1 - t10), b: n };
      break;
    case 5:
      a = { r: n, g: n * (1 - t10), b: n * (1 - t10 * r) };
      break;
    default:
      a = { r: n * (1 - t10), g: n * (1 - t10), b: n * (1 - t10) };
  }
  return a.mode = "rgb", o !== void 0 && (a.alpha = o), a;
}
function Rd({ r: e16, g: t10, b: n, alpha: o }) {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.max(e16, t10, n), a = Math.min(e16, t10, n), i = {
    mode: "hsv",
    s: r === 0 ? 0 : 1 - a / r,
    v: r
  };
  return r - a !== 0 && (i.h = (r === e16 ? (t10 - n) / (r - a) + (t10 < n) * 6 : r === t10 ? (n - e16) / (r - a) + 2 : (e16 - t10) / (r - a) + 4) * 60), o !== void 0 && (i.alpha = o), i;
}
var Ld = {
  mode: "hsv",
  toMode: {
    rgb: Pd
  },
  parse: ["--hsv"],
  serialize: "--hsv",
  fromMode: {
    rgb: Rd
  },
  channels: ["h", "s", "v", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  interpolate: {
    h: { use: ve, fixup: Fn },
    s: ve,
    v: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: si
  },
  average: {
    h: jn
  }
};
function Gg({ h: e16, w: t10, b: n, alpha: o }) {
  if (t10 === void 0 && (t10 = 0), n === void 0 && (n = 0), t10 + n > 1) {
    let r = t10 + n;
    t10 /= r, n /= r;
  }
  return Pd({
    h: e16,
    s: n === 1 ? 1 : 1 - t10 / (1 - n),
    v: 1 - n,
    alpha: o
  });
}
function Xg(e16) {
  let t10 = Rd(e16);
  if (t10 === void 0) return;
  let n = t10.s !== void 0 ? t10.s : 0, o = t10.v !== void 0 ? t10.v : 0, r = {
    mode: "hwb",
    w: (1 - n) * o,
    b: 1 - o
  };
  return t10.h !== void 0 && (r.h = t10.h), t10.alpha !== void 0 && (r.alpha = t10.alpha), r;
}
function Yg(e16, t10) {
  if (!t10 || t10[0] !== "hwb")
    return;
  const n = { mode: "hwb" }, [, o, r, a, i] = t10;
  if (o.type !== ce.None) {
    if (o.type === ce.Percentage)
      return;
    n.h = o.value;
  }
  if (r.type !== ce.None) {
    if (r.type === ce.Hue)
      return;
    n.w = r.value / 100;
  }
  if (a.type !== ce.None) {
    if (a.type === ce.Hue)
      return;
    n.b = a.value / 100;
  }
  return i.type !== ce.None && (n.alpha = Math.min(
    1,
    Math.max(
      0,
      i.type === ce.Number ? i.value : i.value / 100
    )
  )), n;
}
var Qg = {
  mode: "hwb",
  toMode: {
    rgb: Gg
  },
  fromMode: {
    rgb: Xg
  },
  channels: ["h", "w", "b", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  parse: [Yg],
  serialize: (e16) => `hwb(${e16.h !== void 0 ? e16.h : "none"} ${e16.w !== void 0 ? e16.w * 100 + "%" : "none"} ${e16.b !== void 0 ? e16.b * 100 + "%" : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  interpolate: {
    h: { use: ve, fixup: Fn },
    w: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: Pg
  },
  average: {
    h: jn
  }
};
var Fd = 203;
var di = 0.1593017578125;
var jd = 78.84375;
var fi = 0.8359375;
var mi = 18.8515625;
var pi = 18.6875;
function es(e16) {
  if (e16 < 0) return 0;
  const t10 = Math.pow(e16, 1 / jd);
  return 1e4 * Math.pow(Math.max(0, t10 - fi) / (mi - pi * t10), 1 / di);
}
function ts(e16) {
  if (e16 < 0) return 0;
  const t10 = Math.pow(e16 / 1e4, di);
  return Math.pow((fi + mi * t10) / (1 + pi * t10), jd);
}
var ns = (e16) => Math.max(e16 / Fd, 0);
var qc = ({ i: e16, t: t10, p: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  const r = es(
    e16 + 0.008609037037932761 * t10 + 0.11102962500302593 * n
  ), a = es(
    e16 - 0.00860903703793275 * t10 - 0.11102962500302599 * n
  ), i = es(
    e16 + 0.5600313357106791 * t10 - 0.32062717498731885 * n
  ), s = {
    mode: "xyz65",
    x: ns(
      2.070152218389422 * r - 1.3263473389671556 * a + 0.2066510476294051 * i
    ),
    y: ns(
      0.3647385209748074 * r + 0.680566024947227 * a - 0.0453045459220346 * i
    ),
    z: ns(
      -0.049747207535812 * r - 0.0492609666966138 * a + 1.1880659249923042 * i
    )
  };
  return o !== void 0 && (s.alpha = o), s;
};
var os = (e16 = 0) => Math.max(e16 * Fd, 0);
var Vc = ({ x: e16, y: t10, z: n, alpha: o }) => {
  const r = os(e16), a = os(t10), i = os(n), s = ts(
    0.3592832590121217 * r + 0.6976051147779502 * a - 0.0358915932320289 * i
  ), l = ts(
    -0.1920808463704995 * r + 1.1004767970374323 * a + 0.0753748658519118 * i
  ), c = ts(
    0.0070797844607477 * r + 0.0748396662186366 * a + 0.8433265453898765 * i
  ), u = 0.5 * s + 0.5 * l, d = 1.61376953125 * s - 3.323486328125 * l + 1.709716796875 * c, m = 4.378173828125 * s - 4.24560546875 * l - 0.132568359375 * c, p = { mode: "itp", i: u, t: d, p: m };
  return o !== void 0 && (p.alpha = o), p;
};
var Jg = {
  mode: "itp",
  channels: ["i", "t", "p", "alpha"],
  parse: ["--ictcp"],
  serialize: "--ictcp",
  toMode: {
    xyz65: qc,
    rgb: (e16) => zo(qc(e16))
  },
  fromMode: {
    xyz65: Vc,
    rgb: (e16) => Vc(Ko(e16))
  },
  ranges: {
    i: [0, 0.581],
    t: [-0.369, 0.272],
    p: [-0.164, 0.331]
  },
  interpolate: {
    i: ve,
    t: ve,
    p: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var e22 = 134.03437499999998;
var t2 = 16295499532821565e-27;
var as = (e16) => {
  if (e16 < 0) return 0;
  let t10 = Math.pow(e16 / 1e4, di);
  return Math.pow((fi + mi * t10) / (1 + pi * t10), e22);
};
var rs = (e16 = 0) => Math.max(e16 * 203, 0);
var Od = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 = rs(e16), t10 = rs(t10), n = rs(n);
  let r = 1.15 * e16 - 0.15 * n, a = 0.66 * t10 + 0.34 * e16, i = as(0.41478972 * r + 0.579999 * a + 0.014648 * n), s = as(-0.20151 * r + 1.120649 * a + 0.0531008 * n), l = as(-0.0166008 * r + 0.2648 * a + 0.6684799 * n), c = (i + s) / 2, u = {
    mode: "jab",
    j: 0.44 * c / (1 - 0.56 * c) - t2,
    a: 3.524 * i - 4.066708 * s + 0.542708 * l,
    b: 0.199076 * i + 1.096799 * s - 1.295875 * l
  };
  return o !== void 0 && (u.alpha = o), u;
};
var n2 = 134.03437499999998;
var Hc = 16295499532821565e-27;
var is2 = (e16) => {
  if (e16 < 0) return 0;
  let t10 = Math.pow(e16, 1 / n2);
  return 1e4 * Math.pow((fi - t10) / (pi * t10 - mi), 1 / di);
};
var ss = (e16) => e16 / 203;
var Bd = ({ j: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = (e16 + Hc) / (0.44 + 0.56 * (e16 + Hc)), a = is2(r + 0.13860504 * t10 + 0.058047316 * n), i = is2(r - 0.13860504 * t10 - 0.058047316 * n), s = is2(r - 0.096019242 * t10 - 0.8118919 * n), l = {
    mode: "xyz65",
    x: ss(
      1.661373024652174 * a - 0.914523081304348 * i + 0.23136208173913045 * s
    ),
    y: ss(
      -0.3250758611844533 * a + 1.571847026732543 * i - 0.21825383453227928 * s
    ),
    z: ss(-0.090982811 * a - 0.31272829 * i + 1.5227666 * s)
  };
  return o !== void 0 && (l.alpha = o), l;
};
var Zd = (e16) => {
  let t10 = Od(Ko(e16));
  return e16.r === e16.b && e16.b === e16.g && (t10.a = t10.b = 0), t10;
};
var Wd = (e16) => zo(Bd(e16));
var o2 = {
  mode: "jab",
  channels: ["j", "a", "b", "alpha"],
  parse: ["--jzazbz"],
  serialize: "--jzazbz",
  fromMode: {
    rgb: Zd,
    xyz65: Od
  },
  toMode: {
    rgb: Wd,
    xyz65: Bd
  },
  ranges: {
    j: [0, 0.222],
    a: [-0.109, 0.129],
    b: [-0.185, 0.134]
  },
  interpolate: {
    j: ve,
    a: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var Uc = ({ j: e16, a: t10, b: n, alpha: o }) => {
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.sqrt(t10 * t10 + n * n), a = {
    mode: "jch",
    j: e16,
    c: r
  };
  return r && (a.h = At(Math.atan2(n, t10) * 180 / Math.PI)), o !== void 0 && (a.alpha = o), a;
};
var Gc = ({ j: e16, c: t10, h: n, alpha: o }) => {
  n === void 0 && (n = 0);
  let r = {
    mode: "jab",
    j: e16,
    a: t10 ? t10 * Math.cos(n / 180 * Math.PI) : 0,
    b: t10 ? t10 * Math.sin(n / 180 * Math.PI) : 0
  };
  return o !== void 0 && (r.alpha = o), r;
};
var a2 = {
  mode: "jch",
  parse: ["--jzczhz"],
  serialize: "--jzczhz",
  toMode: {
    jab: Gc,
    rgb: (e16) => Wd(Gc(e16))
  },
  fromMode: {
    rgb: (e16) => Uc(Zd(e16)),
    jab: Uc
  },
  channels: ["j", "c", "h", "alpha"],
  ranges: {
    j: [0, 0.221],
    c: [0, 0.19],
    h: [0, 360]
  },
  interpolate: {
    h: { use: ve, fixup: Fn },
    c: ve,
    j: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: li
  },
  average: {
    h: jn
  }
};
var hi = Math.pow(29, 3) / Math.pow(3, 3);
var Fl = Math.pow(6, 3) / Math.pow(29, 3);
var ls = (e16) => Math.pow(e16, 3) > Fl ? Math.pow(e16, 3) : (116 * e16 - 16) / hi;
var jl = ({ l: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = (e16 + 16) / 116, a = t10 / 500 + r, i = r - n / 200, s = {
    mode: "xyz50",
    x: ls(a) * Ct.X,
    y: ls(r) * Ct.Y,
    z: ls(i) * Ct.Z
  };
  return o !== void 0 && (s.alpha = o), s;
};
var tr = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = ya({
    r: e16 * 3.1341359569958707 - t10 * 1.6173863321612538 - 0.4906619460083532 * n,
    g: e16 * -0.978795502912089 + t10 * 1.916254567259524 + 0.03344273116131949 * n,
    b: e16 * 0.07195537988411677 - t10 * 0.2289768264158322 + 1.405386058324125 * n
  });
  return o !== void 0 && (r.alpha = o), r;
};
var qd = (e16) => tr(jl(e16));
var nr = (e16) => {
  let { r: t10, g: n, b: o, alpha: r } = va(e16), a = {
    mode: "xyz50",
    x: 0.436065742824811 * t10 + 0.3851514688337912 * n + 0.14307845442264197 * o,
    y: 0.22249319175623702 * t10 + 0.7168870538238823 * n + 0.06061979053616537 * o,
    z: 0.013923904500943465 * t10 + 0.09708128566574634 * n + 0.7140993584005155 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var cs = (e16) => e16 > Fl ? Math.cbrt(e16) : (hi * e16 + 16) / 116;
var Ol = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = cs(e16 / Ct.X), a = cs(t10 / Ct.Y), i = cs(n / Ct.Z), s = {
    mode: "lab",
    l: 116 * a - 16,
    a: 500 * (r - a),
    b: 200 * (a - i)
  };
  return o !== void 0 && (s.alpha = o), s;
};
var Vd = (e16) => {
  let t10 = Ol(nr(e16));
  return e16.r === e16.b && e16.b === e16.g && (t10.a = t10.b = 0), t10;
};
function r2(e16, t10) {
  if (!t10 || t10[0] !== "lab")
    return;
  const n = { mode: "lab" }, [, o, r, a, i] = t10;
  if (!(o.type === ce.Hue || r.type === ce.Hue || a.type === ce.Hue))
    return o.type !== ce.None && (n.l = Math.min(Math.max(0, o.value), 100)), r.type !== ce.None && (n.a = r.type === ce.Number ? r.value : r.value * 125 / 100), a.type !== ce.None && (n.b = a.type === ce.Number ? a.value : a.value * 125 / 100), i.type !== ce.None && (n.alpha = Math.min(
      1,
      Math.max(
        0,
        i.type === ce.Number ? i.value : i.value / 100
      )
    )), n;
}
var Bl = {
  mode: "lab",
  toMode: {
    xyz50: jl,
    rgb: qd
  },
  fromMode: {
    xyz50: Ol,
    rgb: Vd
  },
  channels: ["l", "a", "b", "alpha"],
  ranges: {
    l: [0, 100],
    a: [-100, 100],
    b: [-100, 100]
  },
  parse: [r2],
  serialize: (e16) => `lab(${e16.l !== void 0 ? e16.l : "none"} ${e16.a !== void 0 ? e16.a : "none"} ${e16.b !== void 0 ? e16.b : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  interpolate: {
    l: ve,
    a: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var i2 = {
  ...Bl,
  mode: "lab65",
  parse: ["--lab-d65"],
  serialize: "--lab-d65",
  toMode: {
    xyz65: Dd,
    rgb: ci
  },
  fromMode: {
    xyz65: Ad,
    rgb: ui
  },
  ranges: {
    l: [0, 100],
    a: [-86.182, 98.234],
    b: [-107.86, 94.477]
  }
};
function s2(e16, t10) {
  if (!t10 || t10[0] !== "lch")
    return;
  const n = { mode: "lch" }, [, o, r, a, i] = t10;
  if (o.type !== ce.None) {
    if (o.type === ce.Hue)
      return;
    n.l = Math.min(Math.max(0, o.value), 100);
  }
  if (r.type !== ce.None && (n.c = Math.max(
    0,
    r.type === ce.Number ? r.value : r.value * 150 / 100
  )), a.type !== ce.None) {
    if (a.type === ce.Percentage)
      return;
    n.h = a.value;
  }
  return i.type !== ce.None && (n.alpha = Math.min(
    1,
    Math.max(
      0,
      i.type === ce.Number ? i.value : i.value / 100
    )
  )), n;
}
var Zl = {
  mode: "lch",
  toMode: {
    lab: no,
    rgb: (e16) => qd(no(e16))
  },
  fromMode: {
    rgb: (e16) => to(Vd(e16)),
    lab: to
  },
  channels: ["l", "c", "h", "alpha"],
  ranges: {
    l: [0, 100],
    c: [0, 150],
    h: [0, 360]
  },
  parse: [s2],
  serialize: (e16) => `lch(${e16.l !== void 0 ? e16.l : "none"} ${e16.c !== void 0 ? e16.c : "none"} ${e16.h !== void 0 ? e16.h : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  interpolate: {
    h: { use: ve, fixup: Fn },
    c: ve,
    l: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: li
  },
  average: {
    h: jn
  }
};
var l2 = {
  ...Zl,
  mode: "lch65",
  parse: ["--lch-d65"],
  serialize: "--lch-d65",
  toMode: {
    lab65: (e16) => no(e16, "lab65"),
    rgb: (e16) => ci(no(e16, "lab65"))
  },
  fromMode: {
    rgb: (e16) => to(ui(e16), "lch65"),
    lab65: (e16) => to(e16, "lch65")
  },
  ranges: {
    l: [0, 100],
    c: [0, 133.807],
    h: [0, 360]
  }
};
var Hd = ({ l: e16, u: t10, v: n, alpha: o }) => {
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.sqrt(t10 * t10 + n * n), a = {
    mode: "lchuv",
    l: e16,
    c: r
  };
  return r && (a.h = At(Math.atan2(n, t10) * 180 / Math.PI)), o !== void 0 && (a.alpha = o), a;
};
var Ud = ({ l: e16, c: t10, h: n, alpha: o }) => {
  n === void 0 && (n = 0);
  let r = {
    mode: "luv",
    l: e16,
    u: t10 ? t10 * Math.cos(n / 180 * Math.PI) : 0,
    v: t10 ? t10 * Math.sin(n / 180 * Math.PI) : 0
  };
  return o !== void 0 && (r.alpha = o), r;
};
var Gd = (e16, t10, n) => 4 * e16 / (e16 + 15 * t10 + 3 * n);
var Xd = (e16, t10, n) => 9 * t10 / (e16 + 15 * t10 + 3 * n);
var c2 = Gd(Ct.X, Ct.Y, Ct.Z);
var u2 = Xd(Ct.X, Ct.Y, Ct.Z);
var d2 = (e16) => e16 <= Fl ? hi * e16 : 116 * Math.cbrt(e16) - 16;
var Vs = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = d2(t10 / Ct.Y), a = Gd(e16, t10, n), i = Xd(e16, t10, n);
  !isFinite(a) || !isFinite(i) ? r = a = i = 0 : (a = 13 * r * (a - c2), i = 13 * r * (i - u2));
  let s = {
    mode: "luv",
    l: r,
    u: a,
    v: i
  };
  return o !== void 0 && (s.alpha = o), s;
};
var f2 = (e16, t10, n) => 4 * e16 / (e16 + 15 * t10 + 3 * n);
var m2 = (e16, t10, n) => 9 * t10 / (e16 + 15 * t10 + 3 * n);
var p2 = f2(Ct.X, Ct.Y, Ct.Z);
var h2 = m2(Ct.X, Ct.Y, Ct.Z);
var Hs = ({ l: e16, u: t10, v: n, alpha: o }) => {
  if (e16 === void 0 && (e16 = 0), e16 === 0)
    return { mode: "xyz50", x: 0, y: 0, z: 0 };
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = t10 / (13 * e16) + p2, a = n / (13 * e16) + h2, i = Ct.Y * (e16 <= 8 ? e16 / hi : Math.pow((e16 + 16) / 116, 3)), s = i * (9 * r) / (4 * a), l = i * (12 - 3 * r - 20 * a) / (4 * a), c = { mode: "xyz50", x: s, y: i, z: l };
  return o !== void 0 && (c.alpha = o), c;
};
var g2 = (e16) => Hd(Vs(nr(e16)));
var v2 = (e16) => tr(Hs(Ud(e16)));
var y2 = {
  mode: "lchuv",
  toMode: {
    luv: Ud,
    rgb: v2
  },
  fromMode: {
    rgb: g2,
    luv: Hd
  },
  channels: ["l", "c", "h", "alpha"],
  parse: ["--lchuv"],
  serialize: "--lchuv",
  ranges: {
    l: [0, 100],
    c: [0, 176.956],
    h: [0, 360]
  },
  interpolate: {
    h: { use: ve, fixup: Fn },
    c: ve,
    l: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: li
  },
  average: {
    h: jn
  }
};
var b2 = {
  ...ga,
  mode: "lrgb",
  toMode: {
    rgb: ya
  },
  fromMode: {
    rgb: va
  },
  parse: ["srgb-linear"],
  serialize: "srgb-linear"
};
var _2 = {
  mode: "luv",
  toMode: {
    xyz50: Hs,
    rgb: (e16) => tr(Hs(e16))
  },
  fromMode: {
    xyz50: Vs,
    rgb: (e16) => Vs(nr(e16))
  },
  channels: ["l", "u", "v", "alpha"],
  parse: ["--luv"],
  serialize: "--luv",
  ranges: {
    l: [0, 100],
    u: [-84.936, 175.042],
    v: [-125.882, 87.243]
  },
  interpolate: {
    l: ve,
    u: ve,
    v: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var Yd = ({ r: e16, g: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.cbrt(
    0.41222147079999993 * e16 + 0.5363325363 * t10 + 0.0514459929 * n
  ), a = Math.cbrt(
    0.2119034981999999 * e16 + 0.6806995450999999 * t10 + 0.1073969566 * n
  ), i = Math.cbrt(
    0.08830246189999998 * e16 + 0.2817188376 * t10 + 0.6299787005000002 * n
  ), s = {
    mode: "oklab",
    l: 0.2104542553 * r + 0.793617785 * a - 0.0040720468 * i,
    a: 1.9779984951 * r - 2.428592205 * a + 0.4505937099 * i,
    b: 0.0259040371 * r + 0.7827717662 * a - 0.808675766 * i
  };
  return o !== void 0 && (s.alpha = o), s;
};
var gi = (e16) => {
  let t10 = Yd(va(e16));
  return e16.r === e16.b && e16.b === e16.g && (t10.a = t10.b = 0), t10;
};
var or = ({ l: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.pow(
    e16 * 0.9999999984505198 + 0.39633779217376786 * t10 + 0.2158037580607588 * n,
    3
  ), a = Math.pow(
    e16 * 1.0000000088817609 - 0.10556134232365635 * t10 - 0.06385417477170591 * n,
    3
  ), i = Math.pow(
    e16 * 1.0000000546724108 - 0.08948418209496575 * t10 - 1.2914855378640917 * n,
    3
  ), s = {
    mode: "lrgb",
    r: 4.076741661347994 * r - 3.307711590408193 * a + 0.230969928729428 * i,
    g: -1.2684380040921763 * r + 2.6097574006633715 * a - 0.3413193963102197 * i,
    b: -0.004196086541837188 * r - 0.7034186144594493 * a + 1.7076147009309444 * i
  };
  return o !== void 0 && (s.alpha = o), s;
};
var vi = (e16) => ya(or(e16));
function Us(e16) {
  const o = 1.170873786407767;
  return 0.5 * (o * e16 - 0.206 + Math.sqrt((o * e16 - 0.206) * (o * e16 - 0.206) + 4 * 0.03 * o * e16));
}
function Vr(e16) {
  return (e16 * e16 + 0.206 * e16) / (1.170873786407767 * (e16 + 0.03));
}
function w2(e16, t10) {
  let n, o, r, a, i, s, l, c;
  -1.88170328 * e16 - 0.80936493 * t10 > 1 ? (n = 1.19086277, o = 1.76576728, r = 0.59662641, a = 0.75515197, i = 0.56771245, s = 4.0767416621, l = -3.3077115913, c = 0.2309699292) : 1.81444104 * e16 - 1.19445276 * t10 > 1 ? (n = 0.73956515, o = -0.45954404, r = 0.08285427, a = 0.1254107, i = 0.14503204, s = -1.2684380046, l = 2.6097574011, c = -0.3413193965) : (n = 1.35733652, o = -915799e-8, r = -1.1513021, a = -0.50559606, i = 692167e-8, s = -0.0041960863, l = -0.7034186147, c = 1.707614701);
  let u = n + o * e16 + r * t10 + a * e16 * e16 + i * e16 * t10, d = 0.3963377774 * e16 + 0.2158037573 * t10, m = -0.1055613458 * e16 - 0.0638541728 * t10, p = -0.0894841775 * e16 - 1.291485548 * t10;
  {
    let f = 1 + u * d, h10 = 1 + u * m, g = 1 + u * p, v = f * f * f, y = h10 * h10 * h10, k = g * g * g, T = 3 * d * f * f, w = 3 * m * h10 * h10, _ = 3 * p * g * g, M = 6 * d * d * f, x = 6 * m * m * h10, R = 6 * p * p * g, I = s * v + l * y + c * k, P = s * T + l * w + c * _, F = s * M + l * x + c * R;
    u = u - I * P / (P * P - 0.5 * I * F);
  }
  return u;
}
function Wl(e16, t10) {
  let n = w2(e16, t10), o = or({ l: 1, a: n * e16, b: n * t10 }), r = Math.cbrt(1 / Math.max(o.r, o.g, o.b)), a = r * n;
  return [r, a];
}
function T2(e16, t10, n, o, r, a = null) {
  a || (a = Wl(e16, t10));
  let i;
  if ((n - r) * a[1] - (a[0] - r) * o <= 0)
    i = a[1] * r / (o * a[0] + a[1] * (r - n));
  else {
    i = a[1] * (r - 1) / (o * (a[0] - 1) + a[1] * (r - n));
    {
      let s = n - r, l = o, c = 0.3963377774 * e16 + 0.2158037573 * t10, u = -0.1055613458 * e16 - 0.0638541728 * t10, d = -0.0894841775 * e16 - 1.291485548 * t10, m = s + l * c, p = s + l * u, f = s + l * d;
      {
        let h10 = r * (1 - i) + i * n, g = i * o, v = h10 + g * c, y = h10 + g * u, k = h10 + g * d, T = v * v * v, w = y * y * y, _ = k * k * k, M = 3 * m * v * v, x = 3 * p * y * y, R = 3 * f * k * k, I = 6 * m * m * v, P = 6 * p * p * y, F = 6 * f * f * k, N = 4.0767416621 * T - 3.3077115913 * w + 0.2309699292 * _ - 1, j = 4.0767416621 * M - 3.3077115913 * x + 0.2309699292 * R, z = 4.0767416621 * I - 3.3077115913 * P + 0.2309699292 * F, A = j / (j * j - 0.5 * N * z), B = -N * A, D = -1.2684380046 * T + 2.6097574011 * w - 0.3413193965 * _ - 1, te = -1.2684380046 * M + 2.6097574011 * x - 0.3413193965 * R, ie = -1.2684380046 * I + 2.6097574011 * P - 0.3413193965 * F, U = te / (te * te - 0.5 * D * ie), oe = -D * U, se = -0.0041960863 * T - 0.7034186147 * w + 1.707614701 * _ - 1, E = -0.0041960863 * M - 0.7034186147 * x + 1.707614701 * R, K = -0.0041960863 * I - 0.7034186147 * P + 1.707614701 * F, ee = E / (E * E - 0.5 * se * K), V = -se * ee;
        B = A >= 0 ? B : 1e6, oe = U >= 0 ? oe : 1e6, V = ee >= 0 ? V : 1e6, i += Math.min(B, Math.min(oe, V));
      }
    }
  }
  return i;
}
function ql(e16, t10, n = null) {
  n || (n = Wl(e16, t10));
  let o = n[0], r = n[1];
  return [r / o, r / (1 - o)];
}
function Qd(e16, t10, n) {
  let o = Wl(t10, n), r = T2(t10, n, e16, 1, e16, o), a = ql(t10, n, o), i = 0.11516993 + 1 / (7.4477897 + 4.1590124 * n + t10 * (-2.19557347 + 1.75198401 * n + t10 * (-2.13704948 - 10.02301043 * n + t10 * (-4.24894561 + 5.38770819 * n + 4.69891013 * t10)))), s = 0.11239642 + 1 / (1.6132032 - 0.68124379 * n + t10 * (0.40370612 + 0.90148123 * n + t10 * (-0.27087943 + 0.6122399 * n + t10 * (299215e-8 - 0.45399568 * n - 0.14661872 * t10)))), l = r / Math.min(e16 * a[0], (1 - e16) * a[1]), c = e16 * i, u = (1 - e16) * s, d = 0.9 * l * Math.sqrt(
    Math.sqrt(
      1 / (1 / (c * c * c * c) + 1 / (u * u * u * u))
    )
  );
  return c = e16 * 0.4, u = (1 - e16) * 0.8, [Math.sqrt(1 / (1 / (c * c) + 1 / (u * u))), d, r];
}
function Xc(e16) {
  const t10 = e16.l !== void 0 ? e16.l : 0, n = e16.a !== void 0 ? e16.a : 0, o = e16.b !== void 0 ? e16.b : 0, r = { mode: "okhsl", l: Us(t10) };
  e16.alpha !== void 0 && (r.alpha = e16.alpha);
  let a = Math.sqrt(n * n + o * o);
  if (!a)
    return r.s = 0, r;
  let [i, s, l] = Qd(t10, n / a, o / a), c;
  if (a < s) {
    let u = 0, d = 0.8 * i, m = 1 - d / s;
    c = (a - u) / (d + m * (a - u)) * 0.8;
  } else {
    let u = s, d = 0.2 * s * s * 1.25 * 1.25 / i, m = 1 - d / (l - s);
    c = 0.8 + 0.2 * ((a - u) / (d + m * (a - u)));
  }
  return c && (r.s = c, r.h = At(Math.atan2(o, n) * 180 / Math.PI)), r;
}
function Yc(e16) {
  let t10 = e16.h !== void 0 ? e16.h : 0, n = e16.s !== void 0 ? e16.s : 0, o = e16.l !== void 0 ? e16.l : 0;
  const r = { mode: "oklab", l: Vr(o) };
  if (e16.alpha !== void 0 && (r.alpha = e16.alpha), !n || o === 1)
    return r.a = r.b = 0, r;
  let a = Math.cos(t10 / 180 * Math.PI), i = Math.sin(t10 / 180 * Math.PI), [s, l, c] = Qd(r.l, a, i), u, d, m, p;
  n < 0.8 ? (u = 1.25 * n, d = 0, m = 0.8 * s, p = 1 - m / l) : (u = 5 * (n - 0.8), d = l, m = 0.2 * l * l * 1.25 * 1.25 / s, p = 1 - m / (c - l));
  let f = d + u * m / (1 - p * u);
  return r.a = f * a, r.b = f * i, r;
}
var C2 = {
  ...zd,
  mode: "okhsl",
  channels: ["h", "s", "l", "alpha"],
  parse: ["--okhsl"],
  serialize: "--okhsl",
  fromMode: {
    oklab: Xc,
    rgb: (e16) => Xc(gi(e16))
  },
  toMode: {
    oklab: Yc,
    rgb: (e16) => vi(Yc(e16))
  }
};
function Qc(e16) {
  let t10 = e16.l !== void 0 ? e16.l : 0, n = e16.a !== void 0 ? e16.a : 0, o = e16.b !== void 0 ? e16.b : 0, r = Math.sqrt(n * n + o * o), a = r ? n / r : 1, i = r ? o / r : 1, [s, l] = ql(a, i), c = 0.5, u = 1 - c / s, d = l / (r + t10 * l), m = d * t10, p = d * r, f = Vr(m), h10 = p * f / m, g = or({ l: f, a: a * h10, b: i * h10 }), v = Math.cbrt(
    1 / Math.max(g.r, g.g, g.b, 0)
  );
  t10 = t10 / v, r = r / v * Us(t10) / t10, t10 = Us(t10);
  const y = {
    mode: "okhsv",
    s: r ? (c + l) * p / (l * c + l * u * p) : 0,
    v: t10 ? t10 / m : 0
  };
  return y.s && (y.h = At(Math.atan2(o, n) * 180 / Math.PI)), e16.alpha !== void 0 && (y.alpha = e16.alpha), y;
}
function Jc(e16) {
  const t10 = { mode: "oklab" };
  e16.alpha !== void 0 && (t10.alpha = e16.alpha);
  const n = e16.h !== void 0 ? e16.h : 0, o = e16.s !== void 0 ? e16.s : 0, r = e16.v !== void 0 ? e16.v : 0, a = Math.cos(n / 180 * Math.PI), i = Math.sin(n / 180 * Math.PI), [s, l] = ql(a, i), c = 0.5, u = 1 - c / s, d = 1 - o * c / (c + l - l * u * o), m = o * l * c / (c + l - l * u * o), p = Vr(d), f = m * p / d, h10 = or({
    l: p,
    a: a * f,
    b: i * f
  }), g = Math.cbrt(
    1 / Math.max(h10.r, h10.g, h10.b, 0)
  ), v = Vr(r * d), y = m * v / d;
  return t10.l = v * g, t10.a = y * a * g, t10.b = y * i * g, t10;
}
var k2 = {
  ...Ld,
  mode: "okhsv",
  channels: ["h", "s", "v", "alpha"],
  parse: ["--okhsv"],
  serialize: "--okhsv",
  fromMode: {
    oklab: Qc,
    rgb: (e16) => Qc(gi(e16))
  },
  toMode: {
    oklab: Jc,
    rgb: (e16) => vi(Jc(e16))
  }
};
function S2(e16, t10) {
  if (!t10 || t10[0] !== "oklab")
    return;
  const n = { mode: "oklab" }, [, o, r, a, i] = t10;
  if (!(o.type === ce.Hue || r.type === ce.Hue || a.type === ce.Hue))
    return o.type !== ce.None && (n.l = Math.min(
      Math.max(0, o.type === ce.Number ? o.value : o.value / 100),
      1
    )), r.type !== ce.None && (n.a = r.type === ce.Number ? r.value : r.value * 0.4 / 100), a.type !== ce.None && (n.b = a.type === ce.Number ? a.value : a.value * 0.4 / 100), i.type !== ce.None && (n.alpha = Math.min(
      1,
      Math.max(
        0,
        i.type === ce.Number ? i.value : i.value / 100
      )
    )), n;
}
var N2 = {
  ...Bl,
  mode: "oklab",
  toMode: {
    lrgb: or,
    rgb: vi
  },
  fromMode: {
    lrgb: Yd,
    rgb: gi
  },
  ranges: {
    l: [0, 1],
    a: [-0.4, 0.4],
    b: [-0.4, 0.4]
  },
  parse: [S2],
  serialize: (e16) => `oklab(${e16.l !== void 0 ? e16.l : "none"} ${e16.a !== void 0 ? e16.a : "none"} ${e16.b !== void 0 ? e16.b : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`
};
function M2(e16, t10) {
  if (!t10 || t10[0] !== "oklch")
    return;
  const n = { mode: "oklch" }, [, o, r, a, i] = t10;
  if (o.type !== ce.None) {
    if (o.type === ce.Hue)
      return;
    n.l = Math.min(
      Math.max(0, o.type === ce.Number ? o.value : o.value / 100),
      1
    );
  }
  if (r.type !== ce.None && (n.c = Math.max(
    0,
    r.type === ce.Number ? r.value : r.value * 0.4 / 100
  )), a.type !== ce.None) {
    if (a.type === ce.Percentage)
      return;
    n.h = a.value;
  }
  return i.type !== ce.None && (n.alpha = Math.min(
    1,
    Math.max(
      0,
      i.type === ce.Number ? i.value : i.value / 100
    )
  )), n;
}
var $2 = {
  ...Zl,
  mode: "oklch",
  toMode: {
    oklab: (e16) => no(e16, "oklab"),
    rgb: (e16) => vi(no(e16, "oklab"))
  },
  fromMode: {
    rgb: (e16) => to(gi(e16), "oklch"),
    oklab: (e16) => to(e16, "oklch")
  },
  parse: [M2],
  serialize: (e16) => `oklch(${e16.l !== void 0 ? e16.l : "none"} ${e16.c !== void 0 ? e16.c : "none"} ${e16.h !== void 0 ? e16.h : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  ranges: {
    l: [0, 1],
    c: [0, 0.4],
    h: [0, 360]
  }
};
var eu = (e16) => {
  let { r: t10, g: n, b: o, alpha: r } = va(e16), a = {
    mode: "xyz65",
    x: 0.486570948648216 * t10 + 0.265667693169093 * n + 0.1982172852343625 * o,
    y: 0.2289745640697487 * t10 + 0.6917385218365062 * n + 0.079286914093745 * o,
    z: 0 * t10 + 0.0451133818589026 * n + 1.043944368900976 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var tu = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = ya(
    {
      r: e16 * 2.4934969119414263 - t10 * 0.9313836179191242 - 0.402710784450717 * n,
      g: e16 * -0.8294889695615749 + t10 * 1.7626640603183465 + 0.0236246858419436 * n,
      b: e16 * 0.0358458302437845 - t10 * 0.0761723892680418 + 0.9568845240076871 * n
    },
    "p3"
  );
  return o !== void 0 && (r.alpha = o), r;
};
var x2 = {
  ...ga,
  mode: "p3",
  parse: ["display-p3"],
  serialize: "display-p3",
  fromMode: {
    rgb: (e16) => tu(Ko(e16)),
    xyz65: tu
  },
  toMode: {
    rgb: (e16) => zo(eu(e16)),
    xyz65: eu
  }
};
var us = (e16) => {
  let t10 = Math.abs(e16);
  return t10 >= 1 / 512 ? Math.sign(e16) * Math.pow(t10, 1 / 1.8) : 16 * e16;
};
var nu = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = {
    mode: "prophoto",
    r: us(
      e16 * 1.3457868816471585 - t10 * 0.2555720873797946 - 0.0511018649755453 * n
    ),
    g: us(
      e16 * -0.5446307051249019 + t10 * 1.5082477428451466 + 0.0205274474364214 * n
    ),
    b: us(e16 * 0 + t10 * 0 + 1.2119675456389452 * n)
  };
  return o !== void 0 && (r.alpha = o), r;
};
var ds = (e16 = 0) => {
  let t10 = Math.abs(e16);
  return t10 >= 16 / 512 ? Math.sign(e16) * Math.pow(t10, 1.8) : e16 / 16;
};
var ou = (e16) => {
  let t10 = ds(e16.r), n = ds(e16.g), o = ds(e16.b), r = {
    mode: "xyz50",
    x: 0.7977666449006423 * t10 + 0.1351812974005331 * n + 0.0313477341283922 * o,
    y: 0.2880748288194013 * t10 + 0.7118352342418731 * n + 899369387256e-16 * o,
    z: 0 * t10 + 0 * n + 0.8251046025104602 * o
  };
  return e16.alpha !== void 0 && (r.alpha = e16.alpha), r;
};
var I2 = {
  ...ga,
  mode: "prophoto",
  parse: ["prophoto-rgb"],
  serialize: "prophoto-rgb",
  fromMode: {
    xyz50: nu,
    rgb: (e16) => nu(nr(e16))
  },
  toMode: {
    xyz50: ou,
    rgb: (e16) => tr(ou(e16))
  }
};
var au = 1.09929682680944;
var D2 = 0.018053968510807;
var fs = (e16) => {
  const t10 = Math.abs(e16);
  return t10 > D2 ? (Math.sign(e16) || 1) * (au * Math.pow(t10, 0.45) - (au - 1)) : 4.5 * e16;
};
var ru = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = {
    mode: "rec2020",
    r: fs(
      e16 * 1.7166511879712683 - t10 * 0.3556707837763925 - 0.2533662813736599 * n
    ),
    g: fs(
      e16 * -0.6666843518324893 + t10 * 1.6164812366349395 + 0.0157685458139111 * n
    ),
    b: fs(
      e16 * 0.0176398574453108 - t10 * 0.0427706132578085 + 0.9421031212354739 * n
    )
  };
  return o !== void 0 && (r.alpha = o), r;
};
var iu = 1.09929682680944;
var A2 = 0.018053968510807;
var ms = (e16 = 0) => {
  let t10 = Math.abs(e16);
  return t10 < A2 * 4.5 ? e16 / 4.5 : (Math.sign(e16) || 1) * Math.pow((t10 + iu - 1) / iu, 1 / 0.45);
};
var su = (e16) => {
  let t10 = ms(e16.r), n = ms(e16.g), o = ms(e16.b), r = {
    mode: "xyz65",
    x: 0.6369580483012911 * t10 + 0.1446169035862083 * n + 0.1688809751641721 * o,
    y: 0.262700212011267 * t10 + 0.6779980715188708 * n + 0.059301716469862 * o,
    z: 0 * t10 + 0.0280726930490874 * n + 1.0609850577107909 * o
  };
  return e16.alpha !== void 0 && (r.alpha = e16.alpha), r;
};
var E2 = {
  ...ga,
  mode: "rec2020",
  fromMode: {
    xyz65: ru,
    rgb: (e16) => ru(Ko(e16))
  },
  toMode: {
    xyz65: su,
    rgb: (e16) => zo(su(e16))
  },
  parse: ["rec2020"],
  serialize: "rec2020"
};
var ko = 0.0037930732552754493;
var Jd = Math.cbrt(ko);
var ps = (e16) => Math.cbrt(e16) - Jd;
var K2 = (e16) => {
  const { r: t10, g: n, b: o, alpha: r } = va(e16), a = ps(0.3 * t10 + 0.622 * n + 0.078 * o + ko), i = ps(0.23 * t10 + 0.692 * n + 0.078 * o + ko), s = ps(
    0.2434226892454782 * t10 + 0.2047674442449682 * n + 0.5518098665095535 * o + ko
  ), l = {
    mode: "xyb",
    x: (a - i) / 2,
    y: (a + i) / 2,
    /* Apply default chroma from luma (subtract Y from B) */
    b: s - (a + i) / 2
  };
  return r !== void 0 && (l.alpha = r), l;
};
var hs = (e16) => Math.pow(e16 + Jd, 3);
var z2 = ({ x: e16, y: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  const r = hs(e16 + t10) - ko, a = hs(t10 - e16) - ko, i = hs(n + t10) - ko, s = ya({
    r: 11.031566904639861 * r - 9.866943908131562 * a - 0.16462299650829934 * i,
    g: -3.2541473810744237 * r + 4.418770377582723 * a - 0.16462299650829934 * i,
    b: -3.6588512867136815 * r + 2.7129230459360922 * a + 1.9459282407775895 * i
  });
  return o !== void 0 && (s.alpha = o), s;
};
var P2 = {
  mode: "xyb",
  channels: ["x", "y", "b", "alpha"],
  parse: ["--xyb"],
  serialize: "--xyb",
  toMode: {
    rgb: z2
  },
  fromMode: {
    rgb: K2
  },
  ranges: {
    x: [-0.0154, 0.0281],
    y: [0, 0.8453],
    b: [-0.2778, 0.388]
  },
  interpolate: {
    x: ve,
    y: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var R2 = {
  mode: "xyz50",
  parse: ["xyz-d50"],
  serialize: "xyz-d50",
  toMode: {
    rgb: tr,
    lab: Ol
  },
  fromMode: {
    rgb: nr,
    lab: jl
  },
  channels: ["x", "y", "z", "alpha"],
  ranges: {
    x: [0, 0.964],
    y: [0, 0.999],
    z: [0, 0.825]
  },
  interpolate: {
    x: ve,
    y: ve,
    z: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var L2 = (e16) => {
  let { x: t10, y: n, z: o, alpha: r } = e16;
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0), o === void 0 && (o = 0);
  let a = {
    mode: "xyz50",
    x: 1.0479298208405488 * t10 + 0.0229467933410191 * n - 0.0501922295431356 * o,
    y: 0.0296278156881593 * t10 + 0.990434484573249 * n - 0.0170738250293851 * o,
    z: -0.0092430581525912 * t10 + 0.0150551448965779 * n + 0.7518742899580008 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var F2 = (e16) => {
  let { x: t10, y: n, z: o, alpha: r } = e16;
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0), o === void 0 && (o = 0);
  let a = {
    mode: "xyz65",
    x: 0.9554734527042182 * t10 - 0.0230985368742614 * n + 0.0632593086610217 * o,
    y: -0.0283697069632081 * t10 + 1.0099954580058226 * n + 0.021041398966943 * o,
    z: 0.0123140016883199 * t10 - 0.0205076964334779 * n + 1.3303659366080753 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var j2 = {
  mode: "xyz65",
  toMode: {
    rgb: zo,
    xyz50: L2
  },
  fromMode: {
    rgb: Ko,
    xyz50: F2
  },
  ranges: {
    x: [0, 0.95],
    y: [0, 1],
    z: [0, 1.088]
  },
  channels: ["x", "y", "z", "alpha"],
  parse: ["xyz", "xyz-d65"],
  serialize: "xyz-d65",
  interpolate: {
    x: ve,
    y: ve,
    z: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var O2 = ({ r: e16, g: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  const r = {
    mode: "yiq",
    y: 0.29889531 * e16 + 0.58662247 * t10 + 0.11448223 * n,
    i: 0.59597799 * e16 - 0.2741761 * t10 - 0.32180189 * n,
    q: 0.21147017 * e16 - 0.52261711 * t10 + 0.31114694 * n
  };
  return o !== void 0 && (r.alpha = o), r;
};
var B2 = ({ y: e16, i: t10, q: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  const r = {
    mode: "rgb",
    r: e16 + 0.95608445 * t10 + 0.6208885 * n,
    g: e16 - 0.27137664 * t10 - 0.6486059 * n,
    b: e16 - 1.10561724 * t10 + 1.70250126 * n
  };
  return o !== void 0 && (r.alpha = o), r;
};
var Z2 = {
  mode: "yiq",
  toMode: {
    rgb: B2
  },
  fromMode: {
    rgb: O2
  },
  channels: ["y", "i", "q", "alpha"],
  parse: ["--yiq"],
  serialize: "--yiq",
  ranges: {
    i: [-0.595, 0.595],
    q: [-0.522, 0.522]
  },
  interpolate: {
    y: ve,
    i: ve,
    q: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
Ge(Ig);
Ge(Rg);
Ge(Lg);
Ge(Fg);
Ge(Bg);
Ge(zd);
Ge(Ld);
Ge(Qg);
Ge(Jg);
Ge(o2);
Ge(a2);
Ge(Bl);
Ge(i2);
Ge(Zl);
Ge(l2);
Ge(y2);
Ge(b2);
Ge(_2);
Ge(C2);
Ge(k2);
Ge(N2);
Ge($2);
Ge(x2);
Ge(I2);
Ge(E2);
Ge(ga);
Ge(P2);
Ge(R2);
Ge(j2);
Ge(Z2);
var W2 = {
  primary: "#3b82f6",
  success: "#22c55e",
  warning: "#f97316",
  danger: "#ef4444",
  error: "#ef4444",
  info: "#64748b"
};
var $a = [
  97.78,
  93.56,
  88.11,
  82.67,
  74.22,
  64.78,
  57.33,
  46.89,
  39.44,
  32,
  23.78
];
var gs = [
  0.0108,
  0.0321,
  0.0609,
  0.0908,
  0.1398,
  0.1472,
  0.1299,
  0.1067,
  0.0898,
  0.0726,
  0.054
];
var q2 = [
  "--k-oklch-50",
  "--k-oklch-100",
  "--k-oklch-200",
  "--k-oklch-300",
  "--k-oklch-400",
  "--k-oklch-500",
  "--k-oklch-600",
  "--k-oklch-700",
  "--k-oklch-800",
  "--k-oklch-900",
  "--k-oklch-950"
];
function Nn(e16) {
  const t10 = $a.map((s) => s - $a[5]), n = gs.map((s) => s - gs[5]), o = W2[e16] ?? e16, r = Os("oklch"), a = Os("rgb"), i = {};
  if ($d(o)) {
    const { l: s, c: l, h: c } = r(o) ?? {};
    if (!s || !l || !c)
      return;
    for (let u = 0; u < 11; u++) {
      const d = s + t10[u] / 100, m = $a[$a.length - 1] / 100, p = $a[0] / 100, f = xa(d, m, p), h10 = l + n[u], g = gs[0], y = xa(h10, g, l), T = a({ l: f, c: y, h: c, mode: "oklch" }), w = {
        mode: "rgb",
        r: (xa(T.r, 0, 1) * 255).toFixed(2),
        g: (xa(T.g, 0, 1) * 255).toFixed(2),
        b: (xa(T.b, 0, 1) * 255).toFixed(2)
      };
      i[q2[u]] = `rgb(${w.r}, ${w.g}, ${w.b})`;
    }
  }
  return {
    colorLevel: i
  };
}
function xa(e16, t10 = 0, n = 255) {
  return Math.max(t10, Math.min(n, e16));
}
var fn = Symbol("__size__");
Object.freeze({});
Object.freeze([]);
var V2 = () => {
};
var $e = (e16, t10) => {
  if (e16.install = (n) => {
    for (const o of [e16, ...Object.values(t10 ?? {})])
      n.component(o.name, o);
  }, t10)
    for (const [n, o] of Object.entries(t10))
      e16[n] = o;
  return e16;
};
var H2 = (e16, t10) => (e16.install = (n) => {
  e16._context = n._context, n.config.globalProperties[t10] = e16;
}, e16);
var tn = (e16) => (e16.install = V2, e16);
var U2 = [
  // bg
  {
    name: "bg-color-main",
    value: "500"
  },
  {
    name: "bg-color-main--hover",
    value: "400"
  },
  {
    name: "bg-color-main--active",
    value: "600"
  },
  {
    name: "bg-color-main--loading",
    value: "300"
  },
  // border
  {
    name: "border-color-main",
    value: "500"
  },
  {
    name: "border-color-main--hover",
    value: "400"
  },
  {
    name: "border-color-main--active",
    value: "600"
  },
  {
    name: "border-color-main--loading",
    value: "300"
  }
];
var G2 = [
  // bg
  {
    name: "bg-color-secondary--hover",
    value: "50"
  },
  {
    name: "bg-color-secondary--active",
    value: "50"
  },
  // content
  {
    name: "content-color-secondary",
    value: "500"
  },
  {
    name: "content-color-secondary--hover",
    value: "400"
  },
  {
    name: "content-color-secondary--active",
    value: "600"
  },
  {
    name: "content-color-secondary--loading",
    value: "300"
  },
  // border
  {
    name: "border-color-secondary",
    value: "500"
  },
  {
    name: "border-color-secondary--hover",
    value: "400"
  },
  {
    name: "border-color-secondary--active",
    value: "600"
  },
  {
    name: "border-color-secondary--loading",
    value: "300"
  }
];
var X2 = [
  // content
  {
    name: "content-color-text",
    value: "500"
  },
  {
    name: "content-color-text--hover",
    value: "400"
  },
  {
    name: "content-color-text--active",
    value: "600"
  },
  {
    name: "content-color-text--loading",
    value: "300"
  }
];
var Y2 = [
  { type: "main", vars: U2 },
  { type: "secondary", vars: G2 },
  { type: "text", vars: X2 }
];
var ef = typeof global == "object" && global && global.Object === Object && global;
var Q2 = typeof self == "object" && self && self.Object === Object && self;
var mn = ef || Q2 || Function("return this")();
var oo = mn.Symbol;
var tf = Object.prototype;
var J2 = tf.hasOwnProperty;
var ev = tf.toString;
var Ia = oo ? oo.toStringTag : void 0;
function tv(e16) {
  var t10 = J2.call(e16, Ia), n = e16[Ia];
  try {
    e16[Ia] = void 0;
    var o = true;
  } catch {
  }
  var r = ev.call(e16);
  return o && (t10 ? e16[Ia] = n : delete e16[Ia]), r;
}
var nv = Object.prototype;
var ov = nv.toString;
function av(e16) {
  return ov.call(e16);
}
var rv = "[object Null]";
var iv = "[object Undefined]";
var lu = oo ? oo.toStringTag : void 0;
function Po(e16) {
  return e16 == null ? e16 === void 0 ? iv : rv : lu && lu in Object(e16) ? tv(e16) : av(e16);
}
function Ro(e16) {
  return e16 != null && typeof e16 == "object";
}
var sv = "[object Symbol]";
function nf(e16) {
  return typeof e16 == "symbol" || Ro(e16) && Po(e16) == sv;
}
function lv(e16, t10) {
  for (var n = -1, o = e16 == null ? 0 : e16.length, r = Array(o); ++n < o; )
    r[n] = t10(e16[n], n, e16);
  return r;
}
var yi = Array.isArray;
var cv = 1 / 0;
var cu = oo ? oo.prototype : void 0;
var uu = cu ? cu.toString : void 0;
function of(e16) {
  if (typeof e16 == "string")
    return e16;
  if (yi(e16))
    return lv(e16, of) + "";
  if (nf(e16))
    return uu ? uu.call(e16) : "";
  var t10 = e16 + "";
  return t10 == "0" && 1 / e16 == -cv ? "-0" : t10;
}
var uv = /\s/;
function dv(e16) {
  for (var t10 = e16.length; t10-- && uv.test(e16.charAt(t10)); )
    ;
  return t10;
}
var fv = /^\s+/;
function mv(e16) {
  return e16 && e16.slice(0, dv(e16) + 1).replace(fv, "");
}
function ao(e16) {
  var t10 = typeof e16;
  return e16 != null && (t10 == "object" || t10 == "function");
}
var du = NaN;
var pv = /^[-+]0x[0-9a-f]+$/i;
var hv = /^0b[01]+$/i;
var gv = /^0o[0-7]+$/i;
var vv = parseInt;
function fu(e16) {
  if (typeof e16 == "number")
    return e16;
  if (nf(e16))
    return du;
  if (ao(e16)) {
    var t10 = typeof e16.valueOf == "function" ? e16.valueOf() : e16;
    e16 = ao(t10) ? t10 + "" : t10;
  }
  if (typeof e16 != "string")
    return e16 === 0 ? e16 : +e16;
  e16 = mv(e16);
  var n = hv.test(e16);
  return n || gv.test(e16) ? vv(e16.slice(2), n ? 2 : 8) : pv.test(e16) ? du : +e16;
}
var yv = "[object AsyncFunction]";
var bv = "[object Function]";
var _v = "[object GeneratorFunction]";
var wv = "[object Proxy]";
function af(e16) {
  if (!ao(e16))
    return false;
  var t10 = Po(e16);
  return t10 == bv || t10 == _v || t10 == yv || t10 == wv;
}
var vs = mn["__core-js_shared__"];
var mu = function() {
  var e16 = /[^.]+$/.exec(vs && vs.keys && vs.keys.IE_PROTO || "");
  return e16 ? "Symbol(src)_1." + e16 : "";
}();
function Tv(e16) {
  return !!mu && mu in e16;
}
var Cv = Function.prototype;
var kv = Cv.toString;
function Lo(e16) {
  if (e16 != null) {
    try {
      return kv.call(e16);
    } catch {
    }
    try {
      return e16 + "";
    } catch {
    }
  }
  return "";
}
var Sv = /[\\^$.*+?()[\]{}|]/g;
var Nv = /^\[object .+?Constructor\]$/;
var Mv = Function.prototype;
var $v = Object.prototype;
var xv = Mv.toString;
var Iv = $v.hasOwnProperty;
var Dv = RegExp(
  "^" + xv.call(Iv).replace(Sv, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Av(e16) {
  if (!ao(e16) || Tv(e16))
    return false;
  var t10 = af(e16) ? Dv : Nv;
  return t10.test(Lo(e16));
}
function Ev(e16, t10) {
  return e16 == null ? void 0 : e16[t10];
}
function Fo(e16, t10) {
  var n = Ev(e16, t10);
  return Av(n) ? n : void 0;
}
var Gs = Fo(mn, "WeakMap");
var pu = Object.create;
var Kv = /* @__PURE__ */ function() {
  function e16() {
  }
  return function(t10) {
    if (!ao(t10))
      return {};
    if (pu)
      return pu(t10);
    e16.prototype = t10;
    var n = new e16();
    return e16.prototype = void 0, n;
  };
}();
function zv(e16, t10) {
  var n = -1, o = e16.length;
  for (t10 || (t10 = Array(o)); ++n < o; )
    t10[n] = e16[n];
  return t10;
}
var hu = function() {
  try {
    var e16 = Fo(Object, "defineProperty");
    return e16({}, "", {}), e16;
  } catch {
  }
}();
function Pv(e16, t10) {
  for (var n = -1, o = e16 == null ? 0 : e16.length; ++n < o && t10(e16[n], n, e16) !== false; )
    ;
  return e16;
}
var Rv = 9007199254740991;
var Lv = /^(?:0|[1-9]\d*)$/;
function Fv(e16, t10) {
  var n = typeof e16;
  return t10 = t10 ?? Rv, !!t10 && (n == "number" || n != "symbol" && Lv.test(e16)) && e16 > -1 && e16 % 1 == 0 && e16 < t10;
}
function rf(e16, t10, n) {
  t10 == "__proto__" && hu ? hu(e16, t10, {
    configurable: true,
    enumerable: true,
    value: n,
    writable: true
  }) : e16[t10] = n;
}
function sf(e16, t10) {
  return e16 === t10 || e16 !== e16 && t10 !== t10;
}
var jv = Object.prototype;
var Ov = jv.hasOwnProperty;
function lf(e16, t10, n) {
  var o = e16[t10];
  (!(Ov.call(e16, t10) && sf(o, n)) || n === void 0 && !(t10 in e16)) && rf(e16, t10, n);
}
function bi(e16, t10, n, o) {
  var r = !n;
  n || (n = {});
  for (var a = -1, i = t10.length; ++a < i; ) {
    var s = t10[a], l = void 0;
    l === void 0 && (l = e16[s]), r ? rf(n, s, l) : lf(n, s, l);
  }
  return n;
}
var Bv = 9007199254740991;
function cf(e16) {
  return typeof e16 == "number" && e16 > -1 && e16 % 1 == 0 && e16 <= Bv;
}
function uf(e16) {
  return e16 != null && cf(e16.length) && !af(e16);
}
var Zv = Object.prototype;
function Vl(e16) {
  var t10 = e16 && e16.constructor, n = typeof t10 == "function" && t10.prototype || Zv;
  return e16 === n;
}
function Wv(e16, t10) {
  for (var n = -1, o = Array(e16); ++n < e16; )
    o[n] = t10(n);
  return o;
}
var qv = "[object Arguments]";
function gu(e16) {
  return Ro(e16) && Po(e16) == qv;
}
var df = Object.prototype;
var Vv = df.hasOwnProperty;
var Hv = df.propertyIsEnumerable;
var Uv = gu(/* @__PURE__ */ function() {
  return arguments;
}()) ? gu : function(e16) {
  return Ro(e16) && Vv.call(e16, "callee") && !Hv.call(e16, "callee");
};
function Gv() {
  return false;
}
var ff = typeof exports == "object" && exports && !exports.nodeType && exports;
var vu = ff && typeof module == "object" && module && !module.nodeType && module;
var Xv = vu && vu.exports === ff;
var yu = Xv ? mn.Buffer : void 0;
var Yv = yu ? yu.isBuffer : void 0;
var mf = Yv || Gv;
var Qv = "[object Arguments]";
var Jv = "[object Array]";
var e42 = "[object Boolean]";
var t4 = "[object Date]";
var n4 = "[object Error]";
var o4 = "[object Function]";
var a4 = "[object Map]";
var r4 = "[object Number]";
var i4 = "[object Object]";
var s4 = "[object RegExp]";
var l4 = "[object Set]";
var c4 = "[object String]";
var u4 = "[object WeakMap]";
var d4 = "[object ArrayBuffer]";
var f4 = "[object DataView]";
var m4 = "[object Float32Array]";
var p4 = "[object Float64Array]";
var h4 = "[object Int8Array]";
var g4 = "[object Int16Array]";
var v4 = "[object Int32Array]";
var y4 = "[object Uint8Array]";
var b4 = "[object Uint8ClampedArray]";
var _4 = "[object Uint16Array]";
var w4 = "[object Uint32Array]";
var st = {};
st[m4] = st[p4] = st[h4] = st[g4] = st[v4] = st[y4] = st[b4] = st[_4] = st[w4] = true;
st[Qv] = st[Jv] = st[d4] = st[e42] = st[f4] = st[t4] = st[n4] = st[o4] = st[a4] = st[r4] = st[i4] = st[s4] = st[l4] = st[c4] = st[u4] = false;
function T4(e16) {
  return Ro(e16) && cf(e16.length) && !!st[Po(e16)];
}
function Hl(e16) {
  return function(t10) {
    return e16(t10);
  };
}
var pf = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ra = pf && typeof module == "object" && module && !module.nodeType && module;
var C4 = Ra && Ra.exports === pf;
var ys = C4 && ef.process;
var da = function() {
  try {
    var e16 = Ra && Ra.require && Ra.require("util").types;
    return e16 || ys && ys.binding && ys.binding("util");
  } catch {
  }
}();
var bu = da && da.isTypedArray;
var k4 = bu ? Hl(bu) : T4;
var S4 = Object.prototype;
var N4 = S4.hasOwnProperty;
function hf(e16, t10) {
  var n = yi(e16), o = !n && Uv(e16), r = !n && !o && mf(e16), a = !n && !o && !r && k4(e16), i = n || o || r || a, s = i ? Wv(e16.length, String) : [], l = s.length;
  for (var c in e16)
    (t10 || N4.call(e16, c)) && !(i && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    Fv(c, l))) && s.push(c);
  return s;
}
function gf(e16, t10) {
  return function(n) {
    return e16(t10(n));
  };
}
var M4 = gf(Object.keys, Object);
var $4 = Object.prototype;
var x4 = $4.hasOwnProperty;
function I4(e16) {
  if (!Vl(e16))
    return M4(e16);
  var t10 = [];
  for (var n in Object(e16))
    x4.call(e16, n) && n != "constructor" && t10.push(n);
  return t10;
}
function Ul(e16) {
  return uf(e16) ? hf(e16) : I4(e16);
}
function D4(e16) {
  var t10 = [];
  if (e16 != null)
    for (var n in Object(e16))
      t10.push(n);
  return t10;
}
var A4 = Object.prototype;
var E4 = A4.hasOwnProperty;
function K4(e16) {
  if (!ao(e16))
    return D4(e16);
  var t10 = Vl(e16), n = [];
  for (var o in e16)
    o == "constructor" && (t10 || !E4.call(e16, o)) || n.push(o);
  return n;
}
function Gl(e16) {
  return uf(e16) ? hf(e16, true) : K4(e16);
}
var Ha = Fo(Object, "create");
function z4() {
  this.__data__ = Ha ? Ha(null) : {}, this.size = 0;
}
function P4(e16) {
  var t10 = this.has(e16) && delete this.__data__[e16];
  return this.size -= t10 ? 1 : 0, t10;
}
var R4 = "__lodash_hash_undefined__";
var L4 = Object.prototype;
var F4 = L4.hasOwnProperty;
function j4(e16) {
  var t10 = this.__data__;
  if (Ha) {
    var n = t10[e16];
    return n === R4 ? void 0 : n;
  }
  return F4.call(t10, e16) ? t10[e16] : void 0;
}
var O4 = Object.prototype;
var B4 = O4.hasOwnProperty;
function Z4(e16) {
  var t10 = this.__data__;
  return Ha ? t10[e16] !== void 0 : B4.call(t10, e16);
}
var W4 = "__lodash_hash_undefined__";
function q4(e16, t10) {
  var n = this.__data__;
  return this.size += this.has(e16) ? 0 : 1, n[e16] = Ha && t10 === void 0 ? W4 : t10, this;
}
function xo(e16) {
  var t10 = -1, n = e16 == null ? 0 : e16.length;
  for (this.clear(); ++t10 < n; ) {
    var o = e16[t10];
    this.set(o[0], o[1]);
  }
}
xo.prototype.clear = z4;
xo.prototype.delete = P4;
xo.prototype.get = j4;
xo.prototype.has = Z4;
xo.prototype.set = q4;
function V4() {
  this.__data__ = [], this.size = 0;
}
function _i(e16, t10) {
  for (var n = e16.length; n--; )
    if (sf(e16[n][0], t10))
      return n;
  return -1;
}
var H4 = Array.prototype;
var U4 = H4.splice;
function G4(e16) {
  var t10 = this.__data__, n = _i(t10, e16);
  if (n < 0)
    return false;
  var o = t10.length - 1;
  return n == o ? t10.pop() : U4.call(t10, n, 1), --this.size, true;
}
function X4(e16) {
  var t10 = this.__data__, n = _i(t10, e16);
  return n < 0 ? void 0 : t10[n][1];
}
function Y4(e16) {
  return _i(this.__data__, e16) > -1;
}
function Q4(e16, t10) {
  var n = this.__data__, o = _i(n, e16);
  return o < 0 ? (++this.size, n.push([e16, t10])) : n[o][1] = t10, this;
}
function On(e16) {
  var t10 = -1, n = e16 == null ? 0 : e16.length;
  for (this.clear(); ++t10 < n; ) {
    var o = e16[t10];
    this.set(o[0], o[1]);
  }
}
On.prototype.clear = V4;
On.prototype.delete = G4;
On.prototype.get = X4;
On.prototype.has = Y4;
On.prototype.set = Q4;
var Ua = Fo(mn, "Map");
function J4() {
  this.size = 0, this.__data__ = {
    hash: new xo(),
    map: new (Ua || On)(),
    string: new xo()
  };
}
function e52(e16) {
  var t10 = typeof e16;
  return t10 == "string" || t10 == "number" || t10 == "symbol" || t10 == "boolean" ? e16 !== "__proto__" : e16 === null;
}
function wi(e16, t10) {
  var n = e16.__data__;
  return e52(t10) ? n[typeof t10 == "string" ? "string" : "hash"] : n.map;
}
function t5(e16) {
  var t10 = wi(this, e16).delete(e16);
  return this.size -= t10 ? 1 : 0, t10;
}
function n5(e16) {
  return wi(this, e16).get(e16);
}
function o5(e16) {
  return wi(this, e16).has(e16);
}
function a5(e16, t10) {
  var n = wi(this, e16), o = n.size;
  return n.set(e16, t10), this.size += n.size == o ? 0 : 1, this;
}
function ba(e16) {
  var t10 = -1, n = e16 == null ? 0 : e16.length;
  for (this.clear(); ++t10 < n; ) {
    var o = e16[t10];
    this.set(o[0], o[1]);
  }
}
ba.prototype.clear = J4;
ba.prototype.delete = t5;
ba.prototype.get = n5;
ba.prototype.has = o5;
ba.prototype.set = a5;
function _u(e16) {
  return e16 == null ? "" : of(e16);
}
function vf(e16, t10) {
  for (var n = -1, o = t10.length, r = e16.length; ++n < o; )
    e16[r + n] = t10[n];
  return e16;
}
var yf = gf(Object.getPrototypeOf, Object);
function r5() {
  this.__data__ = new On(), this.size = 0;
}
function i5(e16) {
  var t10 = this.__data__, n = t10.delete(e16);
  return this.size = t10.size, n;
}
function s5(e16) {
  return this.__data__.get(e16);
}
function l5(e16) {
  return this.__data__.has(e16);
}
var c5 = 200;
function u5(e16, t10) {
  var n = this.__data__;
  if (n instanceof On) {
    var o = n.__data__;
    if (!Ua || o.length < c5 - 1)
      return o.push([e16, t10]), this.size = ++n.size, this;
    n = this.__data__ = new ba(o);
  }
  return n.set(e16, t10), this.size = n.size, this;
}
function _a(e16) {
  var t10 = this.__data__ = new On(e16);
  this.size = t10.size;
}
_a.prototype.clear = r5;
_a.prototype.delete = i5;
_a.prototype.get = s5;
_a.prototype.has = l5;
_a.prototype.set = u5;
function d5(e16, t10) {
  return e16 && bi(t10, Ul(t10), e16);
}
function f5(e16, t10) {
  return e16 && bi(t10, Gl(t10), e16);
}
var bf = typeof exports == "object" && exports && !exports.nodeType && exports;
var wu = bf && typeof module == "object" && module && !module.nodeType && module;
var m5 = wu && wu.exports === bf;
var Tu = m5 ? mn.Buffer : void 0;
var Cu = Tu ? Tu.allocUnsafe : void 0;
function p5(e16, t10) {
  if (t10)
    return e16.slice();
  var n = e16.length, o = Cu ? Cu(n) : new e16.constructor(n);
  return e16.copy(o), o;
}
function h5(e16, t10) {
  for (var n = -1, o = e16 == null ? 0 : e16.length, r = 0, a = []; ++n < o; ) {
    var i = e16[n];
    t10(i, n, e16) && (a[r++] = i);
  }
  return a;
}
function _f() {
  return [];
}
var g5 = Object.prototype;
var v5 = g5.propertyIsEnumerable;
var ku = Object.getOwnPropertySymbols;
var Xl = ku ? function(e16) {
  return e16 == null ? [] : (e16 = Object(e16), h5(ku(e16), function(t10) {
    return v5.call(e16, t10);
  }));
} : _f;
function y5(e16, t10) {
  return bi(e16, Xl(e16), t10);
}
var b5 = Object.getOwnPropertySymbols;
var wf = b5 ? function(e16) {
  for (var t10 = []; e16; )
    vf(t10, Xl(e16)), e16 = yf(e16);
  return t10;
} : _f;
function _5(e16, t10) {
  return bi(e16, wf(e16), t10);
}
function Tf(e16, t10, n) {
  var o = t10(e16);
  return yi(e16) ? o : vf(o, n(e16));
}
function w5(e16) {
  return Tf(e16, Ul, Xl);
}
function T5(e16) {
  return Tf(e16, Gl, wf);
}
var Xs = Fo(mn, "DataView");
var Ys = Fo(mn, "Promise");
var Qs = Fo(mn, "Set");
var Su = "[object Map]";
var C5 = "[object Object]";
var Nu = "[object Promise]";
var Mu = "[object Set]";
var $u = "[object WeakMap]";
var xu = "[object DataView]";
var k5 = Lo(Xs);
var S5 = Lo(Ua);
var N5 = Lo(Ys);
var M5 = Lo(Qs);
var $5 = Lo(Gs);
var zn = Po;
(Xs && zn(new Xs(new ArrayBuffer(1))) != xu || Ua && zn(new Ua()) != Su || Ys && zn(Ys.resolve()) != Nu || Qs && zn(new Qs()) != Mu || Gs && zn(new Gs()) != $u) && (zn = function(e16) {
  var t10 = Po(e16), n = t10 == C5 ? e16.constructor : void 0, o = n ? Lo(n) : "";
  if (o)
    switch (o) {
      case k5:
        return xu;
      case S5:
        return Su;
      case N5:
        return Nu;
      case M5:
        return Mu;
      case $5:
        return $u;
    }
  return t10;
});
var x5 = Object.prototype;
var I5 = x5.hasOwnProperty;
function D5(e16) {
  var t10 = e16.length, n = new e16.constructor(t10);
  return t10 && typeof e16[0] == "string" && I5.call(e16, "index") && (n.index = e16.index, n.input = e16.input), n;
}
var Iu = mn.Uint8Array;
function Yl(e16) {
  var t10 = new e16.constructor(e16.byteLength);
  return new Iu(t10).set(new Iu(e16)), t10;
}
function A5(e16, t10) {
  var n = t10 ? Yl(e16.buffer) : e16.buffer;
  return new e16.constructor(n, e16.byteOffset, e16.byteLength);
}
var E5 = /\w*$/;
function K5(e16) {
  var t10 = new e16.constructor(e16.source, E5.exec(e16));
  return t10.lastIndex = e16.lastIndex, t10;
}
var Du = oo ? oo.prototype : void 0;
var Au = Du ? Du.valueOf : void 0;
function z5(e16) {
  return Au ? Object(Au.call(e16)) : {};
}
function P5(e16, t10) {
  var n = t10 ? Yl(e16.buffer) : e16.buffer;
  return new e16.constructor(n, e16.byteOffset, e16.length);
}
var R5 = "[object Boolean]";
var L5 = "[object Date]";
var F5 = "[object Map]";
var j5 = "[object Number]";
var O5 = "[object RegExp]";
var B5 = "[object Set]";
var Z5 = "[object String]";
var W5 = "[object Symbol]";
var q5 = "[object ArrayBuffer]";
var V5 = "[object DataView]";
var H5 = "[object Float32Array]";
var U5 = "[object Float64Array]";
var G5 = "[object Int8Array]";
var X5 = "[object Int16Array]";
var Y5 = "[object Int32Array]";
var Q5 = "[object Uint8Array]";
var J5 = "[object Uint8ClampedArray]";
var e62 = "[object Uint16Array]";
var t6 = "[object Uint32Array]";
function n6(e16, t10, n) {
  var o = e16.constructor;
  switch (t10) {
    case q5:
      return Yl(e16);
    case R5:
    case L5:
      return new o(+e16);
    case V5:
      return A5(e16, n);
    case H5:
    case U5:
    case G5:
    case X5:
    case Y5:
    case Q5:
    case J5:
    case e62:
    case t6:
      return P5(e16, n);
    case F5:
      return new o();
    case j5:
    case Z5:
      return new o(e16);
    case O5:
      return K5(e16);
    case B5:
      return new o();
    case W5:
      return z5(e16);
  }
}
function o6(e16) {
  return typeof e16.constructor == "function" && !Vl(e16) ? Kv(yf(e16)) : {};
}
var a6 = "[object Map]";
function r6(e16) {
  return Ro(e16) && zn(e16) == a6;
}
var Eu = da && da.isMap;
var i6 = Eu ? Hl(Eu) : r6;
var s6 = "[object Set]";
function l6(e16) {
  return Ro(e16) && zn(e16) == s6;
}
var Ku = da && da.isSet;
var c6 = Ku ? Hl(Ku) : l6;
var u6 = 1;
var d6 = 2;
var f6 = 4;
var Cf = "[object Arguments]";
var m6 = "[object Array]";
var p6 = "[object Boolean]";
var h6 = "[object Date]";
var g6 = "[object Error]";
var kf = "[object Function]";
var v6 = "[object GeneratorFunction]";
var y6 = "[object Map]";
var b6 = "[object Number]";
var Sf = "[object Object]";
var _6 = "[object RegExp]";
var w6 = "[object Set]";
var T6 = "[object String]";
var C6 = "[object Symbol]";
var k6 = "[object WeakMap]";
var S6 = "[object ArrayBuffer]";
var N6 = "[object DataView]";
var M6 = "[object Float32Array]";
var $6 = "[object Float64Array]";
var x6 = "[object Int8Array]";
var I6 = "[object Int16Array]";
var D6 = "[object Int32Array]";
var A6 = "[object Uint8Array]";
var E6 = "[object Uint8ClampedArray]";
var K6 = "[object Uint16Array]";
var z6 = "[object Uint32Array]";
var ot = {};
ot[Cf] = ot[m6] = ot[S6] = ot[N6] = ot[p6] = ot[h6] = ot[M6] = ot[$6] = ot[x6] = ot[I6] = ot[D6] = ot[y6] = ot[b6] = ot[Sf] = ot[_6] = ot[w6] = ot[T6] = ot[C6] = ot[A6] = ot[E6] = ot[K6] = ot[z6] = true;
ot[g6] = ot[kf] = ot[k6] = false;
function kr(e16, t10, n, o, r, a) {
  var i, s = t10 & u6, l = t10 & d6, c = t10 & f6;
  if (i !== void 0)
    return i;
  if (!ao(e16))
    return e16;
  var u = yi(e16);
  if (u) {
    if (i = D5(e16), !s)
      return zv(e16, i);
  } else {
    var d = zn(e16), m = d == kf || d == v6;
    if (mf(e16))
      return p5(e16, s);
    if (d == Sf || d == Cf || m && !r) {
      if (i = l || m ? {} : o6(e16), !s)
        return l ? _5(e16, f5(i, e16)) : y5(e16, d5(i, e16));
    } else {
      if (!ot[d])
        return r ? e16 : {};
      i = n6(e16, d, s);
    }
  }
  a || (a = new _a());
  var p = a.get(e16);
  if (p)
    return p;
  a.set(e16, i), c6(e16) ? e16.forEach(function(g) {
    i.add(kr(g, t10, n, g, e16, a));
  }) : i6(e16) && e16.forEach(function(g, v) {
    i.set(v, kr(g, t10, n, v, e16, a));
  });
  var f = c ? l ? T5 : w5 : l ? Gl : Ul, h10 = u ? void 0 : f(e16);
  return Pv(h10 || e16, function(g, v) {
    h10 && (v = g, g = e16[v]), lf(i, v, kr(g, t10, n, v, e16, a));
  }), i;
}
var P6 = 1;
var R6 = 4;
function Sr(e16) {
  return kr(e16, P6 | R6);
}
var bs = function() {
  return mn.Date.now();
};
var L6 = "Expected a function";
var F6 = Math.max;
var j6 = Math.min;
function O6(e16, t10, n) {
  var o, r, a, i, s, l, c = 0, u = false, d = false, m = true;
  if (typeof e16 != "function")
    throw new TypeError(L6);
  t10 = fu(t10) || 0, ao(n) && (u = !!n.leading, d = "maxWait" in n, a = d ? F6(fu(n.maxWait) || 0, t10) : a, m = "trailing" in n ? !!n.trailing : m);
  function p(_) {
    var M = o, x = r;
    return o = r = void 0, c = _, i = e16.apply(x, M), i;
  }
  function f(_) {
    return c = _, s = setTimeout(v, t10), u ? p(_) : i;
  }
  function h10(_) {
    var M = _ - l, x = _ - c, R = t10 - M;
    return d ? j6(R, a - x) : R;
  }
  function g(_) {
    var M = _ - l, x = _ - c;
    return l === void 0 || M >= t10 || M < 0 || d && x >= a;
  }
  function v() {
    var _ = bs();
    if (g(_))
      return y(_);
    s = setTimeout(v, h10(_));
  }
  function y(_) {
    return s = void 0, m && o ? p(_) : (o = r = void 0, i);
  }
  function k() {
    s !== void 0 && clearTimeout(s), c = 0, o = l = r = s = void 0;
  }
  function T() {
    return s === void 0 ? i : y(bs());
  }
  function w() {
    var _ = bs(), M = g(_);
    if (o = arguments, r = this, l = _, M) {
      if (s === void 0)
        return f(l);
      if (d)
        return clearTimeout(s), s = setTimeout(v, t10), p(l);
    }
    return s === void 0 && (s = setTimeout(v, t10)), i;
  }
  return w.cancel = k, w.flush = T, w;
}
var B6 = "[object Number]";
function Z6(e16) {
  return typeof e16 == "number" || Ro(e16) && Po(e16) == B6;
}
var W6 = /* @__PURE__ */ new Map([
  ["default", "base"],
  ["small", "sm"],
  ["large", "lg"],
  ["base", "base"],
  ["sm", "sm"],
  ["lg", "lg"]
]);
var q6 = /* @__PURE__ */ new Map([
  ["base", "default"],
  ["sm", "small"],
  ["lg", "large"],
  ["default", "default"],
  ["small", "small"],
  ["large", "large"]
]);
function kt(e16) {
  const t10 = inject(fn, "base");
  return computed(() => {
    const n = e16.size || unref(t10);
    let o, r;
    if (typeof n == "object") {
      const { ownSize: a, elSize: i } = n;
      o = a, r = i;
    } else
      o = n, r = n;
    return {
      ownSize: W6.get(_u(o)) ?? "base",
      elSize: q6.get(_u(r)) ?? "default"
    };
  });
}
var V6 = { key: 0 };
var H6 = { key: 1 };
var U6 = defineComponent({
  name: "KButton",
  __name: "button",
  props: {
    type: { default: "" },
    main: { type: Boolean, default: false },
    secondary: { type: Boolean, default: false },
    text: { type: Boolean, default: false },
    icon: { type: Boolean, default: false },
    size: {},
    iconLeft: { default: "" },
    iconRight: { default: "" },
    value: { default: "" },
    disabled: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    loadingIcon: { default: Dp },
    color: { default: "" }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = Dt(8), i = ref(), s = ref(n.color);
    watch(
      () => n.color,
      (m) => {
        var f;
        if (!m)
          return;
        s.value = m;
        const p = (f = Nn(m)) == null ? void 0 : f.colorLevel;
        m && nextTick(() => {
          var h10, g, v, y, k, T;
          if ((g = (h10 = i == null ? void 0 : i.value) == null ? void 0 : h10.$el) != null && g.style) {
            const w = (v = i.value.$el) == null ? void 0 : v.classList, _ = (k = (y = p == null ? void 0 : p["--k-oklch-500"]) == null ? void 0 : y.match(/\(([^)]+)\)/)) == null ? void 0 : k[1];
            for (const M of Y2) {
              const x = `el-button--${M.type}`;
              w != null && w.contains(x) && M.vars.forEach((R) => {
                var I;
                (I = i.value.$el) == null || I.style.setProperty(
                  `--k-button-${R.name}`,
                  p == null ? void 0 : p[`--k-oklch-${R.value}`]
                );
              });
            }
            (T = i.value.$el) == null || T.style.setProperty("--k-button-focus", `rgba(${_}, 0.2)`);
          }
        });
      },
      { immediate: true }
    );
    const l = computed(() => {
      const m = ["primary", "success", "info", "warning", "danger"];
      return n.type && m.includes(n.type) ? `el-button--${n.type}` : "";
    }), c = computed(() => {
      const { ownSize: m } = o.value;
      return m ? `el-button--${m}` : "";
    }), u = computed(() => {
      const m = ["main", "secondary", "text", "icon"];
      if (["primary", "success", "info", "warning", "danger"].includes(n.type))
        return "";
      for (let f = 0; f < m.length; f++)
        if (n[m[f]])
          return "";
      return "k-button--base";
    });
    return t10(Ae({}, i)), (m, p) => (openBlock(), createBlock(unref(ElButton), mergeProps({
      id: unref(a),
      ref_key: "buttonRef",
      ref: i,
      class: ["k-button", [
        "el-button",
        {
          "el-button--main": m.main,
          "el-button--secondary": m.secondary,
          "el-button--text": m.text,
          "el-button--icon": m.icon,
          "is-loading": m.loading,
          "is-disabled": m.disabled,
          "button-loading": m.loading
        },
        l.value,
        c.value,
        u.value,
        unref(r)
      ]],
      loading: m.loading,
      "loading-icon": m.loadingIcon,
      disabled: m.disabled
    }, m.$attrs), {
      default: withCtx(() => [
        renderSlot(m.$slots, "iconLeft", { class: "icon-left" }, () => [
          n.iconLeft ? (openBlock(), createBlock(resolveDynamicComponent(n.iconLeft), { key: 0 })) : createCommentVNode("", true)
        ]),
        n.value && n.icon === false ? (openBlock(), createElementBlock("label", V6, toDisplayString(n.value), 1)) : m.$slots.default ? (openBlock(), createElementBlock("label", H6, [
          renderSlot(m.$slots, "default", { class: "slot-content" })
        ])) : createCommentVNode("", true),
        renderSlot(m.$slots, "iconRight", { class: "icon-right" }, () => [
          n.iconRight ? (openBlock(), createBlock(resolveDynamicComponent(n.iconRight), { key: 0 })) : createCommentVNode("", true)
        ]),
        n.loading ? (openBlock(), createBlock(resolveDynamicComponent(n.loadingIcon), {
          key: 2,
          class: "loading-icon"
        })) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["id", "class", "loading", "loading-icon", "disabled"]));
  }
});
var Lt = $e(U6);
var G6 = defineComponent({
  name: "KInput",
  __name: "input",
  props: {
    size: {},
    iconLeft: { default: void 0 },
    iconRight: { default: void 0 },
    prefixIcon: { default: void 0 },
    suffixIcon: { default: void 0 }
  },
  setup(e16, { expose: t10 }) {
    var p, f, h10, g;
    const o = kt(e16), r = inject("_styleModule", ""), a = useSlots(), i = (p = a.prepend) == null ? void 0 : p.call(a), s = (f = i == null ? void 0 : i[0]) == null ? void 0 : f.type, l = (h10 = a.append) == null ? void 0 : h10.call(a), c = (g = l == null ? void 0 : l[0]) == null ? void 0 : g.type, u = computed(() => (v) => {
      switch (typeof v) {
        case "string":
          return "k-input-slot--htmlTag";
        case "object":
          return "k-input-slot--component";
        case "symbol":
          return "k-input-slot--string";
        default:
          return "";
      }
    });
    provide(fn, o);
    const d = ref();
    return t10(Ae({}, d)), (v, y) => (openBlock(), createBlock(unref(ElInput), mergeProps({
      ref_key: "inputRef",
      ref: d,
      class: [
        "k-input",
        {
          "k-input-has-prepend": a.prepend,
          "k-input-has-append": a.append
        },
        unref(r)
      ]
    }, v.$attrs, {
      "prefix-icon": v.iconLeft ?? v.prefixIcon,
      "suffix-icon": v.iconRight ?? v.suffixIcon,
      size: unref(o).elSize
    }), createSlots({
      prefix: withCtx(() => [
        renderSlot(v.$slots, "prefix")
      ]),
      suffix: withCtx(() => [
        renderSlot(v.$slots, "suffix")
      ]),
      _: 2
    }, [
      a.prepend ? {
        name: "prepend",
        fn: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(u.value(unref(s)))
          }, [
            renderSlot(v.$slots, "prepend")
          ], 2)
        ]),
        key: "0"
      } : void 0,
      a.append ? {
        name: "append",
        fn: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(u.value(unref(c)))
          }, [
            renderSlot(v.$slots, "append")
          ], 2)
        ]),
        key: "1"
      } : void 0
    ]), 1040, ["class", "prefix-icon", "suffix-icon", "size"]));
  }
});
var ro = $e(G6);
var X6 = defineComponent({
  name: "KInputNumber",
  __name: "input_number",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", ""), a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElInputNumber), mergeProps({
      ref_key: "inputNumberRef",
      ref: a,
      class: ["k-input-number", unref(r)]
    }, s.$attrs, {
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var Y6 = $e(X6);
var Q6 = [
  {
    name: "-text-color--hover",
    value: "400"
  },
  {
    name: "-text-color--checked",
    value: "500"
  },
  {
    name: "__inner__border-color--hover",
    value: "400"
  },
  {
    name: "__inner__border-color--checked",
    value: "500"
  },
  {
    name: "__inner__ball-color--normal",
    value: "500"
  },
  {
    name: "__inner__ball-color--hover",
    value: "500"
  },
  {
    name: "__inner__ball-color--checked",
    value: "500"
  },
  {
    name: "__button__border-color--hover",
    value: "400"
  },
  {
    name: "__button__text-color--hover",
    value: "400"
  },
  {
    name: "__button__bg-color--checked",
    value: "500"
  },
  {
    name: "__button__border-color--checked",
    value: "500"
  }
];
var J6 = defineComponent({
  name: "KRadio",
  __name: "radio",
  props: {
    size: {},
    color: { default: "" },
    button: { type: Boolean, default: false }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = ref(n.color), i = ref();
    watch(
      () => n.color,
      (c) => {
        var d;
        if (!c)
          return;
        a.value = c;
        const u = (d = Nn == null ? void 0 : Nn(c)) == null ? void 0 : d.colorLevel;
        nextTick(() => {
          var m, p, f, h10;
          if ((m = i.value.$el) != null && m.style) {
            const g = (f = (p = u == null ? void 0 : u["--k-oklch-500"]) == null ? void 0 : p.match(/\(([^)]+)\)/)) == null ? void 0 : f[1];
            (h10 = i.value.$el) == null || h10.style.setProperty("--radio-color--focus", `rgba(${g}, 0.2)`), Q6.forEach((v) => {
              var y;
              (y = i.value.$el) == null || y.style.setProperty(
                `--radio${v.name}`,
                u == null ? void 0 : u[`--k-oklch-${v.value}`]
              );
            });
          }
        });
      },
      { immediate: true }
    );
    const s = computed(() => {
      const { ownSize: c } = o.value;
      return c ? `k-radio--${c}` : "";
    });
    return t10(Ae({}, i)), (c, u) => (openBlock(), createBlock(unref(ElRadio), mergeProps(c.$attrs, {
      ref_key: "kRadioRef",
      ref: i,
      class: ["k-radio", [s.value, { "is-button": n.button === true }, unref(r)]]
    }), createSlots({ _: 2 }, [
      renderList(c.$slots, (d, m) => ({
        name: m,
        fn: withCtx((p) => [
          renderSlot(c.$slots, m, normalizeProps(guardReactiveProps(p)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Nf = defineComponent({
  name: "KRadioGroup",
  __name: "radio_group",
  props: {
    size: {},
    direction: {},
    button: { type: Boolean, default: false },
    color: {},
    column: { type: Boolean, default: false },
    row: { type: Boolean, default: true }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = ref(null), i = ref(n.color), s = computed(() => o.value.ownSize ? `k-radio-group--${o.value.ownSize}` : "");
    return watch(
      () => n.color,
      (c) => {
        i.value = c;
      }
    ), provide("_fillColor", i), provide(fn, o), t10(Ae({}, a)), (c, u) => (openBlock(), createBlock(unref(ElRadioGroup), mergeProps({
      ref_key: "KRadioGroupRef",
      ref: a,
      class: ["k-radio-group", [
        {
          "k-radio-group--button": n.button === true,
          "k-radio-group--row": n.row === true,
          "k-radio-group--column": n.column === true
        },
        s.value,
        unref(r)
      ]]
    }, c.$attrs), createSlots({ _: 2 }, [
      renderList(c.$slots, (d, m) => ({
        name: m,
        fn: withCtx((p) => [
          renderSlot(c.$slots, m, normalizeProps(guardReactiveProps(p)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Mf = $e(J6, { RadioGroup: Nf });
var $f = tn(Nf);
var ey = [
  {
    name: "-text-color--hover",
    value: "400"
  },
  {
    name: "-text-color--checked",
    value: "500"
  },
  {
    name: "__inner__border-color--hover",
    value: "400"
  },
  {
    name: "__inner__border-color--checked",
    value: "500"
  },
  {
    name: "__inner__bg-color--hover",
    value: "400"
  },
  {
    name: "__inner__bg-color--checked",
    value: "500"
  }
];
var ty = { class: "checkbox__label" };
var ny = defineComponent({
  name: "KCheckbox",
  __name: "checkbox",
  props: {
    size: {},
    label: {},
    color: { default: "" },
    strict: { type: Boolean, default: false }
  },
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = e16, r = ref(), a = Dt(8), i = kt(o), s = ref(o.color), l = ref(), c = ref();
    typeof window < "u" && nextTick(() => {
      l.value = document == null ? void 0 : document.getElementById(a);
    }), watch(
      () => o.color,
      (p) => {
        var h10;
        if (!p)
          return;
        s.value = p;
        const f = (h10 = Nn == null ? void 0 : Nn(p)) == null ? void 0 : h10.colorLevel;
        nextTick(() => {
          var g, v, y, k, T;
          if ((g = l.value) != null && g.style) {
            c.value = (y = (v = l.value) == null ? void 0 : v.parentNode) == null ? void 0 : y.parentNode;
            const w = (k = f == null ? void 0 : f["--k-oklch-500"].match(/\(([^)]+)\)/)) == null ? void 0 : k[1];
            (T = c.value) == null || T.style.setProperty("--checkbox-color--focus", `rgba(${w}, 0.2)`), ey.forEach((_) => {
              var M;
              (M = c.value) == null || M.style.setProperty(
                `--checkbox${_.name}`,
                f == null ? void 0 : f[`--k-oklch-${_.value}`]
              );
            });
          }
        });
      },
      { immediate: true }
    );
    function u(p) {
      var h10;
      if (!o.strict || !p.target || !(p.target instanceof Element))
        return;
      ((h10 = p.target) == null ? void 0 : h10.classList.contains("el-checkbox__inner")) || p.preventDefault();
    }
    const d = computed(() => {
      const { ownSize: p } = i.value;
      return p ? `k-checkbox--${p}` : "";
    });
    return t10(Ae({}, r)), (p, f) => (openBlock(), createBlock(unref(ElCheckbox), mergeProps({
      id: unref(a),
      ref_key: "kCheckboxRef",
      ref: r,
      class: ["k-checkbox", [d.value, unref(n)]]
    }, p.$attrs, {
      label: p.label,
      onClick: u
    }), {
      default: withCtx(() => [
        renderSlot(p.$slots, "default", {}, () => [
          createBaseVNode("span", ty, toDisplayString(o.label), 1)
        ])
      ]),
      _: 3
    }, 16, ["id", "class", "label"]));
  }
});
var xf = defineComponent({
  name: "KCheckboxGroup",
  __name: "checkbox_group",
  props: {
    size: {},
    color: { default: "#409eff" }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = ref(n.color), i = ref(null);
    return watch(
      () => n.color,
      (l) => {
        a.value = l;
      }
    ), provide("useCheckboxGroup", true), provide("_fillColor", a), provide(fn, o), t10(Ae({}, i)), (l, c) => (openBlock(), createBlock(unref(ElCheckboxGroup), mergeProps({
      ref_key: "kCheckboxGroupRef",
      ref: i,
      class: ["k-checkbox-group", unref(r)]
    }, l.$attrs), {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var fa = $e(ny, { CheckboxGroup: xf });
var If = tn(xf);
var oy = defineComponent({
  name: "KSwitch",
  __name: "switch",
  props: {
    switchOnColor: { default: "" },
    switchOffColor: { default: "" },
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = kt(n), a = ref();
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElSwitch), mergeProps({
      ref_key: "kSwitchRef",
      ref: a,
      class: ["k-switch", unref(o)]
    }, s.$attrs, {
      size: unref(r).elSize,
      style: {
        "--el-switch-on-color": n.switchOnColor,
        "--el-switch-off-color": n.switchOffColor
      }
    }), null, 16, ["class", "size", "style"]));
  }
});
var ay = $e(oy);
var ry = { class: "k-dropdown-link" };
var iy = defineComponent({
  name: "KDropdown",
  __name: "dropdown",
  props: {
    title: {},
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = e16, r = kt(o), a = ref();
    return provide(fn, r), t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElDropdown), mergeProps({
      ref_key: "kDropDownRef",
      ref: a,
      class: ["k-dropdown", unref(n)]
    }, s.$attrs, {
      size: unref(r).elSize
    }), {
      dropdown: withCtx(() => [
        createVNode(unref(ElDropdownMenu), null, {
          default: withCtx(() => [
            renderSlot(s.$slots, "default")
          ]),
          _: 3
        })
      ]),
      default: withCtx(() => [
        renderSlot(s.$slots, "title", {}, () => [
          createBaseVNode("span", ry, toDisplayString(o.title), 1)
        ])
      ]),
      _: 3
    }, 16, ["class", "size"]));
  }
});
var Df = defineComponent({
  name: "KDropdownItem",
  __name: "dropdown_item",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElDropdownItem), mergeProps({
      ref_key: "kDropDownItemRef",
      ref: o,
      class: [unref(n)]
    }, a.$attrs), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var ar = $e(iy, { DropdownItem: Df });
var rr = tn(Df);
var sy = defineComponent({
  name: "TabLabel",
  props: {
    tabIndexList: {
      type: Array,
      default: () => []
    },
    tabSlots: {
      type: Object,
      default: () => null
    }
  },
  emits: ["command"],
  setup(e16, {
    slots: t10,
    emit: n
  }) {
    return () => {
      var s, l;
      const a = new Map(e16.tabIndexList.map((c, u) => [c, u])), i = r(jr((l = (s = e16.tabSlots) == null ? void 0 : s.default) == null ? void 0 : l.call(s))).filter((c, u) => a.has(u));
      return createVNode(Fragment, null, [createVNode(ar, {
        trigger: "click",
        disabled: e16.tabIndexList.length === 0,
        maxHeight: "300px",
        onCommand: o
      }, {
        default: () => [i.map((c) => createVNode(rr, {
          key: c.name,
          command: c,
          disabled: c.disabled
        }, {
          default: () => [typeof (c == null ? void 0 : c.label) == "function" ? c.label() : c.label]
        }))],
        ...t10
      })]);
    };
    function o(a) {
      n("command", a);
    }
    function r(a) {
      return a.map((i) => {
        var s;
        if (Cd(i)) {
          const l = {
            ...i.props || {}
          };
          for (const [p, f] of Object.entries(l))
            delete l[p], l[Td(p)] = f;
          const c = i.children || {}, u = ((s = i.props) == null ? void 0 : s.name) !== void 0 ? i.props.name : void 0, {
            label: d = c.label,
            disabled: m
          } = l;
          return {
            name: u,
            label: d,
            disabled: m === "" || m
          };
        }
        return null;
      }).filter((i) => i);
    }
  }
});
var ly = defineComponent({
  name: "KTabs",
  __name: "tabs",
  props: {
    modelValue: { default: void 0 },
    tabPosition: { default: "top" },
    editable: { type: Boolean, default: false },
    addable: { type: Boolean, default: false },
    maxWidth: { default: void 0 },
    type: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(void 0);
    let a = null, i, s = [], l = null;
    const c = ref(), u = ref([]);
    let d = 0;
    onMounted(() => {
      window.addEventListener("resize", f);
    }), onUnmounted(() => {
      window.removeEventListener("resize", f);
    }), nextTick(() => {
      var g;
      a = (g = c == null ? void 0 : c.value) == null ? void 0 : g.$el, i = (a == null ? void 0 : a.querySelector(".el-tabs__nav")) ?? void 0, l = a == null ? void 0 : a.querySelector(".el-tabs__new-tab"), s = (a == null ? void 0 : a.querySelectorAll(".el-tabs__item")) ?? [], f();
    }), watch(
      () => n.maxWidth,
      (g) => {
        g && nextTick(() => {
          a && (a == null || a.style.setProperty("--plane-max-width", g));
        });
      },
      { immediate: true }
    );
    function m(g, v = 0) {
      if (!a)
        return;
      const y = g.getBoundingClientRect(), k = a.getBoundingClientRect(), T = v - d, { width: w, height: _ } = (l == null ? void 0 : l.getBoundingClientRect()) ?? {};
      return n.tabPosition === "top" || n.tabPosition === "bottom" ? y.left + T >= k.left && y.right + T <= k.right - (w ?? 0) : y.top + T >= k.top && y.bottom + T <= k.bottom - (_ ?? 0);
    }
    function p(g) {
      const v = g.name ?? "";
      r.value = v, f();
    }
    function f() {
      setTimeout(() => {
        var T;
        const g = /\(([^)]+)\)/g, v = (T = i == null ? void 0 : i.style.transform) == null ? void 0 : T.match(g);
        if (!v)
          return;
        const [y] = v.map((w) => parseFloat(w.slice(1, -1))), k = [];
        s == null || s.forEach((w, _) => {
          m(w, y) || k.push(_);
        }), d = y, u.value = k;
      });
    }
    return watch(
      () => n.modelValue,
      () => {
        r.value = n.modelValue;
      },
      { immediate: true }
    ), t10(Ae({}, c)), (g, v) => (openBlock(), createBlock(unref(ElTabs), mergeProps({
      ref_key: "KTabsRef",
      ref: c,
      modelValue: r.value,
      "onUpdate:modelValue": v[0] || (v[0] = (y) => r.value = y),
      class: ["k-tabs", unref(o)]
    }, g.$attrs, {
      "tab-position": g.tabPosition,
      editable: g.editable,
      addable: g.addable,
      onTabClick: f
    }), createSlots({
      default: withCtx(() => [
        u.value.length ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["k-tabs-more", `tab-${g.tabPosition}-layout`]),
          style: normalizeStyle({
            right: (g.editable || g.addable) && (g.tabPosition === "top" || g.tabPosition === "bottom") ? "2rem" : 0
          })
        }, [
          createVNode(unref(sy), {
            "tab-index-list": u.value,
            "tab-slots": g.$slots,
            onCommand: p
          }, {
            title: withCtx(() => [
              createVNode(unref(oi))
            ]),
            _: 1
          }, 8, ["tab-index-list", "tab-slots"])
        ], 6)) : createCommentVNode("", true),
        renderSlot(g.$slots, "default")
      ]),
      _: 2
    }, [
      g.$slots.addIcon ? {
        name: "add-icon",
        fn: withCtx(() => [
          renderSlot(g.$slots, "add-icon")
        ]),
        key: "0"
      } : void 0
    ]), 1040, ["modelValue", "class", "tab-position", "editable", "addable"]));
  }
});
var cy = { class: "k-tooltip-icon" };
var uy = defineComponent({
  name: "KTooltip",
  __name: "tooltip",
  props: {
    type: { default: void 0 },
    color: { default: "" },
    textColor: { default: "#FFF" },
    popperStyle: {}
  },
  setup(e16, { expose: t10 }) {
    const n = {
      normal: "#000",
      danger: "#ef4444",
      warning: "#f97316",
      primary: "#2882ff"
    }, o = e16, r = ref(), a = ref(void 0), i = computed(() => {
      const l = o.popperStyle || {};
      return {
        color: o.textColor,
        backgroundColor: a.value,
        borderColor: a.value,
        ...l
      };
    });
    return watch(
      () => [o.type, o.color],
      () => {
        o.color && Jh(o.color) ? a.value = o.color : !o.color && o.type && n[o.type] ? a.value = n[o.type] : a.value = void 0;
      },
      { immediate: true }
    ), t10(Ae({}, r)), (l, c) => (openBlock(), createBlock(unref(ElTooltip), mergeProps({
      ref_key: "tooltipRef",
      ref: r,
      class: "k-tooltip"
    }, l.$attrs, { "popper-style": i.value }), createSlots({
      default: withCtx(() => [
        renderSlot(l.$slots, "default", {}, () => [
          createBaseVNode("i", cy, [
            createVNode(unref(gd), {
              style: normalizeStyle({
                color: a.value,
                width: "15px",
                height: "15px"
              })
            }, null, 8, ["style"])
          ])
        ])
      ]),
      _: 2
    }, [
      l.$slots.content ? {
        name: "content",
        fn: withCtx(() => [
          renderSlot(l.$slots, "content")
        ]),
        key: "0"
      } : void 0
    ]), 1040, ["popper-style"]));
  }
});
var wa = $e(uy);
var Af = defineComponent({
  name: "KTabPane",
  __name: "tab_pane",
  props: {
    closable: {
      type: Boolean,
      default: false
    },
    label: {
      type: String,
      default: ""
    }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(null), a = useSlots(), i = ref(false), s = computed(() => {
      var m, p, f;
      if (a.label) {
        const h10 = ((f = (p = (m = a.label) == null ? void 0 : m.call(a)) == null ? void 0 : p[0]) == null ? void 0 : f.children) ?? "";
        return typeof h10 == "string" ? h10 : null;
      }
      return n.label;
    });
    let l = null;
    function c(m) {
      const p = m.target;
      if (p.clientWidth < p.scrollWidth) {
        l = setTimeout(() => {
          i.value = true;
        }, 500);
        return;
      }
      u();
    }
    function u() {
      l && clearTimeout(l), i.value = false;
    }
    return t10(Ae({}, r)), (m, p) => (openBlock(), createBlock(unref(ElTabPane), mergeProps({
      ref_key: "KTabPaneRef",
      ref: r,
      class: ["k-tab-item", unref(o)]
    }, m.$attrs, {
      closable: n.closable
    }), {
      label: withCtx(() => [
        createVNode(unref(wa), {
          content: s.value,
          visible: i.value && !!s.value
        }, {
          default: withCtx(() => [
            createBaseVNode("span", {
              class: normalizeClass(n.closable ? "k-tab-item-closeable" : ""),
              onMouseenter: c,
              onMouseleave: u
            }, [
              renderSlot(m.$slots, "label", {}, () => [
                createTextVNode(toDisplayString(n.label), 1)
              ])
            ], 34)
          ]),
          _: 3
        }, 8, ["content", "visible"])
      ]),
      default: withCtx(() => [
        renderSlot(m.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "closable"]));
  }
});
var Ef = $e(ly, { TabPane: Af });
var Kf = tn(Af);
var dy = defineComponent({
  name: "KPagination",
  __name: "pagination",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", ""), a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElPagination), mergeProps({
      ref_key: "KPaginationRef",
      ref: a,
      class: ["k-pagination", unref(r)]
    }, s.$attrs, {
      size: unref(o).elSize
    }), null, 16, ["class", "size"]));
  }
});
var zf = $e(dy);
var fy = defineComponent({
  name: "KSelect",
  __name: "select",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", ""), a = ref();
    return provide(fn, o), t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElSelect), mergeProps({
      ref_key: "inputRef",
      ref: a,
      class: ["k-select", [unref(r)]]
    }, s.$attrs, {
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var Pf = defineComponent({
  name: "KOption",
  __name: "option",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElOption), mergeProps({
      ref_key: "KOptionRef",
      ref: o,
      value: "",
      class: ["k-option", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Rf = defineComponent({
  name: "KOptionGroup",
  __name: "option_group",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElOptionGroup), mergeProps({
      ref_key: "KOptionGroupRef",
      ref: o,
      class: ["k-option-group", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Go = $e(fy, { Option: Pf, OptionGroup: Rf });
var vo = tn(Pf);
var my = tn(Rf);
var py = defineComponent({
  name: "KCascader",
  __name: "cascader",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", "");
    provide(fn, o);
    const a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElCascader), mergeProps({
      ref_key: "cascaderRef",
      ref: a,
      class: ["k-cascader", unref(r)]
    }, s.$attrs, {
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var Lf = $e(py);
var hy = defineComponent({
  name: "KDatePicker",
  __name: "date_picker",
  props: {
    size: {},
    shortcuts: {},
    showDefaultShortcuts: { type: Boolean, default: true },
    type: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = inject("$t"), i = ref(null), s = [
      {
        text: a == null ? void 0 : a("within7days"),
        value: () => c(-7)
      },
      {
        text: a == null ? void 0 : a("within15days"),
        value: () => c(-15)
      },
      {
        text: a == null ? void 0 : a("curMonth"),
        value: u()
      },
      {
        text: a == null ? void 0 : a("curQuarter"),
        value: m()
      },
      {
        text: a == null ? void 0 : a("curYear"),
        value: p()
      }
    ], l = computed(() => (n.type === "daterange" || n.type === "datetimerange") && n.showDefaultShortcuts ? [...s, ...n.shortcuts || []] : n.shortcuts);
    function c(h10) {
      const g = /* @__PURE__ */ new Date(), v = /* @__PURE__ */ new Date();
      return v.setDate(v.getDate() + h10), h10 > 0 ? [g, v] : [v, g];
    }
    function u() {
      const h10 = /* @__PURE__ */ new Date();
      h10.setDate(1), h10.setHours(0, 0, 0, 0);
      const g = d(), v = /* @__PURE__ */ new Date();
      return v.setDate(g), v.setHours(23, 59, 59, 59), [h10, v];
    }
    function d() {
      const h10 = (/* @__PURE__ */ new Date()).getMonth() + 1, g = [1, 3, 5, 7, 8, 10, 12], v = [4, 6, 9, 11];
      if (g.includes(h10))
        return 31;
      if (v.includes(h10))
        return 30;
      const y = (/* @__PURE__ */ new Date()).getFullYear();
      return y % 4 === 0 && y % 100 !== 0 || y % 400 === 0 ? 29 : 28;
    }
    function m() {
      const h10 = /* @__PURE__ */ new Date(), g = /* @__PURE__ */ new Date(), v = h10.getMonth(), y = Math.floor(v / 3);
      return h10.setMonth(y * 3), h10.setDate(1), h10.setHours(0, 0, 0, 0), g.setMonth(y * 3 + 2), g.setHours(23, 59, 59, 59), y === 0 || y === 3 ? g.setDate(31) : g.setDate(30), [h10, g];
    }
    function p() {
      const h10 = /* @__PURE__ */ new Date(), g = /* @__PURE__ */ new Date();
      return h10.setMonth(0), h10.setDate(1), h10.setHours(0, 0, 0, 0), g.setMonth(11), g.setDate(31), g.setHours(23, 59, 59, 59), [h10, g];
    }
    return provide(fn, o), t10(Ae({}, i)), (h10, g) => (openBlock(), createBlock(unref(ElDatePicker), mergeProps({
      ref_key: "datePickerRef",
      ref: i,
      class: ["k-date-picker", unref(r)]
    }, h10.$attrs, {
      type: h10.type,
      shortcuts: l.value,
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(h10.$slots, (v, y) => ({
        name: y,
        fn: withCtx((k) => [
          renderSlot(h10.$slots, y, normalizeProps(guardReactiveProps(k)))
        ])
      }))
    ]), 1040, ["class", "type", "shortcuts", "size"]));
  }
});
var Ff = $e(hy);
var gy = {
  key: 0,
  class: "default-sign"
};
var vy = { class: "file-list" };
var yy = ["onClick"];
var by = { class: "header-icon" };
var _y = ["title"];
var wy = { class: "status-icon-box" };
var Ty = { class: "status-icon" };
var Cy = { class: "remove-file" };
var ky = { class: "el-upload__tip" };
var Sy = defineComponent({
  name: "KUpload",
  __name: "upload",
  props: {
    drag: { type: Boolean },
    autoUpload: { type: Boolean },
    disabled: { type: Boolean },
    removeIcon: {},
    successIcon: {},
    failIcon: {},
    onPreview: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(), a = computed(() => (d) => {
      if (d === "success" && n.successIcon)
        return n.successIcon;
      if (d === "success")
        return Tp;
      if (d === "fail" && n.failIcon)
        return n.failIcon;
      if (d === "fail")
        return Rl;
    });
    function i(d) {
      var m;
      d && d.stopPropagation(), d && d.preventDefault(), (m = r.value) == null || m.submit();
    }
    function s(d, m) {
      var p;
      (p = r.value) == null || p.handleRemove(d, m);
    }
    function l(d) {
      var m;
      (m = n.onPreview) == null || m.call(n, d);
    }
    function c() {
      r.value.$el.querySelector("input").click();
    }
    return t10(Ae({ submit: i, selectFile: c, handleRemove: s }, r)), (d, m) => {
      const p = resolveComponent("k-button");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["k-upload", unref(o), { "k-dragger": n.drag }])
      }, [
        createVNode(unref(ElUpload), mergeProps({
          ref_key: "KUploadRef",
          ref: r
        }, d.$attrs, {
          "on-preview": l,
          "auto-upload": d.autoUpload,
          disabled: d.disabled,
          drag: d.drag
        }), {
          trigger: withCtx(() => [
            renderSlot(d.$slots, "trigger", {}, () => [
              n.drag ? (openBlock(), createElementBlock("div", gy, [
                createVNode(unref(Np), { color: "#2882ff" }),
                createTextVNode(" " + toDisplayString(d.$t("uploadDragSign")), 1)
              ])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: "default-upload-btn",
                onClick: m[0] || (m[0] = withModifiers(() => {
                }, ["stop"]))
              }, [
                createVNode(p, {
                  secondary: "",
                  "icon-left": d.autoUpload ? "IconUpload" : "",
                  onClick: c
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(n.autoUpload ? d.$t("uploadFile") : d.$t("selectFile")), 1)
                  ]),
                  _: 1
                }, 8, ["icon-left"]),
                n.autoUpload ? createCommentVNode("", true) : (openBlock(), createBlock(p, {
                  key: 0,
                  main: "",
                  class: "main-btn",
                  disabled: n.disabled,
                  "icon-left": "IconUpload",
                  onClick: i
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(d.$t("uploadFile")), 1)
                  ]),
                  _: 1
                }, 8, ["disabled"]))
              ]))
            ])
          ]),
          file: withCtx(({ file: f }) => [
            renderSlot(d.$slots, "file", {}, () => [
              createBaseVNode("div", vy, [
                createBaseVNode("div", null, [
                  createBaseVNode("a", {
                    onClick: (h10) => l(f)
                  }, [
                    createBaseVNode("span", by, [
                      createVNode(unref(Mp))
                    ]),
                    createBaseVNode("span", {
                      title: f.name
                    }, toDisplayString(f.name), 9, _y)
                  ], 8, yy),
                  f.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                    key: 0,
                    type: "line",
                    "stroke-width": 2,
                    percentage: Number(f.percentage),
                    style: "margin-top: 0.5rem"
                  }, null, 8, ["percentage"])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", wy, [
                  createBaseVNode("span", Ty, [
                    (openBlock(), createBlock(resolveDynamicComponent(a.value(f.status)), {
                      color: f.status === "success" ? "#22c55e" : "#ef4444"
                    }, null, 8, ["color"]))
                  ]),
                  createBaseVNode("span", Cy, [
                    (openBlock(), createBlock(resolveDynamicComponent(n.removeIcon ?? unref(kp)), {
                      color: "#f97316",
                      onClick: (h10) => s(f)
                    }, null, 8, ["onClick"]))
                  ])
                ])
              ])
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", ky, [
              renderSlot(d.$slots, "tip")
            ])
          ]),
          _: 3
        }, 16, ["auto-upload", "disabled", "drag"])
      ], 2);
    };
  }
});
var Ny = $e(Sy);
var My = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_450_84265'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_3105_3983'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_450_84265)'%3e%3cg%20clip-path='url(%23master_svg1_3105_3983)'%3e%3c/g%3e%3cg%20transform='matrix(0,1,-1,0,24,-16)'%3e%3cg%3e%3cg%3e%3cpath%20d='M28,18.5234L21.02422,12.159531C20.911577,12.0567654,20.766101,12,20.615385,12C20.275517,12,20,12.282768,20,12.631579C20,12.811982,20.0751679,12.983774,20.206545,13.10363L27.591160000000002,19.84047C27.82432,20.053179999999998,28.17568,20.053179999999998,28.408839999999998,19.84047L35.7929,13.10416L35.7929,13.10416C35.9248,12.983774,36,12.811982,36,12.631579C36,12.282768,35.7245,12,35.3846,12C35.2339,12,35.0884,12.0567654,34.9758,12.159531L34.9758,12.159531L28,18.5234Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3cg%3e%3cpath%20d='M28,10.523399999999999L21.02422,4.159531C20.911577,4.0567654,20.766101,4,20.615385,4C20.275517,4,20,4.282768,20,4.631579C20,4.811982,20.0751679,4.983774,20.206545,5.10363L27.591160000000002,11.84047C27.82432,12.05318,28.17568,12.05318,28.408839999999998,11.84047L35.7929,5.10416L35.7929,5.10416C35.9248,4.983774,36,4.811982,36,4.631579C36,4.282768,35.7245,4,35.3846,4C35.2339,4,35.0884,4.0567654,34.9758,4.159531L34.9758,4.159531L28,10.523399999999999Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
var $y = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_3069_6476'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_3105_3984'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_3069_6476)'%3e%3cg%20clip-path='url(%23master_svg1_3105_3984)'%3e%3c/g%3e%3cg%20transform='matrix(0,-1,1,0,-16,24)'%3e%3cg%3e%3cg%3e%3cpath%20d='M12,34.39683575515747L5.02422,27.48749075515747C4.911577,27.37591675515747,4.766101,27.31428575515747,4.615385,27.31428575515747C4.275517,27.31428575515747,4,27.62129075515747,4,27.99999975515747C4,28.19586575515747,4.0751679,28.382385755157472,4.206545,28.51250575515747L11.59116,35.82679575515747C11.82432,36.057735755157466,12.17568,36.057735755157466,12.40884,35.82679575515747L19.7929,28.51308575515747L19.7929,28.51308575515747C19.924799999999998,28.382385755157472,20,28.19586575515747,20,27.99999975515747C20,27.62129075515747,19.7245,27.31428575515747,19.3846,27.31428575515747C19.2339,27.31428575515747,19.0884,27.37591675515747,18.9758,27.48749075515747L18.9758,27.48749075515747L12,34.39683575515747Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3cg%3e%3cpath%20d='M12,27.08255L5.02422,20.173205C4.911577,20.061631,4.766101,20,4.615385,20C4.275517,20,4,20.307005,4,20.685714C4,20.88158,4.0751679,21.0681,4.206545,21.19822L11.59116,28.51251C11.82432,28.74345,12.17568,28.74345,12.40884,28.51251L19.7929,21.1988L19.7929,21.1988C19.924799999999998,21.0681,20,20.88158,20,20.685714C20,20.307005,19.7245,20,19.3846,20C19.2339,20,19.0884,20.061631,18.9758,20.173205L18.9758,20.173205L12,27.08255Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
var xy = ["id"];
var Iy = { class: "k-transfer_searcher" };
var Dy = { class: "k-transfer-item" };
var Ay = { class: "k-transfer-label" };
var Ey = {
  id: "draggable",
  class: "k-transfer-sort"
};
var Ky = defineComponent({
  name: "KTransfer",
  __name: "transfer",
  props: {
    modelValue: {},
    data: {},
    filterablePlaceholder: {},
    props: {},
    matchKey: { default: "label" },
    defaultKeys: {},
    filterable: { type: Boolean, default: true }
  },
  emits: [
    "update:modelValue",
    "change",
    "left-check-change",
    "right-check-change",
    "input",
    "reset",
    "sort"
  ],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = n, a = inject("_styleModule", ""), i = inject("$t"), s = ref([]), l = ref(""), c = ref([]);
    let u = null, d, m = [];
    const p = Dt(8);
    onMounted(() => {
      k(), M();
    }), onUnmounted(() => {
      _ == null || _.destroy();
    });
    const f = computed(() => ({
      label: "label",
      key: "key",
      disabled: "disabled",
      ...o.props
    })), h10 = computed(() => o.filterablePlaceholder ?? (i == null ? void 0 : i("searchHeaderName")));
    watch(() => [o.modelValue, o.matchKey], () => {
      s.value = [], Array.isArray(o.modelValue) && o.modelValue.forEach((P) => {
        const F = o.data.find((N) => N[o.matchKey] === P[o.matchKey]);
        if (F) {
          const { key: N } = f.value;
          s.value.push(F[N]);
        }
      });
    }, { immediate: true }), watch(() => o.data, (P) => {
      if (P) {
        Array.isArray(P) || (c.value = [], m.length = 0), c.value = P, m = c.value.map((F) => F[f.value.key]);
        return;
      }
      c.value = [], m.length = 0;
    }, { immediate: true }), watch(() => l.value, (P) => {
      var F;
      if (!(!d || !d.length))
        for (let N = 0; N < d.length; N++) {
          if ((F = d[N]) != null && F.value)
            continue;
          d[N].value = P;
          const j = new Event("input", { bubbles: true });
          d[N].dispatchEvent(j);
        }
    }, { immediate: true });
    function g(P, F, N) {
      const j = w(P);
      r("update:modelValue", j), r("change", P, F, N);
    }
    function v(P, F) {
      r("left-check-change", P, F);
    }
    function y(P, F) {
      r("right-check-change", P, F);
    }
    function k() {
      if (u = document.getElementById(p), u === null)
        return;
      d = u.querySelectorAll(".el-transfer-panel__filter input");
      const P = u.querySelectorAll(".el-transfer-panel__header")[1], F = document.createElement("label");
      F.innerHTML = i == null ? void 0 : i("restoreDefault"), F.classList.add("transfer-restore__text"), F.addEventListener("click", () => {
        T();
      }), P.appendChild(F);
      const N = u.querySelectorAll(".el-transfer__button");
      N[0].innerHTML = `<img class="k-transfer__left-arrow" src="${My}" />`, N[1].innerHTML = `<img class="k-transfer__right-arrow" src="${$y}" />`;
    }
    function T() {
      if (!Array.isArray(o.defaultKeys))
        return;
      const { key: P } = f.value, F = o.data.filter((N) => {
        var j;
        return (j = o.defaultKeys) == null ? void 0 : j.includes(N[P]);
      });
      c.value.sort((N, j) => m.indexOf(N[P]) - m.indexOf(j[P])), r("update:modelValue", F), r("reset", [...o.defaultKeys]), r("sort", c.value);
    }
    function w(P) {
      const F = [], { key: N } = f.value;
      for (const j of P) {
        const z = c.value.find((A) => A[N] === j);
        z && F.push(z);
      }
      return F;
    }
    let _ = null;
    function M() {
      var F, N;
      const P = (N = (F = document.getElementById(p)) == null ? void 0 : F.querySelectorAll(".el-transfer-panel__list")) == null ? void 0 : N[1];
      P && (_ = new sortable_esm_default(P, {
        handle: ".k-transfer-sort",
        animation: 150,
        onEnd: (j) => {
          var D;
          const { newIndex: z, oldIndex: A } = j;
          if (z === A || z === void 0 || A === void 0)
            return;
          s.value.splice(z, 0, s.value.splice(A, 1)[0]), c.value = yd(c.value, s.value, ((D = o.props) == null ? void 0 : D.key) ?? "key");
          const B = w(s.value);
          r("update:modelValue", B), r("sort", c.value);
        }
      }));
    }
    function x() {
      return {
        sourceData: c.value,
        selectData: w(s.value)
      };
    }
    const R = ref(null);
    return t10(Ae({ getTransferData: x }, R)), (P, F) => (openBlock(), createElementBlock("div", {
      id: unref(p),
      class: normalizeClass(["k-transfer", unref(a)])
    }, [
      createBaseVNode("div", Iy, [
        P.filterable ? (openBlock(), createBlock(unref(ro), {
          key: 0,
          modelValue: l.value,
          "onUpdate:modelValue": F[0] || (F[0] = (N) => l.value = N),
          placeholder: h10.value,
          "prefix-icon": unref(Dr)
        }, null, 8, ["modelValue", "placeholder", "prefix-icon"])) : createCommentVNode("", true)
      ]),
      createVNode(unref(ElTransfer), mergeProps({
        ref_key: "kTransferRef",
        ref: R,
        modelValue: s.value,
        "onUpdate:modelValue": F[1] || (F[1] = (N) => s.value = N)
      }, P.$attrs, {
        data: c.value,
        props: o.props,
        format: {
          noChecked: " ",
          hasChecked: " "
        },
        filterable: "",
        onChange: g,
        onLeftCheckChange: v,
        onRightCheckChange: y
      }), {
        default: withCtx(({ option: N }) => [
          createBaseVNode("div", Dy, [
            createBaseVNode("span", Ay, toDisplayString(N[f.value.label]), 1),
            createBaseVNode("span", Ey, [
              s.value.includes(N[f.value.key]) ? (openBlock(), createBlock(unref(bl), { key: 0 })) : createCommentVNode("", true)
            ])
          ])
        ]),
        _: 1
      }, 16, ["modelValue", "data", "props"])
    ], 10, xy));
  }
});
var jf = $e(Ky);
var zy = { class: "k-operate__header" };
var Py = { class: "k-operate__content" };
var Ry = { class: "k-operate__list" };
var Ly = { class: "list-header" };
var Fy = ["onClick"];
var jy = { class: "k-operate-list__label" };
var Oy = {
  key: 0,
  class: "k-operate-rest"
};
var By = { class: "el-dropdown-link" };
var Zy = { class: "k-operate__close" };
var Wy = defineComponent({
  name: "KOperate",
  __name: "operate",
  props: {
    data: { default: () => [] },
    max: { default: 5 },
    total: { default: 0 },
    hideOnClick: { type: Boolean, default: true }
  },
  emits: ["close"],
  setup(e16, { emit: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref([]), a = ref([]);
    watch(() => [n.data, n.max], () => {
      var u;
      if (!Array.isArray(n.data)) {
        a.value = [], r.value = [];
        return;
      }
      const { max: c } = n;
      ((u = n.data) == null ? void 0 : u.length) > c ? (a.value = n.data.slice(0, c), r.value = n.data.slice(c)) : (a.value = n.data, r.value = []);
    }, { immediate: true, deep: true });
    const i = t10;
    function s(c) {
      const { disabled: u, handler: d } = c;
      u || typeof d == "function" && d();
    }
    function l() {
      i("close");
    }
    return (c, u) => Number.isInteger(c.total) && c.total > 0 ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["k-operate", unref(o)])
    }, [
      createBaseVNode("span", zy, toDisplayString(c.total || "-"), 1),
      createBaseVNode("div", Py, [
        createBaseVNode("ul", Ry, [
          createBaseVNode("li", Ly, toDisplayString(c.$t("batchOperation")) + ":", 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (d, m) => (openBlock(), createElementBlock("li", {
            key: m,
            class: normalizeClass(["k-operate-list__item", { "k-operate-list__item--disabled": d.disabled }]),
            onClick: (p) => s(d)
          }, [
            createBaseVNode("span", jy, toDisplayString(d.label), 1)
          ], 10, Fy))), 128)),
          r.value.length ? (openBlock(), createElementBlock("li", Oy, [
            createVNode(unref(ar), {
              trigger: "click",
              "hide-on-click": c.hideOnClick
            }, {
              title: withCtx(() => [
                createBaseVNode("span", By, [
                  createVNode(unref(oi), { color: "#2882FF" })
                ])
              ]),
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (d, m) => (openBlock(), createBlock(unref(rr), {
                  key: m,
                  disabled: d.disabled,
                  class: "k-dropdown-item__content",
                  onClick: (p) => s(d)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(d.label), 1)
                  ]),
                  _: 2
                }, 1032, ["disabled", "onClick"]))), 128))
              ]),
              _: 1
            }, 8, ["hide-on-click"])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", Zy, [
          createVNode(unref(yl), { onClick: l })
        ])
      ])
    ], 2)) : createCommentVNode("", true);
  }
});
var Of = $e(Wy);
var qy = [
  // block colors
  {
    name: "__block__bg-color--normal",
    value: "500"
  },
  {
    name: "__block__bg-color--hover",
    value: "400"
  },
  // point colors
  {
    name: "__point-color--normal",
    value: "500"
  },
  {
    name: "__point-color--hover",
    value: "400"
  },
  {
    name: "__point-color--active",
    value: "300"
  },
  // border colors
  {
    name: "__border__border-color--normal",
    value: "500"
  },
  {
    name: "__border__border-color--hover",
    value: "400"
  },
  {
    name: "__border__bg-color--normal",
    value: "50"
  },
  {
    name: "__border__bg-color--hover",
    value: "50"
  },
  {
    name: "__border__text-color--normal",
    value: "500"
  },
  {
    name: "__border__text-color--hover",
    value: "400"
  }
];
var Vy = defineComponent({
  name: "KTag",
  __name: "tag",
  props: {
    type: { default: void 0 },
    color: {},
    size: {},
    point: { type: Boolean, default: false },
    text: { default: void 0 },
    border: { type: Boolean }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = kt(n), a = ref(), i = ref(n.color);
    return watch(
      () => n.color,
      (l) => {
        var u;
        if (!l)
          return;
        i.value = l;
        const c = (u = Nn == null ? void 0 : Nn(l)) == null ? void 0 : u.colorLevel;
        nextTick(() => {
          var d, m, p, f, h10;
          if ((m = (d = a.value) == null ? void 0 : d.$el) != null && m.style) {
            const g = (f = (p = c == null ? void 0 : c["--k-oklch-500"]) == null ? void 0 : p.match(/\(([^)]+)\)/)) == null ? void 0 : f[1];
            (h10 = a.value.$el) == null || h10.style.setProperty("--tag-color--focus", `rgba(${g}, 0.2)`), qy.forEach((v) => {
              var y;
              (y = a.value.$el) == null || y.style.setProperty(
                `--tag${v.name}`,
                c == null ? void 0 : c[`--k-oklch-${v.value}`]
              );
            });
          }
        });
      },
      { immediate: true }
    ), t10(Ae({}, a)), (l, c) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["k-tag", unref(o)])
    }, [
      createVNode(unref(ElTag), mergeProps({
        ref_key: "KTagRef",
        ref: a,
        class: [
          { "is-border": l.border },
          { "is-point": l.point },
          { [`k-tag__${l.type}`]: l.type },
          { "is-custom": i.value }
        ]
      }, l.$attrs, {
        size: unref(r).elSize
      }), {
        default: withCtx(() => [
          createBaseVNode("span", null, [
            renderSlot(l.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(n.text), 1)
            ])
          ])
        ]),
        _: 3
      }, 16, ["class", "size"])
    ], 2));
  }
});
var Hy = $e(Vy);
var Uy = defineComponent({
  name: "KPopover",
  __name: "popover",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElPopover), mergeProps({
      ref_key: "KPopoverRef",
      ref: o,
      class: ["k-popover", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Io = $e(Uy);
var Gy = defineComponent({
  name: "KPopconfirm",
  __name: "popconfirm",
  props: {
    icon: { default: Cp }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(null);
    return t10(Ae({}, r)), (i, s) => (openBlock(), createBlock(unref(ElPopconfirm), mergeProps({
      ref_key: "KPopconfirmRef",
      ref: r,
      class: ["k-popconfirm", unref(o)]
    }, i.$attrs, {
      icon: n.icon,
      "cancel-button-type": "default"
    }), createSlots({ _: 2 }, [
      renderList(i.$slots, (l, c) => ({
        name: c,
        fn: withCtx((u) => [
          renderSlot(i.$slots, c, normalizeProps(guardReactiveProps(u)))
        ])
      }))
    ]), 1040, ["class", "icon"]));
  }
});
var Xy = $e(Gy);
var Yy = { style: { "max-width": "12vw", "max-height": "12vw", display: "flex", "justify-content": "center", "align-items": "center", margin: "0 auto", overflow: "hidden" } };
var Qy = {
  key: 0,
  class: "def-bg"
};
var Jy = ["data-h1"];
var e32 = { key: 1 };
var t3 = { key: 2 };
var n3 = {
  key: 1,
  class: "def-bg"
};
var o3 = { key: 1 };
var a3 = { key: 3 };
var r3 = { style: { display: "flex", "flex-direction": "column", "align-items": "center" } };
var i3 = {
  key: 0,
  class: "base-title"
};
var s3 = {
  key: 1,
  class: "base-title"
};
var l3 = { class: "base-subTitle" };
var c3 = { style: { display: "flex" } };
var u3 = defineComponent({
  name: "KResult",
  __name: "result",
  props: {
    status: { default: "" },
    title: { default: "" },
    content: {}
  },
  setup(e16) {
    const t10 = e16, n = inject("_styleModule", ""), o = ["403", "404", "500"], r = ["success", "warning", "info", "error"], a = computed(() => {
      switch (t10.status) {
        case "403":
          return { title: "", color: "#a26ef4" };
        case "404":
          return { title: "", color: "#1890ff" };
        case "500":
          return { title: "", color: "#ff603b" };
        case "success":
          return { title: "success", color: "#52c41a" };
        case "warning":
          return { title: "warning", color: "#faad14" };
        case "info":
          return { title: "info", color: "#1890ff" };
        case "error":
          return { title: "error", color: "#ff4d4f" };
        default:
          return {
            title: ",  status / title / subTitle ,  #icon / #extra ",
            color: "#ff4d4f"
          };
      }
    });
    return (i, s) => {
      const l = resolveComponent("IconLocked"), c = resolveComponent("IconCheck"), u = resolveComponent("IconClose");
      return openBlock(), createElementBlock("div", {
        id: "KResult",
        class: normalizeClass(["k-result", [unref(n)]])
      }, [
        createBaseVNode("div", Yy, [
          renderSlot(i.$slots, "icon", {}, () => [
            o.includes(i.status) ? (openBlock(), createElementBlock("div", Qy, [
              createBaseVNode("h1", { "data-h1": i.status }, [
                createTextVNode(toDisplayString(i.status) + " ", 1),
                createBaseVNode("div", {
                  class: "presuppose-icon",
                  style: normalizeStyle({ backgroundColor: a.value.color })
                }, [
                  i.status == "403" ? (openBlock(), createBlock(l, {
                    key: 0,
                    size: "1.8vw",
                    color: "#FFFFFF"
                  })) : createCommentVNode("", true),
                  i.status == "404" ? (openBlock(), createElementBlock("span", e32, "?")) : createCommentVNode("", true),
                  i.status == "500" ? (openBlock(), createElementBlock("span", t3, "!")) : createCommentVNode("", true)
                ], 4)
              ], 8, Jy),
              s[0] || (s[0] = createStaticVNode('<svg width="1132px" height="1098px" viewBox="0 0 1132 1098" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" data-v-2c7b8a62><g id="-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" data-v-2c7b8a62><g id="" transform="translate(-170, 0)" fill-rule="nonzero" data-v-2c7b8a62><g id="undraw_read_notes_gqmq" transform="translate(170, 0)" data-v-2c7b8a62><path id="" d="M1132,566.004115 C1132,878.608187 941.771293,858.439574 629.169503,858.439574 C559.683535,858.439574 429.971413,1119.48065 368.484892,1096.57632 L368.466007,1096.57632 C366.201988,1095.74618 363.956855,1094.87838 361.711702,1093.99156 C361.070292,1093.76516 360.428788,1093.51989 359.806263,1093.25574 C356.278197,1091.89739 352.768922,1090.48238 349.278626,1089.02959 C342.090426,1086.04871 334.977656,1082.91677 327.959312,1079.67173 C324.318065,1077.97368 320.69557,1076.25684 317.110979,1074.48336 C283.830162,1058.16354 252.379448,1038.65521 223.155001,1016.37351 C208.438908,1005.16663 194.270022,993.22402 180.742661,980.658672 C169.535861,970.244272 158.76307,959.39586 148.461814,948.113436 C145.216691,944.585343 142.04711,941.019499 138.915281,937.415996 C137.632366,935.963214 136.387091,934.510546 135.160833,933.057764 C126.274596,922.662136 117.784596,911.926925 109.671949,900.889882 C107.049463,897.324038 104.46473,893.720516 101.917768,890.079128 C84.6169594,865.363653 69.2406832,839.176529 55.9962459,811.781893 C20.1118094,737.446761 0,654.074336 0,566.004115 C0,253.400042 253.398229,0 566.000019,0 C878.601808,0 1132,253.400042 1132,566.004115 Z" fill="#eaeaea" data-v-2c7b8a62></path><path id="" d="M169.71637,924.60466 C169.71637,925.50539 170.43968,926.22869 171.3404,926.22869 L980.98032,926.22869 C981.88101,926.22869 982.60435,925.50538 982.60435,924.60466 C982.60435,923.70394 981.881,922.98063 980.98032,922.98063 L171.3404,922.98063 C170.43968,922.98063 169.71637,923.70394 169.71637,924.60466 Z" fill="#c2c3cb" data-v-2c7b8a62></path><path id="" d="M589.55989,764.33668 C587.33679,777.81193 575.61059,788.1245 561.51566,788.1245 C547.42073,788.1245 535.69457,777.81193 533.47147,764.33668 L461.72286,764.33668 L461.72286,919.82785 L661.30849,919.82785 L661.30849,764.33668 L589.55986,764.33668 L589.5599,764.33668 L589.55989,764.33668 Z" fill="#B6B3C5" data-v-2c7b8a62></path><rect id="" fill="#B6B3C5" x="465.204" y="919.24777" width="19.72649" height="3.48113" data-v-2c7b8a62></rect><rect id="" fill="#B6B3C5" x="639.84147" y="919.82798" width="19.72649" height="3.48113" data-v-2c7b8a62></rect><path id="" d="M962.90439,768.39805 L160.12674,768.39805 C153.99139,768.39805 149,763.40634 149,757.27126 L149,299.12674 C149,292.99168 153.99139,288 160.12674,288 L962.90439,288 C969.03976,288 974.03139,292.99168 974.03139,299.12674 L974.03139,757.2713 C974.03139,763.40638 969.03968,768.39805 962.90439,768.39805 L962.90439,768.39805 Z" fill="#c2c3cb" data-v-2c7b8a62></path><rect id="" fill="#FFFFFF" x="169.30667" y="307.72662" width="785.57844" height="443.26583" data-v-2c7b8a62></rect></g></g></g></svg>', 1))
            ])) : createCommentVNode("", true),
            r.includes(i.status) ? (openBlock(), createElementBlock("div", n3, [
              createBaseVNode("div", {
                class: "presuppose-icon",
                style: normalizeStyle({ backgroundColor: a.value.color })
              }, [
                i.status == "success" ? (openBlock(), createBlock(c, {
                  key: 0,
                  size: "1.8vw",
                  color: "#FFFFFF"
                })) : createCommentVNode("", true),
                i.status == "warning" ? (openBlock(), createElementBlock("span", o3, "!")) : createCommentVNode("", true),
                i.status == "error" ? (openBlock(), createBlock(u, {
                  key: 2,
                  size: "1.8vw",
                  color: "#FFFFFF"
                })) : createCommentVNode("", true),
                i.status == "info" ? (openBlock(), createElementBlock("span", a3, "i")) : createCommentVNode("", true)
              ], 4)
            ])) : createCommentVNode("", true)
          ], true)
        ]),
        renderSlot(i.$slots, "title", {}, () => [
          createBaseVNode("div", r3, [
            i.title ? (openBlock(), createElementBlock("p", s3, toDisplayString(i.title), 1)) : (openBlock(), createElementBlock("p", i3, toDisplayString(a.value.title), 1)),
            createBaseVNode("p", l3, toDisplayString(i.content), 1)
          ])
        ], true),
        createBaseVNode("div", c3, [
          renderSlot(i.$slots, "extra", {}, void 0, true)
        ])
      ], 2);
    };
  }
});
var Ta = (e16, t10) => {
  const n = e16.__vccOpts || e16;
  for (const [o, r] of t10)
    n[o] = r;
  return n;
};
var d3 = Ta(u3, [["__scopeId", "data-v-2c7b8a62"]]);
var f3 = $e(d3);
var m3 = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_3253_09938'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_3253_09939'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_3253_09938)'%3e%3cg%20clip-path='url(%23master_svg1_3253_09939)'%3e%3c/g%3e%3cg%3e%3cpath%20d='M8.6666259765625,11.375L3.6666259765625,11.375C3.3214479765625002,11.375,3.0416259765625,11.654822,3.0416259765625,12C3.0416259765625,12.345178,3.3214479765625002,12.625,3.6666259765625,12.625L8.0416259765625,12.625L8.0416259765625,14.5C8.0416259765625,14.84518,8.3214459765625,15.125,8.6666259765625,15.125L15.3333259765625,15.125C15.6784259765625,15.125,15.9583259765625,14.84518,15.9583259765625,14.5L15.9583259765625,12.625L20.3333259765625,12.625C20.6784259765625,12.625,20.9583259765625,12.345178,20.9583259765625,12C20.9583259765625,11.654822,20.6784259765625,11.375,20.3333259765625,11.375L15.3333259765625,11.375C14.9881259765625,11.375,14.7083259765625,11.654822,14.7083259765625,12L14.7083259765625,13.875L9.2916259765625,13.875L9.2916259765625,12C9.2916259765625,11.654822,9.0118059765625,11.375,8.6666259765625,11.375Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3cg%3e%3cpath%20d='M20.9185259765625,11.780555876464843C20.9448259765625,11.850725876464843,20.9583259765625,11.925055876464842,20.9583259765625,12.000005876464844L20.9583259765625,17.000035876464842Q20.9583259765625,17.949235876464844,20.2871259765625,18.620435876464846Q19.6158259765625,19.291635876464845,18.6666259765625,19.291635876464845L5.3332959765625,19.291635876464845Q4.3840559765625,19.291635876464845,3.7128399765625,18.620435876464846Q3.0416259765625,17.949235876464844,3.041626026233,17.000035876464842L3.0416259765625,12.000005876464844C3.041626026233,11.925055876464842,3.0551053765625,11.850725876464843,3.0814202765625,11.780555876464843L5.1758759765625,6.1953458764648435Q5.4274359765625,5.524509876464844,6.0163059765625,5.116422876464844Q6.6051759765625,4.708335876464844,7.3216259765625,4.708335876464844L16.678325976562498,4.7083359758059435Q17.394725976562498,4.708336025476844,17.9836259765625,5.116422876464844Q18.572525976562503,5.524510876464844,18.824025976562503,6.1953458764648435L20.9185259765625,11.780555876464843ZM17.653625976562502,6.634245876464844L19.7083259765625,12.113335876464845L19.7083259765625,17.000035876464842Q19.7083259765625,17.431435876464846,19.4032259765625,17.736535876464842Q19.0981259765625,18.041635876464845,18.6666259765625,18.041635876464845L5.3332959765625,18.041635876464845Q4.9018159765625,18.041635876464845,4.5967259765624995,17.736535876464842Q4.2916259765625,17.431435876464846,4.2916259765625,17.000035876464842L4.2916259765625,12.113335876464845L6.3462859765625,6.634245876464844Q6.5997559765625,5.958335876464844,7.3216259765625,5.958335876464844L16.678325976562498,5.958335876464844Q17.4001259765625,5.958335876464844,17.653625976562502,6.634245876464844Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
var p3 = ["src"];
var h3 = defineComponent({
  name: "KEmpty",
  __name: "empty",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElEmpty), mergeProps({
      ref_key: "KEmptyRef",
      ref: o,
      class: ["k-empty", unref(n)]
    }, a.$attrs), createSlots({
      image: withCtx(() => [
        renderSlot(a.$slots, "icon", {}, () => [
          createBaseVNode("img", { src: unref(m3) }, null, 8, p3)
        ])
      ]),
      _: 2
    }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var g3 = $e(h3);
var Js = (e16) => {
  if (typeof e16 == "string")
    e16 = {
      message: e16
    };
  else {
    const { type: t10 } = e16;
    t10 === "warning" && (e16.icon = Rl);
  }
  return ElMessage(e16);
};
["success", "error", "info", "warning"].forEach((e16) => {
  const t10 = e16;
  Js[e16] = (n) => (typeof n == "string" ? n = {
    message: n,
    type: t10
  } : (e16 === "warning" && (n.icon = Rl), n.type = t10), Js(n));
});
var Bf = H2(Js, "$message");
var v3 = defineComponent({
  name: "KDialog",
  __name: "dialog",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref();
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElDialog), mergeProps({
      ref_key: "kDialogRef",
      ref: o,
      class: ["k-dialog", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Zf = $e(v3);
var zu = [
  {
    label: "exactDate",
    value: "date"
  },
  {
    label: "dateRange",
    value: "range"
  },
  {
    label: "today",
    value: "today"
  },
  {
    label: "tomorrow",
    value: "tomorrow"
  },
  {
    label: "yesterday",
    value: "yesterday"
  },
  {
    label: "thisWeek",
    value: "current-week"
  },
  {
    label: "lastWeek",
    value: "last-week"
  },
  {
    label: "thisMonth",
    value: "current-month"
  },
  {
    label: "lastMonth",
    value: "last-month"
  },
  {
    label: "withinThePastSevenDays",
    value: "past-seven-days"
  },
  {
    label: "withinThePastThirtyDays",
    value: "past-thirty-days"
  }
];
var _s = [
  {
    type: "number",
    logicList: [
      {
        logic: "equal",
        handler(e16, t10) {
          return Number(e16) === Number(t10);
        }
      },
      {
        logic: "gt",
        handler(e16, t10) {
          return Number(e16) > Number(t10);
        }
      },
      {
        logic: "lt",
        handler(e16, t10) {
          return Number(e16) < Number(t10);
        }
      },
      {
        logic: "gte",
        handler(e16, t10) {
          return Number(e16) >= Number(t10);
        }
      },
      {
        logic: "lte",
        handler(e16, t10) {
          return Number(e16) <= Number(t10);
        }
      },
      {
        logic: "notEqual",
        handler(e16, t10) {
          return Number(e16) !== Number(t10);
        }
      },
      {
        logic: "empty",
        handler(e16) {
          return e16 == null || !e16.toString();
        }
      },
      {
        logic: "nonEmpty",
        handler(e16) {
          return !(e16 == null || !e16.toString());
        }
      }
    ]
  },
  {
    type: "string",
    logicList: [
      {
        logic: "equal",
        handler(e16, t10, n) {
          return n ? e16.toLowerCase() === t10.toLowerCase() : e16 === t10;
        }
      },
      {
        logic: "notEqual",
        handler(e16, t10, n) {
          return n ? e16.toLowerCase() === t10.toLowerCase() : e16 !== t10;
        }
      },
      {
        logic: "contain",
        handler(e16, t10, n) {
          return n ? e16.toLowerCase() === t10.toLowerCase() : e16.includes(t10);
        }
      },
      {
        logic: "empty",
        handler(e16) {
          return !e16;
        }
      },
      {
        logic: "nonEmpty",
        handler(e16) {
          return e16;
        }
      }
    ]
  },
  {
    type: "date",
    logicList: [
      {
        logic: "equal",
        handler(e16, t10) {
          return Array.isArray(t10) ? gn(e16) > gn(t10[0]) && gn(e16) < gn(t10[1]) : gn(e16) === gn(t10);
        }
      },
      {
        logic: "before",
        handler(e16, t10) {
          return gn(e16) < gn(t10);
        }
      },
      {
        logic: "after",
        handler(e16, t10) {
          return gn(e16) > gn(t10);
        }
      },
      {
        logic: "empty",
        handler(e16) {
          return !e16;
        }
      },
      {
        logic: "nonEmpty",
        handler(e16) {
          return e16;
        }
      }
    ]
  }
];
function gn(e16) {
  return e16 instanceof Date ? e16.getTime() : new Date(e16).getTime();
}
var y3 = { key: 1 };
var b3 = { class: "k-filter__content" };
var _3 = { class: "k-filter__header" };
var w3 = ["title"];
var T3 = { class: "k-filter__condition" };
var C3 = { class: "k-filter__logic" };
var k3 = ["title"];
var S3 = {
  key: 0,
  class: "k-filter__date-box"
};
var N3 = ["onClick"];
var M3 = { class: "k-filer__operate-left" };
var $3 = { class: "k-filer__operate-right" };
var x3 = { class: "select-label" };
var I3 = defineComponent({
  name: "KFilter",
  __name: "filter",
  props: {
    data: { default: () => [] },
    column: {},
    options: {},
    border: { type: Boolean, default: true },
    size: {},
    childrenField: { default: "children" },
    filterKey: { default: "title" },
    defaultCondition: {},
    remote: { type: [Boolean, Array] },
    formatter: {},
    ignoreCase: { type: Boolean, default: false },
    showPopper: { type: Boolean }
  },
  emits: ["confirm", "clear", "show", "hide"],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = kt(o);
    onMounted(() => {
      ["column"].forEach((K) => {
        o[K] && console.warn(`[KFilter] The "${K}" field is deprecated, please use "options" instead.`);
      });
    });
    const a = ref(""), i = inject("_styleModule", ""), s = n, l = inject("$t"), c = ref([]), u = ref(0), d = computed(() => Fr(Sr(o.options), "group")), m = computed(
      () => function(E) {
        var ee;
        return (ee = d.value) == null ? void 0 : ee.find((V) => V[o.filterKey] === E);
      }
    ), p = computed(
      () => function(E) {
        var V;
        const K = (V = d.value) == null ? void 0 : V.find((le) => le[o.filterKey] === E.key), ee = (K == null ? void 0 : K.dataType) || "string";
        return _s.find((le) => le.type === ee);
      }
    ), f = computed(
      () => function(E) {
        if (E.logic === "equal")
          return zu;
        const K = ["past-seven-days", "past-thirty-days"];
        return zu.filter((ee) => !K.includes(ee.value));
      }
    ), h10 = computed(() => c.value.some(
      (E) => E.key && E.logic && (E.value || ["empty", "nonEmpty"].includes(E.logic))
    )), g = computed(
      () => function(E) {
        const K = ["empty", "nonEmpty"];
        return !E.logic || K.includes(E.logic);
      }
    ), v = computed(
      () => function(E) {
        const K = ["date", "range"];
        return g.value(E) || !K.includes(E.dateRange);
      }
    ), y = computed(() => {
      const E = c.value.map((K) => K.key);
      return o.remote === true || Array.isArray(o.remote) && o.remote.some((K) => E.includes(K));
    });
    watch(
      () => y.value,
      (E) => {
        E && (u.value = 1);
      },
      { immediate: true }
    ), k();
    function k() {
      var K, ee, V;
      u.value = ((K = o.defaultCondition) == null ? void 0 : K.filterRule) ?? 0;
      const { conditionList: E = [] } = o.defaultCondition ?? {};
      if (!Array.isArray(E) || !E.length) {
        T();
        return;
      }
      for (let le = 0; le < E.length; le++)
        T();
      for (let le = 0; le < c.value.length; le++) {
        const pe = c.value[le], { title: Te, logic: Z, value: X, showValue: Q, key: W, handler: de } = E[le];
        pe.title = Te.split("-"), pe.logic = Z, pe.value = X, pe.showValue = Q, pe.key = W, pe.handler = de;
        const Ne = (ee = d.value) == null ? void 0 : ee.find((Pe) => Pe[o.filterKey] === W);
        pe._allowSelectLogic = !((V = Ne.options) != null && V.length), Ne.dataType === "date" && !Array.isArray(X) ? (pe.dateRange = "date", pe.dateType = "datetime") : Ne.dataType === "date" && Array.isArray(X) && (pe.dateRange = "range", pe.dateType = "datetimerange");
      }
    }
    function T() {
      const E = {
        title: [],
        logic: "",
        showValue: "",
        value: "",
        key: "",
        handler: null,
        dateRange: "date",
        dateType: "datetime"
      };
      c.value.push(E);
    }
    function w(E) {
      if (E === 0 && c.value.length === 1) {
        _(false);
        return;
      }
      c.value.splice(E, 1);
    }
    function _(E = true) {
      return c.value.length = 0, T(), E ? x() : {};
    }
    function M() {
      const { conditionInfo: E, tableData: K } = x();
      s("confirm", E, K ?? []);
    }
    function x(E) {
      const K = Array.isArray(E) ? E : o.data, ee = R();
      if (ee.conditionList.length === 0 || o.remote === true)
        return {
          conditionInfo: ee,
          tableData: K
        };
      const V = I(), le = K == null ? void 0 : K.filter((pe) => u.value === 0 ? ee.conditionList.some((Te) => {
        var X, Q;
        if (V.has(Te.key))
          return true;
        const Z = (X = d.value) == null ? void 0 : X.find((W) => W[o.filterKey] === Te.key);
        return !Z || !Z[o.filterKey] ? false : (Q = Te.handler) == null ? void 0 : Q.call(Te, pe[Z[o.filterKey]], Te.value, o.ignoreCase);
      }) : ee.conditionList.every((Te) => {
        var X, Q;
        if (V.has(Te.key))
          return true;
        const Z = (X = d.value) == null ? void 0 : X.find((W) => W[o.filterKey] === Te.key);
        return !Z || !Z[o.filterKey] ? false : (Q = Te.handler) == null ? void 0 : Q.call(Te, pe[Z[o.filterKey]], Te.value, o.ignoreCase);
      }));
      return {
        conditionInfo: ee,
        tableData: le ?? []
      };
    }
    function R() {
      const E = ["empty", "nonEmpty"];
      return {
        conditionList: c.value.filter(
          (ee) => ee.key && ee.logic && (vd(ee.value) || E.includes(ee.logic))
        ).map((ee) => ({
          title: ee.title.join(" - "),
          logic: l == null ? void 0 : l(ee.logic),
          key: ee.key,
          showValue: ee.showValue,
          value: ee.value,
          handler: ee.handler
        })),
        filterRule: u.value
      };
    }
    function I() {
      return Array.isArray(o.remote) ? new Map(o.remote.map((E, K) => [E, K])) : /* @__PURE__ */ new Map();
    }
    function P(E) {
      var Te;
      const K = c.value[E], ee = K.title ?? [];
      if (ee.length === 0) {
        K.key = null, K.logic = "equal", K.value = "", K.showValue = "";
        return;
      }
      let V = o.options ?? [], le;
      for (const Z of ee)
        le = V == null ? void 0 : V.find((X) => X.title === Z), V = (le == null ? void 0 : le.group) ?? [];
      K.key = le == null ? void 0 : le[o.filterKey], K.logic = "equal";
      const pe = _s.find(
        (Z) => Z.type === ((le == null ? void 0 : le.dataType) || "string")
      );
      if (pe) {
        const Z = pe.logicList.find((X) => X.logic === "equal");
        K.handler = (Z == null ? void 0 : Z.handler) ?? null;
      }
      (Te = le == null ? void 0 : le.options) != null && Te.length ? (K.value = le.options[0].value, K.showValue = le.options[0].label, K._allowSelectLogic = false) : (K.value = "", K.showValue = "", K._allowSelectLogic = true);
    }
    function F(E) {
      var le;
      (E.logic === "after" || E.logic === "before") && E.dateType === "datetimerange" && (E.dateType = "datetime", E.dateRange = "date");
      const K = ((le = m.value(E.key)) == null ? void 0 : le.dataType) ?? "string", ee = _s.find((pe) => pe.type === K);
      if (!ee)
        return;
      g.value(E) && (E.value = "", E.showValue = "");
      const V = ee.logicList.find((pe) => pe.logic === E.logic);
      E.handler = (V == null ? void 0 : V.handler) ?? null, K === "date" && N(E);
    }
    function N(E) {
      if (g.value(E)) {
        E.value = "", E.showValue = "";
        return;
      }
      j(E);
    }
    function j(E) {
      te(E);
      let K = Array.isArray(E.value) ? "" : E.value;
      switch (E.dateRange) {
        case "range":
          K = ["", ""];
          break;
        case "today":
          K = z(0);
          break;
        case "tomorrow":
          K = z(1);
          break;
        case "yesterday":
          K = z(-1);
          break;
        case "current-week":
          K = [z(-A() + 1), z(7 - A(), true)];
          break;
        case "last-week":
          K = [z(-A() - 6), z(-A(), true)];
          break;
        case "current-month":
          K = [
            z(-B() + 1),
            z(D() - B(), true)
          ];
          break;
        case "last-month":
          K = [
            z(-B() - D(true) + 1),
            z(-B(), true)
          ];
          break;
        case "past-seven-days":
          K = [z(-7), z(-1, true)];
          break;
        case "past-thirty-days":
          K = [z(-30), z(-1, true)];
          break;
      }
      const ee = ["current-week", "last-week", "current-month", "last-month"];
      E.dateType === "datetime" && ee.includes(E.dateRange) ? (E.value = K[0], E.showValue = hr(K[0], o.formatter)) : (E.value = K, Array.isArray(K) ? E.showValue = hr(K, o.formatter).join(" - ") : E.showValue = hr(K, o.formatter));
    }
    function z(E, K = false) {
      const ee = /* @__PURE__ */ new Date(), V = new Date(ee);
      return V.setDate(V.getDate() + E), K ? V.setHours(23, 59, 59, 0) : V.setHours(0, 0, 0, 0), V;
    }
    function A() {
      return (/* @__PURE__ */ new Date()).getDay();
    }
    function B() {
      return (/* @__PURE__ */ new Date()).getDate();
    }
    function D(E = false) {
      const K = (/* @__PURE__ */ new Date()).getMonth() + 1, ee = E ? K - 1 : K, V = [1, 3, 5, 7, 8, 10, 12], le = [4, 6, 9, 11];
      if (V.includes(ee))
        return 31;
      if (le.includes(ee))
        return 30;
      const pe = (/* @__PURE__ */ new Date()).getFullYear();
      return pe % 4 === 0 && pe % 100 !== 0 || pe % 400 === 0 ? 29 : 28;
    }
    function te(E) {
      if (E.logic === "equal") {
        const K = ["date", "today", "tomorrow", "yesterday"];
        E.dateType = K.includes(E.dateRange) ? "datetime" : "datetimerange";
      } else if (E.logic === "after" || E.logic === "before") {
        const K = ["range"];
        E.dateType = K.includes(E.dateRange) ? "datetimerange" : "datetime";
      }
    }
    function ie(E, K, ee) {
      if (K === "input")
        E.showValue = E.value;
      else if (K === "select") {
        const V = ee == null ? void 0 : ee.find((le) => le.value === E.value);
        E.showValue = (V == null ? void 0 : V.label) ?? "";
      }
    }
    function U(E, K) {
      const ee = hr(E, o.formatter);
      K.showValue = Array.isArray(ee) ? ee.join(" - ") : ee;
    }
    function oe() {
      s("show");
    }
    function se() {
      s("hide");
    }
    return t10({ filter: x, clearFilter: _, getConditionInfo: R }), (E, K) => {
      const ee = resolveComponent("k-date-picker");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          "k-filter",
          { "text-sm": unref(r).ownSize === "sm", "text-base": unref(r).ownSize !== "sm" },
          unref(i)
        ])
      }, [
        createVNode(unref(Io), {
          trigger: "click",
          width: "auto",
          teleported: false,
          placement: "bottom-end",
          "popper-class": a.value,
          onBeforeEnter: K[2] || (K[2] = () => a.value = "k-filter-popper__enter"),
          onBeforeLeave: K[3] || (K[3] = () => a.value = "k-filter-popper__leave"),
          onShow: oe,
          onHide: se
        }, {
          reference: withCtx(() => [
            renderSlot(E.$slots, "reference", { hasConfigCondition: h10.value }, () => [
              E.border ? (openBlock(), createBlock(unref(Lt), {
                key: 0,
                size: unref(r).ownSize
              }, {
                default: withCtx(() => [
                  h10.value ? (openBlock(), createBlock(unref(Ir), {
                    key: 1,
                    color: "#2882FF"
                  })) : (openBlock(), createBlock(unref(La), { key: 0 }))
                ]),
                _: 1
              }, 8, ["size"])) : (openBlock(), createElementBlock("span", y3, [
                h10.value ? (openBlock(), createBlock(unref(Ir), {
                  key: 1,
                  color: "#2882FF"
                })) : (openBlock(), createBlock(unref(La), { key: 0 }))
              ]))
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", b3, [
              createBaseVNode("div", _3, [
                createBaseVNode("span", {
                  class: normalizeClass([unref(r).ownSize === "sm" ? "text-base" : "text-lg", "font-bold"])
                }, toDisplayString(E.$t("advancedFilter")), 3),
                createBaseVNode("span", {
                  class: normalizeClass(unref(r).ownSize === "sm" ? "text-sm" : "text-base"),
                  onClick: K[0] || (K[0] = () => {
                    _(), s("clear");
                  })
                }, [
                  createVNode(unref(h0)),
                  createTextVNode(" " + toDisplayString(E.$t("clearAll")), 1)
                ], 2)
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(c.value, (V, le) => {
                var pe, Te, Z, X, Q;
                return openBlock(), createElementBlock("div", {
                  key: le,
                  title: (pe = V.title) == null ? void 0 : pe.join("/"),
                  class: "k-filter__item"
                }, [
                  createBaseVNode("div", T3, [
                    createVNode(unref(Lf), {
                      modelValue: V.title,
                      "onUpdate:modelValue": (W) => V.title = W,
                      teleported: false,
                      size: unref(r).ownSize,
                      options: E.options,
                      props: {
                        label: "title",
                        value: "title",
                        children: o.childrenField
                      },
                      clearable: "",
                      onChange: (W) => P(le)
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "size", "options", "props", "onChange"])
                  ]),
                  createBaseVNode("div", C3, [
                    createVNode(unref(Go), {
                      modelValue: V.logic,
                      "onUpdate:modelValue": (W) => V.logic = W,
                      size: unref(r).ownSize,
                      teleported: false,
                      clearable: "",
                      disabled: V._allowSelectLogic === false,
                      onChange: (W) => F(V)
                    }, {
                      default: withCtx(() => {
                        var W;
                        return [
                          (openBlock(true), createElementBlock(Fragment, null, renderList((W = p.value(V)) == null ? void 0 : W.logicList, (de) => (openBlock(), createBlock(unref(vo), {
                            key: de.logic,
                            label: E.$t(de.logic),
                            value: de.logic
                          }, null, 8, ["label", "value"]))), 128))
                        ];
                      }),
                      _: 2
                    }, 1032, ["modelValue", "onUpdate:modelValue", "size", "disabled", "onChange"])
                  ]),
                  createBaseVNode("div", {
                    class: "k-filter__value",
                    title: (Te = V.value) == null ? void 0 : Te.toString()
                  }, [
                    ((Z = m.value(V.key)) == null ? void 0 : Z.dataType) === "date" ? (openBlock(), createElementBlock("div", S3, [
                      createVNode(unref(Go), {
                        modelValue: V.dateRange,
                        "onUpdate:modelValue": (W) => V.dateRange = W,
                        size: unref(r).ownSize,
                        teleported: false,
                        clearable: "",
                        disabled: g.value(V),
                        onChange: (W) => j(V)
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(f.value(V), (W) => (openBlock(), createBlock(unref(vo), {
                            key: W.value,
                            label: E.$t(W.label),
                            value: W.value,
                            disabled: (V.logic === "after" || V.logic === "before") && W.value === "range"
                          }, null, 8, ["label", "value", "disabled"]))), 128))
                        ]),
                        _: 2
                      }, 1032, ["modelValue", "onUpdate:modelValue", "size", "disabled", "onChange"]),
                      createVNode(ee, {
                        modelValue: V.value,
                        "onUpdate:modelValue": (W) => V.value = W,
                        type: V.dateType,
                        teleported: false,
                        size: unref(r).ownSize,
                        clearable: "",
                        disabled: v.value(V),
                        onChange: (W) => {
                          U(W, V);
                        }
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "type", "size", "disabled", "onChange"])
                    ])) : (Q = (X = m.value(V.key)) == null ? void 0 : X.options) != null && Q.length ? (openBlock(), createBlock(unref(Go), {
                      key: 1,
                      modelValue: V.value,
                      "onUpdate:modelValue": (W) => V.value = W,
                      size: unref(r).ownSize,
                      teleported: false,
                      disabled: g.value(V),
                      clearable: "",
                      onChange: (W) => ie(V, "select", m.value(V.key).options)
                    }, {
                      default: withCtx(() => {
                        var W;
                        return [
                          (openBlock(true), createElementBlock(Fragment, null, renderList((W = m.value(V.key)) == null ? void 0 : W.options, (de) => (openBlock(), createBlock(unref(vo), {
                            key: de.value,
                            label: de.label,
                            value: de.value
                          }, null, 8, ["label", "value"]))), 128))
                        ];
                      }),
                      _: 2
                    }, 1032, ["modelValue", "onUpdate:modelValue", "size", "disabled", "onChange"])) : (openBlock(), createBlock(unref(ro), {
                      key: 2,
                      modelValue: V.value,
                      "onUpdate:modelValue": (W) => V.value = W,
                      size: unref(r).ownSize,
                      disabled: g.value(V),
                      clearable: "",
                      onChange: (W) => ie(V, "input", m.value(V.key).options)
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "size", "disabled", "onChange"]))
                  ], 8, k3),
                  createBaseVNode("i", {
                    class: "close-icon",
                    onClick: (W) => w(le)
                  }, [
                    createVNode(unref(yl))
                  ], 8, N3)
                ], 8, w3);
              }), 128)),
              createBaseVNode("div", {
                class: normalizeClass(["k-filter__operate", unref(r).ownSize === "sm" ? "text-sm" : "text-base"])
              }, [
                createBaseVNode("div", M3, [
                  createBaseVNode("span", { onClick: T }, [
                    createVNode(unref(_p)),
                    createTextVNode(" " + toDisplayString(E.$t("addCondition")), 1)
                  ])
                ]),
                createBaseVNode("div", $3, [
                  createBaseVNode("span", x3, toDisplayString(E.$t("aboveCondition")) + "", 1),
                  createVNode(unref(Go), {
                    modelValue: u.value,
                    "onUpdate:modelValue": K[1] || (K[1] = (V) => u.value = V),
                    size: unref(r).ownSize,
                    disabled: y.value,
                    teleported: false
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(vo), {
                        label: E.$t("anyOne"),
                        value: 0
                      }, null, 8, ["label"]),
                      createVNode(unref(vo), {
                        label: E.$t("all"),
                        value: 1
                      }, null, 8, ["label"])
                    ]),
                    _: 1
                  }, 8, ["modelValue", "size", "disabled"]),
                  createVNode(unref(Lt), {
                    size: unref(r).ownSize,
                    main: "",
                    onClick: M
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(E.$t("query")), 1)
                    ]),
                    _: 1
                  }, 8, ["size"])
                ])
              ], 2)
            ])
          ]),
          _: 3
        }, 8, ["popper-class"])
      ], 2);
    };
  }
});
var Wf = $e(I3);
var na = null;
var ws = null;
var Wn = null;
var Pu = "z-index-manage";
var ho = null;
var Ru = "z-index-style";
var qf = "m";
var Vf = "s";
var Ga = {
  m: 1e3,
  s: 1e3
};
function Ql() {
  return na || typeof document < "u" && (na = document), na;
}
function Hf() {
  return na && !ws && (ws = na.body || na.getElementsByTagName("body")[0]), ws;
}
function D3() {
  var e16 = 0, t10 = Ql();
  if (t10) {
    var n = Hf();
    if (n)
      for (var o = n.getElementsByTagName("*"), r = 0; r < o.length; r++) {
        var a = o[r];
        if (a && a.style && a.nodeType === 1) {
          var i = a.style.zIndex;
          i && /^\d+$/.test(i) && (e16 = Math.max(e16, Number(i)));
        }
      }
  }
  return e16;
}
function A3() {
  if (!ho) {
    var e16 = Ql();
    e16 && (ho = e16.getElementById(Ru), ho || (ho = e16.createElement("style"), ho.id = Ru, e16.getElementsByTagName("head")[0].appendChild(ho)));
  }
  return ho;
}
function Uf() {
  var e16 = A3();
  if (e16) {
    var t10 = "--dom-", n = "-z-index";
    e16.innerHTML = ":root{" + t10 + "main" + n + ":" + Ti() + ";" + t10 + "sub" + n + ":" + tc() + "}";
  }
}
function Gf() {
  if (!Wn) {
    var e16 = Ql();
    if (e16 && (Wn = e16.getElementById(Pu), !Wn)) {
      var t10 = Hf();
      t10 && (Wn = e16.createElement("div"), Wn.id = Pu, Wn.style.display = "none", t10.appendChild(Wn), Jl(Ga.m), ec(Ga.s));
    }
  }
  return Wn;
}
function Xf(e16) {
  return function(t10) {
    if (t10) {
      t10 = Number(t10), Ga[e16] = t10;
      var n = Gf();
      n && (n.dataset ? n.dataset[e16] = t10 + "" : n.setAttribute("data-" + e16, t10 + ""));
    }
    return Uf(), Ga[e16];
  };
}
var Jl = Xf(qf);
function Yf(e16, t10) {
  return function(o) {
    var r, a = Gf();
    if (a) {
      var i = a.dataset ? a.dataset[e16] : a.getAttribute("data-" + e16);
      i && (r = Number(i));
    }
    return r || (r = Ga[e16]), o ? Number(o) < r ? t10() : o : r;
  };
}
var Ti = Yf(qf, Qf);
function Qf() {
  return Jl(Ti() + 1);
}
var ec = Xf(Vf);
var Jf = Yf(Vf, e1);
function tc() {
  return Ti() + Jf();
}
function e1() {
  return ec(Jf() + 1), tc();
}
var Lu = {
  setCurrent: Jl,
  getCurrent: Ti,
  getNext: Qf,
  setSubCurrent: ec,
  getSubCurrent: tc,
  getSubNext: e1,
  getMax: D3
};
Uf();
var E3 = { class: "__column-drag-icon" };
var K3 = "desc-change";
var z3 = "hide-column";
var P3 = defineComponent({
  name: "KTable",
  __name: "table",
  props: {
    data: {},
    showDragColumn: { type: Boolean, default: false },
    showColumnMenu: { type: Boolean }
  },
  emits: [
    "desc-change",
    "hide-column",
    "drag",
    "sort-change",
    "clear-sort",
    "filter-change",
    "filter-visible",
    "clear-filter"
  ],
  setup(e16, { expose: t10, emit: n }) {
    const o = {
      descChange: {
        name: "desc-change",
        callback: h10.bind(this)
      },
      hideColumn: {
        name: "hide-column",
        callback: g.bind(this)
      },
      clearFilter: {
        name: "clear-filter",
        callback: x.bind(this)
      },
      filterChange: {
        name: "filter-change",
        callback: _.bind(this)
      },
      filterVisible: {
        name: "filter-visible",
        callback: M.bind(this)
      },
      sortChange: {
        name: "sort-change",
        callback: T.bind(this)
      },
      clearSort: {
        name: "clear-sort",
        callback: w.bind(this)
      }
    }, r = e16, a = inject("_styleModule", ""), i = useSlots(), s = Dt(8), l = inject("_emitter");
    for (const I in o) {
      const { name: P, callback: F } = o[I];
      l.on(P, s, F);
    }
    const c = n;
    onMounted(() => {
      p();
    });
    const u = ref();
    let d, m;
    nextTick(() => {
      d = setTimeout(() => {
        f();
      }, 500), R.value && (R.value.openFilter = y, R.value.closeFilter = k);
    }), onUnmounted(() => {
      for (const I in o) {
        const { name: P } = o[I];
        l.remove(P, s);
      }
      clearTimeout(d), m && m.destroy();
    });
    function p() {
      const I = Lu.getMax();
      Lu.setCurrent(I + 1);
    }
    function f() {
      const I = u.value;
      if (!I || !I.$el)
        return;
      const P = I.$el.querySelector(".body--wrapper > .vxe-table--body tbody");
      P && (m = sortable_esm_default.create(P, {
        handle: ".__column-drag-icon",
        animation: 150,
        onEnd: (F) => {
          c("drag", F);
        }
      }));
    }
    function h10(I, P) {
      c(K3, I, P);
    }
    function g(I) {
      c(z3, I);
    }
    const v = ref({
      field: "___default___",
      isOpen: false
    });
    function y(I) {
      return new Promise((P) => {
        let F = I;
        typeof I == "object" && (F = I.field ?? ""), v.value.field = F, v.value.isOpen = true, P(true);
      });
    }
    function k(I) {
      return new Promise((P) => {
        let F = I;
        typeof I == "object" && (F = I.field ?? ""), v.value.field = F, v.value.isOpen = false, P(true);
      });
    }
    function T(I) {
      c("sort-change", I);
    }
    function w(I) {
      c("clear-sort", I);
    }
    function _(I) {
      c("filter-change", I);
    }
    function M(I) {
      c("filter-visible", I);
    }
    function x(I) {
      c("clear-filter", I);
    }
    provide("tableInstance", u), provide("tableId", s), provide("showColumnMenu", r.showColumnMenu), provide("filterPanelConfig", v);
    const R = computed(() => u.value);
    return t10({
      tableInstance: R
    }), (I, P) => (openBlock(), createBlock(unref(VxeTable), mergeProps({
      ref_key: "vxeTableRef",
      ref: u,
      class: ["k-table", unref(a), { drag_table: I.showDragColumn }],
      data: I.data
    }, I.$attrs), createSlots({
      default: withCtx(() => [
        I.showDragColumn ? (openBlock(), createBlock(unref(VxeColumn), {
          key: 0,
          width: "25",
          class: "drag-column"
        }, {
          default: withCtx(() => [
            createBaseVNode("span", E3, [
              renderSlot(I.$slots, "dragIcon", {}, () => [
                createVNode(unref(bl))
              ])
            ])
          ]),
          _: 3
        })) : createCommentVNode("", true),
        renderSlot(I.$slots, "default", normalizeProps(guardReactiveProps(I.data)))
      ]),
      _: 2
    }, [
      i.empty ? {
        name: "empty",
        fn: withCtx((F) => [
          renderSlot(I.$slots, "empty", normalizeProps(guardReactiveProps(F)))
        ]),
        key: "0"
      } : void 0,
      i.loading ? {
        name: "loading",
        fn: withCtx((F) => [
          renderSlot(I.$slots, "loading", normalizeProps(guardReactiveProps(F)))
        ]),
        key: "1"
      } : void 0
    ]), 1040, ["class", "data"]));
  }
});
var R3 = { class: "filter-menu" };
var L3 = { class: "filter-menu-item" };
var F3 = { class: "filter-buttons" };
var Fu = defineComponent({
  __name: "filter_popper",
  props: {
    filters: { default: () => [] },
    column: { default: () => ({}) },
    trigger: { default: "hover" },
    visible: { type: Boolean, default: void 0 },
    text: { default: () => ({}) }
  },
  emits: ["set-filter", "clear-filter", "filter-change", "filter-visible"],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = n, a = ref(), i = ref(false), s = ref(false);
    function l() {
      var f;
      c(false), r("filter-visible", o.column, (f = o.column) == null ? void 0 : f.field, true, o.filters);
    }
    function c(f) {
      var g, v, y;
      if (f && r("filter-change", o.column, (g = o.column) == null ? void 0 : g.field, o.filters), !Array.isArray(o.filters)) {
        i.value = false;
        return;
      }
      i.value = (v = o.filters) == null ? void 0 : v.every((k) => k.checked);
      const h10 = (y = o.filters) == null ? void 0 : y.some((k) => k.checked);
      !i.value && h10 ? s.value = true : s.value = false;
    }
    function u() {
      var f, h10;
      i.value && s.value && (s.value = false), (f = o.filters) == null || f.forEach((g) => {
        g.checked = i.value;
      }), r("filter-change", o.column, (h10 = o.column) == null ? void 0 : h10.field, o.filters);
    }
    function d() {
      r("set-filter", o.column, o.filters), p();
    }
    function m() {
      var f;
      (f = o.filters) == null || f.forEach((h10) => {
        h10.checked = false;
      }), s.value = false, i.value = false, r("clear-filter", o.column), p();
    }
    function p() {
      var f;
      (f = a.value) == null || f.hide();
    }
    return t10({ closeFilterPanel: p }), (f, h10) => {
      var g;
      return openBlock(), createBlock(unref(Io), {
        ref_key: "filterPopper",
        ref: a,
        trigger: f.trigger,
        "show-arrow": false,
        placement: "right-start",
        "popper-class": "filter-box",
        offset: 2,
        disabled: !((g = o.filters) != null && g.length),
        teleported: true,
        visible: f.visible,
        onShow: l
      }, {
        reference: withCtx(() => [
          renderSlot(f.$slots, "default")
        ]),
        default: withCtx(() => [
          renderSlot(f.$slots, "filter", {}, () => [
            createBaseVNode("ul", R3, [
              createBaseVNode("li", L3, [
                createVNode(unref(fa), {
                  modelValue: i.value,
                  "onUpdate:modelValue": h10[0] || (h10[0] = (v) => i.value = v),
                  label: f.$t("all"),
                  value: "all",
                  indeterminate: s.value,
                  onChange: u
                }, null, 8, ["modelValue", "label", "indeterminate"])
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(o.filters, (v, y) => (openBlock(), createElementBlock("li", {
                key: y,
                class: "filter-menu-item"
              }, [
                createVNode(unref(fa), {
                  modelValue: v.checked,
                  "onUpdate:modelValue": (k) => v.checked = k,
                  label: v.label,
                  value: v.value,
                  onChange: h10[1] || (h10[1] = (k) => c(true))
                }, null, 8, ["modelValue", "onUpdate:modelValue", "label", "value"])
              ]))), 128))
            ])
          ]),
          createBaseVNode("div", F3, [
            createVNode(unref(Lt), {
              size: "sm",
              onClick: m
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(f.text.resetButtonText ?? f.$t("reset")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(Lt), {
              class: "filter-btn-item",
              size: "sm",
              secondary: "",
              onClick: d
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(f.text.confirmButtonText ?? f.$t("filter")), 1)
              ]),
              _: 1
            })
          ])
        ]),
        _: 3
      }, 8, ["trigger", "disabled", "visible"]);
    };
  }
});
var j3 = {
  key: 0,
  class: "k-table-column__header"
};
var O3 = { class: "k-table-column__title" };
var B3 = {
  key: 0,
  class: "k-table-column__edit vxe-table-icon-edit"
};
var Z3 = { class: "k-column__header-dialog" };
var W3 = { class: "header-dialog__buttons" };
var q3 = { class: "k-table-column__operate" };
var V3 = {
  key: 0,
  class: "k-table-column__tooltip"
};
var H3 = ["onClick"];
var U3 = ["onClick"];
var G3 = {
  key: 3,
  class: "k-table-column__more"
};
var X3 = { class: "more-menu" };
var Y3 = { class: "more-menu-item" };
var Q3 = { class: "more-menu-item" };
var J3 = { class: "sort-menu" };
var e82 = ["onClick"];
var t8 = ["onClick"];
var n8 = ["onClick"];
var o8 = ["onClick"];
var a8 = { key: 1 };
var t1 = defineComponent({
  name: "KTableColumn",
  __name: "table_column",
  props: {
    sortable: { type: Boolean },
    filters: {},
    desc: {},
    showColumnMenu: { type: Boolean, default: void 0 },
    editRender: {},
    type: {},
    field: {}
  },
  setup(e16) {
    const t10 = inject(
      "tableInstance",
      computed(() => null)
    ), n = inject("__showTransfer", computed(() => false)), o = inject("tableId"), r = inject(
      "filterPanelConfig",
      computed(() => ({
        field: "___default___",
        isOpen: false
      }))
    ), a = inject("showColumnMenu", false), i = e16, s = useSlots(), l = ref(), c = ref(false), u = ref(""), d = ref(""), m = ref(false), p = ref(""), f = ref(false), h10 = inject("_emitter");
    watch(() => i.desc, (A) => {
      A && (d.value = A);
    }, { immediate: true }), watch(() => r.value, () => {
      const { field: A, isOpen: B } = r.value;
      i.field === A && (B === true ? f.value = true : B === false && (f.value = false));
    }, { deep: true });
    const g = computed(() => i.showColumnMenu ?? a), v = computed(() => {
      var A;
      return (A = t10.value) == null ? void 0 : A.isFilter(i.field ?? "");
    }), y = computed(() => {
      var A;
      return ((A = t10.value) == null ? void 0 : A.filterConfig) ?? {};
    }), k = computed(() => {
      const { confirmButtonText: A, resetButtonText: B } = y.value;
      return {
        confirmButtonText: A,
        resetButtonText: B
      };
    }), T = computed(() => {
      var A;
      return ((A = t10.value) == null ? void 0 : A.sortConfig) ?? {};
    });
    function w(A, B) {
      const D = B.order;
      let te = null;
      A === "_asc-icon" && D !== "asc" ? te = "asc" : A === "_desc-icon" && D !== "desc" && (te = "desc"), _(B, te);
    }
    function _(A, B) {
      var D;
      (D = t10.value) == null || D.sort(A.field ?? "", B), h10.emit("sort-change", o, { column: A, field: A.field, order: B });
    }
    function M(A) {
      var B;
      (B = t10.value) == null || B.clearSort(A), h10.emit("clear-sort", o);
    }
    function x(A) {
      var D, te;
      c.value = A;
      let B = "";
      A ? (u.value = (D = t10.value) == null ? void 0 : D.getColumnWidth(i.field ?? ""), B = "40") : B = u.value ?? "", (te = t10.value) == null || te.setColumnWidth(i.field ?? "", B);
    }
    function R() {
      p.value = d.value ?? "";
    }
    function I(A) {
      d.value = p.value, m.value = false, h10 == null || h10.emit("desc-change", o, A, d.value);
    }
    function P(A) {
      var B;
      h10 == null || h10.emit("hide-column", o, A), (B = l.value) == null || B.hide();
    }
    async function F(A, B) {
      t10.value && (await t10.value.setFilter(A, B), t10.value.updateData());
    }
    async function N(A) {
      t10.value && (await t10.value.clearFilter(A), h10 == null || h10.emit("clear-filter", o, { filterList: i.filters }));
    }
    function j(A, B, D) {
      h10.emit("filter-change", o, { column: A, field: B, filterList: D });
    }
    function z(A, B, D, te) {
      h10.emit("filter-visible", o, { column: A, field: B, visible: D, filterList: te });
    }
    return (A, B) => (openBlock(), createBlock(unref(VxeColumn), mergeProps(A.$attrs, {
      "edit-render": A.editRender,
      filters: A.filters,
      sortable: A.sortable,
      type: A.type,
      field: A.field,
      class: "k-table-column"
    }), createSlots({ _: 2 }, [
      A.type ? void 0 : {
        name: "header",
        fn: withCtx((D) => {
          var te;
          return [
            c.value ? (openBlock(), createElementBlock("div", a8, [
              createVNode(unref(Qh), {
                style: {
                  width: "20px",
                  cursor: "pointer"
                },
                class: "expand-icon",
                onClick: B[6] || (B[6] = (ie) => x(false))
              })
            ])) : (openBlock(), createElementBlock("div", j3, [
              createBaseVNode("div", O3, [
                renderSlot(A.$slots, "header", normalizeProps(guardReactiveProps(D)), () => {
                  var ie, U, oe;
                  return [
                    (ie = unref(t10)) != null && ie.editConfig && ((oe = (U = unref(t10)) == null ? void 0 : U.editConfig) == null ? void 0 : oe.showIcon) !== false && A.editRender ? (openBlock(), createElementBlock("i", B3)) : createCommentVNode("", true),
                    createTextVNode(" " + toDisplayString(D.column.title ?? "-"), 1)
                  ];
                })
              ]),
              g.value ? (openBlock(), createBlock(unref(Zf), {
                key: 0,
                modelValue: m.value,
                "onUpdate:modelValue": B[2] || (B[2] = (ie) => m.value = ie),
                title: A.$t("customDescription"),
                onOpen: R
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", Z3, [
                    createVNode(unref(ro), {
                      modelValue: p.value,
                      "onUpdate:modelValue": B[0] || (B[0] = (ie) => p.value = ie),
                      type: "textarea"
                    }, null, 8, ["modelValue"]),
                    createBaseVNode("div", W3, [
                      createVNode(unref(Lt), {
                        onClick: B[1] || (B[1] = () => m.value = false)
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(A.$t("cancel")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(unref(Lt), {
                        main: "",
                        onClick: (ie) => I(D.column)
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(A.$t("confirm")), 1)
                        ]),
                        _: 2
                      }, 1032, ["onClick"])
                    ])
                  ])
                ]),
                _: 2
              }, 1032, ["modelValue", "title"])) : createCommentVNode("", true),
              createBaseVNode("div", q3, [
                d.value ? (openBlock(), createElementBlock("span", V3, [
                  createVNode(unref(wa), {
                    trigger: "click",
                    content: d.value,
                    placement: "top"
                  }, {
                    reference: withCtx(() => [
                      createBaseVNode("i", null, [
                        createVNode(unref(gd))
                      ])
                    ]),
                    _: 1
                  }, 8, ["content"])
                ])) : createCommentVNode("", true),
                i.sortable && ((te = T.value) == null ? void 0 : te.showIcon) !== false ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass([
                    "k-table-column__sort",
                    T.value.iconLayout === "horizontal" ? "sort-icon__horizontal" : "sort-icon__vertical"
                  ])
                }, [
                  T.value.iconAsc ? (openBlock(), createBlock(resolveDynamicComponent(T.value.iconAsc), {
                    key: 0,
                    style: normalizeStyle({
                      color: D.column.order == "asc" ? "#2882FF" : "",
                      fontSize: "15px"
                    }),
                    onClick: (ie) => w("_asc-icon", D.column)
                  }, null, 8, ["style", "onClick"])) : (openBlock(), createElementBlock("i", {
                    key: 1,
                    class: "vxe-table-icon-caret-up icon-asc",
                    style: normalizeStyle({ color: D.column.order == "asc" ? "#2882FF" : "" }),
                    onClick: (ie) => w("_asc-icon", D.column)
                  }, null, 12, H3)),
                  T.value.iconDesc ? (openBlock(), createBlock(resolveDynamicComponent(T.value.iconDesc), {
                    key: 2,
                    style: normalizeStyle({
                      color: D.column.order == "desc" ? "#2882FF" : "",
                      fontSize: "15px"
                    }),
                    onClick: (ie) => w("_desc-icon", D.column)
                  }, null, 8, ["style", "onClick"])) : (openBlock(), createElementBlock("i", {
                    key: 3,
                    class: "vxe-table-icon-caret-down icon-desc",
                    style: normalizeStyle({ color: D.column.order == "desc" ? "#2882FF" : "" }),
                    onClick: (ie) => w("_desc-icon", D.column)
                  }, null, 12, U3))
                ], 2)) : createCommentVNode("", true),
                i.filters ? (openBlock(), createBlock(Fu, {
                  key: 2,
                  filters: i.filters,
                  column: D.column,
                  trigger: "click",
                  text: k.value,
                  onSetFilter: F,
                  onClearFilter: N,
                  onFilterChange: j,
                  onFilterVisible: z
                }, {
                  default: withCtx(() => {
                    var ie;
                    return [
                      withDirectives(createBaseVNode("span", {
                        class: "k-table-column__filter",
                        onClick: B[3] || (B[3] = () => f.value = !f.value)
                      }, [
                        y.value.iconNone && !v.value ? (openBlock(), createBlock(resolveDynamicComponent(y.value.iconNone), { key: 0 })) : y.value.iconMatch && v.value ? (openBlock(), createBlock(resolveDynamicComponent(y.value.iconMatch), { key: 1 })) : v.value ? (openBlock(), createBlock(unref(Ir), {
                          key: 2,
                          size: 16,
                          color: "#2882FF"
                        })) : (openBlock(), createBlock(unref(La), {
                          key: 3,
                          size: 16
                        }))
                      ], 512), [
                        [vShow, i.filters && ((ie = y.value) == null ? void 0 : ie.showIcon) !== false]
                      ]),
                      A.$slots.filter ? renderSlot(A.$slots, "filter", {
                        key: 0,
                        column: D.column,
                        setFilter: F,
                        clearFilter: N
                      }) : createCommentVNode("", true)
                    ];
                  }),
                  _: 2
                }, 1032, ["filters", "column", "text"])) : createCommentVNode("", true),
                g.value ? (openBlock(), createElementBlock("span", G3, [
                  createVNode(unref(Io), {
                    ref_key: "popoverRef",
                    ref: l,
                    trigger: "click",
                    "show-arrow": false,
                    placement: "bottom-start",
                    "popper-class": "more-box",
                    offset: 2,
                    width: "160px"
                  }, {
                    reference: withCtx(() => [
                      createBaseVNode("i", null, [
                        createVNode(unref(oi))
                      ])
                    ]),
                    default: withCtx(() => [
                      createBaseVNode("ul", X3, [
                        createBaseVNode("li", Y3, [
                          createVNode(Fu, {
                            filters: i.filters,
                            column: D.column,
                            text: k.value,
                            onSetFilter: F,
                            onClearFilter: N,
                            onFilterChange: j,
                            onFilterVisible: z
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("div", {
                                class: normalizeClass(["filter-select-item", { disabled: !i.filters }])
                              }, [
                                createVNode(unref(La), { class: "menu-item-icon" }),
                                createTextVNode(" " + toDisplayString(A.$t("filter")), 1)
                              ], 2),
                              A.$slots.filter ? renderSlot(A.$slots, "filter", {
                                key: 0,
                                column: D.column,
                                setFilter: F,
                                clearFilter: N
                              }) : createCommentVNode("", true)
                            ]),
                            _: 2
                          }, 1032, ["filters", "column", "text"])
                        ]),
                        createBaseVNode("li", Q3, [
                          createVNode(unref(Io), {
                            trigger: "hover",
                            "show-arrow": false,
                            placement: "right-start",
                            "popper-class": "more-box",
                            offset: 2,
                            disabled: !i.sortable,
                            teleported: false
                          }, {
                            reference: withCtx(() => [
                              createBaseVNode("div", {
                                class: normalizeClass(["sort-select-item", { disabled: !i.sortable }])
                              }, [
                                createVNode(unref(Xh), { class: "menu-item-icon" }),
                                createTextVNode(" " + toDisplayString(A.$t("sort")) + " ", 1),
                                createVNode(unref(vl), { class: "sort-arrow-right" })
                              ], 2)
                            ]),
                            default: withCtx(() => [
                              createBaseVNode("ul", J3, [
                                createBaseVNode("li", {
                                  class: "sort-menu-item",
                                  onClick: (ie) => _(D.column, "asc")
                                }, [
                                  createVNode(unref(Yh)),
                                  createTextVNode(" " + toDisplayString(A.$t("ascendingOrder")), 1)
                                ], 8, e82),
                                createBaseVNode("li", {
                                  class: "sort-menu-item",
                                  onClick: (ie) => _(D.column, "desc")
                                }, [
                                  createVNode(unref(Gh)),
                                  createTextVNode(" " + toDisplayString(A.$t("descendingOrder")), 1)
                                ], 8, t8),
                                createBaseVNode("li", {
                                  class: "sort-menu-item",
                                  onClick: (ie) => M(D.column)
                                }, [
                                  createVNode(unref(h0)),
                                  createTextVNode(" " + toDisplayString(A.$t("clearSorting")), 1)
                                ], 8, n8)
                              ])
                            ]),
                            _: 2
                          }, 1032, ["disabled"])
                        ]),
                        createBaseVNode("li", {
                          class: "more-menu-item",
                          onClick: B[4] || (B[4] = (ie) => x(true))
                        }, [
                          createVNode(unref($p), { class: "menu-item-icon" }),
                          createTextVNode(" " + toDisplayString(A.$t("retract")), 1)
                        ]),
                        unref(n) ? (openBlock(), createElementBlock("li", {
                          key: 0,
                          class: "more-menu-item",
                          onClick: (ie) => P(D.column)
                        }, [
                          createVNode(unref(xp), { class: "menu-item-icon" }),
                          createTextVNode(" " + toDisplayString(A.$t("hide")), 1)
                        ], 8, o8)) : createCommentVNode("", true),
                        createBaseVNode("li", {
                          class: "more-menu-item",
                          onClick: B[5] || (B[5] = () => m.value = true)
                        }, [
                          createVNode(unref(Sp), { class: "menu-item-icon" }),
                          createTextVNode(" " + toDisplayString(A.$t("customDescription")), 1)
                        ])
                      ])
                    ]),
                    _: 2
                  }, 1536)
                ])) : createCommentVNode("", true)
              ])
            ]))
          ];
        }),
        key: "0"
      },
      c.value ? {
        name: "default",
        fn: withCtx(() => [
          B[7] || (B[7] = createBaseVNode("span", null, "-", -1))
        ]),
        key: "1"
      } : s.default && !c.value ? {
        name: "default",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "default", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "2"
      } : void 0,
      s.footer ? {
        name: "footer",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "footer", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "3"
      } : void 0,
      s.radio ? {
        name: "radio",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "radio", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "4"
      } : void 0,
      s.checkbox ? {
        name: "checkbox",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "checkbox", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "5"
      } : void 0,
      s.title ? {
        name: "title",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "title", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "6"
      } : void 0,
      s.edit ? {
        name: "edit",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "edit", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "7"
      } : void 0,
      s.valid ? {
        name: "valid",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "valid", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "8"
      } : void 0,
      s.content ? {
        name: "content",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "content", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "9"
      } : void 0
    ]), 1040, ["edit-render", "filters", "sortable", "type", "field"]));
  }
});
var n1 = defineComponent({
  name: "KColumnGroup",
  __name: "column_group",
  setup(e16) {
    const t10 = useSlots();
    return (n, o) => (openBlock(), createBlock(unref(VxeColgroup), normalizeProps(guardReactiveProps(n.$attrs)), createSlots({
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 2
    }, [
      t10.header ? {
        name: "header",
        fn: withCtx((r) => [
          renderSlot(n.$slots, "header", normalizeProps(guardReactiveProps(r)))
        ]),
        key: "0"
      } : void 0
    ]), 1040));
  }
});
var Hr = $e(P3, { TableColumn: t1, ColumnGroup: n1 });
var Ur = tn(t1);
var o1 = tn(n1);
var r8 = defineComponent({
  name: "KDrawer",
  __name: "drawer",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElDrawer), mergeProps({
      ref_key: "KDrawerRef",
      ref: o,
      class: ["k-drawer", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var i8 = $e(r8);
var s8 = defineComponent({
  name: "KForm",
  __name: "form",
  props: {
    size: {},
    showColon: { type: Boolean }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = kt(n), a = ref();
    return t10(Ae({}, a)), provide(fn, r), provide(
      "__showColon__",
      computed(() => n.showColon)
    ), (s, l) => (openBlock(), createBlock(unref(ElForm), mergeProps({
      ref_key: "KFormRef",
      ref: a,
      class: ["k-form", unref(o)]
    }, s.$attrs, {
      size: unref(r).elSize
    }), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var a1 = defineComponent({
  name: "KFormItem",
  __name: "form_item",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", ""), a = ref(null);
    t10(Ae({}, a));
    const s = inject(
      "__showColon__",
      computed(() => false)
    );
    return (l, c) => (openBlock(), createBlock(unref(ElFormItem), mergeProps({
      ref_key: "KFormItemRef",
      ref: a,
      class: ["k-form-item", unref(r), { "k-form-item--colon": unref(s) }]
    }, l.$attrs, {
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(l.$slots, (u, d) => ({
        name: d,
        fn: withCtx((m) => [
          renderSlot(l.$slots, d, normalizeProps(guardReactiveProps(m)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var r1 = $e(s8, { FormItem: a1 });
var i1 = tn(a1);
var l8 = defineComponent({
  name: "KSteps",
  props: {
    processStatus: {
      type: String,
      default: "finish"
    },
    finishStatus: {
      type: String,
      default: "success"
    },
    useAntStyle: {
      type: Boolean,
      default: false
    },
    capsule: {
      type: Boolean,
      default: false
    },
    height: {
      type: [String, Number],
      default: void 0
    },
    active: {
      type: Number,
      default: void 0
    }
  },
  setup(e16, {
    attrs: t10,
    expose: n,
    slots: o
  }) {
    const r = inject("_styleModule", ""), a = ref([]), i = Dt(8), s = ref(null);
    watch(() => e16.height, (u) => {
      u && typeof window < "u" && nextTick(() => {
        const d = typeof u == "number" ? `${u}px` : String(u), m = document.getElementById(i);
        m == null || m.style.setProperty("--height", d);
      });
    }, {
      immediate: true
    });
    function l(u) {
      switch (u) {
        case "primary":
          return "finish";
        case "wait":
          return "wait";
        case "success":
          return "success";
        case "error":
          return "error";
        default:
          return "finish";
      }
    }
    return provide("stepProps", e16), provide("stepsInfo", a), n(Ae({}, s)), () => {
      var u, d, m;
      if (e16.capsule) {
        const p = ((d = (u = o.default) == null ? void 0 : u.call(o)[0]) == null ? void 0 : d.children) || [];
        a.value = p.map((f, h10) => {
          var g;
          return f.type && f.type.name === "KStep" ? {
            key: h10,
            name: ((g = f.props) == null ? void 0 : g.title) || ""
          } : null;
        }).filter((f) => f);
      }
      return createVNode("div", {
        class: `k-steps ${r}`
      }, [e16.capsule ? createVNode("div", {
        id: i,
        class: "k-step__capsule"
      }, [(m = o.default) == null ? void 0 : m.call(o)]) : createVNode(ElSteps, mergeProps({
        ref: s
      }, t10, {
        "process-status": l(e16.processStatus),
        "finish-status": l(e16.finishStatus),
        active: e16.active,
        class: {
          "k-steps--ant": e16.useAntStyle
        }
      }), o)]);
    };
  }
});
var c8 = ["id"];
var u8 = { class: "k-step__title" };
var s1 = defineComponent({
  name: "KStep",
  __name: "step",
  props: {
    title: { default: "" },
    description: { default: "" },
    icon: {},
    status: { default: "" },
    color: {}
  },
  setup(e16, { expose: t10 }) {
    var p;
    const n = e16, o = inject("stepProps", {}), r = inject("stepsInfo", computed(() => [])), a = inject("_styleModule", ""), i = Dt(8), s = ((p = r.value.find((f) => f.name === n.title)) == null ? void 0 : p.key) ?? "", l = {
      primary: "#2882FF",
      success: "#22C55E",
      error: "#EF4444",
      wait: "#EAE8EB"
    };
    watch(
      () => o.active,
      (f) => {
        if (!Z6(f) || f < 0 || f >= r.value.length || n.status || n.color)
          return;
        const h10 = Object.keys(l);
        let g = "";
        if (f === s) {
          const v = u(o.processStatus);
          g = h10.includes(v) ? l[v] : l.primary;
        } else if (f > s) {
          const v = u(o.finishStatus);
          g = h10.includes(v) ? l[v] : l.success;
        } else
          g = l.wait;
        g && c(g);
      },
      { immediate: true }
    ), watch(
      () => [n.color, n.status],
      (f) => {
        if (!f[0] && !f[1])
          return;
        let h10;
        n.status && [n.status] ? h10 = l[n.status] : n.color ? h10 = n.color : h10 = l.primary, c(h10);
      },
      { immediate: true, deep: true }
    );
    function c(f) {
      typeof window < "u" && nextTick(() => {
        var g;
        const h10 = document.getElementById(i);
        (g = h10 == null ? void 0 : h10.style) == null || g.setProperty("--default-bgColor", f);
      });
    }
    function u(f) {
      switch (f) {
        case "primary":
          return "finish";
        case "wait":
          return "wait";
        case "success":
          return "success";
        case "error":
          return "error";
        default:
          return "";
      }
    }
    const d = ref(null);
    return t10(Ae({}, d)), (f, h10) => unref(o).capsule ? (openBlock(), createElementBlock("div", {
      key: 1,
      id: unref(i),
      class: normalizeClass(["k-step__capsule-box", unref(a)])
    }, [
      createVNode(unref(Io), {
        "show-after": 500,
        disabled: !n.description
      }, {
        reference: withCtx(() => [
          renderSlot(f.$slots, "title", {}, () => [
            createBaseVNode("span", u8, [
              n.icon ? (openBlock(), createBlock(resolveDynamicComponent(n.icon), { key: 0 })) : createCommentVNode("", true),
              createTextVNode(" " + toDisplayString(n.title), 1)
            ])
          ])
        ]),
        default: withCtx(() => [
          createTextVNode(" " + toDisplayString(n.description), 1)
        ]),
        _: 3
      }, 8, ["disabled"])
    ], 10, c8)) : (openBlock(), createBlock(unref(ElStep), mergeProps({
      key: 0,
      ref_key: "KStepRef",
      ref: d,
      class: ["k-step", unref(a)]
    }, f.$attrs, {
      title: f.title,
      description: f.description,
      icon: f.icon,
      status: u(f.status)
    }), createSlots({ _: 2 }, [
      renderList(f.$slots, (g, v) => ({
        name: v,
        fn: withCtx((y) => [
          renderSlot(f.$slots, v, normalizeProps(guardReactiveProps(y)))
        ])
      }))
    ]), 1040, ["class", "title", "description", "icon", "status"]));
  }
});
var d8 = $e(l8, { Step: s1 });
var f8 = tn(s1);
var m8 = defineComponent({
  name: "KCollapse",
  __name: "collapse",
  props: {
    block: {
      type: Boolean,
      default: false
    },
    isOutline: {
      type: Boolean,
      default: false
    },
    useAntStyle: {
      type: Boolean,
      default: false
    },
    useStepStyle: {
      type: Boolean,
      default: false
    }
  },
  setup(e16, { expose: t10 }) {
    const n = e16;
    provide(
      "__isBlock__",
      computed(() => n.block)
    );
    const o = inject("_styleModule", ""), r = ref(null);
    return t10(Ae({}, r)), (i, s) => (openBlock(), createElementBlock("div", {
      class: normalizeClass([{ "k-collapse-outline": e16.isOutline }])
    }, [
      createVNode(unref(ElCollapse), mergeProps({
        ref_key: "kCollapseRef",
        ref: r,
        class: [
          "k-collapse",
          unref(o),
          { "is-useAntStyle": e16.useAntStyle, "is-useStepStyle": e16.useStepStyle }
        ]
      }, i.$attrs), createSlots({ _: 2 }, [
        renderList(i.$slots, (l, c) => ({
          name: c,
          fn: withCtx((u) => [
            renderSlot(i.$slots, c, normalizeProps(guardReactiveProps(u)))
          ])
        }))
      ]), 1040, ["class"])
    ], 2));
  }
});
var l1 = defineComponent({
  name: "KCollapseItem",
  __name: "collapse_item",
  props: {
    block: {
      type: Boolean
    },
    process: {
      type: Boolean
    },
    wait: {
      type: Boolean
    },
    finish: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    warning: {
      type: Boolean
    }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = inject(
      "__isBlock__",
      computed(() => n.block)
    ), a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElCollapseItem), mergeProps({
      ref_key: "kCollapseItemRef",
      ref: a,
      class: [
        "k-collapse-item",
        unref(o),
        { "is-block": unref(r) },
        {
          "is-process": e16.process,
          "is-wait": e16.wait,
          "is-finish": e16.finish,
          "is-error": e16.error,
          "is-warning": e16.warning
        }
      ]
    }, s.$attrs), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var p8 = $e(m8, { CollapseItem: l1 });
var h8 = tn(l1);
var g8 = ["draggable"];
var v8 = { class: "k-view-item__label" };
var y8 = { class: "k-view-item__other" };
var b8 = { key: 0 };
var ju = defineComponent({
  name: "KViewItem",
  __name: "view_item",
  props: {
    label: {},
    value: {},
    count: {},
    custom: { type: Boolean },
    disabled: { type: Boolean },
    showCustomControl: { type: Boolean },
    originData: {}
  },
  emits: ["change", "remove", "_drag-start", "_drag-drop"],
  setup(e16, { emit: t10 }) {
    const n = e16, o = t10, r = inject("activeView", ref(0)), a = inject("_styleModule", ""), i = inject("parentProps", {});
    function s(p) {
      switch (p) {
        case "remove":
          c();
      }
    }
    function l() {
      n.disabled || r.value === n.value || o("change", n.originData);
    }
    function c() {
      o("remove", n.originData);
    }
    function u(p) {
      i.draggable && o("_drag-start", p.currentTarget, n.originData);
    }
    function d(p) {
      i.draggable && p.preventDefault();
    }
    function m(p) {
      i.draggable && o("_drag-drop", p.currentTarget);
    }
    return (p, f) => (openBlock(), createElementBlock("div", {
      class: normalizeClass([
        "k-view-item",
        unref(a),
        {
          "k-view-active": unref(r) === n.value,
          "k-view-disabled": n.disabled
        }
      ]),
      draggable: unref(i).draggable,
      onDragstart: u,
      onDragover: d,
      onDrop: m,
      onClick: l
    }, [
      createBaseVNode("div", v8, [
        renderSlot(p.$slots, "label", {}, () => [
          createTextVNode(toDisplayString(n.label), 1)
        ])
      ]),
      createBaseVNode("div", y8, [
        unref(i).showCount ? (openBlock(), createElementBlock("span", b8, toDisplayString(n.count), 1)) : createCommentVNode("", true),
        p.showCustomControl ?? unref(i).showCustomControl ? (openBlock(), createBlock(unref(ElDropdown), {
          key: 1,
          trigger: "click",
          onCommand: s
        }, {
          dropdown: withCtx(() => [
            createVNode(unref(ElDropdownMenu), null, {
              default: withCtx(() => [
                createVNode(unref(ElDropdownItem), { command: "remove" }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(p.$t("remove")), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createBaseVNode("span", {
              class: "k-view-item-remove",
              onClick: f[0] || (f[0] = withModifiers(() => {
              }, ["stop", "prevent"]))
            }, [
              createVNode(unref(oi))
            ])
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ])
    ], 42, g8));
  }
});
var _8 = { class: "k-tree-node-label" };
var w8 = defineComponent({
  name: "KTree",
  __name: "tree",
  props: {
    filterMethod: { type: Function, default: (e16, t10) => {
      var n;
      return (n = t10.label) == null ? void 0 : n.includes(e16);
    } },
    icon: { type: [Function, String], default: "" },
    expandIcon: { type: [Function, String], default: "" },
    collapseIcon: { type: [Function, String], default: "" },
    showArrow: { type: Boolean, default: true },
    props: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(), a = computed(() => (s, l) => {
      let c = "";
      return s.isLeaf ? c = n.icon : s.expanded ? c = n.expandIcon : c = n.collapseIcon, typeof c == "function" ? c(s, l) : c;
    });
    return t10(Ae({}, r)), (s, l) => (openBlock(), createBlock(unref(ElTree), mergeProps({
      ref_key: "KTreeRef",
      ref: r,
      class: ["k-tree", unref(o), { "k-tree-show-arrow": n.showArrow }],
      "filter-method": s.filterMethod,
      props: n.props
    }, s.$attrs), {
      default: withCtx(({ node: c, data: u }) => [
        a.value(c, u) ? (openBlock(), createBlock(resolveDynamicComponent(a.value(c, u)), { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("span", _8, [
          renderSlot(s.$slots, "default", {
            node: c,
            data: u
          }, () => {
            var d, m;
            return [
              createTextVNode(toDisplayString(typeof ((d = n.props) == null ? void 0 : d.label) == "function" ? u[n.props.label(u, c) ?? "label"] : u[((m = n.props) == null ? void 0 : m.label) ?? "label"]), 1)
            ];
          })
        ])
      ]),
      _: 3
    }, 16, ["class", "filter-method", "props"]));
  }
});
var el = $e(w8);
var T8 = { class: "k-view__header" };
var C8 = { class: "view-title text-base font-bold" };
var k8 = ["id"];
var S8 = ["id"];
var N8 = { class: "custom-table-box" };
var M8 = { class: "k-view-content" };
var $8 = defineComponent({
  name: "KView",
  __name: "view",
  props: {
    defaultActive: {},
    data: {},
    draggable: { type: Boolean, default: false },
    collapse: { type: Boolean, default: false },
    showCustomControl: { type: Boolean, default: false },
    useTree: { type: Boolean, default: false },
    treeConfig: { default: () => ({}) },
    showArrow: { type: Boolean, default: false },
    showCount: { type: Boolean, default: true },
    props: {}
  },
  emits: [
    "refresh",
    "change",
    "remove",
    "drag",
    "visible",
    "node-expand",
    "node-collapse"
  ],
  setup(e16, { expose: t10, emit: n }) {
    const o = {
      label: "label",
      value: "value",
      count: "count",
      children: "children",
      disabled: "disabled",
      custom: "custom"
    }, r = e16, a = n, i = inject("_styleModule", ""), s = ref(""), l = computed(() => Object.assign(o, r.props ?? {})), c = computed(() => {
      var D;
      return ((D = r.data) == null ? void 0 : D.filter((te) => !te[l.value.custom])) ?? [];
    }), u = computed(() => {
      var D;
      return (D = r.data) == null ? void 0 : D.filter((te) => !!te[l.value.custom]);
    }), d = ref([]), m = ref("");
    watch(
      () => r.defaultActive,
      (D) => {
        var ie, U;
        let te = D;
        D || (te = ((U = (ie = r.data) == null ? void 0 : ie[0]) == null ? void 0 : U[l.value.value]) ?? ""), s.value = te, d.value = [te ?? ""], m.value = te ?? "";
      },
      { immediate: true }
    );
    function p() {
      a("refresh");
    }
    function f(D, te) {
      s.value = D[l.value.value], a("change", { value: s.value, data: D, node: te });
    }
    function h10(D) {
      a("remove", { value: D[l.value.value], data: D });
    }
    function g(D, te) {
      y(te) || a("node-expand", D, te);
    }
    function v(D, te) {
      y(te) || a("node-collapse", D, te);
    }
    function y(D) {
      return D.isLeaf;
    }
    const k = {
      element: null,
      data: null
    };
    let T = false;
    const w = Dt(8), _ = Dt(8);
    function M(D, te) {
      k.element = D, k.data = te, T = te[l.value.custom] ?? false;
    }
    function x(D) {
      var oe;
      if (!k.element || k.element === D)
        return;
      const te = T ? _ : w, ie = document.getElementById(te);
      if (!R(ie, D))
        return;
      const U = document.createElement("div");
      ie == null || ie.appendChild(U), ie == null || ie.replaceChild(U, D), ie == null || ie.replaceChild(D, k.element), ie == null || ie.replaceChild(k.element, U), k.element = null, T = false, a("drag", { value: (oe = k.data) == null ? void 0 : oe[l.value.value], data: k.data }), k.data = null;
    }
    function R(D, te) {
      return !D || !te ? false : D.contains(te);
    }
    const I = ref(r.collapse);
    function P() {
      F(), a("visible", !I.value);
    }
    function F() {
      I.value = !I.value;
    }
    function N() {
      I.value = false;
    }
    function j() {
      I.value = true;
    }
    function z() {
      return !I.value;
    }
    function A() {
      return I.value;
    }
    function B(D) {
      return {
        label: D[l.value.label] ?? "",
        value: D[l.value.value] ?? "",
        count: D[l.value.count] ?? 0,
        disabled: D[l.value.disabled] ?? false,
        custom: D[l.value.custom] ?? false,
        showCustomControl: D.showCustomControl ?? false
      };
    }
    return provide("activeView", s), provide("parentProps", r), t10({
      expand: N,
      collapse: j,
      toggle: F,
      isExpand: z,
      isCollapse: A
    }), (D, te) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["k-view", "text-base", unref(i)])
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["k-view-nav p-2 h-full border-r border-gray-200 relative flex-shrink-0", { "is-collapse": I.value }])
      }, [
        createBaseVNode("div", {
          class: "showViewBtn flex justify-center items-center rounded-full",
          onClick: P
        }, [
          createVNode(unref(vl), {
            class: normalizeClass({ "is-collapse": !I.value })
          }, null, 8, ["class"])
        ]),
        createBaseVNode("div", {
          class: "k-view-aside",
          style: normalizeStyle({ display: I.value ? "none" : "flex" })
        }, [
          createBaseVNode("div", T8, [
            createBaseVNode("div", C8, [
              renderSlot(D.$slots, "header", {}, () => [
                createTextVNode(toDisplayString(D.$t("view")), 1)
              ])
            ]),
            createBaseVNode("span", {
              class: "view-fresh",
              onClick: p
            }, [
              renderSlot(D.$slots, "refresh", {}, () => [
                createVNode(unref(g0))
              ])
            ])
          ]),
          createBaseVNode("div", {
            id: unref(w),
            class: "k-view__special-data"
          }, [
            createVNode(unref(ElScrollbar), null, {
              default: withCtx(() => {
                var ie;
                return [
                  D.useTree ? (openBlock(), createBlock(unref(el), mergeProps({
                    key: 1,
                    ref: "KViewTree",
                    class: "k-tree-view-item",
                    "node-key": l.value.value,
                    props: {
                      label: l.value.label,
                      disabled: l.value.disabled,
                      children: l.value.children
                    },
                    "default-expanded-keys": d.value,
                    "current-node-key": m.value,
                    data: r.data,
                    "show-arrow": D.showArrow,
                    "highlight-current": ""
                  }, D.treeConfig, {
                    onCurrentChange: f,
                    onNodeExpand: g,
                    onNodeCollapse: v
                  }), createSlots({ _: 2 }, [
                    D.$slots.label ? {
                      name: "default",
                      fn: withCtx(({ node: U, data: oe }) => [
                        renderSlot(D.$slots, "label", {
                          node: U,
                          data: oe
                        })
                      ]),
                      key: "0"
                    } : void 0
                  ]), 1040, ["node-key", "props", "default-expanded-keys", "current-node-key", "data", "show-arrow"])) : (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(c.value, (U) => (openBlock(), createBlock(ju, mergeProps({
                    key: U[l.value.value],
                    "origin-data": U,
                    ref_for: true
                  }, B(U), {
                    onChange: f,
                    onRemove: h10,
                    on_dragStart: M,
                    on_dragDrop: x
                  }), createSlots({ _: 2 }, [
                    D.$slots.label ? {
                      name: "label",
                      fn: withCtx(() => [
                        renderSlot(D.$slots, "label", { data: U })
                      ]),
                      key: "0"
                    } : void 0
                  ]), 1040, ["origin-data"]))), 128)),
                  (ie = u.value) != null && ie.length ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    id: unref(_),
                    class: "k-view__custom-data text-base"
                  }, [
                    renderSlot(D.$slots, "custom-header", {}, () => [
                      createBaseVNode("span", N8, toDisplayString(D.$t("customView")), 1)
                    ]),
                    D.useTree ? (openBlock(), createBlock(unref(el), mergeProps({
                      key: 1,
                      ref: "KCustomViewTree",
                      class: "k-tree-view-item",
                      "node-key": l.value.value,
                      props: {
                        label: l.value.label,
                        disabled: l.value.disabled,
                        children: l.value.children
                      },
                      "default-expanded-keys": d.value,
                      "current-node-key": m.value,
                      data: r.data,
                      "highlight-current": "",
                      "show-arrow": D.showArrow
                    }, D.treeConfig, {
                      onCurrentChange: f,
                      onNodeExpand: g,
                      onNodeCollapse: v
                    }), createSlots({ _: 2 }, [
                      D.$slots.label ? {
                        name: "default",
                        fn: withCtx(({ node: U, data: oe }) => [
                          renderSlot(D.$slots, "label", {
                            node: U,
                            data: oe
                          })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["node-key", "props", "default-expanded-keys", "current-node-key", "data", "show-arrow"])) : (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(u.value, (U) => (openBlock(), createBlock(ju, mergeProps({
                      key: U[l.value.value],
                      "origin-data": U,
                      ref_for: true
                    }, B(U), {
                      onChange: f,
                      onRemove: h10,
                      on_dragStart: M,
                      on_dragDrop: x
                    }), createSlots({ _: 2 }, [
                      D.$slots.label ? {
                        name: "label",
                        fn: withCtx(() => [
                          renderSlot(D.$slots, "label", { data: U })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["origin-data"]))), 128))
                  ], 8, S8)) : createCommentVNode("", true)
                ];
              }),
              _: 3
            })
          ], 8, k8)
        ], 4)
      ], 2),
      createBaseVNode("div", M8, [
        renderSlot(D.$slots, "default"),
        renderSlot(D.$slots, s.value)
      ])
    ], 2));
  }
});
var x8 = $e($8);
var I8 = defineComponent({
  name: "KBadge",
  __name: "badge",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElBadge), mergeProps({
      ref_key: "badgeRef",
      ref: o,
      class: ["k-badge", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var D8 = $e(I8);
var A8 = defineComponent({
  name: "KTimeline",
  __name: "time_line",
  props: {
    showLine: { type: Boolean, default: true }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = computed(() => !n.showLine), a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createElementBlock("div", {
      ref_key: "KTimelineRef",
      ref: a,
      class: normalizeClass(["k-timeline", unref(o), { "hidden-line": r.value }])
    }, [
      createVNode(unref(ElTimeline), null, {
        default: withCtx(() => [
          renderSlot(s.$slots, "default")
        ]),
        _: 3
      })
    ], 2));
  }
});
var c1 = defineComponent({
  name: "KTimelineItem",
  __name: "timeline_item",
  props: {
    placement: { default: "top" },
    type: { default: "wait" },
    color: {},
    hollow: { type: Boolean }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = Dt(8);
    let a, i;
    onMounted(() => {
      a = document.getElementById(r), i = (a == null ? void 0 : a.querySelector(".el-timeline-item__node")) || null;
    }), watch(() => n.color, (d) => {
      nextTick(() => {
        !i || !d || !n.hollow || (i.style.borderColor = n.color || "");
      });
    }, { immediate: true });
    const s = computed(() => n.placement === "right");
    function l(d) {
      const m = ["primary", "success", "warning"];
      if (d === "wait")
        return "info";
      if (d === "error")
        return "danger";
      if (m.includes(d))
        return d;
    }
    const c = ref(null);
    return t10(Ae({}, c)), (d, m) => (openBlock(), createBlock(unref(ElTimelineItem), mergeProps(d.$attrs, {
      id: unref(r),
      ref_key: "KTimelineItemRef",
      ref: c,
      type: l(d.type),
      placement: d.placement === "right" ? "top" : d.placement,
      hollow: d.hollow,
      color: d.color,
      class: [
        "k-timeline__item",
        unref(o),
        {
          "is-show-right": s.value,
          "is-hollow": n.hollow
        }
      ]
    }), createSlots({ _: 2 }, [
      renderList(d.$slots, (p, f) => ({
        name: f,
        fn: withCtx((h10) => [
          renderSlot(d.$slots, f, normalizeProps(guardReactiveProps(h10)))
        ])
      }))
    ]), 1040, ["id", "type", "placement", "hollow", "color", "class"]));
  }
});
var E8 = $e(A8, { TimelineItem: c1 });
var K8 = tn(c1);
var z8 = {
  1: "",
  2: "",
  3: "",
  4: "",
  5: "",
  6: "",
  7: "",
  8: "",
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: "",
  15: "",
  16: "",
  17: "",
  18: "",
  19: "",
  20: "",
  21: "",
  22: "",
  23: "",
  24: "",
  25: "",
  26: "",
  27: "",
  28: "",
  29: "",
  30: ""
};
var P8 = {
  1: "",
  2: "",
  3: "",
  4: "",
  5: "",
  6: "",
  7: "",
  8: "",
  9: "",
  10: "",
  11: "",
  12: ""
};
var R8 = { class: "k-calendar__header" };
var L8 = { class: "k-calendar__header-left" };
var F8 = { class: "k-calendar__header-right" };
var j8 = { class: "k-calendar__item" };
var O8 = { class: "k-calendar__date" };
var B8 = { class: "k-calendar__solar" };
var Z8 = { class: "k-calendar__schedule" };
var W8 = defineComponent({
  name: "KCalendar",
  __name: "calendar",
  props: {
    schedule: { default: () => [] },
    showLunar: { type: Boolean, default: false },
    adaptive: { type: Boolean, default: false }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(), a = ref(false), i = computed(
      () => function(p) {
        const f = p.getFullYear(), h10 = p.getMonth() + 1, g = p.getDate(), v = (0, import_chinese_lunar_calendar.getLunar)(f, h10, g);
        return {
          ...v,
          lunarMonth_zh: P8[v.lunarMonth],
          lunarDate_zh: z8[v.lunarDate]
        };
      }
    ), s = computed(() => n.schedule.map((p) => {
      const { date: f } = p;
      let h10;
      const g = new Date(f);
      return g instanceof Date && !Number.isNaN(g == null ? void 0 : g.getTime()) && (h10 = d(g)), {
        date: h10,
        content: p.content
      };
    }).filter((p) => p.date)), l = computed(
      () => function(p) {
        const f = s.value.find(
          (h10) => h10.date === d(p)
        );
        return (f == null ? void 0 : f.content) || [];
      }
    );
    function c(p) {
      var f;
      (f = r.value) == null || f.selectDate(p);
    }
    function u(p) {
      a.value = p;
    }
    function d(p) {
      const f = p.getFullYear(), h10 = p.getMonth() + 1, g = p.getDate();
      return `${f}-${h10 < 10 ? "0" : ""}${h10}-${g < 10 ? "0" : ""}${g}`;
    }
    return t10(Ae({
      jumpDate: c,
      handleLunar: u
    }, r)), (p, f) => {
      const h10 = resolveComponent("k-button");
      return openBlock(), createBlock(unref(ElCalendar), mergeProps({
        ref_key: "kCalendarRef",
        ref: r,
        class: ["k-calendar", unref(o), { "k-calendar--adaptive": p.adaptive }, "text-base"]
      }, p.$attrs), {
        header: withCtx(({ date: g }) => [
          renderSlot(p.$slots, "header", { date: g }, () => [
            createBaseVNode("div", R8, [
              createBaseVNode("div", L8, [
                createVNode(h10, {
                  onClick: f[0] || (f[0] = (v) => c("today"))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(p.$t("today")), 1)
                  ]),
                  _: 1
                }),
                createVNode(h10, {
                  onClick: f[1] || (f[1] = (v) => c("prev-month"))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(wp))
                  ]),
                  _: 1
                }),
                createVNode(h10, {
                  onClick: f[2] || (f[2] = (v) => c("next-month"))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(vl))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", null, toDisplayString(g), 1)
              ]),
              createBaseVNode("div", F8, [
                p.showLunar ? (openBlock(), createBlock(unref(fa), {
                  key: 0,
                  modelValue: a.value,
                  "onUpdate:modelValue": f[3] || (f[3] = (v) => a.value = v),
                  label: p.$t("showLunar")
                }, null, 8, ["modelValue", "label"])) : createCommentVNode("", true)
              ])
            ])
          ])
        ]),
        "date-cell": withCtx((g) => [
          renderSlot(p.$slots, "date-cell", normalizeProps(guardReactiveProps(g)), () => [
            createBaseVNode("div", j8, [
              createBaseVNode("div", O8, [
                createBaseVNode("span", B8, toDisplayString(g.data.date.getDate()), 1),
                withDirectives(createBaseVNode("span", { class: "k-calendar__lunar" }, toDisplayString(i.value(g.data.date).lunarDate_zh), 513), [
                  [vShow, a.value]
                ])
              ]),
              renderSlot(p.$slots, "schedule", {
                date: g.data.date
              }, () => [
                createBaseVNode("div", Z8, [
                  createBaseVNode("ul", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(l.value(g.data.date), (v) => (openBlock(), createElementBlock("li", {
                      key: v,
                      ref_for: true,
                      ref: "scheduleItemRef",
                      class: "k-calendar__schedule-item"
                    }, toDisplayString(v), 1))), 128))
                  ])
                ])
              ])
            ])
          ])
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
});
var q8 = $e(W8);
var V8 = {
  key: 0,
  class: "column-default__content"
};
var H8 = defineComponent({
  __name: "table_column_content",
  props: {
    row: {
      type: Object,
      default: () => {
      }
    },
    col: {
      type: Object,
      default: () => {
      }
    },
    size: {
      type: String,
      default: "default"
    },
    align: {
      type: String,
      default: () => "left"
    }
  },
  setup(e16) {
    const t10 = inject("tableInstance"), n = e16, o = computed(
      () => (a) => {
        var i;
        return ((i = a.iconStyle) == null ? void 0 : i.size) ?? (n.size === "mini" ? 16 : 20);
      }
    ), r = computed(() => (a) => {
      var i;
      return a.__folder ? (i = t10.value) != null && i.isTreeExpandByRow(a) ? "IconFolderOpen" : "IconFlowNested" : a.icon;
    });
    return (a, i) => {
      var s, l, c, u;
      return e16.col.type ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", V8, [
        n.col.showIcon && (e16.row.icon || e16.row.__folder) ? (openBlock(), createBlock(resolveDynamicComponent(r.value(e16.row)), {
          key: 0,
          color: e16.row.__folder ? "#FAC814" : (s = e16.row.iconStyle) != null && s.empty ? "#cdcacf" : (l = e16.row.iconStyle) == null ? void 0 : l.color,
          size: o.value(e16.row),
          grayscale: !!((c = e16.row.iconStyle) != null && c.grayscale)
        }, null, 8, ["color", "size", "grayscale"])) : createCommentVNode("", true),
        createBaseVNode("span", {
          class: "column-default__content__text",
          style: normalizeStyle({
            marginLeft: (e16.row.icon || e16.row.__folder) && e16.col.showIcon ? `${o.value(e16.row) + (((u = e16.row.iconStyle) == null ? void 0 : u.indent) ?? 3)}px` : 0
          })
        }, [
          a.$slots[`${e16.col.field ?? ""}-label`] ? renderSlot(a.$slots, `${e16.col.field ?? ""}-label`, {
            key: 0,
            row: e16.row,
            column: e16.col
          }) : typeof e16.col.formatter == "function" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(e16.col.formatter({ cellValue: e16.row[e16.col.field], row: e16.row, column: e16.col })), 1)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createTextVNode(toDisplayString(e16.row[e16.col.field] === "" ? "-" : e16.row[e16.col.field] ?? "-"), 1)
          ], 64))
        ], 4)
      ]));
    };
  }
});
var U8 = ["header", "edit"];
var G8 = defineComponent({
  name: "ColumnGroup",
  props: {
    data: Array,
    column: {
      type: Object,
      default: () => ({})
    },
    size: {
      type: String,
      default: "default"
    },
    align: {
      type: String,
      default: () => "left"
    }
  },
  setup(e16, {
    slots: t10
  }) {
    return () => Array.isArray(e16.column.group) && e16.column.group.length ? n(e16.column) : o(t10, e16.column);
    function n(a) {
      const i = a.group || [], s = r(t10, a.field);
      return createVNode(o1, mergeProps(a, {
        key: a,
        resizable: true
      }), {
        default: () => [i.map((l) => Array.isArray(l.group) && l.group.length ? n(l) : o(t10, l))],
        ...s
      });
    }
    function o(a, i) {
      const s = r(a, i.field);
      return !i.render && (a[i.field ?? ""] || i.showIcon) && !i.type && (s.default = (l) => {
        var d;
        const c = i.field ?? "", {
          row: u
        } = l;
        if (a[c])
          return (d = a[c]) == null ? void 0 : d.call(a, l);
        if (i.showIcon) {
          const m = {}, p = `${c}-label`;
          return a[p] && (m[p] = (f) => {
            var h10;
            return (h10 = a[p]) == null ? void 0 : h10.call(a, f);
          }), createVNode(H8, {
            key: i.field,
            col: i,
            row: u,
            size: e16.size,
            align: e16.align
          }, m);
        }
      }), createVNode(Ur, mergeProps({
        key: i.field
      }, i), s);
    }
    function r(a, i) {
      if (!i)
        return {};
      const s = {};
      for (const l of U8) {
        const c = `${i}-${l}`;
        a[c] && (s[l] = (u) => {
          var d;
          return (d = a[c]) == null ? void 0 : d.call(a, u);
        });
      }
      return s;
    }
  }
});
function X8(e16, t10) {
  const n = {
    data: [],
    sortData: [],
    filterData: []
  }, o = ref([]), r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = [], l = computed(() => {
    var N;
    return ((N = e16.rowConfig) == null ? void 0 : N.keyField) ?? "id";
  }), c = (N) => new Promise((j) => {
    var A;
    const z = Array.isArray(N) ? N : [N];
    if (_(), !e16.useTree)
      o.value.unshift(...z);
    else
      for (let B = 0; B < z.length; B++) {
        const D = z[B], te = ((A = e16.treeConfig) == null ? void 0 : A.parentField) ?? "pid", ie = o.value.find((oe) => oe[l.value] === D[te]);
        if (!ie) {
          o.value.unshift(D);
          return;
        }
        const U = o.value.findIndex((oe) => oe[te] === ie[l.value]);
        U === -1 ? o.value.unshift(D) : o.value.splice(U, 0, D);
      }
    w(z, r), M(), j(N);
  }), u = (N, j, z = false) => new Promise((A) => {
    var D;
    const B = Array.isArray(N) ? N : [N];
    if (_(), e16.useTree) {
      const te = [], ie = [];
      let U = -1;
      for (let oe = 0; oe < B.length; oe++) {
        const se = B[oe], E = ((D = e16.treeConfig) == null ? void 0 : D.parentField) ?? "pid";
        if (typeof j == "object" && (j[E] === se[E] || !j[E] && !se[E]))
          U = o.value.findIndex((K) => K[l.value] === j[l.value]), U !== -1 && te.push(se);
        else {
          const K = o.value.find((ee) => ee[l.value] === se[E]);
          K ? (U = o.value.findIndex((ee) => ee[E] === K[l.value]), U === -1 ? ie.push(se) : te.push(se)) : ie.push(se);
        }
      }
      o.value.splice(z ? U + 1 : U, 0, ...te), o.value.push(...ie);
    } else {
      let te;
      const ie = o.value.length;
      if (typeof j == "number")
        te = (Number.isNaN(Math.floor(j)) ? 0 : Math.floor(j)) % ie;
      else if (typeof j == "object") {
        const U = o.value.findIndex((oe) => oe[l.value] === (j == null ? void 0 : j[l.value]));
        te = U === -1 ? 0 : U;
      } else
        te = 0;
      te === -1 ? o.value.push(...B) : (te = z ? te + 1 : te, o.value.splice(te, 0, ...B));
    }
    w(B, r), M(), A(N);
  }), d = (N, j) => u(N, j), m = (N, j) => u(N, j, true), p = () => new Promise((N) => {
    _();
    const j = Array.from(r.values());
    for (let z = 0; z < o.value.length - 1 && r.size !== 0; z++) {
      const A = o.value[z][l.value];
      r.has(A) && (o.value.splice(z, 1), r.delete(A), z--);
    }
    M(), N({ rows: j, row: j });
  }), f = () => Array.from(r.values()), h10 = (N) => r.has(N[l.value]), g = (N) => new Promise((j) => {
    N === void 0 && (o.value.length = 0, j({ rows: [], row: null }));
    let z = N;
    Array.isArray(N) || (z = [N]);
    const A = new Map(z.map((B) => [B[l.value], B]));
    for (let B = 0; B < o.value.length; B++) {
      const D = o.value[B][l.value];
      A.has(D) && (o.value.splice(B, 1), A.delete(D), B--);
    }
    w(z, a), j({ rows: N, row: N });
  }), v = () => Array.from(a.values()), y = () => ({
    insertRecords: Array.from(r.values()),
    removeRecords: Array.from(a.values()),
    updateRecords: Array.from(i.values()),
    pendingRecords: []
  }), k = (N, j) => new Promise((z) => {
    (!N || !j) && z(N);
    let A = N;
    Array.isArray(N) || (A = [N]), A.forEach((B) => {
      Object.assign(B, j), i.set(B[l.value], B);
    }), z(N);
  }), T = (N) => {
    if (_(), !(N != null && N.length)) {
      o.value.length = 0, o.value.push(...n.data);
      return;
    }
    eg(o.value, N), M();
  };
  function w(N, j) {
    N.forEach((z) => {
      j.set(z[l.value], z);
    });
  }
  function _() {
    const N = t10.value;
    !N || !e16.useTree || (s.length = 0, s.push(...N.getTreeExpandRecords() ?? []));
  }
  async function M() {
    const N = t10.value;
    !N || !e16.useTree || setTimeout(async () => {
      await N.setTreeExpand(s, true), s.length = 0;
    });
  }
  function x(N) {
    var U, oe, se, E, K, ee, V, le;
    _();
    const j = N.item, z = j.previousElementSibling, A = (U = t10.value) == null ? void 0 : U.getRowNode(j);
    if (!A)
      return false;
    const B = A.item, D = (oe = o.value) == null ? void 0 : oe.findIndex((pe) => pe.id === B.id), te = (se = o.value) == null ? void 0 : se.splice(D, 1)[0];
    let ie = 0;
    if (z) {
      const pe = (E = t10.value) == null ? void 0 : E.getRowNode(z);
      if (!pe)
        return false;
      const Te = pe.item;
      if (I(te, Te))
        return console.warn("Can not move to child node"), R(te, D), false;
      const Z = (K = o.value) == null ? void 0 : K.findIndex((Q) => Q.id === Te.id), X = (ee = t10.value) == null ? void 0 : ee.getRowById(Te.parentId);
      ie = Z + 1, (V = t10.value) != null && V.isTreeExpandByRow(Te) ? te.parentId = Te.id : (le = t10.value) != null && le.isTreeExpandByRow(X) ? te.parentId = Te.parentId ?? null : te.parentId = (X == null ? void 0 : X.parentId) ?? null;
    } else
      te.parentId = null, ie = 0;
    return R(te, ie), true;
  }
  function R(N, j) {
    setTimeout(() => {
      var z;
      (z = o.value) == null || z.splice(j, 0, N), M();
    });
  }
  function I(N, j) {
    var D;
    const z = ((D = e16.treeConfig) == null ? void 0 : D.parentField) ?? "pid", A = l.value;
    if (!N[A] || !j || !j[z])
      return false;
    if (N[A] === j[z])
      return true;
    const B = o.value.find((te) => te[A] === j[z]);
    return I(N, B);
  }
  async function P(N, j, z = 100) {
    return new Promise(async (A) => {
      var te, ie, U, oe, se;
      const B = Array.isArray(N) ? N : [N];
      (((te = e16.treeConfig) == null ? void 0 : te.lazy) ?? false) || (await ((ie = t10.value) == null ? void 0 : ie.setTreeExpand(B, j)), A(null));
      try {
        const E = new Event("click", { bubbles: true });
        for (const K of B) {
          if (await ((U = t10.value) == null ? void 0 : U.clearTreeExpandLoaded(K)), ((oe = t10.value) == null ? void 0 : oe.isTreeExpandByRow(K)) === j)
            continue;
          const V = (se = t10.value) == null ? void 0 : se.$el.querySelector(`[rowid='${K.id}'] .vxe-tree--btn-wrapper`);
          V && V.dispatchEvent(E);
        }
      } catch (E) {
        console.error(E);
      }
      setTimeout(() => {
        A(null);
      }, z);
    });
  }
  function F(N) {
    r.clear(), a.clear(), i.clear();
    const j = Array.isArray(N) ? N : [];
    return o.value = Array.from(j), n.data = [...o.value], o.value;
  }
  return {
    _methods: {
      insert: c,
      insertAt: d,
      insertNextAt: m,
      removeInsertRow: p,
      getInsertRecords: f,
      isInsertByRow: h10,
      remove: g,
      getRemoveRecords: v,
      getRecordset: y,
      setRow: k,
      setTreeExpand: P
    },
    setTableData: F,
    sortChange: T,
    dragSort: x
  };
}
function Y8(e16, t10, n) {
  const o = {}, r = ref(/* @__PURE__ */ new Set()), a = /* @__PURE__ */ new Set(), i = computed(() => r.value.size);
  onMounted(() => {
    const { checkRowKeys: w, checkAll: _ } = s.value, M = Array.isArray(w) ? w : [], R = (_ ? t10.value.map((I) => I[l.value]) : M).map((I) => {
      var F;
      return (F = e16.value) == null ? void 0 : F.getRowById(I);
    });
    d(R, true);
  });
  const s = computed(() => Object.assign(o, n.checkboxConfig || {})), l = computed(() => {
    var w;
    return ((w = n.rowConfig) == null ? void 0 : w.keyField) ?? "id";
  }), c = (w, _) => new Promise((M) => {
    var I;
    const x = Array.isArray(w) ? w : [w], R = [];
    for (const P of x)
      k(P) || R.push(P);
    d(R, _), (I = e16.value) == null || I.setCheckboxRow(R, _), M({ rows: w, checked: _ });
  }), u = (w) => new Promise((_) => {
    var x, R;
    const M = [];
    if (w) {
      for (const I of t10.value)
        k(I) || M.push(I);
      d(M, w), (x = e16.value) == null || x.setCheckboxRow(M, w);
    } else
      T(), (R = e16.value) == null || R.setAllCheckboxRow(w);
    _({ checked: w });
  }), d = (w, _) => {
    var x;
    const M = Array.isArray(w) ? w : [w];
    for (const R of M) {
      const I = (x = e16.value) == null ? void 0 : x.getRowById(R[l.value]);
      m(I, _);
    }
  }, m = (w, _) => {
    if (w && (_ ? r.value.add(w[l.value]) : r.value.delete(w[l.value]), (!w.children || w.children.length === 0) && (_ ? a.add(w[l.value]) : a.delete(w[l.value])), w.children && w.children.length))
      for (const M of w.children)
        m(M, _);
  };
  async function p() {
    var _, M, x;
    if (await ((_ = e16.value) == null ? void 0 : _.clearCheckboxRow()), a.size === 0)
      return;
    const w = [];
    for (const R of a.values()) {
      const I = (M = e16.value) == null ? void 0 : M.getRowById(R);
      I && w.push(I);
    }
    (x = e16.value) == null || x.setCheckboxRow(w, true);
  }
  const f = () => new Promise((w) => {
    var _;
    n.showPage && !n.useTree ? d(t10.value, false) : T(), (_ = e16.value) == null || _.clearCheckboxRow(), w(void 0);
  }), h10 = async () => {
    var w;
    await ((w = e16.value) == null ? void 0 : w.clearCheckboxReserve()), new Promise((_) => {
      var M, x;
      if (n.showPage && !n.useTree) {
        const R = (M = e16.value) == null ? void 0 : M.getCheckboxRecords();
        r.value = new Set(R.map((I) => I[l.value])), (x = e16.value) == null || x.setCheckboxRow(R, true);
      }
      _(void 0);
    });
  };
  function g({ row: w, checked: _ }) {
    d(w, _);
  }
  function v({ checked: w }) {
    var x;
    const M = (((x = e16.value) == null ? void 0 : x.getCheckboxRecords()) ?? []).filter((R) => !R.children || !R.children.length);
    d(M, w);
  }
  function y() {
    f(), T(), e16.value.clearCheckboxReserve();
  }
  function k(w) {
    const { visibleMethod: _, checkMethod: M } = s.value;
    return typeof _ == "function" && !_({ row: w }) || typeof M == "function" && !M({ row: w });
  }
  function T() {
    r.value.clear(), a.clear();
  }
  return {
    _checkboxMethods: {
      setAllCheckboxRow: u,
      setCheckboxRow: c,
      clearCheckboxRow: f,
      clearCheckboxReserve: h10
    },
    checkBoxChange: g,
    checkboxAll: v,
    closeBatchOperation: y,
    isCheckboxDisabled: k,
    clearCheckedData: T,
    resetCheckboxStatus: p,
    checkedDataSize: i,
    checkboxConfig: s
  };
}
var Q8 = {
  key: 0,
  class: "k-tree-table__header-pure"
};
var J8 = {
  key: 0,
  class: "k-table-info"
};
var eb = { key: 0 };
var tb = ["title"];
var nb = { class: "k-table-func" };
var ob = { class: "text-sm" };
var ab = { class: "text-sm" };
var rb = { class: "table-box flex-1 overflow-auto" };
var ib = {
  key: 0,
  class: "batch-operate"
};
var sb = {
  key: 2,
  ref: "RefTablePagination",
  class: "pagination-box"
};
var lb = defineComponent({
  name: "KTreeTable",
  __name: "tree_table",
  props: {
    data: {},
    size: {},
    sortConfig: {},
    seqConfig: {},
    rowConfig: {},
    editConfig: {},
    scrollY: {},
    columnConfig: {},
    checkboxConfig: {},
    treeConfig: {},
    showOverflow: { type: [String, Boolean], default: true },
    autoResize: { type: Boolean, default: true },
    height: { default: "100%" },
    align: {},
    border: { type: [Boolean, String], default: "default" },
    emptyText: {},
    rowStyle: {},
    column: {},
    showPage: { type: Boolean, default: true },
    useTree: { type: Boolean },
    isRemoteQuery: { type: Boolean },
    isServerPaging: { type: Boolean },
    paginationConfig: {},
    showDescription: { type: Boolean, default: true },
    showHeaderTools: { type: Boolean, default: true },
    batchOperations: {},
    showBatchOperation: { type: Boolean },
    showColumnMenu: { type: Boolean, default: false },
    showDragColumn: { type: Boolean },
    cellClickToggleHighlight: { type: Boolean, default: true },
    widgets: {},
    showSearchInput: { type: Boolean, default: true },
    showFilter: { type: Boolean, default: true },
    showRefresh: { type: Boolean, default: true },
    showTransfer: { type: Boolean, default: false },
    showSizeControl: { type: Boolean },
    advancedFilterConfig: {},
    searchConfig: {},
    style: {},
    class: {},
    simple: { type: Boolean },
    defaultTransferData: {},
    onTransferShow: {},
    onTransferHide: {},
    onTransferChange: {},
    onAdvancedFilterShow: {},
    onAdvancedFilterHide: {},
    useAntStyle: { type: Boolean },
    round: { type: Boolean, default: false },
    adaptive: { type: Boolean }
  },
  emits: [
    "remote-query",
    "server-paging",
    "refresh",
    "highlight-clear",
    "highlight-change",
    "cell-click",
    "resizable-change",
    "hide-column",
    "checkbox-change",
    "checkbox-all",
    "drag",
    "sort-change",
    "advanced-filter-confirm",
    "advanced-filter-clear",
    "page-current-change",
    "page-size-change",
    "page-change",
    "prev-click",
    "next-click"
  ],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = inject("_styleModule", ""), a = useSlots(), i = inject("$t"), s = [25, 50, 80, 100, 150], l = /* @__PURE__ */ new Map([
      ["search", "search"],
      ["refresh", "refresh"],
      ["filter", "filter"],
      ["sizeControl", "sizeControl"],
      ["transfer", "transfer"]
    ]), c = {
      isHover: true,
      isCurrent: true,
      useKey: true,
      keyField: "id"
    }, u = {
      transform: true,
      rowField: "id",
      parentField: "pid",
      childrenField: "children",
      trigger: "cell",
      hasChildField: "hasChild"
    }, d = {
      pagerCount: 7,
      currentPage: 1,
      pageSizes: s,
      pageSize: s[0],
      size: o.useAntStyle ? "sm" : void 0,
      layout: o.useAntStyle ? "total, prev, pager, next, sizes" : void 0
    }, m = {}, p = {
      key: "id",
      trigger: "click",
      mode: "cell"
    }, f = {
      seqMethod: ({ rowIndex: C }) => {
        var ue;
        const G = ((ue = o.seqConfig) == null ? void 0 : ue.startIndex) ?? 1;
        if (Z.value) {
          const { pageSize: ge, currentPage: J } = B.value;
          return (J - 1) * ge + C + G;
        }
        return C + G;
      }
    }, h10 = { enabled: true }, g = { resizable: true }, v = n, y = ref(), k = ref(o.size), T = [
      { label: "", value: "" },
      { label: "", value: "medium" },
      { label: "", value: "small" },
      { label: "", value: "mini" }
    ], w = ref(), _ = ref([]), M = ref([]), x = ref([]), R = ref(""), I = ref(""), P = ref([]), F = ref([]), N = ref([]), j = ref(), z = ref([]), A = ref(), B = ref(d), D = computed(() => {
      const C = [];
      if (!Array.isArray(o.widgets))
        return o.showSearchInput && C.push({
          id: "search",
          slot: null
        }), o.showRefresh && C.push({
          id: "refresh",
          slot: null
        }), o.showFilter && C.push({
          id: "filter",
          slot: null
        }), o.showSizeControl && C.push({
          id: "sizeControl",
          slot: null
        }), o.showTransfer && C.push({
          id: "transfer",
          slot: null
        }), C;
      for (const G of o.widgets) {
        if (!G)
          continue;
        const ue = typeof G;
        ue === "string" ? l.get(G) ? C.push({ id: G, slot: null }) : C.push({ id: G, slot: G }) : (ue === "object" || ue === "function") && C.push(G);
      }
      return C;
    }), te = computed(() => {
      const { filterColumns: C, filterAll: G, exclude: ue = [] } = o.advancedFilterConfig ?? {}, ge = _d(
        Sr(_.value),
        "group",
        (J) => !J.type && J.title && J.field && (G !== false || J.visible !== false) && !ue.includes(J.field)
      );
      return C ? wd(ge, "group", C, "field") : ge;
    }), ie = computed(() => {
      var G;
      return (G = y.value) == null ? void 0 : G.tableInstance;
    }), U = computed(() => {
      var G, ue;
      let C = "";
      if ((ue = (G = A.value) == null ? void 0 : G.conditionList) != null && ue.length) {
        const { filterRule: ge } = A.value;
        C += ge === 0 ? i == null ? void 0 : i("anyOne") : i == null ? void 0 : i("all"), A.value.conditionList.forEach((J, Ce) => {
          const We = o.useTree && Ce === 0 ? "" : "";
          C += `  ${We} ${J.title} ${J.logic} ${J.showValue}`;
        });
      } else {
        const ge = o.useTree ? "" : " ";
        C += `${ge}${i == null ? void 0 : i("showAll")}`;
      }
      return C;
    }), oe = computed(() => k.value ?? void 0), se = computed(() => {
      const C = D.value.map((G) => G.id);
      return !!(o.showHeaderTools && C.includes("transfer"));
    }), E = computed(() => {
      if (o.useTree)
        return Object.assign(u, o.treeConfig || {});
    }), K = computed(() => Object.assign(m, o.sortConfig || {})), ee = computed(() => Object.assign(c, o.rowConfig || {})), V = computed(() => Object.assign(p, o.editConfig || {})), le = computed(() => {
      const C = Object.assign(h10, o.scrollY || {});
      return o.adaptive && (C.enabled = false), C;
    }), pe = computed(() => Object.assign(g, o.columnConfig || {})), Te = computed(() => Object.assign(f, o.seqConfig || {})), Z = computed(() => o.showPage && !o.useTree && !o.simple), X = computed(() => he()), Q = computed(() => {
      pn();
      const { isRemotePaging: C } = B.value;
      return !Z.value || o.isServerPaging || C ? X.value : un(X.value);
    }), W = computed(() => {
      const { isRemotePaging: C, total: G } = B.value;
      return Z.value && (C || o.isServerPaging) ? G : X.value.length;
    }), { setTableData: de, sortChange: Ne, dragSort: Pe, _methods: tt } = X8(o, ie), {
      checkedDataSize: Qe,
      checkboxConfig: lt,
      closeBatchOperation: Be,
      checkBoxChange: Xe,
      checkboxAll: it,
      clearCheckedData: St,
      resetCheckboxStatus: pn,
      _checkboxMethods: hn
    } = Y8(ie, Q, o);
    watch(
      [() => o.data, () => {
        var C;
        return (C = o.data) == null ? void 0 : C.length;
      }],
      () => {
        St(), x.value = de(o.data), zi();
      },
      { immediate: true }
    ), watch(
      () => o.paginationConfig,
      () => {
        B.value = Object.assign(B.value, o.paginationConfig || {});
      },
      { immediate: true, deep: true }
    ), onMounted(() => {
      Ai();
    }), watch(
      () => o.column,
      () => {
        _.value = o.column.map((C) => {
          const G = C.visible !== false, ue = C.field ?? `_table_column_${C.type ?? ""}`;
          return { ...Sr(C), visible: G, field: ue };
        }), cr(), lr();
      },
      { deep: true }
    );
    let cn = false;
    watch(
      () => {
        var C;
        return (C = Q.value) == null ? void 0 : C.length;
      },
      () => {
        o.useTree && nextTick(() => {
          var C, G;
          if (R.value.trim() || cn) {
            cn = false;
            const ue = Q.value.length > 500 ? 500 : Q.value.length, ge = Q.value.slice(0, ue);
            (C = ie.value) == null || C.setTreeExpand(ge, true);
          } else
            (G = ie.value) == null || G.clearTreeExpand();
        });
      },
      { immediate: true }
    );
    let ne = /* @__PURE__ */ new Map();
    const ae = /* @__PURE__ */ new Map();
    function he() {
      var Rt, ct, Zn;
      const C = (ct = (Rt = A.value) == null ? void 0 : Rt.conditionList) != null && ct.length ? z.value : x.value, { strict: G, searchMethod: ue, ignoreCase: ge = false } = o.searchConfig ?? {}, J = R.value.trim().replace(/\\/g, "\\\\");
      if (o.isRemoteQuery || (Zn = o.searchConfig) != null && Zn.isRemoteQuery)
        return v("remote-query", J), C;
      if (!J)
        return C;
      if (typeof ue == "function")
        return ue(J, C);
      const We = M.value.filter((ft) => ft.visible !== false).map((ft) => ft.field && !ft.type ? ft.field : null).filter((ft) => ft !== null);
      let vt = C.filter((ft) => We.some((Wo) => {
        const Ri = ie.value.getCellLabel(ft, Wo);
        return G === true ? Ri === J : ge ? String(Ri).toLowerCase().indexOf(J.toLowerCase()) !== -1 : String(Ri).indexOf(J) !== -1;
      }));
      if (o.useTree) {
        const { rowField: ft } = Oo();
        ne = new Map(x.value.map((Wo) => [Wo[ft], Wo])), xe(vt), vt = Ie([...ae.values()], x.value, ft);
      } else
        jo(vt.length);
      return vt;
    }
    function xe(C) {
      const { parentField: G, rowField: ue } = Oo();
      ae.clear();
      for (let J = 0; J < C.length; J++) {
        const Ce = C[J];
        ae.get(Ce[ue]) || (ae.set(Ce[ue], Ce), Je(Ce, G));
      }
      const ge = Ve();
      Ee(C, ge);
    }
    function Ee(C, G) {
      if (!C || !C.length)
        return;
      const ue = ee.value.keyField;
      for (const ge of C) {
        const J = G.get(ge[ue]);
        J && (J.children.forEach((Ce) => {
          ae.get(Ce[ue]) || ae.set(Ce[ue], Ce);
        }), Ee(J.children, G));
      }
    }
    function Ve() {
      const C = /* @__PURE__ */ new Map(), { rowField: G, parentField: ue } = Oo();
      for (const ge of x.value) {
        C.has(ge[G]) || C.set(ge[G], { node: ge, children: [] });
        const J = C.get(ge[ue]);
        J && J.children.push(ge);
      }
      return C;
    }
    function Je(C, G, ue) {
      const ge = C[G], J = ne.get(ge);
      J && (ae.get(ge) || ae.set(ge, J), J[G] !== null && Je(J, G));
    }
    function Ie(C, G, ue) {
      const ge = G.map((J) => J[ue]);
      return C.sort((J, Ce) => ge.indexOf(J[ue]) < ge.indexOf(Ce[ue]) ? -1 : 1);
    }
    function Nt() {
      I.value = "", R.value = "";
    }
    function bt(C) {
      B.value.pageSize = C;
      const { isRemotePaging: G } = B.value;
      (o.isServerPaging || G) && v("server-paging", B.value), v("page-size-change", C);
    }
    function Ze(C) {
      B.value.currentPage = C;
      const { isRemotePaging: G } = B.value;
      (o.isServerPaging || G) && v("server-paging", B.value), v("page-current-change", C);
    }
    function un(C) {
      const { isRemotePaging: G } = B.value;
      if (o.isServerPaging || G)
        return v("server-paging", B.value), C;
      const { currentPage: ue, pageSize: ge } = B.value, J = (ue - 1) * ge, Ce = J + ge;
      return C.slice(J, Ce);
    }
    function jo(C) {
      let { currentPage: G } = B.value;
      const ue = B.value.pageSize;
      for (; (G - 1) * ue + 1 > C && G > 1; )
        G--;
      B.value.currentPage = G;
    }
    function lo(C) {
      if (!o.rowStyle) {
        const { row: G } = C;
        return G.style || {};
      }
      return typeof o.rowStyle == "function" ? o.rowStyle(C) : o.rowStyle;
    }
    function lr() {
      for (const C of M.value)
        typeof C.render == "function" && (C.cellRender = {
          name: Dt(16),
          ...C.cellRender || {}
        }, index_esm_default2.renderer.add(C.cellRender.name, {
          renderDefault(G, { row: ue, column: ge }) {
            var J;
            return (J = C.render) == null ? void 0 : J.call(C, { row: ue, column: ge });
          }
        }), index_esm_default2.renderer.add(C.cellRender.name, {
          renderTableDefault(G, { row: ue, column: ge }) {
            var J;
            return (J = C.render) == null ? void 0 : J.call(C, { row: ue, column: ge });
          }
        })), typeof C.renderEdit == "function" && (C.editRender = {
          name: Dt(16),
          ...C.editRender || {}
        }, index_esm_default2.renderer.add(C.editRender.name, {
          renderTableEdit(G, { row: ue, column: ge }) {
            var J;
            return (J = C.renderEdit) == null ? void 0 : J.call(C, { row: ue, column: ge });
          }
        }));
    }
    function Oo() {
      var ue, ge;
      const C = ((ue = E.value) == null ? void 0 : ue.parentField) || "pid", G = ((ge = E.value) == null ? void 0 : ge.rowField) || "id";
      return { parentField: C, rowField: G };
    }
    function ka(C) {
      M.value.forEach((G) => {
        C.includes(G.field) ? G.visible = true : G.visible = false;
      });
    }
    async function Ai() {
      var J;
      let C = o.defaultTransferData ?? [];
      typeof o.defaultTransferData == "function" && (C = await ((J = o.defaultTransferData) == null ? void 0 : J.call(o))), C = Array.isArray(C) ? C : [];
      const G = new Map(
        C.map((Ce) => [Ce.key, Ce])
      ), ue = C.map((Ce) => Ce.key), ge = o.column.map((Ce) => {
        var ct, Zn;
        const We = Ce.field ?? `_table_column_${Ce.type ?? ""}`, vt = ((ct = G.get(We)) == null ? void 0 : ct.visible) ?? Ce.visible !== false, Rt = (Zn = G.get(We)) == null ? void 0 : Zn.width;
        return { ...Sr(Ce), visible: vt, field: We, __width__: Rt };
      });
      _.value = ge.sort((Ce, We) => ue.indexOf(Ce.field) - ue.indexOf(We.field)), cr(), lr(), vc(C), setTimeout(() => {
        Bn = JSON.stringify(fr());
      });
    }
    function cr() {
      M.value = Fr(_.value, "group"), F.value = M.value.map((C) => {
        if (C.field)
          return {
            label: C.title || C.type || "undefined",
            key: C.field
          };
      }).filter((C) => C !== void 0), P.value = M.value.filter((C) => C.visible !== false).map((C) => {
        if (C.field)
          return {
            label: C.title || C.type || "undefined",
            key: C.field
          };
      }).filter((C) => C !== void 0), N.value = P.value.map((C) => C.key).filter((C) => C !== void 0);
    }
    function ur(C) {
      if (!se.value)
        return;
      const G = M.value.find((ue) => ue.field === C.field);
      G && (G.visible = false, P.value = M.value.filter((ue) => ue.visible !== false).map((ue) => {
        if (ue.title && ue.field)
          return {
            label: ue.title,
            key: ue.field
          };
      }).filter((ue) => ue !== void 0), v("hide-column", C));
    }
    function co(C) {
      if (!Array.isArray(C))
        return;
      let G = 0;
      const ue = new Map(M.value.map((J) => [J.field, J])), ge = (J) => {
        var Ce;
        for (const [We, vt] of J.entries())
          if (Array.isArray(vt.group) && vt.group.length > 0)
            ge(vt.group);
          else {
            const Rt = (Ce = C[G++]) == null ? void 0 : Ce.key;
            J[We] = ue.get(Rt) ?? {};
          }
      };
      ge(_.value), M.value = Fr(_.value, "group");
    }
    function Bo() {
      typeof o.onTransferShow == "function" && o.onTransferShow();
    }
    let Bn = "";
    function uo() {
      if (typeof o.onTransferChange == "function") {
        const C = fr();
        JSON.stringify(C) !== Bn && (o.onTransferChange(C), Bn = JSON.stringify(C));
      }
    }
    function Ei() {
      if (typeof o.onTransferHide == "function") {
        const C = fr();
        o.onTransferHide(C);
      }
    }
    function Zo(C, G, ue = true) {
      var ge;
      if (A.value = C, z.value = G, o.useTree) {
        xe(z.value);
        const { rowField: J } = Oo();
        z.value = Ie([...ae.values()], x.value, J);
      }
      (ge = C == null ? void 0 : C.conditionList) != null && ge.length ? cn = true : cn = false, ue && v("advanced-filter-confirm", { conditionInfo: C, tableData: G });
    }
    function Ki(C) {
      R.value = C ?? "";
    }
    function nm() {
      typeof o.onAdvancedFilterShow == "function" && o.onAdvancedFilterShow();
    }
    function om() {
      if (typeof o.onAdvancedFilterHide == "function") {
        const C = gc(), G = z.value;
        o.onAdvancedFilterHide({ conditionInfo: C, filterData: G });
      }
    }
    let Sa = false, dr = null;
    function am({ row: C, rowid: G }) {
      var J, Ce, We;
      if (!o.cellClickToggleHighlight)
        return;
      Sa ? Sa && dr === G && ((J = ie.value) == null || J.setCurrentRow(null), Sa = false, dr = null, v("highlight-clear", C)) : Sa = true;
      const ue = (Ce = ie.value) == null ? void 0 : Ce.getCurrentRecord(), ge = (We = ie.value) == null ? void 0 : We.getRowid(ue);
      dr !== G && ge === G && (dr = G), v("highlight-change", C, Sa);
    }
    function rm(C) {
      Pe(C) && v("drag", x.value);
    }
    async function zi(C) {
      var J, Ce, We;
      if (!j.value)
        return;
      await nextTick();
      const G = (We = (Ce = (J = j.value) == null ? void 0 : J[0]) == null ? void 0 : Ce.filter) == null ? void 0 : We.call(Ce, C), { conditionInfo: ue, tableData: ge } = G ?? {};
      return Zo(ue, ge, false), { conditionInfo: ue, tableData: ge };
    }
    async function Pi() {
      var ge, J, Ce;
      if (!j.value)
        return;
      await nextTick();
      const C = (Ce = (J = (ge = j.value) == null ? void 0 : ge[0]) == null ? void 0 : J.clearFilter) == null ? void 0 : Ce.call(J), { conditionInfo: G, tableData: ue } = C ?? {};
      return Zo(G, ue, false), { conditionInfo: G, tableData: ue };
    }
    function im(C) {
      Array.isArray(C) && (x.value = de(C), zi(C));
    }
    function gc() {
      var C, G;
      return (G = (C = j.value) == null ? void 0 : C[0]) == null ? void 0 : G.getConditionInfo();
    }
    function sm(C) {
      const G = ie.value.getSortColumns();
      Ne(G), v("sort-change", C);
    }
    function lm(C) {
      var Ce;
      const G = (Ce = ie.value) == null ? void 0 : Ce.getRowById(C);
      if (G)
        return G;
      const ue = x.value.find(
        (We) => We[ee.value.keyField] === C
      );
      return ue || (ie.value.getInsertRecords().find(
        (We) => We[ee.value.keyField] === C
      ) ?? null);
    }
    function cm() {
      return Q.value;
    }
    function um() {
      const C = document.querySelector(".vxe-table--tooltip-wrapper");
      C && (C == null || C.remove());
    }
    function fr() {
      var We, vt, Rt, ct, Zn;
      const C = /* @__PURE__ */ new Map(), G = (We = ie.value) == null ? void 0 : We.getColumns();
      for (const ft of G) {
        const Wo = (vt = ie.value) == null ? void 0 : vt.getColumnWidth(ft);
        C.set(ft.field, Wo);
      }
      const { sourceData: ue = [], selectData: ge = [] } = ((Zn = (ct = (Rt = w.value) == null ? void 0 : Rt[0]) == null ? void 0 : ct.getTransferData) == null ? void 0 : Zn.call(ct)) ?? [], J = new Set(ge.map((ft) => ft.key));
      return ue.map((ft) => ({
        label: ft.label,
        key: ft.key,
        width: C.get(ft.key) ?? "",
        visible: J.has(ft.key),
        disabled: ft.disabled ?? false
      }));
    }
    function dm(C) {
      var G, ue;
      (G = C.forEach) == null || G.call(C, (ge) => {
        const J = M.value.find((Ce) => Ce.field === ge.key);
        J && (ge.visible ? J.visible = true : J.visible = false);
      }), F.value = ((ue = C.map) == null ? void 0 : ue.call(C, (ge) => ({
        label: ge.label ?? "",
        key: ge.key ?? `_${Dt(8)}`,
        disabled: ge.disabled ?? false,
        visible: ge.visible !== false
      }))) ?? [], P.value = F.value.filter((ge) => ge.visible !== false), co(C), vc(C);
    }
    function vc(C) {
      const G = new Map(
        C.map((ue) => [ue.key, ue])
      );
      for (const ue of _.value) {
        const ge = G.get(ue.field);
        !ge || !ge.width || (ue.width = ge.width);
      }
    }
    function fm() {
      return k.value === "small" || k.value === "mini" ? "sm" : "base";
    }
    provide("__showTransfer", se), provide(
      fn,
      computed(() => fm())
    );
    const mm = {
      tableInstance: ie,
      filter: Ki,
      advancedFilter: zi,
      clearAdvancedFilter: Pi,
      getAdvancedCondition: gc,
      getVisibleData: cm,
      getRowById: lm,
      loadData: im,
      disposeRowTooltip: um,
      getHeaderControllerData: fr,
      setHeaderControllerData: dm,
      clearSearch: Nt,
      ...tt,
      ...hn
    };
    return t10(Ae(mm, ie)), (C, G) => {
      const ue = resolveDirective("ksw_tooltip"), ge = resolveDirective("ksw_drag");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          "k-tree-table flex flex-col h-full",
          o.class,
          unref(r),
          { "tree-table-use-ant-style": C.useAntStyle }
        ]),
        style: normalizeStyle({ height: C.height, ...C.style })
      }, [
        C.simple && C.showSearchInput ? (openBlock(), createElementBlock("div", Q8, [
          createVNode(unref(ro), {
            modelValue: I.value,
            "onUpdate:modelValue": G[0] || (G[0] = (J) => I.value = J),
            "suffix-icon": unref(Dr),
            placeholder: C.$t("searchTable"),
            clearable: "",
            onChange: Ki
          }, null, 8, ["modelValue", "suffix-icon", "placeholder"])
        ])) : C.showHeaderTools && !C.simple ? (openBlock(), createElementBlock("div", {
          key: 1,
          ref: "RefTableHeader",
          class: "k-tree-table__header",
          style: normalizeStyle({
            justifyContent: C.showDescription ? "space-between" : "flex-end"
          })
        }, [
          C.showDescription ? (openBlock(), createElementBlock("div", J8, [
            renderSlot(C.$slots, "description", {
              total: W.value,
              conditionInfo: A.value
            }, () => {
              var J, Ce, We, vt;
              return [
                C.useTree ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", eb, toDisplayString(C.$t("total")) + " " + toDisplayString(W.value) + " " + toDisplayString(C.$t("data")), 1)),
                createBaseVNode("span", {
                  title: U.value,
                  class: "condition-info"
                }, toDisplayString(U.value), 9, tb),
                (Ce = (J = A.value) == null ? void 0 : J.conditionList) != null && Ce.length && ((vt = (We = j.value) == null ? void 0 : We[0]) != null && vt.clearFilter) ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: "filter-reset",
                  onClick: G[1] || (G[1] = () => {
                    Pi(), v("advanced-filter-clear");
                  })
                }, "  " + toDisplayString(C.$t("reset")), 1)) : createCommentVNode("", true)
              ];
            })
          ])) : createCommentVNode("", true),
          createBaseVNode("div", nb, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(D.value, (J) => {
              var Ce, We, vt, Rt;
              return openBlock(), createElementBlock(Fragment, {
                key: J.id
              }, [
                J.slot && C.$slots[J.slot] ? renderSlot(C.$slots, J.slot, { key: 0 }) : J.id === "search" ? (openBlock(), createBlock(unref(ro), {
                  key: 1,
                  modelValue: I.value,
                  "onUpdate:modelValue": G[2] || (G[2] = (ct) => I.value = ct),
                  "suffix-icon": unref(Dr),
                  placeholder: C.$t("searchTable"),
                  clearable: "",
                  onChange: Ki
                }, null, 8, ["modelValue", "suffix-icon", "placeholder"])) : J.id === "refresh" ? withDirectives((openBlock(), createBlock(unref(Lt), {
                  key: 2,
                  onClick: G[3] || (G[3] = () => {
                    v("refresh");
                  })
                }, {
                  default: withCtx(() => [
                    createVNode(unref(g0))
                  ]),
                  _: 1
                })), [
                  [ue, C.$t("refresh")]
                ]) : J.id === "filter" ? (openBlock(), createBlock(unref(Wf), {
                  key: 3,
                  ref_for: true,
                  ref_key: "tableFilterRef",
                  ref: j,
                  data: x.value,
                  options: te.value,
                  "children-field": "group",
                  "filter-key": "field",
                  remote: ((Ce = C.advancedFilterConfig) == null ? void 0 : Ce.remote) ?? false,
                  "ignore-case": (We = C.advancedFilterConfig) == null ? void 0 : We.ignoreCase,
                  formatter: ((vt = C.advancedFilterConfig) == null ? void 0 : vt.dateFormat) ?? "YYYY-MM-DD HH:mm:ss",
                  "default-condition": ((Rt = C.advancedFilterConfig) == null ? void 0 : Rt.defaultCondition) ?? A.value,
                  onConfirm: Zo,
                  onClear: G[4] || (G[4] = () => {
                    Pi(), v("advanced-filter-clear");
                  }),
                  onShow: nm,
                  onHide: om
                }, {
                  reference: withCtx(({ hasConfigCondition: ct }) => [
                    withDirectives((openBlock(), createElementBlock("div", null, [
                      J.widget ? (openBlock(), createBlock(resolveDynamicComponent(typeof J.widget == "function" ? J.widget() : J.widget), { key: 0 })) : renderSlot(C.$slots, "filterTrigger", {
                        key: 1,
                        isFilter: ct
                      }, () => [
                        createVNode(unref(Lt), null, {
                          default: withCtx(() => [
                            ct ? (openBlock(), createBlock(unref(Ir), {
                              key: 1,
                              color: "#2882FF"
                            })) : (openBlock(), createBlock(unref(La), { key: 0 }))
                          ]),
                          _: 2
                        }, 1024)
                      ])
                    ])), [
                      [ue, C.$t("advancedFilter_c")]
                    ])
                  ]),
                  _: 2
                }, 1032, ["data", "options", "remote", "ignore-case", "formatter", "default-condition"])) : J.id === "sizeControl" ? (openBlock(), createBlock(unref(ar), {
                  key: 4,
                  trigger: "click",
                  onCommand: G[5] || (G[5] = (ct) => {
                    k.value = ct || void 0;
                  })
                }, {
                  title: withCtx(() => [
                    withDirectives((openBlock(), createElementBlock("div", ob, [
                      J.widget ? (openBlock(), createBlock(resolveDynamicComponent(typeof J.widget == "function" ? J.widget() : J.widget), { key: 0 })) : renderSlot(C.$slots, "sizeControlTrigger", { key: 1 }, () => [
                        createVNode(unref(Lt), null, {
                          default: withCtx(() => [
                            createVNode(unref(Uh))
                          ]),
                          _: 1
                        })
                      ])
                    ])), [
                      [ue, C.$t("sizeControlTrigger")]
                    ])
                  ]),
                  default: withCtx(() => [
                    (openBlock(), createElementBlock(Fragment, null, renderList(T, (ct) => createVNode(unref(rr), {
                      key: ct.value,
                      style: normalizeStyle({
                        color: k.value === (ct.value || void 0) ? "#2882FF" : ""
                      }),
                      command: ct.value
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(ct.label), 1)
                      ]),
                      _: 2
                    }, 1032, ["style", "command"])), 64))
                  ]),
                  _: 2
                }, 1024)) : J.id === "transfer" ? (openBlock(), createBlock(unref(Io), {
                  key: 5,
                  trigger: "click",
                  width: "auto",
                  teleported: false,
                  onShow: Bo,
                  onHide: G[7] || (G[7] = () => {
                    Ei(), uo();
                  })
                }, {
                  reference: withCtx(() => [
                    withDirectives((openBlock(), createElementBlock("div", ab, [
                      J.widget ? (openBlock(), createBlock(resolveDynamicComponent(typeof J.widget == "function" ? J.widget() : J.widget), { key: 0 })) : renderSlot(C.$slots, "transferTrigger", { key: 1 }, () => [
                        createVNode(unref(Lt), null, {
                          default: withCtx(() => [
                            createVNode(unref(Hh))
                          ]),
                          _: 1
                        })
                      ])
                    ])), [
                      [ue, C.$t("columnHeaderController")]
                    ])
                  ]),
                  default: withCtx(() => [
                    createVNode(unref(jf), {
                      ref_for: true,
                      ref_key: "tableTransferRef",
                      ref: w,
                      modelValue: P.value,
                      "onUpdate:modelValue": G[6] || (G[6] = (ct) => P.value = ct),
                      data: F.value,
                      "default-keys": N.value,
                      titles: [C.$t("unselectedFields"), C.$t("selectedFields")],
                      onChange: ka,
                      onReset: ka,
                      onSort: co
                    }, null, 8, ["modelValue", "data", "default-keys", "titles"])
                  ]),
                  _: 2
                }, 1024)) : J.widget ? (openBlock(), createBlock(resolveDynamicComponent(typeof J.widget == "function" ? J.widget() : J.widget), { key: 6 })) : createCommentVNode("", true)
              ], 64);
            }), 128))
          ])
        ], 4)) : createCommentVNode("", true),
        createBaseVNode("div", rb, [
          createVNode(unref(Hr), mergeProps({
            ref_key: "xTree",
            ref: y,
            border: C.useAntStyle ? "inner" : C.border,
            size: oe.value,
            height: C.adaptive ? void 0 : "100%",
            data: Q.value,
            "row-config": ee.value,
            "sort-config": K.value,
            "tree-config": E.value,
            "seq-config": Te.value,
            "checkbox-config": unref(lt),
            "edit-config": V.value,
            "column-config": pe.value,
            "empty-text": C.emptyText || C.$t("noData"),
            "scroll-y": le.value,
            "row-style": lo,
            "show-overflow": C.showOverflow,
            "auto-resize": C.autoResize,
            "show-column-menu": C.showColumnMenu,
            "show-drag-column": C.showDragColumn,
            align: C.align,
            round: C.useAntStyle || C.round
          }, C.$attrs, {
            onCheckboxChange: G[8] || (G[8] = (J) => {
              unref(Xe)(J), v("checkbox-change", J);
            }),
            onCheckboxAll: G[9] || (G[9] = (J) => {
              unref(it)(J), v("checkbox-all", J);
            }),
            onHideColumn: ur,
            onCellClick: G[10] || (G[10] = (J) => {
              am(J), v("cell-click", J);
            }),
            onResizableChange: G[11] || (G[11] = (J) => {
              uo(), v("resizable-change", J);
            }),
            onSortChange: sm,
            onDrag: rm
          }), createSlots({
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_.value, (J, Ce) => (openBlock(), createBlock(unref(G8), {
                key: Ce,
                column: J,
                size: C.size,
                align: C.align
              }, createSlots({ _: 2 }, [
                renderList(C.$slots, (We, vt) => ({
                  name: vt,
                  fn: withCtx((Rt) => [
                    renderSlot(C.$slots, vt, mergeProps({ ref_for: true }, Rt))
                  ])
                }))
              ]), 1032, ["column", "size", "align"]))), 128))
            ]),
            _: 2
          }, [
            a.empty ? {
              name: "empty",
              fn: withCtx(() => [
                renderSlot(C.$slots, "empty")
              ]),
              key: "0"
            } : void 0,
            a.dragIcon ? {
              name: "dragIcon",
              fn: withCtx(() => [
                renderSlot(C.$slots, "dragIcon")
              ]),
              key: "1"
            } : void 0,
            a.loading ? {
              name: "loading",
              fn: withCtx(() => [
                renderSlot(C.$slots, "loading")
              ]),
              key: "2"
            } : void 0
          ]), 1040, ["border", "size", "height", "data", "row-config", "sort-config", "tree-config", "seq-config", "checkbox-config", "edit-config", "column-config", "empty-text", "scroll-y", "show-overflow", "auto-resize", "show-column-menu", "show-drag-column", "align", "round"]),
          C.showBatchOperation && unref(Qe) > 0 ? withDirectives((openBlock(), createElementBlock("div", ib, [
            createVNode(unref(Of), {
              total: unref(Qe),
              data: C.batchOperations,
              onClose: unref(Be)
            }, null, 8, ["total", "data", "onClose"])
          ])), [
            [ge]
          ]) : createCommentVNode("", true)
        ]),
        Z.value ? (openBlock(), createElementBlock("div", sb, [
          createVNode(unref(zf), mergeProps(B.value, {
            total: W.value,
            onCurrentChange: Ze,
            onSizeChange: bt,
            onChange: G[12] || (G[12] = (J, Ce) => {
              v("page-change", J, Ce);
            }),
            onPrevClick: G[13] || (G[13] = (J) => {
              v("prev-click", J);
            }),
            onNextClick: G[14] || (G[14] = (J) => {
              v("next-click", J);
            })
          }), null, 16, ["total"])
        ], 512)) : createCommentVNode("", true)
      ], 6);
    };
  }
});
var cb = $e(lb);
var ub = {
  key: 0,
  class: "k-transfer__filter"
};
var db = {
  class: "k-transfer__body"
};
var fb = {
  class: "k-transfer-content k-transfer-content__left"
};
var mb = ["onClick"];
var pb = ["title"];
var hb = {
  class: "k-transfer-content k-transfer-content__right"
};
var gb = {
  class: "k-transfer__list"
};
var vb = {
  class: "right-data-header"
};
var yb = {
  class: "right-data-title"
};
var bb = {
  class: "column-body"
};
var _b = {
  class: "column-content"
};
var wb = ["title"];
var Tb = {
  class: "column-operate"
};
var Cb = defineComponent({
  name: "KTreeTransfer",
  __name: "tree_transfer",
  props: {
    data: {},
    defaultData: {
      default: () => []
    },
    titles: {},
    showSearchInput: {
      type: Boolean,
      default: true
    },
    useTree: {
      type: Boolean,
      default: false
    },
    expandIcon: {},
    expandIconColor: {},
    collapseIcon: {},
    collapseIconColor: {},
    icon: {},
    iconColor: {},
    treeConfig: {},
    label: {
      default: "label"
    },
    scrollY: {},
    drag: {
      type: Boolean
    },
    showDrag: {
      type: Boolean,
      default: false
    },
    checkMethod: {},
    searchMethod: {}
  },
  emits: ["change", "sort"],
  setup(e16, {
    expose: t10,
    emit: n
  }) {
    const o = e16, r = inject("_styleModule", ""), a = n, i = {
      transform: true,
      rowField: "id",
      parentField: "pid",
      childrenField: "children",
      trigger: "cell",
      hasChildField: "hasChild",
      indent: 0,
      showIcon: false
    }, s = ref([]), l = ref([]), c = ref([]), u = ref(""), d = ref(), m = ref(), p = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map();
    onMounted(() => {
      pe();
    });
    const h10 = computed(() => function(Z) {
      var W;
      const X = (W = d.value) == null ? void 0 : W.tableInstance.isTreeExpandByRow(Z), Q = !(Z.children && Z.children.length);
      if (Q && Z.nodeType === 1)
        return {
          icon: E(o.collapseIcon, Z),
          color: o.collapseIconColor
        };
      if (o.icon && Q)
        return {
          icon: E(o.icon, Z),
          color: o.iconColor
        };
      if (o.expandIcon && X && !Q)
        return {
          icon: E(o.expandIcon, Z),
          color: o.expandIconColor
        };
      if (o.collapseIcon && !X && !Q)
        return {
          icon: E(o.collapseIcon, Z),
          color: o.collapseIconColor
        };
    }), g = computed(() => {
      if (o.useTree) {
        const Z = Object.assign(i, o.treeConfig || {});
        return Z.indent = 0, Z;
      }
    }), v = computed(() => ({
      enabled: true,
      ...o.scrollY || {}
    })), y = computed(() => (Z) => B(Z)), k = computed(() => function(Z) {
      let X = Z;
      for (; X.pid; ) {
        const de = l.value.find((Ne) => Ne.id === X.pid);
        if (de)
          X = de;
        else
          break;
      }
      const Q = X.name;
      return {
        data: Z[o.label],
        name: Q
      };
    });
    watch(() => o.data, () => {
      s.value = Array.isArray(o.data) ? [...o.data] : [], l.value = [...s.value], setTimeout(() => {
        T();
      });
    }, {
      immediate: true
    });
    function T() {
      var X;
      for (const Q of o.data) {
        if (!o.useTree) {
          f.set(Q.id, {
            row: Q,
            checked: false
          });
          continue;
        }
        Q.disabled || o.data.find((de) => de.pid === Q.id) || f.set(Q.id, {
          row: {
            ...Q
          },
          checked: false
        });
      }
      const Z = (X = d == null ? void 0 : d.value) == null ? void 0 : X.tableInstance;
      if (Z) {
        const Q = Z.getCheckboxRecords();
        for (const W of Q) {
          const de = f.get(W.id);
          de && (de.checked = true);
        }
      }
      _();
    }
    function w(Z, X, Q = false) {
      M(Z, X, Q), _(), a("change", se());
    }
    function _() {
      const Z = l.value.filter((X) => {
        var Q;
        return ((Q = f.get(X.id)) == null ? void 0 : Q.checked) ?? false;
      });
      c.value = Z.filter((X) => {
        var Q;
        return !((Q = o.defaultData) != null && Q.includes(X.id) && !K({
          row: X
        }));
      }), c.value = oe(c.value, s.value);
    }
    function M(Z, X, Q) {
      if (Q) {
        const Ne = d.value.tableInstance.getCheckboxRecords().filter((Pe) => !Pe.children || !Pe.children.length);
        for (const Pe of Ne) {
          const tt = f.get(Pe.id);
          tt && (tt.checked = X);
        }
        return;
      }
      const W = Array.isArray(Z) ? Z : [Z];
      for (const de of W) {
        const Ne = f.get(Z.id);
        if (Ne && (Ne.checked = X), de.children && de.children.length)
          for (const Pe of de.children)
            M(Pe, X, Q);
      }
    }
    function x(Z) {
      if (!Z)
        return;
      const X = f.get(Z.id);
      X && (X.checked = false);
      const Q = d.value.tableInstance.getRowById(Z.id);
      d.value.tableInstance.setCheckboxRow(Q, false);
      const W = c.value.findIndex((de) => de.id === Z.id);
      W >= 0 && c.value.splice(W, 1), a("change", se());
    }
    function R() {
      for (const Z of c.value) {
        const X = f.get(Z.id);
        if (X) {
          X.checked = false;
          const Q = d.value.tableInstance.getRowById(Z.id);
          d.value.tableInstance.setCheckboxRow(Q, false);
        }
      }
      c.value = [], a("change", se());
    }
    async function I() {
      await F(), _();
    }
    function P() {
      return u.value;
    }
    async function F() {
      const Z = d.value.tableInstance, X = u.value.trim();
      let Q = [];
      if (typeof o.searchMethod == "function")
        Q = await o.searchMethod(X, o.data);
      else if (Q = o.data.filter((W) => W[o.label].toString().indexOf(X) !== -1), o.useTree) {
        N(Q);
        const {
          rowField: W
        } = te();
        Q = D([...p.values()], o.data, W), Q.length < 500 && X && nextTick(() => {
          Z.setAllTreeExpand(true);
        }), X || nextTick(() => {
          Z.setAllTreeExpand(false);
        });
      }
      await Z.clearCheckboxRow(), l.value = Q, await nextTick(), A();
    }
    function N(Z) {
      const {
        parentField: X,
        rowField: Q
      } = te();
      p.clear();
      for (let W = 0; W < Z.length; W++) {
        const de = Z[W];
        p.get(de[Q]) || (p.set(de[Q], de), z(de, X, Q));
      }
      j(Z);
    }
    function j(Z) {
      const {
        parentField: X,
        rowField: Q
      } = te(), W = new Map(Z.map((de) => [de[Q], de]));
      for (const de of o.data) {
        const Ne = de[X];
        W.get(Ne) && (p.set(de[Q], de), j([de]));
      }
    }
    function z(Z, X, Q) {
      var Ne;
      const W = Z[X], de = (Ne = o.data) == null ? void 0 : Ne.find((Pe) => Pe[Q] === W);
      de && (p.get(W) || p.set(W, de), de[X] !== null && z(de, X, Q));
    }
    async function A() {
      for (const {
        row: Z,
        checked: X
      } of f.values()) {
        const Q = d.value.tableInstance.getRowById(Z.id);
        Q && await d.value.tableInstance.setCheckboxRow(Q, X);
      }
    }
    function B(Z) {
      if (!o.useTree)
        return 0;
      const {
        parentField: X,
        rowField: Q
      } = te();
      if (!Z[X])
        return 0;
      const W = o.data.find((de) => de[Q] === Z[X]);
      return W ? 1 + B(W) : 0;
    }
    function D(Z, X, Q) {
      const W = X.map((de) => de[Q]);
      return Z.sort((de, Ne) => W.indexOf(de[Q]) < W.indexOf(Ne[Q]) ? -1 : 1);
    }
    function te() {
      var Q, W;
      const Z = ((Q = g.value) == null ? void 0 : Q.parentField) || "pid", X = ((W = g.value) == null ? void 0 : W.rowField) || "id";
      return {
        parentField: Z,
        rowField: X
      };
    }
    function ie(Z, X) {
      o.useTree && !ee(Z) && (X.stopPropagation(), d.value.tableInstance.toggleTreeExpand(Z));
    }
    function U(Z) {
      const {
        oldIndex: X,
        newIndex: Q
      } = Z;
      if (Q === void 0 || X === void 0 || Q === X)
        return;
      const W = c.value.map((Ne) => Ne.id);
      W.splice(Q, 0, W.splice(X, 1)[0]), s.value = yd(s.value, W);
      const de = se();
      a("change", de), a("sort", de), _();
    }
    function oe(Z, X) {
      const Q = X.map((W) => W.id);
      return Z.sort((W, de) => Q.indexOf(W.id) < Q.indexOf(de.id) ? -1 : 1);
    }
    function se() {
      return s.value.filter((Z) => {
        var X;
        return ((X = f.get(Z.id)) == null ? void 0 : X.checked) ?? false;
      });
    }
    function E(Z, X) {
      return typeof Z == "function" ? Z == null ? void 0 : Z(X) : Z;
    }
    function K(Z) {
      var Q;
      const {
        row: X
      } = Z;
      return ((Q = o.checkMethod) == null ? void 0 : Q.call(o, Z)) ?? !X.disabled ?? true;
    }
    function ee(Z) {
      return !Z.children || Z.children.length === 0;
    }
    async function V(Z, X) {
      const W = (Array.isArray(Z) ? Z : [Z]).map((de) => {
        const Ne = d.value.tableInstance.getRowById(de);
        return Ne && K({
          row: Ne
        }) && !Ne.disabled ? Ne : null;
      }).filter((de) => de !== null);
      await d.value.tableInstance.setCheckboxRow(W, X), w(W, X);
    }
    function le(Z) {
      const X = d.value.tableInstance.getRowById(Z);
      return d.value.tableInstance.isCheckedByCheckboxRow(X);
    }
    function pe() {
      var X;
      const Z = (X = m.value) == null ? void 0 : X.$el.querySelector(".el-input__suffix");
      Z ? Z.addEventListener("click", I) : console.error("Element with class .el-input__suffix not found");
    }
    async function Te() {
      u.value = "", await I(), R();
    }
    return t10({
      clearData: R,
      setCheckboxRow: V,
      isCheckedRow: le,
      clearQuery: Te,
      getQuery: P
    }), (Z, X) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["k-tree-transfer", unref(r)])
    }, [Z.showSearchInput ? (openBlock(), createElementBlock("div", ub, [createVNode(unref(ro), {
      ref_key: "KTransferInputRef",
      ref: m,
      modelValue: u.value,
      "onUpdate:modelValue": X[0] || (X[0] = (Q) => u.value = Q),
      placeholder: Z.$t("enterInputSearch"),
      "suffix-icon": unref(Dr),
      onKeyup: withKeys(I, ["enter"])
    }, null, 8, ["modelValue", "placeholder", "suffix-icon"])])) : createCommentVNode("", true), createBaseVNode("div", db, [createBaseVNode("div", fb, [createBaseVNode("div", {
      class: normalizeClass(["k-transfer__list", Z.useTree ? "transfer-tree-table" : ""])
    }, [createVNode(unref(Hr), {
      ref_key: "treeLeftRef",
      ref: d,
      size: "mini",
      border: false,
      height: "100%",
      data: l.value,
      "tree-config": g.value,
      "row-config": {
        keyField: "id"
      },
      "scroll-y": v.value,
      "checkbox-config": {
        checkRowKeys: Z.defaultData,
        trigger: "cell",
        checkMethod: K
      },
      onCheckboxChange: X[1] || (X[1] = ({
        row: Q,
        checked: W
      }) => {
        w(Q, W);
      }),
      onCheckboxAll: X[2] || (X[2] = ({
        row: Q,
        checked: W
      }) => {
        w(Q, W, true);
      })
    }, createSlots({
      default: withCtx(() => {
        var Q;
        return [createVNode(unref(Ur), {
          type: "checkbox",
          field: Z.label,
          title: ((Q = Z.titles) == null ? void 0 : Q[0]) ?? "",
          "tree-node": o.useTree
        }, {
          default: withCtx(({
            row: W
          }) => {
            var de, Ne, Pe;
            return [createBaseVNode("span", {
              class: normalizeClass(["tree-transfer__cell", {
                "list-item-disabled": W.disabled
              }]),
              style: normalizeStyle({
                marginLeft: `${y.value(W) * (((de = o.treeConfig) == null ? void 0 : de.indent) ?? 12)}px`
              }),
              onClick: (tt) => ie(W, tt)
            }, [(openBlock(), createBlock(resolveDynamicComponent((Ne = h10.value(W)) == null ? void 0 : Ne.icon), {
              class: "column-icon",
              color: (Pe = h10.value(W)) == null ? void 0 : Pe.color
            }, null, 8, ["color"])), createBaseVNode("span", {
              class: "tree-transfer__cell-label",
              title: W[o.label]
            }, toDisplayString(W[o.label]), 9, pb)], 14, mb)];
          }),
          _: 1
        }, 8, ["field", "title", "tree-node"])];
      }),
      _: 2
    }, [Z.$slots.empty && u.value ? {
      name: "empty",
      fn: withCtx(() => [renderSlot(Z.$slots, "empty", {
        query: u.value
      })]),
      key: "0"
    } : void 0]), 1032, ["data", "tree-config", "scroll-y", "checkbox-config"])], 2)]), createBaseVNode("div", hb, [createBaseVNode("div", gb, [createVNode(unref(Hr), {
      size: "mini",
      border: false,
      height: "100%",
      data: c.value,
      "row-config": {
        useKey: true
      },
      "scroll-y": v.value,
      onDrag: U
    }, createSlots({
      default: withCtx(() => [createVNode(unref(Ur), {
        field: Z.label
      }, {
        header: withCtx((Q) => [renderSlot(Z.$slots, "rightHeader", normalizeProps(guardReactiveProps(Q)), () => {
          var W;
          return [createBaseVNode("div", vb, [createBaseVNode("span", yb, toDisplayString(((W = o.titles) == null ? void 0 : W[1]) ?? ""), 1), createBaseVNode("span", {
            class: "clear-data",
            onClick: R
          }, toDisplayString(Z.$t("clearData")), 1)])];
        })]),
        default: withCtx(({
          row: Q
        }) => [createBaseVNode("div", bb, [createBaseVNode("span", _b, [renderSlot(Z.$slots, "right-cell", {}, () => [o.icon ? (openBlock(), createBlock(resolveDynamicComponent(E(o.icon, Q)), {
          key: 0,
          class: "column-icon"
        })) : createCommentVNode("", true), renderSlot(Z.$slots, "right-label", {
          parentData: k.value(Q)
        }, () => [createBaseVNode("span", {
          class: "tree-transfer__cell-label",
          title: Q[o.label]
        }, toDisplayString(Q[o.label]), 9, wb)])])]), createBaseVNode("div", Tb, [o.showDrag ? (openBlock(), createBlock(unref(bl), {
          key: 0,
          class: "__column-drag-icon"
        })) : createCommentVNode("", true), createVNode(unref(yl), {
          class: "column-close",
          onClick: (W) => x(Q)
        }, null, 8, ["onClick"])])])]),
        _: 3
      }, 8, ["field"])]),
      _: 2
    }, [Z.$slots.empty && u.value ? {
      name: "empty",
      fn: withCtx(() => [renderSlot(Z.$slots, "empty", {
        query: u.value
      })]),
      key: "0"
    } : void 0]), 1032, ["data", "scroll-y"])])])])], 2));
  }
});
var kb = $e(Cb);
var Sb = defineComponent({
  name: "KTreeSelect",
  __name: "tree_select",
  props: {
    name: {},
    icon: {},
    size: {},
    expandIcon: { default: "IconFolderOpen" },
    collapseIcon: { default: "IconFlowNested" },
    debounce: { default: 500 },
    className: {},
    nodeStyle: {}
  },
  emits: ["input", "blur"],
  setup(e16, { expose: t10, emit: n }) {
    const o = ["empty", "default"], r = e16, a = kt(r), i = inject("_styleModule", ""), s = n, l = ref(), c = ref({
      value: ""
    }), u = Dt(8), d = computed(() => (f) => {
      const { node: h10, data: g } = f;
      return g.icon ? g.icon : h10.isLeaf ? r.icon ?? "IconFlowNested" : h10.expanded ? r.expandIcon ?? "IconFolderOpen" : r.collapseIcon ?? "IconFlowNested";
    }), m = (f) => {
      O6(() => {
        const g = l.value.$el.querySelector(`[name="${r.name ?? u}"]`);
        c.value.value = g.value;
      }, r.debounce)(), s("input", f);
    };
    return provide(fn, a), t10(Ae({}, l)), (f, h10) => (openBlock(), createBlock(unref(ElTreeSelect), mergeProps({
      ref_key: "KTreeSelectRef",
      ref: l,
      name: f.name ?? unref(u),
      class: ["k-tree-select", unref(i)],
      size: unref(a).elSize
    }, f.$attrs, {
      onInput: m,
      onBlur: h10[0] || (h10[0] = (g) => {
        c.value.value = "", s("blur", g);
      })
    }), createSlots({
      default: withCtx((g) => [
        renderSlot(f.$slots, "default", normalizeProps(guardReactiveProps(g)), () => [
          createBaseVNode("span", {
            style: normalizeStyle(
              typeof r.nodeStyle == "function" ? r.nodeStyle(g) : r.nodeStyle
            ),
            class: normalizeClass(
              typeof r.className == "function" ? r.className(g) : r.className
            )
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(d.value(g)), {
              class: normalizeClass([{ "tree-item-icon--noChildren": g.node.isLeaf }])
            }, null, 8, ["class"])),
            createTextVNode(" " + toDisplayString(g.data.label), 1)
          ], 6)
        ])
      ]),
      empty: withCtx(() => [
        renderSlot(f.$slots, "empty", { query: c.value }, () => [
          createTextVNode("'" + toDisplayString(c.value.value) + "'", 1)
        ])
      ]),
      _: 2
    }, [
      renderList(f.$slots, (g, v) => ({
        name: v,
        fn: withCtx((y) => [
          o.includes(v) ? createCommentVNode("", true) : renderSlot(f.$slots, v, normalizeProps(mergeProps({ key: 0 }, y)))
        ])
      }))
    ]), 1040, ["name", "class", "size"]));
  }
});
var Nb = $e(Sb);
var Mb = defineComponent({
  name: "KFilterForm",
  __name: "filter_form",
  props: {
    items: { default: () => [] },
    size: {},
    collapse: { type: Boolean, default: true },
    reserve: { type: Boolean, default: false },
    visible: { type: Boolean, default: false },
    showColon: { type: Boolean }
  },
  emits: ["search", "reset", "change"],
  setup(e16, { expose: t10, emit: n }) {
    const o = ["base", "sm"], r = inject("_styleModule", ""), a = e16, i = kt(a), s = n, l = ref({});
    let c = {};
    const u = ref(), d = ref(), m = ref(), p = ref(), f = ref(a.collapse), h10 = ref(1), g = ref(1), v = ref("");
    onMounted(() => {
      if (!a.collapse) {
        w();
        return;
      }
      I(), p == null || p.value.style.setProperty("--transition-duration", "0.3s"), p == null || p.value.classList.remove("is-expand"), m == null || m.value.classList.remove("is-expand");
    }), window.addEventListener("resize", I), onUnmounted(() => {
      window.removeEventListener("resize", I);
    });
    const y = computed(() => (N = {}) => {
      const { size: j } = N;
      return j && o.includes(j) ? j : i.value.ownSize;
    }), k = computed(() => (N) => {
      let j = N.visible ?? true;
      if (typeof j == "function" && (j = j(l.value)), j === false && N.prop && !a.reserve) {
        const z = a.items.find((A) => A.prop === N.prop);
        l.value[N.prop] = z == null ? void 0 : z.value;
      }
      return j;
    });
    watch(
      () => a.items,
      () => {
        c = {};
      }
    ), watch(
      () => a.items,
      () => {
        var N;
        (N = a.items) == null || N.forEach((j) => {
          const { prop: z, value: A } = j;
          A !== c[z] && (l.value[z] = A, c[z] = A);
        });
      },
      { deep: true, immediate: true }
    ), watch(
      () => l.value,
      (N) => {
        s("change", N), setTimeout(() => {
          var B, D;
          const j = m.value.offsetTop;
          u == null || u.value.style.setProperty("--top-new", `${j}px`);
          const z = ((B = d.value) == null ? void 0 : B.$el.clientHeight) ?? 0;
          p == null || p.value.style.setProperty("--expandHeight", `${z}px`);
          const A = getComputedStyle((D = d == null ? void 0 : d.value) == null ? void 0 : D.$el).gridTemplateRows.split(" ");
          v.value = A[0], g.value = A.length;
        }, 100);
      },
      { deep: true }
    );
    function T() {
      u == null || u.value.classList.toggle("is-expand"), m == null || m.value.classList.toggle("is-expand"), p == null || p.value.classList.toggle("is-expand"), f.value = !f.value;
      const N = m.value.offsetTop;
      u == null || u.value.style.setProperty("--top-new", `${N}px`), setTimeout(() => {
        var A;
        const j = ((A = d.value) == null ? void 0 : A.$el.clientHeight) ?? 0;
        p == null || p.value.style.setProperty("--expandHeight", `${j}px`);
        const z = m.value.offsetTop;
        u == null || u.value.style.setProperty("--top-new", `${z}px`);
      }, 1);
    }
    function w() {
      u == null || u.value.classList.add("is-expand"), d == null || d.value.$el.classList.add("is-expand"), f.value = false;
    }
    function _() {
      u == null || u.value.classList.remove("is-expand"), d == null || d.value.$el.classList.remove("is-expand"), f.value = true;
    }
    function M() {
      s("search", l.value);
    }
    function x() {
      a.items.forEach((N) => {
        l.value[N.prop] = N.value;
      }), d.value.resetFields(), s("reset");
    }
    function R() {
      return l.value;
    }
    function I() {
      var z, A;
      if (!((z = d == null ? void 0 : d.value) != null && z.$el)) return;
      let N = 1;
      const j = getComputedStyle((A = d == null ? void 0 : d.value) == null ? void 0 : A.$el).gridTemplateColumns.split(" ");
      for (let B = 1; B < j.length; B++) {
        if (Math.abs(parseInt(j[B]) - parseInt(j[B - 1])) > 2) {
          h10.value = N;
          break;
        }
        N++;
      }
      h10.value = N, setTimeout(() => {
        P();
      }, 1);
    }
    function P() {
      var B, D;
      const N = ((B = d.value) == null ? void 0 : B.$el.clientHeight) ?? 0, j = m.value.offsetTop, z = getComputedStyle((D = d == null ? void 0 : d.value) == null ? void 0 : D.$el).gridTemplateRows.split(" "), A = z[0];
      g.value = z.length, p == null || p.value.style.setProperty("--expandHeight", `${N}px`), p == null || p.value.style.setProperty("--transition-duration", "0.3s"), u == null || u.value.style.setProperty("--top-new", `${j}px`), p == null || p.value.style.setProperty("--firstRowHeight", `${A}`);
    }
    return t10(Ae({ reset: x, getFormData: R, search: M, toggle: T, expand: w, collapse: _ }, d)), (N, j) => (openBlock(), createElementBlock("div", {
      ref_key: "filterForm",
      ref: p,
      class: "filterForm is-expand"
    }, [
      createVNode(unref(r1), {
        ref_key: "KFormRef",
        ref: d,
        class: normalizeClass(["filtr-items w-full relative grid grid-cols-1 2xs:grid-cols-2 xs:grid-cols-2 sm:grid-cols-3 base:grid-cols-4 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6", ["k-form", unref(r)]]),
        model: l.value,
        size: N.size,
        "show-colon": N.showColon
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(N.items, (z) => (openBlock(), createElementBlock(Fragment, {
            key: z.prop
          }, [
            k.value(z) ? (openBlock(), createBlock(unref(i1), mergeProps({
              key: z.prop,
              ref_for: true
            }, z, {
              style: `grid-column: span ${z.column === void 0 ? 1 : z.column < h10.value ? z.column : h10.value}`,
              class: "grid-auto-rows:max-content;"
            }), {
              default: withCtx(() => [
                renderSlot(N.$slots, z.prop, { formData: l.value }, () => {
                  var A, B;
                  return [
                    typeof z.render == "function" ? (openBlock(), createBlock(resolveDynamicComponent(z.render(l.value)), { key: 0 })) : z.type === "select" ? (openBlock(), createBlock(unref(Go), mergeProps({
                      key: 1,
                      modelValue: l.value[z.prop],
                      "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                      ref_for: true
                    }, z.attrs, {
                      size: y.value(z.attrs),
                      placeholder: ((A = z.attrs) == null ? void 0 : A.placeholder) ?? N.$t("pleaseSelect")
                    }), {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(z.options, (D) => (openBlock(), createBlock(unref(vo), mergeProps({ ref_for: true }, D, { key: D }), null, 16))), 128))
                      ]),
                      _: 2
                    }, 1040, ["modelValue", "onUpdate:modelValue", "size", "placeholder"])) : z.type === "radio" ? (openBlock(), createBlock(unref($f), mergeProps({
                      key: 2,
                      modelValue: l.value[z.prop],
                      "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                      ref_for: true
                    }, z.attrs, {
                      size: y.value(z.attrs)
                    }), {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(z.options, (D) => (openBlock(), createBlock(unref(Mf), mergeProps({ ref_for: true }, D, { key: D }), null, 16))), 128))
                      ]),
                      _: 2
                    }, 1040, ["modelValue", "onUpdate:modelValue", "size"])) : z.type === "checkbox" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                      Array.isArray(z.value) ? (openBlock(), createBlock(unref(If), mergeProps({
                        key: 0,
                        modelValue: l.value[z.prop],
                        "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                        ref_for: true
                      }, z.attrs, {
                        size: y.value(z.attrs)
                      }), {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(z.options, (D) => (openBlock(), createBlock(unref(fa), mergeProps({ ref_for: true }, D, {
                            key: D,
                            size: y.value(z.attrs)
                          }), null, 16, ["size"]))), 128))
                        ]),
                        _: 2
                      }, 1040, ["modelValue", "onUpdate:modelValue", "size"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(z.options, (D) => (openBlock(), createBlock(unref(fa), mergeProps({ ref_for: true }, D, {
                        key: D,
                        modelValue: l.value[z.prop],
                        "onUpdate:modelValue": (te) => l.value[z.prop] = te,
                        size: y.value(z.attrs)
                      }), null, 16, ["modelValue", "onUpdate:modelValue", "size"]))), 128))
                    ], 64)) : z.type === "date" ? (openBlock(), createBlock(unref(Ff), mergeProps({
                      key: 4,
                      modelValue: l.value[z.prop],
                      "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                      ref_for: true
                    }, z.attrs, {
                      size: y.value(z.attrs)
                    }), null, 16, ["modelValue", "onUpdate:modelValue", "size"])) : (openBlock(), createElementBlock(Fragment, { key: 5 }, [
                      k.value(z) ? (openBlock(), createBlock(unref(ro), mergeProps({
                        key: 0,
                        modelValue: l.value[z.prop],
                        "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                        ref_for: true
                      }, z.attrs, {
                        placeholder: ((B = z.attrs) == null ? void 0 : B.placeholder) ?? N.$t("pleaseInput"),
                        size: y.value(z.attrs)
                      }), null, 16, ["modelValue", "onUpdate:modelValue", "placeholder", "size"])) : createCommentVNode("", true)
                    ], 64))
                  ];
                }, true)
              ]),
              _: 2
            }, 1040, ["style"])) : createCommentVNode("", true)
          ], 64))), 128)),
          createBaseVNode("div", {
            ref_key: "markers",
            ref: m,
            class: "markers flex w-full h-8 is-expand",
            style: normalizeStyle(`grid-column: ${h10.value} / ${h10.value + 1}; `)
          }, null, 4),
          createBaseVNode("div", {
            ref_key: "filterBtn",
            ref: u,
            class: "filtr-btns flex bg-white"
          }, [
            renderSlot(N.$slots, "action", {}, () => [
              createVNode(unref(Lt), {
                size: y.value(),
                onClick: x
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(N.$t("reset")), 1)
                ]),
                _: 1
              }, 8, ["size"]),
              createVNode(unref(Lt), {
                size: y.value(),
                main: "",
                onClick: M
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(N.$t("query")), 1)
                ]),
                _: 1
              }, 8, ["size"]),
              withDirectives(createVNode(unref(Lt), {
                text: "",
                "icon-right": f.value ? "IconArrowBottom" : "IconArrowTop",
                onClick: T
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(f.value ? N.$t("expand") : N.$t("collapse")), 1)
                ]),
                _: 1
              }, 8, ["icon-right"]), [
                [vShow, g.value > 1]
              ])
            ], true)
          ], 512)
        ]),
        _: 3
      }, 8, ["model", "size", "class", "show-colon"])
    ], 512));
  }
});
var $b = Ta(Mb, [["__scopeId", "data-v-4f868e9a"]]);
var xb = $e($b);
var Ib = defineComponent({
  name: "TabLabel",
  props: {
    tabs: {
      type: Array,
      default: () => []
    }
  },
  setup(e16, {
    slots: t10,
    attrs: n
  }) {
    return () => createVNode(Fragment, null, [createVNode(ar, mergeProps(n, {
      disabled: e16.tabs.length === 0
    }), {
      default: () => [e16.tabs.map((o) => createVNode(rr, {
        key: o,
        disabled: o.disabled
      }, {
        default: () => [typeof (o == null ? void 0 : o.label) == "function" ? o.label() : o.label]
      }))],
      ...t10
    })]);
  }
});
var Db = { class: "k-button-more-trigger" };
var Ab = defineComponent({
  name: "KButtonContainer",
  __name: "button_container",
  props: {
    trigger: { default: "click" },
    maxHeight: { default: 300 },
    placement: { default: "bottom" },
    hideOnClick: { type: Boolean, default: true },
    showTimeout: {},
    hideTimeout: {},
    popperClass: {},
    teleported: { type: Boolean, default: true },
    triggerIcon: { default: "IconMore" }
  },
  setup(e16) {
    var h10;
    const t10 = inject("__elementObserver"), n = inject("_styleModule", ""), o = e16, r = useSlots(), a = ref(), i = ref(), s = m(jr((h10 = r.default) == null ? void 0 : h10.call(r))), l = ref([]);
    let c;
    const u = `_${Dt(8)}`;
    onMounted(() => {
      var g;
      c = (g = a.value) == null ? void 0 : g.querySelectorAll(".k-button"), i.value.setAttribute("data-observer-key", u), f(), t10.observe(i.value, f);
    }), onBeforeUnmount(() => {
      var g;
      i.value && ((g = t10 == null ? void 0 : t10.unobserve) == null || g.call(t10, i.value));
    });
    const d = kt(o);
    watch(() => d.value, () => {
      nextTick(() => {
        f();
      });
    }, { deep: true });
    function m(g) {
      return g.map((v) => {
        if (Cd(v)) {
          const y = { ...v.props || {} };
          for (const [T, w] of Object.entries(y))
            delete y[T], y[Td(T)] = w;
          return {
            label: (v.children || {}).default,
            disabled: !!y.disabled
          };
        }
        return null;
      }).filter((v) => v !== null);
    }
    function p(g) {
      var k;
      const v = g.getBoundingClientRect(), y = (k = a.value) == null ? void 0 : k.getBoundingClientRect();
      return y ? v.left >= y.left && v.right <= y.right : true;
    }
    function f() {
      const g = [];
      if (!s)
        return [];
      c == null || c.forEach((v, y) => {
        !p(v) && s[y] ? (v.style.opacity = "0", g.push(s[y])) : v.style.opacity = "1";
      }), l.value = g;
    }
    return (g, v) => (openBlock(), createElementBlock("div", {
      ref_key: "box",
      ref: i,
      class: normalizeClass(["k-button-container", unref(n)])
    }, [
      createBaseVNode("div", {
        ref_key: "container",
        ref: a,
        class: "container"
      }, [
        renderSlot(g.$slots, "default")
      ], 512),
      createBaseVNode("div", {
        class: "k-button-more",
        style: normalizeStyle({
          opacity: l.value.length > 0 ? 1 : 0
        })
      }, [
        createVNode(unref(Ib), mergeProps({
          tabs: l.value,
          trigger: g.trigger,
          "max-height": g.maxHeight,
          placement: g.placement,
          "hide-on-click": g.hideOnClick,
          teleported: g.teleported,
          "show-timeout": g.showTimeout,
          "hide-timeout": g.hideTimeout,
          "popper-class": g.popperClass
        }, g.$attrs), {
          title: withCtx(() => [
            createBaseVNode("span", Db, [
              renderSlot(g.$slots, "trigger", {}, () => [
                (openBlock(), createBlock(resolveDynamicComponent(o.triggerIcon)))
              ])
            ])
          ]),
          _: 3
        }, 16, ["tabs", "trigger", "max-height", "placement", "hide-on-click", "teleported", "show-timeout", "hide-timeout", "popper-class"])
      ], 4)
    ], 2));
  }
});
var Eb = $e(Ab);
var Kb = ["onClick"];
var zb = defineComponent({
  name: "KSliderButton",
  __name: "sliderButton",
  props: {
    items: { default: () => [] },
    active: {}
  },
  emits: ["change"],
  setup(e16, { emit: t10 }) {
    const n = e16, o = t10, r = ref(n.active ?? n.items[0].name), a = ref();
    window.addEventListener("resize", i), onMounted(() => {
      i();
    });
    function i() {
      var m, p, f;
      const l = document.querySelector(".k-slider-button-pane.is-active"), { width: c } = (l == null ? void 0 : l.getBoundingClientRect()) || { width: 0, height: 0 }, u = (l == null ? void 0 : l.offsetTop) || 0, d = (l == null ? void 0 : l.offsetLeft) || 0;
      (m = a == null ? void 0 : a.value) == null || m.style.setProperty("--item-top", `${u}px`), (p = a == null ? void 0 : a.value) == null || p.style.setProperty("--item-left", `${d}px`), (f = a == null ? void 0 : a.value) == null || f.style.setProperty("--item-width", `${c}px`);
    }
    function s(l) {
      r.value !== l.name && (r.value = l.name, nextTick(() => {
        i(), o("change", l.name);
      }));
    }
    return (l, c) => (openBlock(), createElementBlock("div", {
      ref_key: "sliderButton",
      ref: a,
      class: "k-slider-button p-1 rounded-lg flex w-full bg-gray-100"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(n.items, (u) => (openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "is-active": r.value === u.name }, "k-slider-button-pane w-full rounded flex justify-center items-center text-center text-gray-500 cursor-pointer relative"]),
        onClick: (d) => s(u)
      }, toDisplayString(u.label), 11, Kb))), 256))
    ], 512));
  }
});
var Pb = $e(zb);
var Rb = { class: "k-script-input-prepend" };
var Lb = { class: "k-script-input-append" };
var Fb = defineComponent({
  name: "KScriptInput",
  __name: "script_input",
  props: {
    modelValue: {},
    size: { default: "base" },
    placeholder: {},
    disabled: { type: Boolean },
    options: { default: () => [] },
    useTree: { type: Boolean, default: false },
    showPopperSwitch: { type: Boolean, default: true },
    showModeSwitch: { type: Boolean, default: true },
    defaultMode: { default: "string" },
    height: {},
    treeConfig: {}
  },
  emits: ["change", "input", "focus", "blur", "select", "update:modelValue"],
  setup(e16, { expose: t10, emit: n }) {
    const o = inject("_styleModule", ""), r = inject("__diffMatchPatch"), a = e16, i = {
      parentField: "pid",
      rowField: "value",
      expandAll: false
    }, s = n;
    onMounted(() => {
      document.addEventListener("keydown", le), document.addEventListener("click", Pe), hn();
    }), onBeforeUnmount(() => {
      document.removeEventListener("keydown", le), document.removeEventListener("click", Pe);
    });
    const l = `_${Dt(8)}`, c = [{ field: "label", label: "", treeNode: true }], u = ref(), d = ref(), m = ref(), p = ref(a.defaultMode === "string");
    let f = "", h10 = "";
    const g = ref(""), v = ref(0);
    let y = false;
    const k = ref(false), T = ref(true);
    let w = false;
    const _ = ref(false), M = ref(false), x = ref(0), R = /fx\((.*?)\)/, I = /* @__PURE__ */ new Set();
    window.addEventListener("resize", hn), onUnmounted(() => {
      window.removeEventListener("resize", hn);
    });
    const P = computed(() => {
      if (a.useTree)
        return Object.assign(i, a.treeConfig || {});
    }), F = computed(() => {
      var ae;
      const ne = ((ae = d.value) == null ? void 0 : ae.getTableData().fullData) ?? [];
      return bd(ne, "children") ?? [];
    });
    watch(
      () => g.value,
      () => {
        var ne, ae, he;
        if (g.value === "" && !y) {
          k.value = false;
          return;
        }
        (ne = d.value) == null || ne.filter(g.value), (he = (ae = d.value) == null ? void 0 : ae.getVisibleData()) != null && he.length ? k.value = true : k.value = false;
      },
      { immediate: true }
    ), watch(
      () => [a.modelValue, a.options],
      () => {
        const ne = typeof a.modelValue;
        if (ne !== "string" && ne !== "number" || a.modelValue === void 0) {
          console.warn(`'modelValue' must be a string or number, but got ${ne}`);
          return;
        }
        a.modelValue !== h10 && nextTick(() => {
          const ae = E(a.modelValue.toString());
          z(ae), h10 = a.modelValue.toString(), f = j(), A = f, Te();
        });
      },
      { immediate: true, deep: true }
    );
    function N(ne) {
      h10 = ne, s("update:modelValue", ne);
    }
    function j() {
      return cn(u.value.innerHTML);
    }
    function z(ne) {
      u.value.innerHTML = ne;
    }
    let A = "";
    function B(ne) {
      if (!(ne.target instanceof HTMLElement) || !T.value)
        return;
      ne.data === " " ? g.value = "" : ne.data === null && g.value.length ? g.value = g.value.slice(0, -1) : ne.data !== null && (g.value += ne.data ?? ""), f = A, A = j();
      const { result: ae = "" } = se();
      N(ae);
    }
    function D() {
      _.value = true, w = true, s("focus");
    }
    function te(ne) {
      if (!(ne.target instanceof HTMLElement))
        return;
      const ae = de(`.${l}`);
      ae && !ae.contains(ne.relatedTarget) && (w = false, s("blur"), s("change", se()), _.value = false, k.value = false);
    }
    function ie({ row: ne }) {
      var he;
      if (ne.optional === false)
        return;
      const ae = F.value.findIndex((xe) => xe.value === ne.value);
      v.value = ae, !((he = ne.children) != null && he.length) && U(ne);
    }
    function U(ne) {
      const { value: ae, key: he } = oe(ne);
      g.value = "", z(ae), f = j(), A = f, Te(he), s("select", ne), k.value = false, nextTick(() => {
        const xe = se();
        N((xe == null ? void 0 : xe.result) ?? ""), s("change", xe);
      });
    }
    function oe(ne) {
      const ae = Dt(8), he = p.value ? V(ne.label, ae) : ne.value;
      if (y)
        return {
          value: j() + he,
          key: ae
        };
      const xe = r.diff_main(f, j());
      let Ee = "";
      const Ve = xe.find((Ze) => Ze[0] === 0), Je = (Ve == null ? void 0 : Ve[1]) ?? "", [Ie, Nt] = xe.find(
        (Ze) => Ze[0] !== 0
      ) ?? [-2, ""];
      Ie === 1 ? Ee = (Je + Nt).slice(0, -g.value.length) : Ie === -1 ? Ee = Je.slice(0, -g.value.length) : Ee = Je;
      let bt = "";
      return Ve ? (Ve[1] = `${Ee}${he}`, bt = xe.filter((Ze) => Ze[0] === 0).map((Ze) => Ze[1]).join("")) : bt = he, {
        value: bt,
        key: ae
      };
    }
    function se() {
      if (!Be())
        return {
          result: j(),
          scriptTags: []
        };
      let ne = "";
      const ae = [], he = (Ee) => {
        if (!Ee)
          return;
        const Ve = Ee.childNodes;
        for (let Je = 0; Je < Ve.length; Je++) {
          const Ie = Ve[Je];
          if (Ie.nodeType === 3)
            ne += Ie.textContent ?? "";
          else if (Ie.tagName.toUpperCase() === "DIV" && Ie.classList.contains("k-script-tag")) {
            const Nt = Ie.innerText;
            if (I.has(Nt))
              ne += `fx(${Nt})`, ae.push(null);
            else {
              const bt = a.options.find((Ze) => Ze.label === Nt);
              ne += `fx(${(bt == null ? void 0 : bt.value) ?? null})`, ae.push(bt ?? null);
            }
          } else Ie.tagName.toUpperCase() === "DIV" && he(Ie);
        }
      };
      he(u.value), ne = ne.split(" ").filter((Ee) => Ee !== "").join(" ");
      const xe = K(ne);
      return s("input", xe), {
        result: xe,
        scriptTags: ae
      };
    }
    function E(ne) {
      I.clear();
      let ae = ne.replace(/''/g, "'");
      if (!Be())
        return ae;
      for (ae = ee(ae); R.test(ae); ) {
        const he = ae.match(R);
        if ((he == null ? void 0 : he[0]) === void 0 || (he == null ? void 0 : he[1]) === void 0)
          break;
        const xe = he[1], Ee = a.options.find((Nt) => Nt.value === xe);
        let Ve = (Ee == null ? void 0 : Ee.label) ?? "", Je = false;
        Ee || (Ve = xe, Bf.error(`'${xe}' not found`), I.add(Ve), Je = true);
        const Ie = Dt(8);
        ae = ae.replace(he == null ? void 0 : he[0], V(Ve, Ie, Je));
      }
      return ae;
    }
    function K(ne) {
      var xe, Ee;
      const ae = /fx\((.*?)\)/;
      if (ne = ne.replace(/'/g, "''"), !p.value)
        return ne;
      let he = "";
      for (; ae.test(ne); ) {
        const Ve = ((xe = ne.match(ae)) == null ? void 0 : xe[0]) ?? "", Je = ne.indexOf(Ve), Ie = ne.slice(0, Je);
        (Ee = Ie == null ? void 0 : Ie.trim()) != null && Ee.length && (he += ` '${Ie == null ? void 0 : Ie.trim()}' `), he += ` ${Ve} `, ne = ne.slice(Je + Ve.length);
      }
      return ne != null && ne.length && (he += `'${ne}'`), he.trim();
    }
    function ee(ne) {
      const ae = ne.split("''");
      return ae.forEach((he, xe) => {
        ae[xe] = he.replace(/'/g, "");
      }), ae.join("'");
    }
    function V(ne, ae, he = false) {
      return `<div class="k-script-tag ${he ? "is-error" : ""}" data-key="${ae}"  contenteditable="false">${ne}</div>`;
    }
    function le(ne) {
      var Ve, Je, Ie;
      const ae = F.value.length, he = de(`.${l} .el-input__inner`);
      if (ne.code === "ArrowUp")
        for (he == null || he.blur(), v.value = (v.value - 1 + ae) % ae; pe(F.value[v.value]) || F.value[v.value].optional === false; )
          v.value = (v.value - 1 + ae) % ae;
      else if (ne.code === "ArrowDown")
        for (he == null || he.blur(), v.value = (v.value + 1) % ae; pe(F.value[v.value]) || F.value[v.value].optional === false; )
          v.value = (v.value + 1) % ae;
      const xe = F.value[v.value], Ee = (Ve = d.value) == null ? void 0 : Ve.getRowById(xe == null ? void 0 : xe.value);
      Ee && d.value.setCurrentRow(Ee), ne.code === "Enter" && k.value && document.activeElement !== he ? (ne.preventDefault(), a.useTree && Ee && ((Je = Ee.children) != null && Je.length) && !Ee.optional ? (Ie = d.value) == null || Ie.toggleTreeExpand(Ee) : U(xe)) : ne.code === "Enter" && (g.value = "");
    }
    function pe(ne) {
      var he, xe;
      const ae = (he = d.value) == null ? void 0 : he.getRowById(ne == null ? void 0 : ne.pid);
      return ae ? !!(!((xe = d.value) != null && xe.isTreeExpandByRow(ae)) && ne.pid) : false;
    }
    function Te(ne) {
      if (!w || window.getSelection === void 0)
        return;
      const ae = window.getSelection();
      if (ne === void 0)
        u.value.focus(), ae == null || ae.selectAllChildren(u.value), ae == null || ae.collapseToEnd();
      else {
        const he = document.createRange();
        he.selectNodeContents(u.value);
        const { node: xe, offset: Ee } = Z(ne);
        he.setStart(xe, Ee), he.collapse(true), ae == null || ae.removeAllRanges(), ae == null || ae.addRange(he);
      }
    }
    function Z(ne) {
      if (!ne)
        return { node: u.value, offset: 0 };
      let ae = false;
      const he = {
        node: u.value,
        offset: 0
      }, xe = (Ee) => {
        var Je, Ie, Nt;
        if (ae)
          return;
        const Ve = Ee.childNodes;
        for (let bt = 0; bt < Ve.length && !ae; bt++) {
          const Ze = Ve[bt];
          if (Ze.parentNode !== he.node && (he.node = Ze.parentNode, he.offset = bt), he.offset++, ((Je = Ze == null ? void 0 : Ze.getAttribute) == null ? void 0 : Je.call(Ze, "data-key")) === ne) {
            ae = true;
            break;
          }
          Ze.nodeType !== 3 && ((Ie = Ze == null ? void 0 : Ze.tagName) == null ? void 0 : Ie.toUpperCase()) === "DIV" && !((Nt = Ze == null ? void 0 : Ze.classList) != null && Nt.contains("k-script-tag")) && (he.node = Ze, he.offset = 0, xe(Ze));
        }
      };
      return xe(u.value), he;
    }
    function X() {
      var he, xe, Ee;
      const ne = (xe = (he = F.value) == null ? void 0 : he[0]) == null ? void 0 : xe.value, ae = (Ee = d.value) == null ? void 0 : Ee.getRowById(ne);
      ae && d.value.setCurrentRow(ae);
    }
    function Q() {
      var ne, ae;
      v.value = 0, (ne = d.value) == null || ne.setCurrentRow(null), (ae = d.value) == null || ae.clearTreeExpand(), M.value = false, y && (y = false);
    }
    function W() {
      k.value || (g.value = "", M.value = true, k.value = true, _.value = true, setTimeout(() => {
        y = true;
      }), nextTick(() => {
        const ne = de(`.${l} .el-input__inner`);
        ne == null || ne.focus();
      }));
    }
    function de(ne) {
      return document.querySelector(ne);
    }
    function Ne() {
      k.value = false, _.value = false, Q();
    }
    function Pe(ne) {
      var he;
      const ae = de(`.${l}`);
      !y || (he = ae == null ? void 0 : ae.contains) != null && he.call(ae, ne.target) || Ne();
    }
    function tt() {
      z(""), f = "", g.value = "";
    }
    function Qe() {
      St(), p.value = !p.value, pn();
    }
    function lt(ne) {
      Be() !== ne && (St(), p.value = ne, pn());
    }
    function Be() {
      return p.value;
    }
    const Xe = {
      expression: "",
      string: ""
    }, it = {
      expression: "",
      string: ""
    };
    function St() {
      const ne = Be() ? "string" : "expression";
      it[ne] = j();
    }
    function pn() {
      tt();
      const ne = Be() ? "string" : "expression";
      z(Xe[ne]);
      const ae = se();
      h10 = (ae == null ? void 0 : ae.result) ?? "", Xe.expression = it.expression, Xe.string = it.string, s("update:modelValue", (ae == null ? void 0 : ae.result) ?? ""), s("change", ae);
    }
    function hn() {
      nextTick(() => {
        var ne;
        x.value = ((ne = m.value) == null ? void 0 : ne.offsetWidth) ?? 0;
      });
    }
    function cn(ne) {
      return ne.replace(/&nbsp;/g, " ");
    }
    return t10({
      clear: tt,
      showPopper: W,
      hidePopper: Ne,
      toggleMode: Qe,
      setStringMode: lt,
      isStringMode: Be
    }), (ne, ae) => {
      const he = resolveComponent("k-button"), xe = resolveComponent("k-tree-table"), Ee = resolveComponent("el-scrollbar"), Ve = resolveComponent("k-popover"), Je = resolveComponent("IconVariable");
      return openBlock(), createElementBlock("div", {
        ref_key: "KScriptInputWrapper",
        ref: m,
        class: "k-script-input-wrapper"
      }, [
        createBaseVNode("div", Rb, [
          ne.showModeSwitch ? (openBlock(), createBlock(he, {
            key: 0,
            onClick: Qe
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(p.value ? "IconModeExpression" : "IconModeExpressionColor"), { color: "var(--k-gray-400)" }))
            ]),
            _: 1
          })) : createCommentVNode("", true),
          renderSlot(ne.$slots, "prepend")
        ]),
        createVNode(Ve, {
          width: x.value,
          "show-arrow": false,
          visible: k.value,
          "popper-class": `k-script-input-popper ${l}`,
          onShow: X,
          onHide: Q,
          class: "overflow-hidden"
        }, {
          reference: withCtx(() => [
            createBaseVNode("div", {
              ref_key: "KScriptInput",
              ref: u,
              class: normalizeClass(["k-script-input", unref(o)]),
              style: normalizeStyle({
                height: ne.height
              }),
              contenteditable: "",
              spellcheck: false,
              onInput: B,
              onBlur: te,
              onFocus: D,
              onCompositionstart: ae[0] || (ae[0] = () => {
                T.value = false;
              }),
              onCompositionend: ae[1] || (ae[1] = (Ie) => {
                T.value = true, B(Ie);
              })
            }, null, 38)
          ]),
          default: withCtx(() => [
            createBaseVNode("div", null, [
              createVNode(Ee, null, {
                default: withCtx(() => [
                  _.value ? (openBlock(), createBlock(xe, {
                    key: 0,
                    id: "k-script-input-tree",
                    class: "mytable-scrollbar",
                    ref_key: "$tree",
                    ref: d,
                    border: "none",
                    height: "320px",
                    "use-tree": ne.useTree,
                    column: c,
                    data: ne.options,
                    "show-search-input": M.value,
                    "show-filter": false,
                    "show-header": false,
                    "show-page": false,
                    "show-header-tools": M.value,
                    "cell-click-toggle-highlight": false,
                    "show-description": false,
                    "show-refresh": false,
                    "row-config": {
                      keyField: "value",
                      isCurrent: true,
                      currentMethod: ({ row: Ie }) => Ie.optional !== false
                    },
                    "row-class-name": ({ row: Ie }) => {
                      var Nt;
                      return Ie.optional === false && !((Nt = Ie.children) != null && Nt.length) ? "k-script-input-tree-disabled" : "";
                    },
                    "tree-config": P.value,
                    "highlight-current": "",
                    adaptive: "",
                    onCellClick: ie
                  }, null, 8, ["use-tree", "data", "show-search-input", "show-header-tools", "row-config", "row-class-name", "tree-config"])) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }, 8, ["width", "visible", "popper-class"]),
        createBaseVNode("div", Lb, [
          renderSlot(ne.$slots, "append"),
          ne.showPopperSwitch ? (openBlock(), createBlock(he, {
            key: 0,
            onClick: W
          }, {
            default: withCtx(() => [
              createVNode(Je)
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ])
      ], 512);
    };
  }
});
var jb = $e(Fb);
var Ou = [
  {
    id: 0,
    name: "add",
    componentName: "IconAdd",
    title: "",
    category: "Character",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 1,
    name: "aom-menu-AOMRZ-color",
    componentName: "IconAomMenuAOMRZColor",
    title: "AOM",
    category: "AOM Menu",
    categoryCN: "AOM ",
    author: "KSW",
    tag: ["AOM", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 2,
    name: "aom-menu-BBCX-color",
    componentName: "IconAomMenuBBCXColor",
    title: "",
    category: "AOM Menu",
    categoryCN: "AOM ",
    author: "KSW",
    tag: ["AOM", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 3,
    name: "aom-menu-BBSH-color",
    componentName: "IconAomMenuBBSHColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 4,
    name: "aom-menu-BBSJ-color",
    componentName: "IconAomMenuBBSJColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 5,
    name: "aom-menu-BBYL-color",
    componentName: "IconAomMenuBBYLColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 6,
    name: "aom-menu-BCLLPZ-color",
    componentName: "IconAomMenuBCLLPZColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 7,
    name: "aom-menu-BCZXKanban-color",
    componentName: "IconAomMenuBCZXKanbanColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 8,
    name: "aom-menu-BDCK-color",
    componentName: "IconAomMenuBDCKColor",
    title: "",
    category: "Tools",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 9,
    name: "aom-menu-BDGL-color",
    componentName: "IconAomMenuBDGLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 10,
    name: "aom-menu-BDKanban-color",
    componentName: "IconAomMenuBDKanbanColor",
    title: "",
    category: "Automation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 11,
    name: "aom-menu-CJCL-color",
    componentName: "IconAomMenuCJCLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 12,
    name: "aom-menu-CKGL-color",
    componentName: "IconAomMenuCKGLColor",
    title: "",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 13,
    name: "aom-menu-CLJL-color",
    componentName: "IconAomMenuCLJLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 14,
    name: "aom-menu-CZRZ-color",
    componentName: "IconAomMenuCZRZColor",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 15,
    name: "aom-menu-default-color",
    componentName: "IconAomMenuDefaultColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 16,
    name: "aom-menu-DLDGL-color",
    componentName: "IconAomMenuDLDGLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 17,
    name: "aom-menu-DLDSJ-color",
    componentName: "IconAomMenuDLDSJColor",
    title: "",
    category: "Automation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 18,
    name: "aom-menu-DLDXC-color",
    componentName: "IconAomMenuDLDXCColor",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 19,
    name: "aom-menu-DLDXX-color",
    componentName: "IconAomMenuDLDXXColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 20,
    name: "aom-menu-DLDXZ-color",
    componentName: "IconAomMenuDLDXZColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 21,
    name: "aom-menu-DPGL-color",
    componentName: "IconAomMenuDPGLColor",
    title: "",
    category: "AOM Menu",
    categoryCN: "AOM ",
    author: "KSW",
    tag: ["AOM", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 22,
    name: "aom-menu-DPYL-color",
    componentName: "IconAomMenuDPYLColor",
    title: "",
    category: "AOM Menu",
    categoryCN: "AOM ",
    author: "KSW",
    tag: ["AOM", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 23,
    name: "aom-menu-DXSZ-color",
    componentName: "IconAomMenuDXSZColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 24,
    name: "aom-menu-DYGX-color",
    componentName: "IconAomMenuDYGXColor",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 25,
    name: "aom-menu-FFQDJ-color",
    componentName: "IconAomMenuFFQDJColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 26,
    name: "aom-menu-FFQSL-color",
    componentName: "IconAomMenuFFQSLColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 27,
    name: "aom-menu-FPGL-color",
    componentName: "IconAomMenuFPGLColor",
    title: "",
    category: "AOM Menu",
    categoryCN: "AOM ",
    author: "KSW",
    tag: ["AOM", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 28,
    name: "aom-menu-FWQPZ-color",
    componentName: "IconAomMenuFWQPZColor",
    title: "",
    category: "Automation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 29,
    name: "aom-menu-FWQXX-color",
    componentName: "IconAomMenuFWQXXColor",
    title: "",
    category: "Server",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 30,
    name: "aom-menu-GLST-color",
    componentName: "IconAomMenuGLSTColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 31,
    name: "aom-menu-GNHS-color",
    componentName: "IconAomMenuGNHSColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 32,
    name: "aom-menu-GRBL-color",
    componentName: "IconAomMenuGRBLColor",
    title: "GRBL",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "GRBL", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 33,
    name: "aom-menu-HSZ-color",
    componentName: "IconAomMenuHSZColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "HSZ"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 34,
    name: "aom-menu-JBGL-color",
    componentName: "IconAomMenuJBGLColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 35,
    name: "aom-menu-JBKanban-color",
    componentName: "IconAomMenuJBKanbanColor",
    title: "AOM",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 36,
    name: "aom-menu-JBRZ-color",
    componentName: "IconAomMenuJBRZColor",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 37,
    name: "aom-menu-JBSM-color",
    componentName: "IconAomMenuJBSMColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 38,
    name: "aom-menu-JCYWPTKanban-color",
    componentName: "IconAomMenuJCYWPTKanbanColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 39,
    name: "aom-menu-JGCL-color",
    componentName: "IconAomMenuJGCLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 40,
    name: "aom-menu-JQFA-color",
    componentName: "IconAomMenuJQFAColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 41,
    name: "aom-menu-JRLC-color",
    componentName: "IconAomMenuJRLCColor",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 42,
    name: "aom-menu-JXCX-color",
    componentName: "IconAomMenuJXCXColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T07:40:46.000Z"
  },
  {
    id: 43,
    name: "aom-menu-JXPZ-color",
    componentName: "IconAomMenuJXPZColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T07:40:46.000Z"
  },
  {
    id: 44,
    name: "aom-menu-JXSH-color",
    componentName: "IconAomMenuJXSHColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T07:40:46.000Z"
  },
  {
    id: 45,
    name: "aom-menu-JXYL-color",
    componentName: "IconAomMenuJXYLColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T07:40:46.000Z"
  },
  {
    id: 46,
    name: "aom-menu-KZTGL-color",
    componentName: "IconAomMenuKZTGLColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 47,
    name: "aom-menu-LCCK-color",
    componentName: "IconAomMenuLCCKColor",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 48,
    name: "aom-menu-LCJG-color",
    componentName: "IconAomMenuLCJGColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 49,
    name: "aom-menu-LCKanban-color",
    componentName: "IconAomMenuLCKanbanColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 50,
    name: "aom-menu-LCMB-color",
    componentName: "IconAomMenuLCMBColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 51,
    name: "aom-menu-LCSH-color",
    componentName: "IconAomMenuLCSHColor",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 52,
    name: "aom-menu-LCST-color",
    componentName: "IconAomMenuLCSTColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 53,
    name: "aom-menu-LYCDL-color",
    componentName: "IconAomMenuLYCDLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 54,
    name: "aom-menu-MBCS-color",
    componentName: "IconAomMenuMBCSColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 55,
    name: "aom-menu-MBGL-color",
    componentName: "IconAomMenuMBGLColor",
    title: "MBGL",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "MBGL", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 56,
    name: "aom-menu-MJRW-color",
    componentName: "IconAomMenuMJRWColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 57,
    name: "aom-menu-QDGL-color",
    componentName: "IconAomMenuQDGLColor",
    title: "",
    category: "Quality",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 58,
    name: "aom-menu-QJBL-color",
    componentName: "IconAomMenuQJBLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 59,
    name: "aom-menu-QXGL-color",
    componentName: "IconAomMenuQXGLColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 60,
    name: "aom-menu-RLPZ-color",
    componentName: "IconAomMenuRLPZColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 61,
    name: "aom-menu-RWCX-color",
    componentName: "IconAomMenuRWCXColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 62,
    name: "aom-menu-RWGL-color",
    componentName: "IconAomMenuRWGLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 63,
    name: "aom-menu-RWXQ-color",
    componentName: "IconAomMenuRWXQColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 64,
    name: "aom-menu-RYFA-color",
    componentName: "IconAomMenuRYFAColor",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 65,
    name: "aom-menu-RZLC-color",
    componentName: "IconAomMenuRZLCColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 66,
    name: "aom-menu-SBST-color",
    componentName: "IconAomMenuSBSTColor",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 67,
    name: "aom-menu-SJCX-color",
    componentName: "IconAomMenuSJCXColor",
    title: "",
    category: "Automation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 68,
    name: "aom-menu-SJGL-color",
    componentName: "IconAomMenuSJGLColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 69,
    name: "aom-menu-SJHB-color",
    componentName: "IconAomMenuSJHBColor",
    title: "SJHB",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 70,
    name: "aom-menu-SJKLJ-color",
    componentName: "IconAomMenuSJKLJColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 71,
    name: "aom-menu-SSSJ-color",
    componentName: "IconAomMenuSSSJColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 72,
    name: "aom-menu-TZJL-color",
    componentName: "IconAomMenuTZJLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 73,
    name: "aom-menu-WHQGL-color",
    componentName: "IconAomMenuWHQGLColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 74,
    name: "aom-menu-WWGL-color",
    componentName: "IconAomMenuWWGLColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "WWGL", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 75,
    name: "aom-menu-XTSZ-color",
    componentName: "IconAomMenuXTSZColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "XTSZ"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 76,
    name: "aom-menu-YHGL-color",
    componentName: "IconAomMenuYHGLColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 77,
    name: "aom-menu-YWBCZL-color",
    componentName: "IconAomMenuYWBCZLColor",
    title: "",
    category: "Tools",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 78,
    name: "aom-menu-YYST-color",
    componentName: "IconAomMenuYYSTColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 79,
    name: "aom-menu-ZBGL-color",
    componentName: "IconAomMenuZBGLColor",
    title: "",
    category: "Automation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 80,
    name: "aom-menu-ZBZXSZ-color",
    componentName: "IconAomMenuZBZXSZColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 81,
    name: "aom-menu-ZHCL-color",
    componentName: "IconAomMenuZHCLColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 82,
    name: "aom-menu-ZHJG-color",
    componentName: "IconAomMenuZHJGColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 83,
    name: "aom-menu-ZXLS-color",
    componentName: "IconAomMenuZXLSColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 84,
    name: "aom-menu-ZYSJ-color",
    componentName: "IconAomMenuZYSJColor",
    title: "",
    category: "Menu",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 85,
    name: "aom-menu-ZZFWQ-color",
    componentName: "IconAomMenuZZFWQColor",
    title: "",
    category: "System",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 86,
    name: "argument",
    componentName: "IconArgument",
    title: "",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 87,
    name: "arrow-bottom",
    componentName: "IconArrowBottom",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 88,
    name: "arrow-left",
    componentName: "IconArrowLeft",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 89,
    name: "arrow-right",
    componentName: "IconArrowRight",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 90,
    name: "arrow-to-left",
    componentName: "IconArrowToLeft",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 91,
    name: "arrow-to-right",
    componentName: "IconArrowToRight",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 92,
    name: "arrow-top",
    componentName: "IconArrowTop",
    title: "",
    category: "Directional",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 93,
    name: "arrow-up-right",
    componentName: "IconArrowUpRight",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 94,
    name: "bot",
    componentName: "IconBot",
    title: "",
    category: "Artificial",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 95,
    name: "c-type-autoit-color",
    componentName: "IconCTypeAutoitColor",
    title: "C",
    category: "Color",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "C"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 96,
    name: "c-type-bat-color",
    componentName: "IconCTypeBatColor",
    title: "C",
    category: "Animal",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "C"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 97,
    name: "c-type-c-sharp-color",
    componentName: "IconCTypeCSharpColor",
    title: "CC",
    category: "Technology",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 98,
    name: "c-type-cn-color",
    componentName: "IconCTypeCnColor",
    title: "",
    category: "Color",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 99,
    name: "c-type-en-color",
    componentName: "IconCTypeEnColor",
    title: "",
    category: "Color",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 100,
    name: "c-type-fn-color",
    componentName: "IconCTypeFnColor",
    title: "",
    category: "Function",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 101,
    name: "c-type-JS-color",
    componentName: "IconCTypeJSColor",
    title: "JavaScript",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["JavaScript", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 102,
    name: "c-type-lego-color",
    componentName: "IconCTypeLegoColor",
    title: "C",
    category: "Building",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 103,
    name: "c-type-linuxshell-color",
    componentName: "IconCTypeLinuxshellColor",
    title: "CLinux",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["", "Linux", "Shell", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 104,
    name: "c-type-perl-color",
    componentName: "IconCTypePerlColor",
    title: "CPerl",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["", "Perl", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 105,
    name: "c-type-powershell-color",
    componentName: "IconCTypePowershellColor",
    title: "CPowerShell",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "PowerShell", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 106,
    name: "c-type-python-color",
    componentName: "IconCTypePythonColor",
    title: "CPython",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["Python", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 107,
    name: "c-type-vbs-color",
    componentName: "IconCTypeVbsColor",
    title: "VBS",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["VBS", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 108,
    name: "c-type-yaml-color",
    componentName: "IconCTypeYamlColor",
    title: "CYAML",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["", "YAML", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 109,
    name: "calendar-color",
    componentName: "IconCalendarColor",
    title: "",
    category: "Calendar",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 110,
    name: "card",
    componentName: "IconCard",
    title: "",
    category: "Finance",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 111,
    name: "chart-pie-color",
    componentName: "IconChartPieColor",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 112,
    name: "chart-pie",
    componentName: "IconChartPie",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 113,
    name: "check-ed-color",
    componentName: "IconCheckEdColor",
    title: "",
    category: "Status",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 114,
    name: "check-normal-color",
    componentName: "IconCheckNormalColor",
    title: "",
    category: "Verification",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 115,
    name: "check-or-color",
    componentName: "IconCheckOrColor",
    title: "",
    category: "Tools",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 116,
    name: "check",
    componentName: "IconCheck",
    title: "",
    category: "Icons",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 117,
    name: "clear",
    componentName: "IconClear",
    title: "",
    category: "Action",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 118,
    name: "clear2",
    componentName: "IconClear2",
    title: "2",
    category: "Cleaning",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 119,
    name: "clearDate",
    componentName: "IconClearDate",
    title: "",
    category: "Date",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 120,
    name: "close",
    componentName: "IconClose",
    title: "",
    category: "Interface",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 121,
    name: "Collect",
    componentName: "IconCollect",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 122,
    name: "copy",
    componentName: "IconCopy",
    title: "",
    category: "Editing",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 123,
    name: "cursor-pointer",
    componentName: "IconCursorPointer",
    title: "",
    category: "Cursor",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 124,
    name: "date",
    componentName: "IconDate",
    title: "",
    category: "Calendar",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 125,
    name: "delete",
    componentName: "IconDelete",
    title: "",
    category: "Action",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 126,
    name: "dev-color",
    componentName: "IconDevColor",
    title: "",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 127,
    name: "down-c",
    componentName: "IconDownC",
    title: "",
    category: "Direction",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 128,
    name: "download",
    componentName: "IconDownload",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 129,
    name: "Drag",
    componentName: "IconDrag",
    title: "",
    category: "Interaction",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 130,
    name: "Edit",
    componentName: "IconEdit",
    title: "",
    category: "Editing",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 131,
    name: "EmptyBox",
    componentName: "IconEmptyBox",
    title: "",
    category: "Containers",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 132,
    name: "fall",
    componentName: "IconFall",
    title: "",
    category: "Season",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 133,
    name: "file-add",
    componentName: "IconFileAdd",
    title: "",
    category: "Document",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 134,
    name: "file-starred-color",
    componentName: "IconFileStarredColor",
    title: "",
    category: "Documents",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 135,
    name: "file",
    componentName: "IconFile",
    title: "",
    category: "Document",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 136,
    name: "filter-fill",
    componentName: "IconFilterFill",
    title: "",
    category: "Tools",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 137,
    name: "filter",
    componentName: "IconFilter",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 138,
    name: "flow-add",
    componentName: "IconFlowAdd",
    title: "",
    category: "Process",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 139,
    name: "flow-back",
    componentName: "IconFlowBack",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 140,
    name: "flow-batch-processing-color",
    componentName: "IconFlowBatchProcessingColor",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 141,
    name: "flow-check-color",
    componentName: "IconFlowCheckColor",
    title: "",
    category: "Process",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 142,
    name: "flow-component-color",
    componentName: "IconFlowComponentColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 143,
    name: "flow-controls-color",
    componentName: "IconFlowControlsColor",
    title: "",
    category: "Flow",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 144,
    name: "flow-end-color",
    componentName: "IconFlowEndColor",
    title: "",
    category: "Flow",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 145,
    name: "flow-end",
    componentName: "IconFlowEnd",
    title: "",
    category: "Process",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 146,
    name: "flow-if-color",
    componentName: "IconFlowIfColor",
    title: "",
    category: "Flow",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 147,
    name: "flow-nested-color",
    componentName: "IconFlowNestedColor",
    title: "",
    category: "Design",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 148,
    name: "flow-nested",
    componentName: "IconFlowNested",
    title: "",
    category: "Design",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 149,
    name: "flow-quote-color",
    componentName: "IconFlowQuoteColor",
    title: "",
    category: "Design",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 150,
    name: "flow-start-color",
    componentName: "IconFlowStartColor",
    title: "",
    category: "Color",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 151,
    name: "flow-start",
    componentName: "IconFlowStart",
    title: "",
    category: "Process",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 152,
    name: "flow-tips-color",
    componentName: "IconFlowTipsColor",
    title: "",
    category: "Design",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 153,
    name: "flow-toolBox",
    componentName: "IconFlowToolBox",
    title: "",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 154,
    name: "flow",
    componentName: "IconFlow",
    title: "",
    category: "Process",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 155,
    name: "fn-add",
    componentName: "IconFnAdd",
    title: "",
    category: "Function",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 156,
    name: "fn",
    componentName: "IconFn",
    title: "",
    category: "Mathematics",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 157,
    name: "fold",
    componentName: "IconFold",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 158,
    name: "folder-add",
    componentName: "IconFolderAdd",
    title: "",
    category: "File",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 159,
    name: "folder-close",
    componentName: "IconFolderClose",
    title: "",
    category: "File",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 160,
    name: "folder-open",
    componentName: "IconFolderOpen",
    title: "",
    category: "File",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 161,
    name: "full-screen",
    componentName: "IconFullScreen",
    title: "",
    category: "Display",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 162,
    name: "GlobalOperation",
    componentName: "IconGlobalOperation",
    title: "",
    category: "International",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 163,
    name: "hard-drive-color",
    componentName: "IconHardDriveColor",
    title: "",
    category: "Storage",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 164,
    name: "hide",
    componentName: "IconHide",
    title: "",
    category: "Visibility",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 165,
    name: "icon-def",
    componentName: "IconIconDef",
    title: "",
    category: "Design",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 166,
    name: "ide-pause",
    componentName: "IconIdePause",
    title: "IDE",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "IDE", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 167,
    name: "ide-play",
    componentName: "IconIdePlay",
    title: "IDE",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "IDE", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 168,
    name: "ide-refresh",
    componentName: "IconIdeRefresh",
    title: "IDE",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["IDE", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 169,
    name: "ide-stop",
    componentName: "IconIdeStop",
    title: "IDE",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["IDE", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 170,
    name: "IP",
    componentName: "IconIP",
    title: "IP",
    category: "Network",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 171,
    name: "item-def-color",
    componentName: "IconItemDefColor",
    title: "",
    category: "Color",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 172,
    name: "left-menu-display",
    componentName: "IconLeftMenuDisplay",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 173,
    name: "line",
    componentName: "IconLine",
    title: "",
    category: "Design",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 174,
    name: "list-close",
    componentName: "IconListClose",
    title: "",
    category: "List",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 175,
    name: "list-open",
    componentName: "IconListOpen",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 176,
    name: "list-search",
    componentName: "IconListSearch",
    title: "",
    category: "Edit",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 177,
    name: "loading",
    componentName: "IconLoading",
    title: "",
    category: "Progress",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 178,
    name: "lock",
    componentName: "IconLock",
    title: "",
    category: "Security",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 179,
    name: "locked",
    componentName: "IconLocked",
    title: "",
    category: "Security",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 180,
    name: "logout",
    componentName: "IconLogout",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 181,
    name: "medal-1",
    componentName: "IconMedal1",
    title: "1",
    category: "Awards",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 182,
    name: "medal-2",
    componentName: "IconMedal2",
    title: "",
    category: "Awards",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 183,
    name: "medal-3",
    componentName: "IconMedal3",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 184,
    name: "menu-collect",
    componentName: "IconMenuCollect",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 185,
    name: "menu-collected",
    componentName: "IconMenuCollected",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 186,
    name: "menu-def-color",
    componentName: "IconMenuDefColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 187,
    name: "Message",
    componentName: "IconMessage",
    title: "",
    category: "Communication",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 188,
    name: "mode-expression-color",
    componentName: "IconModeExpressionColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T09:42:16.000Z"
  },
  {
    id: 189,
    name: "mode-expression",
    componentName: "IconModeExpression",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T09:38:42.000Z"
  },
  {
    id: 190,
    name: "more",
    componentName: "IconMore",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 191,
    name: "organization",
    componentName: "IconOrganization",
    title: "",
    category: "Business",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 192,
    name: "patch-color",
    componentName: "IconPatchColor",
    title: "",
    category: "Design",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 193,
    name: "patch-set-color",
    componentName: "IconPatchSetColor",
    title: "",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 194,
    name: "personnel",
    componentName: "IconPersonnel",
    title: "",
    category: "Human",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 195,
    name: "plug-in-360-color",
    componentName: "IconPlugIn360Color",
    title: "360",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["", "360", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 196,
    name: "plug-in-Chrome-color",
    componentName: "IconPlugInChromeColor",
    title: "",
    category: "Browser",
    categoryCN: "",
    author: "KSW",
    tag: ["", "Chrome", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 197,
    name: "plug-in-Edge-color",
    componentName: "IconPlugInEdgeColor",
    title: "",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 198,
    name: "plug-in-excel-color",
    componentName: "IconPlugInExcelColor",
    title: "Excel",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["Excel", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 199,
    name: "plug-in-Firefox-color",
    componentName: "IconPlugInFirefoxColor",
    title: "",
    category: "Browser",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 200,
    name: "plug-in-image-color",
    componentName: "IconPlugInImageColor",
    title: "",
    category: "Image",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 201,
    name: "plug-in-java-color",
    componentName: "IconPlugInJavaColor",
    title: "Java",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "Java", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 202,
    name: "plug-in-Mail-color",
    componentName: "IconPlugInMailColor",
    title: "",
    category: "Email",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 203,
    name: "plug-in-Net-color-2",
    componentName: "IconPlugInNetColor2",
    title: "2",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 204,
    name: "plug-in-Net-color",
    componentName: "IconPlugInNetColor",
    title: "",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["", "Net", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 205,
    name: "plug-in-OCR-color",
    componentName: "IconPlugInOCRColor",
    title: "OCR",
    category: "Image",
    categoryCN: "",
    author: "KSW",
    tag: ["OCR", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 206,
    name: "plug-in-pdf-color",
    componentName: "IconPlugInPdfColor",
    title: "PDF",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["", "PDF", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 207,
    name: "plug-in-sogou-color",
    componentName: "IconPlugInSogouColor",
    title: "",
    category: "Software",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 208,
    name: "plug-in-SSL-color",
    componentName: "IconPlugInSSLColor",
    title: "SSL",
    category: "Security",
    categoryCN: "",
    author: "KSW",
    tag: ["", "SSL", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 209,
    name: "plug-in-text-color",
    componentName: "IconPlugInTextColor",
    title: "",
    category: "Text",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 210,
    name: "portfolio",
    componentName: "IconPortfolio",
    title: "",
    category: "Finance",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 211,
    name: "project-logo-gf-color",
    componentName: "IconProjectLogoGfColor",
    title: "GF",
    category: "Logo",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 212,
    name: "Question-line",
    componentName: "IconQuestionLine",
    title: "",
    category: "Symbols",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 213,
    name: "question",
    componentName: "IconQuestion",
    title: "",
    category: "Help",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 214,
    name: "ranking-color",
    componentName: "IconRankingColor",
    title: "",
    category: "Color",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 215,
    name: "ranking",
    componentName: "IconRanking",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 216,
    name: "re-screen",
    componentName: "IconReScreen",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 217,
    name: "refresh",
    componentName: "IconRefresh",
    title: "",
    category: "Action",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 218,
    name: "reset",
    componentName: "IconReset",
    title: "",
    category: "System",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 219,
    name: "rise",
    componentName: "IconRise",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 220,
    name: "save",
    componentName: "IconSave",
    title: "",
    category: "File",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 221,
    name: "scan",
    componentName: "IconScan",
    title: "",
    category: "Technology",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 222,
    name: "scrip-color",
    componentName: "IconScripColor",
    title: "",
    category: "Development",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 223,
    name: "scrip",
    componentName: "IconScrip",
    title: "",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 224,
    name: "seal",
    componentName: "IconSeal",
    title: "",
    category: "Stationery",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 225,
    name: "search",
    componentName: "IconSearch",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 226,
    name: "setting-animation",
    componentName: "IconSettingAnimation",
    title: "",
    category: "Design",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 227,
    name: "setting-fill",
    componentName: "IconSettingFill",
    title: "",
    category: "Tools",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 228,
    name: "setting",
    componentName: "IconSetting",
    title: "",
    category: "System",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 229,
    name: "show",
    componentName: "IconShow",
    title: "",
    category: "Visibility",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 230,
    name: "size-controls",
    componentName: "IconSizeControls",
    title: "",
    category: "Edit",
    categoryCN: "",
    author: "KSW",
    tag: [""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 231,
    name: "sort-bottom",
    componentName: "IconSortBottom",
    title: "",
    category: "Sorting",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 232,
    name: "sort-down",
    componentName: "IconSortDown",
    title: "",
    category: "Sorting",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 233,
    name: "sort-top",
    componentName: "IconSortTop",
    title: "",
    category: "Sorting",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 234,
    name: "sort-up",
    componentName: "IconSortUp",
    title: "",
    category: "Sorting",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 235,
    name: "status-403",
    componentName: "IconStatus403",
    title: "",
    category: "HTTP",
    categoryCN: "HTTP",
    author: "KSW",
    tag: ["", "", "403"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 236,
    name: "status-404",
    componentName: "IconStatus404",
    title: "",
    category: "Error",
    categoryCN: "",
    author: "KSW",
    tag: ["", "404", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 237,
    name: "status-500",
    componentName: "IconStatus500",
    title: "500",
    category: "Error",
    categoryCN: "",
    author: "KSW",
    tag: ["", "500", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 238,
    name: "status-danger",
    componentName: "IconStatusDanger",
    title: "",
    category: "Status",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 239,
    name: "status-def",
    componentName: "IconStatusDef",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 240,
    name: "status-empty-color",
    componentName: "IconStatusEmptyColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 241,
    name: "status-empty",
    componentName: "IconStatusEmpty",
    title: "",
    category: "Status",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 242,
    name: "status-info",
    componentName: "IconStatusInfo",
    title: "",
    category: "Information",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 243,
    name: "status-success",
    componentName: "IconStatusSuccess",
    title: "",
    category: "Status",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 244,
    name: "status-warning",
    componentName: "IconStatusWarning",
    title: "",
    category: "Alerts",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 245,
    name: "Step-Status-Failure",
    componentName: "IconStepStatusFailure",
    title: "",
    category: "Process",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 246,
    name: "Step-Status-Success",
    componentName: "IconStepStatusSuccess",
    title: "",
    category: "Progress",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 247,
    name: "store-color",
    componentName: "IconStoreColor",
    title: "",
    category: "Shopping",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 248,
    name: "SupportCenter",
    componentName: "IconSupportCenter",
    title: "",
    category: "Customer",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 249,
    name: "SystemType-aix-color",
    componentName: "IconSystemTypeAixColor",
    title: "",
    category: "Operating",
    categoryCN: "",
    author: "KSW",
    tag: ["AIX", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 250,
    name: "SystemType-android-color",
    componentName: "IconSystemTypeAndroidColor",
    title: "",
    category: "System",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 251,
    name: "SystemType-arm-color",
    componentName: "IconSystemTypeArmColor",
    title: "",
    category: "System",
    categoryCN: "",
    author: "KSW",
    tag: ["", "ARM", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 252,
    name: "SystemType-AS-color",
    componentName: "IconSystemTypeASColor",
    title: "",
    category: "System",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 253,
    name: "SystemType-firewall-color",
    componentName: "IconSystemTypeFirewallColor",
    title: "",
    category: "System",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 254,
    name: "SystemType-interchanger-color",
    componentName: "IconSystemTypeInterchangerColor",
    title: "",
    category: "Other",
    categoryCN: "",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 255,
    name: "SystemType-ios-color",
    componentName: "IconSystemTypeIosColor",
    title: "",
    category: "Operating",
    categoryCN: "",
    author: "KSW",
    tag: ["", "iOS", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 256,
    name: "SystemType-LB-color",
    componentName: "IconSystemTypeLBColor",
    title: "",
    category: "System",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 257,
    name: "SystemType-linux-color",
    componentName: "IconSystemTypeLinuxColor",
    title: "Linux",
    category: "Operating",
    categoryCN: "",
    author: "KSW",
    tag: ["Linux", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 258,
    name: "SystemType-router-color",
    componentName: "IconSystemTypeRouterColor",
    title: "",
    category: "Networking",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 259,
    name: "SystemType-Unix-color",
    componentName: "IconSystemTypeUnixColor",
    title: "Unix",
    category: "Operating",
    categoryCN: "",
    author: "KSW",
    tag: ["Unix", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 260,
    name: "SystemType-windows-color",
    componentName: "IconSystemTypeWindowsColor",
    title: "",
    category: "Operating",
    categoryCN: "",
    author: "KSW",
    tag: ["", "Windows", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 261,
    name: "table-control-more",
    componentName: "IconTableControlMore",
    title: "",
    category: "Table",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 262,
    name: "table-sort-down-color",
    componentName: "IconTableSortDownColor",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 263,
    name: "table-sort-normal-color",
    componentName: "IconTableSortNormalColor",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 264,
    name: "table-sort-up-color",
    componentName: "IconTableSortUpColor",
    title: "",
    category: "Data",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 265,
    name: "task",
    componentName: "IconTask",
    title: "",
    category: "Productivity",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 266,
    name: "test-color",
    componentName: "IconTestColor",
    title: "",
    category: "Color",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 267,
    name: "time",
    componentName: "IconTime",
    title: "",
    category: "Clock",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 268,
    name: "tips",
    componentName: "IconTips",
    title: "",
    category: "Helpful",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 269,
    name: "top1-color",
    componentName: "IconTop1Color",
    title: "",
    category: "Achievement",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 270,
    name: "top2-color",
    componentName: "IconTop2Color",
    title: "2",
    category: "Icons",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 271,
    name: "top3-color",
    componentName: "IconTop3Color",
    title: "",
    category: "Achievement",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 272,
    name: "triangle-bottom",
    componentName: "IconTriangleBottom",
    title: "",
    category: "Shapes",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 273,
    name: "triangle-top",
    componentName: "IconTriangleTop",
    title: "",
    category: "Shapes",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 274,
    name: "unfold",
    componentName: "IconUnfold",
    title: "",
    category: "Navigation",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 275,
    name: "upload",
    componentName: "IconUpload",
    title: "",
    category: "File",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 276,
    name: "user-filled",
    componentName: "IconUserFilled",
    title: "-",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 277,
    name: "users-filled",
    componentName: "IconUsersFilled",
    title: "-",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 278,
    name: "users",
    componentName: "IconUsers",
    title: "",
    category: "User",
    categoryCN: "",
    author: "KSW",
    tag: ["", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 279,
    name: "variable",
    componentName: "IconVariable",
    title: "",
    category: "Programming",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-28T08:21:35.000Z"
  },
  {
    id: 280,
    name: "view-switch-card",
    componentName: "IconViewSwitchCard",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 281,
    name: "view-switch-color",
    componentName: "IconViewSwitchColor",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 282,
    name: "view-toggle-details",
    componentName: "IconViewToggleDetails",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 283,
    name: "view-toggle-table",
    componentName: "IconViewToggleTable",
    title: "",
    category: "UI",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", "", "UI", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 284,
    name: "warning",
    componentName: "IconWarning",
    title: "",
    category: "Safety",
    categoryCN: "",
    author: "KSW",
    tag: ["", "", ""],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  }
];
var Ob = { class: "icon-container" };
var Bb = { class: "icon-list" };
var Zb = defineComponent({
  name: "KIconPopver",
  __name: "icon_popver",
  emits: ["updataIcon"],
  setup(e16, { expose: t10, emit: n }) {
    const o = ref(null), r = {}, a = ref(""), i = async (c) => {
      l("updataIcon", c);
    }, s = computed(() => a.value.trim() === "" ? Ou : Ou.filter((c) => {
      const u = c.name.includes(a.value), d = c.componentName.includes(a.value), m = c.tag.some((p) => p.includes(a.value));
      return u || d || m;
    })), l = n;
    return t10(Ae(r, o)), (c, u) => {
      const d = resolveComponent("k-input"), m = resolveComponent("k-button"), p = resolveComponent("k-popover");
      return openBlock(), createElementBlock("div", {
        ref_key: "KIconPopver",
        ref: o
      }, [
        createVNode(p, {
          trigger: "click",
          width: 470,
          placement: "bottom"
        }, {
          reference: withCtx(() => [
            renderSlot(c.$slots, "default", {}, () => [
              createVNode(m, null, {
                default: withCtx(() => u[1] || (u[1] = [
                  createTextVNode("")
                ])),
                _: 1
              })
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", Ob, [
              createVNode(d, {
                modelValue: a.value,
                "onUpdate:modelValue": u[0] || (u[0] = (f) => a.value = f)
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", Bb, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (f) => (openBlock(), createBlock(resolveDynamicComponent(f.componentName), {
                  class: "icon-item",
                  onClick: (h10) => i(f.componentName)
                }, null, 8, ["onClick"]))), 256))
              ])
            ])
          ]),
          _: 3
        })
      ], 512);
    };
  }
});
var Wb = $e(Zb);
var u1 = [
  Lt,
  Eb,
  ro,
  Y6,
  Mf,
  $f,
  fa,
  If,
  ay,
  Ef,
  Kf,
  zf,
  Go,
  vo,
  my,
  Lf,
  Ff,
  Ny,
  jf,
  Of,
  Hy,
  Io,
  Xy,
  f3,
  g3,
  Bf,
  Zf,
  wa,
  Wf,
  Hr,
  Ur,
  o1,
  i8,
  r1,
  i1,
  d8,
  f8,
  p8,
  h8,
  x8,
  D8,
  E8,
  K8,
  q8,
  el,
  cb,
  ar,
  rr,
  kb,
  Nb,
  xb,
  Pb,
  jb,
  Wb
];
var qb = { class: "drawer-btn w-5 h-5 border rounded-full flex justify-center items-center text-sm bg-white text-gray-400 hover:text-blue-400 hover:font-bold hover:border-blue-400" };
var Vb = { class: "KPageViewBus-content w-56 h-full" };
var Hb = { class: "KPageViewBus-content--drawer w-56 h-full flex flex-col" };
var Ub = { class: "KPageViewBus-head flex justify-between items-center py-4 border-b border-gray-200 box-border" };
var Gb = { class: "KPageViewBus-head-title text-xl" };
var Xb = {
  key: 0,
  class: "KPageViewBus-head-info"
};
var Yb = { class: "KPageViewBus-main pt-3 h-full flex" };
var Qb = {
  key: 0,
  class: "KPageViewBus-foot pt-3"
};
var Jb = defineComponent({
  name: "KPageViewBus",
  __name: "PageViewBus",
  props: {
    title: {
      type: String,
      default: ""
    },
    info: {
      type: String,
      default: void 0
    },
    refresh: {
      type: Boolean,
      default: true
    }
  },
  emits: ["refresh"],
  setup(e16, { emit: t10 }) {
    const n = ref(false), o = ref(false), r = e16, a = t10;
    return (i, s) => {
      const l = resolveComponent("IconArrowLeft"), c = resolveComponent("IconTips"), u = resolveComponent("IconRefresh"), d = resolveComponent("KButton");
      return openBlock(), createElementBlock("div", {
        id: "KPageViewBus",
        class: normalizeClass(["KPageViewBus px-3 border-r border-gray-100 relative", { "is-close": o.value }])
      }, [
        createBaseVNode("div", {
          class: "drawer-btn-box absolute w-6 h-6 flex justify-center items-center",
          onClick: s[0] || (s[0] = () => o.value = !o.value)
        }, [
          createBaseVNode("div", qb, [
            createVNode(l, { class: "text-gray-400" })
          ])
        ]),
        createBaseVNode("div", Vb, [
          createBaseVNode("div", Hb, [
            createBaseVNode("div", Ub, [
              createBaseVNode("div", {
                class: "flex items-center gap-1 h-8",
                onMouseenter: s[2] || (s[2] = () => n.value = true)
              }, [
                createBaseVNode("p", Gb, toDisplayString(e16.title), 1),
                r.info ? (openBlock(), createElementBlock("div", Xb, [
                  createVNode(unref(wa), {
                    content: r.info,
                    onHide: s[1] || (s[1] = () => n.value = false)
                  }, {
                    default: withCtx(() => [
                      withDirectives(createVNode(c, {
                        color: "#4193f2",
                        size: "16"
                      }, null, 512), [
                        [vShow, n.value]
                      ])
                    ]),
                    _: 1
                  }, 8, ["content"])
                ])) : createCommentVNode("", true)
              ], 32),
              renderSlot(i.$slots, "head", {}, () => [
                r.refresh ? (openBlock(), createBlock(d, {
                  key: 0,
                  text: "",
                  style: { "padding-right": "0" },
                  onClick: s[3] || (s[3] = () => a("refresh"))
                }, {
                  default: withCtx(() => [
                    createVNode(u)
                  ]),
                  _: 1
                })) : createCommentVNode("", true)
              ], true)
            ]),
            createBaseVNode("div", Yb, [
              renderSlot(i.$slots, "default", {}, void 0, true)
            ]),
            i.$slots.foot ? (openBlock(), createElementBlock("div", Qb, [
              renderSlot(i.$slots, "foot", {}, void 0, true)
            ])) : createCommentVNode("", true)
          ])
        ])
      ], 2);
    };
  }
});
var e92 = Ta(Jb, [["__scopeId", "data-v-43e1cc5f"]]);
var d1 = $e(e92);
var t9 = { class: "titel text-base text-gray-400 text-nowrap leading-6" };
var n9 = { class: "value text-base text-normal min-h-6 flex items-center leading-6 w-full" };
var o9 = { key: 0 };
var a9 = defineComponent({
  name: "KDetailsItem",
  __name: "DetailsItem",
  props: {
    label: {},
    value: {},
    render: {},
    showLine: { type: Boolean, default: void 0 },
    column: { default: 1 },
    direction: {},
    useflex: { type: Boolean, default: false }
  },
  setup(e16) {
    const t10 = e16, n = inject(
      "__maxColumn__",
      computed(() => t10.column)
    ), o = computed(() => n.value ? n.value >= t10.column ? t10.column : n.value : t10.column);
    return (r, a) => (openBlock(), createElementBlock("div", {
      ref: "RefDetailsItem",
      class: normalizeClass(["k-detailsItem bbm h-fit flex flex-col gap-1 shrink-0 pb-2", [
        { "border-b border-gray-200": t10.showLine === true },
        { "!flex-row": t10.direction === "horizontal" },
        { "min-w-24": t10.useflex === true }
      ]]),
      style: normalizeStyle(t10.useflex ? "" : `grid-column: span ${o.value};`)
    }, [
      createBaseVNode("p", t9, toDisplayString(r.label) + ":", 1),
      createBaseVNode("p", n9, [
        typeof r.value == "string" ? (openBlock(), createElementBlock("span", o9, toDisplayString(r.value), 1)) : createCommentVNode("", true),
        (openBlock(), createBlock(resolveDynamicComponent(typeof r.render == "function" ? r.render() : r.render)))
      ])
    ], 6));
  }
});
var Ci = Ta(a9, [["__scopeId", "data-v-f45a48bc"]]);
var r9 = {
  id: "KPageDetails",
  class: "KPageDetails h-full flex-1",
  style: { "min-width": "0" }
};
var i9 = { class: "KPageDetailsHead-content w-full flex flex-col bg-white rounded overflow-hidden mb-2 shadow-sm" };
var s9 = { class: "extra-head px-6 py-2 border-b border-gray-200" };
var l9 = { class: "w-full flex justify-between items-center" };
var c9 = { class: "head-title" };
var u9 = { class: "flex items-center gap-1 h-8" };
var d9 = { class: "head-toolbar" };
var f9 = { class: "extra-head-body px-6 py-3" };
var m9 = { class: "w-full relative overflow-auto scrollbar-hide flex gap-4" };
var p9 = { class: "shadow-sm flex-1" };
var h9 = defineComponent({
  name: "KPageDetails",
  __name: "PageDetails",
  props: {
    pageIcon: {
      type: String,
      default: ""
    },
    pageTitle: {
      type: String,
      default: ""
    },
    pageDescriptions: {
      type: String,
      default: ""
    },
    abstract: {
      type: Array,
      default: () => []
    },
    showLine: {
      type: Boolean,
      default: false
    },
    direction: {
      type: String,
      default: "vertical"
    },
    useflex: {
      type: Boolean,
      default: true
    }
  },
  setup(e16) {
    const t10 = e16;
    return (n, o) => (openBlock(), createElementBlock("div", r9, [
      createBaseVNode("div", i9, [
        createBaseVNode("div", s9, [
          renderSlot(n.$slots, "extra-head", {}, () => [
            createBaseVNode("div", l9, [
              createBaseVNode("div", c9, [
                renderSlot(n.$slots, "head-title", {}, () => [
                  createBaseVNode("div", u9, [
                    e16.pageIcon ? (openBlock(), createBlock(resolveDynamicComponent(e16.pageIcon), {
                      key: 0,
                      size: "24"
                    })) : createCommentVNode("", true),
                    createBaseVNode("span", null, toDisplayString(e16.pageTitle), 1)
                  ])
                ], true)
              ]),
              createBaseVNode("div", d9, [
                renderSlot(n.$slots, "head-toolbar", {}, void 0, true)
              ])
            ])
          ], true)
        ]),
        createBaseVNode("div", f9, [
          renderSlot(n.$slots, "head-abstract", {}, () => [
            createBaseVNode("div", m9, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(t10.abstract, (r) => (openBlock(), createBlock(Ci, {
                key: r.label,
                label: r.label,
                value: r.value,
                render: r.render,
                "show-line": e16.showLine,
                direction: e16.direction,
                useflex: e16.useflex
              }, null, 8, ["label", "value", "render", "show-line", "direction", "useflex"]))), 128))
            ])
          ], true)
        ])
      ]),
      createBaseVNode("div", p9, [
        renderSlot(n.$slots, "default", {}, void 0, true)
      ])
    ]));
  }
});
var g9 = Ta(h9, [["__scopeId", "data-v-29bd0471"]]);
var v9 = $e(g9);
var y9 = {
  id: "KPageTableView",
  class: "KPageTableView bbm w-full h-full bg-white rounded flex text-gray-700"
};
var b9 = {
  id: "KPageContent",
  class: "KPageContent h-full flex-1 flex flex-col pl-6 pr-3 pt-3",
  style: {
    "min-width": "0",
    "min-height": "0"
  }
};
var _9 = {
  id: "KPageHead",
  class: "KPageHead flex justify-between pb-1"
};
var w9 = {
  key: 0,
  class: "KPageHead-icon w-6 h-6 mr-1"
};
var T9 = {
  class: "KPageHead-title"
};
var C9 = {
  key: 1,
  class: "KPageHead-info pl-1"
};
var k9 = {
  id: "KPageBody",
  class: "KPageBody h-full"
};
var S9 = defineComponent({
  name: "KPageTableView",
  __name: "PageTableView",
  props: {
    showAside: {
      type: Boolean,
      default: false
    },
    asideTitle: {
      type: String,
      default: "viewBus"
    },
    asideInfo: {
      type: String,
      default: ""
    },
    asideRefresh: {
      type: Boolean,
      default: false
    },
    pageIcon: {
      type: String,
      default: ""
    },
    pageTitle: {
      type: String,
      default: ""
    },
    pageInfo: {
      type: String,
      default: ""
    }
  },
  emits: ["refresh"],
  setup(e16, {
    emit: t10
  }) {
    const n = e16, o = ref(false), a = /.(jpg|jpeg|png|gif|svg)$/.test(n.pageIcon) ? () => createVNode("img", {
      src: n.pageIcon,
      alt: "icon",
      class: "KPageHead-icon"
    }, null) : n.pageIcon, i = t10;
    return (s, l) => {
      const c = resolveComponent("IconTips");
      return openBlock(), createElementBlock("div", y9, [e16.showAside ? (openBlock(), createBlock(unref(d1), {
        key: 0,
        title: e16.asideTitle,
        info: e16.asideInfo,
        refresh: e16.asideRefresh,
        onRefresh: l[0] || (l[0] = (u) => i("refresh"))
      }, {
        head: withCtx(() => [renderSlot(s.$slots, "aside-toolbar")]),
        foot: withCtx(() => [renderSlot(s.$slots, "aside-foot")]),
        default: withCtx(() => [renderSlot(s.$slots, "aside")]),
        _: 3
      }, 8, ["title", "info", "refresh"])) : createCommentVNode("", true), createBaseVNode("div", b9, [createBaseVNode("div", _9, [createBaseVNode("div", {
        class: "KPageHead-title-container flex items-center",
        onMouseenter: l[2] || (l[2] = () => o.value = true)
      }, [e16.pageIcon ? (openBlock(), createElementBlock("div", w9, [(openBlock(), createBlock(resolveDynamicComponent(unref(a)), {
        size: "24"
      }))])) : createCommentVNode("", true), createBaseVNode("p", T9, toDisplayString(e16.pageTitle), 1), e16.pageIcon ? (openBlock(), createElementBlock("div", C9, [e16.pageInfo ? (openBlock(), createBlock(unref(wa), {
        key: 0,
        content: e16.pageInfo,
        onHide: l[1] || (l[1] = () => o.value = false)
      }, {
        default: withCtx(() => [withDirectives(createVNode(c, {
          color: "#4193f2",
          size: "16"
        }, null, 512), [[vShow, o.value]])]),
        _: 1
      }, 8, ["content"])) : createCommentVNode("", true)])) : createCommentVNode("", true)], 32), createBaseVNode("div", null, [renderSlot(s.$slots, "toolbar")])]), createBaseVNode("div", k9, [renderSlot(s.$slots, "default")])])]);
    };
  }
});
var N9 = $e(S9);
var M9 = defineComponent({
  name: "KDetails",
  __name: "Details",
  props: {
    abstract: {},
    direction: { default: "vertical" },
    showLine: { type: Boolean, default: false },
    useflex: { type: Boolean, default: false }
  },
  setup(e16) {
    const t10 = e16, n = ref(), o = ref();
    onMounted(() => {
      r();
    }), window.addEventListener("resize", r), onUnmounted(() => {
      window.removeEventListener("resize", r);
    });
    function r() {
      if (!n.value) return;
      let a = 1;
      const i = getComputedStyle(n.value).gridTemplateColumns.split(" ");
      for (let s = 1; s < i.length; s++) {
        if (Math.abs(parseInt(i[s]) - parseInt(i[s - 1])) > 2) {
          o.value = a;
          break;
        }
        a++;
      }
      o.value = a;
    }
    return provide("__maxColumn__", o), provide("__parentProps__", t10), (a, i) => (openBlock(), createElementBlock("div", {
      ref_key: "RefKDetails",
      ref: n,
      class: "box k-details w-full h-fit grid grid-cols-1 2xs:grid-cols-2 xs:grid-cols-2 sm:grid-cols-3 base:grid-cols-4 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6 gap-4"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(a.abstract, (s, l) => (openBlock(), createBlock(Ci, mergeProps({
        key: l,
        ref_for: true
      }, s, {
        "show-line": a.showLine,
        useflex: a.useflex,
        direction: a.direction
      }), null, 16, ["show-line", "useflex", "direction"]))), 128))
    ], 512));
  }
});
var $9 = $e(M9, { DetailsItem: Ci });
var f1 = tn(Ci);
var Vt = (e16, t10) => {
  const { o: n, i: o, u: r } = e16;
  let a = n, i;
  const s = (u, d) => {
    const m = a, p = u, f = d || (o ? !o(m, p) : m !== p);
    return (f || r) && (a = p, i = m), [a, f, i];
  };
  return [t10 ? (u) => s(t10(a, i), u) : s, (u) => [a, !!u, i]];
};
var x9 = typeof window < "u" && typeof HTMLElement < "u" && !!window.document;
var Ft = x9 ? window : {};
var m1 = Math.max;
var I9 = Math.min;
var tl = Math.round;
var Gr = Math.abs;
var Bu = Math.sign;
var p1 = Ft.cancelAnimationFrame;
var nc = Ft.requestAnimationFrame;
var Xr = Ft.setTimeout;
var nl = Ft.clearTimeout;
var ki = (e16) => typeof Ft[e16] < "u" ? Ft[e16] : void 0;
var D9 = ki("MutationObserver");
var Zu = ki("IntersectionObserver");
var Yr = ki("ResizeObserver");
var Nr = ki("ScrollTimeline");
var oc = (e16) => e16 === void 0;
var Si = (e16) => e16 === null;
var Mn = (e16) => typeof e16 == "number";
var ir = (e16) => typeof e16 == "string";
var ac = (e16) => typeof e16 == "boolean";
var ln = (e16) => typeof e16 == "function";
var xn = (e16) => Array.isArray(e16);
var Qr = (e16) => typeof e16 == "object" && !xn(e16) && !Si(e16);
var rc = (e16) => {
  const t10 = !!e16 && e16.length, n = Mn(t10) && t10 > -1 && t10 % 1 == 0;
  return xn(e16) || !ln(e16) && n ? t10 > 0 && Qr(e16) ? t10 - 1 in e16 : true : false;
};
var Jr = (e16) => !!e16 && e16.constructor === Object;
var ei = (e16) => e16 instanceof HTMLElement;
var Ni = (e16) => e16 instanceof Element;
function et(e16, t10) {
  if (rc(e16))
    for (let n = 0; n < e16.length && t10(e16[n], n, e16) !== false; n++)
      ;
  else e16 && et(Object.keys(e16), (n) => t10(e16[n], n, e16));
  return e16;
}
var h1 = (e16, t10) => e16.indexOf(t10) >= 0;
var Xa = (e16, t10) => e16.concat(t10);
var ht = (e16, t10, n) => (!ir(t10) && rc(t10) ? Array.prototype.push.apply(e16, t10) : e16.push(t10), e16);
var so = (e16) => Array.from(e16 || []);
var ic = (e16) => xn(e16) ? e16 : !ir(e16) && rc(e16) ? so(e16) : [e16];
var ol = (e16) => !!e16 && !e16.length;
var al = (e16) => so(new Set(e16));
var Jt = (e16, t10, n) => {
  et(e16, (r) => r ? r.apply(void 0, t10 || []) : true), !n && (e16.length = 0);
};
var g1 = "paddingTop";
var v1 = "paddingRight";
var y1 = "paddingLeft";
var b1 = "paddingBottom";
var _1 = "marginLeft";
var w1 = "marginRight";
var T1 = "marginBottom";
var C1 = "overflowX";
var k1 = "overflowY";
var Mi = "width";
var $i = "height";
var qn = "visible";
var bo = "hidden";
var ma = "scroll";
var A9 = (e16) => {
  const t10 = String(e16 || "");
  return t10 ? t10[0].toUpperCase() + t10.slice(1) : "";
};
var xi = (e16, t10, n, o) => {
  if (e16 && t10) {
    let r = true;
    return et(n, (a) => {
      const i = e16[a], s = t10[a];
      i !== s && (r = false);
    }), r;
  }
  return false;
};
var S1 = (e16, t10) => xi(e16, t10, ["w", "h"]);
var Mr = (e16, t10) => xi(e16, t10, ["x", "y"]);
var E9 = (e16, t10) => xi(e16, t10, ["t", "r", "b", "l"]);
var So = () => {
};
var Me = (e16, ...t10) => e16.bind(0, ...t10);
var Xo = (e16) => {
  let t10;
  const n = e16 ? Xr : nc, o = e16 ? nl : p1;
  return [(r) => {
    o(t10), t10 = n(() => r(), ln(e16) ? e16() : e16);
  }, () => o(t10)];
};
var rl = (e16, t10) => {
  const { _: n, v: o, p: r, S: a } = t10 || {};
  let i, s, l, c, u = So;
  const d = function(g) {
    u(), nl(i), c = i = s = void 0, u = So, e16.apply(this, g);
  }, m = (h10) => a && s ? a(s, h10) : h10, p = () => {
    u !== So && d(m(l) || l);
  }, f = function() {
    const g = so(arguments), v = ln(n) ? n() : n;
    if (Mn(v) && v >= 0) {
      const k = ln(o) ? o() : o, T = Mn(k) && k >= 0, w = v > 0 ? Xr : nc, _ = v > 0 ? nl : p1, x = m(g) || g, R = d.bind(0, x);
      let I;
      u(), r && !c ? (R(), c = true, I = w(() => c = void 0, v)) : (I = w(R, v), T && !i && (i = Xr(p, k))), u = () => _(I), s = l = x;
    } else
      d(g);
  };
  return f.m = p, f;
};
var N1 = (e16, t10) => Object.prototype.hasOwnProperty.call(e16, t10);
var dn = (e16) => e16 ? Object.keys(e16) : [];
var qe = (e16, t10, n, o, r, a, i) => {
  const s = [t10, n, o, r, a, i];
  return (typeof e16 != "object" || Si(e16)) && !ln(e16) && (e16 = {}), et(s, (l) => {
    et(l, (c, u) => {
      const d = l[u];
      if (e16 === d)
        return true;
      const m = xn(d);
      if (d && Jr(d)) {
        const p = e16[u];
        let f = p;
        m && !xn(p) ? f = [] : !m && !Jr(p) && (f = {}), e16[u] = qe(f, d);
      } else
        e16[u] = m ? d.slice() : d;
    });
  }), e16;
};
var M1 = (e16, t10) => et(qe({}, e16), (n, o, r) => {
  n === void 0 ? delete r[o] : n && Jr(n) && (r[o] = M1(n));
});
var sc = (e16) => !dn(e16).length;
var $1 = (e16, t10, n) => m1(e16, I9(t10, n));
var No = (e16) => al((xn(e16) ? e16 : (e16 || "").split(" ")).filter((t10) => t10));
var lc = (e16, t10) => e16 && e16.getAttribute(t10);
var Wu = (e16, t10) => e16 && e16.hasAttribute(t10);
var An = (e16, t10, n) => {
  et(No(t10), (o) => {
    e16 && e16.setAttribute(o, String(n || ""));
  });
};
var vn = (e16, t10) => {
  et(No(t10), (n) => e16 && e16.removeAttribute(n));
};
var Ii = (e16, t10) => {
  const n = No(lc(e16, t10)), o = Me(An, e16, t10), r = (a, i) => {
    const s = new Set(n);
    return et(No(a), (l) => {
      s[i](l);
    }), so(s).join(" ");
  };
  return {
    O: (a) => o(r(a, "delete")),
    $: (a) => o(r(a, "add")),
    C: (a) => {
      const i = No(a);
      return i.reduce((s, l) => s && n.includes(l), i.length > 0);
    }
  };
};
var x1 = (e16, t10, n) => (Ii(e16, t10).O(n), Me(cc, e16, t10, n));
var cc = (e16, t10, n) => (Ii(e16, t10).$(n), Me(x1, e16, t10, n));
var ti = (e16, t10, n, o) => (o ? cc : x1)(e16, t10, n);
var uc = (e16, t10, n) => Ii(e16, t10).C(n);
var I1 = (e16) => Ii(e16, "class");
var D1 = (e16, t10) => {
  I1(e16).O(t10);
};
var dc = (e16, t10) => (I1(e16).$(t10), Me(D1, e16, t10));
var A1 = (e16, t10) => {
  const n = t10 ? Ni(t10) && t10 : document;
  return n ? so(n.querySelectorAll(e16)) : [];
};
var K9 = (e16, t10) => {
  const n = t10 ? Ni(t10) && t10 : document;
  return n && n.querySelector(e16);
};
var il = (e16, t10) => Ni(e16) && e16.matches(t10);
var E1 = (e16) => il(e16, "body");
var sl = (e16) => e16 ? so(e16.childNodes) : [];
var Ya = (e16) => e16 && e16.parentElement;
var Yo = (e16, t10) => Ni(e16) && e16.closest(t10);
var ll = (e16) => document.activeElement;
var z9 = (e16, t10, n) => {
  const o = Yo(e16, t10), r = e16 && K9(n, o), a = Yo(r, t10) === o;
  return o && r ? o === e16 || r === e16 || a && Yo(Yo(e16, n), t10) !== o : false;
};
var pa = (e16) => {
  et(ic(e16), (t10) => {
    const n = Ya(t10);
    t10 && n && n.removeChild(t10);
  });
};
var Gt = (e16, t10) => Me(pa, e16 && t10 && et(ic(t10), (n) => {
  n && e16.appendChild(n);
}));
var oa = (e16) => {
  const t10 = document.createElement("div");
  return An(t10, "class", e16), t10;
};
var K1 = (e16) => {
  const t10 = oa();
  return t10.innerHTML = e16.trim(), et(sl(t10), (n) => pa(n));
};
var qu = (e16, t10) => e16.getPropertyValue(t10) || e16[t10] || "";
var z1 = (e16) => {
  const t10 = e16 || 0;
  return isFinite(t10) ? t10 : 0;
};
var yr = (e16) => z1(parseFloat(e16 || ""));
var cl = (e16) => Math.round(e16 * 1e4) / 1e4;
var P1 = (e16) => `${cl(z1(e16))}px`;
function Qa(e16, t10) {
  e16 && t10 && et(t10, (n, o) => {
    try {
      const r = e16.style, a = Si(n) || ac(n) ? "" : Mn(n) ? P1(n) : n;
      o.indexOf("--") === 0 ? r.setProperty(o, a) : r[o] = a;
    } catch {
    }
  });
}
function Ln(e16, t10, n) {
  const o = ir(t10);
  let r = o ? "" : {};
  if (e16) {
    const a = Ft.getComputedStyle(e16, n) || e16.style;
    r = o ? qu(a, t10) : so(t10).reduce((i, s) => (i[s] = qu(a, s), i), r);
  }
  return r;
}
var Vu = (e16, t10, n) => {
  const o = t10 ? `${t10}-` : "", r = n ? `-${n}` : "", a = `${o}top${r}`, i = `${o}right${r}`, s = `${o}bottom${r}`, l = `${o}left${r}`, c = Ln(e16, [a, i, s, l]);
  return {
    t: yr(c[a]),
    r: yr(c[i]),
    b: yr(c[s]),
    l: yr(c[l])
  };
};
var P9 = (e16, t10) => `translate${Qr(e16) ? `(${e16.x},${e16.y})` : `Y(${e16})`}`;
var R9 = (e16) => !!(e16.offsetWidth || e16.offsetHeight || e16.getClientRects().length);
var L9 = {
  w: 0,
  h: 0
};
var Di = (e16, t10) => t10 ? {
  w: t10[`${e16}Width`],
  h: t10[`${e16}Height`]
} : L9;
var F9 = (e16) => Di("inner", e16 || Ft);
var aa = Me(Di, "offset");
var R1 = Me(Di, "client");
var ni = Me(Di, "scroll");
var fc = (e16) => {
  const t10 = parseFloat(Ln(e16, Mi)) || 0, n = parseFloat(Ln(e16, $i)) || 0;
  return {
    w: t10 - tl(t10),
    h: n - tl(n)
  };
};
var Ts = (e16) => e16.getBoundingClientRect();
var j9 = (e16) => !!e16 && R9(e16);
var ul = (e16) => !!(e16 && (e16[$i] || e16[Mi]));
var L1 = (e16, t10) => {
  const n = ul(e16);
  return !ul(t10) && n;
};
var Hu = (e16, t10, n, o) => {
  et(No(t10), (r) => {
    e16 && e16.removeEventListener(r, n, o);
  });
};
var ut = (e16, t10, n, o) => {
  var r;
  const a = (r = o && o.H) != null ? r : true, i = o && o.I || false, s = o && o.A || false, l = {
    passive: a,
    capture: i
  };
  return Me(Jt, No(t10).map((c) => {
    const u = s ? (d) => {
      Hu(e16, c, u, i), n && n(d);
    } : n;
    return e16 && e16.addEventListener(c, u, l), Me(Hu, e16, c, u, i);
  }));
};
var F1 = (e16) => e16.stopPropagation();
var dl = (e16) => e16.preventDefault();
var j1 = (e16) => F1(e16) || dl(e16);
var Cn = (e16, t10) => {
  const { x: n, y: o } = Mn(t10) ? {
    x: t10,
    y: t10
  } : t10 || {};
  Mn(n) && (e16.scrollLeft = n), Mn(o) && (e16.scrollTop = o);
};
var Xt = (e16) => ({
  x: e16.scrollLeft,
  y: e16.scrollTop
});
var O1 = () => ({
  D: {
    x: 0,
    y: 0
  },
  M: {
    x: 0,
    y: 0
  }
});
var O9 = (e16, t10) => {
  const { D: n, M: o } = e16, { w: r, h: a } = t10, i = (d, m, p) => {
    let f = Bu(d) * p, h10 = Bu(m) * p;
    if (f === h10) {
      const g = Gr(d), v = Gr(m);
      h10 = g > v ? 0 : h10, f = g < v ? 0 : f;
    }
    return f = f === h10 ? 0 : f, [f + 0, h10 + 0];
  }, [s, l] = i(n.x, o.x, r), [c, u] = i(n.y, o.y, a);
  return {
    D: {
      x: s,
      y: c
    },
    M: {
      x: l,
      y: u
    }
  };
};
var Uu = ({ D: e16, M: t10 }) => {
  const n = (o, r) => o === 0 && o <= r;
  return {
    x: n(e16.x, t10.x),
    y: n(e16.y, t10.y)
  };
};
var Gu = ({ D: e16, M: t10 }, n) => {
  const o = (r, a, i) => $1(0, 1, (r - i) / (r - a) || 0);
  return {
    x: o(e16.x, t10.x, n.x),
    y: o(e16.y, t10.y, n.y)
  };
};
var fl = (e16) => {
  e16 && e16.focus && e16.focus({
    preventScroll: true
  });
};
var Xu = (e16, t10) => {
  et(ic(t10), e16);
};
var ml = (e16) => {
  const t10 = /* @__PURE__ */ new Map(), n = (a, i) => {
    if (a) {
      const s = t10.get(a);
      Xu((l) => {
        s && s[l ? "delete" : "clear"](l);
      }, i);
    } else
      t10.forEach((s) => {
        s.clear();
      }), t10.clear();
  }, o = (a, i) => {
    if (ir(a)) {
      const c = t10.get(a) || /* @__PURE__ */ new Set();
      return t10.set(a, c), Xu((u) => {
        ln(u) && c.add(u);
      }, i), Me(n, a, i);
    }
    ac(i) && i && n();
    const s = dn(a), l = [];
    return et(s, (c) => {
      const u = a[c];
      u && ht(l, o(c, u));
    }), Me(Jt, l);
  }, r = (a, i) => {
    et(so(t10.get(a)), (s) => {
      i && !ol(i) ? s.apply(0, i) : s();
    });
  };
  return o(e16 || {}), [o, n, r];
};
var Yu = (e16) => JSON.stringify(e16, (t10, n) => {
  if (ln(n))
    throw 0;
  return n;
});
var Qu = (e16, t10) => e16 ? `${t10}`.split(".").reduce((n, o) => n && N1(n, o) ? n[o] : void 0, e16) : void 0;
var B9 = {
  paddingAbsolute: false,
  showNativeOverlaidScrollbars: false,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    autoHideSuspend: false,
    dragScroll: true,
    clickScroll: false,
    pointers: ["mouse", "touch", "pen"]
  }
};
var B1 = (e16, t10) => {
  const n = {}, o = Xa(dn(t10), dn(e16));
  return et(o, (r) => {
    const a = e16[r], i = t10[r];
    if (Qr(a) && Qr(i))
      qe(n[r] = {}, B1(a, i)), sc(n[r]) && delete n[r];
    else if (N1(t10, r) && i !== a) {
      let s = true;
      if (xn(a) || xn(i))
        try {
          Yu(a) === Yu(i) && (s = false);
        } catch {
        }
      s && (n[r] = i);
    }
  }), n;
};
var Ju = (e16, t10, n) => (o) => [Qu(e16, o), n || Qu(t10, o) !== void 0];
var Ca = "data-overlayscrollbars";
var $r = "os-environment";
var br = `${$r}-scrollbar-hidden`;
var Cs = `${Ca}-initialize`;
var xr = "noClipping";
var e0 = `${Ca}-body`;
var Qn = Ca;
var Z9 = "host";
var En = `${Ca}-viewport`;
var W9 = C1;
var q9 = k1;
var V9 = "arrange";
var Z1 = "measuring";
var H9 = "scrolling";
var W1 = "scrollbarHidden";
var U9 = "noContent";
var pl = `${Ca}-padding`;
var t0 = `${Ca}-content`;
var mc = "os-size-observer";
var G9 = `${mc}-appear`;
var X9 = `${mc}-listener`;
var Y9 = "os-trinsic-observer";
var Q9 = "os-theme-none";
var nn = "os-scrollbar";
var J9 = `${nn}-rtl`;
var e72 = `${nn}-horizontal`;
var t7 = `${nn}-vertical`;
var q1 = `${nn}-track`;
var pc = `${nn}-handle`;
var n7 = `${nn}-visible`;
var o7 = `${nn}-cornerless`;
var n0 = `${nn}-interaction`;
var o0 = `${nn}-unusable`;
var hl = `${nn}-auto-hide`;
var a0 = `${hl}-hidden`;
var r0 = `${nn}-wheel`;
var a7 = `${q1}-interactive`;
var r7 = `${pc}-interactive`;
var V1;
var i7 = () => V1;
var s7 = (e16) => {
  V1 = e16;
};
var ks;
var l7 = () => {
  const e16 = (T, w, _) => {
    Gt(document.body, T), Gt(document.body, T);
    const M = R1(T), x = aa(T), R = fc(w);
    return _ && pa(T), {
      x: x.h - M.h + R.h,
      y: x.w - M.w + R.w
    };
  }, t10 = (T) => {
    let w = false;
    const _ = dc(T, br);
    try {
      w = Ln(T, "scrollbar-width") === "none" || Ln(T, "display", "::-webkit-scrollbar") === "none";
    } catch {
    }
    return _(), w;
  }, n = `.${$r}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${$r} div{width:200%;height:200%;margin:10px 0}.${br}{scrollbar-width:none!important}.${br}::-webkit-scrollbar,.${br}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`, r = K1(`<div class="${$r}"><div></div><style>${n}</style></div>`)[0], a = r.firstChild, i = r.lastChild, s = i7();
  s && (i.nonce = s);
  const [l, , c] = ml(), [u, d] = Vt({
    o: e16(r, a),
    i: Mr
  }, Me(e16, r, a, true)), [m] = d(), p = t10(r), f = {
    x: m.x === 0,
    y: m.y === 0
  }, h10 = {
    elements: {
      host: null,
      padding: !p,
      viewport: (T) => p && E1(T) && T,
      content: false
    },
    scrollbars: {
      slot: true
    },
    cancel: {
      nativeScrollbarsOverlaid: false,
      body: null
    }
  }, g = qe({}, B9), v = Me(qe, {}, g), y = Me(qe, {}, h10), k = {
    T: m,
    k: f,
    R: p,
    V: !!Nr,
    L: Me(l, "r"),
    U: y,
    P: (T) => qe(h10, T) && y(),
    N: v,
    q: (T) => qe(g, T) && v(),
    B: qe({}, h10),
    F: qe({}, g)
  };
  if (vn(r, "style"), pa(r), ut(Ft, "resize", () => {
    c("r", []);
  }), ln(Ft.matchMedia) && !p && (!f.x || !f.y)) {
    const T = (w) => {
      const _ = Ft.matchMedia(`(resolution: ${Ft.devicePixelRatio}dppx)`);
      ut(_, "change", () => {
        w(), T(w);
      }, {
        A: true
      });
    };
    T(() => {
      const [w, _] = u();
      qe(k.T, w), c("r", [_]);
    });
  }
  return k;
};
var In = () => (ks || (ks = l7()), ks);
var H1 = (e16, t10) => ln(t10) ? t10.apply(0, e16) : t10;
var c7 = (e16, t10, n, o) => {
  const r = oc(o) ? n : o;
  return H1(e16, r) || t10.apply(0, e16);
};
var U1 = (e16, t10, n, o) => {
  const r = oc(o) ? n : o, a = H1(e16, r);
  return !!a && (ei(a) ? a : t10.apply(0, e16));
};
var u7 = (e16, t10) => {
  const { nativeScrollbarsOverlaid: n, body: o } = t10 || {}, { k: r, R: a, U: i } = In(), { nativeScrollbarsOverlaid: s, body: l } = i().cancel, c = n ?? s, u = oc(o) ? l : o, d = (r.x || r.y) && c, m = e16 && (Si(u) ? !a : u);
  return !!d || !!m;
};
var hc = /* @__PURE__ */ new WeakMap();
var d7 = (e16, t10) => {
  hc.set(e16, t10);
};
var f7 = (e16) => {
  hc.delete(e16);
};
var G1 = (e16) => hc.get(e16);
var m7 = (e16, t10, n) => {
  let o = false;
  const r = n ? /* @__PURE__ */ new WeakMap() : false, a = () => {
    o = true;
  }, i = (s) => {
    if (r && n) {
      const l = n.map((c) => {
        const [u, d] = c || [];
        return [d && u ? (s || A1)(u, e16) : [], d];
      });
      et(l, (c) => et(c[0], (u) => {
        const d = c[1], m = r.get(u) || [];
        if (e16.contains(u) && d) {
          const f = ut(u, d, (h10) => {
            o ? (f(), r.delete(u)) : t10(h10);
          });
          r.set(u, ht(m, f));
        } else
          Jt(m), r.delete(u);
      }));
    }
  };
  return i(), [a, i];
};
var i0 = (e16, t10, n, o) => {
  let r = false;
  const { j: a, X: i, Y: s, W: l, J: c, G: u } = o || {}, d = rl(() => r && n(true), {
    _: 33,
    v: 99
  }), [m, p] = m7(e16, d, s), f = a || [], h10 = i || [], g = Xa(f, h10), v = (k, T) => {
    if (!ol(T)) {
      const w = c || So, _ = u || So, M = [], x = [];
      let R = false, I = false;
      if (et(T, (P) => {
        const { attributeName: F, target: N, type: j, oldValue: z, addedNodes: A, removedNodes: B } = P, D = j === "attributes", te = j === "childList", ie = e16 === N, U = D && F, oe = U && lc(N, F || ""), se = ir(oe) ? oe : null, E = U && z !== se, K = h1(h10, F) && E;
        if (t10 && (te || !ie)) {
          const ee = D && E, V = ee && l && il(N, l), pe = (V ? !w(N, F, z, se) : !D || ee) && !_(P, !!V, e16, o);
          et(A, (Te) => ht(M, Te)), et(B, (Te) => ht(M, Te)), I = I || pe;
        }
        !t10 && ie && E && !w(N, F, z, se) && (ht(x, F), R = R || K);
      }), p((P) => al(M).reduce((F, N) => (ht(F, A1(P, N)), il(N, P) ? ht(F, N) : F), [])), t10)
        return !k && I && n(false), [false];
      if (!ol(x) || R) {
        const P = [al(x), R];
        return !k && n.apply(0, P), P;
      }
    }
  }, y = new D9(Me(v, false));
  return [() => (y.observe(e16, {
    attributes: true,
    attributeOldValue: true,
    attributeFilter: g,
    subtree: t10,
    childList: t10,
    characterData: t10
  }), r = true, () => {
    r && (m(), y.disconnect(), r = false);
  }), () => {
    if (r)
      return d.m(), v(true, y.takeRecords());
  }];
};
var X1 = {};
var Y1 = {};
var p7 = (e16) => {
  et(e16, (t10) => et(t10, (n, o) => {
    X1[o] = t10[o];
  }));
};
var Q1 = (e16, t10, n) => dn(e16).map((o) => {
  const { static: r, instance: a } = e16[o], [i, s, l] = n || [], c = n ? a : r;
  if (c) {
    const u = n ? c(i, s, t10) : c(t10);
    return (l || Y1)[o] = u;
  }
});
var sr = (e16) => Y1[e16];
var h7 = "__osOptionsValidationPlugin";
var g7 = "__osSizeObserverPlugin";
var v7 = (e16, t10) => {
  const { k: n } = t10, [o, r] = e16("showNativeOverlaidScrollbars");
  return [o && n.x && n.y, r];
};
var ha = (e16) => e16.indexOf(qn) === 0;
var y7 = (e16, t10) => {
  const n = (r, a, i, s) => {
    const l = r === qn ? bo : r.replace(`${qn}-`, ""), c = ha(r), u = ha(i);
    return !a && !s ? bo : c && u ? qn : c ? a && s ? l : a ? qn : bo : a ? l : u && s ? qn : bo;
  }, o = {
    x: n(t10.x, e16.x, t10.y, e16.y),
    y: n(t10.y, e16.y, t10.x, e16.x)
  };
  return {
    K: o,
    Z: {
      x: o.x === ma,
      y: o.y === ma
    }
  };
};
var J1 = "__osScrollbarsHidingPlugin";
var b7 = "__osClickScrollPlugin";
var em = (e16, t10, n) => {
  const { dt: o } = n || {}, r = sr(g7), [a] = Vt({
    o: false,
    u: true
  });
  return () => {
    const i = [], l = K1(`<div class="${mc}"><div class="${X9}"></div></div>`)[0], c = l.firstChild, u = (d) => {
      const m = d instanceof ResizeObserverEntry;
      let p = false, f = false;
      if (m) {
        const [h10, , g] = a(d.contentRect), v = ul(h10);
        f = L1(h10, g), p = !f && !v;
      } else
        f = d === true;
      p || t10({
        ft: true,
        dt: f
      });
    };
    if (Yr) {
      const d = new Yr((m) => u(m.pop()));
      d.observe(c), ht(i, () => {
        d.disconnect();
      });
    } else if (r) {
      const [d, m] = r(c, u, o);
      ht(i, Xa([dc(l, G9), ut(l, "animationstart", d)], m));
    } else
      return So;
    return Me(Jt, ht(i, Gt(e16, l)));
  };
};
var _7 = (e16, t10) => {
  let n;
  const o = (l) => l.h === 0 || l.isIntersecting || l.intersectionRatio > 0, r = oa(Y9), [a] = Vt({
    o: false
  }), i = (l, c) => {
    if (l) {
      const u = a(o(l)), [, d] = u;
      return d && !c && t10(u) && [u];
    }
  }, s = (l, c) => i(c.pop(), l);
  return [() => {
    const l = [];
    if (Zu)
      n = new Zu(Me(s, false), {
        root: e16
      }), n.observe(r), ht(l, () => {
        n.disconnect();
      });
    else {
      const c = () => {
        const u = aa(r);
        i(u);
      };
      ht(l, em(r, c)()), c();
    }
    return Me(Jt, ht(l, Gt(e16, r)));
  }, () => n && s(true, n.takeRecords())];
};
var w7 = (e16, t10, n, o) => {
  let r, a, i, s, l, c;
  const u = `[${Qn}]`, d = `[${En}]`, m = ["id", "class", "style", "open", "wrap", "cols", "rows"], { vt: p, ht: f, ot: h10, gt: g, bt: v, nt: y, wt: k, yt: T, St: w, Ot: _ } = e16, M = (K) => Ln(K, "direction") === "rtl", x = {
    $t: false,
    ct: M(p)
  }, R = In(), I = sr(J1), [P] = Vt({
    i: S1,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const K = I && I.tt(e16, t10, x, R, n).ut, V = !(k && y) && uc(f, Qn, xr), le = !y && T(V9), pe = le && Xt(g), Te = pe && _(), Z = w(Z1, V), X = le && K && K()[0], Q = ni(h10), W = fc(h10);
    return X && X(), Cn(g, pe), Te && Te(), V && Z(), {
      w: Q.w + W.w,
      h: Q.h + W.h
    };
  }), F = rl(o, {
    _: () => r,
    v: () => a,
    S(K, ee) {
      const [V] = K, [le] = ee;
      return [Xa(dn(V), dn(le)).reduce((pe, Te) => (pe[Te] = V[Te] || le[Te], pe), {})];
    }
  }), N = (K) => {
    const ee = M(p);
    qe(K, {
      Ct: c !== ee
    }), qe(x, {
      ct: ee
    }), c = ee;
  }, j = (K, ee) => {
    const [V, le] = K, pe = {
      xt: le
    };
    return qe(x, {
      $t: V
    }), !ee && o(pe), pe;
  }, z = ({ ft: K, dt: ee }) => {
    const le = !(K && !ee) && R.R ? F : o, pe = {
      ft: K || ee,
      dt: ee
    };
    N(pe), le(pe);
  }, A = (K, ee) => {
    const [, V] = P(), le = {
      Ht: V
    };
    return N(le), V && !ee && (K ? o : F)(le), le;
  }, B = (K, ee, V) => {
    const le = {
      Et: ee
    };
    return N(le), ee && !V && F(le), le;
  }, [D, te] = v ? _7(f, j) : [], ie = !y && em(f, z, {
    dt: true
  }), [U, oe] = i0(f, false, B, {
    X: m,
    j: m
  }), se = y && Yr && new Yr((K) => {
    const ee = K[K.length - 1].contentRect;
    z({
      ft: true,
      dt: L1(ee, l)
    }), l = ee;
  }), E = rl(() => {
    const [, K] = P();
    o({
      Ht: K
    });
  }, {
    _: 222,
    p: true
  });
  return [() => {
    se && se.observe(f);
    const K = ie && ie(), ee = D && D(), V = U(), le = R.L((pe) => {
      pe ? F({
        zt: pe
      }) : E();
    });
    return () => {
      se && se.disconnect(), K && K(), ee && ee(), s && s(), V(), le();
    };
  }, ({ It: K, At: ee, Dt: V }) => {
    const le = {}, [pe] = K("update.ignoreMutation"), [Te, Z] = K("update.attributes"), [X, Q] = K("update.elementEvents"), [W, de] = K("update.debounce"), Ne = Q || Z, Pe = ee || V, tt = (Qe) => ln(pe) && pe(Qe);
    if (Ne) {
      i && i(), s && s();
      const [Qe, lt] = i0(v || h10, true, A, {
        j: Xa(m, Te || []),
        Y: X,
        W: u,
        G: (Be, Xe) => {
          const { target: it, attributeName: St } = Be;
          return (!Xe && St && !y ? z9(it, u, d) : false) || !!Yo(it, `.${nn}`) || !!tt(Be);
        }
      });
      s = Qe(), i = lt;
    }
    if (de)
      if (F.m(), xn(W)) {
        const Qe = W[0], lt = W[1];
        r = Mn(Qe) && Qe, a = Mn(lt) && lt;
      } else Mn(W) ? (r = W, a = false) : (r = false, a = false);
    if (Pe) {
      const Qe = oe(), lt = te && te(), Be = i && i();
      Qe && qe(le, B(Qe[0], Qe[1], Pe)), lt && qe(le, j(lt[0], Pe)), Be && qe(le, A(Be[0], Pe));
    }
    return N(le), le;
  }, x];
};
var T7 = (e16, t10, n, o) => {
  const r = "--os-viewport-percent", a = "--os-scroll-percent", i = "--os-scroll-direction", { U: s } = In(), { scrollbars: l } = s(), { slot: c } = l, { vt: u, ht: d, ot: m, Mt: p, gt: f, wt: h10, nt: g } = t10, { scrollbars: v } = p ? {} : e16, { slot: y } = v || {}, k = [], T = [], w = [], _ = U1([u, d, m], () => g && h10 ? u : d, c, y), M = (U) => {
    if (Nr) {
      const oe = new Nr({
        source: f,
        axis: U
      });
      return {
        kt: (E) => {
          const K = E.Tt.animate({
            clear: ["left"],
            [a]: [0, 1]
          }, {
            timeline: oe
          });
          return () => K.cancel();
        }
      };
    }
  }, x = {
    x: M("x"),
    y: M("y")
  }, R = () => {
    const { Rt: U, Vt: oe } = n, se = (E, K) => $1(0, 1, E / (E + K) || 0);
    return {
      x: se(oe.x, U.x),
      y: se(oe.y, U.y)
    };
  }, I = (U, oe, se) => {
    const E = se ? dc : D1;
    et(U, (K) => {
      E(K.Tt, oe);
    });
  }, P = (U, oe) => {
    et(U, (se) => {
      const [E, K] = oe(se);
      Qa(E, K);
    });
  }, F = (U, oe, se) => {
    const E = ac(se), K = E ? se : true, ee = E ? !se : true;
    K && I(T, U, oe), ee && I(w, U, oe);
  }, N = () => {
    const U = R(), oe = (se) => (E) => [E.Tt, {
      [r]: cl(se) + ""
    }];
    P(T, oe(U.x)), P(w, oe(U.y));
  }, j = () => {
    if (!Nr) {
      const { Lt: U } = n, oe = Gu(U, Xt(f)), se = (E) => (K) => [K.Tt, {
        [a]: cl(E) + ""
      }];
      P(T, se(oe.x)), P(w, se(oe.y));
    }
  }, z = () => {
    const { Lt: U } = n, oe = Uu(U), se = (E) => (K) => [K.Tt, {
      [i]: E ? "0" : "1"
    }];
    P(T, se(oe.x)), P(w, se(oe.y));
  }, A = () => {
    if (g && !h10) {
      const { Rt: U, Lt: oe } = n, se = Uu(oe), E = Gu(oe, Xt(f)), K = (ee) => {
        const { Tt: V } = ee, le = Ya(V) === m && V, pe = (Te, Z, X) => {
          const Q = Z * Te;
          return P1(X ? Q : -Q);
        };
        return [le, le && {
          transform: P9({
            x: pe(E.x, U.x, se.x),
            y: pe(E.y, U.y, se.y)
          })
        }];
      };
      P(T, K), P(w, K);
    }
  }, B = (U) => {
    const oe = U ? "x" : "y", E = oa(`${nn} ${U ? e72 : t7}`), K = oa(q1), ee = oa(pc), V = {
      Tt: E,
      Ut: K,
      Pt: ee
    }, le = x[oe];
    return ht(U ? T : w, V), ht(k, [Gt(E, K), Gt(K, ee), Me(pa, E), le && le.kt(V), o(V, F, U)]), V;
  }, D = Me(B, true), te = Me(B, false), ie = () => (Gt(_, T[0].Tt), Gt(_, w[0].Tt), Me(Jt, k));
  return D(), te(), [{
    Nt: N,
    qt: j,
    Bt: z,
    Ft: A,
    jt: F,
    Xt: {
      Yt: T,
      Wt: D,
      Jt: Me(P, T)
    },
    Gt: {
      Yt: w,
      Wt: te,
      Jt: Me(P, w)
    }
  }, ie];
};
var C7 = (e16, t10, n, o) => (r, a, i) => {
  const { ht: s, ot: l, nt: c, gt: u, Kt: d, Ot: m } = t10, { Tt: p, Ut: f, Pt: h10 } = r, [g, v] = Xo(333), [y, k] = Xo(444), T = (M) => {
    ln(u.scrollBy) && u.scrollBy({
      behavior: "smooth",
      left: M.x,
      top: M.y
    });
  }, w = () => {
    const M = "pointerup pointercancel lostpointercapture", x = `client${i ? "X" : "Y"}`, R = i ? Mi : $i, I = i ? "left" : "top", P = i ? "w" : "h", F = i ? "x" : "y", N = (z, A) => (B) => {
      const { Rt: D } = n, te = aa(f)[P] - aa(h10)[P], U = A * B / te * D[F];
      Cn(u, {
        [F]: z + U
      });
    }, j = [];
    return ut(f, "pointerdown", (z) => {
      const A = Yo(z.target, `.${pc}`) === h10, B = A ? h10 : f, D = e16.scrollbars, te = D[A ? "dragScroll" : "clickScroll"], { button: ie, isPrimary: U, pointerType: oe } = z, { pointers: se } = D;
      if (ie === 0 && U && te && (se || []).includes(oe)) {
        Jt(j), k();
        const K = !A && (z.shiftKey || te === "instant"), ee = Me(Ts, h10), V = Me(Ts, f), le = (Xe, it) => (Xe || ee())[I] - (it || V())[I], pe = tl(Ts(u)[R]) / aa(u)[P] || 1, Te = N(Xt(u)[F], 1 / pe), Z = z[x], X = ee(), Q = V(), W = X[R], de = le(X, Q) + W / 2, Ne = Z - Q[I], Pe = A ? 0 : Ne - de, tt = (Xe) => {
          Jt(Be), B.releasePointerCapture(Xe.pointerId);
        }, Qe = A || K, lt = m(), Be = [ut(d, M, tt), ut(d, "selectstart", (Xe) => dl(Xe), {
          H: false
        }), ut(f, M, tt), Qe && ut(f, "pointermove", (Xe) => Te(Pe + (Xe[x] - Z))), Qe && (() => {
          const Xe = Xt(u);
          lt();
          const it = Xt(u), St = {
            x: it.x - Xe.x,
            y: it.y - Xe.y
          };
          (Gr(St.x) > 3 || Gr(St.y) > 3) && (m(), Cn(u, Xe), T(St), y(lt));
        })];
        if (B.setPointerCapture(z.pointerId), K)
          Te(Pe);
        else if (!A) {
          const Xe = sr(b7);
          if (Xe) {
            const it = Xe(Te, Pe, W, (St) => {
              St ? lt() : ht(Be, lt);
            });
            ht(Be, it), ht(j, Me(it, true));
          }
        }
      }
    });
  };
  let _ = true;
  return Me(Jt, [ut(h10, "pointermove pointerleave", o), ut(p, "pointerenter", () => {
    a(n0, true);
  }), ut(p, "pointerleave pointercancel", () => {
    a(n0, false);
  }), !c && ut(p, "mousedown", () => {
    const M = ll();
    (Wu(M, En) || Wu(M, Qn) || M === document.body) && Xr(Me(fl, l), 25);
  }), ut(p, "wheel", (M) => {
    const { deltaX: x, deltaY: R, deltaMode: I } = M;
    _ && I === 0 && Ya(p) === s && T({
      x,
      y: R
    }), _ = false, a(r0, true), g(() => {
      _ = true, a(r0);
    }), dl(M);
  }, {
    H: false,
    I: true
  }), ut(p, "pointerdown", Me(ut, d, "click", j1, {
    A: true,
    I: true,
    H: false
  }), {
    I: true
  }), w(), v, k]);
};
var k7 = (e16, t10, n, o, r, a) => {
  let i, s, l, c, u, d = So, m = 0;
  const p = (U) => U.pointerType === "mouse", [f, h10] = Xo(), [g, v] = Xo(100), [y, k] = Xo(100), [T, w] = Xo(() => m), [_, M] = T7(e16, r, o, C7(t10, r, o, (U) => p(U) && B())), { ht: x, Qt: R, wt: I } = r, { jt: P, Nt: F, qt: N, Bt: j, Ft: z } = _, A = (U, oe) => {
    if (w(), U)
      P(a0);
    else {
      const se = Me(P, a0, true);
      m > 0 && !oe ? T(se) : se();
    }
  }, B = () => {
    (l ? !i : !c) && (A(true), g(() => {
      A(false);
    }));
  }, D = (U) => {
    P(hl, U, true), P(hl, U, false);
  }, te = (U) => {
    p(U) && (i = l, l && A(true));
  }, ie = [w, v, k, h10, () => d(), ut(x, "pointerover", te, {
    A: true
  }), ut(x, "pointerenter", te), ut(x, "pointerleave", (U) => {
    p(U) && (i = false, l && A(false));
  }), ut(x, "pointermove", (U) => {
    p(U) && s && B();
  }), ut(R, "scroll", (U) => {
    f(() => {
      N(), B();
    }), a(U), z();
  })];
  return [() => Me(Jt, ht(ie, M())), ({ It: U, Dt: oe, Zt: se, tn: E }) => {
    const { nn: K, sn: ee, en: V, cn: le } = E || {}, { Ct: pe, dt: Te } = se || {}, { ct: Z } = n, { k: X } = In(), { K: Q, rn: W } = o, [de, Ne] = U("showNativeOverlaidScrollbars"), [Pe, tt] = U("scrollbars.theme"), [Qe, lt] = U("scrollbars.visibility"), [Be, Xe] = U("scrollbars.autoHide"), [it, St] = U("scrollbars.autoHideSuspend"), [pn] = U("scrollbars.autoHideDelay"), [hn, cn] = U("scrollbars.dragScroll"), [ne, ae] = U("scrollbars.clickScroll"), [he, xe] = U("overflow"), Ee = Te && !oe, Ve = W.x || W.y, Je = K || ee || le || pe || oe, Ie = V || lt || xe, Nt = de && X.x && X.y, bt = (Ze, un, jo) => {
      const lo = Ze.includes(ma) && (Qe === qn || Qe === "auto" && un === ma);
      return P(n7, lo, jo), lo;
    };
    if (m = pn, Ee && (it && Ve ? (D(false), d(), y(() => {
      d = ut(R, "scroll", Me(D, true), {
        A: true
      });
    })) : D(true)), Ne && P(Q9, Nt), tt && (P(u), P(Pe, true), u = Pe), St && !it && D(true), Xe && (s = Be === "move", l = Be === "leave", c = Be === "never", A(c, true)), cn && P(r7, hn), ae && P(a7, !!ne), Ie) {
      const Ze = bt(he.x, Q.x, true), un = bt(he.y, Q.y, false);
      P(o7, !(Ze && un));
    }
    Je && (N(), F(), z(), le && j(), P(o0, !W.x, true), P(o0, !W.y, false), P(J9, Z && !I));
  }, {}, _];
};
var S7 = (e16) => {
  const t10 = In(), { U: n, R: o } = t10, { elements: r } = n(), { padding: a, viewport: i, content: s } = r, l = ei(e16), c = l ? {} : e16, { elements: u } = c, { padding: d, viewport: m, content: p } = u || {}, f = l ? e16 : c.target, h10 = E1(f), g = f.ownerDocument, v = g.documentElement, y = () => g.defaultView || Ft, k = Me(c7, [f]), T = Me(U1, [f]), w = Me(oa, ""), _ = Me(k, w, i), M = Me(T, w, s), x = (W) => {
    const de = aa(W), Ne = ni(W), Pe = Ln(W, C1), tt = Ln(W, k1);
    return Ne.w - de.w > 0 && !ha(Pe) || Ne.h - de.h > 0 && !ha(tt);
  }, R = _(m), I = R === f, P = I && h10, F = !I && M(p), N = !I && R === F, j = P ? v : R, z = P ? j : f, A = !I && T(w, a, d), B = !N && F, D = [B, j, A, z].map((W) => ei(W) && !Ya(W) && W), te = (W) => W && h1(D, W), ie = !te(j) && x(j) ? j : f, U = P ? v : j, se = {
    vt: f,
    ht: z,
    ot: j,
    ln: A,
    bt: B,
    gt: U,
    Qt: P ? g : j,
    an: h10 ? v : ie,
    Kt: g,
    wt: h10,
    Mt: l,
    nt: I,
    un: y,
    yt: (W) => uc(j, En, W),
    St: (W, de) => ti(j, En, W, de),
    Ot: () => ti(U, En, H9, true)
  }, { vt: E, ht: K, ln: ee, ot: V, bt: le } = se, pe = [() => {
    vn(K, [Qn, Cs]), vn(E, Cs), h10 && vn(v, [Cs, Qn]);
  }];
  let Te = sl([le, V, ee, K, E].find((W) => W && !te(W)));
  const Z = P ? E : le || V, X = Me(Jt, pe);
  return [se, () => {
    const W = y(), de = ll(), Ne = (Be) => {
      Gt(Ya(Be), sl(Be)), pa(Be);
    }, Pe = (Be) => ut(Be, "focusin focusout focus blur", j1, {
      I: true,
      H: false
    }), tt = "tabindex", Qe = lc(V, tt), lt = Pe(de);
    return An(K, Qn, I ? "" : Z9), An(ee, pl, ""), An(V, En, ""), An(le, t0, ""), I || (An(V, tt, Qe || "-1"), h10 && An(v, e0, "")), Gt(Z, Te), Gt(K, ee), Gt(ee || K, !I && V), Gt(V, le), ht(pe, [lt, () => {
      const Be = ll(), Xe = te(V), it = Xe && Be === V ? E : Be, St = Pe(it);
      vn(ee, pl), vn(le, t0), vn(V, En), h10 && vn(v, e0), Qe ? An(V, tt, Qe) : vn(V, tt), te(le) && Ne(le), Xe && Ne(V), te(ee) && Ne(ee), fl(it), St();
    }]), o && !I && (cc(V, En, W1), ht(pe, Me(vn, V, En))), fl(!I && h10 && de === E && W.top === W ? V : de), lt(), Te = 0, X;
  }, X];
};
var N7 = ({ bt: e16 }) => ({ Zt: t10, _n: n, Dt: o }) => {
  const { xt: r } = t10 || {}, { $t: a } = n;
  e16 && (r || o) && Qa(e16, {
    [$i]: a && "100%"
  });
};
var M7 = ({ ht: e16, ln: t10, ot: n, nt: o }, r) => {
  const [a, i] = Vt({
    i: E9,
    o: Vu()
  }, Me(Vu, e16, "padding", ""));
  return ({ It: s, Zt: l, _n: c, Dt: u }) => {
    let [d, m] = i(u);
    const { R: p } = In(), { ft: f, Ht: h10, Ct: g } = l || {}, { ct: v } = c, [y, k] = s("paddingAbsolute");
    (f || m || (u || h10)) && ([d, m] = a(u));
    const w = !o && (k || g || m);
    if (w) {
      const _ = !y || !t10 && !p, M = d.r + d.l, x = d.t + d.b, R = {
        [w1]: _ && !v ? -M : 0,
        [T1]: _ ? -x : 0,
        [_1]: _ && v ? -M : 0,
        top: _ ? -d.t : 0,
        right: _ ? v ? -d.r : "auto" : 0,
        left: _ ? v ? "auto" : -d.l : 0,
        [Mi]: _ && `calc(100% + ${M}px)`
      }, I = {
        [g1]: _ ? d.t : 0,
        [v1]: _ ? d.r : 0,
        [b1]: _ ? d.b : 0,
        [y1]: _ ? d.l : 0
      };
      Qa(t10 || n, R), Qa(n, I), qe(r, {
        ln: d,
        dn: !_,
        rt: t10 ? I : qe({}, R, I)
      });
    }
    return {
      fn: w
    };
  };
};
var $7 = (e16, t10) => {
  const n = In(), { ht: o, ln: r, ot: a, nt: i, Qt: s, gt: l, wt: c, St: u, un: d } = e16, { R: m } = n, p = c && i, f = Me(m1, 0), h10 = {
    display: () => false,
    direction: (oe) => oe !== "ltr",
    flexDirection: (oe) => oe.endsWith("-reverse"),
    writingMode: (oe) => oe !== "horizontal-tb"
  }, g = dn(h10), v = {
    i: S1,
    o: {
      w: 0,
      h: 0
    }
  }, y = {
    i: Mr,
    o: {}
  }, k = (oe) => {
    u(Z1, !p && oe);
  }, T = (oe) => {
    if (!g.some((Z) => {
      const X = oe[Z];
      return X && h10[Z](X);
    }))
      return {
        D: {
          x: 0,
          y: 0
        },
        M: {
          x: 1,
          y: 1
        }
      };
    k(true);
    const E = Xt(l), K = u(U9, true), ee = ut(s, ma, (Z) => {
      const X = Xt(l);
      Z.isTrusted && X.x === E.x && X.y === E.y && F1(Z);
    }, {
      I: true,
      A: true
    });
    Cn(l, {
      x: 0,
      y: 0
    }), K();
    const V = Xt(l), le = ni(l);
    Cn(l, {
      x: le.w,
      y: le.h
    });
    const pe = Xt(l);
    Cn(l, {
      x: pe.x - V.x < 1 && -le.w,
      y: pe.y - V.y < 1 && -le.h
    });
    const Te = Xt(l);
    return Cn(l, E), nc(() => ee()), {
      D: V,
      M: Te
    };
  }, w = (oe, se) => {
    const E = Ft.devicePixelRatio % 1 !== 0 ? 1 : 0, K = {
      w: f(oe.w - se.w),
      h: f(oe.h - se.h)
    };
    return {
      w: K.w > E ? K.w : 0,
      h: K.h > E ? K.h : 0
    };
  }, [_, M] = Vt(v, Me(fc, a)), [x, R] = Vt(v, Me(ni, a)), [I, P] = Vt(v), [F] = Vt(y), [N, j] = Vt(v), [z] = Vt(y), [A] = Vt({
    i: (oe, se) => xi(oe, se, g),
    o: {}
  }, () => j9(a) ? Ln(a, g) : {}), [B, D] = Vt({
    i: (oe, se) => Mr(oe.D, se.D) && Mr(oe.M, se.M),
    o: O1()
  }), te = sr(J1), ie = (oe, se) => `${se ? W9 : q9}${A9(oe)}`, U = (oe) => {
    const se = (K) => [qn, bo, ma].map((ee) => ie(ee, K)), E = se(true).concat(se()).join(" ");
    u(E), u(dn(oe).map((K) => ie(oe[K], K === "x")).join(" "), true);
  };
  return ({ It: oe, Zt: se, _n: E, Dt: K }, { fn: ee }) => {
    const { ft: V, Ht: le, Ct: pe, dt: Te, zt: Z } = se || {}, X = te && te.tt(e16, t10, E, n, oe), { it: Q, ut: W, _t: de } = X || {}, [Ne, Pe] = v7(oe, n), [tt, Qe] = oe("overflow"), lt = ha(tt.x), Be = ha(tt.y), Xe = true;
    let it = M(K), St = R(K), pn = P(K), hn = j(K);
    Pe && m && u(W1, !Ne);
    {
      uc(o, Qn, xr) && k(true);
      const [ur] = W ? W() : [], [co] = it = _(K), [Bo] = St = x(K), Bn = R1(a), uo = p && F9(d()), Ei = {
        w: f(Bo.w + co.w),
        h: f(Bo.h + co.h)
      }, Zo = {
        w: f((uo ? uo.w : Bn.w + f(Bn.w - Bo.w)) + co.w),
        h: f((uo ? uo.h : Bn.h + f(Bn.h - Bo.h)) + co.h)
      };
      ur && ur(), hn = N(Zo), pn = I(w(Ei, Zo), K);
    }
    const [cn, ne] = hn, [ae, he] = pn, [xe, Ee] = St, [Ve, Je] = it, [Ie, Nt] = F({
      x: ae.w > 0,
      y: ae.h > 0
    }), bt = lt && Be && (Ie.x || Ie.y) || lt && Ie.x && !Ie.y || Be && Ie.y && !Ie.x, Ze = ee || pe || Z || Je || Ee || ne || he || Qe || Pe || Xe, un = y7(Ie, tt), [jo, lo] = z(un.K), [lr, Oo] = A(K), ka = pe || Te || Oo || Nt || K, [Ai, cr] = ka ? B(T(lr), K) : D();
    return Ze && (lo && U(un.K), de && Q && Qa(a, de(un, E, Q(un, xe, Ve)))), k(false), ti(o, Qn, xr, bt), ti(r, pl, xr, bt), qe(t10, {
      K: jo,
      Vt: {
        x: cn.w,
        y: cn.h
      },
      Rt: {
        x: ae.w,
        y: ae.h
      },
      rn: Ie,
      Lt: O9(Ai, ae)
    }), {
      en: lo,
      nn: ne,
      sn: he,
      cn: cr || he,
      vn: ka
    };
  };
};
var x7 = (e16) => {
  const [t10, n, o] = S7(e16), r = {
    ln: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    },
    dn: false,
    rt: {
      [w1]: 0,
      [T1]: 0,
      [_1]: 0,
      [g1]: 0,
      [v1]: 0,
      [b1]: 0,
      [y1]: 0
    },
    Vt: {
      x: 0,
      y: 0
    },
    Rt: {
      x: 0,
      y: 0
    },
    K: {
      x: bo,
      y: bo
    },
    rn: {
      x: false,
      y: false
    },
    Lt: O1()
  }, { vt: a, gt: i, nt: s, Ot: l } = t10, { R: c, k: u } = In(), d = !c && (u.x || u.y), m = [N7(t10), M7(t10, r), $7(t10, r)];
  return [n, (p) => {
    const f = {}, g = d && Xt(i), v = g && l();
    return et(m, (y) => {
      qe(f, y(p, f) || {});
    }), Cn(i, g), v && v(), !s && Cn(a, 0), f;
  }, r, t10, o];
};
var I7 = (e16, t10, n, o, r) => {
  let a = false;
  const i = Ju(t10, {}), [s, l, c, u, d] = x7(e16), [m, p, f] = w7(u, c, i, (T) => {
    k({}, T);
  }), [h10, g, , v] = k7(e16, t10, f, c, u, r), y = (T) => dn(T).some((w) => !!T[w]), k = (T, w) => {
    if (n())
      return false;
    const { pn: _, Dt: M, At: x, hn: R } = T, I = _ || {}, P = !!M || !a, F = {
      It: Ju(t10, I, P),
      pn: I,
      Dt: P
    };
    if (R)
      return g(F), false;
    const N = w || p(qe({}, F, {
      At: x
    })), j = l(qe({}, F, {
      _n: f,
      Zt: N
    }));
    g(qe({}, F, {
      Zt: N,
      tn: j
    }));
    const z = y(N), A = y(j), B = z || A || !sc(I) || P;
    return a = true, B && o(T, {
      Zt: N,
      tn: j
    }), B;
  };
  return [() => {
    const { an: T, gt: w, Ot: _ } = u, M = Xt(T), x = [m(), s(), h10()], R = _();
    return Cn(w, M), R(), Me(Jt, x);
  }, k, () => ({
    gn: f,
    bn: c
  }), {
    wn: u,
    yn: v
  }, d];
};
var kn = (e16, t10, n) => {
  const { N: o } = In(), r = ei(e16), a = r ? e16 : e16.target, i = G1(a);
  if (t10 && !i) {
    let s = false;
    const l = [], c = {}, u = (I) => {
      const P = M1(I), F = sr(h7);
      return F ? F(P, true) : P;
    }, d = qe({}, o(), u(t10)), [m, p, f] = ml(), [h10, g, v] = ml(n), y = (I, P) => {
      v(I, P), f(I, P);
    }, [k, T, w, _, M] = I7(e16, d, () => s, ({ pn: I, Dt: P }, { Zt: F, tn: N }) => {
      const { ft: j, Ct: z, xt: A, Ht: B, Et: D, dt: te } = F, { nn: ie, sn: U, en: oe, cn: se } = N;
      y("updated", [R, {
        updateHints: {
          sizeChanged: !!j,
          directionChanged: !!z,
          heightIntrinsicChanged: !!A,
          overflowEdgeChanged: !!ie,
          overflowAmountChanged: !!U,
          overflowStyleChanged: !!oe,
          scrollCoordinatesChanged: !!se,
          contentMutation: !!B,
          hostMutation: !!D,
          appear: !!te
        },
        changedOptions: I || {},
        force: !!P
      }]);
    }, (I) => y("scroll", [R, I])), x = (I) => {
      f7(a), Jt(l), s = true, y("destroyed", [R, I]), p(), g();
    }, R = {
      options(I, P) {
        if (I) {
          const F = P ? o() : {}, N = B1(d, qe(F, u(I)));
          sc(N) || (qe(d, N), T({
            pn: N
          }));
        }
        return qe({}, d);
      },
      on: h10,
      off: (I, P) => {
        I && P && g(I, P);
      },
      state() {
        const { gn: I, bn: P } = w(), { ct: F } = I, { Vt: N, Rt: j, K: z, rn: A, ln: B, dn: D, Lt: te } = P;
        return qe({}, {
          overflowEdge: N,
          overflowAmount: j,
          overflowStyle: z,
          hasOverflow: A,
          scrollCoordinates: {
            start: te.D,
            end: te.M
          },
          padding: B,
          paddingAbsolute: D,
          directionRTL: F,
          destroyed: s
        });
      },
      elements() {
        const { vt: I, ht: P, ln: F, ot: N, bt: j, gt: z, Qt: A } = _.wn, { Xt: B, Gt: D } = _.yn, te = (U) => {
          const { Pt: oe, Ut: se, Tt: E } = U;
          return {
            scrollbar: E,
            track: se,
            handle: oe
          };
        }, ie = (U) => {
          const { Yt: oe, Wt: se } = U, E = te(oe[0]);
          return qe({}, E, {
            clone: () => {
              const K = te(se());
              return T({
                hn: true
              }), K;
            }
          });
        };
        return qe({}, {
          target: I,
          host: P,
          padding: F || N,
          viewport: N,
          content: j || N,
          scrollOffsetElement: z,
          scrollEventElement: A,
          scrollbarHorizontal: ie(B),
          scrollbarVertical: ie(D)
        });
      },
      update: (I) => T({
        Dt: I,
        At: true
      }),
      destroy: Me(x, false),
      plugin: (I) => c[dn(I)[0]]
    };
    return ht(l, [M]), d7(a, R), Q1(X1, kn, [R, m, c]), u7(_.wn.wt, !r && e16.cancel) ? (x(true), R) : (ht(l, k()), y("initialized", [R]), R.update(), R);
  }
  return i;
};
kn.plugin = (e16) => {
  const t10 = xn(e16), n = t10 ? e16 : [e16], o = n.map((r) => Q1(r, kn)[0]);
  return p7(n), t10 ? o : o[0];
};
kn.valid = (e16) => {
  const t10 = e16 && e16.elements, n = ln(t10) && t10();
  return Jr(n) && !!G1(n.target);
};
kn.env = () => {
  const { T: e16, k: t10, R: n, V: o, B: r, F: a, U: i, P: s, N: l, q: c } = In();
  return qe({}, {
    scrollbarsSize: e16,
    scrollbarsOverlaid: t10,
    scrollbarsHiding: n,
    scrollTimeline: o,
    staticDefaultInitialization: r,
    staticDefaultOptions: a,
    getDefaultInitialization: i,
    setDefaultInitialization: s,
    getDefaultOptions: l,
    setDefaultOptions: c
  });
};
kn.nonce = s7;
var D7 = () => {
  if (typeof window > "u") {
    const c = () => {
    };
    return [c, c];
  }
  let e16, t10;
  const n = window, o = typeof n.requestIdleCallback == "function", r = n.requestAnimationFrame, a = n.cancelAnimationFrame, i = o ? n.requestIdleCallback : r, s = o ? n.cancelIdleCallback : a, l = () => {
    s(e16), a(t10);
  };
  return [
    (c, u) => {
      l(), e16 = i(
        o ? () => {
          l(), t10 = r(c);
        } : c,
        typeof u == "object" ? u : { timeout: 2233 }
      );
    },
    l
  ];
};
var A7 = (e16) => {
  let t10 = null, n, o, r;
  const a = shallowRef(e16 || {}), [i, s] = D7();
  return watch(
    () => {
      var l;
      return unref((l = a.value) == null ? void 0 : l.defer);
    },
    (l) => {
      r = l;
    },
    { deep: true, immediate: true }
  ), watch(
    () => {
      var l;
      return unref((l = a.value) == null ? void 0 : l.options);
    },
    (l) => {
      n = l, kn.valid(t10) && t10.options(n || {}, true);
    },
    { deep: true, immediate: true }
  ), watch(
    () => {
      var l;
      return unref((l = a.value) == null ? void 0 : l.events);
    },
    (l) => {
      o = l, kn.valid(t10) && t10.on(
        /* c8 ignore next */
        o || {},
        true
      );
    },
    { deep: true, immediate: true }
  ), onUnmounted(() => {
    s(), t10 == null || t10.destroy();
  }), [
    (l) => {
      if (kn.valid(t10))
        return t10;
      const c = () => t10 = kn(l, n || {}, o || {});
      r ? i(c, r) : c();
    },
    () => t10
  ];
};
var s0 = defineComponent({
  __name: "OverlayScrollbarsComponent",
  props: {
    element: {
      type: [String, Object],
      default: "div"
    },
    options: { type: Object },
    events: { type: Object },
    defer: { type: [Boolean, Object] }
  },
  emits: ["osInitialized", "osUpdated", "osDestroyed", "osScroll"],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = {
      initialized: "osInitialized",
      updated: "osUpdated",
      destroyed: "osDestroyed",
      scroll: "osScroll"
    }, { element: a, options: i, events: s, defer: l } = toRefs(o), c = shallowRef(null), u = shallowRef(null), d = ref(), [m, p] = A7({ options: i, events: d, defer: l });
    return t10({
      osInstance: p,
      getElement: () => c.value
    }), watchPostEffect((f) => {
      const { value: h10 } = c, { value: g } = u;
      h10 && (m(
        a.value === "body" ? {
          target: h10,
          cancel: {
            body: null
          }
        } : {
          target: h10,
          elements: {
            viewport: g,
            content: g
          }
        }
      ), f(() => {
        var v;
        return (v = p()) == null ? void 0 : v.destroy();
      }));
    }), watch(
      () => unref(s),
      (f) => {
        const h10 = f || {};
        d.value = Object.keys(r).reduce((g, v) => {
          const y = h10[v];
          return g[v] = [
            (...k) => n(
              r[v],
              ...k
            ),
            ...(Array.isArray(y) ? y : [y]).filter(Boolean)
          ], g;
        }, {});
      },
      { deep: true, immediate: true }
    ), (f, h10) => (openBlock(), createBlock(resolveDynamicComponent(unref(a)), {
      "data-overlayscrollbars-initialize": "",
      ref_key: "elementRef",
      ref: c
    }, {
      default: withCtx(() => [
        unref(a) === "body" ? renderSlot(f.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock("div", {
          key: 1,
          "data-overlayscrollbars-contents": "",
          ref_key: "slotRef",
          ref: u
        }, [
          renderSlot(f.$slots, "default")
        ], 512))
      ]),
      _: 3
    }, 512));
  }
});
var E7 = { class: "k-menu-item__title" };
var K7 = { class: "k-menu-item__title" };
var z7 = defineComponent({
  name: "SubMenu",
  __name: "subMenu",
  props: {
    options: {}
  },
  emits: ["click"],
  setup(e16, { emit: t10 }) {
    const n = e16, o = t10, r = computed(() => (i) => {
      const { children: s, ...l } = i;
      return l;
    }), a = (i) => {
      o("click", i);
    };
    return (i, s) => {
      const l = resolveComponent("sub-menu", true);
      return openBlock(true), createElementBlock(Fragment, null, renderList(n.options, (c) => (openBlock(), createElementBlock(Fragment, null, [
        Array.isArray(c.children) && c.children.length > 0 ? (openBlock(), createBlock(unref(ElSubMenu), mergeProps({
          key: 0,
          index: c.index,
          ref_for: true
        }, r.value(c)), {
          title: withCtx(() => [
            c.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(c.icon)))
              ]),
              _: 2
            }, 1024)) : createCommentVNode("", true),
            renderSlot(i.$slots, `${c.index}-title`, {}, () => [
              createBaseVNode("span", E7, toDisplayString(c.title), 1)
            ])
          ]),
          default: withCtx(() => [
            createVNode(l, {
              options: c.children,
              onClick: a
            }, createSlots({ _: 2 }, [
              renderList(i.$slots, (u, d) => ({
                name: d,
                fn: withCtx((m) => [
                  renderSlot(i.$slots, d, mergeProps({ ref_for: true }, m))
                ])
              }))
            ]), 1032, ["options"])
          ]),
          _: 2
        }, 1040, ["index"])) : (openBlock(), createBlock(unref(ElMenuItem), {
          key: 1,
          index: c.index,
          disabled: c.disabled,
          route: c.route,
          onClick: a
        }, {
          title: withCtx(() => [
            renderSlot(i.$slots, `${c.index}-title`, {}, () => [
              createBaseVNode("span", K7, toDisplayString(c.title), 1)
            ])
          ]),
          default: withCtx(() => [
            c.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(c.icon)))
              ]),
              _: 2
            }, 1024)) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1032, ["index", "disabled", "route"]))
      ], 64))), 256);
    };
  }
});
var P7 = { class: "k-layout-container h-screen flex overflow-hidden" };
var R7 = { class: "k-layout-content h-screen overflow-hidden flex flex-col flex-1" };
var L7 = { class: "k-layout-header bg-white h-12 px-4 flex w-full justify-between items-center border-b" };
var F7 = { class: "k-layout-main" };
var j7 = { class: "k-layout-footer" };
var O7 = defineComponent({
  name: "KMenuView",
  __name: "MenuView",
  props: {
    options: { default: () => [] },
    active: {},
    showCollapse: { type: Boolean, default: true },
    collapse: { type: Boolean, default: void 0 }
  },
  emits: ["click", "select"],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = n, a = computed(() => o.collapse !== void 0 ? o.collapse : i.value), i = ref(false), s = (m) => {
      r("click", m);
    }, l = () => {
      o.collapse === void 0 && (i.value = true);
    }, c = () => {
      o.collapse === void 0 && (i.value = false);
    }, u = () => {
      o.collapse === void 0 && (i.value = !i.value);
    }, d = (m) => {
      r("select", m);
    };
    return t10({ collapse: l, expand: c, toggleCollapse: u }), (m, p) => (openBlock(), createElementBlock("div", P7, [
      createBaseVNode("div", {
        class: normalizeClass(["k-layout-aside flex flex-col", { "is-collapse": a.value }])
      }, [
        m.$slots["app-logo"] ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["logo-box h-12 flex justify-start items-center p-4", { "is-collapse": a.value }])
        }, [
          renderSlot(m.$slots, "app-logo")
        ], 2)) : createCommentVNode("", true),
        createVNode(unref(s0), {
          defer: "",
          class: "OverlayScrollbarsComponent flex-1",
          options: { scrollbars: { autoHide: "scroll", theme: "os-theme-light" } }
        }, {
          default: withCtx(() => [
            createVNode(unref(ElMenu), mergeProps(m.$attrs, {
              collapse: a.value,
              onSelect: d
            }), {
              default: withCtx(() => [
                createVNode(z7, {
                  options: m.options,
                  onClick: s
                }, createSlots({ _: 2 }, [
                  renderList(m.$slots, (f, h10) => ({
                    name: h10,
                    fn: withCtx((g) => [
                      renderSlot(m.$slots, h10, normalizeProps(guardReactiveProps(g)))
                    ])
                  }))
                ]), 1032, ["options"])
              ]),
              _: 3
            }, 16, ["collapse"])
          ]),
          _: 3
        })
      ], 2),
      createBaseVNode("div", R7, [
        createBaseVNode("div", L7, [
          o.showCollapse && o.collapse === void 0 ? (openBlock(), createBlock(unref(Ip), {
            key: 0,
            class: normalizeClass([{ "rotate-180": !i.value }, "collapse-btn cursor-pointer"]),
            color: "black",
            size: "20",
            onClick: p[0] || (p[0] = (f) => i.value = !i.value)
          }, null, 8, ["class"])) : createCommentVNode("", true),
          renderSlot(m.$slots, "header")
        ]),
        createVNode(unref(s0), {
          defer: "",
          options: { scrollbars: { autoHide: "scroll" } },
          class: "flex-1"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", F7, [
              renderSlot(m.$slots, "main")
            ]),
            createBaseVNode("div", j7, [
              renderSlot(m.$slots, "footer")
            ])
          ]),
          _: 3
        })
      ])
    ]));
  }
});
var B7 = $e(O7);
var Z7 = {
  id: "GFPageDetails",
  class: "GFPageDetails",
  style: { "min-width": "0" }
};
var W7 = { class: "GFPageDetailsHead-content px-10 w-full flex flex-col bg-white rounded overflow-hidden shadow-sm" };
var q7 = { class: "head" };
var V7 = { class: "w-full flex justify-between items-center mb-4" };
var H7 = { class: "head-title" };
var U7 = { class: "flex items-center gap-1 h-8" };
var G7 = { class: "text-2xl font-bold" };
var X7 = { class: "head-toolbar" };
var Y7 = { class: "head-abstract mb-4 flex flex-col" };
var Q7 = {
  key: 0,
  class: "!m-auto p-2"
};
var J7 = { class: "GFPageDetails-slot--default flex-1" };
var e_ = defineComponent({
  name: "GFPageDetails",
  __name: "GFPageDetails",
  props: {
    icon: { default: "" },
    title: { default: "" },
    descriptions: {},
    columns: { default: 3 },
    abstract: { default: () => [] },
    tabsConfig: {},
    tabs: { default: () => [] },
    direction: { default: "horizontal" },
    useItemCollapse: { type: Boolean, default: false }
  },
  setup(e16, { expose: t10 }) {
    var f;
    const n = e16, o = ref(true), r = ref(), a = (f = n.tabsConfig) == null ? void 0 : f.defaultActive, i = ref(a ?? n.tabs[0].name), s = ref(1), l = ref(1);
    onMounted(() => {
      u(), m();
    });
    function c(h10) {
      i.value = h10;
    }
    function u() {
      var g;
      return (g = r.value) == null ? void 0 : g.children[0].children[0].clientHeight;
    }
    function d() {
      o.value = !o.value;
    }
    function m() {
      if (!(r != null && r.value)) return;
      let h10 = 1;
      const g = getComputedStyle(r == null ? void 0 : r.value).gridTemplateColumns.split(
        " "
      );
      for (let v = 1; v < g.length; v++) {
        if (Math.abs(parseInt(g[v]) - parseInt(g[v - 1])) > 2) {
          s.value = h10;
          break;
        }
        h10++;
      }
      s.value = h10, setTimeout(() => {
        p();
      }, 1);
    }
    function p() {
      var y;
      const h10 = ((y = r.value) == null ? void 0 : y.clientHeight) ?? 0, g = getComputedStyle(r == null ? void 0 : r.value).gridTemplateRows.split(
        " "
      ), v = g[0];
      l.value = g.length, r == null || r.value.style.setProperty("--expandHeight", `${h10}px`), r == null || r.value.style.setProperty("--transition-duration", "0.3s"), r == null || r.value.style.setProperty("--firstRowHeight", `${v}`);
    }
    return t10({ toggleActiveTab: c }), (h10, g) => {
      const v = resolveComponent("IconArrowTop"), y = resolveComponent("k-button");
      return openBlock(), createElementBlock("div", Z7, [
        createBaseVNode("div", W7, [
          createBaseVNode("div", q7, [
            renderSlot(h10.$slots, "extra-head", {}, () => [
              createBaseVNode("div", V7, [
                createBaseVNode("div", H7, [
                  renderSlot(h10.$slots, "head-title", {}, () => [
                    createBaseVNode("div", U7, [
                      h10.icon ? (openBlock(), createBlock(resolveDynamicComponent(h10.icon), {
                        key: 0,
                        size: "24"
                      })) : createCommentVNode("", true),
                      createBaseVNode("span", G7, toDisplayString(h10.title), 1)
                    ])
                  ])
                ]),
                createBaseVNode("div", X7, [
                  renderSlot(h10.$slots, "head-toolbar")
                ])
              ])
            ])
          ]),
          createBaseVNode("div", Y7, [
            renderSlot(h10.$slots, "head-abstract", {}, () => [
              createBaseVNode("div", {
                ref_key: "RefHeadAbstract",
                ref: r,
                class: normalizeClass(["RefHeadAbstract grid gap-4", {
                  "is-collapse": !o.value && h10.useItemCollapse,
                  "use-collapse": h10.useItemCollapse && o.value
                }]),
                style: normalizeStyle(`grid-template-columns:repeat(${h10.columns},minmax(0, 1fr))`)
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(n.abstract, (k) => (openBlock(), createBlock(unref(f1), {
                  key: k.label,
                  label: k.label,
                  value: k.value,
                  render: k.render,
                  style: normalizeStyle(`grid-column: span ${k.column}`),
                  direction: h10.direction
                }, null, 8, ["label", "value", "render", "style", "direction"]))), 128))
              ], 6),
              h10.useItemCollapse ? (openBlock(), createElementBlock("div", Q7, [
                createVNode(y, {
                  text: "",
                  onClick: d
                }, {
                  default: withCtx(() => [
                    createVNode(v, {
                      rotate: o.value ? 180 : 0
                    }, null, 8, ["rotate"]),
                    createTextVNode(" " + toDisplayString(o.value ? "" : ""), 1)
                  ]),
                  _: 1
                })
              ])) : createCommentVNode("", true)
            ])
          ])
        ]),
        createBaseVNode("div", J7, [
          renderSlot(h10.$slots, "detail", {}, () => [
            createVNode(unref(Ef), mergeProps({
              modelValue: i.value,
              "onUpdate:modelValue": g[0] || (g[0] = (k) => i.value = k)
            }, h10.tabsConfig), {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(h10.tabs, (k) => (openBlock(), createBlock(unref(Kf), mergeProps({
                  key: k.name,
                  ref_for: true
                }, k), createSlots({
                  default: withCtx(() => [
                    renderSlot(h10.$slots, k.name)
                  ]),
                  _: 2
                }, [
                  h10.$slots[`${k.name}-label`] ? {
                    name: "label",
                    fn: withCtx(() => [
                      renderSlot(h10.$slots, `${k.name}-label`)
                    ]),
                    key: "0"
                  } : void 0
                ]), 1040))), 128))
              ]),
              _: 3
            }, 16, ["modelValue"])
          ])
        ])
      ]);
    };
  }
});
var t_ = $e(e_);
var n_ = {
  class: "KNewTransfer"
};
var o_ = {
  class: "transfer-dialog-content"
};
var a_ = {
  key: 0,
  class: "my-box"
};
var r_ = {
  class: "empty-text"
};
var i_ = {
  class: "footer"
};
var s_ = defineComponent({
  name: "KNewTransfer",
  __name: "newTransfer",
  props: {
    treeTransferData: {
      default: () => []
    },
    title: {
      default: ""
    },
    defaultVal: {
      default: ""
    },
    selectList: {
      default: () => []
    },
    defaultData: {
      default: () => []
    }
  },
  setup(e16, {
    expose: t10
  }) {
    const n = e16, o = reactive({
      machineType: n.defaultVal
    }), r = ref(null), a = () => {
      o.machineType = u, setTimeout(() => {
        r.value.clearData();
      }, 0), c.value = false;
    }, i = () => {
      c.value = false;
    }, s = ref(n.defaultData), l = (h10) => {
      s.value = h10;
    }, c = ref(false);
    let u = "";
    const d = (h10) => {
      u = h10, o.machineType && s.value.length !== 0 ? c.value = true : o.machineType = h10;
    };
    watch(() => o.machineType, (h10) => {
      setTimeout(() => {
        r.value.clearQuery();
      }, 0);
      const g = n.selectList.find((v) => v.type === h10);
      g && g.fun && typeof g.fun == "function" && g.fun(u);
    });
    const m = ref(), p = () => {
      m.value && m.value.validate((h10) => h10 ? {
        arr: s.value,
        type: o.machineType
      } : (console.warn("error submit!!"), false));
    }, f = () => {
    };
    return t10({
      handleSubmit: p,
      handleSelectType: d,
      handleCancel: f
    }), (h10, g) => {
      const v = resolveComponent("IconTips"), y = resolveComponent("k-radio"), k = resolveComponent("k-popconfirm"), T = resolveComponent("k-radio-group"), w = resolveComponent("k-form-item"), _ = resolveComponent("k-form"), M = resolveComponent("k-tree-transfer"), x = resolveComponent("k-button");
      return openBlock(), createElementBlock("div", n_, [renderSlot(h10.$slots, "header", {}, () => [createBaseVNode("div", o_, [createVNode(v, {
        class: "transfer-dialog-icon"
      }), createTextVNode(" " + toDisplayString(h10.title), 1)])], true), createVNode(_, {
        ref_key: "KFormRef",
        ref: m,
        model: o,
        "labk-width": "auto",
        style: {
          "max-width": "600px"
        }
      }, {
        default: withCtx(() => [createVNode(w, {
          label: "",
          prop: "machineType",
          rules: {
            required: true,
            message: ""
          }
        }, {
          default: withCtx(() => [createVNode(T, {
            modelValue: o.machineType,
            "onUpdate:modelValue": g[1] || (g[1] = (R) => o.machineType = R)
          }, {
            default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(h10.selectList, (R, I) => (openBlock(), createBlock(k, {
              key: I,
              visible: R.type === o.machineType && c.value,
              "confirm-button-text": "Yes",
              "cancel-button-text": "No",
              icon: "IconClear",
              "icon-color": "#626AEF",
              title: ", ?",
              onConfirm: g[0] || (g[0] = (P) => a()),
              onCancel: i
            }, {
              reference: withCtx(() => [createVNode(y, {
                value: R.type,
                size: "large",
                onClick: withModifiers((P) => d(R.type), ["prevent"])
              }, {
                default: withCtx(() => [createTextVNode(toDisplayString(R.name), 1)]),
                _: 2
              }, 1032, ["value", "onClick"])]),
              _: 2
            }, 1032, ["visible"]))), 128))]),
            _: 1
          }, 8, ["modelValue"])]),
          _: 1
        })]),
        _: 1
      }, 8, ["model"]), o.machineType ? (openBlock(), createElementBlock("div", a_, [createVNode(M, mergeProps({
        ref_key: "myTreeTransfer",
        ref: r,
        data: h10.treeTransferData,
        titles: ["IP", "IP"],
        "default-data": h10.defaultData,
        label: "name",
        "expand-icon": "IconFolderOpen",
        "expand-icon-color": "#f60",
        "collapse-icon-color": "red",
        "icon-color": "green",
        "collapse-icon": "IconFolderClose",
        class: "my-box-item"
      }, h10.$attrs, {
        onChange: l
      }), {
        empty: withCtx(({
          query: R
        }) => [createBaseVNode("div", r_, [g[3] || (g[3] = createBaseVNode("div", null, "", -1)), createBaseVNode("div", null, "'" + toDisplayString(R) + "'", 1), g[4] || (g[4] = createBaseVNode("div", null, "", -1))])]),
        _: 1
      }, 16, ["data", "default-data"])])) : createCommentVNode("", true), renderSlot(h10.$slots, "footer", {}, () => [createBaseVNode("div", i_, [createVNode(x, {
        onClick: f
      }, {
        default: withCtx(() => g[5] || (g[5] = [createTextVNode("")])),
        _: 1
      }), createVNode(x, {
        type: "primary",
        main: "",
        onClick: g[2] || (g[2] = (R) => p())
      }, {
        default: withCtx(() => g[6] || (g[6] = [createTextVNode("")])),
        _: 1
      })])], true)]);
    };
  }
});
var l_ = Ta(s_, [["__scopeId", "data-v-bafdc337"]]);
var c_ = $e(l_);
var u_ = [
  d1,
  v9,
  f1,
  $9,
  N9,
  B7,
  t_,
  c_
];
var d_ = (e16) => {
  [...u1, ...u_].forEach((o) => {
    !o || !o.install || !(o != null && o.name) || e16.use(o);
  });
  const n = f_();
  for (const o in n)
    e16.component(o, n[o]);
};
function f_() {
  const e16 = "K", t10 = {};
  for (const n in es_exports)
    if (/^El[A-Z]/.test(n)) {
      const o = n.replace(/^El/, e16);
      u1.find((a) => a.name === o) || (t10[o] = es_exports[n]);
    }
  return t10;
}
var m_ = {
  name: "zh-cn",
  el: {
    breadcrumb: {
      label: ""
    },
    colorpicker: {
      confirm: "",
      clear: "",
      defaultLabel: "",
      description: " {color} Enter ",
      alphaLabel: ""
    },
    datepicker: {
      now: "",
      today: "",
      cancel: "",
      clear: "",
      confirm: "",
      dateTablePrompt: " Enter ",
      monthTablePrompt: " Enter ",
      yearTablePrompt: " Enter ",
      selectedDate: "",
      selectDate: "",
      selectTime: "",
      startDate: "",
      startTime: "",
      endDate: "",
      endTime: "",
      prevYear: "",
      nextYear: "",
      prevMonth: "",
      nextMonth: "",
      year: "",
      month1: "1 ",
      month2: "2 ",
      month3: "3 ",
      month4: "4 ",
      month5: "5 ",
      month6: "6 ",
      month7: "7 ",
      month8: "8 ",
      month9: "9 ",
      month10: "10 ",
      month11: "11 ",
      month12: "12 ",
      weeks: {
        sun: "",
        mon: "",
        tue: "",
        wed: "",
        thu: "",
        fri: "",
        sat: ""
      },
      weeksFull: {
        sun: "",
        mon: "",
        tue: "",
        wed: "",
        thu: "",
        fri: "",
        sat: ""
      },
      months: {
        jan: "",
        feb: "",
        mar: "",
        apr: "",
        may: "",
        jun: "",
        jul: "",
        aug: "",
        sep: "",
        oct: "",
        nov: "",
        dec: ""
      }
    },
    inputNumber: {
      decrease: "",
      increase: ""
    },
    select: {
      loading: "",
      noMatch: "",
      noData: "",
      placeholder: ""
    },
    dropdown: {
      toggleDropdown: ""
    },
    mention: {
      loading: ""
    },
    cascader: {
      noMatch: "",
      loading: "",
      placeholder: "",
      noData: ""
    },
    pagination: {
      goto: "",
      pagesize: "/",
      total: " {total} ",
      pageClassifier: "",
      page: "",
      prev: "",
      next: "",
      currentPage: " {pager} ",
      prevPages: " {pager} ",
      nextPages: " {pager} ",
      deprecationWarning: " el-pagination "
    },
    dialog: {
      close: ""
    },
    drawer: {
      close: ""
    },
    messagebox: {
      title: "",
      confirm: "",
      cancel: "",
      error: "!",
      close: ""
    },
    upload: {
      deleteTip: " delete ",
      delete: "",
      preview: "",
      continue: ""
    },
    slider: {
      defaultLabel: " {min}  {max}",
      defaultRangeStartLabel: "",
      defaultRangeEndLabel: ""
    },
    table: {
      emptyText: "",
      confirmFilter: "",
      resetFilter: "",
      clearFilter: "",
      sumText: ""
    },
    tour: {
      next: "",
      previous: "",
      finish: ""
    },
    tree: {
      emptyText: ""
    },
    transfer: {
      noMatch: "",
      noData: "",
      titles: [" 1", " 2"],
      filterPlaceholder: "",
      noCheckedFormat: " {total} ",
      hasCheckedFormat: " {checked}/{total} "
    },
    image: {
      error: ""
    },
    pageHeader: {
      title: ""
    },
    popconfirm: {
      confirmButtonText: "",
      cancelButtonText: ""
    },
    carousel: {
      leftArrow: "",
      rightArrow: "",
      indicator: " {index}"
    }
  }
};
var p_ = {
  name: "en",
  el: {
    breadcrumb: {
      label: "Breadcrumb"
    },
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color.",
      alphaLabel: "pick alpha value"
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    mention: {
      loading: "Loading"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};
function h_(e16, t10 = {}) {
  e16.use(installer, {
    ...t10 == null ? void 0 : t10.ElementPlusOptions,
    locale: t10.locale === "en" ? p_ : m_
  }), e16.use(index_esm_default2).use(index_esm_default3), index_esm_default3.setConfig(t10.vxeGlobalConfig ?? {});
}
var g_ = {
  advancedFilter: "",
  clearAll: "",
  addCondition: "",
  aboveCondition: "",
  anyOne: "",
  all: "",
  query: "",
  exactDate: "",
  dateRange: "",
  today: "",
  tomorrow: "",
  yesterday: "",
  thisWeek: "",
  lastWeek: "",
  thisMonth: "",
  lastMonth: "",
  withinThePastSevenDays: "",
  withinThePastThirtyDays: "30",
  equal: "",
  before: "",
  after: "",
  empty: "",
  nonEmpty: "",
  batchOperation: "",
  customDescription: "",
  cancel: "",
  confirm: "",
  filter: "",
  reset: "",
  sort: "",
  ascendingOrder: "",
  descendingOrder: "",
  clearSorting: "",
  hide: "",
  retract: "",
  uploadDragSign: "",
  uploadFile: "",
  selectFile: "",
  remove: "",
  view: "",
  customView: "",
  pleaseInput: "",
  pleaseSelect: "",
  expand: "",
  collapse: "",
  success: "",
  error: "",
  warning: "",
  noData: "",
  selectedFields: "",
  unselectedFields: "",
  restoreDefault: "",
  searchHeaderName: "",
  showLunar: "",
  next: "",
  previous: "",
  finish: "",
  searchTable: "",
  data: "",
  showAll: "",
  total: "",
  gt: "",
  lt: "",
  gte: "",
  lte: "",
  contain: "",
  notEqual: "",
  clearData: "",
  enterInputSearch: "",
  within7days: "7",
  within15days: "15",
  curMonth: "",
  curQuarter: "",
  curYear: "",
  refresh: "",
  columnHeaderController: "",
  advancedFilter_c: "",
  sizeControlTrigger: ""
};
var v_ = {
  advancedFilter: "Advanced Filter",
  clearAll: "clear all",
  addCondition: "add condition",
  aboveCondition: "above condition",
  anyOne: "Any One",
  all: "All",
  query: "query",
  exactDate: "exact date",
  dateRange: "date range",
  today: "today",
  tomorrow: "tomorrow",
  yesterday: "yesterday",
  thisWeek: "this week",
  lastWeek: "last week",
  thisMonth: "this month",
  lastMonth: "last month",
  withinThePastSevenDays: "within the past seven days",
  withinThePastThirtyDays: "Within the past thirty days",
  equal: "equal",
  before: "before",
  after: "after",
  empty: "empty",
  nonEmpty: "non empty",
  batchOperation: "Operation",
  customDescription: "custom description",
  cancel: "cancel",
  confirm: "confirm",
  filter: "filter",
  reset: "reset",
  sort: "sort",
  ascendingOrder: "ascending order",
  descendingOrder: "descending order",
  clearSorting: "clear sorting",
  hide: "hide",
  retract: "retract",
  uploadDragSign: "Click or drag the file here to upload",
  uploadFile: "upload file",
  selectFile: "select file",
  remove: "remove",
  view: "view",
  customView: "custom view",
  pleaseInput: "Please Input",
  pleaseSelect: "Please Select",
  expand: "expand",
  collapse: "collapse",
  success: "success",
  error: "error",
  warning: "warning",
  noData: "no data",
  selectedFields: "Selected",
  unselectedFields: "Unselected",
  restoreDefault: "Restore",
  searchHeaderName: "Search Header Name",
  showLunar: "show lunar",
  next: "next",
  previous: "previous",
  finish: "finish",
  searchTable: "search table data",
  total: "total",
  data: "data",
  showAll: "show all",
  gt: "gt",
  lt: "lt",
  gte: "gte",
  lte: "lte",
  contain: "contain",
  notEqual: "not equal",
  clearData: "Clear Data",
  enterInputSearch: "Press Enter to search",
  within7days: "within 7 days",
  within15days: "within 15 days",
  curMonth: "current month",
  curQuarter: "current quarter",
  curYear: "current year",
  refresh: "refresh",
  columnHeaderController: "column header controller",
  advancedFilter_c: "advanced filter",
  sizeControlTrigger: "Size Control"
};
function y_(e16, t10 = {}) {
  const n = { zh: g_, en: v_ }, o = createI18n({
    locale: (t10 == null ? void 0 : t10.locale) === "en" ? "en" : "zh",
    messages: n
  });
  e16.use(o), e16.config.globalProperties.$t = o.global.t, e16.provide("$t", o.global.t);
}
var b_ = {
  mounted(e16) {
    e16.style.cursor = "move", e16.style.position = "absolute";
    const t10 = (n) => {
      n.preventDefault(), n.stopPropagation();
      const o = n.clientX, r = n.clientY, a = e16.getBoundingClientRect(), i = o - a.left, s = r - a.top, l = e16.parentElement.getBoundingClientRect(), c = (d) => {
        let m = d.clientX - i, p = d.clientY - s;
        m < l.left && (m = l.left), p < l.top && (p = l.top), m + a.width > l.right && (m = l.right - a.width), p + a.height > l.bottom && (p = l.bottom - a.height), e16.style.left = `${m - l.left}px`, e16.style.top = `${p - l.top}px`;
      }, u = () => {
        document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
      };
      document.addEventListener("mousemove", c), document.addEventListener("mouseup", u);
    };
    e16.addEventListener("mousedown", t10), e16._handleMouseDown = t10;
  },
  beforeUnmount(e16) {
    e16.removeEventListener("mousedown", e16._handleMouseDown);
  }
};
var __ = {
  mounted(e16, t10) {
    w_(e16, t10);
  }
};
var w_ = (e16, t10) => {
  const n = document.querySelector("#_tooltip_root");
  n && n.remove(), e16._tipRoot = null, e16._tipApp = null;
  const o = "_tooltip_root", r = document.createElement("div");
  r.id = o, r.classList.add("_tipRoot");
  const { trigger: a, placement: i, content: s, showAfter: l, autoClose: c } = (t10 == null ? void 0 : t10.value) ?? {}, u = createApp(wa, {
    virtualRef: e16,
    rawContent: true,
    virtualTriggering: true,
    trigger: a ?? "hover",
    placement: i ?? "bottom",
    content: typeof t10.value == "object" ? String(s) : String(t10.value),
    showAfter: l ?? 500,
    autoClose: c ?? 1e3
  });
  e16._tipRoot = r, e16._tipApp = u, document.body.appendChild(r), u && r && e16._tipApp.mount(`#${o}`);
};
var l0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  drag: b_,
  tooltip: __
}, Symbol.toStringTag, { value: "Module" }));
function T_(e16) {
  for (const t10 in l0)
    e16.directive(`ksw_${t10}`, l0[t10]);
}
function C_(e16, t10 = {}) {
  const n = t10.styleModule, o = ["AOM", "GFAOM", "KingAutometa"];
  let r = "AOM";
  if (typeof n == "string" && o.includes(n) ? r = n : n !== void 0 && console.warn(
    `'styleModule' expected to be ${o.map((a) => `'${a}'`).join(" | ")}, but got '${n}'.`
  ), typeof document < "u") {
    const a = document == null ? void 0 : document.getElementsByTagName("body")[0];
    a == null || a.classList.add(r);
  }
  e16.provide("_styleModule", r === "AOM" ? "" : r);
}
function k_(e16) {
  return e16 && e16.__esModule && Object.prototype.hasOwnProperty.call(e16, "default") ? e16.default : e16;
}
var tm = { exports: {} };
(function(e16) {
  var t10 = function() {
    this.Diff_Timeout = 1, this.Diff_EditCost = 4, this.Match_Threshold = 0.5, this.Match_Distance = 1e3, this.Patch_DeleteThreshold = 0.5, this.Patch_Margin = 4, this.Match_MaxBits = 32;
  }, n = -1, o = 1, r = 0;
  t10.Diff = function(a, i) {
    return [a, i];
  }, t10.prototype.diff_main = function(a, i, s, l) {
    typeof l > "u" && (this.Diff_Timeout <= 0 ? l = Number.MAX_VALUE : l = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3);
    var c = l;
    if (a == null || i == null)
      throw new Error("Null input. (diff_main)");
    if (a == i)
      return a ? [new t10.Diff(r, a)] : [];
    typeof s > "u" && (s = true);
    var u = s, d = this.diff_commonPrefix(a, i), m = a.substring(0, d);
    a = a.substring(d), i = i.substring(d), d = this.diff_commonSuffix(a, i);
    var p = a.substring(a.length - d);
    a = a.substring(0, a.length - d), i = i.substring(0, i.length - d);
    var f = this.diff_compute_(a, i, u, c);
    return m && f.unshift(new t10.Diff(r, m)), p && f.push(new t10.Diff(r, p)), this.diff_cleanupMerge(f), f;
  }, t10.prototype.diff_compute_ = function(a, i, s, l) {
    var c;
    if (!a)
      return [new t10.Diff(o, i)];
    if (!i)
      return [new t10.Diff(n, a)];
    var u = a.length > i.length ? a : i, d = a.length > i.length ? i : a, m = u.indexOf(d);
    if (m != -1)
      return c = [
        new t10.Diff(o, u.substring(0, m)),
        new t10.Diff(r, d),
        new t10.Diff(
          o,
          u.substring(m + d.length)
        )
      ], a.length > i.length && (c[0][0] = c[2][0] = n), c;
    if (d.length == 1)
      return [
        new t10.Diff(n, a),
        new t10.Diff(o, i)
      ];
    var p = this.diff_halfMatch_(a, i);
    if (p) {
      var f = p[0], h10 = p[1], g = p[2], v = p[3], y = p[4], k = this.diff_main(f, g, s, l), T = this.diff_main(h10, v, s, l);
      return k.concat(
        [new t10.Diff(r, y)],
        T
      );
    }
    return s && a.length > 100 && i.length > 100 ? this.diff_lineMode_(a, i, l) : this.diff_bisect_(a, i, l);
  }, t10.prototype.diff_lineMode_ = function(a, i, s) {
    var l = this.diff_linesToChars_(a, i);
    a = l.chars1, i = l.chars2;
    var c = l.lineArray, u = this.diff_main(a, i, false, s);
    this.diff_charsToLines_(u, c), this.diff_cleanupSemantic(u), u.push(new t10.Diff(r, ""));
    for (var d = 0, m = 0, p = 0, f = "", h10 = ""; d < u.length; ) {
      switch (u[d][0]) {
        case o:
          p++, h10 += u[d][1];
          break;
        case n:
          m++, f += u[d][1];
          break;
        case r:
          if (m >= 1 && p >= 1) {
            u.splice(
              d - m - p,
              m + p
            ), d = d - m - p;
            for (var g = this.diff_main(f, h10, false, s), v = g.length - 1; v >= 0; v--)
              u.splice(d, 0, g[v]);
            d = d + g.length;
          }
          p = 0, m = 0, f = "", h10 = "";
          break;
      }
      d++;
    }
    return u.pop(), u;
  }, t10.prototype.diff_bisect_ = function(a, i, s) {
    for (var l = a.length, c = i.length, u = Math.ceil((l + c) / 2), d = u, m = 2 * u, p = new Array(m), f = new Array(m), h10 = 0; h10 < m; h10++)
      p[h10] = -1, f[h10] = -1;
    p[d + 1] = 0, f[d + 1] = 0;
    for (var g = l - c, v = g % 2 != 0, y = 0, k = 0, T = 0, w = 0, _ = 0; _ < u && !((/* @__PURE__ */ new Date()).getTime() > s); _++) {
      for (var M = -_ + y; M <= _ - k; M += 2) {
        var x = d + M, R;
        M == -_ || M != _ && p[x - 1] < p[x + 1] ? R = p[x + 1] : R = p[x - 1] + 1;
        for (var I = R - M; R < l && I < c && a.charAt(R) == i.charAt(I); )
          R++, I++;
        if (p[x] = R, R > l)
          k += 2;
        else if (I > c)
          y += 2;
        else if (v) {
          var P = d + g - M;
          if (P >= 0 && P < m && f[P] != -1) {
            var F = l - f[P];
            if (R >= F)
              return this.diff_bisectSplit_(a, i, R, I, s);
          }
        }
      }
      for (var N = -_ + T; N <= _ - w; N += 2) {
        var P = d + N, F;
        N == -_ || N != _ && f[P - 1] < f[P + 1] ? F = f[P + 1] : F = f[P - 1] + 1;
        for (var j = F - N; F < l && j < c && a.charAt(l - F - 1) == i.charAt(c - j - 1); )
          F++, j++;
        if (f[P] = F, F > l)
          w += 2;
        else if (j > c)
          T += 2;
        else if (!v) {
          var x = d + g - N;
          if (x >= 0 && x < m && p[x] != -1) {
            var R = p[x], I = d + R - x;
            if (F = l - F, R >= F)
              return this.diff_bisectSplit_(a, i, R, I, s);
          }
        }
      }
    }
    return [
      new t10.Diff(n, a),
      new t10.Diff(o, i)
    ];
  }, t10.prototype.diff_bisectSplit_ = function(a, i, s, l, c) {
    var u = a.substring(0, s), d = i.substring(0, l), m = a.substring(s), p = i.substring(l), f = this.diff_main(u, d, false, c), h10 = this.diff_main(m, p, false, c);
    return f.concat(h10);
  }, t10.prototype.diff_linesToChars_ = function(a, i) {
    var s = [], l = {};
    s[0] = "";
    function c(p) {
      for (var f = "", h10 = 0, g = -1, v = s.length; g < p.length - 1; ) {
        g = p.indexOf(`
`, h10), g == -1 && (g = p.length - 1);
        var y = p.substring(h10, g + 1);
        (l.hasOwnProperty ? l.hasOwnProperty(y) : l[y] !== void 0) ? f += String.fromCharCode(l[y]) : (v == u && (y = p.substring(h10), g = p.length), f += String.fromCharCode(v), l[y] = v, s[v++] = y), h10 = g + 1;
      }
      return f;
    }
    var u = 4e4, d = c(a);
    u = 65535;
    var m = c(i);
    return { chars1: d, chars2: m, lineArray: s };
  }, t10.prototype.diff_charsToLines_ = function(a, i) {
    for (var s = 0; s < a.length; s++) {
      for (var l = a[s][1], c = [], u = 0; u < l.length; u++)
        c[u] = i[l.charCodeAt(u)];
      a[s][1] = c.join("");
    }
  }, t10.prototype.diff_commonPrefix = function(a, i) {
    if (!a || !i || a.charAt(0) != i.charAt(0))
      return 0;
    for (var s = 0, l = Math.min(a.length, i.length), c = l, u = 0; s < c; )
      a.substring(u, c) == i.substring(u, c) ? (s = c, u = s) : l = c, c = Math.floor((l - s) / 2 + s);
    return c;
  }, t10.prototype.diff_commonSuffix = function(a, i) {
    if (!a || !i || a.charAt(a.length - 1) != i.charAt(i.length - 1))
      return 0;
    for (var s = 0, l = Math.min(a.length, i.length), c = l, u = 0; s < c; )
      a.substring(a.length - c, a.length - u) == i.substring(i.length - c, i.length - u) ? (s = c, u = s) : l = c, c = Math.floor((l - s) / 2 + s);
    return c;
  }, t10.prototype.diff_commonOverlap_ = function(a, i) {
    var s = a.length, l = i.length;
    if (s == 0 || l == 0)
      return 0;
    s > l ? a = a.substring(s - l) : s < l && (i = i.substring(0, s));
    var c = Math.min(s, l);
    if (a == i)
      return c;
    for (var u = 0, d = 1; ; ) {
      var m = a.substring(c - d), p = i.indexOf(m);
      if (p == -1)
        return u;
      d += p, (p == 0 || a.substring(c - d) == i.substring(0, d)) && (u = d, d++);
    }
  }, t10.prototype.diff_halfMatch_ = function(a, i) {
    if (this.Diff_Timeout <= 0)
      return null;
    var s = a.length > i.length ? a : i, l = a.length > i.length ? i : a;
    if (s.length < 4 || l.length * 2 < s.length)
      return null;
    var c = this;
    function u(k, T, w) {
      for (var _ = k.substring(w, w + Math.floor(k.length / 4)), M = -1, x = "", R, I, P, F; (M = T.indexOf(_, M + 1)) != -1; ) {
        var N = c.diff_commonPrefix(
          k.substring(w),
          T.substring(M)
        ), j = c.diff_commonSuffix(
          k.substring(0, w),
          T.substring(0, M)
        );
        x.length < j + N && (x = T.substring(M - j, M) + T.substring(M, M + N), R = k.substring(0, w - j), I = k.substring(w + N), P = T.substring(0, M - j), F = T.substring(M + N));
      }
      return x.length * 2 >= k.length ? [
        R,
        I,
        P,
        F,
        x
      ] : null;
    }
    var d = u(
      s,
      l,
      Math.ceil(s.length / 4)
    ), m = u(
      s,
      l,
      Math.ceil(s.length / 2)
    ), p;
    if (!d && !m)
      return null;
    m ? d ? p = d[4].length > m[4].length ? d : m : p = m : p = d;
    var f, h10, g, v;
    a.length > i.length ? (f = p[0], h10 = p[1], g = p[2], v = p[3]) : (g = p[0], v = p[1], f = p[2], h10 = p[3]);
    var y = p[4];
    return [f, h10, g, v, y];
  }, t10.prototype.diff_cleanupSemantic = function(a) {
    for (var i = false, s = [], l = 0, c = null, u = 0, d = 0, m = 0, p = 0, f = 0; u < a.length; )
      a[u][0] == r ? (s[l++] = u, d = p, m = f, p = 0, f = 0, c = a[u][1]) : (a[u][0] == o ? p += a[u][1].length : f += a[u][1].length, c && c.length <= Math.max(d, m) && c.length <= Math.max(
        p,
        f
      ) && (a.splice(
        s[l - 1],
        0,
        new t10.Diff(n, c)
      ), a[s[l - 1] + 1][0] = o, l--, l--, u = l > 0 ? s[l - 1] : -1, d = 0, m = 0, p = 0, f = 0, c = null, i = true)), u++;
    for (i && this.diff_cleanupMerge(a), this.diff_cleanupSemanticLossless(a), u = 1; u < a.length; ) {
      if (a[u - 1][0] == n && a[u][0] == o) {
        var h10 = a[u - 1][1], g = a[u][1], v = this.diff_commonOverlap_(h10, g), y = this.diff_commonOverlap_(g, h10);
        v >= y ? (v >= h10.length / 2 || v >= g.length / 2) && (a.splice(u, 0, new t10.Diff(
          r,
          g.substring(0, v)
        )), a[u - 1][1] = h10.substring(0, h10.length - v), a[u + 1][1] = g.substring(v), u++) : (y >= h10.length / 2 || y >= g.length / 2) && (a.splice(u, 0, new t10.Diff(
          r,
          h10.substring(0, y)
        )), a[u - 1][0] = o, a[u - 1][1] = g.substring(0, g.length - y), a[u + 1][0] = n, a[u + 1][1] = h10.substring(y), u++), u++;
      }
      u++;
    }
  }, t10.prototype.diff_cleanupSemanticLossless = function(a) {
    function i(y, k) {
      if (!y || !k)
        return 6;
      var T = y.charAt(y.length - 1), w = k.charAt(0), _ = T.match(t10.nonAlphaNumericRegex_), M = w.match(t10.nonAlphaNumericRegex_), x = _ && T.match(t10.whitespaceRegex_), R = M && w.match(t10.whitespaceRegex_), I = x && T.match(t10.linebreakRegex_), P = R && w.match(t10.linebreakRegex_), F = I && y.match(t10.blanklineEndRegex_), N = P && k.match(t10.blanklineStartRegex_);
      return F || N ? 5 : I || P ? 4 : _ && !x && R ? 3 : x || R ? 2 : _ || M ? 1 : 0;
    }
    for (var s = 1; s < a.length - 1; ) {
      if (a[s - 1][0] == r && a[s + 1][0] == r) {
        var l = a[s - 1][1], c = a[s][1], u = a[s + 1][1], d = this.diff_commonSuffix(l, c);
        if (d) {
          var m = c.substring(c.length - d);
          l = l.substring(0, l.length - d), c = m + c.substring(0, c.length - d), u = m + u;
        }
        for (var p = l, f = c, h10 = u, g = i(l, c) + i(c, u); c.charAt(0) === u.charAt(0); ) {
          l += c.charAt(0), c = c.substring(1) + u.charAt(0), u = u.substring(1);
          var v = i(l, c) + i(c, u);
          v >= g && (g = v, p = l, f = c, h10 = u);
        }
        a[s - 1][1] != p && (p ? a[s - 1][1] = p : (a.splice(s - 1, 1), s--), a[s][1] = f, h10 ? a[s + 1][1] = h10 : (a.splice(s + 1, 1), s--));
      }
      s++;
    }
  }, t10.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/, t10.whitespaceRegex_ = /\s/, t10.linebreakRegex_ = /[\r\n]/, t10.blanklineEndRegex_ = /\n\r?\n$/, t10.blanklineStartRegex_ = /^\r?\n\r?\n/, t10.prototype.diff_cleanupEfficiency = function(a) {
    for (var i = false, s = [], l = 0, c = null, u = 0, d = false, m = false, p = false, f = false; u < a.length; )
      a[u][0] == r ? (a[u][1].length < this.Diff_EditCost && (p || f) ? (s[l++] = u, d = p, m = f, c = a[u][1]) : (l = 0, c = null), p = f = false) : (a[u][0] == n ? f = true : p = true, c && (d && m && p && f || c.length < this.Diff_EditCost / 2 && d + m + p + f == 3) && (a.splice(
        s[l - 1],
        0,
        new t10.Diff(n, c)
      ), a[s[l - 1] + 1][0] = o, l--, c = null, d && m ? (p = f = true, l = 0) : (l--, u = l > 0 ? s[l - 1] : -1, p = f = false), i = true)), u++;
    i && this.diff_cleanupMerge(a);
  }, t10.prototype.diff_cleanupMerge = function(a) {
    a.push(new t10.Diff(r, ""));
    for (var i = 0, s = 0, l = 0, c = "", u = "", d; i < a.length; )
      switch (a[i][0]) {
        case o:
          l++, u += a[i][1], i++;
          break;
        case n:
          s++, c += a[i][1], i++;
          break;
        case r:
          s + l > 1 ? (s !== 0 && l !== 0 && (d = this.diff_commonPrefix(u, c), d !== 0 && (i - s - l > 0 && a[i - s - l - 1][0] == r ? a[i - s - l - 1][1] += u.substring(0, d) : (a.splice(0, 0, new t10.Diff(
            r,
            u.substring(0, d)
          )), i++), u = u.substring(d), c = c.substring(d)), d = this.diff_commonSuffix(u, c), d !== 0 && (a[i][1] = u.substring(u.length - d) + a[i][1], u = u.substring(0, u.length - d), c = c.substring(0, c.length - d))), i -= s + l, a.splice(i, s + l), c.length && (a.splice(
            i,
            0,
            new t10.Diff(n, c)
          ), i++), u.length && (a.splice(
            i,
            0,
            new t10.Diff(o, u)
          ), i++), i++) : i !== 0 && a[i - 1][0] == r ? (a[i - 1][1] += a[i][1], a.splice(i, 1)) : i++, l = 0, s = 0, c = "", u = "";
          break;
      }
    a[a.length - 1][1] === "" && a.pop();
    var m = false;
    for (i = 1; i < a.length - 1; )
      a[i - 1][0] == r && a[i + 1][0] == r && (a[i][1].substring(a[i][1].length - a[i - 1][1].length) == a[i - 1][1] ? (a[i][1] = a[i - 1][1] + a[i][1].substring(0, a[i][1].length - a[i - 1][1].length), a[i + 1][1] = a[i - 1][1] + a[i + 1][1], a.splice(i - 1, 1), m = true) : a[i][1].substring(0, a[i + 1][1].length) == a[i + 1][1] && (a[i - 1][1] += a[i + 1][1], a[i][1] = a[i][1].substring(a[i + 1][1].length) + a[i + 1][1], a.splice(i + 1, 1), m = true)), i++;
    m && this.diff_cleanupMerge(a);
  }, t10.prototype.diff_xIndex = function(a, i) {
    var s = 0, l = 0, c = 0, u = 0, d;
    for (d = 0; d < a.length && (a[d][0] !== o && (s += a[d][1].length), a[d][0] !== n && (l += a[d][1].length), !(s > i)); d++)
      c = s, u = l;
    return a.length != d && a[d][0] === n ? u : u + (i - c);
  }, t10.prototype.diff_prettyHtml = function(a) {
    for (var i = [], s = /&/g, l = /</g, c = />/g, u = /\n/g, d = 0; d < a.length; d++) {
      var m = a[d][0], p = a[d][1], f = p.replace(s, "&amp;").replace(l, "&lt;").replace(c, "&gt;").replace(u, "&para;<br>");
      switch (m) {
        case o:
          i[d] = '<ins style="background:#e6ffe6;">' + f + "</ins>";
          break;
        case n:
          i[d] = '<del style="background:#ffe6e6;">' + f + "</del>";
          break;
        case r:
          i[d] = "<span>" + f + "</span>";
          break;
      }
    }
    return i.join("");
  }, t10.prototype.diff_text1 = function(a) {
    for (var i = [], s = 0; s < a.length; s++)
      a[s][0] !== o && (i[s] = a[s][1]);
    return i.join("");
  }, t10.prototype.diff_text2 = function(a) {
    for (var i = [], s = 0; s < a.length; s++)
      a[s][0] !== n && (i[s] = a[s][1]);
    return i.join("");
  }, t10.prototype.diff_levenshtein = function(a) {
    for (var i = 0, s = 0, l = 0, c = 0; c < a.length; c++) {
      var u = a[c][0], d = a[c][1];
      switch (u) {
        case o:
          s += d.length;
          break;
        case n:
          l += d.length;
          break;
        case r:
          i += Math.max(s, l), s = 0, l = 0;
          break;
      }
    }
    return i += Math.max(s, l), i;
  }, t10.prototype.diff_toDelta = function(a) {
    for (var i = [], s = 0; s < a.length; s++)
      switch (a[s][0]) {
        case o:
          i[s] = "+" + encodeURI(a[s][1]);
          break;
        case n:
          i[s] = "-" + a[s][1].length;
          break;
        case r:
          i[s] = "=" + a[s][1].length;
          break;
      }
    return i.join("	").replace(/%20/g, " ");
  }, t10.prototype.diff_fromDelta = function(a, i) {
    for (var s = [], l = 0, c = 0, u = i.split(/\t/g), d = 0; d < u.length; d++) {
      var m = u[d].substring(1);
      switch (u[d].charAt(0)) {
        case "+":
          try {
            s[l++] = new t10.Diff(o, decodeURI(m));
          } catch {
            throw new Error("Illegal escape in diff_fromDelta: " + m);
          }
          break;
        case "-":
        case "=":
          var p = parseInt(m, 10);
          if (isNaN(p) || p < 0)
            throw new Error("Invalid number in diff_fromDelta: " + m);
          var f = a.substring(c, c += p);
          u[d].charAt(0) == "=" ? s[l++] = new t10.Diff(r, f) : s[l++] = new t10.Diff(n, f);
          break;
        default:
          if (u[d])
            throw new Error("Invalid diff operation in diff_fromDelta: " + u[d]);
      }
    }
    if (c != a.length)
      throw new Error("Delta length (" + c + ") does not equal source text length (" + a.length + ").");
    return s;
  }, t10.prototype.match_main = function(a, i, s) {
    if (a == null || i == null || s == null)
      throw new Error("Null input. (match_main)");
    return s = Math.max(0, Math.min(s, a.length)), a == i ? 0 : a.length ? a.substring(s, s + i.length) == i ? s : this.match_bitap_(a, i, s) : -1;
  }, t10.prototype.match_bitap_ = function(a, i, s) {
    if (i.length > this.Match_MaxBits)
      throw new Error("Pattern too long for this browser.");
    var l = this.match_alphabet_(i), c = this;
    function u(R, I) {
      var P = R / i.length, F = Math.abs(s - I);
      return c.Match_Distance ? P + F / c.Match_Distance : F ? 1 : P;
    }
    var d = this.Match_Threshold, m = a.indexOf(i, s);
    m != -1 && (d = Math.min(u(0, m), d), m = a.lastIndexOf(i, s + i.length), m != -1 && (d = Math.min(u(0, m), d)));
    var p = 1 << i.length - 1;
    m = -1;
    for (var f, h10, g = i.length + a.length, v, y = 0; y < i.length; y++) {
      for (f = 0, h10 = g; f < h10; )
        u(y, s + h10) <= d ? f = h10 : g = h10, h10 = Math.floor((g - f) / 2 + f);
      g = h10;
      var k = Math.max(1, s - h10 + 1), T = Math.min(s + h10, a.length) + i.length, w = Array(T + 2);
      w[T + 1] = (1 << y) - 1;
      for (var _ = T; _ >= k; _--) {
        var M = l[a.charAt(_ - 1)];
        if (y === 0 ? w[_] = (w[_ + 1] << 1 | 1) & M : w[_] = (w[_ + 1] << 1 | 1) & M | ((v[_ + 1] | v[_]) << 1 | 1) | v[_ + 1], w[_] & p) {
          var x = u(y, _ - 1);
          if (x <= d)
            if (d = x, m = _ - 1, m > s)
              k = Math.max(1, 2 * s - m);
            else
              break;
        }
      }
      if (u(y + 1, s) > d)
        break;
      v = w;
    }
    return m;
  }, t10.prototype.match_alphabet_ = function(a) {
    for (var i = {}, s = 0; s < a.length; s++)
      i[a.charAt(s)] = 0;
    for (var s = 0; s < a.length; s++)
      i[a.charAt(s)] |= 1 << a.length - s - 1;
    return i;
  }, t10.prototype.patch_addContext_ = function(a, i) {
    if (i.length != 0) {
      if (a.start2 === null)
        throw Error("patch not initialized");
      for (var s = i.substring(a.start2, a.start2 + a.length1), l = 0; i.indexOf(s) != i.lastIndexOf(s) && s.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin; )
        l += this.Patch_Margin, s = i.substring(
          a.start2 - l,
          a.start2 + a.length1 + l
        );
      l += this.Patch_Margin;
      var c = i.substring(a.start2 - l, a.start2);
      c && a.diffs.unshift(new t10.Diff(r, c));
      var u = i.substring(
        a.start2 + a.length1,
        a.start2 + a.length1 + l
      );
      u && a.diffs.push(new t10.Diff(r, u)), a.start1 -= c.length, a.start2 -= c.length, a.length1 += c.length + u.length, a.length2 += c.length + u.length;
    }
  }, t10.prototype.patch_make = function(a, i, s) {
    var l, c;
    if (typeof a == "string" && typeof i == "string" && typeof s > "u")
      l = /** @type {string} */
      a, c = this.diff_main(
        l,
        /** @type {string} */
        i,
        true
      ), c.length > 2 && (this.diff_cleanupSemantic(c), this.diff_cleanupEfficiency(c));
    else if (a && typeof a == "object" && typeof i > "u" && typeof s > "u")
      c = /** @type {!Array.<!diff_match_patch.Diff>} */
      a, l = this.diff_text1(c);
    else if (typeof a == "string" && i && typeof i == "object" && typeof s > "u")
      l = /** @type {string} */
      a, c = /** @type {!Array.<!diff_match_patch.Diff>} */
      i;
    else if (typeof a == "string" && typeof i == "string" && s && typeof s == "object")
      l = /** @type {string} */
      a, c = /** @type {!Array.<!diff_match_patch.Diff>} */
      s;
    else
      throw new Error("Unknown call format to patch_make.");
    if (c.length === 0)
      return [];
    for (var u = [], d = new t10.patch_obj(), m = 0, p = 0, f = 0, h10 = l, g = l, v = 0; v < c.length; v++) {
      var y = c[v][0], k = c[v][1];
      switch (!m && y !== r && (d.start1 = p, d.start2 = f), y) {
        case o:
          d.diffs[m++] = c[v], d.length2 += k.length, g = g.substring(0, f) + k + g.substring(f);
          break;
        case n:
          d.length1 += k.length, d.diffs[m++] = c[v], g = g.substring(0, f) + g.substring(f + k.length);
          break;
        case r:
          k.length <= 2 * this.Patch_Margin && m && c.length != v + 1 ? (d.diffs[m++] = c[v], d.length1 += k.length, d.length2 += k.length) : k.length >= 2 * this.Patch_Margin && m && (this.patch_addContext_(d, h10), u.push(d), d = new t10.patch_obj(), m = 0, h10 = g, p = f);
          break;
      }
      y !== o && (p += k.length), y !== n && (f += k.length);
    }
    return m && (this.patch_addContext_(d, h10), u.push(d)), u;
  }, t10.prototype.patch_deepCopy = function(a) {
    for (var i = [], s = 0; s < a.length; s++) {
      var l = a[s], c = new t10.patch_obj();
      c.diffs = [];
      for (var u = 0; u < l.diffs.length; u++)
        c.diffs[u] = new t10.Diff(l.diffs[u][0], l.diffs[u][1]);
      c.start1 = l.start1, c.start2 = l.start2, c.length1 = l.length1, c.length2 = l.length2, i[s] = c;
    }
    return i;
  }, t10.prototype.patch_apply = function(a, i) {
    if (a.length == 0)
      return [i, []];
    a = this.patch_deepCopy(a);
    var s = this.patch_addPadding(a);
    i = s + i + s, this.patch_splitMax(a);
    for (var l = 0, c = [], u = 0; u < a.length; u++) {
      var d = a[u].start2 + l, m = this.diff_text1(a[u].diffs), p, f = -1;
      if (m.length > this.Match_MaxBits ? (p = this.match_main(
        i,
        m.substring(0, this.Match_MaxBits),
        d
      ), p != -1 && (f = this.match_main(
        i,
        m.substring(m.length - this.Match_MaxBits),
        d + m.length - this.Match_MaxBits
      ), (f == -1 || p >= f) && (p = -1))) : p = this.match_main(i, m, d), p == -1)
        c[u] = false, l -= a[u].length2 - a[u].length1;
      else {
        c[u] = true, l = p - d;
        var h10;
        if (f == -1 ? h10 = i.substring(p, p + m.length) : h10 = i.substring(p, f + this.Match_MaxBits), m == h10)
          i = i.substring(0, p) + this.diff_text2(a[u].diffs) + i.substring(p + m.length);
        else {
          var g = this.diff_main(m, h10, false);
          if (m.length > this.Match_MaxBits && this.diff_levenshtein(g) / m.length > this.Patch_DeleteThreshold)
            c[u] = false;
          else {
            this.diff_cleanupSemanticLossless(g);
            for (var v = 0, y, k = 0; k < a[u].diffs.length; k++) {
              var T = a[u].diffs[k];
              T[0] !== r && (y = this.diff_xIndex(g, v)), T[0] === o ? i = i.substring(0, p + y) + T[1] + i.substring(p + y) : T[0] === n && (i = i.substring(0, p + y) + i.substring(p + this.diff_xIndex(
                g,
                v + T[1].length
              ))), T[0] !== n && (v += T[1].length);
            }
          }
        }
      }
    }
    return i = i.substring(s.length, i.length - s.length), [i, c];
  }, t10.prototype.patch_addPadding = function(a) {
    for (var i = this.Patch_Margin, s = "", l = 1; l <= i; l++)
      s += String.fromCharCode(l);
    for (var l = 0; l < a.length; l++)
      a[l].start1 += i, a[l].start2 += i;
    var c = a[0], u = c.diffs;
    if (u.length == 0 || u[0][0] != r)
      u.unshift(new t10.Diff(r, s)), c.start1 -= i, c.start2 -= i, c.length1 += i, c.length2 += i;
    else if (i > u[0][1].length) {
      var d = i - u[0][1].length;
      u[0][1] = s.substring(u[0][1].length) + u[0][1], c.start1 -= d, c.start2 -= d, c.length1 += d, c.length2 += d;
    }
    if (c = a[a.length - 1], u = c.diffs, u.length == 0 || u[u.length - 1][0] != r)
      u.push(new t10.Diff(r, s)), c.length1 += i, c.length2 += i;
    else if (i > u[u.length - 1][1].length) {
      var d = i - u[u.length - 1][1].length;
      u[u.length - 1][1] += s.substring(0, d), c.length1 += d, c.length2 += d;
    }
    return s;
  }, t10.prototype.patch_splitMax = function(a) {
    for (var i = this.Match_MaxBits, s = 0; s < a.length; s++)
      if (!(a[s].length1 <= i)) {
        var l = a[s];
        a.splice(s--, 1);
        for (var c = l.start1, u = l.start2, d = ""; l.diffs.length !== 0; ) {
          var m = new t10.patch_obj(), p = true;
          for (m.start1 = c - d.length, m.start2 = u - d.length, d !== "" && (m.length1 = m.length2 = d.length, m.diffs.push(new t10.Diff(r, d))); l.diffs.length !== 0 && m.length1 < i - this.Patch_Margin; ) {
            var f = l.diffs[0][0], h10 = l.diffs[0][1];
            f === o ? (m.length2 += h10.length, u += h10.length, m.diffs.push(l.diffs.shift()), p = false) : f === n && m.diffs.length == 1 && m.diffs[0][0] == r && h10.length > 2 * i ? (m.length1 += h10.length, c += h10.length, p = false, m.diffs.push(new t10.Diff(f, h10)), l.diffs.shift()) : (h10 = h10.substring(
              0,
              i - m.length1 - this.Patch_Margin
            ), m.length1 += h10.length, c += h10.length, f === r ? (m.length2 += h10.length, u += h10.length) : p = false, m.diffs.push(new t10.Diff(f, h10)), h10 == l.diffs[0][1] ? l.diffs.shift() : l.diffs[0][1] = l.diffs[0][1].substring(h10.length));
          }
          d = this.diff_text2(m.diffs), d = d.substring(d.length - this.Patch_Margin);
          var g = this.diff_text1(l.diffs).substring(0, this.Patch_Margin);
          g !== "" && (m.length1 += g.length, m.length2 += g.length, m.diffs.length !== 0 && m.diffs[m.diffs.length - 1][0] === r ? m.diffs[m.diffs.length - 1][1] += g : m.diffs.push(new t10.Diff(r, g))), p || a.splice(++s, 0, m);
        }
      }
  }, t10.prototype.patch_toText = function(a) {
    for (var i = [], s = 0; s < a.length; s++)
      i[s] = a[s];
    return i.join("");
  }, t10.prototype.patch_fromText = function(a) {
    var i = [];
    if (!a)
      return i;
    for (var s = a.split(`
`), l = 0, c = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; l < s.length; ) {
      var u = s[l].match(c);
      if (!u)
        throw new Error("Invalid patch string: " + s[l]);
      var d = new t10.patch_obj();
      for (i.push(d), d.start1 = parseInt(u[1], 10), u[2] === "" ? (d.start1--, d.length1 = 1) : u[2] == "0" ? d.length1 = 0 : (d.start1--, d.length1 = parseInt(u[2], 10)), d.start2 = parseInt(u[3], 10), u[4] === "" ? (d.start2--, d.length2 = 1) : u[4] == "0" ? d.length2 = 0 : (d.start2--, d.length2 = parseInt(u[4], 10)), l++; l < s.length; ) {
        var m = s[l].charAt(0);
        try {
          var p = decodeURI(s[l].substring(1));
        } catch {
          throw new Error("Illegal escape in patch_fromText: " + p);
        }
        if (m == "-")
          d.diffs.push(new t10.Diff(n, p));
        else if (m == "+")
          d.diffs.push(new t10.Diff(o, p));
        else if (m == " ")
          d.diffs.push(new t10.Diff(r, p));
        else {
          if (m == "@")
            break;
          if (m !== "") throw new Error('Invalid patch mode "' + m + '" in: ' + p);
        }
        l++;
      }
    }
    return i;
  }, t10.patch_obj = function() {
    this.diffs = [], this.start1 = null, this.start2 = null, this.length1 = 0, this.length2 = 0;
  }, t10.patch_obj.prototype.toString = function() {
    var a, i;
    this.length1 === 0 ? a = this.start1 + ",0" : this.length1 == 1 ? a = this.start1 + 1 : a = this.start1 + 1 + "," + this.length1, this.length2 === 0 ? i = this.start2 + ",0" : this.length2 == 1 ? i = this.start2 + 1 : i = this.start2 + 1 + "," + this.length2;
    for (var s = ["@@ -" + a + " +" + i + ` @@
`], l, c = 0; c < this.diffs.length; c++) {
      switch (this.diffs[c][0]) {
        case o:
          l = "+";
          break;
        case n:
          l = "-";
          break;
        case r:
          l = " ";
          break;
      }
      s[c + 1] = l + encodeURI(this.diffs[c][1]) + `
`;
    }
    return s.join("").replace(/%20/g, " ");
  }, e16.exports = t10, e16.exports.diff_match_patch = t10, e16.exports.DIFF_DELETE = n, e16.exports.DIFF_INSERT = o, e16.exports.DIFF_EQUAL = r;
})(tm);
var S_ = tm.exports;
var N_ = k_(S_);
function M_(e16) {
  e16.provide("__elementObserver", new ng()), e16.provide("_emitter", new tg()), e16.provide("__diffMatchPatch", new N_());
}
var P_ = (e16, t10) => {
  d_(e16), C_(e16, t10), h_(e16, t10), y_(e16, t10), T_(e16), M_(e16);
};
export {
  t_ as GFPageDetails,
  ElAffix as KAffix,
  ElAlert as KAlert,
  ElAnchor as KAnchor,
  ElAnchorLink as KAnchorLink,
  ElAside as KAside,
  ElAutoResizer as KAutoResizer,
  ElAutocomplete as KAutocomplete,
  ElAvatar as KAvatar,
  ElBacktop as KBacktop,
  D8 as KBadge,
  ElBreadcrumb as KBreadcrumb,
  ElBreadcrumbItem as KBreadcrumbItem,
  Lt as KButton,
  Eb as KButtonContainer,
  ElButtonGroup as KButtonGroup,
  q8 as KCalendar,
  ElCard as KCard,
  ElCarousel as KCarousel,
  ElCarouselItem as KCarouselItem,
  Lf as KCascader,
  ElCascaderPanel as KCascaderPanel,
  ElCheckTag as KCheckTag,
  fa as KCheckbox,
  ElCheckboxButton as KCheckboxButton,
  If as KCheckboxGroup,
  ElCol as KCol,
  p8 as KCollapse,
  h8 as KCollapseItem,
  ElCollapseTransition as KCollapseTransition,
  ElCollection as KCollection,
  ElCollectionItem as KCollectionItem,
  ElColorPicker as KColorPicker,
  o1 as KColumnGroup,
  ElConfigProvider as KConfigProvider,
  ElContainer as KContainer,
  ElCountdown as KCountdown,
  Ff as KDatePicker,
  ElDescriptions as KDescriptions,
  ElDescriptionsItem as KDescriptionsItem,
  $9 as KDetails,
  f1 as KDetailsItem,
  Zf as KDialog,
  ElDivider as KDivider,
  i8 as KDrawer,
  ar as KDropdown,
  rr as KDropdownItem,
  ElDropdownMenu as KDropdownMenu,
  g3 as KEmpty,
  Wf as KFilter,
  xb as KFilterForm,
  ElFooter as KFooter,
  r1 as KForm,
  i1 as KFormItem,
  ElHeader as KHeader,
  ElIcon as KIcon,
  Wb as KIconPopver,
  ElImage as KImage,
  ElImageViewer as KImageViewer,
  ElInfiniteScroll as KInfiniteScroll,
  ro as KInput,
  Y6 as KInputNumber,
  ElLink as KLink,
  ElLoading as KLoading,
  vLoading as KLoadingDirective,
  Loading as KLoadingService,
  ElMain as KMain,
  ElMention as KMention,
  ElMenu as KMenu,
  ElMenuItem as KMenuItem,
  ElMenuItemGroup as KMenuItemGroup,
  B7 as KMenuView,
  Bf as KMessage,
  ElMessageBox as KMessageBox,
  c_ as KNewTransfer,
  ElNotification as KNotification,
  Of as KOperate,
  vo as KOption,
  my as KOptionGroup,
  ElOverlay as KOverlay,
  v9 as KPageDetails,
  ElPageHeader as KPageHeader,
  N9 as KPageTableView,
  d1 as KPageViewBus,
  zf as KPagination,
  Xy as KPopconfirm,
  Io as KPopover,
  ElPopoverDirective as KPopoverDirective,
  ElPopper as KPopper,
  ElPopperArrow as KPopperArrow,
  ElPopperContent as KPopperContent,
  ElPopperTrigger as KPopperTrigger,
  ElProgress as KProgress,
  Mf as KRadio,
  ElRadioButton as KRadioButton,
  $f as KRadioGroup,
  ElRate as KRate,
  f3 as KResult,
  ElRow as KRow,
  jb as KScriptInput,
  ElScrollbar as KScrollbar,
  Go as KSelect,
  ElSelectV2 as KSelectV2,
  ElSkeleton as KSkeleton,
  ElSkeletonItem as KSkeletonItem,
  ElSlider as KSlider,
  Pb as KSliderButton,
  ElSpace as KSpace,
  ElStatistic as KStatistic,
  f8 as KStep,
  d8 as KSteps,
  ElSubMenu as KSubMenu,
  ay as KSwitch,
  Kf as KTabPane,
  Hr as KTable,
  Ur as KTableColumn,
  Ef as KTabs,
  Hy as KTag,
  ElText as KText,
  ElTimePicker as KTimePicker,
  ElTimeSelect as KTimeSelect,
  E8 as KTimeline,
  K8 as KTimelineItem,
  wa as KTooltip,
  ElTour as KTour,
  ElTourStep as KTourStep,
  jf as KTransfer,
  el as KTree,
  Nb as KTreeSelect,
  cb as KTreeTable,
  kb as KTreeTransfer,
  Ny as KUpload,
  x8 as KView,
  ElWatermark as KWatermark,
  P_ as default
};
/*! Bundled license information:

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.6
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)

@intlify/shared/dist/shared.mjs:
  (*!
    * shared v9.14.2
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    *)

@intlify/message-compiler/dist/message-compiler.esm-browser.js:
  (*!
    * message-compiler v9.14.2
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    *)

@intlify/core-base/dist/core-base.mjs:
  (*!
    * core-base v9.14.2
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    *)

vue-i18n/dist/vue-i18n.mjs:
  (*!
    * vue-i18n v9.14.2
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    *)

@ksware/ksw-ux/kingsware-ui/index.js:
  (*!
   * GSAP 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
  (*!
   * CSSPlugin 3.12.5
   * https://gsap.com
   *
   * Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
  (**
  * @vue/shared v3.5.6
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*!
   * OverlayScrollbars
   * Version: 2.10.0
   *
   * Copyright (c) Rene Haas | KingSora.
   * https://github.com/KingSora
   *
   * Released under the MIT license.
   *)
*/
//# sourceMappingURL=@ksware_ksw-ux.js.map
