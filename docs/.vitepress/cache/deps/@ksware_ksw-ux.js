import {
  ElAffix,
  ElAlert,
  ElAnchor,
  ElAnchorLink,
  ElAside,
  ElAutoResizer,
  ElAutocomplete,
  ElAvatar,
  ElBacktop,
  ElBadge,
  ElBreadcrumb,
  ElBreadcrumbItem,
  ElButton,
  ElButtonGroup,
  ElCalendar,
  ElCard,
  ElCarousel,
  ElCarouselItem,
  ElCascader,
  ElCascaderPanel,
  ElCheckTag,
  ElCheckbox,
  ElCheckboxButton,
  ElCheckboxGroup,
  ElCol,
  ElCollapse,
  ElCollapseItem,
  ElCollapseTransition,
  ElCollection,
  ElCollectionItem,
  ElColorPicker,
  ElConfigProvider,
  ElContainer,
  ElCountdown,
  ElDatePicker,
  ElDescriptions,
  ElDescriptionsItem,
  ElDialog,
  ElDivider,
  ElDrawer,
  ElDropdown,
  ElDropdownItem,
  ElDropdownMenu,
  ElEmpty,
  ElFooter,
  ElForm,
  ElFormItem,
  ElHeader,
  ElIcon,
  ElImage,
  ElImageViewer,
  ElInfiniteScroll,
  ElInput,
  ElInputNumber,
  ElLink,
  ElLoading,
  ElMain,
  ElMention,
  ElMenu,
  ElMenuItem,
  ElMenuItemGroup,
  ElMessage,
  ElMessageBox,
  ElNotification,
  ElOption,
  ElOptionGroup,
  ElOverlay,
  ElPageHeader,
  ElPagination,
  ElPopconfirm,
  ElPopover,
  ElPopoverDirective,
  ElPopper,
  ElPopperArrow,
  ElPopperContent,
  ElPopperTrigger,
  ElProgress,
  ElRadio,
  ElRadioButton,
  ElRadioGroup,
  ElRate,
  ElRow,
  ElScrollbar,
  ElSelect,
  ElSelectV2,
  ElSkeleton,
  ElSkeletonItem,
  ElSlider,
  ElSpace,
  ElStatistic,
  ElStep,
  ElSteps,
  ElSubMenu,
  ElSwitch,
  ElTabPane,
  ElTabs,
  ElTag,
  ElText,
  ElTimePicker,
  ElTimeSelect,
  ElTimeline,
  ElTimelineItem,
  ElTooltip,
  ElTour,
  ElTourStep,
  ElTransfer,
  ElTree,
  ElTreeSelect,
  ElUpload,
  ElWatermark,
  Loading,
  es_exports,
  installer,
  vLoading
} from "./chunk-WMQUZUT2.js";
import "./chunk-O3YQPVDG.js";
import {
  Comment,
  Fragment,
  Teleport,
  Text,
  TransitionGroup,
  computed,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createStaticVNode,
  createTextVNode,
  createVNode,
  defineComponent,
  effectScope,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isRef,
  isVNode,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onActivated,
  onBeforeMount,
  onBeforeUnmount,
  onDeactivated,
  onMounted,
  onUnmounted,
  openBlock,
  provide,
  reactive,
  ref,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  shallowRef,
  toDisplayString,
  toRefs,
  unref,
  useSlots,
  vShow,
  watch,
  watchPostEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-SSSTV3QS.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/xe-utils/setupDefaults.js
var require_setupDefaults = __commonJS({
  "node_modules/xe-utils/setupDefaults.js"(exports2, module2) {
    "use strict";
    var setupDefaults = {
      cookies: {
        path: "/"
      },
      treeOptions: {
        parentKey: "parentId",
        key: "id",
        children: "children"
      },
      parseDateFormat: "yyyy-MM-dd HH:mm:ss",
      firstDayOfWeek: 1
    };
    module2.exports = setupDefaults;
  }
});

// node_modules/xe-utils/arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/xe-utils/arrayEach.js"(exports2, module2) {
    function arrayEach(list, iterate, context) {
      if (list) {
        if (list.forEach) {
          list.forEach(iterate, context);
        } else {
          for (var index2 = 0, len = list.length; index2 < len; index2++) {
            iterate.call(context, list[index2], index2, list);
          }
        }
      }
    }
    module2.exports = arrayEach;
  }
});

// node_modules/xe-utils/staticObjectToString.js
var require_staticObjectToString = __commonJS({
  "node_modules/xe-utils/staticObjectToString.js"(exports2, module2) {
    var objectToString2 = Object.prototype.toString;
    module2.exports = objectToString2;
  }
});

// node_modules/xe-utils/helperCreateInInObjectString.js
var require_helperCreateInInObjectString = __commonJS({
  "node_modules/xe-utils/helperCreateInInObjectString.js"(exports2, module2) {
    var objectToString2 = require_staticObjectToString();
    function helperCreateInInObjectString(type) {
      return function(obj) {
        return "[object " + type + "]" === objectToString2.call(obj);
      };
    }
    module2.exports = helperCreateInInObjectString;
  }
});

// node_modules/xe-utils/isArray.js
var require_isArray = __commonJS({
  "node_modules/xe-utils/isArray.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isArray2 = Array.isArray || helperCreateInInObjectString("Array");
    module2.exports = isArray2;
  }
});

// node_modules/xe-utils/hasOwnProp.js
var require_hasOwnProp = __commonJS({
  "node_modules/xe-utils/hasOwnProp.js"(exports2, module2) {
    function hasOwnProp(obj, key) {
      return obj && obj.hasOwnProperty ? obj.hasOwnProperty(key) : false;
    }
    module2.exports = hasOwnProp;
  }
});

// node_modules/xe-utils/objectEach.js
var require_objectEach = __commonJS({
  "node_modules/xe-utils/objectEach.js"(exports2, module2) {
    var hasOwnProp = require_hasOwnProp();
    function objectEach(obj, iterate, context) {
      if (obj) {
        for (var key in obj) {
          if (hasOwnProp(obj, key)) {
            iterate.call(context, obj[key], key, obj);
          }
        }
      }
    }
    module2.exports = objectEach;
  }
});

// node_modules/xe-utils/each.js
var require_each = __commonJS({
  "node_modules/xe-utils/each.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var arrayEach = require_arrayEach();
    var objectEach = require_objectEach();
    function each(obj, iterate, context) {
      if (obj) {
        return (isArray2(obj) ? arrayEach : objectEach)(obj, iterate, context);
      }
      return obj;
    }
    module2.exports = each;
  }
});

// node_modules/xe-utils/helperCreateInTypeof.js
var require_helperCreateInTypeof = __commonJS({
  "node_modules/xe-utils/helperCreateInTypeof.js"(exports2, module2) {
    function helperCreateInTypeof(type) {
      return function(obj) {
        return typeof obj === type;
      };
    }
    module2.exports = helperCreateInTypeof;
  }
});

// node_modules/xe-utils/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/xe-utils/isFunction.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isFunction2 = helperCreateInTypeof("function");
    module2.exports = isFunction2;
  }
});

// node_modules/xe-utils/helperCreateGetObjects.js
var require_helperCreateGetObjects = __commonJS({
  "node_modules/xe-utils/helperCreateGetObjects.js"(exports2, module2) {
    var each = require_each();
    function helperCreateGetObjects(name, getIndex) {
      var proMethod = Object[name];
      return function(obj) {
        var result = [];
        if (obj) {
          if (proMethod) {
            return proMethod(obj);
          }
          each(obj, getIndex > 1 ? function(key) {
            result.push(["" + key, obj[key]]);
          } : function() {
            result.push(arguments[getIndex]);
          });
        }
        return result;
      };
    }
    module2.exports = helperCreateGetObjects;
  }
});

// node_modules/xe-utils/keys.js
var require_keys = __commonJS({
  "node_modules/xe-utils/keys.js"(exports2, module2) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var keys = helperCreateGetObjects("keys", 1);
    module2.exports = keys;
  }
});

// node_modules/xe-utils/clone.js
var require_clone = __commonJS({
  "node_modules/xe-utils/clone.js"(exports2, module2) {
    var objectToString2 = require_staticObjectToString();
    var objectEach = require_objectEach();
    var arrayEach = require_arrayEach();
    function getCativeCtor(val, args) {
      var Ctor = val.__proto__.constructor;
      return args ? new Ctor(args) : new Ctor();
    }
    function handleValueClone(item, isDeep) {
      return isDeep ? copyValue(item, isDeep) : item;
    }
    function copyValue(val, isDeep) {
      if (val) {
        switch (objectToString2.call(val)) {
          case "[object Object]": {
            var restObj = Object.create(Object.getPrototypeOf(val));
            objectEach(val, function(item, key) {
              restObj[key] = handleValueClone(item, isDeep);
            });
            return restObj;
          }
          case "[object Date]":
          case "[object RegExp]": {
            return getCativeCtor(val, val.valueOf());
          }
          case "[object Array]":
          case "[object Arguments]": {
            var restArr = [];
            arrayEach(val, function(item) {
              restArr.push(handleValueClone(item, isDeep));
            });
            return restArr;
          }
          case "[object Set]": {
            var restSet = getCativeCtor(val);
            restSet.forEach(function(item) {
              restSet.add(handleValueClone(item, isDeep));
            });
            return restSet;
          }
          case "[object Map]": {
            var restMap = getCativeCtor(val);
            restMap.forEach(function(item, key) {
              restMap.set(key, handleValueClone(item, isDeep));
            });
            return restMap;
          }
        }
      }
      return val;
    }
    function clone2(obj, deep) {
      if (obj) {
        return copyValue(obj, deep);
      }
      return obj;
    }
    module2.exports = clone2;
  }
});

// node_modules/xe-utils/assign.js
var require_assign = __commonJS({
  "node_modules/xe-utils/assign.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var keys = require_keys();
    var isArray2 = require_isArray();
    var clone2 = require_clone();
    var objectAssignFns = Object.assign;
    function handleAssign(destination, args, isClone) {
      var len = args.length;
      for (var source, index2 = 1; index2 < len; index2++) {
        source = args[index2];
        arrayEach(keys(args[index2]), isClone ? function(key) {
          destination[key] = clone2(source[key], isClone);
        } : function(key) {
          destination[key] = source[key];
        });
      }
      return destination;
    }
    var assign3 = function(target) {
      if (target) {
        var args = arguments;
        if (target === true) {
          if (args.length > 1) {
            target = isArray2(target[1]) ? [] : {};
            return handleAssign(target, args, true);
          }
        } else {
          return objectAssignFns ? objectAssignFns.apply(Object, args) : handleAssign(target, args);
        }
      }
      return target;
    };
    module2.exports = assign3;
  }
});

// node_modules/xe-utils/ctor.js
var require_ctor = __commonJS({
  "node_modules/xe-utils/ctor.js"(exports2, module2) {
    "use strict";
    var setupDefaults = require_setupDefaults();
    var arrayEach = require_arrayEach();
    var each = require_each();
    var isFunction2 = require_isFunction();
    var assign3 = require_assign();
    var XEUtils156 = function() {
    };
    function mixin() {
      arrayEach(arguments, function(methods) {
        each(methods, function(fn2, name) {
          XEUtils156[name] = isFunction2(fn2) ? function() {
            var result = fn2.apply(XEUtils156.$context, arguments);
            XEUtils156.$context = null;
            return result;
          } : fn2;
        });
      });
    }
    function setup3(options) {
      return assign3(setupDefaults, options);
    }
    XEUtils156.VERSION = "3.5.32";
    XEUtils156.mixin = mixin;
    XEUtils156.setup = setup3;
    module2.exports = XEUtils156;
  }
});

// node_modules/xe-utils/lastArrayEach.js
var require_lastArrayEach = __commonJS({
  "node_modules/xe-utils/lastArrayEach.js"(exports2, module2) {
    function lastArrayEach(obj, iterate, context) {
      for (var len = obj.length - 1; len >= 0; len--) {
        iterate.call(context, obj[len], len, obj);
      }
    }
    module2.exports = lastArrayEach;
  }
});

// node_modules/xe-utils/lastObjectEach.js
var require_lastObjectEach = __commonJS({
  "node_modules/xe-utils/lastObjectEach.js"(exports2, module2) {
    var lastArrayEach = require_lastArrayEach();
    var keys = require_keys();
    function lastObjectEach(obj, iterate, context) {
      lastArrayEach(keys(obj), function(key) {
        iterate.call(context, obj[key], key, obj);
      });
    }
    module2.exports = lastObjectEach;
  }
});

// node_modules/xe-utils/isNull.js
var require_isNull = __commonJS({
  "node_modules/xe-utils/isNull.js"(exports2, module2) {
    function isNull(obj) {
      return obj === null;
    }
    module2.exports = isNull;
  }
});

// node_modules/xe-utils/property.js
var require_property = __commonJS({
  "node_modules/xe-utils/property.js"(exports2, module2) {
    var isNull = require_isNull();
    function property(name, defs) {
      return function(obj) {
        return isNull(obj) ? defs : obj[name];
      };
    }
    module2.exports = property;
  }
});

// node_modules/xe-utils/objectMap.js
var require_objectMap = __commonJS({
  "node_modules/xe-utils/objectMap.js"(exports2, module2) {
    var each = require_each();
    var isFunction2 = require_isFunction();
    var property = require_property();
    function objectMap(obj, iterate, context) {
      var result = {};
      if (obj) {
        if (iterate) {
          if (!isFunction2(iterate)) {
            iterate = property(iterate);
          }
          each(obj, function(val, index2) {
            result[index2] = iterate.call(context, val, index2, obj);
          });
        } else {
          return obj;
        }
      }
      return result;
    }
    module2.exports = objectMap;
  }
});

// node_modules/xe-utils/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/xe-utils/isPlainObject.js"(exports2, module2) {
    function isPlainObject2(obj) {
      return obj ? obj.constructor === Object : false;
    }
    module2.exports = isPlainObject2;
  }
});

// node_modules/xe-utils/merge.js
var require_merge = __commonJS({
  "node_modules/xe-utils/merge.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isPlainObject2 = require_isPlainObject();
    var each = require_each();
    function handleMerge(target, source) {
      if (isPlainObject2(target) && isPlainObject2(source) || isArray2(target) && isArray2(source)) {
        each(source, function(obj, key) {
          target[key] = handleMerge(target[key], obj);
        });
        return target;
      }
      return source;
    }
    var merge = function(target) {
      if (!target) {
        target = {};
      }
      var args = arguments;
      var len = args.length;
      for (var source, index2 = 1; index2 < len; index2++) {
        source = args[index2];
        if (source) {
          handleMerge(target, source);
        }
      }
      return target;
    };
    module2.exports = merge;
  }
});

// node_modules/xe-utils/map.js
var require_map = __commonJS({
  "node_modules/xe-utils/map.js"(exports2, module2) {
    var each = require_each();
    function map(obj, iterate, context) {
      var result = [];
      if (obj && arguments.length > 1) {
        if (obj.map) {
          return obj.map(iterate, context);
        } else {
          each(obj, function() {
            result.push(iterate.apply(context, arguments));
          });
        }
      }
      return result;
    }
    module2.exports = map;
  }
});

// node_modules/xe-utils/helperCreateIterateHandle.js
var require_helperCreateIterateHandle = __commonJS({
  "node_modules/xe-utils/helperCreateIterateHandle.js"(exports2, module2) {
    var hasOwnProp = require_hasOwnProp();
    var isArray2 = require_isArray();
    function helperCreateIterateHandle(prop, useArray, restIndex, matchValue, defaultValue) {
      return function(obj, iterate, context) {
        if (obj && iterate) {
          if (prop && obj[prop]) {
            return obj[prop](iterate, context);
          } else {
            if (useArray && isArray2(obj)) {
              for (var index2 = 0, len = obj.length; index2 < len; index2++) {
                if (!!iterate.call(context, obj[index2], index2, obj) === matchValue) {
                  return [true, false, index2, obj[index2]][restIndex];
                }
              }
            } else {
              for (var key in obj) {
                if (hasOwnProp(obj, key)) {
                  if (!!iterate.call(context, obj[key], key, obj) === matchValue) {
                    return [true, false, key, obj[key]][restIndex];
                  }
                }
              }
            }
          }
        }
        return defaultValue;
      };
    }
    module2.exports = helperCreateIterateHandle;
  }
});

// node_modules/xe-utils/some.js
var require_some = __commonJS({
  "node_modules/xe-utils/some.js"(exports2, module2) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var some = helperCreateIterateHandle("some", 1, 0, true, false);
    module2.exports = some;
  }
});

// node_modules/xe-utils/every.js
var require_every = __commonJS({
  "node_modules/xe-utils/every.js"(exports2, module2) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var every = helperCreateIterateHandle("every", 1, 1, false, true);
    module2.exports = every;
  }
});

// node_modules/xe-utils/includes.js
var require_includes = __commonJS({
  "node_modules/xe-utils/includes.js"(exports2, module2) {
    var hasOwnProp = require_hasOwnProp();
    function includes(obj, val) {
      if (obj) {
        if (obj.includes) {
          return obj.includes(val);
        }
        for (var key in obj) {
          if (hasOwnProp(obj, key)) {
            if (val === obj[key]) {
              return true;
            }
          }
        }
      }
      return false;
    }
    module2.exports = includes;
  }
});

// node_modules/xe-utils/includeArrays.js
var require_includeArrays = __commonJS({
  "node_modules/xe-utils/includeArrays.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var includes = require_includes();
    function includeArrays(array1, array2) {
      var len;
      var index2 = 0;
      if (isArray2(array1) && isArray2(array2)) {
        for (len = array2.length; index2 < len; index2++) {
          if (!includes(array1, array2[index2])) {
            return false;
          }
        }
        return true;
      }
      return includes(array1, array2);
    }
    module2.exports = includeArrays;
  }
});

// node_modules/xe-utils/uniq.js
var require_uniq = __commonJS({
  "node_modules/xe-utils/uniq.js"(exports2, module2) {
    var each = require_each();
    var includes = require_includes();
    var isFunction2 = require_isFunction();
    var property = require_property();
    function uniq(array, iterate, context) {
      var result = [];
      if (iterate) {
        if (!isFunction2(iterate)) {
          iterate = property(iterate);
        }
        var val, valMap = {};
        each(array, function(item, key) {
          val = iterate.call(context, item, key, array);
          if (!valMap[val]) {
            valMap[val] = 1;
            result.push(item);
          }
        });
      } else {
        each(array, function(value) {
          if (!includes(result, value)) {
            result.push(value);
          }
        });
      }
      return result;
    }
    module2.exports = uniq;
  }
});

// node_modules/xe-utils/toArray.js
var require_toArray = __commonJS({
  "node_modules/xe-utils/toArray.js"(exports2, module2) {
    var map = require_map();
    function toArray2(list) {
      return map(list, function(item) {
        return item;
      });
    }
    module2.exports = toArray2;
  }
});

// node_modules/xe-utils/union.js
var require_union = __commonJS({
  "node_modules/xe-utils/union.js"(exports2, module2) {
    var uniq = require_uniq();
    var toArray2 = require_toArray();
    function union() {
      var args = arguments;
      var result = [];
      var index2 = 0;
      var len = args.length;
      for (; index2 < len; index2++) {
        result = result.concat(toArray2(args[index2]));
      }
      return uniq(result);
    }
    module2.exports = union;
  }
});

// node_modules/xe-utils/staticStrUndefined.js
var require_staticStrUndefined = __commonJS({
  "node_modules/xe-utils/staticStrUndefined.js"(exports2, module2) {
    var staticStrUndefined = "undefined";
    module2.exports = staticStrUndefined;
  }
});

// node_modules/xe-utils/isUndefined.js
var require_isUndefined = __commonJS({
  "node_modules/xe-utils/isUndefined.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isUndefined = helperCreateInTypeof(staticStrUndefined);
    module2.exports = isUndefined;
  }
});

// node_modules/xe-utils/eqNull.js
var require_eqNull = __commonJS({
  "node_modules/xe-utils/eqNull.js"(exports2, module2) {
    var isNull = require_isNull();
    var isUndefined = require_isUndefined();
    function eqNull(obj) {
      return isNull(obj) || isUndefined(obj);
    }
    module2.exports = eqNull;
  }
});

// node_modules/xe-utils/staticHGKeyRE.js
var require_staticHGKeyRE = __commonJS({
  "node_modules/xe-utils/staticHGKeyRE.js"(exports2, module2) {
    var staticHGKeyRE = /(.+)?\[(\d+)\]$/;
    module2.exports = staticHGKeyRE;
  }
});

// node_modules/xe-utils/helperGetHGSKeys.js
var require_helperGetHGSKeys = __commonJS({
  "node_modules/xe-utils/helperGetHGSKeys.js"(exports2, module2) {
    function helperGetHGSKeys(property) {
      return property ? property.splice && property.join ? property : ("" + property).replace(/(\[\d+\])\.?/g, "$1.").replace(/\.$/, "").split(".") : [];
    }
    module2.exports = helperGetHGSKeys;
  }
});

// node_modules/xe-utils/get.js
var require_get = __commonJS({
  "node_modules/xe-utils/get.js"(exports2, module2) {
    var staticHGKeyRE = require_staticHGKeyRE();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    var isUndefined = require_isUndefined();
    var eqNull = require_eqNull();
    function get(obj, property, defaultValue) {
      if (eqNull(obj)) {
        return defaultValue;
      }
      var result = getValueByPath(obj, property);
      return isUndefined(result) ? defaultValue : result;
    }
    function getDeepProps(obj, key) {
      var matchs = key ? key.match(staticHGKeyRE) : "";
      return matchs ? matchs[1] ? obj[matchs[1]] ? obj[matchs[1]][matchs[2]] : void 0 : obj[matchs[2]] : obj[key];
    }
    function getValueByPath(obj, property) {
      if (obj) {
        var rest, props, len;
        var index2 = 0;
        if (obj[property] || hasOwnProp(obj, property)) {
          return obj[property];
        } else {
          props = helperGetHGSKeys(property);
          len = props.length;
          if (len) {
            for (rest = obj; index2 < len; index2++) {
              rest = getDeepProps(rest, props[index2]);
              if (eqNull(rest)) {
                if (index2 === len - 1) {
                  return rest;
                }
                return;
              }
            }
          }
          return rest;
        }
      }
    }
    module2.exports = get;
  }
});

// node_modules/xe-utils/orderBy.js
var require_orderBy = __commonJS({
  "node_modules/xe-utils/orderBy.js"(exports2, module2) {
    var arrayEach = require_arrayEach();
    var toArray2 = require_toArray();
    var map = require_map();
    var isArray2 = require_isArray();
    var isFunction2 = require_isFunction();
    var isPlainObject2 = require_isPlainObject();
    var isUndefined = require_isUndefined();
    var isNull = require_isNull();
    var eqNull = require_eqNull();
    var get = require_get();
    var property = require_property();
    var ORDER_PROP_ASC = "asc";
    var ORDER_PROP_DESC = "desc";
    function handleSort(v12, v22) {
      if (isUndefined(v12)) {
        return 1;
      }
      if (isNull(v12)) {
        return isUndefined(v22) ? -1 : 1;
      }
      return v12 && v12.localeCompare ? v12.localeCompare(v22) : v12 > v22 ? 1 : -1;
    }
    function buildMultiOrders(name, confs, compares) {
      return function(item1, item2) {
        var v12 = item1[name];
        var v22 = item2[name];
        if (v12 === v22) {
          return compares ? compares(item1, item2) : 0;
        }
        return confs.order === ORDER_PROP_DESC ? handleSort(v22, v12) : handleSort(v12, v22);
      };
    }
    function getSortConfs(arr, list, fieldConfs, context) {
      var sortConfs = [];
      fieldConfs = isArray2(fieldConfs) ? fieldConfs : [fieldConfs];
      arrayEach(fieldConfs, function(handle, index2) {
        if (handle) {
          var field = handle;
          var order;
          if (isArray2(handle)) {
            field = handle[0];
            order = handle[1];
          } else if (isPlainObject2(handle)) {
            field = handle.field;
            order = handle.order;
          }
          sortConfs.push({
            field,
            order: order || ORDER_PROP_ASC
          });
          arrayEach(list, isFunction2(field) ? function(item, key) {
            item[index2] = field.call(context, item.data, key, arr);
          } : function(item) {
            item[index2] = field ? get(item.data, field) : item.data;
          });
        }
      });
      return sortConfs;
    }
    function orderBy(arr, fieldConfs, context) {
      if (arr) {
        if (eqNull(fieldConfs)) {
          return toArray2(arr).sort(handleSort);
        }
        var compares;
        var list = map(arr, function(item) {
          return { data: item };
        });
        var sortConfs = getSortConfs(arr, list, fieldConfs, context);
        var len = sortConfs.length - 1;
        while (len >= 0) {
          compares = buildMultiOrders(len, sortConfs[len], compares);
          len--;
        }
        if (compares) {
          list = list.sort(compares);
        }
        return map(list, property("data"));
      }
      return [];
    }
    module2.exports = orderBy;
  }
});

// node_modules/xe-utils/sortBy.js
var require_sortBy = __commonJS({
  "node_modules/xe-utils/sortBy.js"(exports2, module2) {
    var orderBy = require_orderBy();
    var sortBy = orderBy;
    module2.exports = sortBy;
  }
});

// node_modules/xe-utils/random.js
var require_random = __commonJS({
  "node_modules/xe-utils/random.js"(exports2, module2) {
    function random(minVal, maxVal) {
      return minVal >= maxVal ? minVal : (minVal = minVal >> 0) + Math.round(Math.random() * ((maxVal || 9) - minVal));
    }
    module2.exports = random;
  }
});

// node_modules/xe-utils/values.js
var require_values = __commonJS({
  "node_modules/xe-utils/values.js"(exports2, module2) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var values = helperCreateGetObjects("values", 0);
    module2.exports = values;
  }
});

// node_modules/xe-utils/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/xe-utils/shuffle.js"(exports2, module2) {
    var random = require_random();
    var values = require_values();
    function shuffle(array) {
      var index2;
      var result = [];
      var list = values(array);
      var len = list.length - 1;
      for (; len >= 0; len--) {
        index2 = len > 0 ? random(0, len) : 0;
        result.push(list[index2]);
        list.splice(index2, 1);
      }
      return result;
    }
    module2.exports = shuffle;
  }
});

// node_modules/xe-utils/sample.js
var require_sample = __commonJS({
  "node_modules/xe-utils/sample.js"(exports2, module2) {
    var shuffle = require_shuffle();
    function sample(array, number2) {
      var result = shuffle(array);
      if (arguments.length <= 1) {
        return result[0];
      }
      if (number2 < result.length) {
        result.length = number2 || 0;
      }
      return result;
    }
    module2.exports = sample;
  }
});

// node_modules/xe-utils/helperCreateToNumber.js
var require_helperCreateToNumber = __commonJS({
  "node_modules/xe-utils/helperCreateToNumber.js"(exports2, module2) {
    function helperCreateToNumber(handle) {
      return function(str) {
        if (str) {
          var num = handle(str && str.replace ? str.replace(/,/g, "") : str);
          if (!isNaN(num)) {
            return num;
          }
        }
        return 0;
      };
    }
    module2.exports = helperCreateToNumber;
  }
});

// node_modules/xe-utils/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/xe-utils/toNumber.js"(exports2, module2) {
    var helperCreateToNumber = require_helperCreateToNumber();
    var toNumber = helperCreateToNumber(parseFloat);
    module2.exports = toNumber;
  }
});

// node_modules/xe-utils/slice.js
var require_slice = __commonJS({
  "node_modules/xe-utils/slice.js"(exports2, module2) {
    var toNumber = require_toNumber();
    function slice(array, startIndex, endIndex) {
      var result = [];
      var argsSize = arguments.length;
      if (array) {
        startIndex = argsSize >= 2 ? toNumber(startIndex) : 0;
        endIndex = argsSize >= 3 ? toNumber(endIndex) : array.length;
        if (array.slice) {
          return array.slice(startIndex, endIndex);
        }
        for (; startIndex < endIndex; startIndex++) {
          result.push(array[startIndex]);
        }
      }
      return result;
    }
    module2.exports = slice;
  }
});

// node_modules/xe-utils/filter.js
var require_filter = __commonJS({
  "node_modules/xe-utils/filter.js"(exports2, module2) {
    var each = require_each();
    function filter(obj, iterate, context) {
      var result = [];
      if (obj && iterate) {
        if (obj.filter) {
          return obj.filter(iterate, context);
        }
        each(obj, function(val, key) {
          if (iterate.call(context, val, key, obj)) {
            result.push(val);
          }
        });
      }
      return result;
    }
    module2.exports = filter;
  }
});

// node_modules/xe-utils/findKey.js
var require_findKey = __commonJS({
  "node_modules/xe-utils/findKey.js"(exports2, module2) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var findKey = helperCreateIterateHandle("", 0, 2, true);
    module2.exports = findKey;
  }
});

// node_modules/xe-utils/find.js
var require_find = __commonJS({
  "node_modules/xe-utils/find.js"(exports2, module2) {
    var helperCreateIterateHandle = require_helperCreateIterateHandle();
    var find2 = helperCreateIterateHandle("find", 1, 3, true);
    module2.exports = find2;
  }
});

// node_modules/xe-utils/findLast.js
var require_findLast = __commonJS({
  "node_modules/xe-utils/findLast.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var values = require_values();
    function findLast(obj, iterate, context) {
      if (obj) {
        if (!isArray2(obj)) {
          obj = values(obj);
        }
        for (var len = obj.length - 1; len >= 0; len--) {
          if (iterate.call(context, obj[len], len, obj)) {
            return obj[len];
          }
        }
      }
    }
    module2.exports = findLast;
  }
});

// node_modules/xe-utils/reduce.js
var require_reduce = __commonJS({
  "node_modules/xe-utils/reduce.js"(exports2, module2) {
    var keys = require_keys();
    function reduce(array, callback, initialValue) {
      if (array) {
        var len, reduceMethod;
        var index2 = 0;
        var context = null;
        var previous = initialValue;
        var isInitialVal = arguments.length > 2;
        var keyList = keys(array);
        if (array.length && array.reduce) {
          reduceMethod = function() {
            return callback.apply(context, arguments);
          };
          if (isInitialVal) {
            return array.reduce(reduceMethod, previous);
          }
          return array.reduce(reduceMethod);
        }
        if (isInitialVal) {
          index2 = 1;
          previous = array[keyList[0]];
        }
        for (len = keyList.length; index2 < len; index2++) {
          previous = callback.call(context, previous, array[keyList[index2]], index2, array);
        }
        return previous;
      }
    }
    module2.exports = reduce;
  }
});

// node_modules/xe-utils/copyWithin.js
var require_copyWithin = __commonJS({
  "node_modules/xe-utils/copyWithin.js"(exports2, module2) {
    var isArray2 = require_isArray();
    function copyWithin(array, target, start, end) {
      if (isArray2(array) && array.copyWithin) {
        return array.copyWithin(target, start, end);
      }
      var replaceIndex, replaceArray;
      var targetIndex = target >> 0;
      var startIndex = start >> 0;
      var len = array.length;
      var endIndex = arguments.length > 3 ? end >> 0 : len;
      if (targetIndex < len) {
        targetIndex = targetIndex >= 0 ? targetIndex : len + targetIndex;
        if (targetIndex >= 0) {
          startIndex = startIndex >= 0 ? startIndex : len + startIndex;
          endIndex = endIndex >= 0 ? endIndex : len + endIndex;
          if (startIndex < endIndex) {
            for (replaceIndex = 0, replaceArray = array.slice(startIndex, endIndex); targetIndex < len; targetIndex++) {
              if (replaceArray.length <= replaceIndex) {
                break;
              }
              array[targetIndex] = replaceArray[replaceIndex++];
            }
          }
        }
      }
      return array;
    }
    module2.exports = copyWithin;
  }
});

// node_modules/xe-utils/chunk.js
var require_chunk = __commonJS({
  "node_modules/xe-utils/chunk.js"(exports2, module2) {
    var isArray2 = require_isArray();
    function chunk(array, size) {
      var index2;
      var result = [];
      var arrLen = size >> 0 || 1;
      if (isArray2(array)) {
        if (arrLen >= 0 && array.length > arrLen) {
          index2 = 0;
          while (index2 < array.length) {
            result.push(array.slice(index2, index2 + arrLen));
            index2 += arrLen;
          }
        } else {
          result = array.length ? [array] : array;
        }
      }
      return result;
    }
    module2.exports = chunk;
  }
});

// node_modules/xe-utils/pluck.js
var require_pluck = __commonJS({
  "node_modules/xe-utils/pluck.js"(exports2, module2) {
    var map = require_map();
    var property = require_property();
    function pluck(obj, key) {
      return map(obj, property(key));
    }
    module2.exports = pluck;
  }
});

// node_modules/xe-utils/helperCreateMinMax.js
var require_helperCreateMinMax = __commonJS({
  "node_modules/xe-utils/helperCreateMinMax.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var eqNull = require_eqNull();
    var get = require_get();
    var arrayEach = require_arrayEach();
    function helperCreateMinMax(handle) {
      return function(arr, iterate) {
        if (arr && arr.length) {
          var rest, itemIndex;
          arrayEach(arr, function(itemVal, index2) {
            if (iterate) {
              itemVal = isFunction2(iterate) ? iterate(itemVal, index2, arr) : get(itemVal, iterate);
            }
            if (!eqNull(itemVal) && (eqNull(rest) || handle(rest, itemVal))) {
              itemIndex = index2;
              rest = itemVal;
            }
          });
          return arr[itemIndex];
        }
        return rest;
      };
    }
    module2.exports = helperCreateMinMax;
  }
});

// node_modules/xe-utils/max.js
var require_max = __commonJS({
  "node_modules/xe-utils/max.js"(exports2, module2) {
    var helperCreateMinMax = require_helperCreateMinMax();
    var max = helperCreateMinMax(function(rest, itemVal) {
      return rest < itemVal;
    });
    module2.exports = max;
  }
});

// node_modules/xe-utils/unzip.js
var require_unzip = __commonJS({
  "node_modules/xe-utils/unzip.js"(exports2, module2) {
    var pluck = require_pluck();
    var max = require_max();
    function unzip(arrays) {
      var index2, maxItem, len;
      var result = [];
      if (arrays && arrays.length) {
        index2 = 0;
        maxItem = max(arrays, function(item) {
          return item ? item.length : 0;
        });
        for (len = maxItem ? maxItem.length : 0; index2 < len; index2++) {
          result.push(pluck(arrays, index2));
        }
      }
      return result;
    }
    module2.exports = unzip;
  }
});

// node_modules/xe-utils/zip.js
var require_zip = __commonJS({
  "node_modules/xe-utils/zip.js"(exports2, module2) {
    var unzip = require_unzip();
    function zip() {
      return unzip(arguments);
    }
    module2.exports = zip;
  }
});

// node_modules/xe-utils/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/xe-utils/zipObject.js"(exports2, module2) {
    var values = require_values();
    var each = require_each();
    function zipObject(props, arr) {
      var result = {};
      arr = arr || [];
      each(values(props), function(val, key) {
        result[val] = arr[key];
      });
      return result;
    }
    module2.exports = zipObject;
  }
});

// node_modules/xe-utils/flatten.js
var require_flatten = __commonJS({
  "node_modules/xe-utils/flatten.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var arrayEach = require_arrayEach();
    function flattenDeep(array, deep) {
      var result = [];
      arrayEach(array, function(vals) {
        result = result.concat(isArray2(vals) ? deep ? flattenDeep(vals, deep) : vals : [vals]);
      });
      return result;
    }
    function flatten(array, deep) {
      if (isArray2(array)) {
        return flattenDeep(array, deep);
      }
      return [];
    }
    module2.exports = flatten;
  }
});

// node_modules/xe-utils/invoke.js
var require_invoke = __commonJS({
  "node_modules/xe-utils/invoke.js"(exports2, module2) {
    var map = require_map();
    var isArray2 = require_isArray();
    function deepGetObj(obj, path) {
      var index2 = 0;
      var len = path.length;
      while (obj && index2 < len) {
        obj = obj[path[index2++]];
      }
      return len && obj ? obj : 0;
    }
    function invoke(list, path) {
      var func;
      var args = arguments;
      var params = [];
      var paths = [];
      var index2 = 2;
      var len = args.length;
      for (; index2 < len; index2++) {
        params.push(args[index2]);
      }
      if (isArray2(path)) {
        len = path.length - 1;
        for (index2 = 0; index2 < len; index2++) {
          paths.push(path[index2]);
        }
        path = path[len];
      }
      return map(list, function(context) {
        if (paths.length) {
          context = deepGetObj(context, paths);
        }
        func = context[path] || path;
        if (func && func.apply) {
          return func.apply(context, params);
        }
      });
    }
    module2.exports = invoke;
  }
});

// node_modules/xe-utils/helperDeleteProperty.js
var require_helperDeleteProperty = __commonJS({
  "node_modules/xe-utils/helperDeleteProperty.js"(exports2, module2) {
    function helperDeleteProperty(obj, property) {
      try {
        delete obj[property];
      } catch (e16) {
        obj[property] = void 0;
      }
    }
    module2.exports = helperDeleteProperty;
  }
});

// node_modules/xe-utils/lastEach.js
var require_lastEach = __commonJS({
  "node_modules/xe-utils/lastEach.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var lastArrayEach = require_lastArrayEach();
    var lastObjectEach = require_lastObjectEach();
    function lastEach(obj, iterate, context) {
      if (obj) {
        return (isArray2(obj) ? lastArrayEach : lastObjectEach)(obj, iterate, context);
      }
      return obj;
    }
    module2.exports = lastEach;
  }
});

// node_modules/xe-utils/isObject.js
var require_isObject = __commonJS({
  "node_modules/xe-utils/isObject.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isObject3 = helperCreateInTypeof("object");
    module2.exports = isObject3;
  }
});

// node_modules/xe-utils/clear.js
var require_clear = __commonJS({
  "node_modules/xe-utils/clear.js"(exports2, module2) {
    var helperDeleteProperty = require_helperDeleteProperty();
    var isPlainObject2 = require_isPlainObject();
    var isObject3 = require_isObject();
    var isArray2 = require_isArray();
    var isNull = require_isNull();
    var assign3 = require_assign();
    var objectEach = require_objectEach();
    function clear(obj, defs, assigns) {
      if (obj) {
        var len;
        var isDefs = arguments.length > 1 && (isNull(defs) || !isObject3(defs));
        var extds = isDefs ? assigns : defs;
        if (isPlainObject2(obj)) {
          objectEach(obj, isDefs ? function(val, key) {
            obj[key] = defs;
          } : function(val, key) {
            helperDeleteProperty(obj, key);
          });
          if (extds) {
            assign3(obj, extds);
          }
        } else if (isArray2(obj)) {
          if (isDefs) {
            len = obj.length;
            while (len > 0) {
              len--;
              obj[len] = defs;
            }
          } else {
            obj.length = 0;
          }
          if (extds) {
            obj.push.apply(obj, extds);
          }
        }
      }
      return obj;
    }
    module2.exports = clear;
  }
});

// node_modules/xe-utils/remove.js
var require_remove = __commonJS({
  "node_modules/xe-utils/remove.js"(exports2, module2) {
    var helperDeleteProperty = require_helperDeleteProperty();
    var isFunction2 = require_isFunction();
    var isArray2 = require_isArray();
    var each = require_each();
    var arrayEach = require_arrayEach();
    var lastEach = require_lastEach();
    var clear = require_clear();
    var eqNull = require_eqNull();
    function pluckProperty(name) {
      return function(obj, key) {
        return key === name;
      };
    }
    function remove(obj, iterate, context) {
      if (obj) {
        if (!eqNull(iterate)) {
          var removeKeys = [];
          var rest = [];
          if (!isFunction2(iterate)) {
            iterate = pluckProperty(iterate);
          }
          each(obj, function(item, index2, rest2) {
            if (iterate.call(context, item, index2, rest2)) {
              removeKeys.push(index2);
            }
          });
          if (isArray2(obj)) {
            lastEach(removeKeys, function(item, key) {
              rest.push(obj[item]);
              obj.splice(item, 1);
            });
          } else {
            rest = {};
            arrayEach(removeKeys, function(key) {
              rest[key] = obj[key];
              helperDeleteProperty(obj, key);
            });
          }
          return rest;
        }
        return clear(obj);
      }
      return obj;
    }
    module2.exports = remove;
  }
});

// node_modules/xe-utils/toArrayTree.js
var require_toArrayTree = __commonJS({
  "node_modules/xe-utils/toArrayTree.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var map = require_map();
    var orderBy = require_orderBy();
    var clone2 = require_clone();
    var eqNull = require_eqNull();
    var each = require_each();
    var remove = require_remove();
    var assign3 = require_assign();
    function strictTree(array, optChildren) {
      each(array, function(item) {
        if (item[optChildren] && !item[optChildren].length) {
          remove(item, optChildren);
        }
      });
    }
    function toArrayTree(array, options) {
      var opts = assign3({}, setupDefaults.treeOptions, options);
      var optStrict = opts.strict;
      var optKey = opts.key;
      var optParentKey = opts.parentKey;
      var optChildren = opts.children;
      var optMapChildren = opts.mapChildren;
      var optSortKey = opts.sortKey;
      var optReverse = opts.reverse;
      var optData = opts.data;
      var result = [];
      var treeMap = {};
      var idsMap = {};
      var id2, treeData, parentId;
      if (optSortKey) {
        array = orderBy(clone2(array), optSortKey);
        if (optReverse) {
          array = array.reverse();
        }
      }
      each(array, function(item) {
        id2 = item[optKey];
        idsMap[id2] = true;
      });
      each(array, function(item) {
        id2 = item[optKey];
        if (optData) {
          treeData = {};
          treeData[optData] = item;
        } else {
          treeData = item;
        }
        parentId = item[optParentKey];
        treeMap[id2] = treeMap[id2] || [];
        treeData[optKey] = id2;
        treeData[optParentKey] = parentId;
        if (id2 === parentId) {
          parentId = null;
          console.log("Fix infinite Loop.", item);
        }
        treeMap[parentId] = treeMap[parentId] || [];
        treeMap[parentId].push(treeData);
        treeData[optChildren] = treeMap[id2];
        if (optMapChildren) {
          treeData[optMapChildren] = treeMap[id2];
        }
        if (!optStrict || optStrict && eqNull(parentId)) {
          if (!idsMap[parentId]) {
            result.push(treeData);
          }
        }
      });
      if (optStrict) {
        strictTree(array, optChildren);
      }
      return result;
    }
    module2.exports = toArrayTree;
  }
});

// node_modules/xe-utils/toTreeArray.js
var require_toTreeArray = __commonJS({
  "node_modules/xe-utils/toTreeArray.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var each = require_each();
    var assign3 = require_assign();
    function unTreeList(result, array, opts) {
      var optChildren = opts.children;
      var optData = opts.data;
      var optClear = opts.clear;
      each(array, function(item) {
        var children = item[optChildren];
        if (optData) {
          item = item[optData];
        }
        result.push(item);
        if (children && children.length) {
          unTreeList(result, children, opts);
        }
        if (optClear) {
          delete item[optChildren];
        }
      });
      return result;
    }
    function toTreeArray(array, options) {
      return unTreeList([], array, assign3({}, setupDefaults.treeOptions, options));
    }
    module2.exports = toTreeArray;
  }
});

// node_modules/xe-utils/helperCreateTreeFunc.js
var require_helperCreateTreeFunc = __commonJS({
  "node_modules/xe-utils/helperCreateTreeFunc.js"(exports2, module2) {
    function helperCreateTreeFunc(handle) {
      return function(obj, iterate, options, context) {
        var opts = options || {};
        var optChildren = opts.children || "children";
        return handle(null, obj, iterate, context, [], [], optChildren, opts);
      };
    }
    module2.exports = helperCreateTreeFunc;
  }
});

// node_modules/xe-utils/findTree.js
var require_findTree = __commonJS({
  "node_modules/xe-utils/findTree.js"(exports2, module2) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    function findTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      if (obj) {
        var item, index2, len, paths, nodes, match;
        for (index2 = 0, len = obj.length; index2 < len; index2++) {
          item = obj[index2];
          paths = path.concat(["" + index2]);
          nodes = node.concat([item]);
          if (iterate.call(context, item, index2, obj, paths, parent, nodes)) {
            return { index: index2, item, path: paths, items: obj, parent, nodes };
          }
          if (parseChildren && item) {
            match = findTreeItem(item, item[parseChildren], iterate, context, paths.concat([parseChildren]), nodes, parseChildren, opts);
            if (match) {
              return match;
            }
          }
        }
      }
    }
    var findTree = helperCreateTreeFunc(findTreeItem);
    module2.exports = findTree;
  }
});

// node_modules/xe-utils/eachTree.js
var require_eachTree = __commonJS({
  "node_modules/xe-utils/eachTree.js"(exports2, module2) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var each = require_each();
    function eachTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes;
      each(obj, function(item, index2) {
        paths = path.concat(["" + index2]);
        nodes = node.concat([item]);
        iterate.call(context, item, index2, obj, paths, parent, nodes);
        if (item && parseChildren) {
          paths.push(parseChildren);
          eachTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        }
      });
    }
    var eachTree = helperCreateTreeFunc(eachTreeItem);
    module2.exports = eachTree;
  }
});

// node_modules/xe-utils/mapTree.js
var require_mapTree = __commonJS({
  "node_modules/xe-utils/mapTree.js"(exports2, module2) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var map = require_map();
    function mapTreeItem(parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes, rest;
      var mapChildren = opts.mapChildren || parseChildren;
      return map(obj, function(item, index2) {
        paths = path.concat(["" + index2]);
        nodes = node.concat([item]);
        rest = iterate.call(context, item, index2, obj, paths, parent, nodes);
        if (rest && item && parseChildren && item[parseChildren]) {
          rest[mapChildren] = mapTreeItem(item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
        }
        return rest;
      });
    }
    var mapTree = helperCreateTreeFunc(mapTreeItem);
    module2.exports = mapTree;
  }
});

// node_modules/xe-utils/filterTree.js
var require_filterTree = __commonJS({
  "node_modules/xe-utils/filterTree.js"(exports2, module2) {
    var eachTree = require_eachTree();
    function filterTree(obj, iterate, options, context) {
      var result = [];
      if (obj && iterate) {
        eachTree(obj, function(item, index2, items, path, parent, nodes) {
          if (iterate.call(context, item, index2, items, path, parent, nodes)) {
            result.push(item);
          }
        }, options);
      }
      return result;
    }
    module2.exports = filterTree;
  }
});

// node_modules/xe-utils/searchTree.js
var require_searchTree = __commonJS({
  "node_modules/xe-utils/searchTree.js"(exports2, module2) {
    var helperCreateTreeFunc = require_helperCreateTreeFunc();
    var arrayEach = require_arrayEach();
    var assign3 = require_assign();
    function searchTreeItem(matchParent, parent, obj, iterate, context, path, node, parseChildren, opts) {
      var paths, nodes, rest, isMatch, hasChild;
      var rests = [];
      var hasOriginal = opts.original;
      var sourceData = opts.data;
      var mapChildren = opts.mapChildren || parseChildren;
      var isEvery = opts.isEvery;
      arrayEach(obj, function(item, index2) {
        paths = path.concat(["" + index2]);
        nodes = node.concat([item]);
        isMatch = matchParent && !isEvery || iterate.call(context, item, index2, obj, paths, parent, nodes);
        hasChild = parseChildren && item[parseChildren];
        if (isMatch || hasChild) {
          if (hasOriginal) {
            rest = item;
          } else {
            rest = assign3({}, item);
            if (sourceData) {
              rest[sourceData] = item;
            }
          }
          rest[mapChildren] = searchTreeItem(isMatch, item, item[parseChildren], iterate, context, paths, nodes, parseChildren, opts);
          if (isMatch || rest[mapChildren].length) {
            rests.push(rest);
          }
        } else if (isMatch) {
          rests.push(rest);
        }
      });
      return rests;
    }
    var searchTree = helperCreateTreeFunc(function(parent, obj, iterate, context, path, nodes, parseChildren, opts) {
      return searchTreeItem(0, parent, obj, iterate, context, path, nodes, parseChildren, opts);
    });
    module2.exports = searchTree;
  }
});

// node_modules/xe-utils/arrayIndexOf.js
var require_arrayIndexOf = __commonJS({
  "node_modules/xe-utils/arrayIndexOf.js"(exports2, module2) {
    function arrayIndexOf(list, val) {
      if (list.indexOf) {
        return list.indexOf(val);
      }
      for (var index2 = 0, len = list.length; index2 < len; index2++) {
        if (val === list[index2]) {
          return index2;
        }
      }
    }
    module2.exports = arrayIndexOf;
  }
});

// node_modules/xe-utils/arrayLastIndexOf.js
var require_arrayLastIndexOf = __commonJS({
  "node_modules/xe-utils/arrayLastIndexOf.js"(exports2, module2) {
    function arrayLastIndexOf(list, val) {
      if (list.lastIndexOf) {
        return list.lastIndexOf(val);
      }
      for (var len = list.length - 1; len >= 0; len--) {
        if (val === list[len]) {
          return len;
        }
      }
      return -1;
    }
    module2.exports = arrayLastIndexOf;
  }
});

// node_modules/xe-utils/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/xe-utils/isNumber.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isNumber2 = helperCreateInTypeof("number");
    module2.exports = isNumber2;
  }
});

// node_modules/xe-utils/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/xe-utils/isNaN.js"(exports2, module2) {
    var isNumber2 = require_isNumber();
    function isNumberNaN(obj) {
      return isNumber2(obj) && isNaN(obj);
    }
    module2.exports = isNumberNaN;
  }
});

// node_modules/xe-utils/isString.js
var require_isString = __commonJS({
  "node_modules/xe-utils/isString.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isString3 = helperCreateInTypeof("string");
    module2.exports = isString3;
  }
});

// node_modules/xe-utils/isDate.js
var require_isDate = __commonJS({
  "node_modules/xe-utils/isDate.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isDate2 = helperCreateInInObjectString("Date");
    module2.exports = isDate2;
  }
});

// node_modules/xe-utils/staticParseInt.js
var require_staticParseInt = __commonJS({
  "node_modules/xe-utils/staticParseInt.js"(exports2, module2) {
    var staticParseInt = parseInt;
    module2.exports = staticParseInt;
  }
});

// node_modules/xe-utils/helperGetUTCDateTime.js
var require_helperGetUTCDateTime = __commonJS({
  "node_modules/xe-utils/helperGetUTCDateTime.js"(exports2, module2) {
    function helperGetUTCDateTime(resMaps) {
      return Date.UTC(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
    }
    module2.exports = helperGetUTCDateTime;
  }
});

// node_modules/xe-utils/helperGetDateTime.js
var require_helperGetDateTime = __commonJS({
  "node_modules/xe-utils/helperGetDateTime.js"(exports2, module2) {
    function helperGetDateTime(date) {
      return date.getTime();
    }
    module2.exports = helperGetDateTime;
  }
});

// node_modules/xe-utils/toStringDate.js
var require_toStringDate = __commonJS({
  "node_modules/xe-utils/toStringDate.js"(exports2, module2) {
    var staticParseInt = require_staticParseInt();
    var helperGetUTCDateTime = require_helperGetUTCDateTime();
    var helperGetDateTime = require_helperGetDateTime();
    var isString3 = require_isString();
    var isDate2 = require_isDate();
    function getParseRule(txt) {
      return "(\\d{" + txt + "})";
    }
    function toParseMs(num) {
      if (num < 10) {
        return num * 100;
      } else if (num < 100) {
        return num * 10;
      }
      return num;
    }
    function toParseNum(num) {
      return isNaN(num) ? num : staticParseInt(num);
    }
    var d22 = getParseRule(2);
    var d1or2 = getParseRule("1,2");
    var d1or7 = getParseRule("1,7");
    var d3or4 = getParseRule("3,4");
    var place = ".{1}";
    var d1Or2RE = place + d1or2;
    var dzZ = "(([zZ])|([-+]\\d{2}:?\\d{2}))";
    var defaulParseStrs = [d3or4, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, d1Or2RE, place + d1or7, dzZ];
    var defaulParseREs = [];
    for (len = defaulParseStrs.length - 1; len >= 0; len--) {
      rule = "";
      for (i = 0; i < len + 1; i++) {
        rule += defaulParseStrs[i];
      }
      defaulParseREs.push(new RegExp("^" + rule + "$"));
    }
    var rule;
    var i;
    var len;
    function parseDefaultRules(str) {
      var matchRest, resMaps = {};
      for (var i10 = 0, dfrLen = defaulParseREs.length; i10 < dfrLen; i10++) {
        matchRest = str.match(defaulParseREs[i10]);
        if (matchRest) {
          resMaps.y = matchRest[1];
          resMaps.M = matchRest[2];
          resMaps.d = matchRest[3];
          resMaps.H = matchRest[4];
          resMaps.m = matchRest[5];
          resMaps.s = matchRest[6];
          resMaps.S = matchRest[7];
          resMaps.Z = matchRest[8];
          break;
        }
      }
      return resMaps;
    }
    var customParseStrs = [
      ["yyyy", d3or4],
      ["yy", d22],
      ["MM", d22],
      ["M", d1or2],
      ["dd", d22],
      ["d", d1or2],
      ["HH", d22],
      ["H", d1or2],
      ["mm", d22],
      ["m", d1or2],
      ["ss", d22],
      ["s", d1or2],
      ["SSS", getParseRule(3)],
      ["S", d1or7],
      ["Z", dzZ]
    ];
    var parseRuleMaps = {};
    var parseRuleKeys = ["\\[([^\\]]+)\\]"];
    for (i = 0; i < customParseStrs.length; i++) {
      itemRule = customParseStrs[i];
      parseRuleMaps[itemRule[0]] = itemRule[1] + "?";
      parseRuleKeys.push(itemRule[0]);
    }
    var itemRule;
    var i;
    var customParseRes = new RegExp(parseRuleKeys.join("|"), "g");
    var cacheFormatMaps = {};
    function parseCustomRules(str, format4) {
      var cacheItem = cacheFormatMaps[format4];
      if (!cacheItem) {
        var posIndexs = [];
        var re = format4.replace(/([$(){}*+.?\\^|])/g, "\\$1").replace(customParseRes, function(text, val) {
          var firstChar = text.charAt(0);
          if (firstChar === "[") {
            return val;
          }
          posIndexs.push(firstChar);
          return parseRuleMaps[text];
        });
        cacheItem = cacheFormatMaps[format4] = {
          _i: posIndexs,
          _r: new RegExp(re)
        };
      }
      var resMaps = {};
      var matchRest = str.match(cacheItem._r);
      if (matchRest) {
        var _i2 = cacheItem._i;
        for (var i10 = 1, len2 = matchRest.length; i10 < len2; i10++) {
          resMaps[_i2[i10 - 1]] = matchRest[i10];
        }
        return resMaps;
      }
      return resMaps;
    }
    function parseTimeZone(resMaps) {
      if (/^[zZ]/.test(resMaps.Z)) {
        return new Date(helperGetUTCDateTime(resMaps));
      } else {
        var matchRest = resMaps.Z.match(/([-+])(\d{2}):?(\d{2})/);
        if (matchRest) {
          return new Date(helperGetUTCDateTime(resMaps) - (matchRest[1] === "-" ? -1 : 1) * staticParseInt(matchRest[2]) * 36e5 + staticParseInt(matchRest[3]) * 6e4);
        }
      }
      return /* @__PURE__ */ new Date("");
    }
    function toStringDate(str, format4) {
      if (str) {
        var isDType = isDate2(str);
        if (isDType || !format4 && /^[0-9]{11,15}$/.test(str)) {
          return new Date(isDType ? helperGetDateTime(str) : staticParseInt(str));
        }
        if (isString3(str)) {
          var resMaps = format4 ? parseCustomRules(str, format4) : parseDefaultRules(str);
          if (resMaps.y) {
            if (resMaps.M) {
              resMaps.M = toParseNum(resMaps.M) - 1;
            }
            if (resMaps.S) {
              resMaps.S = toParseMs(toParseNum(resMaps.S.substring(0, 3)));
            }
            if (resMaps.Z) {
              return parseTimeZone(resMaps);
            } else {
              return new Date(resMaps.y, resMaps.M || 0, resMaps.d || 1, resMaps.H || 0, resMaps.m || 0, resMaps.s || 0, resMaps.S || 0);
            }
          }
        }
      }
      return /* @__PURE__ */ new Date("");
    }
    module2.exports = toStringDate;
  }
});

// node_modules/xe-utils/helperNewDate.js
var require_helperNewDate = __commonJS({
  "node_modules/xe-utils/helperNewDate.js"(exports2, module2) {
    function helperNewDate() {
      return /* @__PURE__ */ new Date();
    }
    module2.exports = helperNewDate;
  }
});

// node_modules/xe-utils/isLeapYear.js
var require_isLeapYear = __commonJS({
  "node_modules/xe-utils/isLeapYear.js"(exports2, module2) {
    var isDate2 = require_isDate();
    var toStringDate = require_toStringDate();
    var helperNewDate = require_helperNewDate();
    function isLeapYear(date) {
      var year;
      var currentDate = date ? toStringDate(date) : helperNewDate();
      if (isDate2(currentDate)) {
        year = currentDate.getFullYear();
        return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      }
      return false;
    }
    module2.exports = isLeapYear;
  }
});

// node_modules/xe-utils/forOf.js
var require_forOf = __commonJS({
  "node_modules/xe-utils/forOf.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var hasOwnProp = require_hasOwnProp();
    function forOf(obj, iterate, context) {
      if (obj) {
        if (isArray2(obj)) {
          for (var index2 = 0, len = obj.length; index2 < len; index2++) {
            if (iterate.call(context, obj[index2], index2, obj) === false) {
              break;
            }
          }
        } else {
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (iterate.call(context, obj[key], key, obj) === false) {
                break;
              }
            }
          }
        }
      }
    }
    module2.exports = forOf;
  }
});

// node_modules/xe-utils/lastForOf.js
var require_lastForOf = __commonJS({
  "node_modules/xe-utils/lastForOf.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var keys = require_hasOwnProp();
    function lastForOf(obj, iterate, context) {
      if (obj) {
        var len, list;
        if (isArray2(obj)) {
          for (len = obj.length - 1; len >= 0; len--) {
            if (iterate.call(context, obj[len], len, obj) === false) {
              break;
            }
          }
        } else {
          list = keys(obj);
          for (len = list.length - 1; len >= 0; len--) {
            if (iterate.call(context, obj[list[len]], list[len], obj) === false) {
              break;
            }
          }
        }
      }
    }
    module2.exports = lastForOf;
  }
});

// node_modules/xe-utils/helperCreateIndexOf.js
var require_helperCreateIndexOf = __commonJS({
  "node_modules/xe-utils/helperCreateIndexOf.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isString3 = require_isString();
    var hasOwnProp = require_hasOwnProp();
    function helperCreateIndexOf(name, callback) {
      return function(obj, val) {
        if (obj) {
          if (obj[name]) {
            return obj[name](val);
          }
          if (isString3(obj) || isArray2(obj)) {
            return callback(obj, val);
          }
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (val === obj[key]) {
                return key;
              }
            }
          }
        }
        return -1;
      };
    }
    module2.exports = helperCreateIndexOf;
  }
});

// node_modules/xe-utils/indexOf.js
var require_indexOf = __commonJS({
  "node_modules/xe-utils/indexOf.js"(exports2, module2) {
    var helperCreateIndexOf = require_helperCreateIndexOf();
    var arrayIndexOf = require_arrayIndexOf();
    var indexOf = helperCreateIndexOf("indexOf", arrayIndexOf);
    module2.exports = indexOf;
  }
});

// node_modules/xe-utils/lastIndexOf.js
var require_lastIndexOf = __commonJS({
  "node_modules/xe-utils/lastIndexOf.js"(exports2, module2) {
    var helperCreateIndexOf = require_helperCreateIndexOf();
    var arrayLastIndexOf = require_arrayLastIndexOf();
    var lastIndexOf = helperCreateIndexOf("lastIndexOf", arrayLastIndexOf);
    module2.exports = lastIndexOf;
  }
});

// node_modules/xe-utils/getSize.js
var require_getSize = __commonJS({
  "node_modules/xe-utils/getSize.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isString3 = require_isString();
    var each = require_each();
    function getSize(obj) {
      var len = 0;
      if (isString3(obj) || isArray2(obj)) {
        return obj.length;
      }
      each(obj, function() {
        len++;
      });
      return len;
    }
    module2.exports = getSize;
  }
});

// node_modules/xe-utils/isFinite.js
var require_isFinite = __commonJS({
  "node_modules/xe-utils/isFinite.js"(exports2, module2) {
    var isNumber2 = require_isNumber();
    function isNumberFinite(obj) {
      return isNumber2(obj) && isFinite(obj);
    }
    module2.exports = isNumberFinite;
  }
});

// node_modules/xe-utils/isInteger.js
var require_isInteger = __commonJS({
  "node_modules/xe-utils/isInteger.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isNull = require_isNull();
    var isInteger = function(obj) {
      return !isNull(obj) && !isNaN(obj) && !isArray2(obj) && obj % 1 === 0;
    };
    module2.exports = isInteger;
  }
});

// node_modules/xe-utils/isFloat.js
var require_isFloat = __commonJS({
  "node_modules/xe-utils/isFloat.js"(exports2, module2) {
    var isArray2 = require_isArray();
    var isInteger = require_isInteger();
    var isNull = require_isNull();
    function isFloat(obj) {
      return !isNull(obj) && !isNaN(obj) && !isArray2(obj) && !isInteger(obj);
    }
    module2.exports = isFloat;
  }
});

// node_modules/xe-utils/isBoolean.js
var require_isBoolean = __commonJS({
  "node_modules/xe-utils/isBoolean.js"(exports2, module2) {
    var helperCreateInTypeof = require_helperCreateInTypeof();
    var isBoolean2 = helperCreateInTypeof("boolean");
    module2.exports = isBoolean2;
  }
});

// node_modules/xe-utils/isRegExp.js
var require_isRegExp = __commonJS({
  "node_modules/xe-utils/isRegExp.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isRegExp2 = helperCreateInInObjectString("RegExp");
    module2.exports = isRegExp2;
  }
});

// node_modules/xe-utils/isError.js
var require_isError = __commonJS({
  "node_modules/xe-utils/isError.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isError = helperCreateInInObjectString("Error");
    module2.exports = isError;
  }
});

// node_modules/xe-utils/isTypeError.js
var require_isTypeError = __commonJS({
  "node_modules/xe-utils/isTypeError.js"(exports2, module2) {
    function isTypeError(obj) {
      return obj ? obj.constructor === TypeError : false;
    }
    module2.exports = isTypeError;
  }
});

// node_modules/xe-utils/isEmpty.js
var require_isEmpty = __commonJS({
  "node_modules/xe-utils/isEmpty.js"(exports2, module2) {
    function isEmpty(obj) {
      for (var key in obj) {
        return false;
      }
      return true;
    }
    module2.exports = isEmpty;
  }
});

// node_modules/xe-utils/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/xe-utils/isSymbol.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportSymbol = typeof Symbol !== staticStrUndefined;
    function isSymbol(obj) {
      return supportSymbol && Symbol.isSymbol ? Symbol.isSymbol(obj) : typeof obj === "symbol";
    }
    module2.exports = isSymbol;
  }
});

// node_modules/xe-utils/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/xe-utils/isArguments.js"(exports2, module2) {
    var helperCreateInInObjectString = require_helperCreateInInObjectString();
    var isArguments = helperCreateInInObjectString("Arguments");
    module2.exports = isArguments;
  }
});

// node_modules/xe-utils/isElement.js
var require_isElement = __commonJS({
  "node_modules/xe-utils/isElement.js"(exports2, module2) {
    var isString3 = require_isString();
    var isNumber2 = require_isNumber();
    function isElement(obj) {
      return !!(obj && isString3(obj.nodeName) && isNumber2(obj.nodeType));
    }
    module2.exports = isElement;
  }
});

// node_modules/xe-utils/staticDocument.js
var require_staticDocument = __commonJS({
  "node_modules/xe-utils/staticDocument.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticDocument = typeof document === staticStrUndefined ? 0 : document;
    module2.exports = staticDocument;
  }
});

// node_modules/xe-utils/isDocument.js
var require_isDocument = __commonJS({
  "node_modules/xe-utils/isDocument.js"(exports2, module2) {
    var staticDocument = require_staticDocument();
    function isDocument(obj) {
      return !!(obj && staticDocument && obj.nodeType === 9);
    }
    module2.exports = isDocument;
  }
});

// node_modules/xe-utils/staticWindow.js
var require_staticWindow = __commonJS({
  "node_modules/xe-utils/staticWindow.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticWindow = typeof window === staticStrUndefined ? 0 : window;
    module2.exports = staticWindow;
  }
});

// node_modules/xe-utils/isWindow.js
var require_isWindow = __commonJS({
  "node_modules/xe-utils/isWindow.js"(exports2, module2) {
    var staticWindow = require_staticWindow();
    function isWindow(obj) {
      return !!(staticWindow && !!(obj && obj === obj.window));
    }
    module2.exports = isWindow;
  }
});

// node_modules/xe-utils/isFormData.js
var require_isFormData = __commonJS({
  "node_modules/xe-utils/isFormData.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportFormData = typeof FormData !== staticStrUndefined;
    function isFormData(obj) {
      return supportFormData && obj instanceof FormData;
    }
    module2.exports = isFormData;
  }
});

// node_modules/xe-utils/isMap.js
var require_isMap = __commonJS({
  "node_modules/xe-utils/isMap.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportMap = typeof Map !== staticStrUndefined;
    function isMap(obj) {
      return supportMap && obj instanceof Map;
    }
    module2.exports = isMap;
  }
});

// node_modules/xe-utils/isWeakMap.js
var require_isWeakMap = __commonJS({
  "node_modules/xe-utils/isWeakMap.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportWeakMap = typeof WeakMap !== staticStrUndefined;
    function isWeakMap(obj) {
      return supportWeakMap && obj instanceof WeakMap;
    }
    module2.exports = isWeakMap;
  }
});

// node_modules/xe-utils/isSet.js
var require_isSet = __commonJS({
  "node_modules/xe-utils/isSet.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportSet = typeof Set !== staticStrUndefined;
    function isSet(obj) {
      return supportSet && obj instanceof Set;
    }
    module2.exports = isSet;
  }
});

// node_modules/xe-utils/isWeakSet.js
var require_isWeakSet = __commonJS({
  "node_modules/xe-utils/isWeakSet.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var supportWeakSet = typeof WeakSet !== staticStrUndefined;
    function isWeakSet(obj) {
      return supportWeakSet && obj instanceof WeakSet;
    }
    module2.exports = isWeakSet;
  }
});

// node_modules/xe-utils/helperCreateiterateIndexOf.js
var require_helperCreateiterateIndexOf = __commonJS({
  "node_modules/xe-utils/helperCreateiterateIndexOf.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isString3 = require_isString();
    var isArray2 = require_isArray();
    var hasOwnProp = require_hasOwnProp();
    function helperCreateiterateIndexOf(callback) {
      return function(obj, iterate, context) {
        if (obj && isFunction2(iterate)) {
          if (isArray2(obj) || isString3(obj)) {
            return callback(obj, iterate, context);
          }
          for (var key in obj) {
            if (hasOwnProp(obj, key)) {
              if (iterate.call(context, obj[key], key, obj)) {
                return key;
              }
            }
          }
        }
        return -1;
      };
    }
    module2.exports = helperCreateiterateIndexOf;
  }
});

// node_modules/xe-utils/findIndexOf.js
var require_findIndexOf = __commonJS({
  "node_modules/xe-utils/findIndexOf.js"(exports2, module2) {
    var helperCreateiterateIndexOf = require_helperCreateiterateIndexOf();
    var findIndexOf = helperCreateiterateIndexOf(function(obj, iterate, context) {
      for (var index2 = 0, len = obj.length; index2 < len; index2++) {
        if (iterate.call(context, obj[index2], index2, obj)) {
          return index2;
        }
      }
      return -1;
    });
    module2.exports = findIndexOf;
  }
});

// node_modules/xe-utils/helperEqualCompare.js
var require_helperEqualCompare = __commonJS({
  "node_modules/xe-utils/helperEqualCompare.js"(exports2, module2) {
    var isNumber2 = require_isNumber();
    var isArray2 = require_isArray();
    var isString3 = require_isString();
    var isRegExp2 = require_isRegExp();
    var isDate2 = require_isDate();
    var isBoolean2 = require_isBoolean();
    var isUndefined = require_isUndefined();
    var keys = require_keys();
    var every = require_every();
    function helperEqualCompare(val1, val2, compare, func, key, obj1, obj2) {
      if (val1 === val2) {
        return true;
      }
      if (val1 && val2 && !isNumber2(val1) && !isNumber2(val2) && !isString3(val1) && !isString3(val2)) {
        if (isRegExp2(val1)) {
          return compare("" + val1, "" + val2, key, obj1, obj2);
        }
        if (isDate2(val1) || isBoolean2(val1)) {
          return compare(+val1, +val2, key, obj1, obj2);
        } else {
          var result, val1Keys, val2Keys;
          var isObj1Arr = isArray2(val1);
          var isObj2Arr = isArray2(val2);
          if (isObj1Arr || isObj2Arr ? isObj1Arr && isObj2Arr : val1.constructor === val2.constructor) {
            val1Keys = keys(val1);
            val2Keys = keys(val2);
            if (func) {
              result = func(val1, val2, key);
            }
            if (val1Keys.length === val2Keys.length) {
              return isUndefined(result) ? every(val1Keys, function(key2, index2) {
                return key2 === val2Keys[index2] && helperEqualCompare(val1[key2], val2[val2Keys[index2]], compare, func, isObj1Arr || isObj2Arr ? index2 : key2, val1, val2);
              }) : !!result;
            }
            return false;
          }
        }
      }
      return compare(val1, val2, key, obj1, obj2);
    }
    module2.exports = helperEqualCompare;
  }
});

// node_modules/xe-utils/helperDefaultCompare.js
var require_helperDefaultCompare = __commonJS({
  "node_modules/xe-utils/helperDefaultCompare.js"(exports2, module2) {
    function helperDefaultCompare(v12, v22) {
      return v12 === v22;
    }
    module2.exports = helperDefaultCompare;
  }
});

// node_modules/xe-utils/isEqual.js
var require_isEqual = __commonJS({
  "node_modules/xe-utils/isEqual.js"(exports2, module2) {
    var helperEqualCompare = require_helperEqualCompare();
    var helperDefaultCompare = require_helperDefaultCompare();
    function isEqual(obj1, obj2) {
      return helperEqualCompare(obj1, obj2, helperDefaultCompare);
    }
    module2.exports = isEqual;
  }
});

// node_modules/xe-utils/isMatch.js
var require_isMatch = __commonJS({
  "node_modules/xe-utils/isMatch.js"(exports2, module2) {
    var keys = require_keys();
    var findIndexOf = require_findIndexOf();
    var isEqual = require_isEqual();
    var some = require_some();
    var includeArrays = require_includeArrays();
    function isMatch(obj, source) {
      var objKeys = keys(obj);
      var sourceKeys = keys(source);
      if (sourceKeys.length) {
        if (includeArrays(objKeys, sourceKeys)) {
          return some(sourceKeys, function(key2) {
            return findIndexOf(objKeys, function(key1) {
              return key1 === key2 && isEqual(obj[key1], source[key2]);
            }) > -1;
          });
        }
      } else {
        return true;
      }
      return isEqual(obj, source);
    }
    module2.exports = isMatch;
  }
});

// node_modules/xe-utils/isEqualWith.js
var require_isEqualWith = __commonJS({
  "node_modules/xe-utils/isEqualWith.js"(exports2, module2) {
    var helperEqualCompare = require_helperEqualCompare();
    var helperDefaultCompare = require_helperDefaultCompare();
    var isFunction2 = require_isFunction();
    var isUndefined = require_isUndefined();
    function isEqualWith(obj1, obj2, func) {
      if (isFunction2(func)) {
        return helperEqualCompare(obj1, obj2, function(v12, v22, key, obj12, obj22) {
          var result = func(v12, v22, key, obj12, obj22);
          return isUndefined(result) ? helperDefaultCompare(v12, v22) : !!result;
        }, func);
      }
      return helperEqualCompare(obj1, obj2, helperDefaultCompare);
    }
    module2.exports = isEqualWith;
  }
});

// node_modules/xe-utils/getType.js
var require_getType = __commonJS({
  "node_modules/xe-utils/getType.js"(exports2, module2) {
    var isSymbol = require_isSymbol();
    var isDate2 = require_isDate();
    var isArray2 = require_isArray();
    var isRegExp2 = require_isRegExp();
    var isError = require_isError();
    var isNull = require_isNull();
    function getType(obj) {
      if (isNull(obj)) {
        return "null";
      }
      if (isSymbol(obj)) {
        return "symbol";
      }
      if (isDate2(obj)) {
        return "date";
      }
      if (isArray2(obj)) {
        return "array";
      }
      if (isRegExp2(obj)) {
        return "regexp";
      }
      if (isError(obj)) {
        return "error";
      }
      return typeof obj;
    }
    module2.exports = getType;
  }
});

// node_modules/xe-utils/uniqueId.js
var require_uniqueId = __commonJS({
  "node_modules/xe-utils/uniqueId.js"(exports2, module2) {
    var __uniqueId = 0;
    function uniqueId(prefix) {
      return [prefix, ++__uniqueId].join("");
    }
    module2.exports = uniqueId;
  }
});

// node_modules/xe-utils/findLastIndexOf.js
var require_findLastIndexOf = __commonJS({
  "node_modules/xe-utils/findLastIndexOf.js"(exports2, module2) {
    var helperCreateiterateIndexOf = require_helperCreateiterateIndexOf();
    var findLastIndexOf = helperCreateiterateIndexOf(function(obj, iterate, context) {
      for (var len = obj.length - 1; len >= 0; len--) {
        if (iterate.call(context, obj[len], len, obj)) {
          return len;
        }
      }
      return -1;
    });
    module2.exports = findLastIndexOf;
  }
});

// node_modules/xe-utils/toStringJSON.js
var require_toStringJSON = __commonJS({
  "node_modules/xe-utils/toStringJSON.js"(exports2, module2) {
    var isPlainObject2 = require_isPlainObject();
    var isString3 = require_isString();
    function toStringJSON(str) {
      if (isPlainObject2(str)) {
        return str;
      } else if (isString3(str)) {
        try {
          return JSON.parse(str);
        } catch (e16) {
        }
      }
      return {};
    }
    module2.exports = toStringJSON;
  }
});

// node_modules/xe-utils/toJSONString.js
var require_toJSONString = __commonJS({
  "node_modules/xe-utils/toJSONString.js"(exports2, module2) {
    var eqNull = require_eqNull();
    function toJSONString(obj) {
      return eqNull(obj) ? "" : JSON.stringify(obj);
    }
    module2.exports = toJSONString;
  }
});

// node_modules/xe-utils/entries.js
var require_entries = __commonJS({
  "node_modules/xe-utils/entries.js"(exports2, module2) {
    var helperCreateGetObjects = require_helperCreateGetObjects();
    var entries = helperCreateGetObjects("entries", 2);
    module2.exports = entries;
  }
});

// node_modules/xe-utils/helperCreatePickOmit.js
var require_helperCreatePickOmit = __commonJS({
  "node_modules/xe-utils/helperCreatePickOmit.js"(exports2, module2) {
    var isFunction2 = require_isFunction();
    var isArray2 = require_isArray();
    var each = require_each();
    var findIndexOf = require_findIndexOf();
    function helperCreatePickOmit(case1, case2) {
      return function(obj, callback) {
        var item, index2;
        var rest = {};
        var result = [];
        var context = this;
        var args = arguments;
        var len = args.length;
        if (!isFunction2(callback)) {
          for (index2 = 1; index2 < len; index2++) {
            item = args[index2];
            result.push.apply(result, isArray2(item) ? item : [item]);
          }
          callback = 0;
        }
        each(obj, function(val, key) {
          if ((callback ? callback.call(context, val, key, obj) : findIndexOf(result, function(name) {
            return name === key;
          }) > -1) ? case1 : case2) {
            rest[key] = val;
          }
        });
        return rest;
      };
    }
    module2.exports = helperCreatePickOmit;
  }
});

// node_modules/xe-utils/pick.js
var require_pick = __commonJS({
  "node_modules/xe-utils/pick.js"(exports2, module2) {
    var helperCreatePickOmit = require_helperCreatePickOmit();
    var pick = helperCreatePickOmit(1, 0);
    module2.exports = pick;
  }
});

// node_modules/xe-utils/omit.js
var require_omit = __commonJS({
  "node_modules/xe-utils/omit.js"(exports2, module2) {
    var helperCreatePickOmit = require_helperCreatePickOmit();
    var omit = helperCreatePickOmit(0, 1);
    module2.exports = omit;
  }
});

// node_modules/xe-utils/first.js
var require_first = __commonJS({
  "node_modules/xe-utils/first.js"(exports2, module2) {
    var values = require_values();
    function first(obj) {
      return values(obj)[0];
    }
    module2.exports = first;
  }
});

// node_modules/xe-utils/last.js
var require_last = __commonJS({
  "node_modules/xe-utils/last.js"(exports2, module2) {
    var values = require_values();
    function last(obj) {
      var list = values(obj);
      return list[list.length - 1];
    }
    module2.exports = last;
  }
});

// node_modules/xe-utils/has.js
var require_has = __commonJS({
  "node_modules/xe-utils/has.js"(exports2, module2) {
    var staticHGKeyRE = require_staticHGKeyRE();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    function has(obj, property) {
      if (obj) {
        if (hasOwnProp(obj, property)) {
          return true;
        } else {
          var prop, arrIndex, objProp, matchs, rest, isHas;
          var props = helperGetHGSKeys(property);
          var index2 = 0;
          var len = props.length;
          for (rest = obj; index2 < len; index2++) {
            isHas = false;
            prop = props[index2];
            matchs = prop ? prop.match(staticHGKeyRE) : "";
            if (matchs) {
              arrIndex = matchs[1];
              objProp = matchs[2];
              if (arrIndex) {
                if (rest[arrIndex]) {
                  if (hasOwnProp(rest[arrIndex], objProp)) {
                    isHas = true;
                    rest = rest[arrIndex][objProp];
                  }
                }
              } else {
                if (hasOwnProp(rest, objProp)) {
                  isHas = true;
                  rest = rest[objProp];
                }
              }
            } else {
              if (hasOwnProp(rest, prop)) {
                isHas = true;
                rest = rest[prop];
              }
            }
            if (isHas) {
              if (index2 === len - 1) {
                return true;
              }
            } else {
              break;
            }
          }
        }
      }
      return false;
    }
    module2.exports = has;
  }
});

// node_modules/xe-utils/set.js
var require_set = __commonJS({
  "node_modules/xe-utils/set.js"(exports2, module2) {
    var staticParseInt = require_staticParseInt();
    var helperGetHGSKeys = require_helperGetHGSKeys();
    var hasOwnProp = require_hasOwnProp();
    var sKeyRE = /(.+)?\[(\d+)\]$/;
    function setDeepProps(obj, key, isEnd, nextKey, value) {
      if (obj[key]) {
        if (isEnd) {
          obj[key] = value;
        }
      } else {
        var index2;
        var rest;
        var currMatchs = key ? key.match(sKeyRE) : null;
        if (isEnd) {
          rest = value;
        } else {
          var nextMatchs = nextKey ? nextKey.match(sKeyRE) : null;
          if (nextMatchs && !nextMatchs[1]) {
            rest = new Array(staticParseInt(nextMatchs[2]) + 1);
          } else {
            rest = {};
          }
        }
        if (currMatchs) {
          if (currMatchs[1]) {
            index2 = staticParseInt(currMatchs[2]);
            if (obj[currMatchs[1]]) {
              if (isEnd) {
                obj[currMatchs[1]][index2] = rest;
              } else {
                if (obj[currMatchs[1]][index2]) {
                  rest = obj[currMatchs[1]][index2];
                } else {
                  obj[currMatchs[1]][index2] = rest;
                }
              }
            } else {
              obj[currMatchs[1]] = new Array(index2 + 1);
              obj[currMatchs[1]][index2] = rest;
            }
          } else {
            obj[currMatchs[2]] = rest;
          }
        } else {
          obj[key] = rest;
        }
        return rest;
      }
      return obj[key];
    }
    function set(obj, property, value) {
      if (obj) {
        if ((obj[property] || hasOwnProp(obj, property)) && !isPrototypePolluted(property)) {
          obj[property] = value;
        } else {
          var rest = obj;
          var props = helperGetHGSKeys(property);
          var len = props.length;
          for (var index2 = 0; index2 < len; index2++) {
            if (isPrototypePolluted(props[index2])) {
              continue;
            }
            var isEnd = index2 === len - 1;
            rest = setDeepProps(rest, props[index2], isEnd, isEnd ? null : props[index2 + 1], value);
          }
        }
      }
      return obj;
    }
    function isPrototypePolluted(key) {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    }
    module2.exports = set;
  }
});

// node_modules/xe-utils/groupBy.js
var require_groupBy = __commonJS({
  "node_modules/xe-utils/groupBy.js"(exports2, module2) {
    var isEmpty = require_isEmpty();
    var isObject3 = require_isObject();
    var isFunction2 = require_isFunction();
    var property = require_property();
    var each = require_each();
    function createiterateEmpty(iterate) {
      return function() {
        return isEmpty(iterate);
      };
    }
    function groupBy(obj, iterate, context) {
      var groupKey;
      var result = {};
      if (obj) {
        if (iterate && isObject3(iterate)) {
          iterate = createiterateEmpty(iterate);
        } else if (!isFunction2(iterate)) {
          iterate = property(iterate);
        }
        each(obj, function(val, key) {
          groupKey = iterate ? iterate.call(context, val, key, obj) : val;
          if (result[groupKey]) {
            result[groupKey].push(val);
          } else {
            result[groupKey] = [val];
          }
        });
      }
      return result;
    }
    module2.exports = groupBy;
  }
});

// node_modules/xe-utils/countBy.js
var require_countBy = __commonJS({
  "node_modules/xe-utils/countBy.js"(exports2, module2) {
    var groupBy = require_groupBy();
    var objectEach = require_objectEach();
    function countBy(obj, iterate, context) {
      var result = groupBy(obj, iterate, context || this);
      objectEach(result, function(item, key) {
        result[key] = item.length;
      });
      return result;
    }
    module2.exports = countBy;
  }
});

// node_modules/xe-utils/range.js
var require_range = __commonJS({
  "node_modules/xe-utils/range.js"(exports2, module2) {
    function range(start, stop, step) {
      var index2, len;
      var result = [];
      var args = arguments;
      if (args.length < 2) {
        stop = args[0];
        start = 0;
      }
      index2 = start >> 0;
      len = stop >> 0;
      if (index2 < stop) {
        step = step >> 0 || 1;
        for (; index2 < len; index2 += step) {
          result.push(index2);
        }
      }
      return result;
    }
    module2.exports = range;
  }
});

// node_modules/xe-utils/destructuring.js
var require_destructuring = __commonJS({
  "node_modules/xe-utils/destructuring.js"(exports2, module2) {
    var keys = require_keys();
    var slice = require_slice();
    var includes = require_includes();
    var arrayEach = require_arrayEach();
    var assign3 = require_assign();
    function destructuring(destination, sources) {
      if (destination && sources) {
        var rest = assign3.apply(this, [{}].concat(slice(arguments, 1)));
        var restKeys = keys(rest);
        arrayEach(keys(destination), function(key) {
          if (includes(restKeys, key)) {
            destination[key] = rest[key];
          }
        });
      }
      return destination;
    }
    module2.exports = destructuring;
  }
});

// node_modules/xe-utils/min.js
var require_min = __commonJS({
  "node_modules/xe-utils/min.js"(exports2, module2) {
    var helperCreateMinMax = require_helperCreateMinMax();
    var min = helperCreateMinMax(function(rest, itemVal) {
      return rest > itemVal;
    });
    module2.exports = min;
  }
});

// node_modules/xe-utils/helperNumberDecimal.js
var require_helperNumberDecimal = __commonJS({
  "node_modules/xe-utils/helperNumberDecimal.js"(exports2, module2) {
    function helperNumberDecimal(numStr) {
      return (numStr.split(".")[1] || "").length;
    }
    module2.exports = helperNumberDecimal;
  }
});

// node_modules/xe-utils/helperStringRepeat.js
var require_helperStringRepeat = __commonJS({
  "node_modules/xe-utils/helperStringRepeat.js"(exports2, module2) {
    var staticParseInt = require_staticParseInt();
    function helperStringRepeat(str, count) {
      if (str.repeat) {
        return str.repeat(count);
      }
      var list = isNaN(count) ? [] : new Array(staticParseInt(count));
      return list.join(str) + (list.length > 0 ? str : "");
    }
    module2.exports = helperStringRepeat;
  }
});

// node_modules/xe-utils/helperNumberOffsetPoint.js
var require_helperNumberOffsetPoint = __commonJS({
  "node_modules/xe-utils/helperNumberOffsetPoint.js"(exports2, module2) {
    function helperNumberOffsetPoint(str, offsetIndex) {
      return str.substring(0, offsetIndex) + "." + str.substring(offsetIndex, str.length);
    }
    module2.exports = helperNumberOffsetPoint;
  }
});

// node_modules/xe-utils/toNumberString.js
var require_toNumberString = __commonJS({
  "node_modules/xe-utils/toNumberString.js"(exports2, module2) {
    var helperStringRepeat = require_helperStringRepeat();
    var helperNumberOffsetPoint = require_helperNumberOffsetPoint();
    function toNumberString(num) {
      var rest = "" + num;
      var scienceMatchs = rest.match(/^([-+]?)((\d+)|((\d+)?[.](\d+)?))e([-+]{1})([0-9]+)$/);
      if (scienceMatchs) {
        var isNegative = num < 0;
        var absFlag = isNegative ? "-" : "";
        var intNumStr = scienceMatchs[3] || "";
        var dIntNumStr = scienceMatchs[5] || "";
        var dFloatNumStr = scienceMatchs[6] || "";
        var sciencFlag = scienceMatchs[7];
        var scienceNumStr = scienceMatchs[8];
        var floatOffsetIndex = scienceNumStr - dFloatNumStr.length;
        var intOffsetIndex = scienceNumStr - intNumStr.length;
        var dIntOffsetIndex = scienceNumStr - dIntNumStr.length;
        if (sciencFlag === "+") {
          if (intNumStr) {
            return absFlag + intNumStr + helperStringRepeat("0", scienceNumStr);
          }
          if (floatOffsetIndex > 0) {
            return absFlag + dIntNumStr + dFloatNumStr + helperStringRepeat("0", floatOffsetIndex);
          }
          return absFlag + dIntNumStr + helperNumberOffsetPoint(dFloatNumStr, scienceNumStr);
        }
        if (intNumStr) {
          if (intOffsetIndex > 0) {
            return absFlag + "0." + helperStringRepeat("0", Math.abs(intOffsetIndex)) + intNumStr;
          }
          return absFlag + helperNumberOffsetPoint(intNumStr, intOffsetIndex);
        }
        if (dIntOffsetIndex > 0) {
          return absFlag + "0." + helperStringRepeat("0", Math.abs(dIntOffsetIndex)) + dIntNumStr + dFloatNumStr;
        }
        return absFlag + helperNumberOffsetPoint(dIntNumStr, dIntOffsetIndex) + dFloatNumStr;
      }
      return rest;
    }
    module2.exports = toNumberString;
  }
});

// node_modules/xe-utils/helperMultiply.js
var require_helperMultiply = __commonJS({
  "node_modules/xe-utils/helperMultiply.js"(exports2, module2) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    function helperMultiply(multiplier, multiplicand) {
      var str1 = toNumberString(multiplier);
      var str2 = toNumberString(multiplicand);
      return parseInt(str1.replace(".", "")) * parseInt(str2.replace(".", "")) / Math.pow(10, helperNumberDecimal(str1) + helperNumberDecimal(str2));
    }
    module2.exports = helperMultiply;
  }
});

// node_modules/xe-utils/helperCreateMathNumber.js
var require_helperCreateMathNumber = __commonJS({
  "node_modules/xe-utils/helperCreateMathNumber.js"(exports2, module2) {
    var helperMultiply = require_helperMultiply();
    var toNumber = require_toNumber();
    var toNumberString = require_toNumberString();
    function helperCreateMathNumber(name) {
      return function(num, digits) {
        var numRest = toNumber(num);
        var rest = numRest;
        if (numRest) {
          digits = digits >> 0;
          var numStr = toNumberString(numRest);
          var nums = numStr.split(".");
          var intStr = nums[0];
          var floatStr = nums[1] || "";
          var fStr = floatStr.substring(0, digits + 1);
          var subRest = intStr + (fStr ? "." + fStr : "");
          if (digits >= floatStr.length) {
            return toNumber(subRest);
          }
          subRest = numRest;
          if (digits > 0) {
            var ratio = Math.pow(10, digits);
            rest = Math[name](helperMultiply(subRest, ratio)) / ratio;
          } else {
            rest = Math[name](subRest);
          }
        }
        return rest;
      };
    }
    module2.exports = helperCreateMathNumber;
  }
});

// node_modules/xe-utils/round.js
var require_round = __commonJS({
  "node_modules/xe-utils/round.js"(exports2, module2) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var round = helperCreateMathNumber("round");
    module2.exports = round;
  }
});

// node_modules/xe-utils/ceil.js
var require_ceil = __commonJS({
  "node_modules/xe-utils/ceil.js"(exports2, module2) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var ceil = helperCreateMathNumber("ceil");
    module2.exports = ceil;
  }
});

// node_modules/xe-utils/floor.js
var require_floor = __commonJS({
  "node_modules/xe-utils/floor.js"(exports2, module2) {
    var helperCreateMathNumber = require_helperCreateMathNumber();
    var floor = helperCreateMathNumber("floor");
    module2.exports = floor;
  }
});

// node_modules/xe-utils/toValueString.js
var require_toValueString = __commonJS({
  "node_modules/xe-utils/toValueString.js"(exports2, module2) {
    var eqNull = require_eqNull();
    var isNumber2 = require_isNumber();
    var toNumberString = require_toNumberString();
    function toValueString(obj) {
      if (isNumber2(obj)) {
        return toNumberString(obj);
      }
      return "" + (eqNull(obj) ? "" : obj);
    }
    module2.exports = toValueString;
  }
});

// node_modules/xe-utils/toFixed.js
var require_toFixed = __commonJS({
  "node_modules/xe-utils/toFixed.js"(exports2, module2) {
    var round = require_round();
    var toValueString = require_toValueString();
    var helperStringRepeat = require_helperStringRepeat();
    var helperNumberOffsetPoint = require_helperNumberOffsetPoint();
    function toFixed(num, digits) {
      digits = digits >> 0;
      var str = toValueString(round(num, digits));
      var nums = str.split(".");
      var intStr = nums[0];
      var floatStr = nums[1] || "";
      var digitOffsetIndex = digits - floatStr.length;
      if (digits) {
        if (digitOffsetIndex > 0) {
          return intStr + "." + floatStr + helperStringRepeat("0", digitOffsetIndex);
        }
        return intStr + helperNumberOffsetPoint(floatStr, Math.abs(digitOffsetIndex));
      }
      return intStr;
    }
    module2.exports = toFixed;
  }
});

// node_modules/xe-utils/commafy.js
var require_commafy = __commonJS({
  "node_modules/xe-utils/commafy.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var round = require_round();
    var ceil = require_ceil();
    var floor = require_floor();
    var isNumber2 = require_isNumber();
    var toValueString = require_toValueString();
    var toFixed = require_toFixed();
    var toNumberString = require_toNumberString();
    var assign3 = require_assign();
    function commafy(num, options) {
      var opts = assign3({}, setupDefaults.commafyOptions, options);
      var optDigits = opts.digits;
      var isNum = isNumber2(num);
      var rest, result, isNegative, intStr, floatStr;
      if (isNum) {
        rest = (opts.ceil ? ceil : opts.floor ? floor : round)(num, optDigits);
        result = toNumberString(optDigits ? toFixed(rest, optDigits) : rest).split(".");
        intStr = result[0];
        floatStr = result[1];
        isNegative = intStr && rest < 0;
        if (isNegative) {
          intStr = intStr.substring(1, intStr.length);
        }
      } else {
        rest = toValueString(num).replace(/,/g, "");
        result = rest ? [rest] : [];
        intStr = result[0];
      }
      if (result.length) {
        return (isNegative ? "-" : "") + intStr.replace(new RegExp("(?=(?!(\\b))(.{" + (opts.spaceNumber || 3) + "})+$)", "g"), opts.separator || ",") + (floatStr ? "." + floatStr : "");
      }
      return rest;
    }
    module2.exports = commafy;
  }
});

// node_modules/xe-utils/toInteger.js
var require_toInteger = __commonJS({
  "node_modules/xe-utils/toInteger.js"(exports2, module2) {
    var staticParseInt = require_staticParseInt();
    var helperCreateToNumber = require_helperCreateToNumber();
    var toInteger = helperCreateToNumber(staticParseInt);
    module2.exports = toInteger;
  }
});

// node_modules/xe-utils/multiply.js
var require_multiply = __commonJS({
  "node_modules/xe-utils/multiply.js"(exports2, module2) {
    var helperMultiply = require_helperMultiply();
    var toNumber = require_toNumber();
    function multiply(num1, num2) {
      var multiplier = toNumber(num1);
      var multiplicand = toNumber(num2);
      return helperMultiply(multiplier, multiplicand);
    }
    module2.exports = multiply;
  }
});

// node_modules/xe-utils/helperNumberAdd.js
var require_helperNumberAdd = __commonJS({
  "node_modules/xe-utils/helperNumberAdd.js"(exports2, module2) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var multiply = require_multiply();
    function helperNumberAdd(addend, augend) {
      var str1 = toNumberString(addend);
      var str2 = toNumberString(augend);
      var ratio = Math.pow(10, Math.max(helperNumberDecimal(str1), helperNumberDecimal(str2)));
      return (multiply(addend, ratio) + multiply(augend, ratio)) / ratio;
    }
    module2.exports = helperNumberAdd;
  }
});

// node_modules/xe-utils/add.js
var require_add = __commonJS({
  "node_modules/xe-utils/add.js"(exports2, module2) {
    var helperNumberAdd = require_helperNumberAdd();
    var toNumber = require_toNumber();
    function add(num1, num2) {
      return helperNumberAdd(toNumber(num1), toNumber(num2));
    }
    module2.exports = add;
  }
});

// node_modules/xe-utils/subtract.js
var require_subtract = __commonJS({
  "node_modules/xe-utils/subtract.js"(exports2, module2) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var toNumber = require_toNumber();
    var toFixed = require_toFixed();
    function subtract(num1, num2) {
      var subtrahend = toNumber(num1);
      var minuend = toNumber(num2);
      var str1 = toNumberString(subtrahend);
      var str2 = toNumberString(minuend);
      var digit1 = helperNumberDecimal(str1);
      var digit2 = helperNumberDecimal(str2);
      var ratio = Math.pow(10, Math.max(digit1, digit2));
      var precision = digit1 >= digit2 ? digit1 : digit2;
      return parseFloat(toFixed((subtrahend * ratio - minuend * ratio) / ratio, precision));
    }
    module2.exports = subtract;
  }
});

// node_modules/xe-utils/helperNumberDivide.js
var require_helperNumberDivide = __commonJS({
  "node_modules/xe-utils/helperNumberDivide.js"(exports2, module2) {
    var helperNumberDecimal = require_helperNumberDecimal();
    var toNumberString = require_toNumberString();
    var multiply = require_multiply();
    function helperNumberDivide(divisor, dividend) {
      var str1 = toNumberString(divisor);
      var str2 = toNumberString(dividend);
      var divisorDecimal = helperNumberDecimal(str1);
      var dividendDecimal = helperNumberDecimal(str2);
      var powY = dividendDecimal - divisorDecimal;
      var isMinus = powY < 0;
      var multiplicand = Math.pow(10, isMinus ? Math.abs(powY) : powY);
      return multiply(str1.replace(".", "") / str2.replace(".", ""), isMinus ? 1 / multiplicand : multiplicand);
    }
    module2.exports = helperNumberDivide;
  }
});

// node_modules/xe-utils/divide.js
var require_divide = __commonJS({
  "node_modules/xe-utils/divide.js"(exports2, module2) {
    var helperNumberDivide = require_helperNumberDivide();
    var toNumber = require_toNumber();
    function divide(num1, num2) {
      return helperNumberDivide(toNumber(num1), toNumber(num2));
    }
    module2.exports = divide;
  }
});

// node_modules/xe-utils/sum.js
var require_sum = __commonJS({
  "node_modules/xe-utils/sum.js"(exports2, module2) {
    var helperNumberAdd = require_helperNumberAdd();
    var isFunction2 = require_isFunction();
    var isArray2 = require_isArray();
    var each = require_each();
    var get = require_get();
    function sum(array, iterate, context) {
      var result = 0;
      each(array && array.length > 2 && isArray2(array) ? array.sort() : array, iterate ? isFunction2(iterate) ? function() {
        result = helperNumberAdd(result, iterate.apply(context, arguments));
      } : function(val) {
        result = helperNumberAdd(result, get(val, iterate));
      } : function(val) {
        result = helperNumberAdd(result, val);
      });
      return result;
    }
    module2.exports = sum;
  }
});

// node_modules/xe-utils/mean.js
var require_mean = __commonJS({
  "node_modules/xe-utils/mean.js"(exports2, module2) {
    var helperNumberDivide = require_helperNumberDivide();
    var getSize = require_getSize();
    var sum = require_sum();
    function mean(array, iterate, context) {
      return helperNumberDivide(sum(array, iterate, context), getSize(array));
    }
    module2.exports = mean;
  }
});

// node_modules/xe-utils/staticStrFirst.js
var require_staticStrFirst = __commonJS({
  "node_modules/xe-utils/staticStrFirst.js"(exports2, module2) {
    var staticStrFirst = "first";
    module2.exports = staticStrFirst;
  }
});

// node_modules/xe-utils/staticStrLast.js
var require_staticStrLast = __commonJS({
  "node_modules/xe-utils/staticStrLast.js"(exports2, module2) {
    var staticStrLast = "last";
    module2.exports = staticStrLast;
  }
});

// node_modules/xe-utils/helperGetDateFullYear.js
var require_helperGetDateFullYear = __commonJS({
  "node_modules/xe-utils/helperGetDateFullYear.js"(exports2, module2) {
    function helperGetDateFullYear(date) {
      return date.getFullYear();
    }
    module2.exports = helperGetDateFullYear;
  }
});

// node_modules/xe-utils/staticDayTime.js
var require_staticDayTime = __commonJS({
  "node_modules/xe-utils/staticDayTime.js"(exports2, module2) {
    var staticDayTime = 864e5;
    module2.exports = staticDayTime;
  }
});

// node_modules/xe-utils/helperGetDateMonth.js
var require_helperGetDateMonth = __commonJS({
  "node_modules/xe-utils/helperGetDateMonth.js"(exports2, module2) {
    function helperGetDateMonth(date) {
      return date.getMonth();
    }
    module2.exports = helperGetDateMonth;
  }
});

// node_modules/xe-utils/isValidDate.js
var require_isValidDate = __commonJS({
  "node_modules/xe-utils/isValidDate.js"(exports2, module2) {
    var isDate2 = require_isDate();
    var helperGetDateTime = require_helperGetDateTime();
    function isValidDate(val) {
      return isDate2(val) && !isNaN(helperGetDateTime(val));
    }
    module2.exports = isValidDate;
  }
});

// node_modules/xe-utils/getWhatMonth.js
var require_getWhatMonth = __commonJS({
  "node_modules/xe-utils/getWhatMonth.js"(exports2, module2) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var staticDayTime = require_staticDayTime();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateTime = require_helperGetDateTime();
    var helperGetDateMonth = require_helperGetDateMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isNumber2 = require_isNumber();
    function getWhatMonth(date, offsetMonth, offsetDay) {
      var monthNum = offsetMonth && !isNaN(offsetMonth) ? offsetMonth : 0;
      date = toStringDate(date);
      if (isValidDate(date)) {
        if (offsetDay === staticStrFirst) {
          return new Date(helperGetDateFullYear(date), helperGetDateMonth(date) + monthNum, 1);
        } else if (offsetDay === staticStrLast) {
          return new Date(helperGetDateTime(getWhatMonth(date, monthNum + 1, staticStrFirst)) - 1);
        } else if (isNumber2(offsetDay)) {
          date.setDate(offsetDay);
        }
        if (monthNum) {
          var currDate = date.getDate();
          date.setMonth(helperGetDateMonth(date) + monthNum);
          if (currDate !== date.getDate()) {
            date.setDate(1);
            return new Date(helperGetDateTime(date) - staticDayTime);
          }
        }
      }
      return date;
    }
    module2.exports = getWhatMonth;
  }
});

// node_modules/xe-utils/getWhatYear.js
var require_getWhatYear = __commonJS({
  "node_modules/xe-utils/getWhatYear.js"(exports2, module2) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getWhatYear(date, offset, month) {
      var number2;
      date = toStringDate(date);
      if (isValidDate(date)) {
        if (offset) {
          number2 = offset && !isNaN(offset) ? offset : 0;
          date.setFullYear(helperGetDateFullYear(date) + number2);
        }
        if (month || !isNaN(month)) {
          if (month === staticStrFirst) {
            return new Date(helperGetDateFullYear(date), 0, 1);
          } else if (month === staticStrLast) {
            date.setMonth(11);
            return getWhatMonth(date, 0, staticStrLast);
          } else {
            date.setMonth(month);
          }
        }
      }
      return date;
    }
    module2.exports = getWhatYear;
  }
});

// node_modules/xe-utils/getWhatQuarter.js
var require_getWhatQuarter = __commonJS({
  "node_modules/xe-utils/getWhatQuarter.js"(exports2, module2) {
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getQuarterNumber(date) {
      var month = date.getMonth();
      if (month < 3) {
        return 1;
      } else if (month < 6) {
        return 2;
      } else if (month < 9) {
        return 3;
      }
      return 4;
    }
    function getWhatQuarter(date, offset, day) {
      var currMonth, monthOffset = offset && !isNaN(offset) ? offset * 3 : 0;
      date = toStringDate(date);
      if (isValidDate(date)) {
        currMonth = (getQuarterNumber(date) - 1) * 3;
        date.setMonth(currMonth);
        return getWhatMonth(date, monthOffset, day);
      }
      return date;
    }
    module2.exports = getWhatQuarter;
  }
});

// node_modules/xe-utils/getWhatDay.js
var require_getWhatDay = __commonJS({
  "node_modules/xe-utils/getWhatDay.js"(exports2, module2) {
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var staticParseInt = require_staticParseInt();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    var helperGetDateTime = require_helperGetDateTime();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getWhatDay(date, offset, mode) {
      date = toStringDate(date);
      if (isValidDate(date) && !isNaN(offset)) {
        date.setDate(date.getDate() + staticParseInt(offset));
        if (mode === staticStrFirst) {
          return new Date(helperGetDateFullYear(date), helperGetDateMonth(date), date.getDate());
        } else if (mode === staticStrLast) {
          return new Date(helperGetDateTime(getWhatDay(date, 1, staticStrFirst)) - 1);
        }
      }
      return date;
    }
    module2.exports = getWhatDay;
  }
});

// node_modules/xe-utils/helperStringUpperCase.js
var require_helperStringUpperCase = __commonJS({
  "node_modules/xe-utils/helperStringUpperCase.js"(exports2, module2) {
    function helperStringUpperCase(str) {
      return str.toUpperCase();
    }
    module2.exports = helperStringUpperCase;
  }
});

// node_modules/xe-utils/staticWeekTime.js
var require_staticWeekTime = __commonJS({
  "node_modules/xe-utils/staticWeekTime.js"(exports2, module2) {
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = staticDayTime * 7;
    module2.exports = staticWeekTime;
  }
});

// node_modules/xe-utils/getWhatWeek.js
var require_getWhatWeek = __commonJS({
  "node_modules/xe-utils/getWhatWeek.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var staticDayTime = require_staticDayTime();
    var staticWeekTime = require_staticWeekTime();
    var helperGetDateTime = require_helperGetDateTime();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isNumber2 = require_isNumber();
    function getWhatWeek(date, offsetWeek, offsetDay, firstDay) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        var hasCustomDay = isNumber2(offsetDay);
        var hasStartDay = isNumber2(firstDay);
        var whatDayTime = helperGetDateTime(date);
        if (hasCustomDay || hasStartDay) {
          var viewStartDay = hasStartDay ? firstDay : setupDefaults.firstDayOfWeek;
          var currentDay = date.getDay();
          var customDay = hasCustomDay ? offsetDay : currentDay;
          if (currentDay !== customDay) {
            var offsetNum = 0;
            if (viewStartDay > currentDay) {
              offsetNum = -(7 - viewStartDay + currentDay);
            } else if (viewStartDay < currentDay) {
              offsetNum = viewStartDay - currentDay;
            }
            if (customDay > viewStartDay) {
              whatDayTime += ((customDay === 0 ? 7 : customDay) - viewStartDay + offsetNum) * staticDayTime;
            } else if (customDay < viewStartDay) {
              whatDayTime += (7 - viewStartDay + customDay + offsetNum) * staticDayTime;
            } else {
              whatDayTime += offsetNum * staticDayTime;
            }
          }
        }
        if (offsetWeek && !isNaN(offsetWeek)) {
          whatDayTime += offsetWeek * staticWeekTime;
        }
        return new Date(whatDayTime);
      }
      return date;
    }
    module2.exports = getWhatWeek;
  }
});

// node_modules/xe-utils/helperCreateGetDateWeek.js
var require_helperCreateGetDateWeek = __commonJS({
  "node_modules/xe-utils/helperCreateGetDateWeek.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var staticWeekTime = require_staticWeekTime();
    var isNumber2 = require_isNumber();
    var isValidDate = require_isValidDate();
    var getWhatWeek = require_getWhatWeek();
    var helperGetDateTime = require_helperGetDateTime();
    function helperCreateGetDateWeek(getStartDate) {
      return function(date, firstDay) {
        var viewStartDay = isNumber2(firstDay) ? firstDay : setupDefaults.firstDayOfWeek;
        var targetDate = getWhatWeek(date, 0, viewStartDay, viewStartDay);
        if (isValidDate(targetDate)) {
          var targetOffsetDate = new Date(targetDate.getFullYear(), targetDate.getMonth(), targetDate.getDate());
          var targerStartDate = getStartDate(targetDate);
          var targetFirstDay = targerStartDate.getDay();
          if (targetFirstDay > viewStartDay) {
            targerStartDate.setDate(7 - targetFirstDay + viewStartDay + 1);
          }
          if (targetFirstDay < viewStartDay) {
            targerStartDate.setDate(viewStartDay - targetFirstDay + 1);
          }
          return Math.floor((helperGetDateTime(targetOffsetDate) - helperGetDateTime(targerStartDate)) / staticWeekTime + 1);
        }
        return NaN;
      };
    }
    module2.exports = helperCreateGetDateWeek;
  }
});

// node_modules/xe-utils/getYearWeek.js
var require_getYearWeek = __commonJS({
  "node_modules/xe-utils/getYearWeek.js"(exports2, module2) {
    var helperCreateGetDateWeek = require_helperCreateGetDateWeek();
    var getYearWeek = helperCreateGetDateWeek(function(targetDate) {
      return new Date(targetDate.getFullYear(), 0, 1);
    });
    module2.exports = getYearWeek;
  }
});

// node_modules/xe-utils/helperGetYMD.js
var require_helperGetYMD = __commonJS({
  "node_modules/xe-utils/helperGetYMD.js"(exports2, module2) {
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    function helperGetYMD(date) {
      return new Date(helperGetDateFullYear(date), helperGetDateMonth(date), date.getDate());
    }
    module2.exports = helperGetYMD;
  }
});

// node_modules/xe-utils/helperGetYMDTime.js
var require_helperGetYMDTime = __commonJS({
  "node_modules/xe-utils/helperGetYMDTime.js"(exports2, module2) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperGetYMD = require_helperGetYMD();
    function helperGetYMDTime(date) {
      return helperGetDateTime(helperGetYMD(date));
    }
    module2.exports = helperGetYMDTime;
  }
});

// node_modules/xe-utils/getYearDay.js
var require_getYearDay = __commonJS({
  "node_modules/xe-utils/getYearDay.js"(exports2, module2) {
    var staticDayTime = require_staticDayTime();
    var staticStrFirst = require_staticStrFirst();
    var helperGetYMDTime = require_helperGetYMDTime();
    var getWhatYear = require_getWhatYear();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getYearDay(date) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return Math.floor((helperGetYMDTime(date) - helperGetYMDTime(getWhatYear(date, 0, staticStrFirst))) / staticDayTime) + 1;
      }
      return NaN;
    }
    module2.exports = getYearDay;
  }
});

// node_modules/xe-utils/padStart.js
var require_padStart = __commonJS({
  "node_modules/xe-utils/padStart.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var isUndefined = require_isUndefined();
    var helperStringRepeat = require_helperStringRepeat();
    function padStart(str, targetLength, padString) {
      var rest = toValueString(str);
      targetLength = targetLength >> 0;
      padString = isUndefined(padString) ? " " : "" + padString;
      if (rest.padStart) {
        return rest.padStart(targetLength, padString);
      }
      if (targetLength > rest.length) {
        targetLength -= rest.length;
        if (targetLength > padString.length) {
          padString += helperStringRepeat(padString, targetLength / padString.length);
        }
        return padString.slice(0, targetLength) + rest;
      }
      return rest;
    }
    module2.exports = padStart;
  }
});

// node_modules/xe-utils/toDateString.js
var require_toDateString = __commonJS({
  "node_modules/xe-utils/toDateString.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var helperStringUpperCase = require_helperStringUpperCase();
    var helperGetDateFullYear = require_helperGetDateFullYear();
    var helperGetDateMonth = require_helperGetDateMonth();
    var toStringDate = require_toStringDate();
    var getYearWeek = require_getYearWeek();
    var getYearDay = require_getYearDay();
    var assign3 = require_assign();
    var isValidDate = require_isValidDate();
    var isFunction2 = require_isFunction();
    var padStart = require_padStart();
    function handleCustomTemplate(date, formats6, match, value) {
      var format4 = formats6[match];
      if (format4) {
        if (isFunction2(format4)) {
          return format4(value, match, date);
        } else {
          return format4[value];
        }
      }
      return value;
    }
    var dateFormatRE = /\[([^\]]+)]|y{2,4}|M{1,2}|d{1,2}|H{1,2}|h{1,2}|m{1,2}|s{1,2}|S{1,3}|Z{1,2}|W{1,2}|D{1,3}|[aAeEq]/g;
    function toDateString(date, format4, options) {
      if (date) {
        date = toStringDate(date);
        if (isValidDate(date)) {
          var result = format4 || setupDefaults.parseDateFormat || setupDefaults.formatString;
          var hours = date.getHours();
          var apm = hours < 12 ? "am" : "pm";
          var formats6 = assign3({}, setupDefaults.parseDateRules || setupDefaults.formatStringMatchs, options ? options.formats : null);
          var fy2 = function(match, length) {
            return ("" + helperGetDateFullYear(date)).substr(4 - length);
          };
          var fM = function(match, length) {
            return padStart(helperGetDateMonth(date) + 1, length, "0");
          };
          var fd2 = function(match, length) {
            return padStart(date.getDate(), length, "0");
          };
          var fH = function(match, length) {
            return padStart(hours, length, "0");
          };
          var fh2 = function(match, length) {
            return padStart(hours <= 12 ? hours : hours - 12, length, "0");
          };
          var fm = function(match, length) {
            return padStart(date.getMinutes(), length, "0");
          };
          var fs2 = function(match, length) {
            return padStart(date.getSeconds(), length, "0");
          };
          var fS = function(match, length) {
            return padStart(date.getMilliseconds(), length, "0");
          };
          var fZ = function(match, length) {
            var zoneHours = date.getTimezoneOffset() / 60 * -1;
            return handleCustomTemplate(date, formats6, match, (zoneHours >= 0 ? "+" : "-") + padStart(zoneHours, 2, "0") + (length === 1 ? ":" : "") + "00");
          };
          var fW = function(match, length) {
            return padStart(handleCustomTemplate(date, formats6, match, getYearWeek(date, (options ? options.firstDay : null) || setupDefaults.firstDayOfWeek)), length, "0");
          };
          var fD = function(match, length) {
            return padStart(handleCustomTemplate(date, formats6, match, getYearDay(date)), length, "0");
          };
          var parseDates = {
            yyyy: fy2,
            yy: fy2,
            MM: fM,
            M: fM,
            dd: fd2,
            d: fd2,
            HH: fH,
            H: fH,
            hh: fh2,
            h: fh2,
            mm: fm,
            m: fm,
            ss: fs2,
            s: fs2,
            SSS: fS,
            S: fS,
            ZZ: fZ,
            Z: fZ,
            WW: fW,
            W: fW,
            DDD: fD,
            D: fD,
            a: function(match) {
              return handleCustomTemplate(date, formats6, match, apm);
            },
            A: function(match) {
              return handleCustomTemplate(date, formats6, match, helperStringUpperCase(apm));
            },
            e: function(match) {
              return handleCustomTemplate(date, formats6, match, date.getDay());
            },
            E: function(match) {
              return handleCustomTemplate(date, formats6, match, date.getDay());
            },
            q: function(match) {
              return handleCustomTemplate(date, formats6, match, Math.floor((helperGetDateMonth(date) + 3) / 3));
            }
          };
          return result.replace(dateFormatRE, function(match, skip) {
            return skip || (parseDates[match] ? parseDates[match](match, match.length) : match);
          });
        }
        return "Invalid Date";
      }
      return "";
    }
    module2.exports = toDateString;
  }
});

// node_modules/xe-utils/now.js
var require_now = __commonJS({
  "node_modules/xe-utils/now.js"(exports2, module2) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperNewDate = require_helperNewDate();
    var now2 = Date.now || function() {
      return helperGetDateTime(helperNewDate());
    };
    module2.exports = now2;
  }
});

// node_modules/xe-utils/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/xe-utils/timestamp.js"(exports2, module2) {
    var helperGetDateTime = require_helperGetDateTime();
    var now2 = require_now();
    var toStringDate = require_toStringDate();
    var isDate2 = require_isDate();
    var timestamp = function(str, format4) {
      if (str) {
        var date = toStringDate(str, format4);
        return isDate2(date) ? helperGetDateTime(date) : date;
      }
      return now2();
    };
    module2.exports = timestamp;
  }
});

// node_modules/xe-utils/isDateSame.js
var require_isDateSame = __commonJS({
  "node_modules/xe-utils/isDateSame.js"(exports2, module2) {
    var toDateString = require_toDateString();
    function isDateSame(date1, date2, format4) {
      if (date1 && date2) {
        date1 = toDateString(date1, format4);
        return date1 !== "Invalid Date" && date1 === toDateString(date2, format4);
      }
      return false;
    }
    module2.exports = isDateSame;
  }
});

// node_modules/xe-utils/getMonthWeek.js
var require_getMonthWeek = __commonJS({
  "node_modules/xe-utils/getMonthWeek.js"(exports2, module2) {
    var helperCreateGetDateWeek = require_helperCreateGetDateWeek();
    var getMonthWeek = helperCreateGetDateWeek(function(targetDate) {
      return new Date(targetDate.getFullYear(), targetDate.getMonth(), 1);
    });
    module2.exports = getMonthWeek;
  }
});

// node_modules/xe-utils/getDayOfYear.js
var require_getDayOfYear = __commonJS({
  "node_modules/xe-utils/getDayOfYear.js"(exports2, module2) {
    var getWhatYear = require_getWhatYear();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var isLeapYear = require_isLeapYear();
    function getDayOfYear(date, year) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return isLeapYear(getWhatYear(date, year)) ? 366 : 365;
      }
      return NaN;
    }
    module2.exports = getDayOfYear;
  }
});

// node_modules/xe-utils/getDayOfMonth.js
var require_getDayOfMonth = __commonJS({
  "node_modules/xe-utils/getDayOfMonth.js"(exports2, module2) {
    var staticDayTime = require_staticDayTime();
    var staticStrFirst = require_staticStrFirst();
    var staticStrLast = require_staticStrLast();
    var helperGetDateTime = require_helperGetDateTime();
    var getWhatMonth = require_getWhatMonth();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    function getDayOfMonth(date, month) {
      date = toStringDate(date);
      if (isValidDate(date)) {
        return Math.floor((helperGetDateTime(getWhatMonth(date, month, staticStrLast)) - helperGetDateTime(getWhatMonth(date, month, staticStrFirst))) / staticDayTime) + 1;
      }
      return NaN;
    }
    module2.exports = getDayOfMonth;
  }
});

// node_modules/xe-utils/getDateDiff.js
var require_getDateDiff = __commonJS({
  "node_modules/xe-utils/getDateDiff.js"(exports2, module2) {
    var helperGetDateTime = require_helperGetDateTime();
    var helperNewDate = require_helperNewDate();
    var toStringDate = require_toStringDate();
    var isValidDate = require_isValidDate();
    var dateDiffRules = [
      ["yyyy", 31536e6],
      ["MM", 2592e6],
      ["dd", 864e5],
      ["HH", 36e5],
      ["mm", 6e4],
      ["ss", 1e3],
      ["S", 0]
    ];
    function getDateDiff(startDate, endDate) {
      var startTime, endTime, item, diffTime, len, index2;
      var result = { done: false, time: 0 };
      startDate = toStringDate(startDate);
      endDate = endDate ? toStringDate(endDate) : helperNewDate();
      if (isValidDate(startDate) && isValidDate(endDate)) {
        startTime = helperGetDateTime(startDate);
        endTime = helperGetDateTime(endDate);
        if (startTime < endTime) {
          diffTime = result.time = endTime - startTime;
          result.done = true;
          for (index2 = 0, len = dateDiffRules.length; index2 < len; index2++) {
            item = dateDiffRules[index2];
            if (diffTime >= item[1]) {
              if (index2 === len - 1) {
                result[item[0]] = diffTime || 0;
              } else {
                result[item[0]] = Math.floor(diffTime / item[1]);
                diffTime -= result[item[0]] * item[1];
              }
            } else {
              result[item[0]] = 0;
            }
          }
        }
      }
      return result;
    }
    module2.exports = getDateDiff;
  }
});

// node_modules/xe-utils/padEnd.js
var require_padEnd = __commonJS({
  "node_modules/xe-utils/padEnd.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var isUndefined = require_isUndefined();
    var helperStringRepeat = require_helperStringRepeat();
    function padEnd(str, targetLength, padString) {
      var rest = toValueString(str);
      targetLength = targetLength >> 0;
      padString = isUndefined(padString) ? " " : "" + padString;
      if (rest.padEnd) {
        return rest.padEnd(targetLength, padString);
      }
      if (targetLength > rest.length) {
        targetLength -= rest.length;
        if (targetLength > padString.length) {
          padString += helperStringRepeat(padString, targetLength / padString.length);
        }
        return rest + padString.slice(0, targetLength);
      }
      return rest;
    }
    module2.exports = padEnd;
  }
});

// node_modules/xe-utils/repeat.js
var require_repeat = __commonJS({
  "node_modules/xe-utils/repeat.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var helperStringRepeat = require_helperStringRepeat();
    function repeat(str, count) {
      return helperStringRepeat(toValueString(str), count);
    }
    module2.exports = repeat;
  }
});

// node_modules/xe-utils/trimRight.js
var require_trimRight = __commonJS({
  "node_modules/xe-utils/trimRight.js"(exports2, module2) {
    var toValueString = require_toValueString();
    function trimRight(str) {
      return str && str.trimRight ? str.trimRight() : toValueString(str).replace(/[\s\uFEFF\xA0]+$/g, "");
    }
    module2.exports = trimRight;
  }
});

// node_modules/xe-utils/trimLeft.js
var require_trimLeft = __commonJS({
  "node_modules/xe-utils/trimLeft.js"(exports2, module2) {
    var toValueString = require_toValueString();
    function trimLeft(str) {
      return str && str.trimLeft ? str.trimLeft() : toValueString(str).replace(/^[\s\uFEFF\xA0]+/g, "");
    }
    module2.exports = trimLeft;
  }
});

// node_modules/xe-utils/trim.js
var require_trim = __commonJS({
  "node_modules/xe-utils/trim.js"(exports2, module2) {
    var trimRight = require_trimRight();
    var trimLeft = require_trimLeft();
    function trim(str) {
      return str && str.trim ? str.trim() : trimRight(trimLeft(str));
    }
    module2.exports = trim;
  }
});

// node_modules/xe-utils/staticEscapeMap.js
var require_staticEscapeMap = __commonJS({
  "node_modules/xe-utils/staticEscapeMap.js"(exports2, module2) {
    var staticEscapeMap = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
    module2.exports = staticEscapeMap;
  }
});

// node_modules/xe-utils/helperFormatEscaper.js
var require_helperFormatEscaper = __commonJS({
  "node_modules/xe-utils/helperFormatEscaper.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var keys = require_keys();
    function helperFormatEscaper(dataMap) {
      var replaceRegexp = new RegExp("(?:" + keys(dataMap).join("|") + ")", "g");
      return function(str) {
        return toValueString(str).replace(replaceRegexp, function(match) {
          return dataMap[match];
        });
      };
    }
    module2.exports = helperFormatEscaper;
  }
});

// node_modules/xe-utils/escape.js
var require_escape = __commonJS({
  "node_modules/xe-utils/escape.js"(exports2, module2) {
    var staticEscapeMap = require_staticEscapeMap();
    var helperFormatEscaper = require_helperFormatEscaper();
    var escape2 = helperFormatEscaper(staticEscapeMap);
    module2.exports = escape2;
  }
});

// node_modules/xe-utils/unescape.js
var require_unescape = __commonJS({
  "node_modules/xe-utils/unescape.js"(exports2, module2) {
    var staticEscapeMap = require_staticEscapeMap();
    var helperFormatEscaper = require_helperFormatEscaper();
    var each = require_each();
    var unescapeMap = {};
    each(staticEscapeMap, function(item, key) {
      unescapeMap[staticEscapeMap[key]] = key;
    });
    var unescape = helperFormatEscaper(unescapeMap);
    module2.exports = unescape;
  }
});

// node_modules/xe-utils/helperStringSubstring.js
var require_helperStringSubstring = __commonJS({
  "node_modules/xe-utils/helperStringSubstring.js"(exports2, module2) {
    function helperStringSubstring(str, start, end) {
      return str.substring(start, end);
    }
    module2.exports = helperStringSubstring;
  }
});

// node_modules/xe-utils/helperStringLowerCase.js
var require_helperStringLowerCase = __commonJS({
  "node_modules/xe-utils/helperStringLowerCase.js"(exports2, module2) {
    function helperStringLowerCase(str) {
      return str.toLowerCase();
    }
    module2.exports = helperStringLowerCase;
  }
});

// node_modules/xe-utils/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/xe-utils/camelCase.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var helperStringSubstring = require_helperStringSubstring();
    var helperStringUpperCase = require_helperStringUpperCase();
    var helperStringLowerCase = require_helperStringLowerCase();
    var camelCacheMaps = {};
    function camelCase(str) {
      str = toValueString(str);
      if (camelCacheMaps[str]) {
        return camelCacheMaps[str];
      }
      var strLen = str.length;
      var rest = str.replace(/([-]+)/g, function(text, flag, index2) {
        return index2 && index2 + flag.length < strLen ? "-" : "";
      });
      strLen = rest.length;
      rest = rest.replace(/([A-Z]+)/g, function(text, upper, index2) {
        var upperLen = upper.length;
        upper = helperStringLowerCase(upper);
        if (index2) {
          if (upperLen > 2 && index2 + upperLen < strLen) {
            return helperStringUpperCase(helperStringSubstring(upper, 0, 1)) + helperStringSubstring(upper, 1, upperLen - 1) + helperStringUpperCase(helperStringSubstring(upper, upperLen - 1, upperLen));
          }
          return helperStringUpperCase(helperStringSubstring(upper, 0, 1)) + helperStringSubstring(upper, 1, upperLen);
        } else {
          if (upperLen > 1 && index2 + upperLen < strLen) {
            return helperStringSubstring(upper, 0, upperLen - 1) + helperStringUpperCase(helperStringSubstring(upper, upperLen - 1, upperLen));
          }
        }
        return upper;
      }).replace(/(-[a-zA-Z])/g, function(text, upper) {
        return helperStringUpperCase(helperStringSubstring(upper, 1, upper.length));
      });
      camelCacheMaps[str] = rest;
      return rest;
    }
    module2.exports = camelCase;
  }
});

// node_modules/xe-utils/kebabCase.js
var require_kebabCase = __commonJS({
  "node_modules/xe-utils/kebabCase.js"(exports2, module2) {
    var toValueString = require_toValueString();
    var helperStringSubstring = require_helperStringSubstring();
    var helperStringLowerCase = require_helperStringLowerCase();
    var kebabCacheMaps = {};
    function kebabCase(str) {
      str = toValueString(str);
      if (kebabCacheMaps[str]) {
        return kebabCacheMaps[str];
      }
      if (/^[A-Z]+$/.test(str)) {
        return helperStringLowerCase(str);
      }
      var rest = str.replace(/^([a-z])([A-Z]+)([a-z]+)$/, function(text, prevLower, upper, nextLower) {
        var upperLen = upper.length;
        if (upperLen > 1) {
          return prevLower + "-" + helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper, upperLen - 1, upperLen)) + nextLower;
        }
        return helperStringLowerCase(prevLower + "-" + upper + nextLower);
      }).replace(/^([A-Z]+)([a-z]+)?$/, function(text, upper, nextLower) {
        var upperLen = upper.length;
        return helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1) + "-" + helperStringSubstring(upper, upperLen - 1, upperLen) + (nextLower || ""));
      }).replace(/([a-z]?)([A-Z]+)([a-z]?)/g, function(text, prevLower, upper, nextLower, index2) {
        var upperLen = upper.length;
        if (upperLen > 1) {
          if (prevLower) {
            prevLower += "-";
          }
          if (nextLower) {
            return (prevLower || "") + helperStringLowerCase(helperStringSubstring(upper, 0, upperLen - 1)) + "-" + helperStringLowerCase(helperStringSubstring(upper, upperLen - 1, upperLen)) + nextLower;
          }
        }
        return (prevLower || "") + (index2 ? "-" : "") + helperStringLowerCase(upper) + (nextLower || "");
      });
      rest = rest.replace(/([-]+)/g, function(text, flag, index2) {
        return index2 && index2 + flag.length < rest.length ? "-" : "";
      });
      kebabCacheMaps[str] = rest;
      return rest;
    }
    module2.exports = kebabCase;
  }
});

// node_modules/xe-utils/startsWith.js
var require_startsWith = __commonJS({
  "node_modules/xe-utils/startsWith.js"(exports2, module2) {
    var toValueString = require_toValueString();
    function startsWith(str, val, startIndex) {
      var rest = toValueString(str);
      return (arguments.length === 1 ? rest : rest.substring(startIndex)).indexOf(val) === 0;
    }
    module2.exports = startsWith;
  }
});

// node_modules/xe-utils/endsWith.js
var require_endsWith = __commonJS({
  "node_modules/xe-utils/endsWith.js"(exports2, module2) {
    var toValueString = require_toValueString();
    function endsWith(str, val, startIndex) {
      var rest = toValueString(str);
      var argsLen = arguments.length;
      return argsLen > 1 && (argsLen > 2 ? rest.substring(0, startIndex).indexOf(val) === startIndex - 1 : rest.indexOf(val) === rest.length - 1);
    }
    module2.exports = endsWith;
  }
});

// node_modules/xe-utils/template.js
var require_template = __commonJS({
  "node_modules/xe-utils/template.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var toValueString = require_toValueString();
    var trim = require_trim();
    var get = require_get();
    function template(str, args, options) {
      return toValueString(str).replace((options || setupDefaults).tmplRE || /\{{2}([.\w[\]\s]+)\}{2}/g, function(match, key) {
        return get(args, trim(key));
      });
    }
    module2.exports = template;
  }
});

// node_modules/xe-utils/toFormatString.js
var require_toFormatString = __commonJS({
  "node_modules/xe-utils/toFormatString.js"(exports2, module2) {
    var template = require_template();
    function toFormatString(str, obj) {
      return template(str, obj, { tmplRE: /\{([.\w[\]\s]+)\}/g });
    }
    module2.exports = toFormatString;
  }
});

// node_modules/xe-utils/noop.js
var require_noop = __commonJS({
  "node_modules/xe-utils/noop.js"(exports2, module2) {
    function noop() {
    }
    module2.exports = noop;
  }
});

// node_modules/xe-utils/bind.js
var require_bind = __commonJS({
  "node_modules/xe-utils/bind.js"(exports2, module2) {
    var slice = require_slice();
    function bind(callback, context) {
      var args = slice(arguments, 2);
      return function() {
        return callback.apply(context, slice(arguments).concat(args));
      };
    }
    module2.exports = bind;
  }
});

// node_modules/xe-utils/once.js
var require_once = __commonJS({
  "node_modules/xe-utils/once.js"(exports2, module2) {
    var slice = require_slice();
    function once(callback, context) {
      var done = false;
      var rest = null;
      var args = slice(arguments, 2);
      return function() {
        if (done) {
          return rest;
        }
        rest = callback.apply(context, slice(arguments).concat(args));
        done = true;
        return rest;
      };
    }
    module2.exports = once;
  }
});

// node_modules/xe-utils/after.js
var require_after = __commonJS({
  "node_modules/xe-utils/after.js"(exports2, module2) {
    var slice = require_slice();
    function after(count, callback, context) {
      var runCount = 0;
      var rests = [];
      return function() {
        var args = arguments;
        runCount++;
        if (runCount <= count) {
          rests.push(args[0]);
        }
        if (runCount >= count) {
          callback.apply(context, [rests].concat(slice(args)));
        }
      };
    }
    module2.exports = after;
  }
});

// node_modules/xe-utils/before.js
var require_before = __commonJS({
  "node_modules/xe-utils/before.js"(exports2, module2) {
    var slice = require_slice();
    function before(count, callback, context) {
      var runCount = 0;
      var rests = [];
      context = context || this;
      return function() {
        var args = arguments;
        runCount++;
        if (runCount < count) {
          rests.push(args[0]);
          callback.apply(context, [rests].concat(slice(args)));
        }
      };
    }
    module2.exports = before;
  }
});

// node_modules/xe-utils/throttle.js
var require_throttle = __commonJS({
  "node_modules/xe-utils/throttle.js"(exports2, module2) {
    function throttle2(callback, wait, options) {
      var args = null;
      var context = null;
      var opts = options || {};
      var runFlag = false;
      var timeout = null;
      var optLeading = "leading" in opts ? opts.leading : true;
      var optTrailing = "trailing" in opts ? opts.trailing : false;
      var gcFn = function() {
        args = null;
        context = null;
      };
      var runFn = function() {
        runFlag = true;
        callback.apply(context, args);
        timeout = setTimeout(endFn, wait);
        gcFn();
      };
      var endFn = function() {
        timeout = null;
        if (!runFlag && optTrailing === true) {
          runFn();
        }
      };
      var cancelFn = function() {
        var rest = timeout !== null;
        if (rest) {
          clearTimeout(timeout);
        }
        gcFn();
        timeout = null;
        runFlag = false;
        return rest;
      };
      var throttled = function() {
        args = arguments;
        context = this;
        runFlag = false;
        if (timeout === null) {
          if (optLeading === true) {
            runFn();
          } else if (optTrailing === true) {
            timeout = setTimeout(endFn, wait);
          }
        }
      };
      throttled.cancel = cancelFn;
      return throttled;
    }
    module2.exports = throttle2;
  }
});

// node_modules/xe-utils/debounce.js
var require_debounce = __commonJS({
  "node_modules/xe-utils/debounce.js"(exports2, module2) {
    function debounce(callback, wait, options) {
      var args = null;
      var context = null;
      var opts = options || {};
      var runFlag = false;
      var timeout = null;
      var isLeading = typeof options === "boolean";
      var optLeading = "leading" in opts ? opts.leading : isLeading;
      var optTrailing = "trailing" in opts ? opts.trailing : !isLeading;
      var gcFn = function() {
        args = null;
        context = null;
      };
      var runFn = function() {
        runFlag = true;
        callback.apply(context, args);
        gcFn();
      };
      var endFn = function() {
        if (optLeading === true) {
          timeout = null;
        }
        if (!runFlag && optTrailing === true) {
          runFn();
        }
      };
      var cancelFn = function() {
        var rest = timeout !== null;
        if (rest) {
          clearTimeout(timeout);
        }
        gcFn();
        timeout = null;
        runFlag = false;
        return rest;
      };
      var debounced = function() {
        runFlag = false;
        args = arguments;
        context = this;
        if (timeout === null) {
          if (optLeading === true) {
            runFn();
          }
        } else {
          clearTimeout(timeout);
        }
        timeout = setTimeout(endFn, wait);
      };
      debounced.cancel = cancelFn;
      return debounced;
    }
    module2.exports = debounce;
  }
});

// node_modules/xe-utils/delay.js
var require_delay = __commonJS({
  "node_modules/xe-utils/delay.js"(exports2, module2) {
    var slice = require_slice();
    function delay(callback, wait) {
      var args = slice(arguments, 2);
      var context = this;
      return setTimeout(function() {
        callback.apply(context, args);
      }, wait);
    }
    module2.exports = delay;
  }
});

// node_modules/xe-utils/staticDecodeURIComponent.js
var require_staticDecodeURIComponent = __commonJS({
  "node_modules/xe-utils/staticDecodeURIComponent.js"(exports2, module2) {
    var staticDecodeURIComponent = decodeURIComponent;
    module2.exports = staticDecodeURIComponent;
  }
});

// node_modules/xe-utils/unserialize.js
var require_unserialize = __commonJS({
  "node_modules/xe-utils/unserialize.js"(exports2, module2) {
    var staticDecodeURIComponent = require_staticDecodeURIComponent();
    var arrayEach = require_arrayEach();
    var isString3 = require_isString();
    function unserialize(str) {
      var items;
      var result = {};
      if (str && isString3(str)) {
        arrayEach(str.split("&"), function(param) {
          items = param.split("=");
          result[staticDecodeURIComponent(items[0])] = staticDecodeURIComponent(items[1] || "");
        });
      }
      return result;
    }
    module2.exports = unserialize;
  }
});

// node_modules/xe-utils/staticEncodeURIComponent.js
var require_staticEncodeURIComponent = __commonJS({
  "node_modules/xe-utils/staticEncodeURIComponent.js"(exports2, module2) {
    var staticEncodeURIComponent = encodeURIComponent;
    module2.exports = staticEncodeURIComponent;
  }
});

// node_modules/xe-utils/serialize.js
var require_serialize = __commonJS({
  "node_modules/xe-utils/serialize.js"(exports2, module2) {
    var staticEncodeURIComponent = require_staticEncodeURIComponent();
    var each = require_each();
    var isArray2 = require_isArray();
    var isNull = require_isNull();
    var isUndefined = require_isUndefined();
    var isPlainObject2 = require_isPlainObject();
    function stringifyParams(resultVal, resultKey, isArr) {
      var _arr;
      var result = [];
      each(resultVal, function(item, key) {
        _arr = isArray2(item);
        if (isPlainObject2(item) || _arr) {
          result = result.concat(stringifyParams(item, resultKey + "[" + key + "]", _arr));
        } else {
          result.push(staticEncodeURIComponent(resultKey + "[" + (isArr ? "" : key) + "]") + "=" + staticEncodeURIComponent(isNull(item) ? "" : item));
        }
      });
      return result;
    }
    function serialize(query) {
      var _arr;
      var params = [];
      each(query, function(item, key) {
        if (!isUndefined(item)) {
          _arr = isArray2(item);
          if (isPlainObject2(item) || _arr) {
            params = params.concat(stringifyParams(item, key, _arr));
          } else {
            params.push(staticEncodeURIComponent(key) + "=" + staticEncodeURIComponent(isNull(item) ? "" : item));
          }
        }
      });
      return params.join("&").replace(/%20/g, "+");
    }
    module2.exports = serialize;
  }
});

// node_modules/xe-utils/staticLocation.js
var require_staticLocation = __commonJS({
  "node_modules/xe-utils/staticLocation.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticLocation = typeof location === staticStrUndefined ? 0 : location;
    module2.exports = staticLocation;
  }
});

// node_modules/xe-utils/helperGetLocatOrigin.js
var require_helperGetLocatOrigin = __commonJS({
  "node_modules/xe-utils/helperGetLocatOrigin.js"(exports2, module2) {
    var staticLocation = require_staticLocation();
    function helperGetLocatOrigin() {
      return staticLocation ? staticLocation.origin || staticLocation.protocol + "//" + staticLocation.host : "";
    }
    module2.exports = helperGetLocatOrigin;
  }
});

// node_modules/xe-utils/parseUrl.js
var require_parseUrl = __commonJS({
  "node_modules/xe-utils/parseUrl.js"(exports2, module2) {
    var staticLocation = require_staticLocation();
    var unserialize = require_unserialize();
    var helperGetLocatOrigin = require_helperGetLocatOrigin();
    function parseURLQuery(uri) {
      return unserialize(uri.split("?")[1] || "");
    }
    function parseUrl(url) {
      var hashs, portText, searchs, parsed;
      var href = "" + url;
      if (href.indexOf("//") === 0) {
        href = (staticLocation ? staticLocation.protocol : "") + href;
      } else if (href.indexOf("/") === 0) {
        href = helperGetLocatOrigin() + href;
      }
      searchs = href.replace(/#.*/, "").match(/(\?.*)/);
      parsed = {
        href,
        hash: "",
        host: "",
        hostname: "",
        protocol: "",
        port: "",
        search: searchs && searchs[1] && searchs[1].length > 1 ? searchs[1] : ""
      };
      parsed.path = href.replace(/^([a-z0-9.+-]*:)\/\//, function(text, protocol) {
        parsed.protocol = protocol;
        return "";
      }).replace(/^([a-z0-9.+-]*)(:\d+)?\/?/, function(text, hostname, port) {
        portText = port || "";
        parsed.port = portText.replace(":", "");
        parsed.hostname = hostname;
        parsed.host = hostname + portText;
        return "/";
      }).replace(/(#.*)/, function(text, hash) {
        parsed.hash = hash.length > 1 ? hash : "";
        return "";
      });
      hashs = parsed.hash.match(/#((.*)\?|(.*))/);
      parsed.pathname = parsed.path.replace(/(\?|#.*).*/, "");
      parsed.origin = parsed.protocol + "//" + parsed.host;
      parsed.hashKey = hashs ? hashs[2] || hashs[1] || "" : "";
      parsed.hashQuery = parseURLQuery(parsed.hash);
      parsed.searchQuery = parseURLQuery(parsed.search);
      return parsed;
    }
    module2.exports = parseUrl;
  }
});

// node_modules/xe-utils/getBaseURL.js
var require_getBaseURL = __commonJS({
  "node_modules/xe-utils/getBaseURL.js"(exports2, module2) {
    var staticLocation = require_staticLocation();
    var helperGetLocatOrigin = require_helperGetLocatOrigin();
    var lastIndexOf = require_lastIndexOf();
    function getBaseURL() {
      if (staticLocation) {
        var pathname = staticLocation.pathname;
        var lastIndex = lastIndexOf(pathname, "/") + 1;
        return helperGetLocatOrigin() + (lastIndex === pathname.length ? pathname : pathname.substring(0, lastIndex));
      }
      return "";
    }
    module2.exports = getBaseURL;
  }
});

// node_modules/xe-utils/locat.js
var require_locat = __commonJS({
  "node_modules/xe-utils/locat.js"(exports2, module2) {
    var staticLocation = require_staticLocation();
    var parseUrl = require_parseUrl();
    function locat() {
      return staticLocation ? parseUrl(staticLocation.href) : {};
    }
    module2.exports = locat;
  }
});

// node_modules/xe-utils/cookie.js
var require_cookie = __commonJS({
  "node_modules/xe-utils/cookie.js"(exports2, module2) {
    var setupDefaults = require_setupDefaults();
    var staticDocument = require_staticDocument();
    var staticDecodeURIComponent = require_staticDecodeURIComponent();
    var staticEncodeURIComponent = require_staticEncodeURIComponent();
    var isArray2 = require_isArray();
    var isObject3 = require_isObject();
    var isDate2 = require_isDate();
    var isUndefined = require_isUndefined();
    var includes = require_includes();
    var keys = require_keys();
    var assign3 = require_assign();
    var arrayEach = require_arrayEach();
    var helperNewDate = require_helperNewDate();
    var helperGetDateTime = require_helperGetDateTime();
    var getWhatYear = require_getWhatYear();
    var getWhatMonth = require_getWhatMonth();
    var getWhatDay = require_getWhatDay();
    function toCookieUnitTime(unit, expires) {
      var num = parseFloat(expires);
      var nowdate = helperNewDate();
      var time = helperGetDateTime(nowdate);
      switch (unit) {
        case "y":
          return helperGetDateTime(getWhatYear(nowdate, num));
        case "M":
          return helperGetDateTime(getWhatMonth(nowdate, num));
        case "d":
          return helperGetDateTime(getWhatDay(nowdate, num));
        case "h":
        case "H":
          return time + num * 60 * 60 * 1e3;
        case "m":
          return time + num * 60 * 1e3;
        case "s":
          return time + num * 1e3;
      }
      return time;
    }
    function toCookieUTCString(date) {
      return (isDate2(date) ? date : new Date(date)).toUTCString();
    }
    function cookie(name, value, options) {
      if (staticDocument) {
        var opts, expires, values, result, cookies, keyIndex;
        var inserts = [];
        var args = arguments;
        if (isArray2(name)) {
          inserts = name;
        } else if (args.length > 1) {
          inserts = [assign3({ name, value }, options)];
        } else if (isObject3(name)) {
          inserts = [name];
        }
        if (inserts.length > 0) {
          arrayEach(inserts, function(obj) {
            opts = assign3({}, setupDefaults.cookies, obj);
            values = [];
            if (opts.name) {
              expires = opts.expires;
              values.push(staticEncodeURIComponent(opts.name) + "=" + staticEncodeURIComponent(isObject3(opts.value) ? JSON.stringify(opts.value) : opts.value));
              if (expires) {
                if (isNaN(expires)) {
                  expires = expires.replace(/^([0-9]+)(y|M|d|H|h|m|s)$/, function(text, num, unit) {
                    return toCookieUTCString(toCookieUnitTime(unit, num));
                  });
                } else if (/^[0-9]{11,13}$/.test(expires) || isDate2(expires)) {
                  expires = toCookieUTCString(expires);
                } else {
                  expires = toCookieUTCString(toCookieUnitTime("d", expires));
                }
                opts.expires = expires;
              }
              arrayEach(["expires", "path", "domain", "secure"], function(key) {
                if (!isUndefined(opts[key])) {
                  values.push(opts[key] && key === "secure" ? key : key + "=" + opts[key]);
                }
              });
            }
            staticDocument.cookie = values.join("; ");
          });
          return true;
        } else {
          result = {};
          cookies = staticDocument.cookie;
          if (cookies) {
            arrayEach(cookies.split("; "), function(val) {
              keyIndex = val.indexOf("=");
              result[staticDecodeURIComponent(val.substring(0, keyIndex))] = staticDecodeURIComponent(val.substring(keyIndex + 1) || "");
            });
          }
          return args.length === 1 ? result[name] : result;
        }
      }
      return false;
    }
    function hasCookieItem(value) {
      return includes(cookieKeys(), value);
    }
    function getCookieItem(name) {
      return cookie(name);
    }
    function setCookieItem(name, value, options) {
      cookie(name, value, options);
      return cookie;
    }
    function removeCookieItem(name, options) {
      cookie(name, "", assign3({ expires: -1 }, setupDefaults.cookies, options));
    }
    function cookieKeys() {
      return keys(cookie());
    }
    function cookieJson() {
      return cookie();
    }
    assign3(cookie, {
      has: hasCookieItem,
      set: setCookieItem,
      setItem: setCookieItem,
      get: getCookieItem,
      getItem: getCookieItem,
      remove: removeCookieItem,
      removeItem: removeCookieItem,
      keys: cookieKeys,
      getJSON: cookieJson
    });
    module2.exports = cookie;
  }
});

// node_modules/xe-utils/browse.js
var require_browse = __commonJS({
  "node_modules/xe-utils/browse.js"(exports2, module2) {
    var staticStrUndefined = require_staticStrUndefined();
    var staticDocument = require_staticDocument();
    var staticWindow = require_staticWindow();
    var assign3 = require_assign();
    var arrayEach = require_arrayEach();
    function isBrowseStorage(storage) {
      try {
        var testKey = "__xe_t";
        storage.setItem(testKey, 1);
        storage.removeItem(testKey);
        return true;
      } catch (e16) {
        return false;
      }
    }
    function isBrowseType(type) {
      return navigator.userAgent.indexOf(type) > -1;
    }
    function browse4() {
      var $body, isChrome, isEdge;
      var isMobile = false;
      var isLocalStorage = false;
      var isSessionStorage = false;
      var result = {
        isNode: false,
        isMobile,
        isPC: false,
        isDoc: !!staticDocument
      };
      if (!staticWindow && typeof process !== staticStrUndefined) {
        result.isNode = true;
      } else {
        isEdge = isBrowseType("Edge");
        isChrome = isBrowseType("Chrome");
        isMobile = /(Android|webOS|iPhone|iPad|iPod|SymbianOS|BlackBerry|Windows Phone)/.test(navigator.userAgent);
        if (result.isDoc) {
          $body = staticDocument.body || staticDocument.documentElement;
          arrayEach(["webkit", "khtml", "moz", "ms", "o"], function(core) {
            result["-" + core] = !!$body[core + "MatchesSelector"];
          });
        }
        try {
          isLocalStorage = isBrowseStorage(staticWindow.localStorage);
        } catch (e16) {
        }
        try {
          isSessionStorage = isBrowseStorage(staticWindow.sessionStorage);
        } catch (e16) {
        }
        assign3(result, {
          edge: isEdge,
          firefox: isBrowseType("Firefox"),
          msie: !isEdge && result["-ms"],
          safari: !isChrome && !isEdge && isBrowseType("Safari"),
          isMobile,
          isPC: !isMobile,
          isLocalStorage,
          isSessionStorage
        });
      }
      return result;
    }
    module2.exports = browse4;
  }
});

// node_modules/xe-utils/index.js
var require_xe_utils = __commonJS({
  "node_modules/xe-utils/index.js"(exports2, module2) {
    "use strict";
    var XEUtils156 = require_ctor();
    var assign3 = require_assign();
    var objectEach = require_objectEach();
    var lastObjectEach = require_lastObjectEach();
    var objectMap = require_objectMap();
    var merge = require_merge();
    var map = require_map();
    var some = require_some();
    var every = require_every();
    var includeArrays = require_includeArrays();
    var arrayEach = require_arrayEach();
    var lastArrayEach = require_lastArrayEach();
    var uniq = require_uniq();
    var union = require_union();
    var toArray2 = require_toArray();
    var sortBy = require_sortBy();
    var orderBy = require_orderBy();
    var shuffle = require_shuffle();
    var sample = require_sample();
    var slice = require_slice();
    var filter = require_filter();
    var findKey = require_findKey();
    var includes = require_includes();
    var find2 = require_find();
    var findLast = require_findLast();
    var reduce = require_reduce();
    var copyWithin = require_copyWithin();
    var chunk = require_chunk();
    var zip = require_zip();
    var unzip = require_unzip();
    var zipObject = require_zipObject();
    var flatten = require_flatten();
    var pluck = require_pluck();
    var invoke = require_invoke();
    var toArrayTree = require_toArrayTree();
    var toTreeArray = require_toTreeArray();
    var findTree = require_findTree();
    var eachTree = require_eachTree();
    var mapTree = require_mapTree();
    var filterTree = require_filterTree();
    var searchTree = require_searchTree();
    var arrayIndexOf = require_arrayIndexOf();
    var arrayLastIndexOf = require_arrayLastIndexOf();
    var hasOwnProp = require_hasOwnProp();
    var isArray2 = require_isArray();
    var isNull = require_isNull();
    var isNumberNaN = require_isNaN();
    var isUndefined = require_isUndefined();
    var isFunction2 = require_isFunction();
    var isObject3 = require_isObject();
    var isString3 = require_isString();
    var isPlainObject2 = require_isPlainObject();
    var isLeapYear = require_isLeapYear();
    var isDate2 = require_isDate();
    var eqNull = require_eqNull();
    var each = require_each();
    var forOf = require_forOf();
    var lastForOf = require_lastForOf();
    var indexOf = require_indexOf();
    var lastIndexOf = require_lastIndexOf();
    var keys = require_keys();
    var values = require_values();
    var clone2 = require_clone();
    var getSize = require_getSize();
    var lastEach = require_lastEach();
    var remove = require_remove();
    var clear = require_clear();
    var isNumberFinite = require_isFinite();
    var isFloat = require_isFloat();
    var isInteger = require_isInteger();
    var isBoolean2 = require_isBoolean();
    var isNumber2 = require_isNumber();
    var isRegExp2 = require_isRegExp();
    var isError = require_isError();
    var isTypeError = require_isTypeError();
    var isEmpty = require_isEmpty();
    var isSymbol = require_isSymbol();
    var isArguments = require_isArguments();
    var isElement = require_isElement();
    var isDocument = require_isDocument();
    var isWindow = require_isWindow();
    var isFormData = require_isFormData();
    var isMap = require_isMap();
    var isWeakMap = require_isWeakMap();
    var isSet = require_isSet();
    var isWeakSet = require_isWeakSet();
    var isMatch = require_isMatch();
    var isEqual = require_isEqual();
    var isEqualWith = require_isEqualWith();
    var getType = require_getType();
    var uniqueId = require_uniqueId();
    var findIndexOf = require_findIndexOf();
    var findLastIndexOf = require_findLastIndexOf();
    var toStringJSON = require_toStringJSON();
    var toJSONString = require_toJSONString();
    var entries = require_entries();
    var pick = require_pick();
    var omit = require_omit();
    var first = require_first();
    var last = require_last();
    var has = require_has();
    var get = require_get();
    var set = require_set();
    var groupBy = require_groupBy();
    var countBy = require_countBy();
    var range = require_range();
    var destructuring = require_destructuring();
    var random = require_random();
    var max = require_max();
    var min = require_min();
    var commafy = require_commafy();
    var round = require_round();
    var ceil = require_ceil();
    var floor = require_floor();
    var toFixed = require_toFixed();
    var toInteger = require_toInteger();
    var toNumber = require_toNumber();
    var toNumberString = require_toNumberString();
    var add = require_add();
    var subtract = require_subtract();
    var multiply = require_multiply();
    var divide = require_divide();
    var sum = require_sum();
    var mean = require_mean();
    var getWhatYear = require_getWhatYear();
    var getWhatQuarter = require_getWhatQuarter();
    var getWhatMonth = require_getWhatMonth();
    var getWhatDay = require_getWhatDay();
    var toStringDate = require_toStringDate();
    var toDateString = require_toDateString();
    var now2 = require_now();
    var timestamp = require_timestamp();
    var isValidDate = require_isValidDate();
    var isDateSame = require_isDateSame();
    var getWhatWeek = require_getWhatWeek();
    var getYearDay = require_getYearDay();
    var getYearWeek = require_getYearWeek();
    var getMonthWeek = require_getMonthWeek();
    var getDayOfYear = require_getDayOfYear();
    var getDayOfMonth = require_getDayOfMonth();
    var getDateDiff = require_getDateDiff();
    var padEnd = require_padEnd();
    var padStart = require_padStart();
    var repeat = require_repeat();
    var trim = require_trim();
    var trimRight = require_trimRight();
    var trimLeft = require_trimLeft();
    var escape2 = require_escape();
    var unescape = require_unescape();
    var camelCase = require_camelCase();
    var kebabCase = require_kebabCase();
    var startsWith = require_startsWith();
    var endsWith = require_endsWith();
    var template = require_template();
    var toFormatString = require_toFormatString();
    var toValueString = require_toValueString();
    var noop = require_noop();
    var property = require_property();
    var bind = require_bind();
    var once = require_once();
    var after = require_after();
    var before = require_before();
    var throttle2 = require_throttle();
    var debounce = require_debounce();
    var delay = require_delay();
    var unserialize = require_unserialize();
    var serialize = require_serialize();
    var parseUrl = require_parseUrl();
    var getBaseURL = require_getBaseURL();
    var locat = require_locat();
    var cookie = require_cookie();
    var browse4 = require_browse();
    assign3(XEUtils156, {
      // object
      assign: assign3,
      objectEach,
      lastObjectEach,
      objectMap,
      merge,
      // array
      uniq,
      union,
      sortBy,
      orderBy,
      shuffle,
      sample,
      some,
      every,
      slice,
      filter,
      find: find2,
      findLast,
      findKey,
      includes,
      arrayIndexOf,
      arrayLastIndexOf,
      map,
      reduce,
      copyWithin,
      chunk,
      zip,
      unzip,
      zipObject,
      flatten,
      toArray: toArray2,
      includeArrays,
      pluck,
      invoke,
      arrayEach,
      lastArrayEach,
      toArrayTree,
      toTreeArray,
      findTree,
      eachTree,
      mapTree,
      filterTree,
      searchTree,
      // base
      hasOwnProp,
      eqNull,
      isNaN: isNumberNaN,
      isFinite: isNumberFinite,
      isUndefined,
      isArray: isArray2,
      isFloat,
      isInteger,
      isFunction: isFunction2,
      isBoolean: isBoolean2,
      isString: isString3,
      isNumber: isNumber2,
      isRegExp: isRegExp2,
      isObject: isObject3,
      isPlainObject: isPlainObject2,
      isDate: isDate2,
      isError,
      isTypeError,
      isEmpty,
      isNull,
      isSymbol,
      isArguments,
      isElement,
      isDocument,
      isWindow,
      isFormData,
      isMap,
      isWeakMap,
      isSet,
      isWeakSet,
      isLeapYear,
      isMatch,
      isEqual,
      isEqualWith,
      getType,
      uniqueId,
      getSize,
      indexOf,
      lastIndexOf,
      findIndexOf,
      findLastIndexOf,
      toStringJSON,
      toJSONString,
      keys,
      values,
      entries,
      pick,
      omit,
      first,
      last,
      each,
      forOf,
      lastForOf,
      lastEach,
      has,
      get,
      set,
      groupBy,
      countBy,
      clone: clone2,
      clear,
      remove,
      range,
      destructuring,
      // number
      random,
      min,
      max,
      commafy,
      round,
      ceil,
      floor,
      toFixed,
      toNumber,
      toNumberString,
      toInteger,
      add,
      subtract,
      multiply,
      divide,
      sum,
      mean,
      // date
      now: now2,
      timestamp,
      isValidDate,
      isDateSame,
      toStringDate,
      toDateString,
      getWhatYear,
      getWhatQuarter,
      getWhatMonth,
      getWhatWeek,
      getWhatDay,
      getYearDay,
      getYearWeek,
      getMonthWeek,
      getDayOfYear,
      getDayOfMonth,
      getDateDiff,
      // string
      trim,
      trimLeft,
      trimRight,
      escape: escape2,
      unescape,
      camelCase,
      kebabCase,
      repeat,
      padStart,
      padEnd,
      startsWith,
      endsWith,
      template,
      toFormatString,
      toString: toValueString,
      toValueString,
      // function
      noop,
      property,
      bind,
      once,
      after,
      before,
      throttle: throttle2,
      debounce,
      delay,
      // url
      unserialize,
      serialize,
      parseUrl,
      // web
      getBaseURL,
      locat,
      browse: browse4,
      cookie
    });
    module2.exports = XEUtils156;
  }
});

// node_modules/chinese-lunar-calendar/src/utils.js
var require_utils = __commonJS({
  "node_modules/chinese-lunar-calendar/src/utils.js"(exports2, module2) {
    function base64ToBit(base64Str) {
      const base64CodeMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const result = [];
      for (let i = 0; i < base64Str.length; i++) {
        let n = base64CodeMap.indexOf(base64Str[i]);
        result.push(n.toString(2).padStart(6, "0"));
      }
      return result.join("");
    }
    function checkDate(year, month, date) {
      if (year < 1901 || year > 2100) {
        throw new Error("Invalid Year");
      }
      if (month < 1 || month > 12) {
        throw new Error("Invalid Month");
      }
      if (date < 1 || date > 31) {
        throw new Error("Invalid Date");
      }
      if ([4, 6, 9, 11].indexOf(month) != -1 && date > 30) {
        throw new Error("Invalid Date");
      }
      if (month == 2) {
        if (date > 29) {
          throw new Error("Invalid Date");
        } else {
          let isLeap = false;
          if (year % 400 == 0) {
            isLeap = true;
          } else if (year % 4 == 0 && year % 100 != 0) {
            isLeap = true;
          }
          if (!isLeap && date > 28) {
            throw new Error("Invalid Date");
          }
        }
      }
    }
    module2.exports = {
      base64ToBit,
      checkDate
    };
  }
});

// node_modules/chinese-lunar-calendar/src/solar_term.js
var require_solar_term = __commonJS({
  "node_modules/chinese-lunar-calendar/src/solar_term.js"(exports2, module2) {
    var { base64ToBit, checkDate } = require_utils();
    var names = [
      "小寒",
      "大寒",
      "立春",
      "雨水",
      "惊蛰",
      "春分",
      "清明",
      "谷雨",
      "立夏",
      "小满",
      "芒种",
      "夏至",
      "小暑",
      "大暑",
      "立秋",
      "处暑",
      "白露",
      "秋分",
      "寒露",
      "霜降",
      "立冬",
      "小雪",
      "大雪",
      "冬至"
    ];
    var baseDate = [4, 19, 3, 18, 4, 19, 4, 19, 4, 20, 4, 20, 6, 22, 6, 22, 6, 22, 7, 22, 6, 21, 6, 21];
    var table = [];
    function decompressData() {
      const codeStr = "ABCDAECDAECDFGHIJKHILKMILABNOABNOAENOAENOAEPQRGSTUGSTLAVTOAWXOAWXOAYXOAYZOabcdebcQUfgThijkOilXOimXOimXOimcOnocdpqcQrsgktujkvumXvumXvumcvumcvwocxyqcz0sj10s213u243um43um53wm56wq567q589s+/0s~/3u~!3u@#3um";
      const groupsStr = "paaqmqqpqaquqqqqqvruruqq6qWaWZqlqaqqqqqqlaaqmqqppaaqqqqqqrququqqqqWaWZaVlaaampqlpaaqqqqplaWampqlqaququqqqqWZWZVVlaWaWZqlqqVZWZVVlaWaWZaVlaaqmpqpqmVZVZVVVaWaWZaVlaWampqpqlVZVZVVqVVZVVVVVaWZWZVVqVVVVVVVVaVZWZVVpaaqmpqpqVFVVVVVVaVZVZVVlaWaWZalpaaampqppVFVRVVVVWVZVZVVlaWaWpqlpVFVRVVUVVVZVVVVVaWZWZaVVFVZVVVVVFVVVVVVpVFVRUVUVFFVVVVVpVFFRUVUVFFVRVVVlVBFRUVUUFFVRVVVlVBFBEVUUFFVRVVUlVBFBEVQUFFFRUVUlVBFBEFQUFBFRUVUlVBEBEFAQFBFBEVUVVBEBEFAVVVVVVVVQFBFBEVQVVBEBEAAVVAEAEAAQFBFBEFQUFBFBUVUQFBEBEFAUFBFBEVUVQAEAAAAAFBEBEFAVQAAAAAAAFBEBEAAVAAAAAAAAFBEAEAA";
      const groups = [];
      for (let i = 0; i < groupsStr.length; i += 8) {
        const groupBitStr = base64ToBit(groupsStr.substr(i, 8));
        const group = [];
        for (let j = 0; j < groupBitStr.length; j += 2) {
          group.push(+`0b${groupBitStr.substr(j, 2)}`);
        }
        groups.push(group);
      }
      const codeMapStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/~!@#";
      for (let i = 0; i < codeStr.length; i++) {
        table.push(groups[codeMapStr.indexOf(codeStr[i])]);
      }
    }
    decompressData();
    function getSolarTerm(year, month, date) {
      year = Math.floor(+year);
      month = Math.floor(+month);
      date = Math.floor(+date);
      checkDate(year, month, date);
      const index2 = (month - 1) * 2 + (date < 15 ? 0 : 1);
      const d = baseDate[index2] + table[year - 1901][index2];
      if (date == d) {
        return names[index2];
      } else {
        return null;
      }
    }
    module2.exports = { getSolarTerm };
  }
});

// node_modules/chinese-lunar-calendar/src/lunar_calendar.js
var require_lunar_calendar = __commonJS({
  "node_modules/chinese-lunar-calendar/src/lunar_calendar.js"(exports2, module2) {
    var { base64ToBit, checkDate } = require_utils();
    var { getSolarTerm } = require_solar_term();
    var table = [];
    var heavenlyStemStr = "甲乙丙丁戊己庚辛壬癸";
    var earthlyBranchStr = "子丑寅卯辰巳午未申酉戌亥";
    var zodiacStr = "鼠牛虎兔龙蛇马羊猴鸡狗猪";
    var lunarMonthStr = "正二三四五六七八九十冬腊";
    var nubmerStr = "一二三四五六七八九十";
    function decompressData() {
      const base64Str = "hLaCVwUrqpNDSYNlUaqgrUE1pJXQSuak2FJoaSrqlC1QNailtBK26TcElwpLWyWDUoNqJW1ArYJVySXgkuzJYNSg6lVtSC1oFbHJuCS58loZKhqU20oLVQVqSq2BLoSWlkrCpV7SoNlBaqqrUE2gpbNSuClcVKg6VBqpq1QVaglslK4KVwUmPpMGyrrVQVqCW1UroJWhSamk0NJY1ShaoFtTS2glbBJtKS4Ul1ZLBqUG1GraBVsEq6pLwSXBks2pQdSw1lBawKtlk2hJcGSyalQ1KDaUlqoK1PVbAl0JLVyVhUqFpSWqgrVlVqCXQUtspXBSsKk0dKg1UFapJtQS2alcFJwaTL0mDVMFqja1BLbaV0ErQpNbSWGkoapLtUC1oFbSStgk29JcKSwqlW1KDaQVtGq2CTeEl4JLgyWzUoOpQaqSrYFVwSXHkuDJZ9SoalBtKq1UFagptRS6ClsVKwqVC0prVQVqgq0lLoKWwUrOpODSbuUwaqCtVU2oJbBSuik4NFo6TBqkG1TNagVtBK5KToUWhoqWyUNUg";
      const bitStr = base64ToBit(base64Str);
      let solarDate = { y: 1900, m: 1, d: 31, obj: new Date(1900, 0, 31, 0, 0, 0, 0) };
      let heavenlyStem = 6;
      let earthlyBranch = 0;
      for (let i = 0; i < bitStr.length; ) {
        if (i + 16 >= bitStr.length) {
          break;
        }
        const head = bitStr.substr(i, 4);
        i += 4;
        const leapMonth = +`0b${head}`;
        const monthCount = leapMonth > 0 ? 13 : 12;
        const months = bitStr.substr(i, monthCount).split("").map((o) => +o);
        i += monthCount;
        table.push({
          solarDate,
          leapMonth,
          months,
          heavenlyStem,
          earthlyBranch
        });
        const dateCount = monthCount * 29 + months.filter((o) => o == 1).length;
        const newSolarDate = new Date(solarDate.y, solarDate.m - 1, solarDate.d + dateCount, 0, 0, 0, 0);
        solarDate = {
          y: newSolarDate.getFullYear(),
          m: newSolarDate.getMonth() + 1,
          d: newSolarDate.getDate(),
          obj: newSolarDate
        };
        heavenlyStem = (heavenlyStem + 1) % 10;
        earthlyBranch = (earthlyBranch + 1) % 12;
      }
    }
    decompressData();
    function isBefore(base, target) {
      if (base.y != target.y) {
        return base.y > target.y;
      } else if (base.m != target.m) {
        return base.m > target.m;
      } else if (base.d != target.d) {
        return base.d > target.d;
      }
      return false;
    }
    function getLunarStr(month, date, isLeap) {
      const monthStr = `${isLeap ? "闰" : ""}${lunarMonthStr[month - 1]}月`;
      if (date <= 10) {
        return `${monthStr}初${nubmerStr[date - 1]}`;
      } else if (date < 20) {
        return `${monthStr}十${nubmerStr[date - 11]}`;
      } else if (date == 20) {
        return `${monthStr}廿十`;
      } else if (date > 20) {
        return `${monthStr}廿${nubmerStr[date - 21]}`;
      } else {
        return `${monthStr}三十`;
      }
    }
    function getLunar(year, month, date) {
      year = Math.floor(+year);
      month = Math.floor(+month);
      date = Math.floor(+date);
      checkDate(year, month, date);
      let index2 = year - 1900;
      let row = table[index2];
      if (isBefore(row.solarDate, { y: year, m: month, d: date })) {
        index2 -= 1;
        row = table[index2];
      }
      if (!row) {
        throw new Error("Invalid Date");
      }
      const targetDate = new Date(year, month - 1, date, 0, 0, 0, 0);
      let delta = Math.round((targetDate.getTime() - row.solarDate.obj.getTime()) / (24 * 60 * 60 * 1e3));
      let afterLeap = false;
      for (let i = 0; i < row.months.length; i++) {
        const isLeap = row.leapMonth > 0 && i == row.leapMonth;
        if (isLeap) {
          afterLeap = true;
        }
        const days = 29 + row.months[i];
        if (delta < days) {
          let lunarMonth = afterLeap ? i : i + 1;
          return {
            lunarMonth,
            lunarDate: delta + 1,
            isLeap,
            solarTerm: getSolarTerm(year, month, date),
            lunarYear: `${heavenlyStemStr[row.heavenlyStem]}${earthlyBranchStr[row.earthlyBranch]}年`,
            zodiac: `${zodiacStr[row.earthlyBranch]}`,
            dateStr: getLunarStr(lunarMonth, delta + 1, isLeap)
          };
        } else {
          delta -= days;
        }
      }
      throw new Error(`There's something wrong!`);
    }
    module2.exports = { getLunar };
  }
});

// node_modules/sortablejs/modular/sortable.esm.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
var version = "1.15.6";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on(el2, event, fn2) {
  el2.addEventListener(event, fn2, !IE11OrLess && captureMode);
}
function off(el2, event, fn2) {
  el2.removeEventListener(event, fn2, !IE11OrLess && captureMode);
}
function matches(el2, selector) {
  if (!selector) return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el2) {
    try {
      if (el2.matches) {
        return el2.matches(selector);
      } else if (el2.msMatchesSelector) {
        return el2.msMatchesSelector(selector);
      } else if (el2.webkitMatchesSelector) {
        return el2.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el2) {
  return el2.host && el2 !== document && el2.host.nodeType ? el2.host : el2.parentNode;
}
function closest(el2, selector, ctx, includeCTX) {
  if (el2) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el2.parentNode === ctx && matches(el2, selector) : matches(el2, selector)) || includeCTX && el2 === ctx) {
        return el2;
      }
      if (el2 === ctx) break;
    } while (el2 = getParentOrHost(el2));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el2, name, state) {
  if (el2 && name) {
    if (el2.classList) {
      el2.classList[state ? "add" : "remove"](name);
    } else {
      var className = (" " + el2.className + " ").replace(R_SPACE, " ").replace(" " + name + " ", " ");
      el2.className = (className + (state ? " " + name : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el2, prop, val) {
  var style = el2 && el2.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el2, "");
      } else if (el2.currentStyle) {
        val = el2.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el2, selfOnly) {
  var appliedTransforms = "";
  if (typeof el2 === "string") {
    appliedTransforms = el2;
  } else {
    do {
      var transform2 = css(el2, "transform");
      if (transform2 && transform2 !== "none") {
        appliedTransforms = transform2 + " " + appliedTransforms;
      }
    } while (!selfOnly && (el2 = el2.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el2, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el2.getBoundingClientRect && el2 !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el2 !== window && el2.parentNode && el2 !== getWindowScrollingElement()) {
    elRect = el2.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el2 !== window) {
    container = container || el2.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el2 !== window) {
    var elMatrix = matrix(container || el2), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el2, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el2, true), elSideVal = getRect(el2)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el2, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el2.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el2, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el2, selector) {
  var last = el2.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index(el2, selector) {
  var index2 = 0;
  if (!el2 || !el2.parentNode) {
    return -1;
  }
  while (el2 = el2.previousElementSibling) {
    if (el2.nodeName.toUpperCase() !== "TEMPLATE" && el2 !== Sortable.clone && (!selector || matches(el2, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el2) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el2) {
    do {
      var elMatrix = matrix(el2), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el2.scrollLeft * scaleX;
      offsetTop += el2.scrollTop * scaleY;
    } while (el2 !== winScroller && (el2 = el2.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el2, includeSelf) {
  if (!el2 || !el2.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el2;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms2) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms2);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el2, x, y) {
  el2.scrollLeft += x;
  el2.scrollTop += y;
}
function clone(el2) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el2).cloneNode(true);
  } else if ($) {
    return $(el2).clone(true)[0];
  } else {
    return el2.cloneNode(true);
  }
}
function getChildContainingRectFromElement(container, options, ghostEl2) {
  var rect = {};
  Array.from(container.children).forEach(function(child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function") callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function") callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function") callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el2, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el2, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2)) continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function") return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName]) return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === "function") {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable) return;
  var evt, options = sortable.options, onName = "on" + name.charAt(0).toUpperCase() + name.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable,
        name,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl;
var parentEl;
var ghostEl;
var rootEl;
var nextEl;
var lastDownEl;
var cloneEl;
var cloneHidden;
var oldIndex;
var newIndex;
var oldDraggableIndex;
var newDraggableIndex;
var activeGroup;
var putSortable;
var awaitingDragStarted = false;
var ignoreNextClick = false;
var sortables = [];
var tapEvt;
var touchEvt;
var lastDx;
var lastDy;
var tapDistanceLeft;
var tapDistanceTop;
var moved;
var lastTarget;
var lastDirection;
var pastFirstInvertThresh = false;
var isCircumstantialInvert = false;
var targetMoveDistance;
var ghostRelativeParent;
var ghostRelativeParentInitialScroll = [];
var _silent = false;
var savedInputChecked = [];
var documentExists = typeof document !== "undefined";
var PositionGhostAbsolutely = IOS;
var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
var supportCssPointerEvents = function() {
  if (!documentExists) return;
  if (IE11OrLess) {
    return false;
  }
  var el2 = document.createElement("x");
  el2.style.cssText = "pointer-events:auto";
  return el2.style.pointerEvents === "auto";
}();
var _detectDirection = function _detectDirection2(el2, options) {
  var elCSS = css(el2), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el2, 0, options), child2 = getChild(el2, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
};
var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
};
var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable)) return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
};
var _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to2, from, dragEl2, evt) {
      var sameGroup = to2.options.group.name && from.options.group.name && to2.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to2, from, dragEl2, evt), pull)(to2, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to2 : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
};
var _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
};
var _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists && !ChromeForAndroid) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el2, options) {
  if (!(el2 && el2.nodeType && el2.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el2));
  }
  this.el = el2;
  this.options = options = _extends({}, options);
  el2[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el2.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el2, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && (!Safari || IOS),
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el2, defaults2);
  for (var name in defaults2) {
    !(name in options) && (options[name] = defaults2[name]);
  }
  _prepareGroup(options);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on(el2, "pointerdown", this._onTapStart);
  } else {
    on(el2, "mousedown", this._onTapStart);
    on(el2, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el2, "dragover", this);
    on(el2, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */
{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable) return;
    var _this = this, el2 = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el2);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el2, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el2,
          fromEl: el2
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el2, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el2,
            toEl: el2
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el2, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el2 = _this.el, options = _this.options, ownerDocument = el2.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el2) {
      var dragRect = getRect(target);
      rootEl = el2;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      if (options.supportPointer) {
        on(ownerDocument, "pointerup", _this._onDrop);
        !this.nativeDraggable && on(ownerDocument, "pointercancel", _this._onDrop);
      } else {
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop);
      }
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        if (options.supportPointer) {
          on(ownerDocument, "pointerup", _this._disableDelayedDrag);
          on(ownerDocument, "pointercancel", _this._disableDelayedDrag);
        } else {
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        }
        on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e16) {
    var touch = e16.touches ? e16.touches[0] : e16;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "pointerup", this._disableDelayedDrag);
    off(ownerDocument, "pointercancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on(document, "touchmove", this._onTouchMove);
      } else {
        on(document, "mousemove", this._onTouchMove);
      }
    } else {
      on(dragEl, "dragend", this);
      on(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy2 = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy2 - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy2
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy2;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, "selectstart", _this);
    moved = true;
    window.getSelection().removeAllRanges();
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver(evt) {
    var el2 = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent2(name, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el2, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el2 && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el2,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el2, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el2, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el2 === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            el2.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el2.appendChild(dragEl);
          }
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el2, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el2.insertBefore(dragEl, firstChild);
          parentEl = el2;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el2) {
        targetRect = getRect(target);
        var direction = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el2, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el2, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el2.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el2.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "pointercancel", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el2 = this.el, options = this.options;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el2, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el2) {
      el2.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [], el2, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el2 = children[i];
      if (closest(el2, options.draggable, this.el, false)) {
        order.push(el2.getAttribute(options.dataIdAttr) || _generateId(el2));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id2, i) {
      var el2 = rootEl2.children[i];
      if (closest(el2, this.options.draggable, rootEl2, false)) {
        items[id2] = el2;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id2) {
      if (items[id2]) {
        rootEl2.removeChild(items[id2]);
        rootEl2.appendChild(items[id2]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el2, selector) {
    return closest(el2, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== "undefined") {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === "group") {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el2 = this.el;
    el2[expando] = null;
    off(el2, "mousedown", this._onTapStart);
    off(el2, "touchstart", this._onTapStart);
    off(el2, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el2, "dragover", this);
      off(el2, "dragenter", this);
    }
    Array.prototype.forEach.call(el2.querySelectorAll("[draggable]"), function(el3) {
      el3.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el2 = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled) return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el2) {
  el2.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el2) {
  var str = el2.tagName + el2.className + el2.src + el2.href + el2.textContent, i = str.length, sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el2 = inputs[idx];
    el2.checked && savedInputChecked.push(el2);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id2) {
  return clearTimeout(id2);
}
if (documentExists) {
  on(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on,
  off,
  css,
  find,
  is: function is(el2, selector) {
    return !!closest(el2, selector, el2, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild,
  expando
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array) plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el2, options) {
  return new Sortable(el2, options);
};
Sortable.version = version;
var autoScrolls = [];
var scrollEl;
var scrollRootEl;
var scrolling = false;
var lastAutoScrollX;
var lastAutoScrollY;
var touchEvt$1;
var pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el2 = currentParent, rect = getRect(el2), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el2.scrollWidth, scrollHeight = el2.scrollHeight, elCSS = css(el2), scrollPosX = el2.scrollLeft, scrollPosY = el2.scrollTop;
    if (el2 === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy2 = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy2 || autoScrolls[layersOut].el !== el2) {
      autoScrolls[layersOut].el = el2;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy2;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy2 != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval((function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }).bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
var sortable_esm_default = Sortable;

// node_modules/vxe-table/es/components.js
var components_exports = {};
__export(components_exports, {
  Colgroup: () => Colgroup,
  Column: () => Column,
  Grid: () => Grid,
  Table: () => Table,
  Toolbar: () => Toolbar,
  VXETable: () => VXETable,
  VxeColgroup: () => VxeColgroup,
  VxeColumn: () => VxeColumn,
  VxeGrid: () => VxeGrid,
  VxeTable: () => VxeTable,
  VxeToolbar: () => VxeToolbar,
  VxeUI: () => VxeUI,
  _t: () => _t,
  clipboard: () => clipboard2,
  commands: () => commands2,
  config: () => config,
  formats: () => formats2,
  getConfig: () => getConfig2,
  getI18n: () => getI18n2,
  getIcon: () => getIcon2,
  getTheme: () => getTheme2,
  globalEvents: () => globalEvents2,
  globalResize: () => globalResize2,
  hooks: () => hooks2,
  install: () => install,
  interceptor: () => interceptor2,
  log: () => log2,
  menus: () => menus2,
  modal: () => modal,
  print: () => print,
  readFile: () => readFile,
  renderer: () => renderer2,
  saveFile: () => saveFile,
  setConfig: () => setConfig2,
  setI18n: () => setI18n2,
  setIcon: () => setIcon2,
  setLanguage: () => setLanguage2,
  setTheme: () => setTheme2,
  setup: () => setup,
  t: () => t,
  use: () => use2,
  validators: () => validators2,
  version: () => version3
});

// node_modules/@vxe-ui/core/es/src/core.js
var coreVersion = "4.0.23";
var VxeCore = {
  coreVersion,
  uiVersion: "",
  tableVersion: ""
};

// node_modules/@vxe-ui/core/es/src/config.js
var import_xe_utils = __toESM(require_xe_utils());

// node_modules/dom-zindex/es/index.esm.js
var winDom = null;
var bodyEl = null;
var storeEl = null;
var storeId = "z-index-manage";
var styleEl = null;
var styleId = "z-index-style";
var storeMainKey = "m";
var storeSubKey = "s";
var storeData = {
  m: 1e3,
  s: 1e3
};
function getDocument() {
  if (!winDom) {
    if (typeof document !== "undefined") {
      winDom = document;
    }
  }
  return winDom;
}
function getBody() {
  if (winDom && !bodyEl) {
    bodyEl = winDom.body || winDom.getElementsByTagName("body")[0];
  }
  return bodyEl;
}
function getDomMaxZIndex() {
  var max = 0;
  var dom = getDocument();
  if (dom) {
    var body = getBody();
    if (body) {
      var allElem = body.getElementsByTagName("*");
      for (var i = 0; i < allElem.length; i++) {
        var elem = allElem[i];
        if (elem && elem.style && elem.nodeType === 1) {
          var zIndex = elem.style.zIndex;
          if (zIndex && /^\d+$/.test(zIndex)) {
            max = Math.max(max, Number(zIndex));
          }
        }
      }
    }
  }
  return max;
}
function getStyle() {
  if (!styleEl) {
    var dom = getDocument();
    if (dom) {
      styleEl = dom.getElementById(styleId);
      if (!styleEl) {
        styleEl = dom.createElement("style");
        styleEl.id = styleId;
        dom.getElementsByTagName("head")[0].appendChild(styleEl);
      }
    }
  }
  return styleEl;
}
function updateVar() {
  var styEl = getStyle();
  if (styEl) {
    var prefixes = "--dom-";
    var propKey = "-z-index";
    styEl.innerHTML = ":root{" + prefixes + "main" + propKey + ":" + getCurrent() + ";" + prefixes + "sub" + propKey + ":" + getSubCurrent() + "}";
  }
}
function getStoreDom() {
  if (!storeEl) {
    var dom = getDocument();
    if (dom) {
      storeEl = dom.getElementById(storeId);
      if (!storeEl) {
        var body = getBody();
        if (body) {
          storeEl = dom.createElement("div");
          storeEl.id = storeId;
          storeEl.style.display = "none";
          body.appendChild(storeEl);
          setCurrent(storeData.m);
          setSubCurrent(storeData.s);
        }
      }
    }
  }
  return storeEl;
}
function createSetHandle(key) {
  return function(value) {
    if (value) {
      value = Number(value);
      storeData[key] = value;
      var el2 = getStoreDom();
      if (el2) {
        if (el2.dataset) {
          el2.dataset[key] = value + "";
        } else {
          el2.setAttribute("data-" + key, value + "");
        }
      }
    }
    updateVar();
    return storeData[key];
  };
}
var setCurrent = createSetHandle(storeMainKey);
function createGetHandle(key, nextMethod) {
  return function getCurrent2(currZindex) {
    var zIndex;
    var el2 = getStoreDom();
    if (el2) {
      var domVal = el2.dataset ? el2.dataset[key] : el2.getAttribute("data-" + key);
      if (domVal) {
        zIndex = Number(domVal);
      }
    }
    if (!zIndex) {
      zIndex = storeData[key];
    }
    if (currZindex) {
      if (Number(currZindex) < zIndex) {
        return nextMethod();
      }
      return currZindex;
    }
    return zIndex;
  };
}
var getCurrent = createGetHandle(storeMainKey, getNext);
function getNext() {
  return setCurrent(getCurrent() + 1);
}
var setSubCurrent = createSetHandle(storeSubKey);
var _getSubCurrent = createGetHandle(storeSubKey, getSubNext);
function getSubCurrent() {
  return getCurrent() + _getSubCurrent();
}
function getSubNext() {
  setSubCurrent(_getSubCurrent() + 1);
  return getSubCurrent();
}
var DomZIndex = {
  setCurrent,
  getCurrent,
  getNext,
  setSubCurrent,
  getSubCurrent,
  getSubNext,
  getMax: getDomMaxZIndex
};
updateVar();
var index_esm_default = DomZIndex;

// node_modules/@vxe-ui/core/es/src/configStore.js
var globalConfigStore = {
  size: "",
  version: 1,
  zIndex: 999,
  resizeInterval: 500
};

// node_modules/@vxe-ui/core/es/src/themeStore.js
var themeConfigStore = {
  theme: ""
};

// node_modules/@vxe-ui/core/es/src/theme.js
function setTheme(name) {
  const theme = !name || name === "default" ? "light" : name;
  themeConfigStore.theme = theme;
  if (typeof document !== "undefined") {
    const documentElement = document.documentElement;
    if (documentElement) {
      documentElement.setAttribute("data-vxe-ui-theme", theme);
    }
  }
  return VxeCore;
}
function getTheme() {
  return themeConfigStore.theme;
}

// node_modules/@vxe-ui/core/es/src/config.js
function setConfig(options) {
  if (options) {
    if (options.zIndex) {
      index_esm_default.setCurrent(options.zIndex);
    }
    if (options.theme) {
      setTheme(options.theme);
    }
    import_xe_utils.default.merge(globalConfigStore, options);
  }
  return VxeCore;
}
function getConfig(key, defaultValue) {
  return arguments.length ? import_xe_utils.default.get(globalConfigStore, key, defaultValue) : globalConfigStore;
}

// node_modules/@vxe-ui/core/es/src/dataStore.js
var globalStore = {};

// node_modules/@vxe-ui/core/es/src/icon.js
var import_xe_utils2 = __toESM(require_xe_utils());

// node_modules/@vxe-ui/core/es/src/iconStore.js
var iconConfigStore = {};

// node_modules/@vxe-ui/core/es/src/icon.js
function setIcon(options) {
  if (options) {
    Object.assign(iconConfigStore, options);
  }
  return VxeCore;
}
function getIcon(key) {
  return arguments.length ? import_xe_utils2.default.get(iconConfigStore, key) : iconConfigStore;
}

// node_modules/@vxe-ui/core/es/src/event.js
var import_xe_utils3 = __toESM(require_xe_utils());
var GLOBAL_EVENT_KEYS = {
  F2: "F2",
  ESCAPE: "Escape",
  ENTER: "Enter",
  TAB: "Tab",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  SPACEBAR: " ",
  CONTEXT_MENU: "ContextMenu",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  R: "R",
  P: "P",
  Z: "Z",
  X: "X",
  C: "C",
  V: "V",
  M: "M"
};
var browse = import_xe_utils3.default.browse();
var convertEventKeys = {
  " ": "Spacebar",
  Apps: GLOBAL_EVENT_KEYS.CONTEXT_MENU,
  Del: GLOBAL_EVENT_KEYS.DELETE,
  Up: GLOBAL_EVENT_KEYS.ARROW_UP,
  Down: GLOBAL_EVENT_KEYS.ARROW_DOWN,
  Left: GLOBAL_EVENT_KEYS.ARROW_LEFT,
  Right: GLOBAL_EVENT_KEYS.ARROW_RIGHT
};
var wheelName = browse.firefox ? "DOMMouseScroll" : "mousewheel";
var eventStore = [];
function triggerEvent(evnt) {
  const isWheel = evnt.type === wheelName;
  eventStore.forEach(({ type, cb: cb2 }) => {
    if (!evnt.cancelBubble) {
      if (type === evnt.type || isWheel && type === "mousewheel") {
        cb2(evnt);
      }
    }
  });
}
var VxeComponentEvent = class {
  constructor(evnt, params1, params2) {
    Object.defineProperty(this, "$event", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "type", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "key", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    this.$event = evnt;
    if (evnt) {
      if (evnt.type) {
        this.type = evnt.type;
      }
      if (evnt.key) {
        this.key = evnt.key;
      }
      if (evnt.code) {
        this.code = evnt.code;
      }
    }
    Object.assign(this, params1, params2);
  }
  stopPropagation() {
    const evnt = this.$event;
    if (evnt) {
      evnt.stopPropagation();
    }
  }
  preventDefault() {
    const evnt = this.$event;
    if (evnt) {
      evnt.preventDefault();
    }
  }
};
var createEvent = (evnt, params1, params2) => {
  return new VxeComponentEvent(evnt, params1, params2);
};
var globalEvents = {
  on(comp, type, cb2) {
    eventStore.push({ comp, type, cb: cb2 });
  },
  off(comp, type) {
    import_xe_utils3.default.remove(eventStore, (item) => item.comp === comp && item.type === type);
  },
  hasKey(evnt, targetKey) {
    const { key } = evnt;
    targetKey = targetKey.toLowerCase();
    return key ? targetKey === key.toLowerCase() || !!(convertEventKeys[key] && convertEventKeys[key].toLowerCase() === targetKey) : false;
  }
};
if (browse.isDoc) {
  if (!browse.msie) {
    window.addEventListener("copy", triggerEvent, false);
    window.addEventListener("cut", triggerEvent, false);
    window.addEventListener("paste", triggerEvent, false);
  }
  document.addEventListener("keydown", triggerEvent, false);
  document.addEventListener("contextmenu", triggerEvent, false);
  window.addEventListener("mousedown", triggerEvent, false);
  window.addEventListener("blur", triggerEvent, false);
  window.addEventListener("resize", triggerEvent, false);
  window.addEventListener(wheelName, import_xe_utils3.default.throttle(triggerEvent, 100, { leading: true, trailing: false }), { passive: true, capture: false });
}

// node_modules/@vxe-ui/core/es/src/resize.js
var import_xe_utils4 = __toESM(require_xe_utils());
var resizeTimeout;
var eventStore2 = [];
var defaultInterval = 500;
function eventHandle() {
  if (eventStore2.length) {
    eventStore2.forEach((item) => {
      item.tarList.forEach((observer) => {
        const { target, width, heighe } = observer;
        const clientWidth = target.clientWidth;
        const clientHeight = target.clientHeight;
        const rWidth = clientWidth && width !== clientWidth;
        const rHeight = clientHeight && heighe !== clientHeight;
        if (rWidth || rHeight) {
          observer.width = clientWidth;
          observer.heighe = clientHeight;
          setTimeout(item.callback);
        }
      });
    });
    eventListener();
  }
}
function eventListener() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(eventHandle, globalConfigStore.resizeInterval || defaultInterval);
}
var XEResizeObserver = class {
  constructor(callback) {
    Object.defineProperty(this, "tarList", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "callback", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.callback = callback;
  }
  observe(target) {
    if (target) {
      const { tarList } = this;
      if (!tarList.some((observer) => observer.target === target)) {
        tarList.push({
          target,
          width: target.clientWidth,
          heighe: target.clientHeight
        });
      }
      if (!eventStore2.length) {
        eventListener();
      }
      if (!eventStore2.some((item) => item === this)) {
        eventStore2.push(this);
      }
    }
  }
  unobserve(target) {
    import_xe_utils4.default.remove(eventStore2, (item) => item.tarList.some((observer) => observer.target === target));
  }
  disconnect() {
    import_xe_utils4.default.remove(eventStore2, (item) => item === this);
  }
};
var globalResize = {
  create(callback) {
    if (window.ResizeObserver) {
      return new window.ResizeObserver(callback);
    }
    return new XEResizeObserver(callback);
  }
};

// node_modules/@vxe-ui/core/es/src/i18n.js
var import_xe_utils5 = __toESM(require_xe_utils());

// node_modules/@vxe-ui/core/es/src/i18nStore.js
var i18nConfigStore = reactive({
  language: "",
  langMaps: {}
});

// node_modules/@vxe-ui/core/es/src/i18n.js
var checkInstall = false;
function getI18n(key, args) {
  const { langMaps, language } = i18nConfigStore;
  const { i18n } = globalConfigStore;
  if (i18n) {
    return `${i18n(key, args) || ""}`;
  }
  if (!checkInstall) {
    if (!langMaps[language]) {
      console.error(`[vxe core] 语言包未安装。Language not installed. https://${VxeCore.uiVersion ? "vxeui.com" : "vxetable.cn"}/#/start/i18n`);
    }
    checkInstall = true;
  }
  return import_xe_utils5.default.toFormatString(import_xe_utils5.default.get(langMaps[language], key, key), args);
}
function setLanguage(locale) {
  i18nConfigStore.language = locale || "zh-CN";
  return VxeCore;
}
function setI18n(locale, data) {
  i18nConfigStore.langMaps[locale] = Object.assign({}, data);
  return VxeCore;
}
function hasLanguage(language) {
  const { langMaps } = i18nConfigStore;
  return !!langMaps[language];
}
function getLanguage() {
  const { language } = i18nConfigStore;
  return language;
}

// node_modules/@vxe-ui/core/es/src/renderer.js
var import_xe_utils6 = __toESM(require_xe_utils());

// node_modules/@vxe-ui/core/es/src/log.js
function createLog(type, name) {
  return function(key, args) {
    const msg = `[vxe ${name || ""}] ${getI18n(key, args)}`;
    console[type](msg);
    return msg;
  };
}
var version2 = "4.0.23";
var log = {
  create: createLog,
  warn: createLog("warn", `v${version2}`),
  err: createLog("error", `v${version2}`)
};

// node_modules/@vxe-ui/core/es/src/renderer.js
var renderMap = {};
var renderer = {
  mixin(opts) {
    import_xe_utils6.default.each(opts, (options, name) => renderer.add(name, options));
    return renderer;
  },
  get(name) {
    return renderMap[name] || null;
  },
  add(name, options) {
    if (name && options) {
      const renders = renderMap[name];
      if (renders) {
        if (true) {
          import_xe_utils6.default.each(options, (val, key) => {
            if (!import_xe_utils6.default.eqNull(renders[key]) && renders[key] !== val) {
              log.warn("vxe.error.coverProp", [`Renderer.${name}`, key]);
            }
          });
        }
        Object.assign(renders, options);
      } else {
        renderMap[name] = options;
      }
    }
    return renderer;
  },
  forEach(callback) {
    import_xe_utils6.default.objectEach(renderMap, callback);
    return renderer;
  },
  delete(name) {
    delete renderMap[name];
    return renderer;
  }
};

// node_modules/@vxe-ui/core/es/src/store.js
var import_xe_utils7 = __toESM(require_xe_utils());
var Store = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils7.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, options) {
    const conf = this.store[name];
    if (true) {
      const confKeys = import_xe_utils7.default.keys(conf);
      import_xe_utils7.default.each(options, (item, key) => {
        if (confKeys.includes(key)) {
          log.warn("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils7.default.merge(conf, options) : options;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils7.default.objectEach(this.store, callback);
  }
};
var store_default = Store;

// node_modules/@vxe-ui/core/es/src/validators.js
var validators = new store_default();
if (true) {
  Object.assign(validators, { _name: "Validators" });
}

// node_modules/@vxe-ui/core/es/src/menus.js
var import_xe_utils8 = __toESM(require_xe_utils());
var VXEMenusStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils8.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils8.default.isFunction(render)) {
      if (true) {
        log.warn("vxe.error.delProp", ["menus -> callback", "menuMethod"]);
      }
      render = {
        menuMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils8.default.keys(conf);
      import_xe_utils8.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          log.warn("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils8.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils8.default.objectEach(this.store, callback);
  }
};
var menus = new VXEMenusStore();
if (true) {
  Object.assign(menus, { _name: "Menus" });
}

// node_modules/@vxe-ui/core/es/src/formats.js
var import_xe_utils9 = __toESM(require_xe_utils());
var VXEFormatsStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils9.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils9.default.isFunction(render)) {
      if (true) {
        log.warn("vxe.error.delProp", ["formats -> callback", "cellFormatMethod"]);
      }
      render = {
        cellFormatMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils9.default.keys(conf);
      import_xe_utils9.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          log.warn("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils9.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils9.default.objectEach(this.store, callback);
  }
};
var formats = new VXEFormatsStore();
if (true) {
  Object.assign(formats, { _name: "Formats" });
}

// node_modules/@vxe-ui/core/es/src/commands.js
var import_xe_utils10 = __toESM(require_xe_utils());
var VXECommandsStore = class {
  constructor() {
    Object.defineProperty(this, "store", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
  }
  mixin(options) {
    import_xe_utils10.default.each(options, (item, key) => {
      this.add(key, item);
    });
    return this;
  }
  has(name) {
    return !!this.get(name);
  }
  get(name) {
    return this.store[name];
  }
  add(name, render) {
    const conf = this.store[name];
    if (import_xe_utils10.default.isFunction(render)) {
      if (true) {
        log.warn("vxe.error.delProp", ["commands -> callback", "commandMethod"]);
      }
      render = {
        commandMethod: render
      };
    }
    if (true) {
      const confKeys = import_xe_utils10.default.keys(conf);
      import_xe_utils10.default.each(render, (item, key) => {
        if (confKeys.includes(key)) {
          log.warn("vxe.error.coverProp", [name, key]);
        }
      });
    }
    this.store[name] = conf ? import_xe_utils10.default.merge(conf, render) : render;
    return this;
  }
  delete(name) {
    delete this.store[name];
  }
  forEach(callback) {
    import_xe_utils10.default.objectEach(this.store, callback);
  }
};
var commands = new VXECommandsStore();
if (true) {
  Object.assign(commands, { _name: "Commands" });
}

// node_modules/@vxe-ui/core/es/src/interceptor.js
var import_xe_utils11 = __toESM(require_xe_utils());
var storeMap = {};
var interceptor = {
  mixin(options) {
    import_xe_utils11.default.each(options, (render, type) => {
      interceptor.add(type, render);
    });
    return interceptor;
  },
  get(type) {
    return storeMap[type] || [];
  },
  add(type, render) {
    if (import_xe_utils11.default.isFunction(render)) {
      render = {
        tableInterceptorMethod: render
      };
    }
    const callback = render.tableInterceptorMethod;
    if (callback) {
      let eList = storeMap[type];
      if (!eList) {
        eList = storeMap[type] = [];
      }
      if (true) {
        if (eList.indexOf(callback) > -1) {
          log.warn("vxe.error.coverProp", ["Interceptor", type]);
        }
      }
      eList.push(callback);
    }
    return interceptor;
  },
  delete(type, render) {
    const eList = storeMap[type];
    if (eList) {
      if (import_xe_utils11.default.isFunction(render)) {
        render = {
          tableInterceptorMethod: render
        };
      }
      const callback = render ? render.tableInterceptorMethod : null;
      if (callback) {
        import_xe_utils11.default.remove(eList, (fn2) => fn2 === callback);
      } else {
        delete storeMap[type];
      }
    }
  }
};

// node_modules/@vxe-ui/core/es/src/clipboard.js
var import_xe_utils12 = __toESM(require_xe_utils());
var copyElem;
var clipStore = {
  text: "",
  html: ""
};
function handleText(text) {
  if (!copyElem) {
    copyElem = document.createElement("textarea");
    copyElem.id = "$VxeCopy";
    const styles = copyElem.style;
    styles.width = "48px";
    styles.height = "24px";
    styles.position = "fixed";
    styles.zIndex = "0";
    styles.left = "-500px";
    styles.top = "-500px";
    document.body.appendChild(copyElem);
  }
  copyElem.value = text;
}
var clipboard = {
  getStore() {
    return clipStore;
  },
  setStore(data) {
    Object.assign(clipStore, data || {});
  },
  /**
   * 复制内容到剪贴板
   *
   * @param {String} content Text 内容
   */
  copy(content) {
    let result = false;
    try {
      const text = import_xe_utils12.default.toValueString(content);
      handleText(text);
      copyElem.select();
      copyElem.setSelectionRange(0, copyElem.value.length);
      result = document.execCommand("copy");
      copyElem.blur();
      clipStore.text = text;
      clipStore.html = "";
    } catch (e16) {
    }
    return result;
  }
};

// node_modules/@vxe-ui/core/es/src/permission.js
var import_xe_utils13 = __toESM(require_xe_utils());
function handleCheckInfo(permissionCode, permissionMethod) {
  let checkVisible = true;
  let checkDisabled = false;
  const checkMethod = permissionMethod || globalConfigStore.permissionMethod;
  if (permissionCode && checkMethod) {
    checkVisible = false;
    checkDisabled = true;
    let vDone = false;
    let dDone = false;
    const codeList = String(permissionCode).split("|");
    for (let i = 0; i < codeList.length; i++) {
      const code3 = codeList[i];
      let visible = true;
      let disabled = false;
      const rest = checkMethod({ code: code3 });
      if (import_xe_utils13.default.isBoolean(rest)) {
        visible = rest;
      } else if (rest) {
        visible = !!rest.visible;
        disabled = !!rest.disabled;
      }
      if (!disabled && !dDone) {
        dDone = true;
        checkDisabled = disabled;
      }
      if (visible && !vDone) {
        vDone = true;
        checkVisible = visible;
      }
      if (vDone && dDone) {
        break;
      }
    }
  }
  const info = {
    code: permissionCode,
    visible: checkVisible,
    disabled: checkDisabled
  };
  return info;
}
var permission = {
  getCheckInfo(code3) {
    return handleCheckInfo(code3);
  },
  checkVisible(code3) {
    const permissionInfo = handleCheckInfo(code3);
    return permissionInfo.visible;
  },
  checkDisable(code3) {
    const permissionInfo = handleCheckInfo(code3);
    return permissionInfo.disabled;
  }
};

// node_modules/@vxe-ui/core/es/src/hooks.js
var hooks = new store_default();

// node_modules/@vxe-ui/core/es/src/useFns.js
function useSize(props) {
  const xeSizeInfo = inject("xeSizeInfo", null);
  const computeSize = computed(() => {
    return props.size || (xeSizeInfo ? xeSizeInfo.value : null);
  });
  provide("xeSizeInfo", computeSize);
  return { computeSize };
}
function usePermission(props) {
  const computePermissionInfo = computed(() => {
    return handleCheckInfo(props.permissionCode, props.permissionMethod);
  });
  return {
    computePermissionInfo
  };
}
var useFns = {
  useSize,
  usePermission
};

// node_modules/@vxe-ui/core/es/index.esm.js
var installedPlugins = [];
function use(Plugin, options) {
  if (Plugin && Plugin.install) {
    if (installedPlugins.indexOf(Plugin) === -1) {
      Plugin.install(VxeUI, options);
      installedPlugins.push(Plugin);
    }
  }
  return VxeUI;
}
var components = {};
function getComponent(name) {
  return components[name] || null;
}
function component(comp) {
  if (comp && comp.name) {
    components[comp.name] = comp;
  }
}
function renderEmptyElement() {
  return createCommentVNode();
}
var VxeUI = Object.assign(VxeCore, {
  renderEmptyElement,
  setTheme,
  getTheme,
  setConfig,
  getConfig,
  setIcon,
  getIcon,
  setLanguage,
  hasLanguage,
  getLanguage,
  setI18n,
  getI18n,
  globalEvents,
  GLOBAL_EVENT_KEYS,
  createEvent,
  globalResize,
  renderer,
  validators,
  menus,
  formats,
  commands,
  interceptor,
  clipboard,
  log,
  permission,
  globalStore,
  hooks,
  component,
  getComponent,
  useFns,
  use
});
setTheme();

// node_modules/vxe-table/es/ui/src/utils.js
var import_xe_utils14 = __toESM(require_xe_utils());
function isEnableConf(conf) {
  return conf && conf.enabled !== false;
}
function isEmptyValue(cellValue) {
  return cellValue === null || cellValue === void 0 || cellValue === "";
}
function parseFile(file) {
  const name = file.name;
  const tIndex = import_xe_utils14.default.lastIndexOf(name, ".");
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return { filename, type };
}
function nextZIndex() {
  return index_esm_default.getNext();
}
function getLastZIndex() {
  return index_esm_default.getCurrent();
}
function hasChildrenList(item) {
  return item && item.children && item.children.length > 0;
}
function getFuncText(content, args) {
  if (content) {
    const translate2 = VxeUI.getConfig().translate;
    return import_xe_utils14.default.toValueString(translate2 ? translate2("" + content, args) : content);
  }
  return "";
}
function formatText(value, placeholder) {
  return "" + (isEmptyValue(value) ? placeholder ? VxeUI.getConfig().emptyCell : "" : value);
}
function eqEmptyValue(cellValue) {
  return cellValue === "" || import_xe_utils14.default.eqNull(cellValue);
}

// node_modules/vxe-table/es/ui/index.js
var version3 = "4.9.29";
VxeUI.version = version3;
VxeUI.tableVersion = version3;
VxeUI.setConfig({
  emptyCell: "　",
  table: {
    fit: true,
    showHeader: true,
    animat: true,
    delayHover: 250,
    autoResize: true,
    padding: true,
    minHeight: 144,
    // keepSource: false,
    // showOverflow: null,
    // showHeaderOverflow: null,
    // showFooterOverflow: null,
    // resizeInterval: 500,
    // size: null,
    // zIndex: null,
    // stripe: false,
    // border: false,
    // round: false,
    // emptyText: '暂无数据',
    // emptyRender: {
    //   name: ''
    // },
    // rowConfig: {
    //   keyField: '_X_ROW_KEY' // 行数据的唯一主键字段名
    // },
    resizeConfig: {
      // refreshDelay: 250
    },
    resizableConfig: {
      dragMode: "auto",
      showDragTip: true
    },
    radioConfig: {
      // trigger: 'default'
      strict: true
    },
    rowDragConfig: {
      showIcon: true,
      animation: true
    },
    columnDragConfig: {
      showIcon: true,
      animation: true
    },
    checkboxConfig: {
      // trigger: 'default',
      strict: true
    },
    tooltipConfig: {
      enterable: true
    },
    validConfig: {
      showMessage: true,
      autoClear: true,
      autoPos: true,
      message: "inline",
      msgMode: "single",
      theme: "beautify"
    },
    columnConfig: {
      maxFixedSize: 4
    },
    // menuConfig: {
    //   visibleMethod () {}
    // },
    customConfig: {
      // enabled: false,
      allowVisible: true,
      allowResizable: true,
      allowFixed: true,
      allowSort: true,
      showFooter: true,
      placement: "top-right",
      //  storage: false,
      //  checkMethod () {},
      modalOptions: {
        showMaximize: true,
        mask: true,
        lockView: true,
        resize: true,
        escClosable: true
      },
      drawerOptions: {
        mask: true,
        lockView: true,
        escClosable: true,
        resize: true
      }
    },
    sortConfig: {
      // remote: false,
      // trigger: 'default',
      // orders: ['asc', 'desc', null],
      // sortMethod: null,
      showIcon: true,
      iconLayout: "vertical"
    },
    filterConfig: {
      // remote: false,
      // filterMethod: null,
      showIcon: true
    },
    treeConfig: {
      rowField: "id",
      parentField: "parentId",
      childrenField: "children",
      hasChildField: "hasChild",
      mapChildrenField: "_X_ROW_CHILD",
      indent: 20,
      showIcon: true
    },
    expandConfig: {
      // trigger: 'default',
      showIcon: true
    },
    editConfig: {
      // mode: 'cell',
      showIcon: true,
      showAsterisk: true,
      autoFocus: true
    },
    importConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    exportConfig: {
      _typeMaps: {
        csv: 1,
        html: 1,
        xml: 1,
        txt: 1
      }
    },
    printConfig: {},
    mouseConfig: {
      extension: true
    },
    keyboardConfig: {
      isEsc: true
    },
    areaConfig: {
      autoClear: true,
      selectCellByHeader: true,
      selectCellByBody: true
    },
    clipConfig: {
      isCopy: true,
      isCut: true,
      isPaste: true
    },
    fnrConfig: {
      isFind: true,
      isReplace: true
    },
    scrollX: {
      // enabled: false,
      gt: 60
      // oSize: 0
    },
    scrollY: {
      // enabled: false,
      gt: 100
      // oSize: 0
    }
  },
  // export: {
  //   types: {}
  // },
  grid: {
    // size: null,
    // zoomConfig: {
    //   escRestore: true
    // },
    formConfig: {
      enabled: true
    },
    pagerConfig: {
      enabled: true
      // perfect: false
    },
    toolbarConfig: {
      enabled: true
      // perfect: false
    },
    proxyConfig: {
      enabled: true,
      autoLoad: true,
      showResponseMsg: true,
      showActiveMsg: true,
      props: {
        list: null,
        result: "result",
        total: "page.total",
        message: "message"
      }
      // beforeItem: null,
      // beforeColumn: null,
      // beforeQuery: null,
      // afterQuery: null,
      // beforeDelete: null,
      // afterDelete: null,
      // beforeSave: null,
      // afterSave: null
    }
  },
  toolbar: {
    // size: null,
    // import: {
    //   mode: 'covering'
    // },
    // export: {
    //   types: ['csv', 'html', 'xml', 'txt']
    // },
    // buttons: []
  }
});
var iconPrefix = "vxe-table-icon-";
VxeUI.setIcon({
  // table
  TABLE_SORT_ASC: iconPrefix + "caret-up",
  TABLE_SORT_DESC: iconPrefix + "caret-down",
  TABLE_FILTER_NONE: iconPrefix + "funnel",
  TABLE_FILTER_MATCH: iconPrefix + "funnel",
  TABLE_EDIT: iconPrefix + "edit",
  TABLE_TITLE_PREFIX: iconPrefix + "question-circle-fill",
  TABLE_TITLE_SUFFIX: iconPrefix + "question-circle-fill",
  TABLE_TREE_LOADED: iconPrefix + "spinner roll",
  TABLE_TREE_OPEN: iconPrefix + "caret-right rotate90",
  TABLE_TREE_CLOSE: iconPrefix + "caret-right",
  TABLE_EXPAND_LOADED: iconPrefix + "spinner roll",
  TABLE_EXPAND_OPEN: iconPrefix + "arrow-right rotate90",
  TABLE_EXPAND_CLOSE: iconPrefix + "arrow-right",
  TABLE_CHECKBOX_CHECKED: iconPrefix + "checkbox-checked-fill",
  TABLE_CHECKBOX_UNCHECKED: iconPrefix + "checkbox-unchecked",
  TABLE_CHECKBOX_INDETERMINATE: iconPrefix + "checkbox-indeterminate-fill",
  TABLE_RADIO_CHECKED: iconPrefix + "radio-checked-fill",
  TABLE_RADIO_UNCHECKED: iconPrefix + "radio-unchecked",
  TABLE_CUSTOM_SORT: iconPrefix + "drag-handle",
  TABLE_MENU_OPTIONS: iconPrefix + "arrow-right",
  TABLE_DRAG_ROW: iconPrefix + "drag-handle",
  TABLE_DRAG_COLUMN: iconPrefix + "drag-handle",
  TABLE_DRAG_STATUS_ROW: iconPrefix + "sort",
  TABLE_DRAG_STATUS_SUB_ROW: iconPrefix + "add-sub",
  TABLE_DRAG_STATUS_COLUMN: iconPrefix + "swap",
  TABLE_DRAG_DISABLED: iconPrefix + "no-drop",
  // toolbar
  TOOLBAR_TOOLS_REFRESH: iconPrefix + "repeat",
  TOOLBAR_TOOLS_REFRESH_LOADING: iconPrefix + "repeat roll",
  TOOLBAR_TOOLS_IMPORT: iconPrefix + "upload",
  TOOLBAR_TOOLS_EXPORT: iconPrefix + "download",
  TOOLBAR_TOOLS_PRINT: iconPrefix + "print",
  TOOLBAR_TOOLS_FULLSCREEN: iconPrefix + "fullscreen",
  TOOLBAR_TOOLS_MINIMIZE: iconPrefix + "minimize",
  TOOLBAR_TOOLS_CUSTOM: iconPrefix + "custom-column",
  TOOLBAR_TOOLS_FIXED_LEFT: iconPrefix + "fixed-left",
  TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE: iconPrefix + "fixed-left-fill",
  TOOLBAR_TOOLS_FIXED_RIGHT: iconPrefix + "fixed-right",
  TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE: iconPrefix + "fixed-right-fill"
});
var setTheme2 = VxeUI.setTheme;
var getTheme2 = VxeUI.getTheme;
var setConfig2 = VxeUI.setConfig;
var getConfig2 = VxeUI.getConfig;
var setIcon2 = VxeUI.setIcon;
var getIcon2 = VxeUI.getIcon;
var setLanguage2 = VxeUI.setLanguage;
var setI18n2 = VxeUI.setI18n;
var getI18n2 = VxeUI.getI18n;
var globalEvents2 = VxeUI.globalEvents;
var globalResize2 = VxeUI.globalResize;
var renderer2 = VxeUI.renderer;
var validators2 = VxeUI.validators;
var menus2 = VxeUI.menus;
var formats2 = VxeUI.formats;
var commands2 = VxeUI.commands;
var interceptor2 = VxeUI.interceptor;
var clipboard2 = VxeUI.clipboard;
var log2 = VxeUI.log;
var hooks2 = VxeUI.hooks;
var use2 = VxeUI.use;
var setup = (options) => {
  return VxeUI.setConfig(options);
};
VxeUI.setup = setup;
var config = (options) => {
  return VxeUI.setConfig(options);
};
VxeUI.config = config;
var t = (key, args) => {
  return VxeUI.getI18n(key, args);
};
VxeUI.t = t;
var _t = (content, args) => {
  return getFuncText(content, args);
};
VxeUI._t = _t;
var VXETable = VxeUI;
var saveFile = (options) => {
  return VxeUI.saveFile(options);
};
var readFile = (options) => {
  return VxeUI.readFile(options);
};
var print = (options) => {
  return VxeUI.print(options);
};
var modal = {
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  get(id2) {
    return VxeUI.modal.get(id2);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  close(id2) {
    return VxeUI.modal.close(id2);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  open(options) {
    return VxeUI.modal.open(options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  alert(content, title, options) {
    return VxeUI.modal.alert(content, title, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  confirm(content, title, options) {
    return VxeUI.modal.confirm(content, title, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  message(content, options) {
    return VxeUI.modal.message(content, options);
  },
  /**
   * 已废弃，兼容老版本
   * @deprecated
   */
  notification(content, title, options) {
    return VxeUI.modal.notification(content, title, options);
  }
};

// node_modules/vxe-table/es/table/src/util.js
var import_xe_utils17 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/src/columnInfo.js
var import_xe_utils15 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/ui/src/log.js
var { log: log3 } = VxeUI;
var version4 = `table v${"4.9.29"}`;
var warnLog = log3.create("warn", version4);
var errLog = log3.create("error", version4);

// node_modules/vxe-table/es/table/src/columnInfo.js
var { getI18n: getI18n3, formats: formats3 } = VxeUI;
var ColumnInfo = class {
  /* eslint-disable @typescript-eslint/no-use-before-define */
  constructor($xeTable, _vm, { renderHeader, renderCell, renderFooter, renderData } = {}) {
    const $xeGrid = $xeTable.xegrid;
    const formatter = _vm.formatter;
    const visible = import_xe_utils15.default.isBoolean(_vm.visible) ? _vm.visible : true;
    const { props: tableProps } = $xeTable;
    if (true) {
      const types = ["seq", "checkbox", "radio", "expand", "html"];
      if (_vm.type && types.indexOf(_vm.type) === -1) {
        warnLog("vxe.error.errProp", [`type=${_vm.type}`, types.join(", ")]);
      }
      if (import_xe_utils15.default.isBoolean(_vm.cellRender) || _vm.cellRender && !import_xe_utils15.default.isObject(_vm.cellRender)) {
        warnLog("vxe.error.errProp", [`column.cell-render=${_vm.cellRender}`, "column.cell-render={}"]);
      }
      if (import_xe_utils15.default.isBoolean(_vm.editRender) || _vm.editRender && !import_xe_utils15.default.isObject(_vm.editRender)) {
        warnLog("vxe.error.errProp", [`column.edit-render=${_vm.editRender}`, "column.edit-render={}"]);
      }
      if (_vm.cellRender && _vm.editRender) {
        warnLog("vxe.error.errConflicts", ["column.cell-render", "column.edit-render"]);
      }
      if (_vm.type === "expand") {
        const { treeConfig } = tableProps;
        const { computeTreeOpts } = $xeTable.getComputeMaps();
        const treeOpts = computeTreeOpts.value;
        if (treeConfig && (treeOpts.showLine || treeOpts.line)) {
          errLog("vxe.error.errConflicts", ["tree-config.showLine", "column.type=expand"]);
        }
      }
      if (formatter) {
        if (import_xe_utils15.default.isString(formatter)) {
          const gFormatOpts = formats3.get(formatter) || import_xe_utils15.default[formatter];
          if (!gFormatOpts || !import_xe_utils15.default.isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
            errLog("vxe.error.notFormats", [formatter]);
          }
        } else if (import_xe_utils15.default.isArray(formatter)) {
          const gFormatOpts = formats3.get(formatter[0]) || import_xe_utils15.default[formatter[0]];
          if (!gFormatOpts || !import_xe_utils15.default.isFunction(gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod)) {
            errLog("vxe.error.notFormats", [formatter[0]]);
          }
        }
      }
    }
    Object.assign(this, {
      // 基本属性
      type: _vm.type,
      property: _vm.field,
      field: _vm.field,
      title: _vm.title,
      width: _vm.width,
      minWidth: _vm.minWidth,
      maxWidth: _vm.maxWidth,
      resizable: _vm.resizable,
      fixed: _vm.fixed,
      align: _vm.align,
      headerAlign: _vm.headerAlign,
      footerAlign: _vm.footerAlign,
      showOverflow: _vm.showOverflow,
      showHeaderOverflow: _vm.showHeaderOverflow,
      showFooterOverflow: _vm.showFooterOverflow,
      className: _vm.className,
      headerClassName: _vm.headerClassName,
      footerClassName: _vm.footerClassName,
      formatter,
      footerFormatter: _vm.footerFormatter,
      sortable: _vm.sortable,
      sortBy: _vm.sortBy,
      sortType: _vm.sortType,
      filters: toFilters(_vm.filters),
      filterMultiple: import_xe_utils15.default.isBoolean(_vm.filterMultiple) ? _vm.filterMultiple : true,
      filterMethod: _vm.filterMethod,
      filterResetMethod: _vm.filterResetMethod,
      filterRecoverMethod: _vm.filterRecoverMethod,
      filterRender: _vm.filterRender,
      treeNode: _vm.treeNode,
      dragSort: _vm.dragSort,
      cellType: _vm.cellType,
      cellRender: _vm.cellRender,
      editRender: _vm.editRender,
      contentRender: _vm.contentRender,
      headerExportMethod: _vm.headerExportMethod,
      exportMethod: _vm.exportMethod,
      footerExportMethod: _vm.footerExportMethod,
      titleHelp: _vm.titleHelp,
      titlePrefix: _vm.titlePrefix,
      titleSuffix: _vm.titleSuffix,
      // 自定义参数
      params: _vm.params,
      // 渲染属性
      id: _vm.colId || import_xe_utils15.default.uniqueId("col_"),
      parentId: null,
      visible,
      // 内部属性（一旦被使用，将导致不可升级版本）
      halfVisible: false,
      defaultVisible: visible,
      defaultFixed: _vm.fixed,
      checked: false,
      halfChecked: false,
      disabled: false,
      // 分组层级
      level: 1,
      // 跨行
      rowSpan: 1,
      // 跨列
      colSpan: 1,
      // 数据排序
      order: null,
      sortTime: 0,
      // 列排序
      sortNumber: 0,
      renderSortNumber: 0,
      renderFixed: "",
      renderVisible: false,
      renderWidth: 0,
      renderHeight: 0,
      renderResizeWidth: 0,
      renderAutoWidth: 0,
      resizeWidth: 0,
      renderLeft: 0,
      renderArgs: [],
      model: {},
      renderHeader: renderHeader || _vm.renderHeader,
      renderCell: renderCell || _vm.renderCell,
      renderFooter: renderFooter || _vm.renderFooter,
      renderData,
      // 单元格插槽，只对 grid 有效
      slots: _vm.slots
    });
    if ($xeGrid) {
      const { computeProxyOpts } = $xeGrid.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      if (proxyOpts.beforeColumn) {
        proxyOpts.beforeColumn({ $grid: $xeGrid, column: this });
      }
    }
  }
  getTitle() {
    return getFuncText(this.title || (this.type === "seq" ? getI18n3("vxe.table.seqTitle") : ""));
  }
  getKey() {
    const { type } = this;
    return this.field || (type ? `type=${type}` : null);
  }
  update(name, value) {
    if (name !== "filters") {
      if (name === "field") {
        this.property = value;
      }
      this[name] = value;
    }
  }
};

// node_modules/vxe-table/es/ui/src/dom.js
var import_xe_utils16 = __toESM(require_xe_utils());
var reClsMap = {};
var browse2 = import_xe_utils16.default.browse();
var tpImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";
function getPropClass(property, params) {
  return property ? import_xe_utils16.default.isFunction(property) ? property(params) : property : "";
}
function getClsRE(cls) {
  if (!reClsMap[cls]) {
    reClsMap[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, "g");
  }
  return reClsMap[cls];
}
function getNodeOffset(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function isPx(val) {
  return val && /^\d+(px)?$/.test(val);
}
function isScale(val) {
  return val && /^\d+%$/.test(val);
}
function hasClass(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE(cls));
}
function removeClass(elem, cls) {
  if (elem && hasClass(elem, cls)) {
    elem.className = elem.className.replace(getClsRE(cls), "");
  }
}
function addClass(elem, cls) {
  if (elem && !hasClass(elem, cls)) {
    removeClass(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function getDomNode() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getOffsetHeight(elem) {
  return elem ? elem.offsetHeight : 0;
}
function getPaddingTopBottomSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingTop = import_xe_utils16.default.toNumber(computedStyle.paddingTop);
    const paddingBottom = import_xe_utils16.default.toNumber(computedStyle.paddingBottom);
    return paddingTop + paddingBottom;
  }
  return 0;
}
function setScrollTop(elem, scrollTop) {
  if (elem) {
    elem.scrollTop = scrollTop;
  }
}
function setScrollLeft(elem, scrollLeft) {
  if (elem) {
    elem.scrollLeft = scrollLeft;
  }
}
function updateCellTitle(overflowElem, column) {
  const content = column.type === "html" ? overflowElem.innerText : overflowElem.textContent;
  if (overflowElem.getAttribute("title") !== content) {
    overflowElem.setAttribute("title", content);
  }
}
function getEventTargetNode(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos(elem, container) {
  return getNodeOffset(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
var scrollIntoViewIfNeeded = "scrollIntoViewIfNeeded";
var scrollIntoView = "scrollIntoView";
function scrollToView(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded]) {
      elem[scrollIntoViewIfNeeded]();
    } else if (elem[scrollIntoView]) {
      elem[scrollIntoView]();
    }
  }
}
function triggerEvent2(targetElem, type) {
  if (targetElem) {
    targetElem.dispatchEvent(new Event(type));
  }
}
function isNodeElement(elem) {
  return elem && elem.nodeType === 1;
}

// node_modules/vxe-table/es/table/src/util.js
var getAllConvertColumns = (columns, parentColumn) => {
  const result = [];
  columns.forEach((column) => {
    column.parentId = parentColumn ? parentColumn.id : null;
    if (column.visible) {
      if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
        result.push(column);
        result.push(...getAllConvertColumns(column.children, column));
      } else {
        result.push(column);
      }
    }
  });
  return result;
};
var convertHeaderColumnToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;
      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }
    if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
      let colSpan = 0;
      column.children.forEach((subColumn) => {
        if (subColumn.visible) {
          traverse(subColumn, column);
          colSpan += subColumn.colSpan;
        }
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column.level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getAllConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.children && column.children.length && column.children.some((column2) => column2.visible)) {
      column.rowSpan = 1;
    } else {
      column.rowSpan = maxLevel - column.level + 1;
    }
    rows[column.level - 1].push(column);
  });
  return rows;
};
function restoreScrollLocation($xeTable, scrollLeft, scrollTop) {
  const { internalData } = $xeTable;
  return $xeTable.clearScroll().then(() => {
    if (scrollLeft || scrollTop) {
      internalData.lastScrollLeft = 0;
      internalData.lastScrollTop = 0;
      return $xeTable.scrollTo(scrollLeft, scrollTop);
    }
  });
}
function getRowUniqueId() {
  return import_xe_utils17.default.uniqueId("row_");
}
function getRowkey($xeTable) {
  const { props } = $xeTable;
  const { computeRowOpts } = $xeTable.getComputeMaps();
  const { rowId } = props;
  const rowOpts = computeRowOpts.value;
  return rowId || rowOpts.keyField || "_X_ROW_KEY";
}
function getRowid($xeTable, row) {
  const rowid = import_xe_utils17.default.get(row, getRowkey($xeTable));
  return import_xe_utils17.default.eqNull(rowid) ? "" : encodeURIComponent(rowid);
}
var handleFieldOrColumn = ($xeTable, fieldOrColumn) => {
  if (fieldOrColumn) {
    return import_xe_utils17.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
  }
  return null;
};
function getPaddingLeftRightSize(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const paddingLeft = import_xe_utils17.default.toNumber(computedStyle.paddingLeft);
    const paddingRight = import_xe_utils17.default.toNumber(computedStyle.paddingRight);
    return paddingLeft + paddingRight;
  }
  return 0;
}
function getElementMarginWidth(elem) {
  if (elem) {
    const computedStyle = getComputedStyle(elem);
    const marginLeft = import_xe_utils17.default.toNumber(computedStyle.marginLeft);
    const marginRight = import_xe_utils17.default.toNumber(computedStyle.marginRight);
    return elem.offsetWidth + marginLeft + marginRight;
  }
  return 0;
}
function queryCellElement(cell, selector) {
  return cell.querySelector(".vxe-cell" + selector);
}
function toFilters(filters) {
  if (filters && import_xe_utils17.default.isArray(filters)) {
    return filters.map(({ label, value, data, resetValue, checked }) => {
      return { label, value, data, resetValue, checked: !!checked, _checked: !!checked };
    });
  }
  return filters;
}
function toTreePathSeq(path) {
  return path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
}
function getCellValue(row, column) {
  return import_xe_utils17.default.get(row, column.field);
}
function setCellValue(row, column, value) {
  return import_xe_utils17.default.set(row, column.field, value);
}
function getRefElem(refEl) {
  if (refEl) {
    const rest = refEl.value;
    if (rest) {
      return rest.$el || rest;
    }
  }
  return null;
}
function getColReMinWidth(params) {
  const { $table, column, cell } = params;
  const { props: tableProps } = $table;
  const { computeResizableOpts } = $table.getComputeMaps();
  const resizableOpts = computeResizableOpts.value;
  const { minWidth: reMinWidth } = resizableOpts;
  if (reMinWidth) {
    const customMinWidth = import_xe_utils17.default.isFunction(reMinWidth) ? reMinWidth(params) : reMinWidth;
    if (customMinWidth !== "auto") {
      return Math.max(1, import_xe_utils17.default.toNumber(customMinWidth));
    }
  }
  const { showHeaderOverflow: allColumnHeaderOverflow } = tableProps;
  const { showHeaderOverflow, minWidth: colMinWidth } = column;
  const headOverflow = import_xe_utils17.default.isUndefined(showHeaderOverflow) || import_xe_utils17.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showEllipsis = headOverflow === "ellipsis";
  const showTitle = headOverflow === "title";
  const showTooltip = headOverflow === true || headOverflow === "tooltip";
  const hasEllipsis = showTitle || showTooltip || showEllipsis;
  const minTitleWidth = import_xe_utils17.default.floor((import_xe_utils17.default.toNumber(getComputedStyle(cell).fontSize) || 14) * 1.6);
  const paddingLeftRight = getPaddingLeftRightSize(cell) + getPaddingLeftRightSize(queryCellElement(cell, ""));
  let mWidth = minTitleWidth + paddingLeftRight;
  if (hasEllipsis) {
    const dragIconWidth = getPaddingLeftRightSize(queryCellElement(cell, ">.vxe-cell--drag-handle"));
    const checkboxIconWidth = getPaddingLeftRightSize(queryCellElement(cell, ">.vxe-cell--checkbox"));
    const requiredIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell--required-icon"));
    const editIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell--edit-icon"));
    const prefixIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell-title-prefix-icon"));
    const suffixIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell-title-suffix-icon"));
    const sortIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell--sort"));
    const filterIconWidth = getElementMarginWidth(queryCellElement(cell, ">.vxe-cell--filter"));
    mWidth += dragIconWidth + checkboxIconWidth + requiredIconWidth + editIconWidth + prefixIconWidth + suffixIconWidth + filterIconWidth + sortIconWidth;
  }
  if (colMinWidth) {
    const { refTableBody } = $table.getRefMaps();
    const tableBody = refTableBody.value;
    const bodyElem = tableBody ? tableBody.$el : null;
    if (bodyElem) {
      if (isScale(colMinWidth)) {
        const bodyWidth = bodyElem.clientWidth - 1;
        const meanWidth = bodyWidth / 100;
        return Math.max(mWidth, Math.floor(import_xe_utils17.default.toInteger(colMinWidth) * meanWidth));
      } else if (isPx(colMinWidth)) {
        return Math.max(mWidth, import_xe_utils17.default.toInteger(colMinWidth));
      }
    }
  }
  return mWidth;
}
function isColumnInfo(column) {
  return column && (column.constructor === ColumnInfo || column instanceof ColumnInfo);
}
function createColumn($xeTable, options, renderOptions) {
  return isColumnInfo(options) ? options : reactive(new ColumnInfo($xeTable, options, renderOptions));
}
function watchColumn($xeTable, props, column) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      column.update(name, value);
      if ($xeTable) {
        if (name === "filters") {
          $xeTable.setFilter(column, value);
          $xeTable.handleUpdateDataQueue();
        } else if (["visible", "fixed", "width", "minWidth", "maxWidth"].includes(name)) {
          $xeTable.handleRefreshColumnQueue();
        }
      }
    });
  });
}
function assembleColumn($xeTable, elem, column, colgroup) {
  const { reactData } = $xeTable;
  const { staticColumns } = reactData;
  const parentElem = elem.parentNode;
  const parentColumn = colgroup ? colgroup.columnConfig : null;
  const parentCols = parentColumn ? parentColumn.children : staticColumns;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils17.default.arrayIndexOf(parentElem.children, elem), 0, column);
    reactData.staticColumns = staticColumns.slice(0);
  }
}
function destroyColumn($xeTable, column) {
  const { reactData } = $xeTable;
  const { staticColumns } = reactData;
  const matchObj = import_xe_utils17.default.findTree(staticColumns, (item) => item.id === column.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticColumns = staticColumns.slice(0);
}
function getRootColumn($xeTable, column) {
  const { internalData } = $xeTable;
  const { fullColumnIdData } = internalData;
  if (!column) {
    return null;
  }
  let parentColId = column.parentId;
  while (fullColumnIdData[parentColId]) {
    const column2 = fullColumnIdData[parentColId].column;
    parentColId = column2.parentId;
    if (!parentColId) {
      return column2;
    }
  }
  return column;
}
function mergeBodyMethod(mergeList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
function clearTableDefaultStatus($xeTable) {
  const { props, internalData } = $xeTable;
  internalData.initStatus = false;
  $xeTable.clearSort();
  $xeTable.clearCurrentRow();
  $xeTable.clearCurrentColumn();
  $xeTable.clearRadioRow();
  $xeTable.clearRadioReserve();
  $xeTable.clearCheckboxRow();
  $xeTable.clearCheckboxReserve();
  $xeTable.clearRowExpand();
  $xeTable.clearTreeExpand();
  $xeTable.clearTreeExpandReserve();
  $xeTable.clearPendingRow();
  if ($xeTable.clearFilter) {
    $xeTable.clearFilter();
  }
  if ($xeTable.clearSelected && (props.keyboardConfig || props.mouseConfig)) {
    $xeTable.clearSelected();
  }
  if ($xeTable.clearCellAreas && props.mouseConfig) {
    $xeTable.clearCellAreas();
    $xeTable.clearCopyCellArea();
  }
  return $xeTable.clearScroll();
}
function clearTableAllStatus($xeTable) {
  if ($xeTable.clearFilter) {
    $xeTable.clearFilter();
  }
  return clearTableDefaultStatus($xeTable);
}
function rowToVisible($xeTable, row) {
  const { reactData, internalData } = $xeTable;
  const tableProps = $xeTable.props;
  const { showOverflow } = tableProps;
  const { refTableBody } = $xeTable.getRefMaps();
  const { columnStore, scrollYLoad } = reactData;
  const { afterFullData, scrollYStore, fullAllDataRowIdData } = internalData;
  const tableBody = refTableBody.value;
  const { leftList, rightList } = columnStore;
  const bodyElem = tableBody ? tableBody.$el : null;
  const rowid = getRowid($xeTable, row);
  let offsetFixedLeft = 0;
  leftList.forEach((item) => {
    offsetFixedLeft += item.renderWidth;
  });
  let offsetFixedRight = 0;
  rightList.forEach((item) => {
    offsetFixedRight += item.renderWidth;
  });
  if (bodyElem) {
    const bodyHeight = bodyElem.clientHeight;
    const bodyScrollTop = bodyElem.scrollTop;
    const trElem = bodyElem.querySelector(`[rowid="${rowid}"]`);
    if (trElem) {
      const trOffsetParent = trElem.offsetParent;
      const trOffsetTop = trElem.offsetTop + (trOffsetParent ? trOffsetParent.offsetTop : 0);
      const trHeight = trElem.clientHeight;
      if (trOffsetTop < bodyScrollTop || trOffsetTop > bodyScrollTop + bodyHeight) {
        return $xeTable.scrollTo(null, trOffsetTop);
      } else if (trOffsetTop + trHeight >= bodyHeight + bodyScrollTop) {
        return $xeTable.scrollTo(null, bodyScrollTop + trHeight);
      }
    } else {
      if (scrollYLoad) {
        if (showOverflow) {
          return $xeTable.scrollTo(null, ($xeTable.findRowIndexOf(afterFullData, row) - 1) * scrollYStore.rowHeight);
        }
        let scrollTop = 0;
        const rest = fullAllDataRowIdData[rowid];
        const rHeight = rest ? rest.height : 0;
        for (let i = 0; i < afterFullData.length; i++) {
          const currRow = afterFullData[i];
          const currRowid = getRowid($xeTable, currRow);
          if (currRow === row || currRowid === rowid) {
            break;
          }
          const rest2 = fullAllDataRowIdData[currRowid];
          scrollTop += rest2 ? rest2.height : 0;
        }
        if (scrollTop < bodyScrollTop) {
          return $xeTable.scrollTo(null, scrollTop - offsetFixedLeft - 1);
        }
        return $xeTable.scrollTo(null, scrollTop + rHeight - (bodyHeight - offsetFixedRight - 1));
      }
    }
  }
  return Promise.resolve();
}
function colToVisible($xeTable, column, row) {
  const { reactData, internalData } = $xeTable;
  const { refTableBody } = $xeTable.getRefMaps();
  const { columnStore, scrollXLoad } = reactData;
  const { visibleColumn } = internalData;
  const { leftList, rightList } = columnStore;
  const tableBody = refTableBody.value;
  const bodyElem = tableBody ? tableBody.$el : null;
  if (column.fixed) {
    return Promise.resolve();
  }
  let offsetFixedLeft = 0;
  leftList.forEach((item) => {
    offsetFixedLeft += item.renderWidth;
  });
  let offsetFixedRight = 0;
  rightList.forEach((item) => {
    offsetFixedRight += item.renderWidth;
  });
  if (bodyElem) {
    const bodyWidth = bodyElem.clientWidth;
    const bodyScrollLeft = bodyElem.scrollLeft;
    let tdElem = null;
    if (row) {
      const rowid = getRowid($xeTable, row);
      tdElem = bodyElem.querySelector(`[rowid="${rowid}"] .${column.id}`);
    }
    if (!tdElem) {
      tdElem = bodyElem.querySelector(`.${column.id}`);
    }
    if (tdElem) {
      const tdOffsetParent = tdElem.offsetParent;
      const tdOffsetLeft = tdElem.offsetLeft + (tdOffsetParent ? tdOffsetParent.offsetLeft : 0);
      const cellWidth = tdElem.clientWidth;
      if (tdOffsetLeft < bodyScrollLeft + offsetFixedLeft) {
        return $xeTable.scrollTo(tdOffsetLeft - offsetFixedLeft - 1);
      } else if (tdOffsetLeft + cellWidth - bodyScrollLeft > bodyWidth - offsetFixedRight) {
        return $xeTable.scrollTo(tdOffsetLeft + cellWidth - (bodyWidth - offsetFixedRight - 1));
      }
    } else {
      if (scrollXLoad) {
        let scrollLeft = 0;
        const cellWidth = column.renderWidth;
        for (let i = 0; i < visibleColumn.length; i++) {
          const currCol = visibleColumn[i];
          if (currCol === column || currCol.id === column.id) {
            break;
          }
          scrollLeft += currCol.renderWidth;
        }
        if (scrollLeft < bodyScrollLeft) {
          return $xeTable.scrollTo(scrollLeft - offsetFixedLeft - 1);
        }
        return $xeTable.scrollTo(scrollLeft + cellWidth - (bodyWidth - offsetFixedRight - 1));
      }
    }
  }
  return Promise.resolve();
}

// node_modules/vxe-table/es/table/src/cell.js
var import_xe_utils19 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/ui/src/vn.js
var import_xe_utils18 = __toESM(require_xe_utils());
function getOnName(type) {
  return "on" + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
      return "input";
    case "select":
      return "change";
  }
  return "update:modelValue";
}
function getChangeEvent(renderOpts) {
  switch (renderOpts.name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeNumberInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function getSlotVNs(vns) {
  if (import_xe_utils18.default.isArray(vns)) {
    return vns;
  }
  return [vns];
}

// node_modules/vxe-table/es/table/src/cell.js
var { getI18n: getI18n4, getIcon: getIcon3, renderer: renderer3, formats: formats4, renderEmptyElement: renderEmptyElement2 } = VxeUI;
function renderTitlePrefixIcon(params) {
  const { $table, column } = params;
  const titlePrefix = column.titlePrefix || column.titleHelp;
  if (titlePrefix) {
    return h("i", {
      class: ["vxe-cell-title-prefix-icon", titlePrefix.icon || getIcon3().TABLE_TITLE_PREFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titlePrefix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    });
  }
  return renderEmptyElement2($table);
}
function renderTitleSuffixIcon(params) {
  const { $table, column } = params;
  const titleSuffix = column.titleSuffix;
  if (titleSuffix) {
    return h("i", {
      class: ["vxe-cell-title-suffix-icon", titleSuffix.icon || getIcon3().TABLE_TITLE_SUFFIX],
      onMouseenter(evnt) {
        $table.triggerHeaderTitleEvent(evnt, titleSuffix, params);
      },
      onMouseleave(evnt) {
        $table.handleTargetLeaveEvent(evnt);
      }
    });
  }
  return renderEmptyElement2($table);
}
function renderCellDragIcon(params) {
  const { $table } = params;
  const tableProps = $table.props;
  const { dragConfig } = tableProps;
  const { computeRowDragOpts } = $table.getComputeMaps();
  const rowDragOpts = computeRowDragOpts.value;
  const { icon, trigger, disabledMethod } = rowDragOpts;
  const rDisabledMethod = disabledMethod || (dragConfig ? dragConfig.rowDisabledMethod : null);
  const isDisabled = rDisabledMethod && rDisabledMethod(params);
  const ons = {};
  if (trigger !== "cell") {
    ons.onMousedown = (evnt) => {
      if (!isDisabled) {
        $table.handleCellDragMousedownEvent(evnt, params);
      }
    };
    ons.onMouseup = $table.handleCellDragMouseupEvent;
  }
  return h("span", Object.assign({ key: "dg", class: ["vxe-cell--drag-handle", {
    "is--disabled": isDisabled
  }] }, ons), [
    h("i", {
      class: icon || (dragConfig ? dragConfig.rowIcon : "") || getIcon3().TABLE_DRAG_ROW
    })
  ]);
}
function renderCellBaseVNs(params, content) {
  const { $table, column, level } = params;
  const { dragSort } = column;
  const tableProps = $table.props;
  const { treeConfig, dragConfig } = tableProps;
  const { computeRowOpts, computeRowDragOpts } = $table.getComputeMaps();
  const rowOpts = computeRowOpts.value;
  const rowDragOpts = computeRowDragOpts.value;
  const { showIcon, isCrossDrag, visibleMethod } = rowDragOpts;
  const rVisibleMethod = visibleMethod || (dragConfig ? dragConfig.rowVisibleMethod : null);
  const vns = import_xe_utils19.default.isArray(content) ? content : [content];
  if (dragSort && rowOpts.drag && ((showIcon || (dragConfig ? dragConfig.showRowIcon : false)) && (!rVisibleMethod || rVisibleMethod(params)))) {
    if (treeConfig) {
      if (isCrossDrag || !level) {
        vns.unshift(renderCellDragIcon(params));
      }
    } else {
      vns.unshift(renderCellDragIcon(params));
    }
  }
  return vns;
}
function renderHeaderCellDragIcon(params) {
  const { $table, column } = params;
  const { computeColumnOpts, computeColumnDragOpts } = $table.getComputeMaps();
  const columnOpts = computeColumnOpts.value;
  const columnDragOpts = computeColumnDragOpts.value;
  const { showIcon, icon, trigger, isCrossDrag, visibleMethod, disabledMethod } = columnDragOpts;
  if (columnOpts.drag && showIcon && (!visibleMethod || visibleMethod(params))) {
    if (!column.fixed && (isCrossDrag || !column.parentId)) {
      const isDisabled = disabledMethod && disabledMethod(params);
      const ons = {};
      if (trigger !== "cell") {
        ons.onMousedown = (evnt) => {
          if (!isDisabled) {
            $table.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        };
        ons.onMouseup = $table.handleHeaderCellDragMouseupEvent;
      }
      return h("span", Object.assign({ key: "dg", class: ["vxe-cell--drag-handle", {
        "is--disabled": isDisabled
      }] }, ons), [
        h("i", {
          class: icon || getIcon3().TABLE_DRAG_COLUMN
        })
      ]);
    }
  }
  return renderEmptyElement2($table);
}
function renderHeaderCellBaseVNs(params, content) {
  const vns = [
    renderTitlePrefixIcon(params),
    renderHeaderCellDragIcon(params),
    ...import_xe_utils19.default.isArray(content) ? content : [content],
    renderTitleSuffixIcon(params)
  ];
  return vns;
}
function renderTitleContent(params, content) {
  const { $table, column } = params;
  const { props, reactData } = $table;
  const { computeTooltipOpts } = $table.getComputeMaps();
  const { showHeaderOverflow: allColumnHeaderOverflow } = props;
  const { type, showHeaderOverflow } = column;
  const tooltipOpts = computeTooltipOpts.value;
  const showAllTip = tooltipOpts.showAll;
  const headOverflow = import_xe_utils19.default.isUndefined(showHeaderOverflow) || import_xe_utils19.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
  const showTitle = headOverflow === "title";
  const showTooltip = headOverflow === true || headOverflow === "tooltip";
  const ons = {};
  if (showTitle || showTooltip || showAllTip) {
    ons.onMouseenter = (evnt) => {
      if (reactData._isResize) {
        return;
      }
      if (showTitle) {
        updateCellTitle(evnt.currentTarget, column);
      } else if (showTooltip || showAllTip) {
        $table.triggerHeaderTooltipEvent(evnt, params);
      }
    };
  }
  if (showTooltip || showAllTip) {
    ons.onMouseleave = (evnt) => {
      if (reactData._isResize) {
        return;
      }
      if (showTooltip || showAllTip) {
        $table.handleTargetLeaveEvent(evnt);
      }
    };
  }
  return [
    type === "html" && import_xe_utils19.default.isString(content) ? h("span", Object.assign({ class: "vxe-cell--title", innerHTML: content }, ons)) : h("span", Object.assign({ class: "vxe-cell--title" }, ons), getSlotVNs(content))
  ];
}
function formatFooterLabel(footerFormatter, params) {
  if (import_xe_utils19.default.isFunction(footerFormatter)) {
    return footerFormatter(params);
  }
  const isArr = import_xe_utils19.default.isArray(footerFormatter);
  const gFormatOpts = isArr ? formats4.get(footerFormatter[0]) : formats4.get(footerFormatter);
  const footerFormatMethod = gFormatOpts ? gFormatOpts.tableFooterCellFormatMethod : null;
  if (footerFormatMethod) {
    return isArr ? footerFormatMethod(params, ...footerFormatter.slice(1)) : footerFormatMethod(params);
  }
  return "";
}
function getFooterContent(params) {
  const { $table, column, _columnIndex, items, row } = params;
  const { slots, editRender, cellRender, footerFormatter } = column;
  const renderOpts = editRender || cellRender;
  const footerSlot = slots ? slots.footer : null;
  if (footerSlot) {
    return $table.callSlot(footerSlot, params);
  }
  if (renderOpts) {
    const compConf = renderer3.get(renderOpts.name);
    if (compConf) {
      const rtFooter = compConf.renderTableFooter || compConf.renderFooter;
      if (rtFooter) {
        return getSlotVNs(rtFooter(renderOpts, params));
      }
    }
  }
  let itemValue = "";
  if (import_xe_utils19.default.isArray(items)) {
    itemValue = items[_columnIndex];
    return [
      footerFormatter ? formatFooterLabel(footerFormatter, {
        itemValue,
        column,
        row,
        items,
        _columnIndex
      }) : formatText(itemValue, 1)
    ];
  }
  itemValue = import_xe_utils19.default.get(row, column.field);
  return [
    footerFormatter ? formatFooterLabel(footerFormatter, {
      itemValue,
      column,
      row,
      items,
      _columnIndex
    }) : formatText(itemValue, 1)
  ];
}
function getDefaultCellLabel(params) {
  const { $table, row, column } = params;
  return formatText($table.getCellLabel(row, column), 1);
}
var Cell = {
  createColumn($xeTable, columnOpts) {
    const { type, sortable, filters, editRender, treeNode } = columnOpts;
    const { props } = $xeTable;
    const { editConfig } = props;
    const { computeEditOpts, computeCheckboxOpts } = $xeTable.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const editOpts = computeEditOpts.value;
    const renConfs = {
      renderHeader: Cell.renderDefaultHeader,
      renderCell: treeNode ? Cell.renderTreeCell : Cell.renderDefaultCell,
      renderFooter: Cell.renderDefaultFooter
    };
    switch (type) {
      case "seq":
        renConfs.renderHeader = Cell.renderSeqHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeIndexCell : Cell.renderSeqCell;
        break;
      case "radio":
        renConfs.renderHeader = Cell.renderRadioHeader;
        renConfs.renderCell = treeNode ? Cell.renderTreeRadioCell : Cell.renderRadioCell;
        break;
      case "checkbox":
        renConfs.renderHeader = Cell.renderCheckboxHeader;
        renConfs.renderCell = checkboxOpts.checkField ? treeNode ? Cell.renderTreeSelectionCellByProp : Cell.renderCheckboxCellByProp : treeNode ? Cell.renderTreeSelectionCell : Cell.renderCheckboxCell;
        break;
      case "expand":
        renConfs.renderCell = Cell.renderExpandCell;
        renConfs.renderData = Cell.renderExpandData;
        break;
      case "html":
        renConfs.renderCell = treeNode ? Cell.renderTreeHTMLCell : Cell.renderHTMLCell;
        if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
        break;
      default:
        if (editConfig && editRender) {
          renConfs.renderHeader = Cell.renderEditHeader;
          renConfs.renderCell = editOpts.mode === "cell" ? treeNode ? Cell.renderTreeCellEdit : Cell.renderCellEdit : treeNode ? Cell.renderTreeRowEdit : Cell.renderRowEdit;
        } else if (filters && sortable) {
          renConfs.renderHeader = Cell.renderSortAndFilterHeader;
        } else if (sortable) {
          renConfs.renderHeader = Cell.renderSortHeader;
        } else if (filters) {
          renConfs.renderHeader = Cell.renderFilterHeader;
        }
    }
    return createColumn($xeTable, columnOpts, renConfs);
  },
  /**
   * 列头标题
   */
  renderHeaderTitle(params) {
    const { $table, column } = params;
    const { slots, editRender, cellRender } = column;
    const renderOpts = editRender || cellRender;
    const headerSlot = slots ? slots.header : null;
    if (headerSlot) {
      return renderTitleContent(params, $table.callSlot(headerSlot, params));
    }
    if (renderOpts) {
      const compConf = renderer3.get(renderOpts.name);
      if (compConf) {
        const rtHeader = compConf.renderTableHeader || compConf.renderHeader;
        if (rtHeader) {
          return renderTitleContent(params, getSlotVNs(rtHeader(renderOpts, params)));
        }
      }
    }
    return renderTitleContent(params, formatText(column.getTitle(), 1));
  },
  renderDefaultHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params));
  },
  renderDefaultCell(params) {
    const { $table, row, column } = params;
    const { slots, editRender, cellRender } = column;
    const renderOpts = editRender || cellRender;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    if (renderOpts) {
      const compConf = renderer3.get(renderOpts.name);
      if (compConf) {
        const rtCell = compConf.renderTableCell || compConf.renderCell;
        const rtDefault = compConf.renderTableDefault || compConf.renderDefault;
        const renderFn = editRender ? rtCell : rtDefault;
        if (renderFn) {
          return renderCellBaseVNs(params, getSlotVNs(renderFn(renderOpts, Object.assign({ $type: editRender ? "edit" : "cell" }, params))));
        }
      }
    }
    const cellValue = $table.getCellLabel(row, column);
    const cellPlaceholder = editRender ? editRender.placeholder : "";
    return renderCellBaseVNs(params, [
      h("span", {
        class: "vxe-cell--label"
      }, [
        // 如果设置占位符
        editRender && eqEmptyValue(cellValue) ? h("span", {
          class: "vxe-cell--placeholder"
        }, formatText(getFuncText(cellPlaceholder), 1)) : h("span", formatText(cellValue, 1))
      ])
    ]);
  },
  renderTreeCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderDefaultCell(params));
  },
  renderDefaultFooter(params) {
    return [
      h("span", {
        class: "vxe-cell--item"
      }, getFooterContent(params))
    ];
  },
  /**
   * 树节点
   */
  renderTreeIcon(params, cellVNodes) {
    const { $table, isHidden } = params;
    const { reactData, internalData } = $table;
    const { computeTreeOpts } = $table.getComputeMaps();
    const { treeExpandedMaps, treeExpandLazyLoadedMaps } = reactData;
    const { fullAllDataRowIdData } = internalData;
    const treeOpts = computeTreeOpts.value;
    const { row, column, level } = params;
    const { slots } = column;
    const { indent, lazy, trigger, iconLoaded, showIcon, iconOpen, iconClose } = treeOpts;
    const childrenField = treeOpts.children || treeOpts.childrenField;
    const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
    const rowChilds = row[childrenField];
    const hasChild = rowChilds && rowChilds.length;
    const iconSlot = slots ? slots.icon : null;
    let hasLazyChilds = false;
    let isAceived = false;
    let isLazyLoading = false;
    let isLazyLoaded = false;
    const ons = {};
    if (iconSlot) {
      return $table.callSlot(iconSlot, params);
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!treeExpandedMaps[rowid];
      if (lazy) {
        const rest = fullAllDataRowIdData[rowid];
        isLazyLoading = !!treeExpandLazyLoadedMaps[rowid];
        hasLazyChilds = row[hasChildField];
        isLazyLoaded = !!rest.treeLoaded;
      }
    }
    if (!trigger || trigger === "default") {
      ons.onClick = (evnt) => {
        $table.triggerTreeExpandEvent(evnt, params);
      };
    }
    return [
      h("div", {
        class: ["vxe-cell--tree-node", {
          "is--active": isAceived
        }],
        style: {
          paddingLeft: `${level * indent}px`
        }
      }, [
        showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [
          h("div", Object.assign({ class: "vxe-tree--btn-wrapper" }, ons), [
            h("i", {
              class: ["vxe-tree--node-btn", isLazyLoading ? iconLoaded || getIcon3().TABLE_TREE_LOADED : isAceived ? iconOpen || getIcon3().TABLE_TREE_OPEN : iconClose || getIcon3().TABLE_TREE_CLOSE]
            })
          ])
        ] : null,
        h("div", {
          class: "vxe-tree-cell"
        }, cellVNodes)
      ])
    ];
  },
  /**
   * 序号
   */
  renderSeqHeader(params) {
    const { $table, column } = params;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    return renderHeaderCellBaseVNs(params, renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : formatText(column.getTitle(), 1)));
  },
  renderSeqCell(params) {
    const { $table, column } = params;
    const { props } = $table;
    const { treeConfig } = props;
    const { computeSeqOpts } = $table.getComputeMaps();
    const seqOpts = computeSeqOpts.value;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    const { seq } = params;
    const seqMethod = seqOpts.seqMethod;
    return renderCellBaseVNs(params, [
      h("span", `${formatText(seqMethod ? seqMethod(params) : treeConfig ? seq : (seqOpts.startIndex || 0) + seq, 1)}`)
    ]);
  },
  renderTreeIndexCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderSeqCell(params));
  },
  /**
   * 单选
   */
  renderRadioHeader(params) {
    const { $table, column } = params;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    return renderHeaderCellBaseVNs(params, renderTitleContent(params, headerSlot ? $table.callSlot(headerSlot, params) : [
      h("span", {
        class: "vxe-radio--label"
      }, titleSlot ? $table.callSlot(titleSlot, params) : formatText(column.getTitle(), 1))
    ]));
  },
  renderRadioCell(params) {
    const { $table, column, isHidden } = params;
    const { reactData } = $table;
    const { computeRadioOpts } = $table.getComputeMaps();
    const { selectRadioRow } = reactData;
    const radioOpts = computeRadioOpts.value;
    const { slots } = column;
    const { labelField, checkMethod, visibleMethod } = radioOpts;
    const { row } = params;
    const defaultSlot = slots ? slots.default : null;
    const radioSlot = slots ? slots.radio : null;
    const isChecked = $table.eqRow(row, selectRadioRow);
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerRadioRowEvent(evnt, params);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
    }
    const radioParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible });
    if (radioSlot) {
      return renderCellBaseVNs(params, $table.callSlot(radioSlot, radioParams));
    }
    const radioVNs = [];
    if (isVisible) {
      radioVNs.push(h("span", {
        class: ["vxe-radio--icon", isChecked ? getIcon3().TABLE_RADIO_CHECKED : getIcon3().TABLE_RADIO_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      radioVNs.push(h("span", {
        class: "vxe-radio--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, radioParams) : import_xe_utils19.default.get(row, labelField)));
    }
    return renderCellBaseVNs(params, [
      h("span", Object.assign({ class: ["vxe-cell--radio", {
        "is--checked": isChecked,
        "is--disabled": isDisabled
      }] }, ons), radioVNs)
    ]);
  },
  renderTreeRadioCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderRadioCell(params));
  },
  /**
   * 多选
   */
  renderCheckboxHeader(params) {
    const { $table, column, isHidden } = params;
    const { reactData } = $table;
    const { computeIsAllCheckboxDisabled, computeCheckboxOpts } = $table.getComputeMaps();
    const { isAllSelected: isAllCheckboxSelected, isIndeterminate: isAllCheckboxIndeterminate } = reactData;
    const isAllCheckboxDisabled = computeIsAllCheckboxDisabled.value;
    const { slots } = column;
    const headerSlot = slots ? slots.header : null;
    const titleSlot = slots ? slots.title : null;
    const checkboxOpts = computeCheckboxOpts.value;
    const headerTitle = column.getTitle();
    let ons;
    if (!isHidden) {
      ons = {
        onClick(evnt) {
          if (!isAllCheckboxDisabled) {
            $table.triggerCheckAllEvent(evnt, !isAllCheckboxSelected);
          }
        }
      };
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isAllCheckboxSelected, disabled: isAllCheckboxDisabled, indeterminate: isAllCheckboxIndeterminate });
    if (headerSlot) {
      return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, $table.callSlot(headerSlot, checkboxParams)));
    }
    if (checkboxOpts.checkStrictly ? !checkboxOpts.showHeader : checkboxOpts.showHeader === false) {
      return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, [
        h("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ]));
    }
    return renderHeaderCellBaseVNs(params, renderTitleContent(checkboxParams, [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isAllCheckboxSelected,
        "is--disabled": isAllCheckboxDisabled,
        "is--indeterminate": isAllCheckboxIndeterminate
      }], title: getI18n4("vxe.table.allTitle") }, ons), [
        h("span", {
          class: ["vxe-checkbox--icon", isAllCheckboxIndeterminate ? getIcon3().TABLE_CHECKBOX_INDETERMINATE : isAllCheckboxSelected ? getIcon3().TABLE_CHECKBOX_CHECKED : getIcon3().TABLE_CHECKBOX_UNCHECKED]
        })
      ].concat(titleSlot || headerTitle ? [
        h("span", {
          class: "vxe-checkbox--label"
        }, titleSlot ? $table.callSlot(titleSlot, checkboxParams) : headerTitle)
      ] : []))
    ]));
  },
  renderCheckboxCell(params) {
    const { $table, row, column, isHidden } = params;
    const { props, reactData } = $table;
    const { treeConfig } = props;
    const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
    const { computeCheckboxOpts } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const { labelField, checkMethod, visibleMethod } = checkboxOpts;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let indeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = !!selectCheckboxMaps[rowid];
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
      if (treeConfig) {
        indeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate });
    if (checkboxSlot) {
      return renderCellBaseVNs(params, $table.callSlot(checkboxSlot, checkboxParams));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h("span", {
        class: ["vxe-checkbox--icon", indeterminate ? getIcon3().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon3().TABLE_CHECKBOX_CHECKED : getIcon3().TABLE_CHECKBOX_UNCHECKED]
      }));
    }
    if (defaultSlot || labelField) {
      checkVNs.push(h("span", {
        class: "vxe-checkbox--label"
      }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : import_xe_utils19.default.get(row, labelField)));
    }
    return renderCellBaseVNs(params, [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminate,
        "is--hidden": !isVisible
      }] }, ons), checkVNs)
    ]);
  },
  renderTreeSelectionCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCell(params));
  },
  renderCheckboxCellByProp(params) {
    const { $table, row, column, isHidden } = params;
    const { props, reactData } = $table;
    const { treeConfig } = props;
    const { treeIndeterminateMaps } = reactData;
    const { computeCheckboxOpts } = $table.getComputeMaps();
    const checkboxOpts = computeCheckboxOpts.value;
    const { labelField, checkField, checkMethod, visibleMethod } = checkboxOpts;
    const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const checkboxSlot = slots ? slots.checkbox : null;
    let isIndeterminate = false;
    let isChecked = false;
    const isVisible = !visibleMethod || visibleMethod({ row });
    let isDisabled = !!checkMethod;
    let ons;
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isChecked = import_xe_utils19.default.get(row, checkField);
      ons = {
        onClick(evnt) {
          if (!isDisabled && isVisible) {
            $table.triggerCheckRowEvent(evnt, params, !isChecked);
          }
        }
      };
      if (checkMethod) {
        isDisabled = !checkMethod({ row });
      }
      if (treeConfig) {
        isIndeterminate = !!treeIndeterminateMaps[rowid];
      }
    }
    const checkboxParams = Object.assign(Object.assign({}, params), { checked: isChecked, disabled: isDisabled, visible: isVisible, indeterminate: isIndeterminate });
    if (checkboxSlot) {
      return renderCellBaseVNs(params, $table.callSlot(checkboxSlot, checkboxParams));
    }
    const checkVNs = [];
    if (isVisible) {
      checkVNs.push(h("span", {
        class: ["vxe-checkbox--icon", isIndeterminate ? getIcon3().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon3().TABLE_CHECKBOX_CHECKED : getIcon3().TABLE_CHECKBOX_UNCHECKED]
      }));
      if (defaultSlot || labelField) {
        checkVNs.push(h("span", {
          class: "vxe-checkbox--label"
        }, defaultSlot ? $table.callSlot(defaultSlot, checkboxParams) : import_xe_utils19.default.get(row, labelField)));
      }
    }
    return renderCellBaseVNs(params, [
      h("span", Object.assign({ class: ["vxe-cell--checkbox", {
        "is--checked": isChecked,
        "is--disabled": isDisabled,
        "is--indeterminate": indeterminateField && !isChecked ? row[indeterminateField] : isIndeterminate,
        "is--hidden": !isVisible
      }] }, ons), checkVNs)
    ]);
  },
  renderTreeSelectionCellByProp(params) {
    return Cell.renderTreeIcon(params, Cell.renderCheckboxCellByProp(params));
  },
  /**
   * 展开行
   */
  renderExpandCell(params) {
    const { $table, isHidden, row, column } = params;
    const { reactData } = $table;
    const { rowExpandedMaps, rowExpandLazyLoadedMaps } = reactData;
    const { computeExpandOpts } = $table.getComputeMaps();
    const expandOpts = computeExpandOpts.value;
    const { lazy, labelField, iconLoaded, showIcon, iconOpen, iconClose, visibleMethod } = expandOpts;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    const iconSlot = slots ? slots.icon : null;
    let isAceived = false;
    let isLazyLoading = false;
    if (iconSlot) {
      return renderCellBaseVNs(params, $table.callSlot(iconSlot, params));
    }
    if (!isHidden) {
      const rowid = getRowid($table, row);
      isAceived = !!rowExpandedMaps[rowid];
      if (lazy) {
        isLazyLoading = !!rowExpandLazyLoadedMaps[rowid];
      }
    }
    return renderCellBaseVNs(params, [
      showIcon && (!visibleMethod || visibleMethod(params)) ? h("span", {
        class: ["vxe-table--expanded", {
          "is--active": isAceived
        }],
        onClick(evnt) {
          $table.triggerRowExpandEvent(evnt, params);
        }
      }, [
        h("i", {
          class: ["vxe-table--expand-btn", isLazyLoading ? iconLoaded || getIcon3().TABLE_EXPAND_LOADED : isAceived ? iconOpen || getIcon3().TABLE_EXPAND_OPEN : iconClose || getIcon3().TABLE_EXPAND_CLOSE]
        })
      ]) : renderEmptyElement2($table),
      defaultSlot || labelField ? h("span", {
        class: "vxe-table--expand-label"
      }, defaultSlot ? $table.callSlot(defaultSlot, params) : import_xe_utils19.default.get(row, labelField)) : renderEmptyElement2($table)
    ]);
  },
  renderExpandData(params) {
    const { $table, column } = params;
    const { slots, contentRender } = column;
    const contentSlot = slots ? slots.content : null;
    if (contentSlot) {
      return $table.callSlot(contentSlot, params);
    }
    if (contentRender) {
      const compConf = renderer3.get(contentRender.name);
      if (compConf) {
        const rtExpand = compConf.renderTableExpand || compConf.renderExpand;
        if (rtExpand) {
          return getSlotVNs(rtExpand(contentRender, params));
        }
      }
    }
    return [];
  },
  /**
   * HTML 标签
   */
  renderHTMLCell(params) {
    const { $table, column } = params;
    const { slots } = column;
    const defaultSlot = slots ? slots.default : null;
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, params));
    }
    return renderCellBaseVNs(params, [
      h("span", {
        class: "vxe-cell--html",
        innerHTML: getDefaultCellLabel(params)
      })
    ]);
  },
  renderTreeHTMLCell(params) {
    return Cell.renderTreeIcon(params, Cell.renderHTMLCell(params));
  },
  /**
   * 排序和筛选
   */
  renderSortAndFilterHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderSortIcon(params).concat(Cell.renderFilterIcon(params))));
  },
  /**
   * 排序
   */
  renderSortHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderSortIcon(params)));
  },
  renderSortIcon(params) {
    const { $table, column } = params;
    const { computeSortOpts } = $table.getComputeMaps();
    const sortOpts = computeSortOpts.value;
    const { showIcon, iconLayout, iconAsc, iconDesc } = sortOpts;
    const { order } = column;
    if (showIcon) {
      return [
        h("span", {
          class: ["vxe-cell--sort", `vxe-cell--sort-${iconLayout}-layout`]
        }, [
          h("i", {
            class: ["vxe-sort--asc-btn", iconAsc || getIcon3().TABLE_SORT_ASC, {
              "sort--active": order === "asc"
            }],
            title: getI18n4("vxe.table.sortAsc"),
            onClick(evnt) {
              evnt.stopPropagation();
              $table.triggerSortEvent(evnt, column, "asc");
            }
          }),
          h("i", {
            class: ["vxe-sort--desc-btn", iconDesc || getIcon3().TABLE_SORT_DESC, {
              "sort--active": order === "desc"
            }],
            title: getI18n4("vxe.table.sortDesc"),
            onClick(evnt) {
              evnt.stopPropagation();
              $table.triggerSortEvent(evnt, column, "desc");
            }
          })
        ])
      ];
    }
    return [];
  },
  /**
   * 筛选
   */
  renderFilterHeader(params) {
    return renderHeaderCellBaseVNs(params, Cell.renderHeaderTitle(params).concat(Cell.renderFilterIcon(params)));
  },
  renderFilterIcon(params) {
    const { $table, column, hasFilter } = params;
    const { reactData } = $table;
    const { filterStore } = reactData;
    const { computeFilterOpts } = $table.getComputeMaps();
    const filterOpts = computeFilterOpts.value;
    const { showIcon, iconNone, iconMatch } = filterOpts;
    return showIcon ? [
      h("span", {
        class: ["vxe-cell--filter", {
          "is--active": filterStore.visible && filterStore.column === column
        }]
      }, [
        h("i", {
          class: ["vxe-filter--btn", hasFilter ? iconMatch || getIcon3().TABLE_FILTER_MATCH : iconNone || getIcon3().TABLE_FILTER_NONE],
          title: getI18n4("vxe.table.filter"),
          onClick(evnt) {
            if ($table.triggerFilterEvent) {
              $table.triggerFilterEvent(evnt, params.column, params);
            }
          }
        })
      ])
    ] : [];
  },
  /**
   * 可编辑
   */
  renderEditHeader(params) {
    const { $table, column } = params;
    const { props } = $table;
    const { computeEditOpts } = $table.getComputeMaps();
    const { editConfig, editRules } = props;
    const editOpts = computeEditOpts.value;
    const { sortable, filters, editRender } = column;
    let isRequired = false;
    if (editRules) {
      const columnRules = import_xe_utils19.default.get(editRules, column.field);
      if (columnRules) {
        isRequired = columnRules.some((rule) => rule.required);
      }
    }
    let editIconVNs = [];
    if (isEnableConf(editConfig)) {
      editIconVNs = [
        isRequired && editOpts.showAsterisk ? h("i", {
          class: "vxe-cell--required-icon"
        }) : renderEmptyElement2($table),
        isEnableConf(editRender) && editOpts.showIcon ? h("i", {
          class: ["vxe-cell--edit-icon", editOpts.icon || getIcon3().TABLE_EDIT]
        }) : renderEmptyElement2($table)
      ];
    }
    return renderHeaderCellBaseVNs(params, editIconVNs.concat(Cell.renderHeaderTitle(params)).concat(sortable ? Cell.renderSortIcon(params) : []).concat(filters ? Cell.renderFilterIcon(params) : []));
  },
  // 行格编辑模式
  renderRowEdit(params) {
    const { $table, column } = params;
    const { reactData } = $table;
    const { editStore } = reactData;
    const { actived } = editStore;
    const { editRender } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row);
  },
  renderTreeRowEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderRowEdit(params));
  },
  // 单元格编辑模式
  renderCellEdit(params) {
    const { $table, column } = params;
    const { reactData } = $table;
    const { editStore } = reactData;
    const { actived } = editStore;
    const { editRender } = column;
    return Cell.runRenderer(params, isEnableConf(editRender) && actived && actived.row === params.row && actived.column === params.column);
  },
  renderTreeCellEdit(params) {
    return Cell.renderTreeIcon(params, Cell.renderCellEdit(params));
  },
  runRenderer(params, isEdit) {
    const { $table, column } = params;
    const { slots, editRender, formatter } = column;
    const defaultSlot = slots ? slots.default : null;
    const editSlot = slots ? slots.edit : null;
    const compConf = renderer3.get(editRender.name);
    const rtEdit = compConf ? compConf.renderTableEdit || compConf.renderEdit : null;
    const cellParams = Object.assign({ $type: "", isEdit }, params);
    if (isEdit) {
      cellParams.$type = "edit";
      if (editSlot) {
        return $table.callSlot(editSlot, cellParams);
      }
      if (rtEdit) {
        return getSlotVNs(rtEdit(editRender, cellParams));
      }
      return [];
    }
    if (defaultSlot) {
      return renderCellBaseVNs(params, $table.callSlot(defaultSlot, cellParams));
    }
    if (formatter) {
      return renderCellBaseVNs(params, [
        h("span", {
          class: "vxe-cell--label"
        }, getDefaultCellLabel(cellParams))
      ]);
    }
    return Cell.renderDefaultCell(cellParams);
  }
};
var cell_default = Cell;

// node_modules/vxe-table/es/table/src/column.js
var columnProps = {
  // 列唯一主键
  colId: [String, Number],
  // 渲染类型 index,radio,checkbox,expand,html
  type: String,
  // 列字段名
  field: String,
  // 列标题
  title: String,
  // 列宽度
  width: [Number, String],
  // 列最小宽度，把剩余宽度按比例分配
  minWidth: [Number, String],
  // 列最大宽度
  maxWidth: [Number, String],
  // 是否允许拖动列宽调整大小
  resizable: {
    type: Boolean,
    default: null
  },
  // 将列固定在左侧或者右侧
  fixed: String,
  // 列对其方式
  align: String,
  // 表头对齐方式
  headerAlign: String,
  // 表尾列的对齐方式
  footerAlign: String,
  // 当内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表头内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 当表尾内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: null
  },
  // 给单元格附加 className
  className: [String, Function],
  // 给表头单元格附加 className
  headerClassName: [String, Function],
  // 给表尾单元格附加 className
  footerClassName: [String, Function],
  // 格式化显示内容
  formatter: [Function, Array, String],
  // 格式化表尾显示内容
  footerFormatter: [Function, Array, String],
  // 是否允许排序
  sortable: Boolean,
  // 自定义排序的属性
  sortBy: [String, Function],
  // 排序的字段类型，比如字符串转数值等
  sortType: String,
  // 配置筛选条件数组
  filters: {
    type: Array,
    default: null
  },
  // 筛选是否允许多选
  filterMultiple: {
    type: Boolean,
    default: true
  },
  // 自定义筛选方法
  filterMethod: Function,
  // 筛选重置方法
  filterResetMethod: Function,
  // 筛选复原方法
  filterRecoverMethod: Function,
  // 筛选模板配置项
  filterRender: Object,
  // 设置为树节点
  treeNode: Boolean,
  // 指定为树节点
  dragSort: Boolean,
  // 是否可视
  visible: {
    type: Boolean,
    default: null
  },
  // 表头单元格数据导出方法
  headerExportMethod: Function,
  // 单元格数据导出方法
  exportMethod: Function,
  // 表尾单元格数据导出方法
  footerExportMethod: Function,
  // 已废弃，被 titlePrefix 替换
  titleHelp: Object,
  // 标题前缀图标配置项
  titlePrefix: Object,
  // 标题后缀图标配置项
  titleSuffix: Object,
  // 单元格值类型
  cellType: String,
  // 单元格渲染配置项
  cellRender: Object,
  // 单元格编辑渲染配置项
  editRender: Object,
  // 内容渲染配置项
  contentRender: Object,
  // 额外的参数
  params: Object
};
var column_default = defineComponent({
  name: "VxeColumn",
  props: columnProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeTable = inject("$xeTable", null);
    const $xeColgroup = inject("$xeColgroup", null);
    if (!$xeTable) {
      return () => createCommentVNode();
    }
    const columnConfig = cell_default.createColumn($xeTable, props);
    columnConfig.slots = slots;
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    const $xeColumn = {
      columnConfig,
      renderVN
    };
    watchColumn($xeTable, props, columnConfig);
    onMounted(() => {
      const elem = refElem.value;
      if (elem) {
        assembleColumn($xeTable, elem, columnConfig, $xeColgroup);
      }
    });
    onUnmounted(() => {
      destroyColumn($xeTable, columnConfig);
    });
    provide("$xeColumn", $xeColumn);
    provide("$xeGrid", null);
    return renderVN;
  }
});

// node_modules/vxe-table/es/column/index.js
var VxeColumn = Object.assign({}, column_default, {
  install(app) {
    app.component(column_default.name, column_default);
    app.component("VxeTableColumn", column_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(column_default.name, column_default);
  VxeUI.dynamicApp.component("VxeTableColumn", column_default);
}
VxeUI.component(column_default);
var Column = VxeColumn;

// node_modules/vxe-table/es/table/src/group.js
var group_default = defineComponent({
  name: "VxeColgroup",
  props: columnProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeTable = inject("$xeTable", null);
    const $xeParentColgroup = inject("$xeColgroup", null);
    if (!$xeTable) {
      return () => createCommentVNode();
    }
    const columnConfig = cell_default.createColumn($xeTable, props);
    const columnSlots = {};
    if (slots.header) {
      columnSlots.header = slots.header;
    }
    columnConfig.slots = columnSlots;
    columnConfig.children = [];
    watchColumn($xeTable, props, columnConfig);
    onMounted(() => {
      const elem = refElem.value;
      if (elem) {
        assembleColumn($xeTable, elem, columnConfig, $xeParentColgroup);
      }
    });
    onUnmounted(() => {
      destroyColumn($xeTable, columnConfig);
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, slots.default ? slots.default() : []);
    };
    const $xeColgroup = { columnConfig };
    provide("$xeColgroup", $xeColgroup);
    provide("$xeGrid", null);
    return renderVN;
  }
});

// node_modules/vxe-table/es/colgroup/index.js
var VxeColgroup = Object.assign({}, group_default, {
  install(app) {
    app.component(group_default.name, group_default);
    app.component("VxeTableColgroup", group_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(group_default.name, group_default);
  VxeUI.dynamicApp.component("VxeTableColgroup", group_default);
}
VxeUI.component(group_default);
var Colgroup = VxeColgroup;

// node_modules/vxe-table/es/grid/src/grid.js
var import_xe_utils38 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/src/table.js
var import_xe_utils27 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/src/body.js
var import_xe_utils20 = __toESM(require_xe_utils());
var { getI18n: getI18n5, renderer: renderer4, renderEmptyElement: renderEmptyElement3 } = VxeUI;
var renderType = "body";
var lineOffsetSizes = {
  mini: 3,
  small: 2,
  medium: 1
};
var body_default = defineComponent({
  name: "VxeTableBody",
  props: {
    tableData: Array,
    tableColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: ""
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const xesize = inject("xesize", null);
    const { xID, props: tableProps, context: tableContext, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { refTableBody, refTableHeader, refTableFooter, refTableLeftBody, refTableRightBody, refScrollXHandleElem, refScrollYHandleElem } = $xeTable.getRefMaps();
    const { computeEditOpts, computeMouseOpts, computeAreaOpts, computeSYOpts, computeEmptyOpts, computeKeyboardOpts, computeTooltipOpts, computeRadioOpts, computeExpandOpts, computeTreeOpts, computeCheckboxOpts, computeCellOpts, computeValidOpts, computeRowOpts, computeColumnOpts, computeRowDragOpts, computeColumnDragOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refBodyTable = ref();
    const refBodyColgroup = ref();
    const refBodyTBody = ref();
    const refBodyXSpace = ref();
    const refBodyYSpace = ref();
    const refBodyEmptyBlock = ref();
    const getOffsetSize = () => {
      if (xesize) {
        const vSize = xesize.value;
        if (vSize) {
          return lineOffsetSizes[vSize] || 0;
        }
      }
      return 0;
    };
    const isVMScrollProcess = () => {
      const { delayHover } = tableProps;
      const { lastScrollTime, _isResize } = tableReactData;
      return !!(_isResize || lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const countTreeExpand = (prevRow, params) => {
      let count = 1;
      if (!prevRow) {
        return count;
      }
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rowChildren = prevRow[childrenField];
      if (rowChildren && $xeTable.isTreeExpandByRow(prevRow)) {
        for (let index2 = 0; index2 < rowChildren.length; index2++) {
          count += countTreeExpand(rowChildren[index2], params);
        }
      }
      return count;
    };
    const calcTreeLine = (params, items, rIndex) => {
      let expandSize = 1;
      if (rIndex) {
        expandSize = countTreeExpand(items[rIndex - 1], params);
      }
      return tableReactData.rowHeight * expandSize - (rIndex ? 1 : 12 - getOffsetSize());
    };
    const renderLine = (params) => {
      const { row, column } = params;
      const { afterFullData } = tableInternalData;
      const { treeConfig } = tableProps;
      const treeOpts = computeTreeOpts.value;
      const { slots, treeNode } = column;
      const { fullAllDataRowIdData } = tableInternalData;
      const rowid = getRowid($xeTable, row);
      const rest = fullAllDataRowIdData[rowid];
      let rLevel = 0;
      let rIndex = 0;
      let items = [];
      if (rest) {
        rLevel = rest.level;
        rIndex = rest._index;
        items = rest.items;
      }
      if (slots && slots.line) {
        return $xeTable.callSlot(slots.line, params);
      }
      const isFirstRow = $xeTable.eqRow(afterFullData[0], row);
      if (treeConfig && treeNode && (treeOpts.showLine || treeOpts.line)) {
        return [
          h("div", {
            class: "vxe-tree--line-wrapper"
          }, [
            h("div", {
              class: "vxe-tree--line",
              style: {
                height: `${isFirstRow ? 1 : calcTreeLine(params, items, rIndex)}px`,
                left: `${rLevel * treeOpts.indent + (rLevel ? 2 - getOffsetSize() : 0) + 16}px`
              }
            })
          ])
        ];
      }
      return [];
    };
    const renderColumn = (seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, columns, items) => {
      const { fullAllDataRowIdData } = tableInternalData;
      const { columnKey, height, showOverflow: allColumnOverflow, cellClassName: allCellClassName, cellStyle, align: allAlign, spanMethod, mouseConfig, editConfig, editRules, tooltipConfig } = tableProps;
      const { tableData, overflowX, currentColumn, scrollXLoad, scrollYLoad, mergeList, editStore, isAllOverflow, validErrorMaps } = tableReactData;
      const { afterFullData } = tableInternalData;
      const cellOpts = computeCellOpts.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const editOpts = computeEditOpts.value;
      const tooltipOpts = computeTooltipOpts.value;
      const rowOpts = computeRowOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const { disabledMethod: dragDisabledMethod } = rowDragOpts;
      const sYOpts = computeSYOpts.value;
      const columnOpts = computeColumnOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { selectCellToRow } = areaOpts;
      const { type, cellRender, editRender, align, showOverflow, className, treeNode, slots } = column;
      const { verticalAlign } = cellOpts;
      const { actived } = editStore;
      const { rHeight: scrollYRHeight } = sYOpts;
      const { height: rowHeight } = rowOpts;
      const colid = column.id;
      const renderOpts = editRender || cellRender;
      const compConf = renderOpts ? renderer4.get(renderOpts.name) : null;
      const compCellClassName = compConf ? compConf.tableCellClassName || compConf.cellClassName : null;
      const compCellStyle = compConf ? compConf.tableCellStyle || compConf.cellStyle : "";
      const showAllTip = tooltipOpts.showAll;
      const columnIndex = $xeTable.getColumnIndex(column);
      const _columnIndex = $xeTable.getVTColumnIndex(column);
      const isEdit = isEnableConf(editRender);
      let fixedHiddenColumn = fixedType ? column.fixed !== fixedType : column.fixed && overflowX;
      const cellOverflow = import_xe_utils20.default.isUndefined(showOverflow) || import_xe_utils20.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
      const showEllipsis = cellOverflow === "ellipsis";
      const showTitle = cellOverflow === "title";
      const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
      const hasEllipsis = allColumnOverflow || showTitle || showTooltip || showEllipsis;
      let isDirty;
      const tdOns = {};
      const rest = fullAllDataRowIdData[rowid];
      const cellAlign = align || (compConf ? compConf.tableCellAlign : "") || allAlign;
      const errorValidItem = validErrorMaps[`${rowid}:${colid}`];
      const showValidTip = editRules && validOpts.showMessage && (validOpts.message === "default" ? height || tableData.length > 1 : validOpts.message === "inline");
      const attrs = { colid };
      const params = {
        $table: $xeTable,
        $grid: $xeTable.xegrid,
        isEdit: false,
        seq,
        rowid,
        row,
        rowIndex,
        $rowIndex,
        _rowIndex,
        column,
        columnIndex,
        $columnIndex,
        _columnIndex,
        fixed: fixedType,
        type: renderType,
        isHidden: fixedHiddenColumn,
        level: rowLevel,
        visibleData: afterFullData,
        data: tableData,
        items
      };
      let isColDragCell = false;
      let isDisabledDrag = false;
      if (rowOpts.drag) {
        isColDragCell = rowDragOpts.trigger === "row" || column.dragSort && rowDragOpts.trigger === "cell";
      }
      if (isColDragCell) {
        isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(params));
      }
      if (showTitle || showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseenter = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTitle) {
            updateCellTitle(evnt.currentTarget, column);
          } else if (showTooltip || showAllTip) {
            $xeTable.triggerBodyTooltipEvent(evnt, params);
          }
          $xeTable.dispatchEvent("cell-mouseenter", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (showTooltip || showAllTip || tooltipConfig) {
        tdOns.onMouseleave = (evnt) => {
          if (isVMScrollProcess()) {
            return;
          }
          if (showTooltip || showAllTip) {
            $xeTable.handleTargetLeaveEvent(evnt);
          }
          $xeTable.dispatchEvent("cell-mouseleave", Object.assign({ cell: evnt.currentTarget }, params), evnt);
        };
      }
      if (isColDragCell || checkboxOpts.range || mouseConfig) {
        tdOns.onMousedown = (evnt) => {
          $xeTable.triggerCellMousedownEvent(evnt, params);
        };
      }
      tdOns.onClick = (evnt) => {
        $xeTable.triggerCellClickEvent(evnt, params);
      };
      tdOns.onDblclick = (evnt) => {
        $xeTable.triggerCellDblclickEvent(evnt, params);
      };
      if (mergeList.length) {
        const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
        if (spanRest) {
          const { rowspan, colspan } = spanRest;
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
      } else if (spanMethod) {
        const { rowspan = 1, colspan = 1 } = spanMethod(params) || {};
        if (!rowspan || !colspan) {
          return null;
        }
        if (rowspan > 1) {
          attrs.rowspan = rowspan;
        }
        if (colspan > 1) {
          attrs.colspan = colspan;
        }
      }
      if (fixedHiddenColumn && mergeList) {
        if (attrs.colspan > 1 || attrs.rowspan > 1) {
          fixedHiddenColumn = false;
        }
      }
      if (!fixedHiddenColumn && editConfig && (editRender || cellRender) && (editOpts.showStatus || editOpts.showUpdateStatus)) {
        isDirty = $xeTable.isUpdateByRow(row, column.field);
      }
      const tdVNs = [];
      if (fixedHiddenColumn && (allColumnOverflow ? isAllOverflow : allColumnOverflow)) {
        tdVNs.push(h("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
          }
        }));
      } else {
        tdVNs.push(...renderLine(params), h("div", {
          class: ["vxe-cell", {
            "c--title": showTitle,
            "c--tooltip": showTooltip,
            "c--ellipsis": showEllipsis
          }],
          style: {
            maxHeight: hasEllipsis && (scrollYRHeight || rowHeight) ? `${scrollYRHeight || rowHeight}px` : ""
          },
          title: showTitle ? $xeTable.getCellLabel(row, column) : null
        }, column.renderCell(params)));
        if (showValidTip && errorValidItem) {
          const errRule = errorValidItem.rule;
          const validSlot = slots ? slots.valid : null;
          const validParams = Object.assign(Object.assign(Object.assign({}, params), errorValidItem), { rule: errorValidItem });
          tdVNs.push(h("div", {
            class: ["vxe-cell--valid-error-tip", getPropClass(validOpts.className, validParams)],
            style: errRule && errRule.maxWidth ? {
              width: `${errRule.maxWidth}px`
            } : null
          }, [
            h("div", {
              class: `vxe-cell--valid-error-wrapper vxe-cell--valid-error-theme-${validOpts.theme || "normal"}`
            }, [
              validSlot ? $xeTable.callSlot(validSlot, validParams) : [
                h("span", {
                  class: "vxe-cell--valid-error-msg"
                }, errorValidItem.content)
              ]
            ])
          ]));
        }
      }
      let cellHeight = "";
      if (hasEllipsis && (scrollYRHeight || rowHeight)) {
        cellHeight = `${scrollYRHeight || rowHeight}px`;
      } else if (scrollXLoad || scrollYLoad) {
        if (!hasEllipsis) {
          cellHeight = `${rest.height || 24}px`;
        }
      }
      if (mouseConfig && mouseOpts.area && selectCellToRow) {
        if (!$columnIndex && selectCellToRow === true || selectCellToRow === column.field) {
          tdVNs.push(h("div", {
            class: "vxe-cell--area-status"
          }));
        }
      }
      return h("td", Object.assign(Object.assign(Object.assign({ class: [
        "vxe-body--column",
        colid,
        {
          [`col--${cellAlign}`]: cellAlign,
          [`col--vertical-${verticalAlign}`]: verticalAlign,
          [`col--${type}`]: type,
          "col--last": $columnIndex === columns.length - 1,
          "col--tree-node": treeNode,
          "col--edit": isEdit,
          "col--ellipsis": hasEllipsis,
          "fixed--hidden": fixedHiddenColumn,
          "is--drag-cell": isColDragCell,
          "is--drag-disabled": isDisabledDrag,
          "col--dirty": isDirty,
          "col--active": editConfig && isEdit && (actived.row === row && (actived.column === column || editOpts.mode === "row")),
          "col--valid-error": !!errorValidItem,
          "col--current": currentColumn === column
        },
        getPropClass(compCellClassName, params),
        getPropClass(className, params),
        getPropClass(allCellClassName, params)
      ], key: columnKey || columnOpts.useKey || rowOpts.useKey || columnOpts.drag ? colid : $columnIndex }, attrs), { style: Object.assign({
        height: cellHeight
      }, import_xe_utils20.default.isFunction(compCellStyle) ? compCellStyle(params) : compCellStyle, import_xe_utils20.default.isFunction(cellStyle) ? cellStyle(params) : cellStyle) }), tdOns), tdVNs);
    };
    const renderRows = (fixedType, tableData, tableColumn) => {
      const { stripe, rowKey, highlightHoverRow, rowClassName, rowStyle, showOverflow: allColumnOverflow, editConfig, treeConfig } = tableProps;
      const { hasFixedColumn, treeExpandedMaps, scrollYLoad, rowExpandedMaps, expandColumn, selectRadioRow, pendingRowMaps, isDragColMove } = tableReactData;
      const { fullAllDataRowIdData } = tableInternalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const radioOpts = computeRadioOpts.value;
      const treeOpts = computeTreeOpts.value;
      const editOpts = computeEditOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { transform: transform2, seqMode } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const rows = [];
      tableData.forEach((row, $rowIndex) => {
        const trOn = {};
        let rowIndex = $rowIndex;
        rowIndex = $xeTable.getRowIndex(row);
        if (rowOpts.isHover || highlightHoverRow) {
          trOn.onMouseenter = (evnt) => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.triggerHoverEvent(evnt, { row, rowIndex });
          };
          trOn.onMouseleave = () => {
            if (isVMScrollProcess()) {
              return;
            }
            $xeTable.clearHoverRow();
          };
        }
        const rowid = getRowid($xeTable, row);
        const rest = fullAllDataRowIdData[rowid];
        let rowLevel = 0;
        let seq = -1;
        let _rowIndex = 0;
        if (rest) {
          rowLevel = rest.level;
          if (treeConfig && transform2 && seqMode === "increasing") {
            seq = rest._index + 1;
          } else {
            seq = rest.seq;
          }
          _rowIndex = rest._index;
        }
        const params = { $table: $xeTable, seq, rowid, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
        const isExpandRow = expandColumn && !!rowExpandedMaps[rowid];
        let isExpandTree = false;
        let rowChildren = [];
        let isNewRow = false;
        if (editConfig) {
          isNewRow = $xeTable.isInsertByRow(row);
        }
        if (treeConfig && !scrollYLoad && !transform2) {
          rowChildren = row[childrenField];
          isExpandTree = rowChildren && rowChildren.length > 0 && !!treeExpandedMaps[rowid];
        }
        if (rowOpts.drag && (!treeConfig || transform2)) {
          trOn.onDragstart = $xeTable.handleRowDragDragstartEvent;
          trOn.onDragend = $xeTable.handleRowDragDragendEvent;
          trOn.onDragover = $xeTable.handleRowDragDragoverEvent;
        }
        const trClass = [
          "vxe-body--row",
          treeConfig ? `row--level-${rowLevel}` : "",
          {
            "row--stripe": stripe && (_rowIndex + 1) % 2 === 0,
            "is--new": isNewRow,
            "is--expand-row": isExpandRow,
            "is--expand-tree": isExpandTree,
            "row--new": isNewRow && (editOpts.showStatus || editOpts.showInsertStatus),
            "row--radio": radioOpts.highlight && $xeTable.eqRow(selectRadioRow, row),
            "row--checked": checkboxOpts.highlight && $xeTable.isCheckedByCheckboxRow(row),
            "row--pending": !!pendingRowMaps[rowid]
          },
          getPropClass(rowClassName, params)
        ];
        const tdVNs = tableColumn.map((column, $columnIndex) => {
          return renderColumn(seq, rowid, fixedType, rowLevel, row, rowIndex, $rowIndex, _rowIndex, column, $columnIndex, tableColumn, tableData);
        });
        rows.push(columnOpts.drag && columnDragOpts.animation ? h(TransitionGroup, Object.assign({ name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`, tag: "tr", class: trClass, rowid, style: rowStyle ? import_xe_utils20.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || rowOpts.useKey || rowOpts.drag || columnOpts.drag || treeConfig ? rowid : $rowIndex }, trOn), {
          default: () => tdVNs
        }) : h("tr", Object.assign({ class: trClass, rowid, style: rowStyle ? import_xe_utils20.default.isFunction(rowStyle) ? rowStyle(params) : rowStyle : null, key: rowKey || rowOpts.useKey || rowOpts.drag || columnOpts.drag || treeConfig ? rowid : $rowIndex }, trOn), tdVNs));
        if (isExpandRow) {
          const expandOpts = computeExpandOpts.value;
          const { height: expandHeight, padding } = expandOpts;
          const cellStyle = {};
          if (expandHeight) {
            cellStyle.height = `${expandHeight}px`;
          }
          if (treeConfig) {
            cellStyle.paddingLeft = `${rowLevel * treeOpts.indent + 30}px`;
          }
          const { showOverflow } = expandColumn;
          const hasEllipsis = import_xe_utils20.default.isUndefined(showOverflow) || import_xe_utils20.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
          const expandParams = { $table: $xeTable, seq, column: expandColumn, fixed: fixedType, type: renderType, level: rowLevel, row, rowIndex, $rowIndex, _rowIndex };
          rows.push(h("tr", Object.assign({ class: ["vxe-body--expanded-row", {
            "is--padding": padding
          }], key: `expand_${rowid}`, style: rowStyle ? import_xe_utils20.default.isFunction(rowStyle) ? rowStyle(expandParams) : rowStyle : null }, trOn), [
            h("td", {
              class: {
                "vxe-body--expanded-column": 1,
                "fixed--hidden": fixedType && !hasFixedColumn,
                "col--ellipsis": hasEllipsis
              },
              colspan: tableColumn.length
            }, [
              h("div", {
                class: {
                  "vxe-body--expanded-cell": 1,
                  "is--ellipsis": expandHeight
                },
                style: cellStyle
              }, [
                expandColumn.renderData(expandParams)
              ])
            ])
          ]));
        }
        if (isExpandTree) {
          rows.push(...renderRows(fixedType, rowChildren, tableColumn));
        }
      });
      return rows;
    };
    const scrollEvent = (evnt) => {
      const { fixedType } = props;
      const { lastScrollTop, lastScrollLeft, inVirtualScroll, inBodyScroll, bodyScrollType, inFooterScroll } = tableInternalData;
      if (inVirtualScroll) {
        return;
      }
      if (inFooterScroll) {
        return;
      }
      if (inBodyScroll) {
        if (bodyScrollType !== fixedType) {
          return;
        }
      }
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const scrollBodyElem = refElem.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      const bodyElem = tableBody.$el;
      if (!bodyElem) {
        return;
      }
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const xHandleEl = refScrollXHandleElem.value;
      const yHandleEl = refScrollYHandleElem.value;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = bodyElem.scrollLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      tableInternalData.inBodyScroll = true;
      tableInternalData.bodyScrollType = fixedType;
      if (isRollY) {
        if (leftElem && fixedType === "left") {
          setScrollTop(bodyElem, scrollTop);
          setScrollTop(rightElem, scrollTop);
        } else if (rightElem && fixedType === "right") {
          setScrollTop(bodyElem, scrollTop);
          setScrollTop(leftElem, scrollTop);
        } else {
          setScrollTop(leftElem, scrollTop);
          setScrollTop(rightElem, scrollTop);
        }
        setScrollTop(yHandleEl, scrollTop);
        $xeTable.triggerScrollYEvent(evnt);
      }
      if (isRollX) {
        setScrollLeft(xHandleEl, scrollLeft);
        setScrollLeft(headerElem, scrollLeft);
        setScrollLeft(footerElem, scrollLeft);
        $xeTable.triggerScrollXEvent(evnt);
      }
      $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
        type: renderType,
        fixed: fixedType
      });
    };
    let wheelTime;
    let wheelYSize = 0;
    let wheelYInterval = 0;
    let wheelYTotal = 0;
    let isPrevWheelTop = false;
    const handleWheel = (evnt, isTopWheel, deltaTop, isRollX, isRollY) => {
      const { elemStore } = tableInternalData;
      const { scrollXLoad, scrollYLoad } = tableReactData;
      const tableBody = refTableBody.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const bodyElem = tableBody.$el;
      const bodyYElem = getRefElem(elemStore["main-body-ySpace"]);
      const bodyXElem = getRefElem(elemStore["main-body-xSpace"]);
      const bodyHeight = scrollYLoad && bodyYElem ? bodyYElem.clientHeight : bodyElem.clientHeight;
      const bodyWidth = scrollXLoad && bodyXElem ? bodyXElem.clientWidth : bodyElem.clientWidth;
      const remainSize = isPrevWheelTop === isTopWheel ? Math.max(0, wheelYSize - wheelYTotal) : 0;
      isPrevWheelTop = isTopWheel;
      wheelYSize = Math.abs(isTopWheel ? deltaTop - remainSize : deltaTop + remainSize);
      wheelYInterval = 0;
      wheelYTotal = 0;
      clearTimeout(wheelTime);
      const handleSmooth = () => {
        if (wheelYTotal < wheelYSize) {
          const { fixedType } = props;
          wheelYInterval = Math.max(5, Math.floor(wheelYInterval * 1.5));
          wheelYTotal = wheelYTotal + wheelYInterval;
          if (wheelYTotal > wheelYSize) {
            wheelYInterval = wheelYInterval - (wheelYTotal - wheelYSize);
          }
          const { scrollTop, clientHeight, scrollHeight } = bodyElem;
          const targerTop = scrollTop + wheelYInterval * (isTopWheel ? -1 : 1);
          bodyElem.scrollTop = targerTop;
          if (leftElem) {
            leftElem.scrollTop = targerTop;
          }
          if (rightElem) {
            rightElem.scrollTop = targerTop;
          }
          if (isTopWheel ? targerTop < scrollHeight - clientHeight : targerTop >= 0) {
            wheelTime = setTimeout(handleSmooth, 10);
          }
          $xeTable.dispatchEvent("scroll", {
            type: renderType,
            fixed: fixedType,
            scrollTop: bodyElem.scrollTop,
            scrollLeft: bodyElem.scrollLeft,
            scrollHeight: bodyElem.scrollHeight,
            scrollWidth: bodyElem.scrollWidth,
            bodyHeight,
            bodyWidth,
            isX: isRollX,
            isY: isRollY
          }, evnt);
        }
      };
      handleSmooth();
    };
    const wheelEvent = (evnt) => {
      const { deltaY, deltaX } = evnt;
      const { highlightHoverRow } = tableProps;
      const { scrollYLoad } = tableReactData;
      const { lastScrollTop, lastScrollLeft } = tableInternalData;
      const rowOpts = computeRowOpts.value;
      const tableBody = refTableBody.value;
      const scrollBodyElem = refElem.value;
      const bodyElem = tableBody.$el;
      const deltaTop = deltaY;
      const deltaLeft = deltaX;
      const isTopWheel = deltaTop < 0;
      if (isTopWheel ? scrollBodyElem.scrollTop <= 0 : scrollBodyElem.scrollTop >= scrollBodyElem.scrollHeight - scrollBodyElem.clientHeight) {
        return;
      }
      const scrollTop = scrollBodyElem.scrollTop + deltaTop;
      const scrollLeft = bodyElem.scrollLeft + deltaLeft;
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = scrollTop !== lastScrollTop;
      if (isRollY) {
        evnt.preventDefault();
        tableInternalData.lastScrollTop = scrollTop;
        tableInternalData.lastScrollLeft = scrollLeft;
        tableReactData.lastScrollTime = Date.now();
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        handleWheel(evnt, isTopWheel, deltaTop, isRollX, isRollY);
        if (scrollYLoad) {
          $xeTable.triggerScrollYEvent(evnt);
        }
      }
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-body-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refBodyTable;
        elemStore[`${prefix}colgroup`] = refBodyColgroup;
        elemStore[`${prefix}list`] = refBodyTBody;
        elemStore[`${prefix}xSpace`] = refBodyXSpace;
        elemStore[`${prefix}ySpace`] = refBodyYSpace;
        elemStore[`${prefix}emptyBlock`] = refBodyEmptyBlock;
      });
    });
    onBeforeUnmount(() => {
      clearTimeout(wheelTime);
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-body-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}ySpace`] = null;
      elemStore[`${prefix}emptyBlock`] = null;
    });
    const renderVN = () => {
      let { fixedColumn, fixedType, tableColumn } = props;
      const { keyboardConfig, showOverflow: allColumnOverflow, spanMethod, mouseConfig } = tableProps;
      const { tableData, mergeList, scrollYLoad, isAllOverflow, isDragRowMove } = tableReactData;
      const { visibleColumn } = tableInternalData;
      const { slots } = tableContext;
      const rowOpts = computeRowOpts.value;
      const sYOpts = computeSYOpts.value;
      const emptyOpts = computeEmptyOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      if (fixedType) {
        if (!tableReactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
          if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      let emptyContent;
      const emptySlot = slots ? slots.empty : null;
      if (emptySlot) {
        emptyContent = $xeTable.callSlot(emptySlot, { $table: $xeTable, $grid: $xeTable.xegrid });
      } else {
        const compConf = emptyOpts.name ? renderer4.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          emptyContent = getSlotVNs(rtEmptyView(emptyOpts, { $table: $xeTable }));
        } else {
          emptyContent = tableProps.emptyText || getI18n5("vxe.table.emptyText");
        }
      }
      const ons = {
        onScroll: scrollEvent
      };
      if (sYOpts.mode === "wheel") {
        ons.onWheel = wheelEvent;
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--body-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"], xid: xID }, ons), [
        fixedType ? createCommentVNode() : h("div", {
          ref: refBodyXSpace,
          class: "vxe-body--x-space"
        }),
        h("div", {
          ref: refBodyYSpace,
          class: "vxe-body--y-space"
        }),
        h("table", {
          ref: refBodyTable,
          class: "vxe-table--body",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          h("colgroup", {
            ref: refBodyColgroup
          }, tableColumn.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          })),
          /**
           * 内容
           */
          rowOpts.drag && rowDragOpts.animation ? h(TransitionGroup, {
            ref: refBodyTBody,
            name: `vxe-body--row-list${isDragRowMove ? "" : "-disabled"}`,
            tag: "tbody"
          }, {
            default: () => renderRows(fixedType, tableData, tableColumn)
          }) : h("tbody", {
            ref: refBodyTBody
          }, renderRows(fixedType, tableData, tableColumn))
        ]),
        h("div", {
          class: "vxe-table--checkbox-range"
        }),
        mouseConfig && mouseOpts.area ? h("div", {
          class: "vxe-table--cell-area"
        }, [
          h("span", {
            class: "vxe-table--cell-main-area"
          }, mouseOpts.extension ? [
            h("span", {
              class: "vxe-table--cell-main-area-btn",
              onMousedown(evnt) {
                if ($xeTable.triggerCellAreaExtendMousedownEvent) {
                  $xeTable.triggerCellAreaExtendMousedownEvent(evnt, { $table: $xeTable, fixed: fixedType, type: renderType });
                }
              }
            })
          ] : []),
          h("span", {
            class: "vxe-table--cell-copy-area"
          }),
          h("span", {
            class: "vxe-table--cell-extend-area"
          }),
          h("span", {
            class: "vxe-table--cell-multi-area"
          }),
          h("span", {
            class: "vxe-table--cell-active-area"
          })
        ]) : renderEmptyElement3($xeTable),
        !fixedType ? h("div", {
          class: "vxe-table--empty-block",
          ref: refBodyEmptyBlock
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, emptyContent)
        ]) : renderEmptyElement3($xeTable)
      ]);
    };
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/header.js
var import_xe_utils21 = __toESM(require_xe_utils());
var { renderer: renderer5 } = VxeUI;
var renderType2 = "header";
var header_default = defineComponent({
  name: "VxeTableHeader",
  props: {
    tableData: Array,
    tableColumn: Array,
    tableGroupColumn: Array,
    fixedColumn: Array,
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { refElem: tableRefElem, refTableBody, refLeftContainer, refRightContainer, refCellResizeBar, refCellResizeTip } = $xeTable.getRefMaps();
    const { computeColumnOpts, computeColumnDragOpts, computeResizableOpts } = $xeTable.getComputeMaps();
    const headerColumn = ref([]);
    const refElem = ref();
    const refHeaderTable = ref();
    const refHeaderColgroup = ref();
    const refHeaderTHead = ref();
    const refHeaderXSpace = ref();
    const refHeaderBorderRepair = ref();
    const uploadColumn = () => {
      const { isGroup } = tableReactData;
      headerColumn.value = isGroup ? convertHeaderColumnToRows(props.tableGroupColumn) : [];
    };
    const resizeMousedown = (evnt, params) => {
      const { column } = params;
      const { fixedType } = props;
      const { visibleColumn } = tableInternalData;
      const resizableOpts = computeResizableOpts.value;
      const tableBody = refTableBody.value;
      const tableEl = tableRefElem.value;
      const leftContainerElem = refLeftContainer.value;
      const rightContainerElem = refRightContainer.value;
      const resizeBarElem = refCellResizeBar.value;
      const resizeTipElem = refCellResizeTip.value;
      const { clientX: dragClientX } = evnt;
      const wrapperElem = refElem.value;
      const dragBtnElem = evnt.target;
      const cell = params.cell = dragBtnElem.parentNode;
      let dragLeft = 0;
      const tableBodyElem = tableBody.$el;
      const pos = getOffsetPos(dragBtnElem, wrapperElem);
      const dragBtnWidth = dragBtnElem.clientWidth;
      const dragBtnOffsetWidth = Math.floor(dragBtnWidth / 2);
      const minInterval = getColReMinWidth(params) - dragBtnOffsetWidth;
      let dragMinLeft = pos.left - cell.clientWidth + dragBtnWidth + minInterval;
      let dragPosLeft = pos.left + dragBtnOffsetWidth;
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const isLeftFixed = fixedType === "left";
      const isRightFixed = fixedType === "right";
      let fixedOffsetWidth = 0;
      if (isLeftFixed || isRightFixed) {
        const siblingProp = isLeftFixed ? "nextElementSibling" : "previousElementSibling";
        let tempCellElem = cell[siblingProp];
        while (tempCellElem) {
          if (hasClass(tempCellElem, "fixed--hidden")) {
            break;
          } else if (!hasClass(tempCellElem, "col--group")) {
            fixedOffsetWidth += tempCellElem.offsetWidth;
          }
          tempCellElem = tempCellElem[siblingProp];
        }
        if (isRightFixed && rightContainerElem) {
          dragPosLeft = rightContainerElem.offsetLeft + fixedOffsetWidth;
        }
      }
      const updateEvent = function(evnt2) {
        evnt2.stopPropagation();
        evnt2.preventDefault();
        const offsetX = evnt2.clientX - dragClientX;
        let left = dragPosLeft + offsetX;
        const scrollLeft = fixedType ? 0 : tableBodyElem.scrollLeft;
        if (isLeftFixed) {
          left = Math.min(left, (rightContainerElem ? rightContainerElem.offsetLeft : tableBodyElem.clientWidth) - fixedOffsetWidth - minInterval);
        } else if (isRightFixed) {
          dragMinLeft = (leftContainerElem ? leftContainerElem.clientWidth : 0) + fixedOffsetWidth + minInterval;
          left = Math.min(left, dragPosLeft + cell.clientWidth - minInterval);
        } else {
          dragMinLeft = Math.max(tableBodyElem.scrollLeft, dragMinLeft);
        }
        dragLeft = Math.max(left, dragMinLeft);
        const resizeBarLeft = dragLeft - scrollLeft;
        resizeBarElem.style.left = `${resizeBarLeft}px`;
        if (resizableOpts.showDragTip && resizeTipElem) {
          const tableWidth = tableEl.clientWidth;
          const wrapperRect = wrapperElem.getBoundingClientRect();
          const resizeBarWidth = resizeBarElem.clientWidth;
          const resizeTipWidth = resizeTipElem.clientWidth;
          const resizeTipHeight = resizeTipElem.clientHeight;
          let resizeTipLeft = -resizeTipWidth;
          if (resizeBarLeft < resizeTipWidth + resizeBarWidth) {
            resizeTipLeft = resizeTipWidth + resizeBarWidth - resizeBarLeft;
          } else if (resizeBarLeft > tableWidth) {
            resizeTipLeft += tableWidth - resizeBarLeft;
          }
          resizeTipElem.style.left = `${resizeTipLeft}px`;
          resizeTipElem.style.top = `${Math.min(tableEl.clientHeight - resizeTipHeight, Math.max(0, evnt2.clientY - wrapperRect.y - resizeTipHeight / 2))}px`;
          resizeTipElem.textContent = `${column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft)}px`;
        }
      };
      tableReactData._isResize = true;
      addClass(tableEl, "drag--resize");
      resizeBarElem.style.display = "block";
      document.onmousemove = updateEvent;
      document.onmouseup = function(evnt2) {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        const resizeWidth = column.renderWidth + (isRightFixed ? dragPosLeft - dragLeft : dragLeft - dragPosLeft);
        column.resizeWidth = resizeWidth;
        if (resizableOpts.dragMode === "fixed") {
          visibleColumn.forEach((item) => {
            if (item.id !== column.id) {
              if (!item.resizeWidth) {
                item.resizeWidth = item.renderWidth;
              }
            }
          });
        }
        resizeBarElem.style.display = "none";
        tableReactData._isResize = false;
        tableInternalData._lastResizeTime = Date.now();
        $xeTable.analyColumnWidth();
        $xeTable.recalculate(true).then(() => {
          $xeTable.saveCustomStore("update:visible");
          $xeTable.updateCellAreas();
          $xeTable.dispatchEvent("resizable-change", Object.assign(Object.assign({}, params), { resizeWidth }), evnt2);
          setTimeout(() => $xeTable.recalculate(true), 300);
        });
        removeClass(tableEl, "drag--resize");
      };
      updateEvent(evnt);
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const renderRows = (cols, $rowIndex) => {
      const { fixedType } = props;
      const { resizable: allResizable, border, columnKey, headerCellClassName, headerCellStyle, showHeaderOverflow: allColumnHeaderOverflow, headerAlign: allHeaderAlign, align: allAlign, mouseConfig } = tableProps;
      const { currentColumn, scrollXLoad, overflowX, scrollbarWidth } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { disabledMethod: dragDisabledMethod } = columnDragOpts;
      return cols.map((column, $columnIndex) => {
        const { type, showHeaderOverflow, headerAlign, align, headerClassName, editRender, cellRender } = column;
        const colid = column.id;
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer5.get(renderOpts.name) : null;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : !!column.fixed && overflowX;
        const headOverflow = import_xe_utils21.default.eqNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
        const headAlign = headerAlign || (compConf ? compConf.tableHeaderCellAlign : "") || allHeaderAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        let showEllipsis = headOverflow === "ellipsis";
        const showTitle = headOverflow === "title";
        const showTooltip = headOverflow === true || headOverflow === "tooltip";
        let hasEllipsis = showTitle || showTooltip || showEllipsis;
        const hasFilter = column.filters && column.filters.some((item) => item.checked);
        const columnIndex = $xeTable.getColumnIndex(column);
        const _columnIndex = $xeTable.getVTColumnIndex(column);
        const params = { $table: $xeTable, $grid: $xeTable.xegrid, $rowIndex, column, columnIndex, $columnIndex, _columnIndex, fixed: fixedType, type: renderType2, isHidden: fixedHiddenColumn, hasFilter };
        const thAttrs = {
          colid,
          colspan: column.colSpan > 1 ? column.colSpan : null,
          rowspan: column.rowSpan > 1 ? column.rowSpan : null
        };
        const thOns = {
          onClick: (evnt) => $xeTable.triggerHeaderCellClickEvent(evnt, params),
          onDblclick: (evnt) => $xeTable.triggerHeaderCellDblclickEvent(evnt, params)
        };
        if (scrollXLoad && !hasEllipsis) {
          showEllipsis = hasEllipsis = true;
        }
        const isColDragCell = columnOpts.drag && columnDragOpts.trigger === "cell";
        let isDisabledDrag = false;
        if (isColDragCell) {
          isDisabledDrag = !!(dragDisabledMethod && dragDisabledMethod(params));
        }
        if (mouseConfig || isColDragCell) {
          thOns.onMousedown = (evnt) => $xeTable.triggerHeaderCellMousedownEvent(evnt, params);
        }
        if (columnOpts.drag) {
          thOns.onDragstart = $xeTable.handleHeaderCellDragDragstartEvent;
          thOns.onDragend = $xeTable.handleHeaderCellDragDragendEvent;
          thOns.onDragover = $xeTable.handleHeaderCellDragDragoverEvent;
          if (isColDragCell) {
            thOns.onMouseup = $xeTable.handleHeaderCellDragMouseupEvent;
          }
        }
        return h("th", Object.assign(Object.assign(Object.assign({ class: [
          "vxe-header--column",
          colid,
          {
            [`col--${headAlign}`]: headAlign,
            [`col--${type}`]: type,
            "col--last": $columnIndex === cols.length - 1,
            "col--fixed": column.fixed,
            "col--group": isColGroup,
            "col--ellipsis": hasEllipsis,
            "fixed--hidden": fixedHiddenColumn,
            "is--sortable": column.sortable,
            "col--filter": !!column.filters,
            "is--filter-active": hasFilter,
            "is--drag-disabled": isDisabledDrag,
            "col--current": currentColumn === column
          },
          headerClassName ? import_xe_utils21.default.isFunction(headerClassName) ? headerClassName(params) : headerClassName : "",
          headerCellClassName ? import_xe_utils21.default.isFunction(headerCellClassName) ? headerCellClassName(params) : headerCellClassName : ""
        ], style: headerCellStyle ? import_xe_utils21.default.isFunction(headerCellStyle) ? headerCellStyle(params) : headerCellStyle : null }, thAttrs), thOns), { key: columnKey || columnOpts.useKey || columnOpts.drag || isColGroup ? colid : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }]
          }, column.renderHeader(params)),
          /**
           * 列宽拖动
           */
          !fixedHiddenColumn && !isColGroup && (import_xe_utils21.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? h("div", {
            class: ["vxe-resizable", {
              "is--line": !border || border === "none"
            }],
            onMousedown: (evnt) => resizeMousedown(evnt, params)
          }) : null
        ]);
      }).concat(scrollbarWidth ? [
        h("th", {
          key: `gr${$rowIndex}`,
          class: "vxe-header--gutter col--gutter"
        })
      ] : []);
    };
    const renderHeads = (headerGroups) => {
      const { fixedType } = props;
      const { headerRowClassName, headerRowStyle } = tableProps;
      const { isDragColMove } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return headerGroups.map((cols, $rowIndex) => {
        const params = { $table: $xeTable, $rowIndex, fixed: fixedType, type: renderType2 };
        if (columnOpts.drag && columnDragOpts.animation) {
          return h(TransitionGroup, {
            name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`,
            tag: "tr",
            class: [
              "vxe-header--row",
              headerRowClassName ? import_xe_utils21.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
            ],
            style: headerRowStyle ? import_xe_utils21.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
          }, {
            default: () => renderRows(cols, $rowIndex)
          });
        }
        return h("tr", {
          class: [
            "vxe-header--row",
            headerRowClassName ? import_xe_utils21.default.isFunction(headerRowClassName) ? headerRowClassName(params) : headerRowClassName : ""
          ],
          style: headerRowStyle ? import_xe_utils21.default.isFunction(headerRowStyle) ? headerRowStyle(params) : headerRowStyle : null
        }, renderRows(cols, $rowIndex));
      });
    };
    const renderVN = () => {
      const { fixedType, fixedColumn, tableColumn } = props;
      const { showHeaderOverflow: allColumnHeaderOverflow } = tableProps;
      const { isGroup, scrollXLoad, scrollbarWidth } = tableReactData;
      const { visibleColumn } = tableInternalData;
      let headerGroups = headerColumn.value;
      let renderColumnList = tableColumn;
      if (isGroup) {
        renderColumnList = visibleColumn;
      } else {
        if (fixedType) {
          if (scrollXLoad || allColumnHeaderOverflow) {
            renderColumnList = fixedColumn;
          }
        }
        headerGroups = [renderColumnList];
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table--header-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"],
        xid: xID
      }, [
        fixedType ? createCommentVNode() : h("div", {
          ref: refHeaderXSpace,
          class: "vxe-body--x-space"
        }),
        h("table", {
          ref: refHeaderTable,
          class: "vxe-table--header",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          h("colgroup", {
            ref: refHeaderColgroup
          }, renderColumnList.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 头部
           */
          h("thead", {
            ref: refHeaderTHead
          }, renderHeads(headerGroups))
        ]),
        /**
         * 其他
         */
        h("div", {
          ref: refHeaderBorderRepair,
          class: "vxe-table--header-border-line"
        })
      ]);
    };
    watch(() => props.tableColumn, uploadColumn);
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { internalData } = $xeTable;
        const { elemStore } = internalData;
        const prefix = `${fixedType || "main"}-header-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refHeaderTable;
        elemStore[`${prefix}colgroup`] = refHeaderColgroup;
        elemStore[`${prefix}list`] = refHeaderTHead;
        elemStore[`${prefix}xSpace`] = refHeaderXSpace;
        elemStore[`${prefix}repair`] = refHeaderBorderRepair;
        uploadColumn();
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { internalData } = $xeTable;
      const { elemStore } = internalData;
      const prefix = `${fixedType || "main"}-header-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
      elemStore[`${prefix}repair`] = null;
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/footer.js
var import_xe_utils22 = __toESM(require_xe_utils());
var { renderer: renderer6 } = VxeUI;
var renderType3 = "footer";
function mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex) {
  for (let mIndex = 0; mIndex < mergeFooterList.length; mIndex++) {
    const { row: mergeRowIndex, col: mergeColIndex, rowspan: mergeRowspan, colspan: mergeColspan } = mergeFooterList[mIndex];
    if (mergeColIndex > -1 && mergeRowIndex > -1 && mergeRowspan && mergeColspan) {
      if (mergeRowIndex === _rowIndex && mergeColIndex === _columnIndex) {
        return { rowspan: mergeRowspan, colspan: mergeColspan };
      }
      if (_rowIndex >= mergeRowIndex && _rowIndex < mergeRowIndex + mergeRowspan && _columnIndex >= mergeColIndex && _columnIndex < mergeColIndex + mergeColspan) {
        return { rowspan: 0, colspan: 0 };
      }
    }
  }
}
var footer_default = defineComponent({
  name: "VxeTableFooter",
  props: {
    footerTableData: {
      type: Array,
      default: () => []
    },
    tableColumn: {
      type: Array,
      default: () => []
    },
    fixedColumn: {
      type: Array,
      default: () => []
    },
    fixedType: {
      type: String,
      default: null
    }
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { xID, props: tableProps, reactData: tableReactData, internalData: tableInternalData } = $xeTable;
    const { refTableHeader, refTableBody, refScrollXHandleElem } = $xeTable.getRefMaps();
    const { computeTooltipOpts, computeColumnOpts, computeColumnDragOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const refFooterTable = ref();
    const refFooterColgroup = ref();
    const refFooterTFoot = ref();
    const refFooterXSpace = ref();
    const scrollEvent = (evnt) => {
      const { inVirtualScroll, inBodyScroll } = tableInternalData;
      if (inVirtualScroll) {
        return;
      }
      if (inBodyScroll) {
        return;
      }
      const { fixedType } = props;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = refElem.value;
      if (!footerElem) {
        return;
      }
      const bodyElem = tableBody ? tableBody.$el : null;
      if (!bodyElem) {
        return;
      }
      const xHandleEl = refScrollXHandleElem.value;
      const scrollLeft = footerElem.scrollLeft;
      const isRollX = true;
      const isRollY = false;
      const scrollTop = bodyElem.scrollTop;
      tableInternalData.inFooterScroll = true;
      setScrollLeft(xHandleEl, scrollLeft);
      setScrollLeft(headerElem, scrollLeft);
      setScrollLeft(bodyElem, scrollLeft);
      $xeTable.triggerScrollXEvent(evnt);
      $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
        type: renderType3,
        fixed: fixedType
      });
    };
    const renderRows = (tableColumn, footerTableData, row, $rowIndex, _rowIndex) => {
      const { fixedType } = props;
      const { footerCellClassName, footerCellStyle, footerAlign: allFooterAlign, footerSpanMethod, align: allAlign, columnKey, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { scrollXLoad, overflowX, scrollbarWidth, currentColumn, mergeFooterList } = tableReactData;
      const tooltipOpts = computeTooltipOpts.value;
      const columnOpts = computeColumnOpts.value;
      return tableColumn.map((column, $columnIndex) => {
        const { type, showFooterOverflow, footerAlign, align, footerClassName, editRender, cellRender } = column;
        const renderOpts = editRender || cellRender;
        const compConf = renderOpts ? renderer6.get(renderOpts.name) : null;
        const showAllTip = tooltipOpts.showAll;
        const isColGroup = column.children && column.children.length;
        const fixedHiddenColumn = fixedType ? column.fixed !== fixedType && !isColGroup : column.fixed && overflowX;
        const footOverflow = import_xe_utils22.default.eqNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
        const footAlign = footerAlign || (compConf ? compConf.tableFooterCellAlign : "") || allFooterAlign || align || (compConf ? compConf.tableCellAlign : "") || allAlign;
        let showEllipsis = footOverflow === "ellipsis";
        const showTitle = footOverflow === "title";
        const showTooltip = footOverflow === true || footOverflow === "tooltip";
        let hasEllipsis = showTitle || showTooltip || showEllipsis;
        const attrs = { colid: column.id };
        const tfOns = {};
        const columnIndex = $xeTable.getColumnIndex(column);
        const _columnIndex = $xeTable.getVTColumnIndex(column);
        const itemIndex = _columnIndex;
        const cellParams = {
          $table: $xeTable,
          $grid: $xeTable.xegrid,
          row,
          rowIndex: _rowIndex,
          _rowIndex,
          $rowIndex,
          column,
          columnIndex,
          $columnIndex,
          _columnIndex,
          itemIndex,
          items: row,
          fixed: fixedType,
          type: renderType3,
          data: footerTableData
        };
        if (scrollXLoad && !hasEllipsis) {
          showEllipsis = hasEllipsis = true;
        }
        if (showTitle || showTooltip || showAllTip) {
          tfOns.onMouseenter = (evnt) => {
            if (showTitle) {
              updateCellTitle(evnt.currentTarget, column);
            } else if (showTooltip || showAllTip) {
              $xeTable.triggerFooterTooltipEvent(evnt, cellParams);
            }
          };
        }
        if (showTooltip || showAllTip) {
          tfOns.onMouseleave = (evnt) => {
            if (showTooltip || showAllTip) {
              $xeTable.handleTargetLeaveEvent(evnt);
            }
          };
        }
        tfOns.onClick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-click", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        tfOns.onDblclick = (evnt) => {
          $xeTable.dispatchEvent("footer-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, cellParams), evnt);
        };
        if (mergeFooterList.length) {
          const spanRest = mergeFooterMethod(mergeFooterList, _rowIndex, _columnIndex);
          if (spanRest) {
            const { rowspan, colspan } = spanRest;
            if (!rowspan || !colspan) {
              return null;
            }
            if (rowspan > 1) {
              attrs.rowspan = rowspan;
            }
            if (colspan > 1) {
              attrs.colspan = colspan;
            }
          }
        } else if (footerSpanMethod) {
          const { rowspan = 1, colspan = 1 } = footerSpanMethod(cellParams) || {};
          if (!rowspan || !colspan) {
            return null;
          }
          if (rowspan > 1) {
            attrs.rowspan = rowspan;
          }
          if (colspan > 1) {
            attrs.colspan = colspan;
          }
        }
        return h("td", Object.assign(Object.assign(Object.assign(Object.assign({ class: ["vxe-footer--column", column.id, {
          [`col--${footAlign}`]: footAlign,
          [`col--${type}`]: type,
          "col--last": $columnIndex === tableColumn.length - 1,
          "fixed--hidden": fixedHiddenColumn,
          "col--ellipsis": hasEllipsis,
          "col--current": currentColumn === column
        }, getPropClass(footerClassName, cellParams), getPropClass(footerCellClassName, cellParams)] }, attrs), { style: footerCellStyle ? import_xe_utils22.default.isFunction(footerCellStyle) ? footerCellStyle(cellParams) : footerCellStyle : null }), tfOns), { key: columnKey || columnOpts.useKey || columnOpts.drag ? column.id : $columnIndex }), [
          h("div", {
            class: ["vxe-cell", {
              "c--title": showTitle,
              "c--tooltip": showTooltip,
              "c--ellipsis": showEllipsis
            }]
          }, column.renderFooter(cellParams))
        ]);
      }).concat(scrollbarWidth ? [
        h("td", {
          key: `gr${$rowIndex}`,
          class: "vxe-footer--gutter col--gutter"
        })
      ] : []);
    };
    const renderHeads = (footerTableData) => {
      const { fixedType, tableColumn } = props;
      const { footerRowClassName, footerRowStyle } = tableProps;
      const { isDragColMove } = tableReactData;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return footerTableData.map((row, $rowIndex) => {
        const _rowIndex = $rowIndex;
        const rowParams = { $table: $xeTable, row, _rowIndex, $rowIndex, fixed: fixedType, type: renderType3 };
        if (columnOpts.drag && columnDragOpts.animation) {
          return h(TransitionGroup, {
            name: `vxe-header--col-list${isDragColMove ? "" : "-disabled"}`,
            tag: "tr",
            class: [
              "vxe-footer--row",
              footerRowClassName ? import_xe_utils22.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
            ],
            style: footerRowStyle ? import_xe_utils22.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
          }, {
            default: () => renderRows(tableColumn, footerTableData, row, $rowIndex, _rowIndex)
          });
        }
        return h("tr", {
          class: [
            "vxe-footer--row",
            footerRowClassName ? import_xe_utils22.default.isFunction(footerRowClassName) ? footerRowClassName(rowParams) : footerRowClassName : ""
          ],
          style: footerRowStyle ? import_xe_utils22.default.isFunction(footerRowStyle) ? footerRowStyle(rowParams) : footerRowStyle : null
        }, renderRows(tableColumn, footerTableData, row, $rowIndex, _rowIndex));
      });
    };
    const renderVN = () => {
      let { fixedType, fixedColumn, tableColumn, footerTableData } = props;
      const { footerSpanMethod, showFooterOverflow: allColumnFooterOverflow } = tableProps;
      const { visibleColumn } = tableInternalData;
      const { scrollXLoad, scrollbarWidth, mergeFooterList } = tableReactData;
      if (fixedType) {
        if (!tableReactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
          if (!mergeFooterList.length || !footerSpanMethod) {
            tableColumn = fixedColumn;
          } else {
            tableColumn = visibleColumn;
          }
        } else {
          tableColumn = visibleColumn;
        }
      }
      const ons = {};
      if (!fixedType) {
        ons.onScroll = scrollEvent;
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--footer-wrapper", fixedType ? `fixed-${fixedType}--wrapper` : "body--wrapper"], xid: xID }, ons), [
        fixedType ? createCommentVNode() : h("div", {
          ref: refFooterXSpace,
          class: "vxe-body--x-space"
        }),
        h("table", {
          ref: refFooterTable,
          class: "vxe-table--footer",
          xid: xID,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          /**
           * 列宽
           */
          h("colgroup", {
            ref: refFooterColgroup
          }, tableColumn.map((column, $columnIndex) => {
            return h("col", {
              name: column.id,
              key: $columnIndex
            });
          }).concat(scrollbarWidth ? [
            h("col", {
              name: "col_gutter"
            })
          ] : [])),
          /**
           * 底部
           */
          h("tfoot", {
            ref: refFooterTFoot
          }, renderHeads(footerTableData))
        ])
      ]);
    };
    onMounted(() => {
      nextTick(() => {
        const { fixedType } = props;
        const { elemStore } = tableInternalData;
        const prefix = `${fixedType || "main"}-footer-`;
        elemStore[`${prefix}wrapper`] = refElem;
        elemStore[`${prefix}table`] = refFooterTable;
        elemStore[`${prefix}colgroup`] = refFooterColgroup;
        elemStore[`${prefix}list`] = refFooterTFoot;
        elemStore[`${prefix}xSpace`] = refFooterXSpace;
      });
    });
    onUnmounted(() => {
      const { fixedType } = props;
      const { elemStore } = tableInternalData;
      const prefix = `${fixedType || "main"}-footer-`;
      elemStore[`${prefix}wrapper`] = null;
      elemStore[`${prefix}table`] = null;
      elemStore[`${prefix}colgroup`] = null;
      elemStore[`${prefix}list`] = null;
      elemStore[`${prefix}xSpace`] = null;
    });
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/src/props.js
var { getConfig: getConfig3 } = VxeUI;
var props_default = {
  /** 基本属性 */
  id: [String, Function],
  // 数据
  data: Array,
  // 表格的高度
  height: [Number, String],
  // 表格的最小高度
  minHeight: {
    type: [Number, String],
    default: () => getConfig3().table.minHeight
  },
  // 表格的最大高度
  maxHeight: [Number, String],
  // 已废弃，被 column-config.resizable 替换
  resizable: {
    type: Boolean,
    default: () => getConfig3().table.resizable
  },
  // 是否带有斑马纹
  stripe: {
    type: Boolean,
    default: () => getConfig3().table.stripe
  },
  // 是否带有边框
  border: {
    type: [Boolean, String],
    default: () => getConfig3().table.border
  },
  // 单元格是否有边距
  padding: {
    type: Boolean,
    default: () => getConfig3().table.padding
  },
  // 是否圆角边框
  round: {
    type: Boolean,
    default: () => getConfig3().table.round
  },
  // 表格的尺寸
  size: {
    type: String,
    default: () => getConfig3().table.size || getConfig3().size
  },
  // 列的宽度是否自撑开（可能会被废弃的参数，不要使用）
  fit: {
    type: Boolean,
    default: () => getConfig3().table.fit
  },
  // 表格是否加载中
  loading: Boolean,
  // 所有的列对其方式
  align: {
    type: String,
    default: () => getConfig3().table.align
  },
  // 所有的表头列的对齐方式
  headerAlign: {
    type: String,
    default: () => getConfig3().table.headerAlign
  },
  // 所有的表尾列的对齐方式
  footerAlign: {
    type: String,
    default: () => getConfig3().table.footerAlign
  },
  // 是否显示表头
  showHeader: {
    type: Boolean,
    default: () => getConfig3().table.showHeader
  },
  // （即将废弃）是否要高亮当前选中行
  highlightCurrentRow: {
    type: Boolean,
    default: () => getConfig3().table.highlightCurrentRow
  },
  // （即将废弃）鼠标移到行是否要高亮显示
  highlightHoverRow: {
    type: Boolean,
    default: () => getConfig3().table.highlightHoverRow
  },
  // （即将废弃）是否要高亮当前选中列
  highlightCurrentColumn: {
    type: Boolean,
    default: () => getConfig3().table.highlightCurrentColumn
  },
  // （即将废弃）鼠标移到列是否要高亮显示
  highlightHoverColumn: {
    type: Boolean,
    default: () => getConfig3().table.highlightHoverColumn
  },
  // （即将废弃）激活单元格编辑时是否高亮显示
  highlightCell: Boolean,
  // 是否显示表尾合计
  showFooter: Boolean,
  // 表尾数据
  footerData: Array,
  // 表尾合计的计算方法
  footerMethod: Function,
  // 给行附加 className
  rowClassName: [String, Function],
  // 给单元格附加 className
  cellClassName: [String, Function],
  // 给表头的行附加 className
  headerRowClassName: [String, Function],
  // 给表头的单元格附加 className
  headerCellClassName: [String, Function],
  // 给表尾的行附加 className
  footerRowClassName: [String, Function],
  // 给表尾的单元格附加 className
  footerCellClassName: [String, Function],
  // 给单元格附加样式
  cellStyle: [Object, Function],
  // 给表头单元格附加样式
  headerCellStyle: [Object, Function],
  // 给表尾单元格附加样式
  footerCellStyle: [Object, Function],
  // 给行附加样式
  rowStyle: [Object, Function],
  // 给表头行附加样式
  headerRowStyle: [Object, Function],
  // 给表尾行附加样式
  footerRowStyle: [Object, Function],
  // 合并指定单元格
  mergeCells: Array,
  // 合并指定的表尾
  mergeFooterItems: Array,
  // 自定义合并行或列的方法
  spanMethod: Function,
  // 表尾合并行或列
  footerSpanMethod: Function,
  // 设置所有内容过长时显示为省略号
  showOverflow: {
    type: [Boolean, String],
    default: () => getConfig3().table.showOverflow
  },
  // 设置表头所有内容过长时显示为省略号
  showHeaderOverflow: {
    type: [Boolean, String],
    default: () => getConfig3().table.showHeaderOverflow
  },
  // 设置表尾所有内容过长时显示为省略号
  showFooterOverflow: {
    type: [Boolean, String],
    default: () => getConfig3().table.showFooterOverflow
  },
  /** 高级属性 */
  // （即将废弃）columnKey 已废弃，被 column-config.useKey 替换
  columnKey: Boolean,
  // （即将废弃）rowKey 已废弃，被 row-config.useKey 替换
  rowKey: Boolean,
  // （即将废弃）rowId 已废弃，被 row-config.keyField 替换
  rowId: {
    type: String,
    default: () => getConfig3().table.rowId
  },
  zIndex: Number,
  emptyText: {
    type: String,
    default: () => getConfig3().table.emptyText
  },
  keepSource: {
    type: Boolean,
    default: () => getConfig3().table.keepSource
  },
  // 是否自动监听父容器变化去更新响应式表格宽高
  autoResize: {
    type: Boolean,
    default: () => getConfig3().table.autoResize
  },
  // 是否自动根据状态属性去更新响应式表格宽高
  syncResize: [Boolean, String, Number],
  // 响应式布局配置项
  resizeConfig: Object,
  // 列配置信息
  columnConfig: Object,
  // 单元格配置信息
  cellConfig: Object,
  // 行配置信息
  rowConfig: Object,
  // 已废弃，被 rowDragConfig 替换
  dragConfig: Object,
  // 行拖拽排序配置项
  rowDragConfig: Object,
  // 列拖拽排序配置项
  columnDragConfig: Object,
  // 列调整配置项
  resizableConfig: Object,
  // 序号配置项
  seqConfig: Object,
  // 排序配置项
  sortConfig: Object,
  // 筛选配置项
  filterConfig: Object,
  // 单选框配置
  radioConfig: Object,
  // 复选框配置项
  checkboxConfig: Object,
  // tooltip 配置项
  tooltipConfig: Object,
  // 导出配置项
  exportConfig: Object,
  // 导入配置项
  importConfig: Object,
  // 打印配置项
  printConfig: Object,
  // 展开行配置项
  expandConfig: Object,
  // 树形结构配置项
  treeConfig: Object,
  // 快捷菜单配置项
  menuConfig: Object,
  // 鼠标配置项
  mouseConfig: Object,
  // 区域配置项
  areaConfig: Object,
  // 按键配置项
  keyboardConfig: Object,
  // 复制粘/贴配置项
  clipConfig: Object,
  // 查找/替换配置项
  fnrConfig: Object,
  // 编辑配置项
  editConfig: Object,
  // 校验配置项
  validConfig: Object,
  // 校验规则配置项
  editRules: Object,
  // 加载中配置项
  loadingConfig: Object,
  // 空内容渲染配置项
  emptyRender: Object,
  // 自定义列配置项
  customConfig: Object,
  // 横向虚拟滚动配置项
  scrollX: Object,
  // 纵向虚拟滚动配置项
  scrollY: Object,
  // （即将废弃）优化相关
  animat: {
    type: Boolean,
    default: () => getConfig3().table.animat
  },
  // （可能会被废弃的参数，不要使用）
  delayHover: {
    type: Number,
    default: () => getConfig3().table.delayHover
  },
  // 额外的参数
  params: Object
};

// node_modules/vxe-table/es/table/src/emits.js
var emits_default = [
  "update:data",
  "keydown-start",
  "keydown",
  "keydown-end",
  "paste",
  "copy",
  "cut",
  "current-change",
  "radio-change",
  "checkbox-change",
  "checkbox-all",
  "checkbox-range-start",
  "checkbox-range-change",
  "checkbox-range-end",
  "checkbox-range-select",
  "cell-click",
  "cell-dblclick",
  "cell-menu",
  "cell-mouseenter",
  "cell-mouseleave",
  "cell-selected",
  "cell-delete-value",
  "cell-backspace-value",
  "header-cell-click",
  "header-cell-dblclick",
  "header-cell-menu",
  "footer-cell-click",
  "footer-cell-dblclick",
  "footer-cell-menu",
  "clear-merge",
  "sort-change",
  "clear-sort",
  "filter-change",
  "filter-visible",
  "clear-filter",
  "resizable-change",
  "toggle-row-expand",
  "toggle-tree-expand",
  "menu-click",
  "edit-closed",
  "row-dragstart",
  "row-dragover",
  "row-dragend",
  "column-dragstart",
  "column-dragover",
  "column-dragend",
  "enter-append-row",
  "edit-actived",
  "edit-activated",
  "edit-disabled",
  "valid-error",
  "scroll",
  "scroll-boundary",
  "custom",
  "change-fnr",
  "open-fnr",
  "show-fnr",
  "hide-fnr",
  "fnr-change",
  "fnr-find",
  "fnr-find-all",
  "fnr-replace",
  "fnr-replace-all",
  "cell-area-copy",
  "cell-area-cut",
  "cell-area-paste",
  "cell-area-merge",
  "clear-cell-area-selection",
  "clear-cell-area-merge",
  "header-cell-area-selection",
  "cell-area-selection-invalid",
  "cell-area-selection-start",
  "cell-area-selection-drag",
  "cell-area-selection-end",
  "cell-area-extension-start",
  "cell-area-extension-drag",
  "cell-area-extension-end",
  "cell-area-selection-all-start",
  "cell-area-selection-all-end",
  "cell-area-arrows-start",
  "cell-area-arrows-end",
  "active-cell-change-start",
  "active-cell-change-end"
];

// node_modules/vxe-table/es/table/module/custom/panel.js
var import_xe_utils23 = __toESM(require_xe_utils());
var { getI18n: getI18n6, getIcon: getIcon4, renderEmptyElement: renderEmptyElement4 } = VxeUI;
var panel_default = defineComponent({
  name: "TableCustomPanel",
  props: {
    customStore: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIDrawerComponent = VxeUI.getComponent("VxeDrawer");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUINumberInputComponent = VxeUI.getComponent("VxeNumberInput");
    const VxeUIRadioGroupComponent = VxeUI.getComponent("VxeRadioGroup");
    const $xeTable = inject("$xeTable", {});
    const { props: tableProps, reactData, internalData } = $xeTable;
    const { computeCustomOpts, computeColumnDragOpts, computeColumnOpts, computeIsMaxFixedColumn, computeResizableOpts } = $xeTable.getComputeMaps();
    const refElem = ref();
    const bodyElemRef = ref();
    const refDragLineElem = ref();
    const refDragTipElem = ref();
    const dragColumnRef = ref();
    let prevDragCol;
    let prevDragToChild = false;
    let prevDragPos;
    const handleWrapperMouseenterEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = true;
      $xeTable.customOpenEvent(evnt);
    };
    const handleWrapperMouseleaveEvent = (evnt) => {
      const { customStore } = props;
      customStore.activeWrapper = false;
      setTimeout(() => {
        if (!customStore.activeBtn && !customStore.activeWrapper) {
          $xeTable.customCloseEvent(evnt);
        }
      }, 300);
    };
    const confirmCustomEvent = ({ $event }) => {
      reactData.isCustomStatus = true;
      $xeTable.saveCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("confirm", $event);
    };
    const cancelCloseEvent = ({ $event }) => {
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("close", $event);
    };
    const cancelCustomEvent = ({ $event }) => {
      $xeTable.cancelCustom();
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("cancel", $event);
    };
    const handleResetCustomEvent = (evnt) => {
      $xeTable.resetCustom(true);
      $xeTable.closeCustom();
      $xeTable.emitCustomEvent("reset", evnt);
    };
    const resetCustomEvent = ({ $event }) => {
      if (VxeUI.modal) {
        VxeUI.modal.confirm({
          content: getI18n6("vxe.custom.cstmConfirmRestore"),
          className: "vxe-table--ignore-clear",
          escClosable: true
        }).then((type) => {
          if (type === "confirm") {
            handleResetCustomEvent($event);
          }
        });
      } else {
        handleResetCustomEvent($event);
      }
    };
    const handleOptionCheck = (column) => {
      const { customColumnList } = reactData;
      const matchObj = import_xe_utils23.default.findTree(customColumnList, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.renderVisible = parent.children.every((column2) => column2.renderVisible);
          parent.halfVisible = !parent.renderVisible && parent.children.some((column2) => column2.renderVisible || column2.halfVisible);
          handleOptionCheck(parent);
        }
      }
    };
    const changeCheckboxOption = (column) => {
      const isChecked = !column.renderVisible;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        import_xe_utils23.default.eachTree([column], (item) => {
          item.visible = isChecked;
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils23.default.eachTree([column], (item) => {
          item.renderVisible = isChecked;
          item.halfVisible = false;
        });
      }
      handleOptionCheck(column);
      $xeTable.checkCustomStatus();
    };
    const changeColumnWidth = (column) => {
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderResizeWidth !== column.renderWidth) {
          column.resizeWidth = column.renderResizeWidth;
          column.renderWidth = column.renderResizeWidth;
          reactData.isCustomStatus = true;
          $xeTable.handleCustom();
          $xeTable.saveCustomStore("update:width");
        }
      }
    };
    const changeFixedOption = (column, colFixed) => {
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const customOpts = computeCustomOpts.value;
      if (customOpts.immediate) {
        if (column.renderFixed === colFixed) {
          import_xe_utils23.default.eachTree([column], (col) => {
            col.fixed = "";
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            import_xe_utils23.default.eachTree([column], (col) => {
              col.fixed = colFixed;
              col.renderFixed = colFixed;
            });
          }
        }
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:fixed");
      } else {
        if (column.renderFixed === colFixed) {
          import_xe_utils23.default.eachTree([column], (col) => {
            col.renderFixed = "";
          });
        } else {
          if (!isMaxFixedColumn || column.renderFixed) {
            import_xe_utils23.default.eachTree([column], (col) => {
              col.renderFixed = colFixed;
            });
          }
        }
      }
    };
    const allOptionEvent = () => {
      $xeTable.toggleCustomAllCheckbox();
    };
    const showDropTip = (evnt, optEl, showLine, dragPos) => {
      const el2 = bodyElemRef.value;
      if (!el2) {
        return;
      }
      const wrapperRect = el2.getBoundingClientRect();
      if (optEl) {
        const dragLineEl = refDragLineElem.value;
        if (dragLineEl) {
          if (showLine) {
            const optRect = optEl.getBoundingClientRect();
            dragLineEl.style.display = "block";
            dragLineEl.style.top = `${Math.max(1, optRect.y + el2.scrollTop - wrapperRect.y)}px`;
            dragLineEl.style.height = `${optRect.height}px`;
            dragLineEl.style.width = `${optRect.width}px`;
            dragLineEl.setAttribute("drag-pos", dragPos);
            dragLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            dragLineEl.style.display = "";
          }
        }
      }
      const dragTipEl = refDragTipElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "block";
        dragTipEl.style.top = `${Math.min(el2.clientHeight + el2.scrollTop - dragTipEl.clientHeight, evnt.clientY + el2.scrollTop - wrapperRect.y)}px`;
        dragTipEl.style.left = `${Math.min(el2.clientWidth + el2.scrollLeft - dragTipEl.clientWidth, evnt.clientX + el2.scrollLeft - wrapperRect.x)}px`;
        dragTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const dragTipEl = refDragTipElem.value;
      const dragLineEl = refDragLineElem.value;
      if (dragTipEl) {
        dragTipEl.style.display = "";
      }
      if (dragLineEl) {
        dragLineEl.style.display = "";
      }
    };
    const sortMousedownEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      const colid = trEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      trEl.draggable = true;
      dragColumnRef.value = column;
      addClass(trEl, "active--drag-origin");
    };
    const sortMouseupEvent = (evnt) => {
      const btnEl = evnt.currentTarget;
      const cellEl = btnEl.parentElement;
      const tdEl = cellEl.parentElement;
      const trEl = tdEl.parentElement;
      hideDropTip();
      trEl.draggable = false;
      dragColumnRef.value = null;
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragstartEvent = (evnt) => {
      if (evnt.dataTransfer) {
        const img = new Image();
        img.src = tpImg;
        evnt.dataTransfer.setDragImage(img, 0, 0);
      }
    };
    const sortDragendEvent = (evnt) => {
      const { mouseConfig } = tableProps;
      const { customColumnList } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const trEl = evnt.currentTarget;
      const dragCol = dragColumnRef.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod } = columnDragOpts;
      const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
      if (prevDragCol && dragCol) {
        if (prevDragCol !== dragCol) {
          const oldColumn = dragCol;
          const newColumn = prevDragCol;
          Promise.resolve(dragEndMethod ? dragEndMethod({
            oldColumn,
            newColumn,
            dragPos: prevDragPos,
            offsetIndex: dragOffsetIndex
          }) : true).then((status) => {
            if (!status) {
              return;
            }
            let oafIndex = -1;
            let nafIndex = -1;
            const oldAllMaps = {};
            import_xe_utils23.default.eachTree([oldColumn], (column) => {
              oldAllMaps[column.id] = column;
            });
            let isSelfToChildStatus = false;
            if (immediate) {
              if (oldColumn.parentId && newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!isSelfToChildDrag) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n6("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else if (oldColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!isSelfToChildDrag) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n6("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils23.default.findTree(collectColumn, (item) => item.id === oldColumn.id);
              if (isSelfToChildStatus && isSelfToChildDrag) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = oldColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = oldColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  oldColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils23.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isToChildDrag && prevDragToChild) {
                  oldColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([oldColumn]);
                } else {
                  oldColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, oldColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils23.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index2 + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
            } else {
              oafIndex = import_xe_utils23.default.findIndexOf(customColumnList, (item) => item.id === oldColumn.id);
              customColumnList.splice(oafIndex, 1);
              nafIndex = import_xe_utils23.default.findIndexOf(customColumnList, (item) => item.id === newColumn.id);
              customColumnList.splice(nafIndex + dragOffsetIndex, 0, oldColumn);
            }
            reactData.isDragColMove = true;
            if (mouseConfig) {
              if ($xeTable.clearSelected) {
                $xeTable.clearSelected();
              }
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
            }
            $xeTable.dispatchEvent("column-dragend", {
              oldColumn,
              newColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex,
              _index: {
                newIndex: nafIndex,
                oldIndex: oafIndex
              }
            }, evnt);
            if (immediate) {
              reactData.customColumnList = collectColumn.slice(0);
              $xeTable.refreshColumn(true).then(() => {
                $xeTable.updateCellAreas();
                $xeTable.handleCustom();
                $xeTable.saveCustomStore("update:sort");
              });
            }
          }).catch(() => {
          });
        }
      }
      hideDropTip();
      dragColumnRef.value = null;
      trEl.draggable = false;
      trEl.removeAttribute("drag-pos");
      removeClass(trEl, "active--drag-target");
      removeClass(trEl, "active--drag-origin");
    };
    const sortDragoverEvent = (evnt) => {
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isToChildDrag } = columnDragOpts;
      const optEl = evnt.currentTarget;
      const hasCtrlKey = evnt.ctrlKey;
      const colid = optEl.getAttribute("colid");
      const column = $xeTable.getColumnById(colid);
      const dragCol = dragColumnRef.value;
      if (column && (isCrossDrag || column.level === 1)) {
        evnt.preventDefault();
        const offsetY = evnt.clientY - optEl.getBoundingClientRect().y;
        const dragPos = offsetY < optEl.clientHeight / 2 ? "top" : "bottom";
        if (dragCol && dragCol.id === column.id || !isCrossDrag && column.level > 1 || !immediate && column.level > 1 || column.renderFixed) {
          showDropTip(evnt, optEl, false, dragPos);
          return;
        }
        prevDragToChild = !!(isToChildDrag && hasCtrlKey && immediate);
        prevDragCol = column;
        prevDragPos = dragPos;
        showDropTip(evnt, optEl, true, dragPos);
      }
    };
    const renderDragTip = () => {
      const dragCol = dragColumnRef.value;
      return h("div", {}, [
        h("div", {
          ref: refDragLineElem,
          class: "vxe-table-custom-popup--drag-line"
        }),
        h("div", {
          ref: refDragTipElem,
          class: "vxe-table-custom-popup--drag-tip"
        }, [
          h("div", {
            class: "vxe-table-custom-popup--drag-tip-wrapper"
          }, [
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-status"
            }, [
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-normal-status", getIcon4().TABLE_DRAG_STATUS_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-sub-status", getIcon4().TABLE_DRAG_STATUS_SUB_ROW]
              }),
              h("span", {
                class: ["vxe-table-custom-popup--drag-tip-disabled-status", getIcon4().TABLE_DRAG_DISABLED]
              })
            ]),
            h("div", {
              class: "vxe-table-custom-popup--drag-tip-content"
            }, getI18n6("vxe.custom.cstmDragTarget", [dragCol && dragCol.type !== "html" ? dragCol.getTitle() : ""]))
          ])
        ])
      ]);
    };
    const renderSimplePanel = () => {
      const { customStore } = props;
      const { isCustomStatus, customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { maxHeight } = customStore;
      const { checkMethod, visibleMethod, allowVisible, allowSort, allowFixed, trigger, placement } = customOpts;
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const colVNs = [];
      const customWrapperOns = {};
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      if (trigger === "hover") {
        customWrapperOns.onMouseenter = handleWrapperMouseenterEvent;
        customWrapperOns.onMouseleave = handleWrapperMouseleaveEvent;
      }
      const params = {
        $table: $xeTable,
        $grid: $xeTable.xegrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils23.default.eachTree(customColumnList, (column, index2, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const isColGroup = column.children && column.children.length;
          const colTitle = formatText(column.getTitle(), 1);
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          const isHidden = !isChecked;
          colVNs.push(h("li", {
            key: column.id,
            colid: column.id,
            class: ["vxe-table-custom--option", `level--${column.level}`, {
              "is--hidden": isDisabled || isHidden,
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("div", {
              class: ["vxe-table-custom--checkbox-option", {
                "is--checked": isChecked,
                "is--indeterminate": isIndeterminate,
                "is--disabled": isDisabled
              }],
              title: getI18n6("vxe.custom.setting.colVisible"),
              onClick: () => {
                if (!isDisabled) {
                  changeCheckboxOption(column);
                }
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-table-custom--name-option"
            }, [
              allowSort && ((isCrossDrag ? immediate : false) || column.level === 1) ? h("div", {
                class: "vxe-table-custom--sort-option"
              }, [
                h("span", Object.assign({ class: ["vxe-table-custom--sort-btn", {
                  "is--disabled": isDisabled || isHidden || column.renderFixed
                }], title: getI18n6("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden || column.renderFixed ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon4().TABLE_CUSTOM_SORT
                  })
                ])
              ]) : createCommentVNode(),
              column.type === "html" ? h("div", {
                key: "1",
                class: "vxe-table-custom--checkbox-label",
                innerHTML: colTitle
              }) : h("div", {
                key: "0",
                class: "vxe-table-custom--checkbox-label"
              }, colTitle)
            ]),
            !parent && allowFixed ? h("div", {
              class: "vxe-table-custom--fixed-option"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "left" ? getIcon4().TOOLBAR_TOOLS_FIXED_LEFT_ACTIVE : getIcon4().TOOLBAR_TOOLS_FIXED_LEFT,
                status: column.renderFixed === "left" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n6(column.renderFixed === "left" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedLeft"),
                onClick: () => {
                  changeFixedOption(column, "left");
                }
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                mode: "text",
                icon: column.renderFixed === "right" ? getIcon4().TOOLBAR_TOOLS_FIXED_RIGHT_ACTIVE : getIcon4().TOOLBAR_TOOLS_FIXED_RIGHT,
                status: column.renderFixed === "right" ? "primary" : "",
                disabled: isDisabled || isHidden || isMaxFixedColumn && !column.renderFixed,
                title: getI18n6(column.renderFixed === "right" ? "vxe.toolbar.cancelFixed" : "vxe.toolbar.fixedRight"),
                onClick: () => {
                  changeFixedOption(column, "right");
                }
              }) : createCommentVNode()
            ]) : createCommentVNode()
          ]));
        }
      });
      return h("div", {
        ref: refElem,
        key: "simple",
        class: ["vxe-table-custom-wrapper", `placement--${placement}`, {
          "is--active": customStore.visible
        }],
        style: maxHeight && !["left", "right"].includes(placement) ? {
          maxHeight: `${maxHeight}px`
        } : {}
      }, customStore.visible ? [
        h("div", {
          class: "vxe-table-custom--header"
        }, headerSlot ? $xeTable.callSlot(headerSlot, params) : [
          h("ul", {
            class: "vxe-table-custom--panel-list"
          }, [
            h("li", {
              class: "vxe-table-custom--option"
            }, [
              allowVisible ? h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isAllChecked,
                  "is--indeterminate": isAllIndeterminate
                }],
                title: getI18n6("vxe.table.allTitle"),
                onClick: allOptionEvent
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                }),
                h("span", {
                  class: "vxe-checkbox--label"
                }, getI18n6("vxe.toolbar.customAll"))
              ]) : h("span", {
                class: "vxe-checkbox--label"
              }, getI18n6("vxe.table.customTitle"))
            ])
          ])
        ]),
        h("div", {
          ref: bodyElemRef,
          class: "vxe-table-custom--body"
        }, [
          topSlot ? h("div", {
            class: "vxe-table-custom--panel-top"
          }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
          defaultSlot ? h("div", {
            class: "vxe-table-custom--panel-body"
          }, $xeTable.callSlot(defaultSlot, params)) : h(TransitionGroup, Object.assign({ class: "vxe-table-custom--panel-list", name: "vxe-table-custom--list", tag: "ul" }, customWrapperOns), {
            default: () => colVNs
          }),
          bottomSlot ? h("div", {
            class: "vxe-table-custom--panel-bottom"
          }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
          renderDragTip()
        ]),
        customOpts.showFooter ? h("div", {
          class: "vxe-table-custom--footer"
        }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
          h("div", {
            class: "vxe-table-custom--footer-buttons"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.resetButtonText || getI18n6("vxe.table.customRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : createCommentVNode(),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.closeButtonText || getI18n6("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              content: customOpts.cancelButtonText || getI18n6("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : createCommentVNode(),
            immediate ? createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              mode: "text",
              status: "primary",
              content: customOpts.confirmButtonText || getI18n6("vxe.table.customConfirm"),
              onClick: confirmCustomEvent
            }) : createCommentVNode()
          ])
        ]) : null
      ] : []);
    };
    const renderPopupPanel = () => {
      const { customStore } = props;
      const { resizable: allResizable } = tableProps;
      const { isCustomStatus, customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { immediate } = customOpts;
      const columnDragOpts = computeColumnDragOpts.value;
      const { mode, modalOptions, drawerOptions, allowVisible, allowSort, allowFixed, allowResizable, checkMethod, visibleMethod } = customOpts;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      const resizableOpts = computeResizableOpts.value;
      const { minWidth: reMinWidth, maxWidth: reMaxWidth } = resizableOpts;
      const modalOpts = Object.assign({}, modalOptions);
      const drawerOpts = Object.assign({}, drawerOptions);
      const isMaxFixedColumn = computeIsMaxFixedColumn.value;
      const { isCrossDrag } = columnDragOpts;
      const slots = customOpts.slots || {};
      const headerSlot = slots.header;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const trVNs = [];
      const isAllChecked = customStore.isAll;
      const isAllIndeterminate = customStore.isIndeterminate;
      const params = {
        $table: $xeTable,
        $grid: $xeTable.xegrid,
        columns: customColumnList,
        isAllChecked,
        isAllIndeterminate,
        isCustomStatus
      };
      import_xe_utils23.default.eachTree(customColumnList, (column, index2, items, path, parent) => {
        const isVisible = visibleMethod ? visibleMethod({ column }) : true;
        if (isVisible) {
          let customMinWidth = 0;
          let customMaxWidth = 0;
          if (allowResizable) {
            const resizeParams = {
              $table: $xeTable,
              column,
              columnIndex: index2,
              $columnIndex: index2,
              $rowIndex: -1
            };
            if (reMinWidth) {
              customMinWidth = import_xe_utils23.default.toNumber(import_xe_utils23.default.isFunction(reMinWidth) ? reMinWidth(resizeParams) : reMinWidth);
            }
            if (reMaxWidth) {
              customMaxWidth = import_xe_utils23.default.toNumber(import_xe_utils23.default.isFunction(reMaxWidth) ? reMaxWidth(resizeParams) : reMaxWidth);
            }
          }
          const isChecked = column.renderVisible;
          const isIndeterminate = column.halfVisible;
          const colTitle = formatText(column.getTitle(), 1);
          const isColGroup = column.children && column.children.length;
          const isDisabled = checkMethod ? !checkMethod({ column }) : false;
          const isHidden = !isChecked;
          trVNs.push(h("tr", {
            key: column.id,
            colid: column.id,
            class: [`vxe-table-custom-popup--row level--${column.level}`, {
              "is--group": isColGroup
            }],
            onDragstart: sortDragstartEvent,
            onDragend: sortDragendEvent,
            onDragover: sortDragoverEvent
          }, [
            allowVisible ? h("td", {
              class: "vxe-table-custom-popup--column-item col--visible"
            }, [
              h("div", {
                class: ["vxe-table-custom--checkbox-option", {
                  "is--checked": isChecked,
                  "is--indeterminate": isIndeterminate,
                  "is--disabled": isDisabled
                }],
                title: getI18n6("vxe.custom.setting.colVisible"),
                onClick: () => {
                  if (!isDisabled) {
                    changeCheckboxOption(column);
                  }
                }
              }, [
                h("span", {
                  class: ["vxe-checkbox--icon", isIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                })
              ])
            ]) : createCommentVNode(),
            h("td", {
              class: "vxe-table-custom-popup--column-item col--name"
            }, [
              h("div", {
                class: "vxe-table-custom-popup--name"
              }, [
                allowSort ? (isCrossDrag ? immediate : false) || column.level === 1 ? h("div", Object.assign({ class: ["vxe-table-custom-popup--column-sort-btn", {
                  "is--disabled": isDisabled || isHidden || column.renderFixed
                }], title: getI18n6("vxe.custom.setting.sortHelpTip") }, isDisabled || isHidden || column.renderFixed ? {} : {
                  onMousedown: sortMousedownEvent,
                  onMouseup: sortMouseupEvent
                }), [
                  h("i", {
                    class: getIcon4().TABLE_CUSTOM_SORT
                  })
                ]) : h("div", {
                  class: "vxe-table-custom-popup--column-sort-placeholder"
                }) : createCommentVNode(),
                column.type === "html" ? h("div", {
                  key: "1",
                  class: "vxe-table-custom-popup--title",
                  innerHTML: colTitle
                }) : h("div", {
                  key: "0",
                  class: "vxe-table-custom-popup--title",
                  title: colTitle
                }, colTitle)
              ])
            ]),
            allowResizable ? h("td", {
              class: "vxe-table-custom-popup--column-item col--resizable"
            }, [
              column.children && column.children.length || !(import_xe_utils23.default.isBoolean(column.resizable) ? column.resizable : columnOpts.resizable || allResizable) ? h("span", "-") : VxeUINumberInputComponent ? h(VxeUINumberInputComponent, {
                type: "integer",
                immediate: false,
                disabled: isDisabled || isHidden,
                modelValue: column.renderResizeWidth,
                min: customMinWidth || void 0,
                max: customMaxWidth || void 0,
                "onUpdate:modelValue"(value) {
                  const width = Math.max(0, Number(value));
                  column.renderResizeWidth = width;
                },
                onChange() {
                  changeColumnWidth(column);
                }
              }) : createCommentVNode()
            ]) : createCommentVNode(),
            allowFixed ? h("td", {
              class: "vxe-table-custom-popup--column-item col--fixed"
            }, [
              parent ? h("span", "-") : VxeUIRadioGroupComponent ? h(VxeUIRadioGroupComponent, {
                modelValue: column.renderFixed || "",
                type: "button",
                size: "mini",
                disabled: isDisabled || isHidden,
                options: [
                  { label: getI18n6("vxe.custom.setting.fixedLeft"), value: "left", disabled: isDisabled || isHidden || isMaxFixedColumn },
                  { label: getI18n6("vxe.custom.setting.fixedUnset"), value: "", disabled: isDisabled || isHidden },
                  { label: getI18n6("vxe.custom.setting.fixedRight"), value: "right", disabled: isDisabled || isHidden || isMaxFixedColumn }
                ],
                "onUpdate:modelValue"(value) {
                  changeFixedOption(column, value);
                }
              }) : createCommentVNode()
            ]) : createCommentVNode()
          ]));
        }
      });
      const scopedSlots = {
        default: () => {
          if (defaultSlot) {
            return $xeTable.callSlot(defaultSlot, params);
          }
          return h("div", {
            ref: bodyElemRef,
            class: "vxe-table-custom-popup--body"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-custom-popup--table-top"
            }, $xeTable.callSlot(topSlot, params)) : renderEmptyElement4($xeTable),
            h("div", {
              class: "vxe-table-custom-popup--table-wrapper"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  allowVisible ? h("col", {
                    class: "vxe-table-custom-popup--table-col-seq"
                  }) : createCommentVNode(),
                  h("col", {
                    class: "vxe-table-custom-popup--table-col-title"
                  }),
                  allowResizable ? h("col", {
                    class: "vxe-table-custom-popup--table-col-width"
                  }) : createCommentVNode(),
                  allowFixed ? h("col", {
                    class: "vxe-table-custom-popup--table-col-fixed"
                  }) : createCommentVNode()
                ]),
                h("thead", {}, [
                  h("tr", {}, [
                    allowVisible ? h("th", {}, [
                      h("div", {
                        class: ["vxe-table-custom--checkbox-option", {
                          "is--checked": isAllChecked,
                          "is--indeterminate": isAllIndeterminate
                        }],
                        title: getI18n6("vxe.table.allTitle"),
                        onClick: allOptionEvent
                      }, [
                        h("span", {
                          class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon4().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon4().TABLE_CHECKBOX_CHECKED : getIcon4().TABLE_CHECKBOX_UNCHECKED]
                        }),
                        h("span", {
                          class: "vxe-checkbox--label"
                        }, getI18n6("vxe.toolbar.customAll"))
                      ])
                    ]) : createCommentVNode(),
                    h("th", {}, getI18n6("vxe.custom.setting.colTitle")),
                    allowResizable ? h("th", {}, getI18n6("vxe.custom.setting.colResizable")) : createCommentVNode(),
                    allowFixed ? h("th", {}, getI18n6(`vxe.custom.setting.${maxFixedSize ? "colFixedMax" : "colFixed"}`, [maxFixedSize])) : createCommentVNode()
                  ])
                ]),
                h(TransitionGroup, {
                  class: "vxe-table-custom--panel-list",
                  tag: "tbody",
                  name: "vxe-table-custom--list"
                }, {
                  default: () => trVNs
                })
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-custom-popup--table-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : renderEmptyElement4($xeTable),
            renderDragTip()
          ]);
        },
        footer: () => {
          if (footerSlot) {
            return $xeTable.callSlot(footerSlot, params);
          }
          return h("div", {
            class: "vxe-table-custom-popup--footer"
          }, [
            VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.resetButtonText || getI18n6("vxe.custom.cstmRestore"),
              disabled: !isCustomStatus,
              onClick: resetCustomEvent
            }) : createCommentVNode(),
            immediate ? VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.closeButtonText || getI18n6("vxe.table.customClose"),
              onClick: cancelCloseEvent
            }) : createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              content: customOpts.cancelButtonText || getI18n6("vxe.table.customCancel"),
              onClick: cancelCustomEvent
            }) : createCommentVNode(),
            immediate ? createCommentVNode() : VxeUIButtonComponent ? h(VxeUIButtonComponent, {
              status: "primary",
              content: customOpts.confirmButtonText || getI18n6("vxe.custom.cstmConfirm"),
              onClick: confirmCustomEvent
            }) : createCommentVNode()
          ]);
        }
      };
      if (headerSlot) {
        scopedSlots.header = () => $xeTable.callSlot(headerSlot, params);
      }
      if (mode === "drawer") {
        return VxeUIDrawerComponent ? h(VxeUIDrawerComponent, {
          key: "drawer",
          className: ["vxe-table-custom-drawer-wrapper", "vxe-table--ignore-clear", drawerOpts.className || ""].join(" "),
          modelValue: customStore.visible,
          title: drawerOpts.title || getI18n6("vxe.custom.cstmTitle"),
          width: drawerOpts.width || Math.min(880, Math.floor(document.documentElement.clientWidth * 0.6)),
          position: drawerOpts.position,
          resize: !!drawerOpts.resize,
          escClosable: !!drawerOpts.escClosable,
          maskClosable: !!drawerOpts.maskClosable,
          destroyOnClose: true,
          showFooter: true,
          "onUpdate:modelValue"(value) {
            customStore.visible = value;
          }
        }, scopedSlots) : createCommentVNode();
      }
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        key: "modal",
        className: ["vxe-table-custom-modal-wrapper", "vxe-table--ignore-clear", modalOpts.className || ""].join(" "),
        modelValue: customStore.visible,
        title: modalOpts.title || getI18n6("vxe.custom.cstmTitle"),
        width: modalOpts.width || Math.min(880, document.documentElement.clientWidth),
        minWidth: modalOpts.minWidth || 700,
        height: modalOpts.height || Math.min(680, document.documentElement.clientHeight),
        minHeight: modalOpts.minHeight || 400,
        showZoom: modalOpts.showZoom,
        showMaximize: modalOpts.showMaximize,
        showMinimize: modalOpts.showMinimize,
        mask: modalOpts.mask,
        lockView: modalOpts.lockView,
        resize: modalOpts.resize,
        escClosable: !!modalOpts.escClosable,
        maskClosable: !!modalOpts.maskClosable,
        destroyOnClose: true,
        showFooter: true,
        "onUpdate:modelValue"(value) {
          customStore.visible = value;
        }
      }, scopedSlots) : createCommentVNode();
    };
    const renderVN = () => {
      const customOpts = computeCustomOpts.value;
      if (["modal", "drawer", "popup"].includes(`${customOpts.mode}`)) {
        return renderPopupPanel();
      }
      return renderSimplePanel();
    };
    if (true) {
      nextTick(() => {
        const customOpts = computeCustomOpts.value;
        const { mode } = customOpts;
        if (!VxeUIModalComponent) {
          errLog("vxe.error.reqComp", ["vxe-modal"]);
        }
        if (!VxeUIDrawerComponent && mode === "drawer") {
          errLog("vxe.error.reqComp", ["vxe-drawer"]);
        }
        if (!VxeUIButtonComponent) {
          errLog("vxe.error.reqComp", ["vxe-button"]);
        }
        if (!VxeUINumberInputComponent) {
          errLog("vxe.error.reqComp", ["vxe-number-input"]);
        }
        if (!VxeUIRadioGroupComponent) {
          errLog("vxe.error.reqComp", ["vxe-radio-group"]);
        }
      });
    }
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/filter/panel.js
var { getI18n: getI18n7, getIcon: getIcon5, renderer: renderer7 } = VxeUI;
var panel_default2 = defineComponent({
  name: "VxeTableFilterPanel",
  props: {
    filterStore: Object
  },
  setup(props) {
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData, internalData: tableInternalData, getComputeMaps } = $xeTable;
    const { computeFilterOpts } = getComputeMaps();
    const computeHasCheckOption = computed(() => {
      const { filterStore } = props;
      return filterStore && filterStore.options.some((option2) => option2.checked);
    });
    const filterCheckAllEvent = (evnt, value) => {
      const { filterStore } = props;
      filterStore.options.forEach((option2) => {
        option2._checked = value;
        option2.checked = value;
      });
      filterStore.isAllSelected = value;
      filterStore.isIndeterminate = false;
    };
    const confirmFilter = (evnt) => {
      $xeTable.handleFilterConfirmFilter(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeRadioOption(evnt, checked, item);
    };
    const resetFilter = (evnt) => {
      $xeTable.handleFilterResetFilter(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeMultipleOption(evnt, checked, item);
    };
    const changeOption = (evnt, checked, item) => {
      $xeTable.handleFilterChangeOption(evnt, checked, item);
    };
    const changeAllOption = (evnt, checked) => {
      const { filterStore } = props;
      if (filterStore.multiple) {
        filterCheckAllEvent(evnt, checked);
      } else {
        resetFilter(evnt);
      }
    };
    const $panel = {
      changeRadioOption,
      changeMultipleOption,
      changeAllOption,
      changeOption,
      confirmFilter,
      resetFilter
    };
    const renderOptions = (filterRender, compConf) => {
      const { filterStore } = props;
      const { column, multiple, maxHeight } = filterStore;
      const slots = column ? column.slots : null;
      const filterSlot = slots ? slots.filter : null;
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xeTable });
      const rtFilter = compConf ? compConf.renderTableFilter || compConf.renderFilter : null;
      if (filterSlot) {
        return [
          h("div", {
            class: "vxe-table--filter-template"
          }, $xeTable.callSlot(filterSlot, params))
        ];
      } else if (rtFilter) {
        return [
          h("div", {
            class: "vxe-table--filter-template"
          }, getSlotVNs(rtFilter(filterRender, params)))
        ];
      }
      const isAllChecked = multiple ? filterStore.isAllSelected : !filterStore.options.some((item) => item._checked);
      const isAllIndeterminate = multiple && filterStore.isIndeterminate;
      return [
        h("ul", {
          class: "vxe-table--filter-header"
        }, [
          h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": isAllChecked,
              "is--indeterminate": isAllIndeterminate
            }],
            title: getI18n7(multiple ? "vxe.table.allTitle" : "vxe.table.allFilter"),
            onClick: (evnt) => {
              changeAllOption(evnt, !filterStore.isAllSelected);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon5().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon5().TABLE_CHECKBOX_CHECKED : getIcon5().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, getI18n7("vxe.table.allFilter"))
          ]))
        ]),
        h("ul", {
          class: "vxe-table--filter-body",
          style: maxHeight ? {
            maxHeight: `${maxHeight}px`
          } : {}
        }, filterStore.options.map((item) => {
          const isChecked = item._checked;
          const isIndeterminate = false;
          return h("li", {
            class: ["vxe-table--filter-option", {
              "is--checked": item._checked
            }],
            title: item.label,
            onClick: (evnt) => {
              changeOption(evnt, !item._checked, item);
            }
          }, (multiple ? [
            h("span", {
              class: ["vxe-checkbox--icon", isIndeterminate ? getIcon5().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon5().TABLE_CHECKBOX_CHECKED : getIcon5().TABLE_CHECKBOX_UNCHECKED]
            })
          ] : []).concat([
            h("span", {
              class: "vxe-checkbox--label"
            }, formatText(item.label, 1))
          ]));
        }))
      ];
    };
    const renderFooters = () => {
      const { filterStore } = props;
      const { column, multiple } = filterStore;
      const filterOpts = computeFilterOpts.value;
      const hasCheckOption = computeHasCheckOption.value;
      const { filterRender } = column;
      const compConf = isEnableConf(filterRender) ? renderer7.get(filterRender.name) : null;
      const isDisabled = !hasCheckOption && !filterStore.isAllSelected && !filterStore.isIndeterminate;
      return multiple && (compConf ? !(compConf.showTableFilterFooter === false || compConf.showFilterFooter === false || compConf.isFooter === false) : true) ? [
        h("div", {
          class: "vxe-table--filter-footer"
        }, [
          h("button", {
            class: {
              "is--disabled": isDisabled
            },
            disabled: isDisabled,
            onClick: confirmFilter
          }, filterOpts.confirmButtonText || getI18n7("vxe.table.confirmFilter")),
          h("button", {
            onClick: resetFilter
          }, filterOpts.resetButtonText || getI18n7("vxe.table.resetFilter"))
        ])
      ] : [];
    };
    const renderVN = () => {
      const { filterStore } = props;
      const { initStore } = tableReactData;
      const { column } = filterStore;
      const filterRender = column ? column.filterRender : null;
      const compConf = isEnableConf(filterRender) ? renderer7.get(filterRender.name) : null;
      const filterClassName = compConf ? compConf.tableFilterClassName || compConf.filterClassName : "";
      const params = Object.assign({}, tableInternalData._currFilterParams, { $panel, $table: $xeTable });
      return h("div", {
        class: [
          "vxe-table--filter-wrapper",
          "filter--prevent-default",
          getPropClass(filterClassName, params),
          {
            "is--animat": $xeTable.props.animat,
            "is--multiple": filterStore.multiple,
            "is--active": filterStore.visible
          }
        ],
        style: filterStore.style
      }, initStore.filter && column ? renderOptions(filterRender, compConf).concat(renderFooters()) : []);
    };
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/export/import-panel.js
var import_xe_utils24 = __toESM(require_xe_utils());
var { getI18n: getI18n8, getIcon: getIcon6 } = VxeUI;
var import_panel_default = defineComponent({
  name: "VxeTableImportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const $xeTable = inject("$xeTable", {});
    const { computeImportOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      loading: false
    });
    const refFileBtn = ref();
    const computeSelectName = computed(() => {
      const { storeData: storeData2 } = props;
      return `${storeData2.filename}.${storeData2.type}`;
    });
    const computeHasFile = computed(() => {
      const { storeData: storeData2 } = props;
      return storeData2.file && storeData2.type;
    });
    const computeParseTypeLabel = computed(() => {
      const { storeData: storeData2 } = props;
      const { type, typeList } = storeData2;
      if (type) {
        const selectItem = import_xe_utils24.default.find(typeList, (item) => type === item.value);
        return selectItem ? selectItem.label : "*.*";
      }
      return `*.${typeList.map((item) => item.value).join(", *.")}`;
    });
    const clearFileEvent = () => {
      const { storeData: storeData2 } = props;
      Object.assign(storeData2, {
        filename: "",
        sheetName: "",
        type: ""
      });
    };
    const selectFileEvent = () => {
      const { storeData: storeData2, defaultOptions } = props;
      $xeTable.readFile(defaultOptions).then((params) => {
        const { file } = params;
        Object.assign(storeData2, parseFile(file), { file });
      }).catch((e16) => e16);
    };
    const showEvent = () => {
      nextTick(() => {
        const targetElem = refFileBtn.value;
        if (targetElem) {
          targetElem.focus();
        }
      });
    };
    const cancelEvent = () => {
      const { storeData: storeData2 } = props;
      storeData2.visible = false;
    };
    const importEvent = () => {
      const { storeData: storeData2, defaultOptions } = props;
      const importOpts = computeImportOpts.value;
      reactData.loading = true;
      $xeTable.importByFile(storeData2.file, Object.assign({}, importOpts, defaultOptions)).then(() => {
        reactData.loading = false;
        storeData2.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const renderVN = () => {
      const { defaultOptions, storeData: storeData2 } = props;
      const selectName = computeSelectName.value;
      const hasFile = computeHasFile.value;
      const parseTypeLabel = computeParseTypeLabel.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_IMPORT_MODAL",
        modelValue: storeData2.visible,
        title: getI18n8("vxe.import.impTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 540,
        minWidth: 360,
        minHeight: 240,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData2.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeTable.xegrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : createCommentVNode(),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  h("tr", [
                    h("td", getI18n8("vxe.import.impFile")),
                    h("td", [
                      hasFile ? h("div", {
                        class: "vxe-table-export--selected--file",
                        title: selectName
                      }, [
                        h("span", selectName),
                        h("i", {
                          class: getIcon6().INPUT_CLEAR,
                          onClick: clearFileEvent
                        })
                      ]) : h("button", {
                        ref: refFileBtn,
                        class: "vxe-table-export--select--file",
                        onClick: selectFileEvent
                      }, getI18n8("vxe.import.impSelect"))
                    ])
                  ]),
                  h("tr", [
                    h("td", getI18n8("vxe.import.impType")),
                    h("td", parseTypeLabel)
                  ]),
                  h("tr", [
                    h("td", getI18n8("vxe.import.impMode")),
                    h("td", [
                      VxeUISelectComponent ? h(VxeUISelectComponent, {
                        modelValue: defaultOptions.mode,
                        options: storeData2.modeList,
                        "onUpdate:modelValue"(value) {
                          defaultOptions.mode = value;
                        }
                      }) : createCommentVNode()
                    ])
                  ])
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : createCommentVNode()
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeTable.xegrid,
            options: defaultOptions,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n8("vxe.import.impCancel"),
                onClick: cancelEvent
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                status: "primary",
                disabled: !hasFile || reactData.loading,
                content: getI18n8("vxe.import.impConfirm"),
                onClick: importEvent
              }) : createCommentVNode()
            ])
          ]);
        }
      }) : createCommentVNode();
    };
    if (true) {
      nextTick(() => {
        if (!VxeUIModalComponent) {
          errLog("vxe.error.reqComp", ["vxe-modal"]);
        }
        if (!VxeUIButtonComponent) {
          errLog("vxe.error.reqComp", ["vxe-button"]);
        }
        if (!VxeUISelectComponent) {
          errLog("vxe.error.reqComp", ["vxe-select"]);
        }
      });
    }
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/export/export-panel.js
var import_xe_utils25 = __toESM(require_xe_utils());
var { getI18n: getI18n9, getIcon: getIcon7 } = VxeUI;
var export_panel_default = defineComponent({
  name: "VxeTableExportPanel",
  props: {
    defaultOptions: Object,
    storeData: Object
  },
  setup(props) {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const VxeUISelectComponent = VxeUI.getComponent("VxeSelect");
    const VxeUIInputComponent = VxeUI.getComponent("VxeInput");
    const VxeUICheckboxComponent = VxeUI.getComponent("VxeCheckbox");
    const $xeTable = inject("$xeTable", {});
    const { computeExportOpts, computePrintOpts } = $xeTable.getComputeMaps();
    const reactData = reactive({
      isAll: false,
      isIndeterminate: false,
      loading: false
    });
    const xButtonConfirm = ref();
    const xInputFilename = ref();
    const xInputSheetname = ref();
    const computeCheckedAll = computed(() => {
      const { storeData: storeData2 } = props;
      return storeData2.columns.every((column) => column.checked);
    });
    const computeShowSheet = computed(() => {
      const { defaultOptions } = props;
      return ["html", "xml", "xlsx", "pdf"].indexOf(defaultOptions.type) > -1;
    });
    const computeSupportMerge = computed(() => {
      const { storeData: storeData2, defaultOptions } = props;
      return !defaultOptions.original && defaultOptions.mode === "current" && (storeData2.isPrint || ["html", "xlsx"].indexOf(defaultOptions.type) > -1);
    });
    const computeSupportStyle = computed(() => {
      const { defaultOptions } = props;
      return !defaultOptions.original && ["xlsx"].indexOf(defaultOptions.type) > -1;
    });
    const handleOptionCheck = (column) => {
      const { storeData: storeData2 } = props;
      const matchObj = import_xe_utils25.default.findTree(storeData2.columns, (item) => item === column);
      if (matchObj && matchObj.parent) {
        const { parent } = matchObj;
        if (parent.children && parent.children.length) {
          parent.checked = parent.children.every((column2) => column2.checked);
          parent.halfChecked = !parent.checked && parent.children.some((column2) => column2.checked || column2.halfChecked);
          handleOptionCheck(parent);
        }
      }
    };
    const checkStatus = () => {
      const { storeData: storeData2 } = props;
      const columns = storeData2.columns;
      reactData.isAll = columns.every((column) => column.disabled || column.checked);
      reactData.isIndeterminate = !reactData.isAll && columns.some((column) => !column.disabled && (column.checked || column.halfChecked));
    };
    const changeOption = (column) => {
      const isChecked = !column.checked;
      import_xe_utils25.default.eachTree([column], (item) => {
        item.checked = isChecked;
        item.halfChecked = false;
      });
      handleOptionCheck(column);
      checkStatus();
    };
    const allColumnEvent = () => {
      const { storeData: storeData2 } = props;
      const isAll = !reactData.isAll;
      import_xe_utils25.default.eachTree(storeData2.columns, (column) => {
        if (!column.disabled) {
          column.checked = isAll;
          column.halfChecked = false;
        }
      });
      reactData.isAll = isAll;
      checkStatus();
    };
    const showEvent = () => {
      nextTick(() => {
        const filenameInp = xInputFilename.value;
        const sheetnameInp = xInputSheetname.value;
        const confirmBtn = xButtonConfirm.value;
        const targetElem = filenameInp || sheetnameInp || confirmBtn;
        if (targetElem) {
          targetElem.focus();
        }
      });
      checkStatus();
    };
    const getExportOption = () => {
      const { storeData: storeData2, defaultOptions } = props;
      const { hasMerge, columns } = storeData2;
      const checkedAll = computeCheckedAll.value;
      const supportMerge = computeSupportMerge.value;
      const expColumns = import_xe_utils25.default.searchTree(columns, (column) => column.checked, { children: "children", mapChildren: "childNodes", original: true });
      return Object.assign({}, defaultOptions, {
        columns: expColumns,
        isMerge: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false
      });
    };
    const printEvent = () => {
      const { storeData: storeData2 } = props;
      const printOpts = computePrintOpts.value;
      storeData2.visible = false;
      $xeTable.print(Object.assign({}, printOpts, getExportOption()));
    };
    const exportEvent = () => {
      const { storeData: storeData2 } = props;
      const exportOpts = computeExportOpts.value;
      reactData.loading = true;
      $xeTable.exportData(Object.assign({}, exportOpts, getExportOption())).then(() => {
        reactData.loading = false;
        storeData2.visible = false;
      }).catch(() => {
        reactData.loading = false;
      });
    };
    const cancelEvent = () => {
      const { storeData: storeData2 } = props;
      storeData2.visible = false;
    };
    const confirmEvent = () => {
      const { storeData: storeData2 } = props;
      if (storeData2.isPrint) {
        printEvent();
      } else {
        exportEvent();
      }
    };
    const renderVN = () => {
      const { defaultOptions, storeData: storeData2 } = props;
      const { isAll: isAllChecked, isIndeterminate: isAllIndeterminate } = reactData;
      const { hasTree, hasMerge, isPrint, hasColgroup, columns } = storeData2;
      const { isHeader } = defaultOptions;
      const cols = [];
      const checkedAll = computeCheckedAll.value;
      const showSheet = computeShowSheet.value;
      const supportMerge = computeSupportMerge.value;
      const supportStyle = computeSupportStyle.value;
      const slots = defaultOptions.slots || {};
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const parameterSlot = slots.parameter;
      import_xe_utils25.default.eachTree(columns, (column) => {
        const colTitle = formatText(column.getTitle(), 1);
        const isColGroup = column.children && column.children.length;
        const isChecked = column.checked;
        const indeterminate = column.halfChecked;
        const isHtml = column.type === "html";
        cols.push(h("li", {
          key: column.id,
          class: ["vxe-table-export--panel-column-option", `level--${column.level}`, {
            "is--group": isColGroup,
            "is--checked": isChecked,
            "is--indeterminate": indeterminate,
            "is--disabled": column.disabled
          }],
          title: isHtml ? "" : colTitle,
          onClick: () => {
            if (!column.disabled) {
              changeOption(column);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", indeterminate ? getIcon7().TABLE_CHECKBOX_INDETERMINATE : isChecked ? getIcon7().TABLE_CHECKBOX_CHECKED : getIcon7().TABLE_CHECKBOX_UNCHECKED]
          }),
          isHtml ? h("span", {
            key: "1",
            class: "vxe-checkbox--label",
            innerHTML: colTitle
          }) : h("span", {
            key: "0",
            class: "vxe-checkbox--label"
          }, colTitle)
        ]));
      });
      return VxeUIModalComponent ? h(VxeUIModalComponent, {
        id: "VXE_EXPORT_MODAL",
        modelValue: storeData2.visible,
        title: getI18n9(isPrint ? "vxe.export.printTitle" : "vxe.export.expTitle"),
        className: "vxe-table-export-popup-wrapper",
        width: 660,
        minWidth: 500,
        minHeight: 400,
        mask: true,
        lockView: true,
        showFooter: true,
        escClosable: true,
        maskClosable: true,
        showMaximize: true,
        resize: true,
        loading: reactData.loading,
        "onUpdate:modelValue"(value) {
          storeData2.visible = value;
        },
        onShow: showEvent
      }, {
        default: () => {
          const params = {
            $table: $xeTable,
            $grid: $xeTable.xegrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel"
          }, [
            topSlot ? h("div", {
              class: "vxe-table-export--panel-top"
            }, $xeTable.callSlot(topSlot, params)) : createCommentVNode(),
            h("div", {
              class: "vxe-table-export--panel-body"
            }, defaultSlot ? $xeTable.callSlot(defaultSlot, params) : [
              h("table", {
                class: "vxe-table-export--panel-table",
                cellspacing: 0,
                cellpadding: 0,
                border: 0
              }, [
                h("tbody", [
                  [
                    isPrint ? createCommentVNode() : h("tr", [
                      h("td", getI18n9("vxe.export.expName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputFilename,
                          modelValue: defaultOptions.filename,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n9("vxe.export.expNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.filename = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    isPrint ? createCommentVNode() : h("tr", [
                      h("td", getI18n9("vxe.export.expType")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.type,
                          options: storeData2.typeList,
                          "onUpdate:modelValue"(value) {
                            defaultOptions.type = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    isPrint || showSheet ? h("tr", [
                      h("td", getI18n9("vxe.export.expSheetName")),
                      h("td", [
                        VxeUIInputComponent ? h(VxeUIInputComponent, {
                          ref: xInputSheetname,
                          modelValue: defaultOptions.sheetName,
                          type: "text",
                          clearable: true,
                          placeholder: getI18n9("vxe.export.expSheetNamePlaceholder"),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.sheetName = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]) : createCommentVNode(),
                    h("tr", [
                      h("td", getI18n9("vxe.export.expMode")),
                      h("td", [
                        VxeUISelectComponent ? h(VxeUISelectComponent, {
                          modelValue: defaultOptions.mode,
                          options: storeData2.modeList.map((item) => {
                            return {
                              value: item.value,
                              label: getI18n9(item.label)
                            };
                          }),
                          "onUpdate:modelValue"(value) {
                            defaultOptions.mode = value;
                          }
                        }) : createCommentVNode()
                      ])
                    ]),
                    h("tr", [
                      h("td", [getI18n9("vxe.export.expColumn")]),
                      h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-column"
                        }, [
                          h("ul", {
                            class: "vxe-table-export--panel-column-header"
                          }, [
                            h("li", {
                              class: ["vxe-table-export--panel-column-option", {
                                "is--checked": isAllChecked,
                                "is--indeterminate": isAllIndeterminate
                              }],
                              title: getI18n9("vxe.table.allTitle"),
                              onClick: allColumnEvent
                            }, [
                              h("span", {
                                class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon7().TABLE_CHECKBOX_INDETERMINATE : isAllChecked ? getIcon7().TABLE_CHECKBOX_CHECKED : getIcon7().TABLE_CHECKBOX_UNCHECKED]
                              }),
                              h("span", {
                                class: "vxe-checkbox--label"
                              }, getI18n9("vxe.export.expCurrentColumn"))
                            ])
                          ]),
                          h("ul", {
                            class: "vxe-table-export--panel-column-body"
                          }, cols)
                        ])
                      ])
                    ]),
                    h("tr", [
                      h("td", getI18n9("vxe.export.expOpts")),
                      parameterSlot ? h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, $xeTable.callSlot(parameterSlot, params))
                      ]) : h("td", [
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.isHeader,
                            title: getI18n9("vxe.export.expHeaderTitle"),
                            content: getI18n9("vxe.export.expOptHeader"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isHeader = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.isFooter,
                            disabled: !storeData2.hasFooter,
                            title: getI18n9("vxe.export.expFooterTitle"),
                            content: getI18n9("vxe.export.expOptFooter"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isFooter = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: defaultOptions.original,
                            title: getI18n9("vxe.export.expOriginalTitle"),
                            content: getI18n9("vxe.export.expOptOriginal"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.original = value;
                            }
                          }) : createCommentVNode()
                        ]),
                        h("div", {
                          class: "vxe-table-export--panel-option-row"
                        }, [
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: isHeader && hasColgroup && supportMerge ? defaultOptions.isColgroup : false,
                            title: getI18n9("vxe.export.expColgroupTitle"),
                            disabled: !isHeader || !hasColgroup || !supportMerge,
                            content: getI18n9("vxe.export.expOptColgroup"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isColgroup = value;
                            }
                          }) : createCommentVNode(),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasMerge && supportMerge && checkedAll ? defaultOptions.isMerge : false,
                            title: getI18n9("vxe.export.expMergeTitle"),
                            disabled: !hasMerge || !supportMerge || !checkedAll,
                            content: getI18n9("vxe.export.expOptMerge"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isMerge = value;
                            }
                          }) : createCommentVNode(),
                          isPrint || !VxeUICheckboxComponent ? createCommentVNode() : h(VxeUICheckboxComponent, {
                            modelValue: supportStyle ? defaultOptions.useStyle : false,
                            disabled: !supportStyle,
                            title: getI18n9("vxe.export.expUseStyleTitle"),
                            content: getI18n9("vxe.export.expOptUseStyle"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.useStyle = value;
                            }
                          }),
                          VxeUICheckboxComponent ? h(VxeUICheckboxComponent, {
                            modelValue: hasTree ? defaultOptions.isAllExpand : false,
                            disabled: !hasTree,
                            title: getI18n9("vxe.export.expAllExpandTitle"),
                            content: getI18n9("vxe.export.expOptAllExpand"),
                            "onUpdate:modelValue"(value) {
                              defaultOptions.isAllExpand = value;
                            }
                          }) : createCommentVNode()
                        ])
                      ])
                    ])
                  ]
                ])
              ])
            ]),
            bottomSlot ? h("div", {
              class: "vxe-table-export--panel-bottom"
            }, $xeTable.callSlot(bottomSlot, params)) : createCommentVNode()
          ]);
        },
        footer() {
          const params = {
            $table: $xeTable,
            $grid: $xeTable.xegrid,
            options: defaultOptions,
            columns,
            params: defaultOptions.params
          };
          return h("div", {
            class: "vxe-table-export--panel-footer"
          }, footerSlot ? $xeTable.callSlot(footerSlot, params) : [
            h("div", {
              class: "vxe-table-export--panel-btns"
            }, [
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                content: getI18n9("vxe.export.expCancel"),
                onClick: cancelEvent
              }) : createCommentVNode(),
              VxeUIButtonComponent ? h(VxeUIButtonComponent, {
                ref: xButtonConfirm,
                status: "primary",
                content: getI18n9(isPrint ? "vxe.export.expPrint" : "vxe.export.expConfirm"),
                onClick: confirmEvent
              }) : createCommentVNode()
            ])
          ]);
        }
      }) : createCommentVNode();
    };
    if (true) {
      nextTick(() => {
        if (!VxeUIModalComponent) {
          errLog("vxe.error.reqComp", ["vxe-modal"]);
        }
        if (!VxeUIButtonComponent) {
          errLog("vxe.error.reqComp", ["vxe-button"]);
        }
        if (!VxeUISelectComponent) {
          errLog("vxe.error.reqComp", ["vxe-select"]);
        }
        if (!VxeUIInputComponent) {
          errLog("vxe.error.reqComp", ["vxe-input"]);
        }
        if (!VxeUICheckboxComponent) {
          errLog("vxe.error.reqComp", ["vxe-checkbox"]);
        }
      });
    }
    return renderVN;
  }
});

// node_modules/vxe-table/es/table/module/menu/panel.js
var import_xe_utils26 = __toESM(require_xe_utils());
var { getIcon: getIcon8 } = VxeUI;
var panel_default3 = defineComponent({
  name: "VxeTableMenuPanel",
  setup(props, context) {
    const xID = import_xe_utils26.default.uniqueId();
    const $xeTable = inject("$xeTable", {});
    const { reactData: tableReactData } = $xeTable;
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeMenuPanel = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    const renderVN = () => {
      const { ctxMenuStore } = tableReactData;
      const { computeMenuOpts } = $xeTable.getComputeMaps();
      const menuOpts = computeMenuOpts.value;
      return h(Teleport, {
        to: "body",
        disabled: false
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-table--context-menu-wrapper", menuOpts.className, {
            "is--visible": ctxMenuStore.visible
          }],
          style: ctxMenuStore.style
        }, ctxMenuStore.list.map((options, gIndex) => {
          return options.every((item) => item.visible === false) ? createCommentVNode() : h("ul", {
            class: "vxe-context-menu--option-wrapper",
            key: gIndex
          }, options.map((item, index2) => {
            const hasChildMenus = item.children && item.children.some((child) => child.visible !== false);
            const prefixOpts = Object.assign({}, item.prefixConfig);
            const suffixOpts = Object.assign({}, item.suffixConfig);
            return item.visible === false ? null : h("li", {
              class: [item.className, {
                "link--disabled": item.disabled,
                "link--active": item === ctxMenuStore.selected
              }],
              key: `${gIndex}_${index2}`
            }, [
              h("a", {
                class: "vxe-context-menu--link",
                onClick(evnt) {
                  $xeTable.ctxMenuLinkEvent(evnt, item);
                },
                onMouseover(evnt) {
                  $xeTable.ctxMenuMouseoverEvent(evnt, item);
                },
                onMouseout(evnt) {
                  $xeTable.ctxMenuMouseoutEvent(evnt, item);
                }
              }, [
                h("div", {
                  class: ["vxe-context-menu--link-prefix", prefixOpts.className || ""]
                }, [
                  h("i", {
                    class: prefixOpts.icon || item.prefixIcon
                  }),
                  prefixOpts.content ? h("span", {}, `${prefixOpts.content}`) : createCommentVNode()
                ]),
                h("div", {
                  class: "vxe-context-menu--link-content"
                }, getFuncText(item.name)),
                h("div", {
                  class: ["vxe-context-menu--link-suffix", suffixOpts.className || ""]
                }, [
                  h("i", {
                    class: suffixOpts.icon || item.suffixIcon || (hasChildMenus ? getIcon8().TABLE_MENU_OPTIONS : "")
                  }),
                  suffixOpts.content ? h("span", `${suffixOpts.content}`) : createCommentVNode()
                ])
              ]),
              hasChildMenus ? h("ul", {
                class: ["vxe-table--context-menu-clild-wrapper", {
                  "is--show": item === ctxMenuStore.selected && ctxMenuStore.showChild
                }]
              }, item.children.map((child, cIndex) => {
                const childPrefixOpts = Object.assign({}, child.prefixConfig);
                const childSuffixOpts = Object.assign({}, child.suffixConfig);
                return child.visible === false ? null : h("li", {
                  class: [child.className, {
                    "link--disabled": child.disabled,
                    "link--active": child === ctxMenuStore.selectChild
                  }],
                  key: `${gIndex}_${index2}_${cIndex}`
                }, [
                  h("a", {
                    class: "vxe-context-menu--link",
                    onClick(evnt) {
                      $xeTable.ctxMenuLinkEvent(evnt, child);
                    },
                    onMouseover(evnt) {
                      $xeTable.ctxMenuMouseoverEvent(evnt, item, child);
                    },
                    onMouseout(evnt) {
                      $xeTable.ctxMenuMouseoutEvent(evnt, item);
                    }
                  }, [
                    h("div", {
                      class: ["vxe-context-menu--link-prefix", childPrefixOpts.className || ""]
                    }, [
                      h("i", {
                        class: childPrefixOpts.icon || child.prefixIcon
                      }),
                      childPrefixOpts.content ? h("span", `${childPrefixOpts.content}`) : createCommentVNode()
                    ]),
                    h("div", {
                      class: "vxe-context-menu--link-content"
                    }, getFuncText(child.name)),
                    h("div", {
                      class: ["vxe-context-menu--link-suffix", childSuffixOpts.className || ""]
                    }, [
                      h("i", {
                        class: childSuffixOpts.icon
                      }),
                      childSuffixOpts.content ? h("span", `${childSuffixOpts.content}`) : createCommentVNode()
                    ])
                  ])
                ]);
              })) : null
            ]);
          }));
        }))
      ]);
    };
    $xeMenuPanel.renderVN = renderVN;
    return $xeMenuPanel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/table/src/table.js
var { getConfig: getConfig4, getIcon: getIcon9, getI18n: getI18n10, renderer: renderer8, formats: formats5, createEvent: createEvent2, globalResize: globalResize3, interceptor: interceptor3, hooks: hooks3, globalEvents: globalEvents3, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS2, useFns: useFns2, renderEmptyElement: renderEmptyElement5 } = VxeUI;
var customStorageKey = "VXE_CUSTOM_STORE";
var table_default = defineComponent({
  name: "VxeTable",
  props: props_default,
  emits: emits_default,
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils27.default.uniqueId();
    const VxeUILoadingComponent = VxeUI.getComponent("VxeLoading");
    const VxeUITooltipComponent = VxeUI.getComponent("VxeTooltip");
    const $xeTabs = inject("$xeTabs", null);
    const { computeSize } = useFns2.useSize(props);
    const reactData = reactive({
      isCalcColumn: false,
      // 低性能的静态列
      staticColumns: [],
      // 渲染的列分组
      tableGroupColumn: [],
      // 可视区渲染的列
      tableColumn: [],
      // 渲染中的数据
      tableData: [],
      // 是否启用了横向 X 可视渲染方式加载
      scrollXLoad: false,
      // 是否启用了纵向 Y 可视渲染方式加载
      scrollYLoad: false,
      // 是否存在纵向滚动条
      overflowY: true,
      // 是否存在横向滚动条
      overflowX: false,
      // 纵向滚动条的宽度
      scrollbarWidth: 0,
      // 横向滚动条的高度
      scrollbarHeight: 0,
      // 最后滚动时间戳
      lastScrollTime: 0,
      // 行高
      rowHeight: 0,
      // 表格父容器的高度
      parentHeight: 0,
      // 是否使用分组表头
      isGroup: false,
      isAllOverflow: false,
      // 复选框属性，是否全选
      isAllSelected: false,
      // 复选框属性，有选中且非全选状态
      isIndeterminate: false,
      // 复选框属性，已选中的行集合
      selectCheckboxMaps: {},
      // 当前行
      currentRow: null,
      // 单选框属性，选中列
      currentColumn: null,
      // 单选框属性，选中行
      selectRadioRow: null,
      // 表尾合计数据
      footerTableData: [],
      // 展开列信息
      expandColumn: null,
      // 树节点列信息
      treeNodeColumn: null,
      hasFixedColumn: false,
      // 已展开的行集合
      rowExpandedMaps: {},
      // 懒加载中的展开行的集合
      rowExpandLazyLoadedMaps: {},
      // 已展开树节点集合
      treeExpandedMaps: {},
      // 懒加载中的树节点的集合
      treeExpandLazyLoadedMaps: {},
      // 树节点不确定状态的集合
      treeIndeterminateMaps: {},
      // 合并单元格的对象集
      mergeList: [],
      // 合并表尾数据的对象集
      mergeFooterList: [],
      // 刷新列标识，当列筛选被改变时，触发表格刷新数据
      upDataFlag: 0,
      // 刷新列标识，当列的特定属性被改变时，触发表格刷新列
      reColumnFlag: 0,
      // 已标记的对象集
      pendingRowMaps: {},
      // 初始化标识
      initStore: {
        filter: false,
        import: false,
        export: false,
        custom: false
      },
      // 自定义列相关的信息
      customStore: {
        btnEl: null,
        isAll: false,
        isIndeterminate: false,
        activeBtn: false,
        activeWrapper: false,
        visible: false,
        maxHeight: 0,
        oldSortMaps: {},
        oldFixedMaps: {},
        oldVisibleMaps: {}
      },
      customColumnList: [],
      // 当前选中的筛选列
      filterStore: {
        isAllSelected: false,
        isIndeterminate: false,
        style: null,
        options: [],
        column: null,
        multiple: false,
        visible: false,
        maxHeight: null
      },
      // 存放列相关的信息
      columnStore: {
        leftList: [],
        centerList: [],
        rightList: [],
        resizeList: [],
        pxList: [],
        pxMinList: [],
        autoMinList: [],
        scaleList: [],
        scaleMinList: [],
        autoList: [],
        remainList: []
      },
      // 存放快捷菜单的信息
      ctxMenuStore: {
        selected: null,
        visible: false,
        showChild: false,
        selectChild: null,
        list: [],
        style: null
      },
      // 存放可编辑相关信息
      editStore: {
        indexs: {
          columns: []
        },
        titles: {
          columns: []
        },
        // 选中源
        selected: {
          row: null,
          column: null
        },
        // 已复制源
        copyed: {
          cut: false,
          rows: [],
          columns: []
        },
        // 激活
        actived: {
          row: null,
          column: null
        },
        // 当前被强制聚焦单元格，只会在鼠标点击后算聚焦
        focused: {
          row: null,
          column: null
        },
        insertMaps: {},
        removeMaps: {}
      },
      // 存放 tooltip 相关信息
      tooltipStore: {
        row: null,
        column: null,
        content: null,
        visible: false,
        currOpts: {}
      },
      // 存放数据校验相关信息
      validStore: {
        visible: false
      },
      validErrorMaps: {},
      // 导入相关信息
      importStore: {
        inited: false,
        file: null,
        type: "",
        modeList: [],
        typeList: [],
        filename: "",
        visible: false
      },
      importParams: {
        mode: "",
        types: null,
        message: true
      },
      // 导出相关信息
      exportStore: {
        inited: false,
        name: "",
        modeList: [],
        typeList: [],
        columns: [],
        isPrint: false,
        hasFooter: false,
        hasMerge: false,
        hasTree: false,
        hasColgroup: false,
        visible: false
      },
      exportParams: {
        filename: "",
        sheetName: "",
        mode: "",
        type: "",
        isColgroup: false,
        isMerge: false,
        isAllExpand: false,
        useStyle: false,
        original: false,
        message: true,
        isHeader: false,
        isFooter: false
      },
      scrollVMLoading: false,
      isCustomStatus: false,
      isDragRowMove: false,
      dragRow: null,
      isDragColMove: false,
      dragCol: null,
      dragTipText: "",
      _isResize: false,
      _isLoading: false
    });
    const internalData = {
      tZindex: 0,
      elemStore: {},
      // 存放横向 X 虚拟滚动相关的信息
      scrollXStore: {
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 存放纵向 Y 虚拟滚动相关信息
      scrollYStore: {
        rowHeight: 0,
        offsetSize: 0,
        visibleSize: 0,
        startIndex: 0,
        endIndex: 0
      },
      // 表格宽度
      tableWidth: 0,
      // 表格高度
      tableHeight: 0,
      // 表头高度
      headerHeight: 0,
      // 表尾高度
      footerHeight: 0,
      customHeight: 0,
      customMinHeight: 0,
      customMaxHeight: 0,
      // 当前 hover 行
      hoverRow: null,
      // 最后滚动位置
      lastScrollLeft: 0,
      lastScrollTop: 0,
      // 单选框属性，已选中保留的行
      radioReserveRow: null,
      // 复选框属性，已选中保留的行集合
      checkboxReserveRowMap: {},
      // 行数据，已展开保留的行集合
      rowExpandedReserveRowMap: {},
      // 树结构数据，已展开保留的行集合
      treeExpandedReserveRowMap: {},
      // 树结构数据，不确定状态的集合
      treeIndeterminateRowMaps: {},
      // 列表完整数据、条件处理后
      tableFullData: [],
      afterFullData: [],
      afterTreeFullData: [],
      // 列表条件处理后数据集合
      afterFullRowMaps: {},
      // 树结构完整数据、条件处理后
      tableFullTreeData: [],
      tableSynchData: [],
      tableSourceData: [],
      // 收集的列配置（带分组）
      collectColumn: [],
      // 完整所有列（不带分组）
      tableFullColumn: [],
      // 渲染所有列
      visibleColumn: [],
      // 总的缓存数据集
      fullAllDataRowIdData: {},
      // 渲染中缓存数据
      sourceDataRowIdData: {},
      fullDataRowIdData: {},
      fullColumnIdData: {},
      fullColumnFieldData: {},
      // 列选取状态
      columnStatusMaps: {},
      // 行选取状态
      rowStatusMaps: {},
      // prevDragRow: null,
      inited: false,
      tooltipTimeout: null,
      initStatus: false,
      isActivated: false
    };
    let tableMethods = {};
    let tablePrivateMethods = {};
    const refElem = ref();
    const refTooltip = ref();
    const refCommTooltip = ref();
    const refValidTooltip = ref();
    const refTableMenu = ref();
    const refTableFilter = ref();
    const refTableCustom = ref();
    const refTableHeader = ref();
    const refTableBody = ref();
    const refTableFooter = ref();
    const refTableLeftHeader = ref();
    const refTableLeftBody = ref();
    const refTableLeftFooter = ref();
    const refTableRightHeader = ref();
    const refTableRightBody = ref();
    const refTableRightFooter = ref();
    const refLeftContainer = ref();
    const refRightContainer = ref();
    const refCellResizeBar = ref();
    const refCellResizeTip = ref();
    const refEmptyPlaceholder = ref();
    const refDragTipElem = ref();
    const refDragRowLineElem = ref();
    const refDragColLineElem = ref();
    const refScrollXVirtualElem = ref();
    const refScrollYVirtualElem = ref();
    const refScrollXHandleElem = ref();
    const refScrollYHandleElem = ref();
    const refScrollXSpaceElem = ref();
    const refScrollYSpaceElem = ref();
    const $xeGrid = inject("$xeGrid", null);
    let $xeToolbar;
    const computeTableId = computed(() => {
      const { id: id2 } = props;
      if (id2) {
        if (import_xe_utils27.default.isFunction(id2)) {
          return `${id2({ $table: $xeTable, $grid: $xeGrid }) || ""}`;
        }
        return `${id2}`;
      }
      return "";
    });
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig4().table.validConfig, props.validConfig);
    });
    const computeSXOpts = computed(() => {
      return Object.assign({}, getConfig4().table.scrollX, props.scrollX);
    });
    const computeScrollXThreshold = computed(() => {
      const sXOpts = computeSXOpts.value;
      const { threshold } = sXOpts;
      if (threshold) {
        return import_xe_utils27.default.toNumber(threshold);
      }
      return 0;
    });
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig4().table.scrollY, props.scrollY);
    });
    const computeScrollYThreshold = computed(() => {
      const sYOpts = computeSYOpts.value;
      const { threshold } = sYOpts;
      if (threshold) {
        return import_xe_utils27.default.toNumber(threshold);
      }
      return 0;
    });
    const computeRowHeightMaps = computed(() => {
      return {
        default: 48,
        medium: 44,
        small: 40,
        mini: 36
      };
    });
    const computeColumnOpts = computed(() => {
      return Object.assign({}, getConfig4().table.columnConfig, props.columnConfig);
    });
    const computeCellOpts = computed(() => {
      return Object.assign({}, getConfig4().table.cellConfig, props.cellConfig);
    });
    const computeRowOpts = computed(() => {
      return Object.assign({}, getConfig4().table.rowConfig, props.rowConfig);
    });
    const computeRowDragOpts = computed(() => {
      return Object.assign({}, getConfig4().table.rowDragConfig, props.rowDragConfig);
    });
    const computeColumnDragOpts = computed(() => {
      return Object.assign({}, getConfig4().table.columnDragConfig, props.columnDragConfig);
    });
    const computeResizeOpts = computed(() => {
      return Object.assign({}, getConfig4().table.resizeConfig, props.resizeConfig);
    });
    const computeResizableOpts = computed(() => {
      return Object.assign({}, getConfig4().table.resizableConfig, props.resizableConfig);
    });
    const computeSeqOpts = computed(() => {
      return Object.assign({ startIndex: 0 }, getConfig4().table.seqConfig, props.seqConfig);
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({}, getConfig4().table.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({}, getConfig4().table.checkboxConfig, props.checkboxConfig);
    });
    let computeTooltipOpts = ref();
    computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig4().tooltip, getConfig4().table.tooltipConfig, props.tooltipConfig);
    });
    const computeTipConfig = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({}, tooltipOpts);
    });
    const computeValidTipOpts = computed(() => {
      const tooltipOpts = computeTooltipOpts.value;
      return Object.assign({ isArrow: false }, tooltipOpts);
    });
    const computeEditOpts = computed(() => {
      return Object.assign({}, getConfig4().table.editConfig, props.editConfig);
    });
    const computeSortOpts = computed(() => {
      return Object.assign({ orders: ["asc", "desc", null] }, getConfig4().table.sortConfig, props.sortConfig);
    });
    const computeFilterOpts = computed(() => {
      return Object.assign({}, getConfig4().table.filterConfig, props.filterConfig);
    });
    const computeMouseOpts = computed(() => {
      return Object.assign({}, getConfig4().table.mouseConfig, props.mouseConfig);
    });
    const computeAreaOpts = computed(() => {
      return Object.assign({}, getConfig4().table.areaConfig, props.areaConfig);
    });
    const computeKeyboardOpts = computed(() => {
      return Object.assign({}, getConfig4().table.keyboardConfig, props.keyboardConfig);
    });
    const computeClipOpts = computed(() => {
      return Object.assign({}, getConfig4().table.clipConfig, props.clipConfig);
    });
    const computeFNROpts = computed(() => {
      return Object.assign({}, getConfig4().table.fnrConfig, props.fnrConfig);
    });
    const computeMenuOpts = computed(() => {
      return Object.assign({}, getConfig4().table.menuConfig, props.menuConfig);
    });
    const computeHeaderMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerOpts = menuOpts.header;
      return headerOpts && headerOpts.options ? headerOpts.options : [];
    });
    const computeBodyMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const bodyOpts = menuOpts.body;
      return bodyOpts && bodyOpts.options ? bodyOpts.options : [];
    });
    const computeFooterMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const footerOpts = menuOpts.footer;
      return footerOpts && footerOpts.options ? footerOpts.options : [];
    });
    const computeIsMenu = computed(() => {
      const menuOpts = computeMenuOpts.value;
      const headerMenu = computeHeaderMenu.value;
      const bodyMenu = computeBodyMenu.value;
      const footerMenu = computeFooterMenu.value;
      return !!(props.menuConfig && isEnableConf(menuOpts) && (headerMenu.length || bodyMenu.length || footerMenu.length));
    });
    const computeMenuList = computed(() => {
      const { ctxMenuStore } = reactData;
      const rest = [];
      ctxMenuStore.list.forEach((list) => {
        list.forEach((item) => {
          rest.push(item);
        });
      });
      return rest;
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, getConfig4().table.exportConfig, props.exportConfig);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, getConfig4().table.importConfig, props.importConfig);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, getConfig4().table.printConfig, props.printConfig);
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig4().table.expandConfig, props.expandConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig4().table.treeConfig, props.treeConfig);
    });
    const computeEmptyOpts = computed(() => {
      return Object.assign({}, getConfig4().table.emptyRender, props.emptyRender);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig4().table.loadingConfig, props.loadingConfig);
    });
    const computeCellOffsetWidth = computed(() => {
      return props.border ? Math.max(2, Math.ceil(reactData.scrollbarWidth / reactData.tableColumn.length)) : 1;
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, getConfig4().table.customConfig, props.customConfig);
    });
    const computeAutoWidthColumnList = computed(() => {
      const { visibleColumn } = internalData;
      const { tableColumn } = reactData;
      return tableColumn.length || visibleColumn.length ? visibleColumn.filter((column) => column.width === "auto" || column.minWidth === "auto") : [];
    });
    const computeFixedColumnSize = computed(() => {
      const { tableColumn } = reactData;
      const { collectColumn } = internalData;
      let fixedSize = 0;
      if (tableColumn.length && collectColumn.length) {
        collectColumn.forEach((column) => {
          if (column.renderFixed) {
            fixedSize++;
          }
        });
      }
      return fixedSize;
    });
    const computeIsMaxFixedColumn = computed(() => {
      const fixedColumnSize = computeFixedColumnSize.value;
      const columnOpts = computeColumnOpts.value;
      const { maxFixedSize } = columnOpts;
      if (maxFixedSize) {
        return fixedColumnSize >= maxFixedSize;
      }
      return false;
    });
    const computeTableBorder = computed(() => {
      const { border } = props;
      if (border === true) {
        return "full";
      }
      if (border) {
        return border;
      }
      return "default";
    });
    const computeIsAllCheckboxDisabled = computed(() => {
      const { treeConfig } = props;
      const { tableData } = reactData;
      const { tableFullData } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      const { strict, checkMethod } = checkboxOpts;
      if (strict) {
        if (tableData.length || tableFullData.length) {
          if (checkMethod) {
            if (treeConfig) {
            }
            return tableFullData.every((row) => !checkMethod({ row }));
          }
          return false;
        }
        return true;
      }
      return false;
    });
    const computeVirtualScrollBars = computed(() => {
      const { overflowX, scrollXLoad, overflowY, scrollYLoad } = reactData;
      return {
        x: overflowX && scrollXLoad,
        y: overflowY && scrollYLoad
      };
    });
    const computeTableStyle = computed(() => {
      const { tableData } = reactData;
      const columnOpts = computeColumnOpts.value;
      const stys = {};
      if (columnOpts.drag) {
        stys["--vxe-ui-table-drag-column-move-delay"] = `${Math.max(0.06, Math.min(0.3, tableData.length / 800))}s`;
      }
      return stys;
    });
    const refMaps = {
      refElem,
      refTooltip,
      refValidTooltip,
      refTableFilter,
      refTableCustom,
      refTableMenu,
      refTableHeader,
      refTableBody,
      refTableFooter,
      refTableLeftHeader,
      refTableLeftBody,
      refTableLeftFooter,
      refTableRightHeader,
      refTableRightBody,
      refTableRightFooter,
      refLeftContainer,
      refRightContainer,
      refCellResizeBar,
      refCellResizeTip,
      refScrollXVirtualElem,
      refScrollYVirtualElem,
      refScrollXHandleElem,
      refScrollYHandleElem,
      refScrollXSpaceElem,
      refScrollYSpaceElem
    };
    const computeMaps = {
      computeSize,
      computeTableId,
      computeValidOpts,
      computeSXOpts,
      computeSYOpts,
      computeColumnOpts,
      computeCellOpts,
      computeRowOpts,
      computeRowDragOpts,
      computeColumnDragOpts,
      computeResizeOpts,
      computeResizableOpts,
      computeSeqOpts,
      computeRadioOpts,
      computeCheckboxOpts,
      computeTooltipOpts,
      computeEditOpts,
      computeSortOpts,
      computeFilterOpts,
      computeMouseOpts,
      computeAreaOpts,
      computeKeyboardOpts,
      computeClipOpts,
      computeFNROpts,
      computeHeaderMenu,
      computeBodyMenu,
      computeFooterMenu,
      computeIsMenu,
      computeMenuOpts,
      computeExportOpts,
      computeImportOpts,
      computePrintOpts,
      computeExpandOpts,
      computeTreeOpts,
      computeEmptyOpts,
      computeLoadingOpts,
      computeCustomOpts,
      computeFixedColumnSize,
      computeIsMaxFixedColumn,
      computeIsAllCheckboxDisabled,
      computeVirtualScrollBars
    };
    const $xeTable = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps,
      xegrid: $xeGrid
    };
    const eqCellValue = (row1, row2, field) => {
      const val1 = import_xe_utils27.default.get(row1, field);
      const val2 = import_xe_utils27.default.get(row2, field);
      if (eqEmptyValue(val1) && eqEmptyValue(val2)) {
        return true;
      }
      if (import_xe_utils27.default.isString(val1) || import_xe_utils27.default.isNumber(val1)) {
        return "" + val1 === "" + val2;
      }
      return import_xe_utils27.default.isEqual(val1, val2);
    };
    const getNextSortOrder = (column) => {
      const sortOpts = computeSortOpts.value;
      const { orders } = sortOpts;
      const currOrder = column.order || null;
      const oIndex = orders.indexOf(currOrder) + 1;
      return orders[oIndex < orders.length ? oIndex : 0];
    };
    const getCustomStorageMap = (id2) => {
      const version7 = getConfig4().version;
      const rest = import_xe_utils27.default.toStringJSON(localStorage.getItem(customStorageKey) || "");
      const maps = rest && rest._v === version7 ? rest : { _v: version7 };
      return (id2 ? maps[id2] : maps) || {};
    };
    const setCustomStorageMap = (id2, data) => {
      const version7 = getConfig4().version;
      const maps = getCustomStorageMap();
      maps[id2] = data || void 0;
      maps._v = version7;
      localStorage.setItem(customStorageKey, import_xe_utils27.default.toJSONString(maps));
    };
    const getRecoverRowMaps = (keyMaps) => {
      const { fullAllDataRowIdData } = internalData;
      const restKeys = {};
      import_xe_utils27.default.each(keyMaps, (row, rowid) => {
        if (fullAllDataRowIdData[rowid]) {
          restKeys[rowid] = row;
        }
      });
      return restKeys;
    };
    const handleReserveRow = (reserveRowMap) => {
      const { fullDataRowIdData } = internalData;
      const reserveList = [];
      import_xe_utils27.default.each(reserveRowMap, (item, rowid) => {
        if (fullDataRowIdData[rowid] && $xeTable.findRowIndexOf(reserveList, fullDataRowIdData[rowid].row) === -1) {
          reserveList.push(fullDataRowIdData[rowid].row);
        }
      });
      return reserveList;
    };
    const handleVirtualXVisible = () => {
      const { visibleColumn } = internalData;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      if (tableBodyElem) {
        const { scrollLeft, clientWidth } = tableBodyElem;
        const endWidth = scrollLeft + clientWidth;
        let toVisibleIndex = -1;
        let cWidth = 0;
        let visibleSize = 0;
        for (let colIndex = 0, colLen = visibleColumn.length; colIndex < colLen; colIndex++) {
          cWidth += visibleColumn[colIndex].renderWidth;
          if (toVisibleIndex === -1 && scrollLeft < cWidth) {
            toVisibleIndex = colIndex;
          }
          if (toVisibleIndex >= 0) {
            visibleSize++;
            if (cWidth > endWidth) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(6, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 6 };
    };
    const computeRowHeight = () => {
      const { showOverflow } = props;
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const vSize = computeSize.value;
      const rowHeightMaps = computeRowHeightMaps.value;
      let rowHeight = 24;
      if (showOverflow) {
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          let firstTrElem;
          firstTrElem = tableBodyElem.querySelector("tr");
          if (!firstTrElem && tableHeaderElem) {
            firstTrElem = tableHeaderElem.querySelector("tr");
          }
          if (firstTrElem) {
            rowHeight = firstTrElem.clientHeight;
          }
          if (!rowHeight) {
            rowHeight = rowHeightMaps[vSize || "default"];
          }
        }
      }
      return rowHeight;
    };
    const handleVirtualYVisible = () => {
      const { scrollYStore, afterFullData, fullAllDataRowIdData } = internalData;
      const tableBody = refTableBody.value;
      const tableBodyElem = tableBody ? tableBody.$el : null;
      const { rowHeight } = scrollYStore;
      if (tableBodyElem) {
        const { scrollTop, clientHeight } = tableBodyElem;
        const endHeight = scrollTop + clientHeight;
        let toVisibleIndex = -1;
        let offsetTop = 0;
        let visibleSize = 0;
        for (let rIndex = 0, rLen = afterFullData.length; rIndex < rLen; rIndex++) {
          const row = afterFullData[rIndex];
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (!rowRest) {
            break;
          }
          offsetTop += rowRest.height || rowHeight;
          if (toVisibleIndex === -1 && scrollTop < offsetTop) {
            toVisibleIndex = rIndex;
          }
          if (toVisibleIndex >= 0) {
            visibleSize++;
            if (offsetTop > endHeight) {
              break;
            }
          }
        }
        return { toVisibleIndex: Math.max(0, toVisibleIndex), visibleSize: Math.max(8, visibleSize) };
      }
      return { toVisibleIndex: 0, visibleSize: 8 };
    };
    const calculateMergerOffsetIndex = (list, offsetItem, type) => {
      for (let mcIndex = 0, len = list.length; mcIndex < len; mcIndex++) {
        const mergeItem = list[mcIndex];
        const { startIndex, endIndex } = offsetItem;
        const mergeStartIndex = mergeItem[type];
        const mergeSpanNumber = mergeItem[type + "span"];
        const mergeEndIndex = mergeStartIndex + mergeSpanNumber;
        if (mergeStartIndex < startIndex && startIndex < mergeEndIndex) {
          offsetItem.startIndex = mergeStartIndex;
        }
        if (mergeStartIndex < endIndex && endIndex < mergeEndIndex) {
          offsetItem.endIndex = mergeEndIndex;
        }
        if (offsetItem.startIndex !== startIndex || offsetItem.endIndex !== endIndex) {
          mcIndex = -1;
        }
      }
    };
    const setMerges = (merges, mList, rowList) => {
      if (merges) {
        const { treeConfig } = props;
        const { visibleColumn } = internalData;
        if (!import_xe_utils27.default.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach((item) => {
          let { row, col, rowspan, colspan } = item;
          if (rowList && import_xe_utils27.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils27.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          if ((rowList ? row : import_xe_utils27.default.isNumber(row)) && col && (rowspan || colspan)) {
            rowspan = import_xe_utils27.default.toNumber(rowspan) || 1;
            colspan = import_xe_utils27.default.toNumber(colspan) || 1;
            if (rowspan > 1 || colspan > 1) {
              const mcIndex = import_xe_utils27.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xeTable, item2._row) === getRowid($xeTable, row)) && (item2._col.id === col || item2._col.id === col.id));
              const mergeItem = mList[mcIndex];
              if (mergeItem) {
                mergeItem.rowspan = rowspan;
                mergeItem.colspan = colspan;
                mergeItem._rowspan = rowspan;
                mergeItem._colspan = colspan;
              } else {
                const mergeRowIndex = rowList ? $xeTable.findRowIndexOf(rowList, row) : row;
                const mergeColIndex = tableMethods.getVTColumnIndex(col);
                mList.push({
                  row: mergeRowIndex,
                  col: mergeColIndex,
                  rowspan,
                  colspan,
                  _row: row,
                  _col: col,
                  _rowspan: rowspan,
                  _colspan: colspan
                });
              }
            }
          }
        });
      }
    };
    const removeMerges = (merges, mList, rowList) => {
      const rest = [];
      if (merges) {
        const { treeConfig } = props;
        const { visibleColumn } = internalData;
        if (!import_xe_utils27.default.isArray(merges)) {
          merges = [merges];
        }
        if (treeConfig && merges.length) {
          errLog("vxe.error.noTree", ["merge-cells | merge-footer-items"]);
        }
        merges.forEach((item) => {
          let { row, col } = item;
          if (rowList && import_xe_utils27.default.isNumber(row)) {
            row = rowList[row];
          }
          if (import_xe_utils27.default.isNumber(col)) {
            col = visibleColumn[col];
          }
          const mcIndex = import_xe_utils27.default.findIndexOf(mList, (item2) => (item2._row === row || getRowid($xeTable, item2._row) === getRowid($xeTable, row)) && (item2._col.id === col || item2._col.id === col.id));
          if (mcIndex > -1) {
            const rItems = mList.splice(mcIndex, 1);
            rest.push(rItems[0]);
          }
        });
      }
      return rest;
    };
    const clearAllSort = () => {
      const { tableFullColumn } = internalData;
      tableFullColumn.forEach((column) => {
        column.order = null;
      });
    };
    const calcTableHeight = (key) => {
      const { parentHeight } = reactData;
      const val = props[key];
      let num = 0;
      if (val) {
        if (val === "100%" || val === "auto") {
          num = parentHeight;
        } else {
          const excludeHeight = $xeTable.getExcludeHeight();
          if (isScale(val)) {
            num = Math.floor((import_xe_utils27.default.toInteger(val) || 1) / 100 * parentHeight);
          } else {
            num = import_xe_utils27.default.toNumber(val);
          }
          num = Math.max(40, num - excludeHeight);
        }
      }
      return num;
    };
    const handleCustomRestore = (storeData2) => {
      let { collectColumn } = internalData;
      const { resizableData, sortData, visibleData, fixedData } = storeData2;
      let hasCustomSort = false;
      if (resizableData || sortData || visibleData || fixedData) {
        import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
          const colKey = column.getKey();
          if (!parent) {
            if (fixedData && fixedData[colKey]) {
              column.fixed = fixedData[colKey];
            }
            if (sortData && import_xe_utils27.default.isNumber(sortData[colKey])) {
              hasCustomSort = true;
              column.renderSortNumber = sortData[colKey];
            }
          }
          if (resizableData && import_xe_utils27.default.isNumber(resizableData[colKey])) {
            column.resizeWidth = resizableData[colKey];
          }
          if (visibleData && import_xe_utils27.default.isBoolean(visibleData[colKey])) {
            column.visible = visibleData[colKey];
          }
        });
        if (hasCustomSort) {
          collectColumn = import_xe_utils27.default.orderBy(collectColumn, "renderSortNumber");
          internalData.collectColumn = collectColumn;
          internalData.tableFullColumn = getColumnList(collectColumn);
        }
        reactData.isCustomStatus = true;
      } else {
        reactData.isCustomStatus = false;
      }
    };
    const restoreCustomStorage = () => {
      const { customConfig } = props;
      const tableId = computeTableId.value;
      const customOpts = computeCustomOpts.value;
      const { storage, restoreStore } = customOpts;
      const isAllCustom = storage === true;
      const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
      const isCustomResizable = isAllCustom || storageOpts.resizable;
      const isCustomVisible = isAllCustom || storageOpts.visible;
      const isCustomFixed = isAllCustom || storageOpts.fixed;
      const isCustomSort = isAllCustom || storageOpts.sort;
      if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
        if (!tableId) {
          errLog("vxe.error.reqProp", ["id"]);
          return;
        }
        const storeData2 = getCustomStorageMap(tableId);
        if (restoreStore) {
          return Promise.resolve(restoreStore({ id: tableId, type: "restore", storeData: storeData2 })).then((storeData3) => {
            if (!storeData3) {
              return;
            }
            return handleCustomRestore(storeData3);
          }).catch((e16) => e16);
        } else {
          return handleCustomRestore(storeData2);
        }
      }
    };
    const cacheColumnMap = () => {
      const { tableFullColumn, collectColumn } = internalData;
      const fullColumnIdData = internalData.fullColumnIdData = {};
      const fullColumnFieldData = internalData.fullColumnFieldData = {};
      const mouseOpts = computeMouseOpts.value;
      const columnOpts = computeColumnOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      const { isCrossDrag, isSelfToChildDrag } = columnDragOpts;
      const rowOpts = computeRowOpts.value;
      const isGroup = collectColumn.some(hasChildrenList);
      let isAllOverflow = !!props.showOverflow;
      let expandColumn;
      let treeNodeColumn;
      let checkboxColumn;
      let radioColumn;
      let htmlColumn;
      let hasFixed;
      const handleFunc = (column, index2, items, path, parent) => {
        const { id: colid, field, fixed, type, treeNode } = column;
        const rest = { $index: -1, _index: -1, column, colid, index: index2, items, parent: parent || null, width: 0 };
        if (field) {
          if (fullColumnFieldData[field]) {
            errLog("vxe.error.colRepet", ["field", field]);
          }
          fullColumnFieldData[field] = rest;
        } else {
          if (isCrossDrag || isSelfToChildDrag) {
            errLog("vxe.error.emptyProp", ["column.field"]);
          }
        }
        if (!hasFixed && fixed) {
          hasFixed = fixed;
        }
        if (!htmlColumn && type === "html") {
          htmlColumn = column;
        }
        if (treeNode) {
          if (true) {
            if (treeNodeColumn) {
              warnLog("vxe.error.colRepet", ["tree-node", treeNode]);
            }
          }
          if (!treeNodeColumn) {
            treeNodeColumn = column;
          }
        } else if (type === "expand") {
          if (true) {
            if (expandColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
          }
          if (!expandColumn) {
            expandColumn = column;
          }
        }
        if (true) {
          if (type === "checkbox") {
            if (checkboxColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!checkboxColumn) {
              checkboxColumn = column;
            }
          } else if (type === "radio") {
            if (radioColumn) {
              warnLog("vxe.error.colRepet", ["type", type]);
            }
            if (!radioColumn) {
              radioColumn = column;
            }
          }
        }
        if (isAllOverflow && column.showOverflow === false) {
          isAllOverflow = false;
        }
        if (fullColumnIdData[colid]) {
          errLog("vxe.error.colRepet", ["colId", colid]);
        }
        fullColumnIdData[colid] = rest;
      };
      if (isGroup) {
        import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent, nodes) => {
          column.level = nodes.length;
          handleFunc(column, index2, items, path, parent);
        });
      } else {
        tableFullColumn.forEach(handleFunc);
      }
      if (true) {
        if (expandColumn && mouseOpts.area) {
          errLog("vxe.error.errConflicts", ["mouse-config.area", "column.type=expand"]);
        }
      }
      if (true) {
        if (htmlColumn) {
          if (!columnOpts.useKey) {
            errLog("vxe.error.reqProp", ["column-config.useKey & column.type=html"]);
          }
          if (!rowOpts.useKey) {
            errLog("vxe.error.reqProp", ["row-config.useKey & column.type=html"]);
          }
        }
      }
      reactData.isGroup = isGroup;
      reactData.treeNodeColumn = treeNodeColumn;
      reactData.expandColumn = expandColumn;
      reactData.isAllOverflow = isAllOverflow;
    };
    const updateHeight = () => {
      internalData.customHeight = calcTableHeight("height");
      internalData.customMinHeight = calcTableHeight("minHeight");
      internalData.customMaxHeight = calcTableHeight("maxHeight");
    };
    const calcCellWidth = () => {
      const autoWidthColumnList = computeAutoWidthColumnList.value;
      reactData.isCalcColumn = true;
      return nextTick().then(() => {
        const { fullColumnIdData } = internalData;
        const el2 = refElem.value;
        if (el2) {
          autoWidthColumnList.forEach((column) => {
            const colid = column.id;
            const colRest = fullColumnIdData[colid];
            const cellElList = el2.querySelectorAll(`.vxe-header--column.${column.id}>.vxe-cell,.vxe-body--column.${column.id}>.vxe-cell,.vxe-footer--column.${column.id}>.vxe-cell`);
            const firstCellEl = cellElList[0];
            let paddingSize = 0;
            if (firstCellEl) {
              const cellStyle = getComputedStyle(firstCellEl);
              paddingSize = Math.floor(import_xe_utils27.default.toNumber(cellStyle.paddingLeft) + import_xe_utils27.default.toNumber(cellStyle.paddingRight)) + 2;
            }
            let colWidth = column.renderAutoWidth - paddingSize;
            import_xe_utils27.default.arrayEach(cellElList, (itemEl) => {
              const cellEl = itemEl;
              const thElem = cellEl.parentElement;
              let titleWidth = 0;
              if (`${thElem.tagName}`.toLowerCase() === "th") {
                import_xe_utils27.default.arrayEach(cellEl.children, (btnEl) => {
                  titleWidth += btnEl.offsetWidth + 1;
                });
              } else {
                const labelEl = cellEl.firstElementChild;
                if (labelEl) {
                  titleWidth = labelEl.offsetWidth;
                }
              }
              if (titleWidth) {
                colWidth = Math.max(colWidth, Math.ceil(titleWidth) + 4);
              }
            });
            if (colRest) {
              colRest.width = Math.max(colWidth, colRest.width);
            }
            column.renderAutoWidth = colWidth + paddingSize;
          });
          tablePrivateMethods.analyColumnWidth();
        }
        reactData.isCalcColumn = false;
      });
    };
    const autoCellWidth = () => {
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const bodyElem = tableBody ? tableBody.$el : null;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      if (!bodyElem) {
        return;
      }
      let tableWidth = 0;
      const minCellWidth = 40;
      const bodyWidth = bodyElem.clientWidth - 1;
      let remainWidth = bodyWidth;
      let meanWidth = remainWidth / 100;
      const { fit } = props;
      const { columnStore } = reactData;
      const { resizeList, pxMinList, autoMinList, pxList, scaleList, scaleMinList, autoList, remainList } = columnStore;
      pxMinList.forEach((column) => {
        const minWidth = import_xe_utils27.default.toInteger(column.minWidth);
        tableWidth += minWidth;
        column.renderWidth = minWidth;
      });
      autoMinList.forEach((column) => {
        const scaleWidth = Math.max(60, import_xe_utils27.default.toInteger(column.renderAutoWidth));
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      scaleMinList.forEach((column) => {
        const scaleWidth = Math.floor(import_xe_utils27.default.toInteger(column.minWidth) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      scaleList.forEach((column) => {
        const scaleWidth = Math.floor(import_xe_utils27.default.toInteger(column.width) * meanWidth);
        tableWidth += scaleWidth;
        column.renderWidth = scaleWidth;
      });
      pxList.forEach((column) => {
        const width = import_xe_utils27.default.toInteger(column.width);
        tableWidth += width;
        column.renderWidth = width;
      });
      autoList.forEach((column) => {
        const width = Math.max(60, import_xe_utils27.default.toInteger(column.renderAutoWidth));
        tableWidth += width;
        column.renderWidth = width;
      });
      resizeList.forEach((column) => {
        const width = import_xe_utils27.default.toInteger(column.resizeWidth);
        tableWidth += width;
        column.renderWidth = width;
      });
      remainWidth -= tableWidth;
      meanWidth = remainWidth > 0 ? Math.floor(remainWidth / (scaleMinList.length + pxMinList.length + autoMinList.length + remainList.length)) : 0;
      if (fit) {
        if (remainWidth > 0) {
          scaleMinList.concat(pxMinList).concat(autoMinList).forEach((column) => {
            tableWidth += meanWidth;
            column.renderWidth += meanWidth;
          });
        }
      } else {
        meanWidth = minCellWidth;
      }
      remainList.forEach((column) => {
        const width = Math.max(meanWidth, minCellWidth);
        column.renderWidth = width;
        tableWidth += width;
      });
      if (fit) {
        const dynamicList = scaleList.concat(scaleMinList).concat(pxMinList).concat(autoMinList).concat(remainList);
        let dynamicSize = dynamicList.length - 1;
        if (dynamicSize > 0) {
          let odiffer = bodyWidth - tableWidth;
          if (odiffer > 0) {
            while (odiffer > 0 && dynamicSize >= 0) {
              odiffer--;
              dynamicList[dynamicSize--].renderWidth++;
            }
            tableWidth = bodyWidth;
          }
        }
      }
      const tableHeight = bodyElem.offsetHeight;
      const overflowY = bodyElem.scrollHeight > bodyElem.clientHeight;
      let scrollbarWidth = 0;
      if (overflowY) {
        scrollbarWidth = Math.max(bodyElem.offsetWidth - bodyElem.clientWidth, 0);
      }
      reactData.scrollbarWidth = scrollbarWidth;
      reactData.overflowY = overflowY;
      internalData.tableWidth = tableWidth;
      internalData.tableHeight = tableHeight;
      let headerHeight = 0;
      if (headerElem) {
        headerHeight = headerElem.clientHeight;
        nextTick(() => {
          if (headerElem && bodyElem && headerElem.scrollLeft !== bodyElem.scrollLeft) {
            headerElem.scrollLeft = bodyElem.scrollLeft;
          }
        });
      }
      internalData.headerHeight = headerHeight;
      let overflowX = false;
      let footerHeight = 0;
      let scrollbarHeight = 0;
      if (footerElem) {
        footerHeight = footerElem.offsetHeight;
        overflowX = tableWidth > footerElem.clientWidth;
        scrollbarHeight = Math.max(footerHeight - footerElem.clientHeight, 0);
      } else {
        overflowX = tableWidth > bodyWidth;
        scrollbarHeight = Math.max(tableHeight - bodyElem.clientHeight, 0);
      }
      internalData.footerHeight = footerHeight;
      reactData.overflowX = overflowX;
      reactData.scrollbarHeight = scrollbarHeight;
      updateHeight();
      reactData.parentHeight = Math.max(internalData.headerHeight + footerHeight + 20, tablePrivateMethods.getParentHeight());
      if (overflowX) {
        tablePrivateMethods.checkScrolling();
      }
    };
    const calcCellHeight = () => {
      const { showOverflow } = props;
      const { tableData, scrollXLoad, scrollYLoad } = reactData;
      const { fullAllDataRowIdData } = internalData;
      const el2 = refElem.value;
      if (!showOverflow && (scrollXLoad || scrollYLoad) && el2) {
        let paddingTop = 0;
        let paddingBottom = 0;
        let calcPadding = false;
        tableData.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          const trList = el2.querySelectorAll(`.vxe-body--row[rowid="${rowid}"]`);
          if (rowRest && trList.length) {
            let height = 0;
            for (let i = 0; i < trList.length; i++) {
              const trEl = trList[i];
              const tdList = trEl.children;
              for (let j = 0; j < tdList.length; j++) {
                const tdEl = tdList[j];
                const cellElem = tdEl.querySelector(".vxe-cell");
                if (!calcPadding) {
                  paddingTop = import_xe_utils27.default.toNumber(getComputedStyle(tdEl).paddingTop);
                  paddingBottom = import_xe_utils27.default.toNumber(getComputedStyle(tdEl).paddingBottom);
                  calcPadding = true;
                }
                let cellHeight = paddingTop + paddingBottom;
                if (cellElem) {
                  cellHeight += cellElem.offsetHeight;
                }
                height = Math.max(height, cellHeight);
              }
            }
            rowRest.height = scrollXLoad ? Math.max(rowRest.height, height) : height;
          }
        });
      }
    };
    const getOrderField = (column) => {
      const { sortBy, sortType } = column;
      return (row) => {
        let cellValue;
        if (sortBy) {
          cellValue = import_xe_utils27.default.isFunction(sortBy) ? sortBy({ row, column }) : import_xe_utils27.default.get(row, sortBy);
        } else {
          cellValue = tableMethods.getCellLabel(row, column);
        }
        if (!sortType || sortType === "auto") {
          return isNaN(cellValue) ? cellValue : import_xe_utils27.default.toNumber(cellValue);
        } else if (sortType === "number") {
          return import_xe_utils27.default.toNumber(cellValue);
        } else if (sortType === "string") {
          return import_xe_utils27.default.toValueString(cellValue);
        }
        return cellValue;
      };
    };
    const updateTreeDataIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeConfig) {
        if (treeOpts.transform) {
          afterFullData.forEach((row, index2) => {
            const rowid = getRowid($xeTable, row);
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = index2;
            } else {
              const rest = { row, rowid, seq: "-1", index: -1, $index: -1, _index: index2, items: [], parent: null, level: 0, height: 0 };
              fullAllDataRowIdData[rowid] = rest;
              fullDataRowIdData[rowid] = rest;
            }
          });
        }
      }
    };
    const updateAfterDataIndex = () => {
      const { treeConfig } = props;
      const { afterFullData, fullDataRowIdData, fullAllDataRowIdData, afterTreeFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const fullMaps = {};
      if (treeConfig) {
        import_xe_utils27.default.eachTree(afterTreeFullData, (row, index2, items, path) => {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          const seq = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
          if (rowRest) {
            rowRest.seq = seq;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: -1, items: [], parent: null, level: 0, height: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        }, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        updateTreeDataIndex();
      } else {
        afterFullData.forEach((row, index2) => {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          const seq = index2 + 1;
          if (rowRest) {
            rowRest.seq = seq;
            rowRest._index = index2;
          } else {
            const rest = { row, rowid, seq, index: -1, $index: -1, _index: index2, items: [], parent: null, level: 0, height: 0 };
            fullAllDataRowIdData[rowid] = rest;
            fullDataRowIdData[rowid] = rest;
          }
          fullMaps[rowid] = row;
        });
      }
      internalData.afterFullRowMaps = fullMaps;
    };
    const handleVirtualTreeToList = () => {
      const { treeConfig } = props;
      const { treeExpandedMaps } = reactData;
      const { fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (treeConfig && treeOpts.transform) {
        const fullData = [];
        const expandMaps = {};
        import_xe_utils27.default.eachTree(internalData.afterTreeFullData, (row, index2, items, path, parent) => {
          const rowid = getRowid($xeTable, row);
          const parentRowid = getRowid($xeTable, parent);
          if (!parent || expandMaps[parentRowid] && treeExpandedMaps[parentRowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              rowRest._index = fullData.length;
            }
            expandMaps[rowid] = 1;
            fullData.push(row);
          }
        }, { children: childrenField });
        internalData.afterFullData = fullData;
        updateScrollYStatus(fullData);
        return fullData;
      }
      return internalData.afterFullData;
    };
    const updateAfterFullData = () => {
      const { treeConfig } = props;
      const { tableFullColumn, tableFullData, tableFullTreeData } = internalData;
      const filterOpts = computeFilterOpts.value;
      const sortOpts = computeSortOpts.value;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const { transform: transform2 } = treeOpts;
      const { remote: allRemoteFilter, filterMethod: allFilterMethod } = filterOpts;
      const { remote: allRemoteSort, sortMethod: allSortMethod, multiple: sortMultiple, chronological } = sortOpts;
      let tableData = [];
      let tableTree = [];
      if (!allRemoteFilter || !allRemoteSort) {
        const filterColumns = [];
        let orderColumns = [];
        tableFullColumn.forEach((column) => {
          const { field, sortable, order, filters } = column;
          if (!allRemoteFilter && filters && filters.length) {
            const valueList = [];
            const itemList = [];
            filters.forEach((item) => {
              if (item.checked) {
                itemList.push(item);
                valueList.push(item.value);
              }
            });
            if (itemList.length) {
              filterColumns.push({ column, valueList, itemList });
            }
          }
          if (!allRemoteSort && sortable && order) {
            orderColumns.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (sortMultiple && chronological && orderColumns.length > 1) {
          orderColumns = import_xe_utils27.default.orderBy(orderColumns, "sortTime");
        }
        if (!allRemoteFilter && filterColumns.length) {
          const handleFilter = (row) => {
            return filterColumns.every(({ column, valueList, itemList }) => {
              const { filterMethod, filterRender } = column;
              const compConf = isEnableConf(filterRender) ? renderer8.get(filterRender.name) : null;
              const compFilterMethod = compConf ? compConf.tableFilterMethod || compConf.filterMethod : null;
              const tdFilterMethod = compConf ? compConf.tableFilterDefaultMethod || compConf.defaultTableFilterMethod || compConf.defaultFilterMethod : null;
              const cellValue = getCellValue(row, column);
              if (filterMethod) {
                return itemList.some((item) => filterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (compFilterMethod) {
                return itemList.some((item) => compFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              } else if (allFilterMethod) {
                return allFilterMethod({ options: itemList, values: valueList, cellValue, row, column });
              } else if (tdFilterMethod) {
                return itemList.some((item) => tdFilterMethod({ value: item.value, option: item, cellValue, row, column, $table: $xeTable }));
              }
              return valueList.indexOf(import_xe_utils27.default.get(row, column.field)) > -1;
            });
          };
          if (treeConfig && transform2) {
            tableTree = import_xe_utils27.default.searchTree(tableFullTreeData, handleFilter, {
              original: true,
              isEvery: true,
              children: treeOpts.mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.filter(handleFilter) : tableFullData.filter(handleFilter);
            tableTree = tableData;
          }
        } else {
          if (treeConfig && transform2) {
            tableTree = import_xe_utils27.default.searchTree(tableFullTreeData, () => true, {
              original: true,
              isEvery: true,
              children: treeOpts.mapChildrenField,
              mapChildren: childrenField
            });
            tableData = tableTree;
          } else {
            tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
            tableTree = tableData;
          }
        }
        if (!allRemoteSort && orderColumns.length) {
          if (treeConfig && transform2) {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableTree, sortList: orderColumns, $table: $xeTable });
              tableTree = import_xe_utils27.default.isArray(sortRests) ? sortRests : tableTree;
            } else {
              tableTree = import_xe_utils27.default.orderBy(tableTree, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableData = tableTree;
          } else {
            if (allSortMethod) {
              const sortRests = allSortMethod({ data: tableData, sortList: orderColumns, $table: $xeTable });
              tableData = import_xe_utils27.default.isArray(sortRests) ? sortRests : tableData;
            } else {
              tableData = import_xe_utils27.default.orderBy(tableData, orderColumns.map(({ column, order }) => [getOrderField(column), order]));
            }
            tableTree = tableData;
          }
        }
      } else {
        if (treeConfig && transform2) {
          tableTree = import_xe_utils27.default.searchTree(tableFullTreeData, () => true, {
            original: true,
            isEvery: true,
            children: treeOpts.mapChildrenField,
            mapChildren: childrenField
          });
          tableData = tableTree;
        } else {
          tableData = treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0);
          tableTree = tableData;
        }
      }
      internalData.afterFullData = tableData;
      internalData.afterTreeFullData = tableTree;
      updateAfterDataIndex();
    };
    const updateStyle = () => {
      const { border, showFooter, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow, showFooterOverflow: allColumnFooterOverflow, mouseConfig, spanMethod, footerSpanMethod, keyboardConfig } = props;
      const { isGroup, currentRow, tableColumn, scrollXLoad, scrollYLoad, overflowX, scrollbarWidth, scrollbarHeight, columnStore, editStore, mergeList, mergeFooterList, isAllOverflow } = reactData;
      let { visibleColumn, fullColumnIdData, tableHeight, tableWidth, headerHeight, footerHeight, elemStore, customHeight, customMinHeight, customMaxHeight } = internalData;
      const containerList = ["main", "left", "right"];
      const emptyPlaceholderElem = refEmptyPlaceholder.value;
      const cellOffsetWidth = computeCellOffsetWidth.value;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const bodyWrapperElem = getRefElem(elemStore["main-body-wrapper"]);
      if (emptyPlaceholderElem) {
        emptyPlaceholderElem.style.top = `${headerHeight}px`;
        emptyPlaceholderElem.style.height = bodyWrapperElem ? `${bodyWrapperElem.offsetHeight - scrollbarHeight}px` : "";
      }
      if (customHeight > 0) {
        if (showFooter) {
          customHeight += scrollbarHeight;
        }
      }
      const scrollXVirtualEl = refScrollXVirtualElem.value;
      if (scrollXVirtualEl) {
        scrollXVirtualEl.style.height = `${scrollbarHeight}px`;
      }
      const scrollYVirtualEl = refScrollYVirtualElem.value;
      if (scrollYVirtualEl) {
        let bodyHeight = 0;
        let bodyMaxHeight = 0;
        const bodyMinHeight = customMinHeight - headerHeight - footerHeight;
        if (customMaxHeight) {
          bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;
          bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);
        }
        if (customHeight) {
          bodyHeight = customHeight - headerHeight - footerHeight;
          if (bodyMaxHeight) {
            bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
          }
          bodyHeight = Math.max(bodyMinHeight, bodyHeight);
        }
        scrollYVirtualEl.style.top = `${headerHeight}px`;
        scrollYVirtualEl.style.width = `${scrollbarWidth}px`;
        scrollYVirtualEl.style.height = `${bodyHeight + (overflowX ? -Math.max(1, scrollbarHeight) : 0)}px`;
      }
      containerList.forEach((name, index2) => {
        const fixedType = index2 > 0 ? name : "";
        const layoutList = ["header", "body", "footer"];
        const isFixedLeft = fixedType === "left";
        let fixedColumn = [];
        let fixedWrapperElem;
        if (fixedType) {
          fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
          fixedWrapperElem = isFixedLeft ? refLeftContainer.value : refRightContainer.value;
        }
        layoutList.forEach((layout) => {
          const wrapperElem = getRefElem(elemStore[`${name}-${layout}-wrapper`]);
          const tableElem = getRefElem(elemStore[`${name}-${layout}-table`]);
          if (layout === "header") {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (isGroup) {
              renderColumnList = visibleColumn;
            } else {
              if (fixedType) {
                if (scrollXLoad || allColumnHeaderOverflow) {
                  renderColumnList = fixedColumn;
                }
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : "";
            }
            const repairElem = getRefElem(elemStore[`${name}-${layout}-repair`]);
            if (repairElem) {
              repairElem.style.width = `${tableWidth}px`;
            }
            const listElem = getRefElem(elemStore[`${name}-${layout}-list`]);
            if (isGroup && listElem) {
              import_xe_utils27.default.arrayEach(listElem.querySelectorAll(".col--group"), (thElem) => {
                const colNode = tableMethods.getColumnNode(thElem);
                if (colNode) {
                  const column = colNode.item;
                  const { showHeaderOverflow } = column;
                  const cellOverflow = import_xe_utils27.default.isBoolean(showHeaderOverflow) ? showHeaderOverflow : allColumnHeaderOverflow;
                  const showEllipsis = cellOverflow === "ellipsis";
                  const showTitle = cellOverflow === "title";
                  const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
                  const hasEllipsis = showTitle || showTooltip || showEllipsis;
                  let childWidth = 0;
                  let countChild = 0;
                  if (hasEllipsis) {
                    import_xe_utils27.default.eachTree(column.children, (item) => {
                      if (!item.children || !column.children.length) {
                        countChild++;
                      }
                      childWidth += item.renderWidth;
                    }, { children: "children" });
                  }
                  thElem.style.width = hasEllipsis ? `${childWidth - countChild - (border ? 2 : 0)}px` : "";
                }
              });
            }
          } else if (layout === "body") {
            const emptyBlockElem = getRefElem(elemStore[`${name}-${layout}-emptyBlock`]);
            if (isNodeElement(wrapperElem)) {
              let bodyMaxHeight = 0;
              const bodyMinHeight = customMinHeight - headerHeight - footerHeight;
              if (customMaxHeight) {
                bodyMaxHeight = customMaxHeight - headerHeight - footerHeight;
                if (fixedType) {
                  bodyMaxHeight -= showFooter ? 0 : scrollbarHeight;
                }
                bodyMaxHeight = Math.max(bodyMinHeight, bodyMaxHeight);
                wrapperElem.style.maxHeight = `${bodyMaxHeight}px`;
              }
              if (customHeight) {
                let bodyHeight = customHeight - headerHeight - footerHeight;
                if (fixedType) {
                  bodyHeight -= showFooter ? 0 : scrollbarHeight;
                }
                if (bodyMaxHeight) {
                  bodyHeight = Math.min(bodyMaxHeight, bodyHeight);
                }
                wrapperElem.style.height = `${Math.max(bodyMinHeight, bodyHeight)}px`;
              } else {
                wrapperElem.style.height = "";
              }
              wrapperElem.style.minHeight = `${bodyMinHeight}px`;
            }
            if (fixedWrapperElem) {
              if (isNodeElement(wrapperElem)) {
                wrapperElem.style.top = `${headerHeight}px`;
              }
              fixedWrapperElem.style.height = `${(customHeight > 0 ? customHeight - headerHeight - footerHeight : tableHeight) + headerHeight + footerHeight - scrollbarHeight * (showFooter ? 2 : 1)}px`;
              fixedWrapperElem.style.width = `${fixedColumn.reduce((previous, column) => previous + column.renderWidth, isFixedLeft ? 0 : scrollbarWidth)}px`;
            }
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (fixedType) {
              if (!reactData.expandColumn && (scrollYLoad || (allColumnOverflow ? isAllOverflow : allColumnOverflow))) {
                if (!mergeList.length && !spanMethod && !(keyboardConfig && keyboardOpts.isMerge)) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth}px` : "";
              tableElem.style.paddingRight = scrollbarWidth && fixedType && (browse2["-moz"] || browse2.safari) ? `${scrollbarWidth}px` : "";
            }
            if (emptyBlockElem) {
              emptyBlockElem.style.width = tWidth ? `${tWidth}px` : "";
            }
          } else if (layout === "footer") {
            let tWidth = tableWidth;
            let renderColumnList = tableColumn;
            if (fixedType) {
              if (!reactData.expandColumn && (scrollXLoad || allColumnFooterOverflow)) {
                if (!mergeFooterList.length || !footerSpanMethod) {
                  renderColumnList = fixedColumn;
                } else {
                  renderColumnList = visibleColumn;
                }
              } else {
                renderColumnList = visibleColumn;
              }
            }
            tWidth = renderColumnList.reduce((previous, column) => previous + column.renderWidth, 0);
            if (isNodeElement(wrapperElem)) {
              if (fixedWrapperElem) {
                wrapperElem.style.top = `${customHeight > 0 ? customHeight - footerHeight : tableHeight + headerHeight}px`;
              }
              wrapperElem.style.marginTop = `${-Math.max(1, scrollbarHeight)}px`;
            }
            if (tableElem) {
              tableElem.style.width = tWidth ? `${tWidth + scrollbarWidth}px` : "";
            }
          }
          const colgroupElem = getRefElem(elemStore[`${name}-${layout}-colgroup`]);
          if (colgroupElem) {
            import_xe_utils27.default.arrayEach(colgroupElem.children, (colElem) => {
              const colid = colElem.getAttribute("name");
              if (colid === "col_gutter") {
                colElem.style.width = `${scrollbarWidth}px`;
              }
              if (fullColumnIdData[colid]) {
                const colRest = fullColumnIdData[colid];
                const column = colRest.column;
                const { showHeaderOverflow, showFooterOverflow, showOverflow } = column;
                let cellOverflow;
                colElem.style.width = `${column.renderWidth}px`;
                if (layout === "header") {
                  cellOverflow = import_xe_utils27.default.isUndefined(showHeaderOverflow) || import_xe_utils27.default.isNull(showHeaderOverflow) ? allColumnHeaderOverflow : showHeaderOverflow;
                } else if (layout === "footer") {
                  cellOverflow = import_xe_utils27.default.isUndefined(showFooterOverflow) || import_xe_utils27.default.isNull(showFooterOverflow) ? allColumnFooterOverflow : showFooterOverflow;
                } else {
                  cellOverflow = import_xe_utils27.default.isUndefined(showOverflow) || import_xe_utils27.default.isNull(showOverflow) ? allColumnOverflow : showOverflow;
                }
                const showEllipsis = cellOverflow === "ellipsis";
                const showTitle = cellOverflow === "title";
                const showTooltip = cellOverflow === true || cellOverflow === "tooltip";
                let hasEllipsis = showTitle || showTooltip || showEllipsis;
                const listElem = getRefElem(elemStore[`${name}-${layout}-list`]);
                if (scrollYLoad && !hasEllipsis) {
                  hasEllipsis = true;
                }
                if (listElem) {
                  import_xe_utils27.default.arrayEach(listElem.querySelectorAll(`.${column.id}`), (elem) => {
                    const colspan = parseInt(elem.getAttribute("colspan") || 1);
                    const cellElem = elem.querySelector(".vxe-cell");
                    let colWidth = column.renderWidth;
                    if (cellElem) {
                      if (colspan > 1) {
                        const columnIndex = tableMethods.getColumnIndex(column);
                        for (let index3 = 1; index3 < colspan; index3++) {
                          const nextColumn = tableMethods.getColumns(columnIndex + index3);
                          if (nextColumn) {
                            colWidth += nextColumn.renderWidth;
                          }
                        }
                      }
                      cellElem.style.width = hasEllipsis ? `${colWidth - cellOffsetWidth * colspan}px` : "";
                    }
                  });
                }
              }
            });
          }
        });
      });
      if (currentRow) {
        tableMethods.setCurrentRow(currentRow);
      }
      if (mouseConfig && mouseOpts.selected && editStore.selected.row && editStore.selected.column) {
        $xeTable.addCellSelectedClass();
      }
      return nextTick();
    };
    const checkValidate = (type) => {
      if ($xeTable.triggerValidate) {
        return $xeTable.triggerValidate(type);
      }
      return nextTick();
    };
    const handleChangeCell = (evnt, params) => {
      checkValidate("blur").catch((e16) => e16).then(() => {
        $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e16) => e16);
      });
    };
    const handleDefaultSort = () => {
      const { sortConfig } = props;
      if (sortConfig) {
        const sortOpts = computeSortOpts.value;
        let { defaultSort } = sortOpts;
        if (defaultSort) {
          if (!import_xe_utils27.default.isArray(defaultSort)) {
            defaultSort = [defaultSort];
          }
          if (defaultSort.length) {
            (sortConfig.multiple ? defaultSort : defaultSort.slice(0, 1)).forEach((item, index2) => {
              const { field, order } = item;
              if (field && order) {
                const column = tableMethods.getColumnByField(field);
                if (column && column.sortable) {
                  column.order = order;
                  column.sortTime = Date.now() + index2;
                }
              }
            });
            if (!sortOpts.remote) {
              tablePrivateMethods.handleTableData(true).then(updateStyle);
            }
          }
        }
      }
    };
    const handleDefaultSelectionChecked = () => {
      const { checkboxConfig } = props;
      if (checkboxConfig) {
        const { fullDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkAll, checkRowKeys } = checkboxOpts;
        if (checkAll) {
          handleCheckedAllCheckboxRow(true, true);
        } else if (checkRowKeys) {
          const defSelection = [];
          checkRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defSelection.push(fullDataRowIdData[rowid].row);
            }
          });
          handleCheckedCheckboxRow(defSelection, true, true);
        }
      }
    };
    const handleDefaultRadioChecked = () => {
      const { radioConfig } = props;
      if (radioConfig) {
        const { fullDataRowIdData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const { checkRowKey: rowid, reserve } = radioOpts;
        if (rowid) {
          if (fullDataRowIdData[rowid]) {
            handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
          }
          if (reserve) {
            const rowkey = getRowkey($xeTable);
            internalData.radioReserveRow = { [rowkey]: rowid };
          }
        }
      }
    };
    const handleDefaultRowExpand = () => {
      const { expandConfig } = props;
      if (expandConfig) {
        const { fullDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { expandAll, expandRowKeys } = expandOpts;
        if (expandAll) {
          tableMethods.setAllRowExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          expandRowKeys.forEach((rowid) => {
            if (fullDataRowIdData[rowid]) {
              defExpandeds.push(fullDataRowIdData[rowid].row);
            }
          });
          tableMethods.setRowExpand(defExpandeds, true);
        }
      }
    };
    const handleRadioReserveRow = (row) => {
      const radioOpts = computeRadioOpts.value;
      if (radioOpts.reserve) {
        internalData.radioReserveRow = row;
      }
    };
    const handleCheckboxReserveRow = (row, checked) => {
      const { checkboxReserveRowMap } = internalData;
      const checkboxOpts = computeCheckboxOpts.value;
      if (checkboxOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (checked) {
          checkboxReserveRowMap[rowid] = row;
        } else if (checkboxReserveRowMap[rowid]) {
          delete checkboxReserveRowMap[rowid];
        }
      }
    };
    const handleCheckedRadioRow = (row, isForce) => {
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      if (row && (isForce || (!checkMethod || checkMethod({ row })))) {
        reactData.selectRadioRow = row;
        handleRadioReserveRow(row);
      }
      return nextTick();
    };
    const handleCheckedCheckboxRow = (rows, value, isForce) => {
      if (rows && !import_xe_utils27.default.isArray(rows)) {
        rows = [rows];
      }
      $xeTable.handleBatchSelectRows(rows, !!value, isForce);
      $xeTable.checkSelectionStatus();
      return nextTick();
    };
    const handleCheckedAllCheckboxRow = (checked, isForce) => {
      const { treeConfig } = props;
      const { selectCheckboxMaps } = reactData;
      const { afterFullData, checkboxReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkField, reserve, checkMethod } = checkboxOpts;
      const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
      const selectRowMaps = {};
      if (checkField) {
        const checkValFn = (row) => {
          if (isForce || (!checkMethod || checkMethod({ row }))) {
            if (checked) {
              selectRowMaps[getRowid($xeTable, row)] = row;
            }
            import_xe_utils27.default.set(row, checkField, checked);
          }
          if (treeConfig && indeterminateField) {
            import_xe_utils27.default.set(row, indeterminateField, false);
          }
        };
        if (treeConfig) {
          import_xe_utils27.default.eachTree(afterFullData, checkValFn, { children: childrenField });
        } else {
          afterFullData.forEach(checkValFn);
        }
      } else {
        if (treeConfig) {
          if (checked) {
            import_xe_utils27.default.eachTree(afterFullData, (row) => {
              if (isForce || (!checkMethod || checkMethod({ row }))) {
                selectRowMaps[getRowid($xeTable, row)] = row;
              }
            }, { children: childrenField });
          } else {
            if (!isForce && checkMethod) {
              import_xe_utils27.default.eachTree(afterFullData, (row) => {
                const rowid = getRowid($xeTable, row);
                if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              }, { children: childrenField });
            }
          }
        } else {
          if (checked) {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = getRowid($xeTable, row);
                if (selectCheckboxMaps[rowid] || checkMethod({ row })) {
                  selectRowMaps[rowid] = row;
                }
              });
            } else {
              afterFullData.forEach((row) => {
                selectRowMaps[getRowid($xeTable, row)] = row;
              });
            }
          } else {
            if (!isForce && checkMethod) {
              afterFullData.forEach((row) => {
                const rowid = getRowid($xeTable, row);
                if (checkMethod({ row }) ? 0 : selectCheckboxMaps[rowid]) {
                  selectRowMaps[rowid] = row;
                }
              });
            }
          }
        }
      }
      if (reserve) {
        if (checked) {
          import_xe_utils27.default.each(selectRowMaps, (row, rowid) => {
            checkboxReserveRowMap[rowid] = row;
          });
        } else {
          afterFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
      }
      reactData.selectCheckboxMaps = checkField ? {} : selectRowMaps;
      reactData.isAllSelected = checked;
      reactData.isIndeterminate = false;
      reactData.treeIndeterminateMaps = {};
      internalData.treeIndeterminateRowMaps = {};
      tablePrivateMethods.checkSelectionStatus();
      return nextTick();
    };
    const handleReserveStatus = () => {
      const { treeConfig } = props;
      const { expandColumn, currentRow, selectCheckboxMaps, selectRadioRow, rowExpandedMaps, treeExpandedMaps } = reactData;
      const { fullDataRowIdData, fullAllDataRowIdData, radioReserveRow } = internalData;
      const expandOpts = computeExpandOpts.value;
      const treeOpts = computeTreeOpts.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      if (selectRadioRow && !fullAllDataRowIdData[getRowid($xeTable, selectRadioRow)]) {
        reactData.selectRadioRow = null;
      }
      if (radioOpts.reserve && radioReserveRow) {
        const rowid = getRowid($xeTable, radioReserveRow);
        if (fullDataRowIdData[rowid]) {
          handleCheckedRadioRow(fullDataRowIdData[rowid].row, true);
        }
      }
      reactData.selectCheckboxMaps = getRecoverRowMaps(selectCheckboxMaps);
      if (checkboxOpts.reserve) {
        handleCheckedCheckboxRow(handleReserveRow(internalData.checkboxReserveRowMap), true, true);
      }
      if (currentRow && !fullAllDataRowIdData[getRowid($xeTable, currentRow)]) {
        reactData.currentRow = null;
      }
      reactData.rowExpandedMaps = expandColumn ? getRecoverRowMaps(rowExpandedMaps) : {};
      if (expandColumn && expandOpts.reserve) {
        tableMethods.setRowExpand(handleReserveRow(internalData.rowExpandedReserveRowMap), true);
      }
      reactData.treeExpandedMaps = treeConfig ? getRecoverRowMaps(treeExpandedMaps) : {};
      if (treeConfig && treeOpts.reserve) {
        tableMethods.setTreeExpand(handleReserveRow(internalData.treeExpandedReserveRowMap), true);
      }
    };
    const handleDefaultTreeExpand = () => {
      const { treeConfig } = props;
      if (treeConfig) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { expandAll, expandRowKeys } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (expandAll) {
          tableMethods.setAllTreeExpand(true);
        } else if (expandRowKeys) {
          const defExpandeds = [];
          const rowkey = getRowkey($xeTable);
          expandRowKeys.forEach((rowid) => {
            const matchObj = import_xe_utils27.default.findTree(tableFullData, (item) => rowid === import_xe_utils27.default.get(item, rowkey), { children: childrenField });
            if (matchObj) {
              defExpandeds.push(matchObj.item);
            }
          });
          tableMethods.setTreeExpand(defExpandeds, true);
        }
      }
    };
    const handleAsyncTreeExpandChilds = (row) => {
      const treeOpts = computeTreeOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { transform: transform2, loadMethod } = treeOpts;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const { treeExpandLazyLoadedMaps } = reactData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          treeExpandLazyLoadedMaps[rowid] = row;
          Promise.resolve(loadMethod({ $table: $xeTable, row })).then((childRecords) => {
            if (rowRest) {
              rowRest.treeLoaded = true;
            }
            if (treeExpandLazyLoadedMaps[rowid]) {
              delete treeExpandLazyLoadedMaps[rowid];
            }
            if (!import_xe_utils27.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return tableMethods.loadTreeChildren(row, childRecords).then((childRows) => {
                const { treeExpandedMaps } = reactData;
                if (childRows.length && !treeExpandedMaps[rowid]) {
                  treeExpandedMaps[rowid] = row;
                }
                if (!checkStrictly && tableMethods.isCheckedByCheckboxRow(row)) {
                  handleCheckedCheckboxRow(childRows, true);
                }
                return nextTick().then(() => {
                  if (transform2) {
                    tablePrivateMethods.handleTableData();
                    updateTreeDataIndex();
                    return nextTick();
                  }
                });
              });
            }
          }).catch(() => {
            const { treeExpandLazyLoadedMaps: treeExpandLazyLoadedMaps2 } = reactData;
            if (rowRest) {
              rowRest.treeLoaded = false;
            }
            if (treeExpandLazyLoadedMaps2[rowid]) {
              delete treeExpandLazyLoadedMaps2[rowid];
            }
          }).finally(() => {
            nextTick().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleTreeExpandReserve = (row, expanded) => {
      const { treeExpandedReserveRowMap } = internalData;
      const treeOpts = computeTreeOpts.value;
      if (treeOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          treeExpandedReserveRowMap[rowid] = row;
        } else if (treeExpandedReserveRowMap[rowid]) {
          delete treeExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleAsyncRowExpand = (row) => {
      return new Promise((resolve) => {
        const expandOpts = computeExpandOpts.value;
        const { loadMethod } = expandOpts;
        if (loadMethod) {
          const { fullAllDataRowIdData } = internalData;
          const { rowExpandLazyLoadedMaps } = reactData;
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          rowExpandLazyLoadedMaps[rowid] = row;
          loadMethod({ $table: $xeTable, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) }).then(() => {
            const { rowExpandedMaps } = reactData;
            if (rowRest) {
              rowRest.expandLoaded = true;
            }
            rowExpandedMaps[rowid] = row;
          }).catch(() => {
            if (rowRest) {
              rowRest.expandLoaded = false;
            }
          }).finally(() => {
            const { rowExpandLazyLoadedMaps: rowExpandLazyLoadedMaps2 } = reactData;
            if (rowExpandLazyLoadedMaps2[rowid]) {
              delete rowExpandLazyLoadedMaps2[rowid];
            }
            nextTick().then(() => tableMethods.recalculate()).then(() => resolve());
          });
        } else {
          resolve();
        }
      });
    };
    const handleRowExpandReserve = (row, expanded) => {
      const { rowExpandedReserveRowMap } = internalData;
      const expandOpts = computeExpandOpts.value;
      if (expandOpts.reserve) {
        const rowid = getRowid($xeTable, row);
        if (expanded) {
          rowExpandedReserveRowMap[rowid] = row;
        } else if (rowExpandedReserveRowMap[rowid]) {
          delete rowExpandedReserveRowMap[rowid];
        }
      }
    };
    const handleDefaultMergeCells = () => {
      const { mergeCells } = props;
      if (mergeCells) {
        tableMethods.setMergeCells(mergeCells);
      }
    };
    const handleDefaultMergeFooterItems = () => {
      const { mergeFooterItems } = props;
      if (mergeFooterItems) {
        tableMethods.setMergeFooterItems(mergeFooterItems);
      }
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollXLoad, scrollYLoad } = reactData;
        const { scrollXStore, scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const sXOpts = computeSXOpts.value;
        if (scrollXLoad) {
          const { visibleSize: visibleXSize } = handleVirtualXVisible();
          const offsetXSize = Math.max(0, sXOpts.oSize ? import_xe_utils27.default.toNumber(sXOpts.oSize) : browse2.edge ? 5 : 0);
          scrollXStore.offsetSize = offsetXSize;
          scrollXStore.visibleSize = visibleXSize;
          scrollXStore.endIndex = Math.max(scrollXStore.startIndex + scrollXStore.visibleSize + offsetXSize, scrollXStore.endIndex);
          tablePrivateMethods.updateScrollXData();
        } else {
          tablePrivateMethods.updateScrollXSpace();
        }
        calcCellHeight();
        const rowHeight = computeRowHeight();
        scrollYStore.rowHeight = rowHeight;
        reactData.rowHeight = rowHeight;
        const { visibleSize: visibleYSize } = handleVirtualYVisible();
        if (scrollYLoad) {
          const offsetYSize = Math.max(0, sYOpts.oSize ? import_xe_utils27.default.toNumber(sYOpts.oSize) : browse2.edge ? 10 : 0);
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex + visibleYSize + offsetYSize, scrollYStore.endIndex);
          tablePrivateMethods.updateScrollYData();
        } else {
          tablePrivateMethods.updateScrollYSpace();
        }
        nextTick(updateStyle);
      });
    };
    const handleRecalculateLayout = (reFull) => {
      const el2 = refElem.value;
      if (!el2 || !el2.clientWidth) {
        return nextTick();
      }
      calcCellWidth();
      autoCellWidth();
      return computeScrollLoad().then(() => {
        if (reFull === true) {
          calcCellHeight();
          calcCellWidth();
          autoCellWidth();
          return computeScrollLoad();
        }
      });
    };
    const loadTableData = (datas) => {
      const { keepSource, treeConfig, showOverflow } = props;
      const { editStore, scrollYLoad: oldScrollYLoad } = reactData;
      const { scrollYStore, scrollXStore, lastScrollLeft, lastScrollTop } = internalData;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const { transform: transform2 } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      let treeData = [];
      let fullData = reactive(datas ? datas.slice(0) : []);
      if (treeConfig) {
        if (transform2) {
          if (true) {
            if (!treeOpts.rowField) {
              errLog("vxe.error.reqProp", ["tree-config.rowField"]);
            }
            if (!treeOpts.parentField) {
              errLog("vxe.error.reqProp", ["tree-config.parentField"]);
            }
            if (!childrenField) {
              errLog("vxe.error.reqProp", ["tree-config.childrenField"]);
            }
            if (!treeOpts.mapChildrenField) {
              errLog("vxe.error.reqProp", ["tree-config.mapChildrenField"]);
            }
            if (childrenField === treeOpts.mapChildrenField) {
              errLog("vxe.error.errConflicts", ["tree-config.childrenField", "tree-config.mapChildrenField"]);
            }
          }
          treeData = import_xe_utils27.default.toArrayTree(fullData, {
            key: treeOpts.rowField,
            parentKey: treeOpts.parentField,
            children: childrenField,
            mapChildren: treeOpts.mapChildrenField
          });
          fullData = treeData.slice(0);
        } else {
          treeData = fullData.slice(0);
        }
      }
      scrollYStore.startIndex = 0;
      scrollYStore.endIndex = 1;
      scrollXStore.startIndex = 0;
      scrollXStore.endIndex = 1;
      reactData.scrollVMLoading = false;
      editStore.insertMaps = {};
      editStore.removeMaps = {};
      const sYLoad = updateScrollYStatus(fullData);
      reactData.scrollYLoad = sYLoad;
      reactData.isDragRowMove = false;
      internalData.tableFullData = fullData;
      internalData.tableFullTreeData = treeData;
      tablePrivateMethods.cacheRowMap(true);
      internalData.tableSynchData = datas;
      if (keepSource) {
        tablePrivateMethods.cacheSourceMap(fullData);
      }
      if (sYLoad) {
        if (showOverflow) {
          if (!rowOpts.height) {
            const errColumn = internalData.tableFullColumn.find((column) => column.showOverflow === false);
            if (errColumn) {
              errLog("vxe.error.errProp", [`column[field="${errColumn.field}"].show-overflow=false`, "show-overflow=true"]);
            }
          }
        }
        if (true) {
          if (!(props.height || props.maxHeight)) {
            errLog("vxe.error.reqProp", ["table.height | table.max-height | table.scroll-y={enabled: false}"]);
          }
          if (props.spanMethod) {
            warnLog("vxe.error.scrollErrProp", ["table.span-method"]);
          }
        }
      }
      if ($xeTable.clearCellAreas && props.mouseConfig) {
        $xeTable.clearCellAreas();
        $xeTable.clearCopyCellArea();
      }
      tableMethods.clearMergeCells();
      tableMethods.clearMergeFooterItems();
      tablePrivateMethods.handleTableData(true);
      tableMethods.updateFooter();
      return nextTick().then(() => {
        updateHeight();
        updateStyle();
      }).then(() => {
        computeScrollLoad();
      }).then(() => {
        if (sYLoad) {
          scrollYStore.endIndex = scrollYStore.visibleSize;
        }
        handleReserveStatus();
        tablePrivateMethods.checkSelectionStatus();
        return new Promise((resolve) => {
          nextTick().then(() => tableMethods.recalculate()).then(() => {
            let targetScrollLeft = lastScrollLeft;
            let targetScrollTop = lastScrollTop;
            const sXOpts = computeSXOpts.value;
            const sYOpts = computeSYOpts.value;
            if (sXOpts.scrollToLeftOnChange) {
              targetScrollLeft = 0;
            }
            if (sYOpts.scrollToTopOnChange) {
              targetScrollTop = 0;
            }
            if (oldScrollYLoad === sYLoad) {
              restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(resolve);
            } else {
              setTimeout(() => restoreScrollLocation($xeTable, targetScrollLeft, targetScrollTop).then(resolve));
            }
          });
        });
      });
    };
    const handleLoadDefaults = () => {
      handleDefaultSelectionChecked();
      handleDefaultRadioChecked();
      handleDefaultRowExpand();
      handleDefaultTreeExpand();
      handleDefaultMergeCells();
      handleDefaultMergeFooterItems();
      nextTick(() => setTimeout(() => tableMethods.recalculate()));
    };
    const handleInitDefaults = () => {
      handleDefaultSort();
    };
    const handleTableColumn = () => {
      const { scrollXLoad } = reactData;
      const { visibleColumn, scrollXStore, fullColumnIdData } = internalData;
      const tableColumn = scrollXLoad ? visibleColumn.slice(scrollXStore.startIndex, scrollXStore.endIndex) : visibleColumn.slice(0);
      tableColumn.forEach((column, $index) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest.$index = $index;
        }
      });
      reactData.tableColumn = tableColumn;
    };
    const loadScrollXData = () => {
      const { mergeList, mergeFooterList } = reactData;
      const { scrollXStore } = internalData;
      const { startIndex, endIndex, offsetSize } = scrollXStore;
      const { toVisibleIndex, visibleSize } = handleVirtualXVisible();
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetSize),
        endIndex: toVisibleIndex + visibleSize + offsetSize
      };
      calculateMergerOffsetIndex(mergeList.concat(mergeFooterList), offsetItem, "col");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollXStore.startIndex = offsetStartIndex;
          scrollXStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollXData();
        }
      }
      tableMethods.closeTooltip();
    };
    const getColumnList = (columns) => {
      const result = [];
      columns.forEach((column) => {
        result.push(...column.children && column.children.length ? getColumnList(column.children) : [column]);
      });
      return result;
    };
    const parseColumns = () => {
      const { showOverflow } = props;
      const rowOpts = computeRowOpts.value;
      const leftList = [];
      const centerList = [];
      const rightList = [];
      const { isGroup, columnStore } = reactData;
      const sXOpts = computeSXOpts.value;
      const { collectColumn, tableFullColumn, scrollXStore, fullColumnIdData } = internalData;
      if (isGroup) {
        const leftGroupList = [];
        const centerGroupList = [];
        const rightGroupList = [];
        import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
          const isColGroup = hasChildrenList(column);
          if (parent && parent.fixed) {
            column.fixed = parent.fixed;
          }
          if (parent && column.fixed !== parent.fixed) {
            errLog("vxe.error.groupFixed");
          }
          if (isColGroup) {
            column.visible = !!import_xe_utils27.default.findTree(column.children, (subColumn) => hasChildrenList(subColumn) ? false : subColumn.visible);
          } else if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
        collectColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftGroupList.push(column);
            } else if (column.fixed === "right") {
              rightGroupList.push(column);
            } else {
              centerGroupList.push(column);
            }
          }
        });
        reactData.tableGroupColumn = leftGroupList.concat(centerGroupList).concat(rightGroupList);
      } else {
        tableFullColumn.forEach((column) => {
          if (column.visible) {
            if (column.fixed === "left") {
              leftList.push(column);
            } else if (column.fixed === "right") {
              rightList.push(column);
            } else {
              centerList.push(column);
            }
          }
        });
      }
      const visibleColumn = leftList.concat(centerList).concat(rightList);
      const scrollXLoad = !!sXOpts.enabled && sXOpts.gt > -1 && (sXOpts.gt === 0 || sXOpts.gt < tableFullColumn.length);
      reactData.hasFixedColumn = leftList.length > 0 || rightList.length > 0;
      Object.assign(columnStore, { leftList, centerList, rightList });
      if (scrollXLoad) {
        if (showOverflow) {
          if (!rowOpts.height) {
            const errColumn = internalData.tableFullColumn.find((column) => column.showOverflow === false);
            if (errColumn) {
              errLog("vxe.error.errProp", [`column[field="${errColumn.field}"].show-overflow=false`, "show-overflow=true"]);
            }
          }
        }
        if (true) {
          if (props.spanMethod) {
            warnLog("vxe.error.scrollErrProp", ["span-method"]);
          }
          if (props.footerSpanMethod) {
            warnLog("vxe.error.scrollErrProp", ["footer-span-method"]);
          }
        }
        const { visibleSize } = handleVirtualXVisible();
        scrollXStore.startIndex = 0;
        scrollXStore.endIndex = visibleSize;
        scrollXStore.visibleSize = visibleSize;
      }
      if (visibleColumn.length !== internalData.visibleColumn.length || !internalData.visibleColumn.every((column, index2) => column === visibleColumn[index2])) {
        tableMethods.clearMergeCells();
        tableMethods.clearMergeFooterItems();
      }
      reactData.scrollXLoad = scrollXLoad;
      visibleColumn.forEach((column, index2) => {
        const colid = column.id;
        const colRest = fullColumnIdData[colid];
        if (colRest) {
          colRest._index = index2;
        }
      });
      internalData.visibleColumn = visibleColumn;
      handleTableColumn();
      return tableMethods.updateFooter().then(() => {
        return tableMethods.recalculate();
      }).then(() => {
        tableMethods.updateCellAreas();
        return tableMethods.recalculate();
      });
    };
    const initColumnSort = () => {
      const { collectColumn } = internalData;
      collectColumn.forEach((column, index2) => {
        const sortIndex = index2 + 1;
        column.sortNumber = sortIndex;
        column.renderSortNumber = sortIndex;
      });
    };
    const handleColumn = (collectColumn) => {
      internalData.collectColumn = collectColumn;
      const tableFullColumn = getColumnList(collectColumn);
      internalData.tableFullColumn = tableFullColumn;
      reactData._isLoading = true;
      reactData.isDragColMove = false;
      initColumnSort();
      return Promise.resolve(restoreCustomStorage()).then(() => {
        reactData._isLoading = false;
        cacheColumnMap();
        parseColumns().then(() => {
          if (reactData.scrollXLoad) {
            loadScrollXData();
          }
        });
        tableMethods.clearMergeCells();
        tableMethods.clearMergeFooterItems();
        tablePrivateMethods.handleTableData(true);
        if (true) {
          if ((reactData.scrollXLoad || reactData.scrollYLoad) && reactData.expandColumn) {
            warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
          }
        }
        return nextTick().then(() => {
          if ($xeToolbar) {
            $xeToolbar.syncUpdate({
              collectColumn: internalData.collectColumn,
              $table: $xeTable
            });
          }
          if ($xeTable.handleUpdateCustomColumn) {
            $xeTable.handleUpdateCustomColumn();
          }
          return tableMethods.recalculate();
        });
      });
    };
    const updateScrollYStatus = (fullData) => {
      const { treeConfig } = props;
      const sYOpts = computeSYOpts.value;
      const treeOpts = computeTreeOpts.value;
      const { transform: transform2 } = treeOpts;
      const allList = fullData || internalData.tableFullData;
      const scrollYLoad = (transform2 || !treeConfig) && !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt < allList.length);
      reactData.scrollYLoad = scrollYLoad;
      return scrollYLoad;
    };
    const handleBaseTreeExpand = (rows, expanded) => {
      const { treeExpandedMaps, treeExpandLazyLoadedMaps, treeNodeColumn } = reactData;
      const treeTempExpandedMaps = Object.assign({}, treeExpandedMaps);
      const { fullAllDataRowIdData, tableFullData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { reserve, lazy, accordion, toggleMethod } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
      const result = [];
      const columnIndex = tableMethods.getColumnIndex(treeNodeColumn);
      const $columnIndex = tableMethods.getVMColumnIndex(treeNodeColumn);
      let validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column: treeNodeColumn, columnIndex, $columnIndex, row })) : rows;
      if (accordion) {
        validRows = validRows.length ? [validRows[validRows.length - 1]] : [];
        const matchObj = import_xe_utils27.default.findTree(tableFullData, (item) => item === validRows[0], { children: childrenField });
        if (matchObj) {
          matchObj.items.forEach((item) => {
            const rowid = getRowid($xeTable, item);
            if (treeTempExpandedMaps[rowid]) {
              delete treeTempExpandedMaps[rowid];
            }
          });
        }
      }
      if (expanded) {
        validRows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (!treeTempExpandedMaps[rowid]) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              const isLoad = lazy && row[hasChildField] && !rowRest.treeLoaded && !treeExpandLazyLoadedMaps[rowid];
              if (isLoad) {
                result.push(handleAsyncTreeExpandChilds(row));
              } else {
                if (row[childrenField] && row[childrenField].length) {
                  treeTempExpandedMaps[rowid] = row;
                }
              }
            }
          }
        });
      } else {
        validRows.forEach((item) => {
          const rowid = getRowid($xeTable, item);
          if (treeTempExpandedMaps[rowid]) {
            delete treeTempExpandedMaps[rowid];
          }
        });
      }
      if (reserve) {
        validRows.forEach((row) => handleTreeExpandReserve(row, expanded));
      }
      reactData.treeExpandedMaps = treeTempExpandedMaps;
      return Promise.all(result).then(() => {
        return tableMethods.recalculate();
      });
    };
    const handleVirtualTreeExpand = (rows, expanded) => {
      return handleBaseTreeExpand(rows, expanded).then(() => {
        handleVirtualTreeToList();
        tablePrivateMethods.handleTableData();
        updateTreeDataIndex();
      }).then(() => {
        return tableMethods.recalculate();
      }).then(() => {
        setTimeout(() => {
          tableMethods.updateCellAreas();
        }, 30);
      });
    };
    const handleCheckAllEvent = (evnt, value) => {
      handleCheckedAllCheckboxRow(value);
      if (evnt) {
        dispatchEvent2("checkbox-all", {
          records: tableMethods.getCheckboxRecords(),
          reserves: tableMethods.getCheckboxReserveRecords(),
          indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
          checked: value
        }, evnt);
      }
    };
    const loadScrollYData = () => {
      const { showOverflow } = props;
      const { mergeList } = reactData;
      const { tableHeight, scrollYStore } = internalData;
      const { startIndex, endIndex, offsetSize } = scrollYStore;
      const offsetYSize = showOverflow ? offsetSize : offsetSize + Math.min(8, Math.ceil(tableHeight / 200));
      const { toVisibleIndex, visibleSize } = handleVirtualYVisible();
      const offsetItem = {
        startIndex: Math.max(0, toVisibleIndex - 1 - offsetYSize),
        endIndex: toVisibleIndex + visibleSize + offsetYSize
      };
      calculateMergerOffsetIndex(mergeList, offsetItem, "row");
      const { startIndex: offsetStartIndex, endIndex: offsetEndIndex } = offsetItem;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          tablePrivateMethods.updateScrollYData();
        }
      }
    };
    const createGetRowCacheProp = (prop) => {
      return function(row) {
        const { fullAllDataRowIdData } = internalData;
        if (row) {
          const rowid = getRowid($xeTable, row);
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return rowRest[prop];
          }
        }
        return -1;
      };
    };
    const createGetColumnCacheProp = (prop) => {
      return function(column) {
        const { fullColumnIdData } = internalData;
        if (column) {
          const colRest = fullColumnIdData[column.id];
          if (colRest) {
            return colRest[prop];
          }
        }
        return -1;
      };
    };
    const lazyScrollXData = () => {
      const { lxTimeout, lxRunTime, scrollXStore } = internalData;
      const { visibleSize } = scrollXStore;
      const fpsTime = Math.min(80, Math.floor(visibleSize * 3));
      if (lxTimeout) {
        clearTimeout(lxTimeout);
      }
      if (!lxRunTime || lxRunTime + fpsTime < Date.now()) {
        internalData.lxRunTime = Date.now();
        loadScrollXData();
      }
      internalData.lxTimeout = setTimeout(() => {
        internalData.lxRunTime = void 0;
        internalData.lxRunTime = void 0;
        loadScrollXData();
      }, fpsTime);
    };
    const lazyScrollYData = () => {
      const { lyTimeout, lyRunTime, scrollYStore } = internalData;
      const { visibleSize } = scrollYStore;
      const fpsTime = Math.min(80, Math.floor(visibleSize * 2));
      if (lyTimeout) {
        clearTimeout(lyTimeout);
      }
      if (!lyRunTime || lyRunTime + fpsTime < Date.now()) {
        internalData.lyRunTime = Date.now();
        loadScrollYData();
      }
      internalData.lyTimeout = setTimeout(() => {
        internalData.lyTimeout = void 0;
        internalData.lyRunTime = void 0;
        loadScrollYData();
      }, fpsTime);
    };
    const scrollXEvent = (evnt) => {
      const { inFooterScroll, inBodyScroll, lastScrollTop } = internalData;
      if (inFooterScroll) {
        return;
      }
      if (inBodyScroll) {
        return;
      }
      const tableHeader = refTableHeader.value;
      const tableBody = refTableBody.value;
      const tableFooter = refTableFooter.value;
      const bodyElem = tableBody.$el;
      const headerElem = tableHeader ? tableHeader.$el : null;
      const footerElem = tableFooter ? tableFooter.$el : null;
      const yHandleEl = refScrollYHandleElem.value;
      const wrapperEl = evnt.currentTarget;
      const { scrollLeft } = wrapperEl;
      const yBodyEl = yHandleEl || bodyElem;
      let scrollTop = 0;
      if (yBodyEl) {
        scrollTop = yBodyEl.scrollTop;
      }
      const isRollX = true;
      const isRollY = scrollTop !== lastScrollTop;
      internalData.inVirtualScroll = true;
      setScrollLeft(bodyElem, scrollLeft);
      setScrollLeft(headerElem, scrollLeft);
      setScrollLeft(footerElem, scrollLeft);
      $xeTable.triggerScrollXEvent(evnt);
      $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
        type: "table",
        fixed: ""
      });
    };
    const scrollYEvent = (evnt) => {
      const { inFooterScroll, inBodyScroll, lastScrollLeft } = internalData;
      if (inFooterScroll) {
        return;
      }
      if (inBodyScroll) {
        return;
      }
      const tableBody = refTableBody.value;
      const leftBody = refTableLeftBody.value;
      const rightBody = refTableRightBody.value;
      const bodyElem = tableBody.$el;
      const leftElem = leftBody ? leftBody.$el : null;
      const rightElem = rightBody ? rightBody.$el : null;
      const xHandleEl = refScrollXHandleElem.value;
      const wrapperEl = evnt.currentTarget;
      const { scrollTop } = wrapperEl;
      const xBodyEl = xHandleEl || bodyElem;
      let scrollLeft = 0;
      if (xBodyEl) {
        scrollLeft = xBodyEl.scrollLeft;
      }
      const isRollX = scrollLeft !== lastScrollLeft;
      const isRollY = true;
      internalData.inVirtualScroll = true;
      setScrollTop(bodyElem, scrollTop);
      setScrollTop(leftElem, scrollTop);
      setScrollTop(rightElem, scrollTop);
      $xeTable.triggerScrollYEvent(evnt);
      $xeTable.handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, {
        type: "table",
        fixed: ""
      });
    };
    const checkLastSyncScroll = (isRollX, isRollY) => {
      const { scrollXLoad, scrollYLoad } = reactData;
      const { lcsTimeout } = internalData;
      if (lcsTimeout) {
        clearTimeout(lcsTimeout);
      }
      internalData.lcsTimeout = setTimeout(() => {
        internalData.lcsTimeout = void 0;
        internalData.inVirtualScroll = false;
        internalData.inBodyScroll = false;
        internalData.bodyScrollType = "";
        internalData.inFooterScroll = false;
        if (isRollX && scrollXLoad) {
          tablePrivateMethods.updateScrollXData();
        }
        if (isRollY && scrollYLoad) {
          tablePrivateMethods.updateScrollYData();
        }
        tableMethods.updateCellAreas();
      }, 200);
    };
    let keyCtxTimeout;
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent2(evnt, { $table: $xeTable, $grid: $xeGrid }, params));
    };
    const handleScrollToRowColumn = (fieldOrColumn, row) => {
      const { fullColumnIdData } = internalData;
      const column = handleFieldOrColumn($xeTable, fieldOrColumn);
      if (column && fullColumnIdData[column.id]) {
        return colToVisible($xeTable, column, row);
      }
      return nextTick();
    };
    tableMethods = {
      dispatchEvent: dispatchEvent2,
      /**
       * 重置表格的一切数据状态
       */
      clearAll() {
        return clearTableAllStatus($xeTable);
      },
      /**
       * 同步 data 数据（即将废弃）
       * 如果用了该方法，那么组件将不再记录增删改的状态，只能自行实现对应逻辑
       * 对于某些特殊的场景，比如深层树节点元素发生变动时可能会用到
       */
      syncData() {
        warnLog("vxe.error.delFunc", ["syncData", "getData"]);
        return nextTick().then(() => {
          reactData.tableData = [];
          emit("update:data", internalData.tableFullData);
          return nextTick();
        });
      },
      /**
       * 手动处理数据，用于手动排序与筛选
       * 对于手动更改了排序、筛选...等条件后需要重新处理数据时可能会用到
       */
      updateData() {
        const { scrollXLoad, scrollYLoad } = reactData;
        return tablePrivateMethods.handleTableData(true).then(() => {
          tableMethods.updateFooter();
          if (scrollXLoad || scrollYLoad) {
            if (scrollXLoad) {
              tablePrivateMethods.updateScrollXSpace();
            }
            if (scrollYLoad) {
              tablePrivateMethods.updateScrollYSpace();
            }
            return tableMethods.refreshScroll();
          }
        }).then(() => {
          tableMethods.updateCellAreas();
          return tableMethods.recalculate(true);
        }).then(() => {
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 重新加载数据，不会清空表格状态
       * @param {Array} datas 数据
       */
      loadData(datas) {
        const { initStatus } = internalData;
        return loadTableData(datas).then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          if (!initStatus) {
            handleLoadDefaults();
          }
          return tableMethods.recalculate();
        });
      },
      /**
       * 重新加载数据，会清空表格状态
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        return tableMethods.clearAll().then(() => {
          internalData.inited = true;
          internalData.initStatus = true;
          return loadTableData(datas);
        }).then(() => {
          handleLoadDefaults();
          return tableMethods.recalculate();
        });
      },
      /**
       * 修改行数据
       */
      setRow(rows, record) {
        if (rows && record) {
          let rest = rows;
          if (!import_xe_utils27.default.isArray(rows)) {
            rest = [rows];
          }
          const rowkey = getRowkey($xeTable);
          rest.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            const newRecord = import_xe_utils27.default.clone(Object.assign({}, record), true);
            import_xe_utils27.default.set(newRecord, rowkey, rowid);
            Object.assign(row, newRecord);
          });
        }
        return nextTick();
      },
      /**
       * 局部加载行数据并恢复到初始状态
       * 对于行数据需要局部更改的场景中可能会用到
       * @param {Row} row 行对象
       * @param {Object} record 新数据
       * @param {String} field 字段名
       */
      reloadRow(row, record, field) {
        const { keepSource } = props;
        const { tableData } = reactData;
        const { tableSourceData } = internalData;
        if (keepSource) {
          const rowIndex = tableMethods.getRowIndex(row);
          const oRow = tableSourceData[rowIndex];
          if (oRow && row) {
            if (field) {
              const newValue = import_xe_utils27.default.clone(import_xe_utils27.default.get(record || row, field), true);
              import_xe_utils27.default.set(row, field, newValue);
              import_xe_utils27.default.set(oRow, field, newValue);
            } else {
              const rowkey = getRowkey($xeTable);
              const rowid = getRowid($xeTable, row);
              const newRecord = import_xe_utils27.default.clone(Object.assign({}, record), true);
              import_xe_utils27.default.set(newRecord, rowkey, rowid);
              import_xe_utils27.default.destructuring(oRow, Object.assign(row, newRecord));
            }
          }
          reactData.tableData = tableData.slice(0);
        } else {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
        }
        return nextTick();
      },
      getParams() {
        return props.params;
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadTreeChildren(row, childRecords) {
        const { keepSource } = props;
        const { tableSourceData, fullDataRowIdData, fullAllDataRowIdData, sourceDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const parentRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        const parentLevel = parentRest ? parentRest.level : 0;
        return tableMethods.createData(childRecords).then((rows) => {
          if (keepSource) {
            const rowid = getRowid($xeTable, row);
            const matchObj = import_xe_utils27.default.findTree(tableSourceData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
            if (matchObj) {
              matchObj.item[childrenField] = import_xe_utils27.default.clone(rows, true);
            }
            rows.forEach((childRow) => {
              const rowid2 = getRowid($xeTable, childRow);
              sourceDataRowIdData[rowid2] = import_xe_utils27.default.clone(childRow, true);
            });
          }
          import_xe_utils27.default.eachTree(rows, (childRow, index2, items, path, parent, nodes) => {
            const rowid = getRowid($xeTable, childRow);
            const parentRow = parent || parentRest.row;
            const rest = { row: childRow, rowid, seq: -1, index: index2, _index: -1, $index: -1, items, parent: parentRow, level: parentLevel + nodes.length, height: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
          }, { children: childrenField });
          row[childrenField] = rows;
          if (transform2) {
            row[mapChildrenField] = import_xe_utils27.default.clone(rows, false);
          }
          updateAfterDataIndex();
          return rows;
        });
      },
      /**
       * 加载列配置
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      loadColumn(columns) {
        const collectColumn = import_xe_utils27.default.mapTree(columns, (column) => reactive(cell_default.createColumn($xeTable, column)));
        return handleColumn(collectColumn);
      },
      /**
       * 加载列配置并恢复到初始状态
       * 对于表格列需要重载、局部递增场景下可能会用到
       * @param {ColumnInfo} columns 列配置
       */
      reloadColumn(columns) {
        return tableMethods.clearAll().then(() => {
          return tableMethods.loadColumn(columns);
        });
      },
      /**
       * 根据 tr 元素获取对应的 row 信息
       * @param {Element} tr 元素
       */
      getRowNode(tr2) {
        if (tr2) {
          const { fullAllDataRowIdData } = internalData;
          const rowid = tr2.getAttribute("rowid");
          if (rowid) {
            const rowRest = fullAllDataRowIdData[rowid];
            if (rowRest) {
              return {
                rowid: rowRest.rowid,
                item: rowRest.row,
                index: rowRest.index,
                items: rowRest.items,
                parent: rowRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 th/td 元素获取对应的 column 信息
       * @param {Element} cell 元素
       */
      getColumnNode(cell) {
        if (cell) {
          const { fullColumnIdData } = internalData;
          const colid = cell.getAttribute("colid");
          if (colid) {
            const colRest = fullColumnIdData[colid];
            if (colRest) {
              return {
                colid: colRest.colid,
                item: colRest.column,
                index: colRest.index,
                items: colRest.items,
                parent: colRest.parent
              };
            }
          }
        }
        return null;
      },
      /**
       * 根据 row 获取序号
       * @param {Row} row 行对象
       */
      getRowSeq: createGetRowCacheProp("seq"),
      /**
       * 根据 row 获取相对于 data 中的索引
       * @param {Row} row 行对象
       */
      getRowIndex: createGetRowCacheProp("index"),
      /**
       * 根据 row 获取相对于当前数据中的索引
       * @param {Row} row 行对象
       */
      getVTRowIndex: createGetRowCacheProp("_index"),
      /**
       * 根据 row 获取渲染中的虚拟索引
       * @param {Row} row 行对象
       */
      getVMRowIndex: createGetRowCacheProp("$index"),
      /**
       * 根据 column 获取相对于 columns 中的索引
       * @param {ColumnInfo} column 列配置
       */
      getColumnIndex: createGetColumnCacheProp("index"),
      /**
       * 根据 column 获取相对于当前表格列中的索引
       * @param {ColumnInfo} column 列配置
       */
      getVTColumnIndex: createGetColumnCacheProp("_index"),
      /**
       * 根据 column 获取渲染中的虚拟索引
       * @param {ColumnInfo} column 列配置
       */
      getVMColumnIndex: createGetColumnCacheProp("$index"),
      /**
       * 创建 data 对象
       * 对于某些特殊场景可能会用到，会自动对数据的字段名进行检测，如果不存在就自动定义
       * @param {Array} records 新数据
       */
      createData(records) {
        return nextTick().then(() => {
          return reactive(tablePrivateMethods.defineField(records));
        });
      },
      /**
       * 创建 Row|Rows 对象
       * 对于某些特殊场景需要对数据进行手动插入时可能会用到
       * @param {Array/Object} records 新数据
       */
      createRow(records) {
        const isArr = import_xe_utils27.default.isArray(records);
        if (!isArr) {
          records = [records || {}];
        }
        return tableMethods.createData(records).then((rows) => isArr ? rows : rows[0]);
      },
      // toOriginalRecords (rows: any[]) {
      //   const { treeConfig } = props
      //   const treeOpts = computeTreeOpts.value
      //   const { transform, mapChildrenField } = treeOpts
      //   const rowkey = getRowkey($xeTable)
      //   if (treeConfig) {
      //     if (transform) {
      //       return []
      //     }
      //     return []
      //   }
      //   return rows.map(item => {
      //     const obj = Object.assign({}, item)
      //     delete obj.rowkey
      //     return obj
      //   })
      // },
      /**
       * 还原数据
       * 如果不传任何参数，则还原整个表格
       * 如果传 row 则还原一行
       * 如果传 rows 则还原多行
       * 如果还额外传了 field 则还原指定的单元格数据
       */
      revertData(rows, field) {
        const { keepSource } = props;
        const { tableSourceData, sourceDataRowIdData } = internalData;
        if (!keepSource) {
          if (true) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
          return nextTick();
        }
        let targetRows = rows;
        if (rows) {
          if (!import_xe_utils27.default.isArray(rows)) {
            targetRows = [rows];
          }
        } else {
          targetRows = import_xe_utils27.default.toArray($xeTable.getUpdateRecords());
        }
        if (targetRows.length) {
          targetRows.forEach((row) => {
            if (!tableMethods.isInsertByRow(row)) {
              const rowid = getRowid($xeTable, row);
              const oRow = sourceDataRowIdData[rowid];
              if (oRow && row) {
                if (field) {
                  import_xe_utils27.default.set(row, field, import_xe_utils27.default.clone(import_xe_utils27.default.get(oRow, field), true));
                } else {
                  import_xe_utils27.default.destructuring(row, import_xe_utils27.default.clone(oRow, true));
                }
              }
            }
          });
        }
        if (rows) {
          return nextTick();
        }
        return tableMethods.reloadData(tableSourceData);
      },
      /**
       * 清空单元格内容
       * 如果不创参数，则清空整个表格内容
       * 如果传 row 则清空一行内容
       * 如果传 rows 则清空多行内容
       * 如果还额外传了 field 则清空指定单元格内容
       * @param {Array/Row} rows 行数据
       * @param {String} field 字段名
       */
      clearData(rows, field) {
        const { tableFullData, visibleColumn } = internalData;
        if (!arguments.length) {
          rows = tableFullData;
        } else if (rows && !import_xe_utils27.default.isArray(rows)) {
          rows = [rows];
        }
        if (field) {
          rows.forEach((row) => import_xe_utils27.default.set(row, field, null));
        } else {
          rows.forEach((row) => {
            visibleColumn.forEach((column) => {
              if (column.field) {
                setCellValue(row, column, null);
              }
            });
          });
        }
        return nextTick();
      },
      getCellElement(row, fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const rowid = getRowid($xeTable, row);
        const tableBody = refTableBody.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        let bodyElem;
        if (column) {
          if (column.fixed) {
            if (column.fixed === "left") {
              if (leftBody) {
                bodyElem = leftBody.$el;
              }
            } else {
              if (rightBody) {
                bodyElem = rightBody.$el;
              }
            }
          }
          if (!bodyElem) {
            bodyElem = tableBody.$el;
          }
          if (bodyElem) {
            return bodyElem.querySelector(`.vxe-body--row[rowid="${rowid}"] .${column.id}`);
          }
        }
        return null;
      },
      getCellLabel(row, fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (!column) {
          return null;
        }
        const formatter = column.formatter;
        const cellValue = getCellValue(row, column);
        let cellLabel = cellValue;
        if (formatter) {
          let formatData;
          const { fullAllDataRowIdData } = internalData;
          const rowid = getRowid($xeTable, row);
          const colid = column.id;
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            formatData = rowRest.formatData;
            if (!formatData) {
              formatData = fullAllDataRowIdData[rowid].formatData = {};
            }
            if (rowRest && formatData[colid]) {
              if (formatData[colid].value === cellValue) {
                return formatData[colid].label;
              }
            }
          }
          const formatParams = { cellValue, row, rowIndex: tableMethods.getRowIndex(row), column, columnIndex: tableMethods.getColumnIndex(column) };
          if (import_xe_utils27.default.isString(formatter)) {
            const gFormatOpts = formats5.get(formatter);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams) : "";
          } else if (import_xe_utils27.default.isArray(formatter)) {
            const gFormatOpts = formats5.get(formatter[0]);
            const tcFormatMethod = gFormatOpts ? gFormatOpts.tableCellFormatMethod || gFormatOpts.cellFormatMethod : null;
            cellLabel = tcFormatMethod ? tcFormatMethod(formatParams, ...formatter.slice(1)) : "";
          } else {
            cellLabel = formatter(formatParams);
          }
          if (formatData) {
            formatData[colid] = { value: cellValue, label: cellLabel };
          }
        }
        return cellLabel;
      },
      /**
       * 检查是否为临时行数据
       * @param {Row} row 行对象
       */
      isInsertByRow(row) {
        const { editStore } = reactData;
        const rowid = getRowid($xeTable, row);
        return !!editStore.insertMaps[rowid];
      },
      /**
       * 删除所有新增的临时数据
       * @returns
       */
      removeInsertRow() {
        const { editStore } = reactData;
        editStore.insertMaps = {};
        return $xeTable.remove($xeTable.getInsertRecords());
      },
      /**
       * 检查行或列数据是否发生改变
       * @param {Row} row 行对象
       * @param {String} field 字段名
       */
      isUpdateByRow(row, field) {
        const { keepSource } = props;
        const { tableFullColumn, fullDataRowIdData, sourceDataRowIdData } = internalData;
        if (keepSource) {
          const rowid = getRowid($xeTable, row);
          if (!fullDataRowIdData[rowid]) {
            return false;
          }
          const oRow = sourceDataRowIdData[rowid];
          if (oRow) {
            if (arguments.length > 1) {
              return !eqCellValue(oRow, row, field);
            }
            for (let index2 = 0, len = tableFullColumn.length; index2 < len; index2++) {
              const property = tableFullColumn[index2].field;
              if (property && !eqCellValue(oRow, row, property)) {
                return true;
              }
            }
          }
        }
        return false;
      },
      /**
       * 获取表格的可视列，也可以指定索引获取列
       * @param {Number} columnIndex 索引
       */
      getColumns(columnIndex) {
        const columns = internalData.visibleColumn;
        return import_xe_utils27.default.isUndefined(columnIndex) ? columns.slice(0) : columns[columnIndex];
      },
      /**
       * 根据列获取列的唯一主键
       */
      getColid(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column ? column.id : null;
      },
      /**
       * 根据列的唯一主键获取列
       * @param {String} colid 列主键
       */
      getColumnById(colid) {
        const fullColumnIdData = internalData.fullColumnIdData;
        return colid && fullColumnIdData[colid] ? fullColumnIdData[colid].column : null;
      },
      /**
       * 根据列的字段名获取列
       * @param {String} field 字段名
       */
      getColumnByField(field) {
        const fullColumnFieldData = internalData.fullColumnFieldData;
        return field && fullColumnFieldData[field] ? fullColumnFieldData[field].column : null;
      },
      getParentColumn(fieldOrColumn) {
        const fullColumnIdData = internalData.fullColumnIdData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        return column && column.parentId && fullColumnIdData[column.parentId] ? fullColumnIdData[column.parentId].column : null;
      },
      /**
       * 获取当前表格的列
       * 收集到的全量列、全量表头列、处理条件之后的全量表头列、当前渲染中的表头列
       */
      getTableColumn() {
        return {
          collectColumn: internalData.collectColumn.slice(0),
          fullColumn: internalData.tableFullColumn.slice(0),
          visibleColumn: internalData.visibleColumn.slice(0),
          tableColumn: reactData.tableColumn.slice(0)
        };
      },
      /**
       * 获取表格的全量列
       */
      getFullColumns() {
        const { collectColumn } = internalData;
        return collectColumn.slice(0);
      },
      /**
       * 获取数据，和 data 的行为一致，也可以指定索引获取数据
       */
      getData(rowIndex) {
        const tableSynchData = props.data || internalData.tableSynchData;
        return import_xe_utils27.default.isUndefined(rowIndex) ? tableSynchData.slice(0) : tableSynchData[rowIndex];
      },
      /**
       * 用于多选行，获取已选中的数据
       */
      getCheckboxRecords(isFull) {
        const { treeConfig } = props;
        const { tableFullData, afterFullData, afterTreeFullData, tableFullTreeData, fullDataRowIdData, afterFullRowMaps } = internalData;
        const treeOpts = computeTreeOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const { checkField } = checkboxOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let rowList = [];
        const currTableData = isFull ? transform2 ? tableFullTreeData : tableFullData : transform2 ? afterTreeFullData : afterFullData;
        if (checkField) {
          if (treeConfig) {
            rowList = import_xe_utils27.default.filterTree(currTableData, (row) => import_xe_utils27.default.get(row, checkField), { children: transform2 ? mapChildrenField : childrenField });
          } else {
            rowList = currTableData.filter((row) => import_xe_utils27.default.get(row, checkField));
          }
        } else {
          const { selectCheckboxMaps } = reactData;
          import_xe_utils27.default.each(selectCheckboxMaps, (row, rowid) => {
            if (isFull) {
              if (fullDataRowIdData[rowid]) {
                rowList.push(fullDataRowIdData[rowid].row);
              }
            } else {
              if (afterFullRowMaps[rowid]) {
                rowList.push(afterFullRowMaps[rowid]);
              }
            }
          });
        }
        return rowList;
      },
      /**
       * 只对 tree-config 有效，获取行的子级
       */
      getTreeRowChildren(rowOrRowid) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils27.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullDataRowIdData[rowid];
            const row = rest ? rest.row : null;
            if (row) {
              return row[transform2 ? mapChildrenField : childrenField] || [];
            }
          }
        }
        return [];
      },
      /**
       * 只对 tree-config 有效，获取行的父级
       */
      getTreeParentRow(rowOrRowid) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        if (rowOrRowid && treeConfig) {
          let rowid;
          if (import_xe_utils27.default.isString(rowOrRowid)) {
            rowid = rowOrRowid;
          } else {
            rowid = getRowid($xeTable, rowOrRowid);
          }
          if (rowid) {
            const rest = fullDataRowIdData[rowid];
            return rest ? rest.parent : null;
          }
        }
        return null;
      },
      getParentRow(rowOrRowid) {
        warnLog("vxe.error.delFunc", ["getParentRow", "getTreeParentRow"]);
        return $xeTable.getTreeParentRow(rowOrRowid);
      },
      /**
       * 根据行的唯一主键获取行
       * @param {String/Number} rowid 行主键
       */
      getRowById(cellValue) {
        const { fullDataRowIdData } = internalData;
        const rowid = import_xe_utils27.default.eqNull(cellValue) ? "" : encodeURIComponent(cellValue || "");
        return fullDataRowIdData[rowid] ? fullDataRowIdData[rowid].row : null;
      },
      /**
       * 根据行获取行的唯一主键
       * @param {Row} row 行对象
       */
      getRowid(row) {
        return getRowid($xeTable, row);
      },
      /**
       * 获取处理后的表格数据
       * 如果存在筛选条件，继续处理
       * 如果存在排序，继续处理
       */
      getTableData() {
        const { tableData, footerTableData } = reactData;
        const { tableFullData, afterFullData, tableFullTreeData } = internalData;
        return {
          fullData: props.treeConfig ? tableFullTreeData.slice(0) : tableFullData.slice(0),
          visibleData: afterFullData.slice(0),
          tableData: tableData.slice(0),
          footerData: footerTableData.slice(0)
        };
      },
      /**
       * 获取表格的全量数据，如果是 tree-config 则返回带层级的树结构
       */
      getFullData() {
        const { treeConfig } = props;
        const { tableFullData, tableFullTreeData } = internalData;
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const { transform: transform2, mapChildrenField } = treeOpts;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          if (transform2) {
            return import_xe_utils27.default.toArrayTree(import_xe_utils27.default.toTreeArray(tableFullTreeData, {
              children: mapChildrenField
            }), { children: childrenField });
          }
          return tableFullTreeData.slice(0);
        }
        return tableFullData.slice(0);
      },
      /**
       * 设置为固定列
       */
      setColumnFixed(fieldOrColumn, fixed) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        const columnOpts = computeColumnOpts.value;
        const isMaxFixedColumn = computeIsMaxFixedColumn.value;
        for (let i = 0; i < cols.length; i++) {
          const item = cols[i];
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed !== fixed) {
            if (!targetColumn.fixed && isMaxFixedColumn) {
              if (VxeUI.modal) {
                VxeUI.modal.message({
                  status: "error",
                  content: getI18n10("vxe.table.maxFixedCol", [columnOpts.maxFixedSize])
                });
              }
              return nextTick();
            }
            import_xe_utils27.default.eachTree([targetColumn], (column2) => {
              column2.fixed = fixed;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        }
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 取消指定固定列
       */
      clearColumnFixed(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          const targetColumn = getRootColumn($xeTable, column);
          if (targetColumn && targetColumn.fixed) {
            import_xe_utils27.default.eachTree([targetColumn], (column2) => {
              column2.fixed = null;
            });
            tablePrivateMethods.saveCustomStore("update:fixed");
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      /**
       * 隐藏指定列
       */
      hideColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && column.visible) {
            column.visible = false;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      /**
       * 显示指定列
       */
      showColumn(fieldOrColumn) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column && !column.visible) {
            column.visible = true;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tablePrivateMethods.handleCustom();
        }
        return nextTick();
      },
      setColumnWidth(fieldOrColumn, width) {
        let status = false;
        const cols = import_xe_utils27.default.isArray(fieldOrColumn) ? fieldOrColumn : [fieldOrColumn];
        cols.forEach((item) => {
          const column = handleFieldOrColumn($xeTable, item);
          if (column) {
            const colWidth = import_xe_utils27.default.toInteger(width);
            let rdWidth = colWidth;
            if (isScale(width)) {
              const tableBody = refTableBody.value;
              const bodyElem = tableBody ? tableBody.$el : null;
              const bodyWidth = bodyElem ? bodyElem.clientWidth - 1 : 0;
              rdWidth = Math.floor(colWidth * bodyWidth);
            }
            column.resizeWidth = rdWidth;
            if (!status) {
              status = true;
            }
          }
        });
        if (status) {
          return tableMethods.refreshColumn();
        }
        return nextTick();
      },
      getColumnWidth(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.renderWidth;
        }
        return 0;
      },
      /**
       * 手动重置列的显示隐藏、列宽拖动的状态、固定列、排序列；
       * 如果为 true 则重置所有状态
       * 如果已关联工具栏，则会同步更新
       */
      resetColumn(options) {
        warnLog("vxe.error.delFunc", ["resetColumn", "resetCustom"]);
        return $xeTable.resetCustom(options);
      },
      /**
       * 刷新列信息
       * 将固定的列左边、右边分别靠边
       * 如果传 true 则会检查列顺序并排序
       */
      refreshColumn(initOrder) {
        if (initOrder) {
          const columnList = import_xe_utils27.default.orderBy(internalData.collectColumn, "renderSortNumber");
          internalData.collectColumn = columnList;
          const tableFullColumn = getColumnList(columnList);
          internalData.tableFullColumn = tableFullColumn;
          cacheColumnMap();
        }
        return parseColumns().then(() => {
          return tableMethods.refreshScroll();
        }).then(() => {
          return tableMethods.recalculate();
        });
      },
      /**
       * 刷新滚动操作，手动同步滚动相关位置（对于某些特殊的操作，比如滚动条错位、固定列不同步）
       */
      refreshScroll() {
        const { lastScrollLeft, lastScrollTop } = internalData;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        return new Promise((resolve) => {
          if (lastScrollLeft || lastScrollTop) {
            return restoreScrollLocation($xeTable, lastScrollLeft, lastScrollTop).then().then(() => {
              setTimeout(resolve, 30);
            });
          }
          setScrollTop(tableBodyElem, lastScrollTop);
          setScrollTop(leftBodyElem, lastScrollTop);
          setScrollTop(rightBodyElem, lastScrollTop);
          setScrollLeft(tableFooterElem, lastScrollLeft);
          setTimeout(resolve, 30);
        });
      },
      /**
       * 重新渲染布局
       * 刷新布局
       */
      recalculate(reFull) {
        return new Promise((resolve) => {
          const { rceTimeout } = internalData;
          const el2 = refElem.value;
          if (el2 && el2.clientWidth) {
            autoCellWidth();
          }
          if (rceTimeout) {
            clearTimeout(rceTimeout);
            nextTick(() => {
              resolve();
            });
          } else {
            resolve(handleRecalculateLayout(!!reFull));
          }
          internalData.rceTimeout = setTimeout(() => {
            internalData.rceTimeout = void 0;
            handleRecalculateLayout(!!reFull);
          }, 20);
        });
      },
      openTooltip(target, content) {
        const $commTip = refCommTooltip.value;
        if ($commTip && $commTip.open) {
          return $commTip.open(target, content);
        }
        return nextTick();
      },
      /**
       * 关闭 tooltip
       */
      closeTooltip() {
        const { tooltipStore } = reactData;
        const $tooltip = refTooltip.value;
        const $commTip = refCommTooltip.value;
        if (tooltipStore.visible) {
          Object.assign(tooltipStore, {
            row: null,
            column: null,
            content: null,
            visible: false,
            currOpts: {}
          });
          if ($tooltip && $tooltip.close) {
            $tooltip.close();
          }
        }
        if ($commTip && $commTip.close) {
          $commTip.close();
        }
        return nextTick();
      },
      /**
       * 判断列头复选框是否被选中
       */
      isAllCheckboxChecked() {
        return reactData.isAllSelected;
      },
      /**
       * 判断列头复选框是否被半选
       */
      isAllCheckboxIndeterminate() {
        return !reactData.isAllSelected && reactData.isIndeterminate;
      },
      /**
       * 获取复选框半选状态的行数据
       */
      getCheckboxIndeterminateRecords(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData } = internalData;
        const { treeIndeterminateMaps } = reactData;
        if (treeConfig) {
          const fullRest = [];
          const defRest = [];
          import_xe_utils27.default.each(treeIndeterminateMaps, (item, rowid) => {
            if (item) {
              fullRest.push(item);
              if (fullDataRowIdData[rowid]) {
                defRest.push(item);
              }
            }
          });
          if (isFull) {
            return fullRest;
          }
          return defRest;
        }
        return [];
      },
      /**
       * 用于多选行，设置行为选中状态，第二个参数为选中与否
       * @param {Array/Row} rows 行数据
       * @param {Boolean} value 是否选中
       */
      setCheckboxRow(rows, checked) {
        if (rows && !import_xe_utils27.default.isArray(rows)) {
          rows = [rows];
        }
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      setCheckboxRowKey(keys, checked) {
        const { fullAllDataRowIdData } = internalData;
        if (!import_xe_utils27.default.isArray(keys)) {
          keys = [keys];
        }
        const rows = [];
        keys.forEach((rowid) => {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            rows.push(rowRest.row);
          }
        });
        return handleCheckedCheckboxRow(rows, checked, true);
      },
      isCheckedByCheckboxRow(row) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          return import_xe_utils27.default.get(row, checkField);
        }
        return !!selectCheckboxMaps[getRowid($xeTable, row)];
      },
      isCheckedByCheckboxRowKey(rowid) {
        const { selectCheckboxMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        if (checkField) {
          const rowRest = fullAllDataRowIdData[rowid];
          if (rowRest) {
            return import_xe_utils27.default.get(rowRest.row, checkField);
          }
          return false;
        }
        return !!selectCheckboxMaps[rowid];
      },
      isIndeterminateByCheckboxRow(row) {
        const { treeIndeterminateMaps } = reactData;
        return !!treeIndeterminateMaps[getRowid($xeTable, row)] && !$xeTable.isCheckedByCheckboxRow(row);
      },
      isIndeterminateByCheckboxRowKey(rowid) {
        const { treeIndeterminateMaps } = reactData;
        return !!treeIndeterminateMaps[rowid] && !$xeTable.isCheckedByCheckboxRowKey(rowid);
      },
      /**
       * 多选，切换某一行的选中状态
       */
      toggleCheckboxRow(row) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField } = checkboxOpts;
        const checked = checkField ? !import_xe_utils27.default.get(row, checkField) : !selectCheckboxMaps[getRowid($xeTable, row)];
        tablePrivateMethods.handleBatchSelectRows([row], checked, true);
        tablePrivateMethods.checkSelectionStatus();
        return nextTick();
      },
      /**
       * 用于多选行，设置所有行的选中状态
       * @param {Boolean} value 是否选中
       */
      setAllCheckboxRow(value) {
        return handleCheckedAllCheckboxRow(value, true);
      },
      /**
       * 获取单选框保留选中的行
       */
      getRadioReserveRecord(isFull) {
        const { treeConfig } = props;
        const { fullDataRowIdData, radioReserveRow, afterFullData } = internalData;
        const radioOpts = computeRadioOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        if (radioOpts.reserve && radioReserveRow) {
          const rowid = getRowid($xeTable, radioReserveRow);
          if (isFull) {
            if (!fullDataRowIdData[rowid]) {
              return radioReserveRow;
            }
          } else {
            const rowkey = getRowkey($xeTable);
            if (treeConfig) {
              const matchObj = import_xe_utils27.default.findTree(afterFullData, (row) => rowid === import_xe_utils27.default.get(row, rowkey), { children: childrenField });
              if (matchObj) {
                return radioReserveRow;
              }
            } else {
              if (!afterFullData.some((row) => rowid === import_xe_utils27.default.get(row, rowkey))) {
                return radioReserveRow;
              }
            }
          }
        }
        return null;
      },
      clearRadioReserve() {
        internalData.radioReserveRow = null;
        return nextTick();
      },
      /**
       * 获取复选框保留选中的行
       */
      getCheckboxReserveRecords(isFull) {
        const { treeConfig } = props;
        const { afterFullData, fullDataRowIdData, checkboxReserveRowMap } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const reserveSelection = [];
        if (checkboxOpts.reserve) {
          const afterFullIdMaps = {};
          if (treeConfig) {
            import_xe_utils27.default.eachTree(afterFullData, (row) => {
              afterFullIdMaps[getRowid($xeTable, row)] = 1;
            }, { children: childrenField });
          } else {
            afterFullData.forEach((row) => {
              afterFullIdMaps[getRowid($xeTable, row)] = 1;
            });
          }
          import_xe_utils27.default.each(checkboxReserveRowMap, (oldRow, oldRowid) => {
            if (oldRow) {
              if (isFull) {
                if (!fullDataRowIdData[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              } else {
                if (!afterFullIdMaps[oldRowid]) {
                  reserveSelection.push(oldRow);
                }
              }
            }
          });
        }
        return reserveSelection;
      },
      clearCheckboxReserve() {
        internalData.checkboxReserveRowMap = {};
        return nextTick();
      },
      /**
       * 多选，切换所有行的选中状态
       */
      toggleAllCheckboxRow() {
        handleCheckAllEvent(null, !reactData.isAllSelected);
        return nextTick();
      },
      /**
       * 用于多选行，手动清空用户的选择
       * 清空行为不管是否被禁用还是保留记录，都将彻底清空选中状态
       */
      clearCheckboxRow() {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, reserve } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          const handleClearChecked = (item) => {
            if (treeConfig && indeterminateField) {
              import_xe_utils27.default.set(item, indeterminateField, false);
            }
            import_xe_utils27.default.set(item, checkField, false);
          };
          if (treeConfig) {
            import_xe_utils27.default.eachTree(tableFullData, handleClearChecked, { children: childrenField });
          } else {
            tableFullData.forEach(handleClearChecked);
          }
        }
        if (reserve) {
          tableFullData.forEach((row) => handleCheckboxReserveRow(row, false));
        }
        reactData.isAllSelected = false;
        reactData.isIndeterminate = false;
        reactData.selectCheckboxMaps = {};
        reactData.treeIndeterminateMaps = {};
        return nextTick();
      },
      /**
       * 用于当前行，设置某一行为高亮状态
       * @param {Row} row 行对象
       */
      setCurrentRow(row) {
        const rowOpts = computeRowOpts.value;
        const el2 = refElem.value;
        tableMethods.clearCurrentRow();
        reactData.currentRow = row;
        if (rowOpts.isCurrent || props.highlightCurrentRow) {
          if (el2) {
            import_xe_utils27.default.arrayEach(el2.querySelectorAll(`[rowid="${getRowid($xeTable, row)}"]`), (elem) => addClass(elem, "row--current"));
          }
        }
        return nextTick();
      },
      isCheckedByRadioRow(row) {
        const { selectRadioRow } = reactData;
        if (row && selectRadioRow) {
          return $xeTable.eqRow(selectRadioRow, row);
        }
        return false;
      },
      isCheckedByRadioRowKey(key) {
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          return key === getRowid($xeTable, selectRadioRow);
        }
        return false;
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param {Row} row 行对象
       */
      setRadioRow(row) {
        return handleCheckedRadioRow(row, true);
      },
      /**
       * 用于单选行，设置某一行为选中状态
       * @param key 行主键
       */
      setRadioRowKey(rowid) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[rowid];
        if (rowRest) {
          return handleCheckedRadioRow(rowRest.row, true);
        }
        return nextTick();
      },
      /**
       * 用于当前行，手动清空当前高亮的状态
       */
      clearCurrentRow() {
        const el2 = refElem.value;
        reactData.currentRow = null;
        internalData.hoverRow = null;
        if (el2) {
          import_xe_utils27.default.arrayEach(el2.querySelectorAll(".row--current"), (elem) => removeClass(elem, "row--current"));
        }
        return nextTick();
      },
      /**
       * 用于单选行，手动清空用户的选择
       */
      clearRadioRow() {
        reactData.selectRadioRow = null;
        return nextTick();
      },
      /**
       * 用于当前行，获取当前行的数据
       */
      getCurrentRecord() {
        const rowOpts = computeRowOpts.value;
        return rowOpts.isCurrent || props.highlightCurrentRow ? reactData.currentRow : null;
      },
      /**
       * 用于单选行，获取当已选中的数据
       */
      getRadioRecord(isFull) {
        const { fullDataRowIdData, afterFullRowMaps } = internalData;
        const { selectRadioRow } = reactData;
        if (selectRadioRow) {
          const rowid = getRowid($xeTable, selectRadioRow);
          if (isFull) {
            if (fullDataRowIdData[rowid]) {
              return selectRadioRow;
            }
          } else {
            if (afterFullRowMaps[rowid]) {
              return selectRadioRow;
            }
          }
        }
        return null;
      },
      getCurrentColumn() {
        const columnOpts = computeColumnOpts.value;
        return columnOpts.isCurrent || props.highlightCurrentColumn ? reactData.currentColumn : null;
      },
      /**
       * 用于当前列，设置某列行为高亮状态
       */
      setCurrentColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          tableMethods.clearCurrentColumn();
          reactData.currentColumn = column;
        }
        return nextTick();
      },
      /**
       * 用于当前列，手动清空当前高亮的状态
       */
      clearCurrentColumn() {
        reactData.currentColumn = null;
        return nextTick();
      },
      setPendingRow(rows, status) {
        const pendingMaps = Object.assign({}, reactData.pendingRowMaps);
        if (rows && !import_xe_utils27.default.isArray(rows)) {
          rows = [rows];
        }
        if (status) {
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            if (rowid && !pendingMaps[rowid]) {
              pendingMaps[rowid] = row;
            }
          });
        } else {
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            if (rowid && pendingMaps[rowid]) {
              delete pendingMaps[rowid];
            }
          });
        }
        reactData.pendingRowMaps = pendingMaps;
        return nextTick();
      },
      togglePendingRow(rows) {
        const pendingMaps = Object.assign({}, reactData.pendingRowMaps);
        if (rows && !import_xe_utils27.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (rowid) {
            if (pendingMaps[rowid]) {
              delete pendingMaps[rowid];
            } else {
              pendingMaps[rowid] = row;
            }
          }
        });
        reactData.pendingRowMaps = pendingMaps;
        return nextTick();
      },
      hasPendingByRow(row) {
        return tableMethods.isPendingByRow(row);
      },
      isPendingByRow(row) {
        const { pendingRowMaps } = reactData;
        const rowid = getRowid($xeTable, row);
        return !!pendingRowMaps[rowid];
      },
      getPendingRecords() {
        const { pendingRowMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const insertRecords = [];
        import_xe_utils27.default.each(pendingRowMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      clearPendingRow() {
        reactData.pendingRowMaps = {};
        return nextTick();
      },
      sort(sortConfs, sortOrder) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (sortConfs) {
          if (import_xe_utils27.default.isString(sortConfs)) {
            sortConfs = [
              { field: sortConfs, order: sortOrder }
            ];
          }
        }
        if (!import_xe_utils27.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs.length) {
          if (!multiple) {
            clearAllSort();
          }
          (multiple ? sortConfs : [sortConfs[0]]).forEach((confs, index2) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils27.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index2;
            }
          });
          if (!remote) {
            tablePrivateMethods.handleTableData(true);
          }
          return nextTick().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      setSort(sortConfs, isUpdate) {
        const sortOpts = computeSortOpts.value;
        const { multiple, remote, orders } = sortOpts;
        if (!import_xe_utils27.default.isArray(sortConfs)) {
          sortConfs = [sortConfs];
        }
        if (sortConfs && sortConfs.length) {
          if (!multiple) {
            sortConfs = [sortConfs[0]];
            clearAllSort();
          }
          let firstColumn = null;
          sortConfs.forEach((confs, index2) => {
            let { field, order } = confs;
            let column = field;
            if (import_xe_utils27.default.isString(field)) {
              column = tableMethods.getColumnByField(field);
            }
            if (!firstColumn) {
              firstColumn = column;
            }
            if (column && column.sortable) {
              if (orders.indexOf(order) === -1) {
                order = getNextSortOrder(column);
              }
              if (column.order !== order) {
                column.order = order;
              }
              column.sortTime = Date.now() + index2;
            }
          });
          if (isUpdate) {
            if (!remote) {
              tablePrivateMethods.handleTableData(true);
            }
            $xeTable.handleColumnSortEvent(new Event("click"), firstColumn);
          }
          return nextTick().then(() => {
            tableMethods.updateCellAreas();
            return updateStyle();
          });
        }
        return nextTick();
      },
      /**
       * 清空指定列的排序条件
       * 如果为空则清空所有列的排序条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearSort(fieldOrColumn) {
        const sortOpts = computeSortOpts.value;
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            column.order = null;
          }
        } else {
          clearAllSort();
        }
        if (!sortOpts.remote) {
          tablePrivateMethods.handleTableData(true);
        }
        return nextTick().then(updateStyle);
      },
      isSort(fieldOrColumn) {
        if (fieldOrColumn) {
          const column = handleFieldOrColumn($xeTable, fieldOrColumn);
          return column ? column.sortable && !!column.order : false;
        }
        return tableMethods.getSortColumns().length > 0;
      },
      getSortColumns() {
        const sortOpts = computeSortOpts.value;
        const { multiple, chronological } = sortOpts;
        const sortList = [];
        const { tableFullColumn } = internalData;
        tableFullColumn.forEach((column) => {
          const { field, order } = column;
          if (column.sortable && order) {
            sortList.push({ column, field, property: field, order, sortTime: column.sortTime });
          }
        });
        if (multiple && chronological && sortList.length > 1) {
          return import_xe_utils27.default.orderBy(sortList, "sortTime");
        }
        return sortList;
      },
      /**
       * 关闭筛选
       * @param {Event} evnt 事件
       */
      closeFilter() {
        const { filterStore } = reactData;
        const { column, visible } = filterStore;
        Object.assign(filterStore, {
          isAllSelected: false,
          isIndeterminate: false,
          options: [],
          visible: false
        });
        if (visible) {
          dispatchEvent2("filter-visible", { column, property: column.field, field: column.field, filterList: $xeTable.getCheckedFilters(), visible: false }, null);
        }
        return nextTick();
      },
      /**
       * 判断指定列是否为筛选状态，如果为空则判断所有列
       * @param {String} fieldOrColumn 字段名
       */
      isActiveFilterByColumn(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column) {
          return column.filters && column.filters.some((option2) => option2.checked);
        }
        return $xeTable.getCheckedFilters().length > 0;
      },
      isFilter(fieldOrColumn) {
        return tableMethods.isActiveFilterByColumn(fieldOrColumn);
      },
      /**
       * 判断展开行是否懒加载完成
       * @param {Row} row 行对象
       */
      isRowExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.expandLoaded;
      },
      clearRowExpandLoaded(row) {
        const { rowExpandLazyLoadedMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (lazy && rowRest) {
          rowRest.expandLoaded = false;
          delete rowExpandLazyLoadedMaps[rowid];
        }
        return nextTick();
      },
      /**
       * 重新懒加载展开行，并展开内容
       * @param {Row} row 行对象
       */
      reloadRowExpand(row) {
        const { rowExpandLazyLoadedMaps } = reactData;
        const expandOpts = computeExpandOpts.value;
        const { lazy } = expandOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && !rowExpandLazyLoadedMaps[rowid]) {
          tableMethods.clearRowExpandLoaded(row).then(() => handleAsyncRowExpand(row));
        }
        return nextTick();
      },
      reloadExpandContent(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadExpandContent", "reloadRowExpand"]);
        }
        return tableMethods.reloadRowExpand(row);
      },
      /**
       * 切换展开行
       */
      toggleRowExpand(row) {
        return tableMethods.setRowExpand(row, !tableMethods.isRowExpandByRow(row));
      },
      /**
       * 设置所有行的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllRowExpand(expanded) {
        const treeOpts = computeTreeOpts.value;
        const { tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let expandedRows = [];
        if (props.treeConfig) {
          import_xe_utils27.default.eachTree(tableFullTreeData, (row) => {
            expandedRows.push(row);
          }, { children: childrenField });
        } else {
          expandedRows = tableFullData;
        }
        return tableMethods.setRowExpand(expandedRows, expanded);
      },
      /**
       * 设置展开行，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setRowExpand(rows, expanded) {
        const { rowExpandedMaps, rowExpandLazyLoadedMaps, expandColumn: column } = reactData;
        const { fullAllDataRowIdData } = internalData;
        let rExpandedMaps = Object.assign({}, rowExpandedMaps);
        const expandOpts = computeExpandOpts.value;
        const { reserve, lazy, accordion, toggleMethod } = expandOpts;
        const lazyRests = [];
        const columnIndex = tableMethods.getColumnIndex(column);
        const $columnIndex = tableMethods.getVMColumnIndex(column);
        if (rows) {
          if (!import_xe_utils27.default.isArray(rows)) {
            rows = [rows];
          }
          if (accordion) {
            rExpandedMaps = {};
            rows = rows.slice(rows.length - 1, rows.length);
          }
          const validRows = toggleMethod ? rows.filter((row) => toggleMethod({ $table: $xeTable, expanded, column, columnIndex, $columnIndex, row, rowIndex: tableMethods.getRowIndex(row), $rowIndex: tableMethods.getVMRowIndex(row) })) : rows;
          if (expanded) {
            validRows.forEach((row) => {
              const rowid = getRowid($xeTable, row);
              if (!rExpandedMaps[rowid]) {
                const rowRest = fullAllDataRowIdData[rowid];
                const isLoad = lazy && !rowRest.expandLoaded && !rowExpandLazyLoadedMaps[rowid];
                if (isLoad) {
                  lazyRests.push(handleAsyncRowExpand(row));
                } else {
                  rExpandedMaps[rowid] = row;
                }
              }
            });
          } else {
            validRows.forEach((item) => {
              const rowid = getRowid($xeTable, item);
              if (rExpandedMaps[rowid]) {
                delete rExpandedMaps[rowid];
              }
            });
          }
          if (reserve) {
            validRows.forEach((row) => handleRowExpandReserve(row, expanded));
          }
        }
        reactData.rowExpandedMaps = rExpandedMaps;
        return Promise.all(lazyRests).then(() => tableMethods.recalculate());
      },
      /**
       * 判断行是否为展开状态
       * @param {Row} row 行对象
       */
      isRowExpandByRow(row) {
        const { rowExpandedMaps } = reactData;
        const rowid = getRowid($xeTable, row);
        return !!rowExpandedMaps[rowid];
      },
      isExpandByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isExpandByRow", "isRowExpandByRow"]);
        }
        return tableMethods.isRowExpandByRow(row);
      },
      /**
       * 手动清空展开行状态，数据会恢复成未展开的状态
       */
      clearRowExpand() {
        const { tableFullData } = internalData;
        const expandOpts = computeExpandOpts.value;
        const { reserve } = expandOpts;
        const expList = tableMethods.getRowExpandRecords();
        reactData.rowExpandedMaps = {};
        if (reserve) {
          tableFullData.forEach((row) => handleRowExpandReserve(row, false));
        }
        return nextTick().then(() => {
          if (expList.length) {
            tableMethods.recalculate();
          }
        });
      },
      clearRowExpandReserve() {
        internalData.rowExpandedReserveRowMap = {};
        return nextTick();
      },
      getRowExpandRecords() {
        const rest = [];
        import_xe_utils27.default.each(reactData.rowExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      getTreeExpandRecords() {
        const rest = [];
        import_xe_utils27.default.each(reactData.treeExpandedMaps, (item) => {
          if (item) {
            rest.push(item);
          }
        });
        return rest;
      },
      /**
       * 判断树节点是否懒加载完成
       * @param {Row} row 行对象
       */
      isTreeExpandLoaded(row) {
        const { fullAllDataRowIdData } = internalData;
        const rowRest = fullAllDataRowIdData[getRowid($xeTable, row)];
        return rowRest && !!rowRest.treeLoaded;
      },
      clearTreeExpandLoaded(row) {
        const { treeExpandedMaps } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, lazy } = treeOpts;
        const rowid = getRowid($xeTable, row);
        const rowRest = fullAllDataRowIdData[rowid];
        if (lazy && rowRest) {
          rowRest.treeLoaded = false;
          if (treeExpandedMaps[rowid]) {
            delete treeExpandedMaps[rowid];
          }
        }
        if (transform2) {
          handleVirtualTreeToList();
          return tablePrivateMethods.handleTableData();
        }
        return nextTick();
      },
      /**
       * 重新懒加载树节点，并展开该节点
       * @param {Row} row 行对象
       */
      reloadTreeExpand(row) {
        const { treeExpandLazyLoadedMaps } = reactData;
        const treeOpts = computeTreeOpts.value;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const { transform: transform2, lazy } = treeOpts;
        const rowid = getRowid($xeTable, row);
        if (lazy && row[hasChildField] && !treeExpandLazyLoadedMaps[rowid]) {
          return tableMethods.clearTreeExpandLoaded(row).then(() => {
            return handleAsyncTreeExpandChilds(row);
          }).then(() => {
            if (transform2) {
              handleVirtualTreeToList();
              return tablePrivateMethods.handleTableData();
            }
          }).then(() => {
            return tableMethods.recalculate();
          });
        }
        return nextTick();
      },
      reloadTreeChilds(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["reloadTreeChilds", "reloadTreeExpand"]);
        }
        return tableMethods.reloadTreeExpand(row);
      },
      /**
       * 切换/展开树节点
       */
      toggleTreeExpand(row) {
        return tableMethods.setTreeExpand(row, !tableMethods.isTreeExpandByRow(row));
      },
      /**
       * 设置所有树节点的展开与否
       * @param {Boolean} expanded 是否展开
       */
      setAllTreeExpand(expanded) {
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, lazy } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const expandeds = [];
        import_xe_utils27.default.eachTree(tableFullData, (row) => {
          const rowChildren = row[childrenField];
          if (lazy || rowChildren && rowChildren.length) {
            expandeds.push(row);
          }
        }, { children: childrenField });
        return tableMethods.setTreeExpand(expandeds, expanded).then(() => {
          if (transform2) {
            handleVirtualTreeToList();
            return tableMethods.recalculate();
          }
        });
      },
      /**
       * 设置展开树形节点，二个参数设置这一行展开与否
       * 支持单行
       * 支持多行
       * @param {Array/Row} rows 行数据
       * @param {Boolean} expanded 是否展开
       */
      setTreeExpand(rows, expanded) {
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2 } = treeOpts;
        if (rows) {
          if (!import_xe_utils27.default.isArray(rows)) {
            rows = [rows];
          }
          if (rows.length) {
            if (transform2) {
              return handleVirtualTreeExpand(rows, expanded);
            } else {
              return handleBaseTreeExpand(rows, expanded);
            }
          }
        }
        return nextTick();
      },
      /**
       * 判断行是否为树形节点展开状态
       * @param {Row} row 行对象
       */
      isTreeExpandByRow(row) {
        const { treeExpandedMaps } = reactData;
        return !!treeExpandedMaps[getRowid($xeTable, row)];
      },
      /**
       * 手动清空树形节点的展开状态，数据会恢复成未展开的状态
       */
      clearTreeExpand() {
        const { tableFullTreeData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { transform: transform2, reserve } = treeOpts;
        const expList = tableMethods.getTreeExpandRecords();
        reactData.treeExpandedMaps = {};
        if (reserve) {
          import_xe_utils27.default.eachTree(tableFullTreeData, (row) => handleTreeExpandReserve(row, false), { children: childrenField });
        }
        return tablePrivateMethods.handleTableData().then(() => {
          if (transform2) {
            handleVirtualTreeToList();
            return tablePrivateMethods.handleTableData();
          }
        }).then(() => {
          if (expList.length) {
            return tableMethods.recalculate();
          }
        });
      },
      clearTreeExpandReserve() {
        internalData.treeExpandedReserveRowMap = {};
        return nextTick();
      },
      /**
       * 获取表格的滚动状态
       */
      getScroll() {
        const { scrollXLoad, scrollYLoad } = reactData;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody.$el;
        return {
          virtualX: scrollXLoad,
          virtualY: scrollYLoad,
          scrollTop: bodyElem.scrollTop,
          scrollLeft: bodyElem.scrollLeft
        };
      },
      /**
       * 如果有滚动条，则滚动到对应的位置
       * @param {Number} scrollLeft 左距离
       * @param {Number} scrollTop 上距离
       */
      scrollTo(scrollLeft, scrollTop) {
        const tableBody = refTableBody.value;
        const tableHeader = refTableHeader.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableHeaderElem = tableHeader ? tableHeader.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        if (import_xe_utils27.default.isNumber(scrollLeft)) {
          const xHandleEl = refScrollXHandleElem.value;
          if (xHandleEl) {
            setScrollLeft(xHandleEl, scrollLeft);
          } else {
            setScrollLeft(tableBodyElem, scrollLeft);
            setScrollLeft(tableHeaderElem, scrollLeft);
            setScrollLeft(tableFooterElem, scrollLeft);
          }
        }
        if (import_xe_utils27.default.isNumber(scrollTop)) {
          const yHandleEl = refScrollYHandleElem.value;
          if (yHandleEl) {
            setScrollTop(yHandleEl, scrollTop);
          } else {
            setScrollTop(tableBodyElem, scrollTop);
            setScrollTop(leftBodyElem, scrollTop);
            setScrollTop(rightBodyElem, scrollTop);
          }
        }
        if (reactData.scrollXLoad || reactData.scrollYLoad) {
          return new Promise((resolve) => {
            setTimeout(() => {
              nextTick(() => {
                resolve();
              });
            }, 30);
          });
        }
        return nextTick();
      },
      /**
       * 如果有滚动条，则滚动到对应的行
       * @param {Row} row 行对象
       * @param {ColumnInfo} fieldOrColumn 列配置
       */
      scrollToRow(row, fieldOrColumn) {
        const rest = [];
        if (row) {
          if (props.treeConfig) {
            rest.push(tablePrivateMethods.scrollToTreeRow(row));
          } else {
            rest.push(rowToVisible($xeTable, row));
          }
        }
        if (fieldOrColumn) {
          rest.push(handleScrollToRowColumn(fieldOrColumn, row));
        }
        return Promise.all(rest);
      },
      /**
       * 如果有滚动条，则滚动到对应的列
       */
      scrollToColumn(fieldOrColumn) {
        const { fullColumnIdData } = internalData;
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && fullColumnIdData[column.id]) {
          return colToVisible($xeTable, column);
        }
        return nextTick();
      },
      /**
       * 手动清除滚动相关信息，还原到初始状态
       */
      clearScroll() {
        const { scrollXStore, scrollYStore } = internalData;
        const tableBody = refTableBody.value;
        const tableHeader = refTableHeader.value;
        const tableFooter = refTableFooter.value;
        const leftBody = refTableLeftBody.value;
        const rightBody = refTableRightBody.value;
        const leftBodyElem = leftBody ? leftBody.$el : null;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        const rightBodyElem = rightBody ? rightBody.$el : null;
        const tableHeaderElem = tableHeader ? tableHeader.$el : null;
        const tableFooterElem = tableFooter ? tableFooter.$el : null;
        const xHandleEl = refScrollXHandleElem.value;
        if (xHandleEl) {
          setScrollLeft(xHandleEl, 0);
        } else {
          setScrollLeft(tableBodyElem, 0);
          setScrollLeft(tableHeaderElem, 0);
          setScrollLeft(tableFooterElem, 0);
        }
        const yHandleEl = refScrollYHandleElem.value;
        if (yHandleEl) {
          setScrollTop(yHandleEl, 0);
        } else {
          setScrollTop(tableBodyElem, 0);
          setScrollTop(leftBodyElem, 0);
          setScrollTop(rightBodyElem, 0);
        }
        scrollXStore.startIndex = 0;
        scrollXStore.endIndex = scrollXStore.visibleSize;
        scrollYStore.startIndex = 0;
        scrollYStore.endIndex = scrollYStore.visibleSize;
        return nextTick().then(() => {
          setScrollLeft(tableBodyElem, 0);
          setScrollLeft(tableHeaderElem, 0);
          setScrollLeft(tableFooterElem, 0);
          setScrollTop(tableBodyElem, 0);
          setScrollTop(leftBodyElem, 0);
          setScrollTop(rightBodyElem, 0);
        });
      },
      /**
       * 更新表尾合计
       */
      updateFooter() {
        const { showFooter, footerData, footerMethod } = props;
        const { visibleColumn, afterFullData } = internalData;
        let footData = [];
        if (showFooter && footerData && footerData.length) {
          footData = footerData.slice(0);
        } else if (showFooter && footerMethod) {
          footData = visibleColumn.length ? footerMethod({ columns: visibleColumn, data: afterFullData, $table: $xeTable, $grid: $xeGrid }) : [];
        }
        reactData.footerTableData = footData;
        return nextTick();
      },
      /**
       * 更新列状态 updateStatus({ row, column }, cellValue)
       * 如果组件值 v-model 发生 change 时，调用改函数用于更新某一列编辑状态
       * 如果单元格配置了校验规则，则会进行校验
       */
      updateStatus(slotParams, cellValue) {
        const customVal = !import_xe_utils27.default.isUndefined(cellValue);
        return nextTick().then(() => {
          const { editRules } = props;
          const { validStore } = reactData;
          const tableBody = refTableBody.value;
          if (slotParams && tableBody && editRules) {
            const { row, column } = slotParams;
            const type = "change";
            if ($xeTable.hasCellRules) {
              if ($xeTable.hasCellRules(type, row, column)) {
                const cell = tableMethods.getCellElement(row, column);
                if (cell) {
                  return $xeTable.validCellRules(type, row, column, cellValue).then(() => {
                    if (customVal && validStore.visible) {
                      setCellValue(row, column, cellValue);
                    }
                    $xeTable.clearValidate(row, column);
                  }).catch(({ rule }) => {
                    if (customVal) {
                      setCellValue(row, column, cellValue);
                    }
                    $xeTable.showValidTooltip({ rule, row, column, cell });
                  });
                }
              }
            }
          }
        });
      },
      /**
       * 设置合并单元格
       * @param {TableMergeConfig[]} merges { row: Row|number, column: ColumnInfo|number, rowspan: number, colspan: number }
       */
      setMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        setMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      /**
       * 移除单元格合并
       * @param {TableMergeConfig[]} merges 多个或数组 [{row:Row|number, col:ColumnInfo|number}]
       */
      removeMergeCells(merges) {
        if (props.spanMethod) {
          errLog("vxe.error.errConflicts", ["merge-cells", "span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeList, internalData.afterFullData);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的单元格
       */
      getMergeCells() {
        return reactData.mergeList.slice(0);
      },
      /**
       * 清除所有单元格合并
       */
      clearMergeCells() {
        reactData.mergeList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      setMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        setMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          return updateStyle();
        });
      },
      removeMergeFooterItems(merges) {
        if (props.footerSpanMethod) {
          errLog("vxe.error.errConflicts", ["merge-footer-items", "footer-span-method"]);
        }
        const rest = removeMerges(merges, reactData.mergeFooterList);
        return nextTick().then(() => {
          tableMethods.updateCellAreas();
          updateStyle();
          return rest;
        });
      },
      /**
       * 获取所有被合并的表尾
       */
      getMergeFooterItems() {
        return reactData.mergeFooterList.slice(0);
      },
      /**
       * 清除所有表尾合并
       */
      clearMergeFooterItems() {
        reactData.mergeFooterList = [];
        return nextTick().then(() => {
          return updateStyle();
        });
      },
      updateCellAreas() {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        if (mouseConfig && mouseOpts.area && $xeTable.handleRecalculateCellAreas) {
          return $xeTable.handleRecalculateCellAreas();
        }
        return nextTick();
      },
      getCustomStoreData() {
        const { id: id2 } = props;
        const customOpts = computeCustomOpts.value;
        const { collectColumn } = internalData;
        const { checkMethod } = customOpts;
        const resizableData = {};
        const sortData = {};
        const visibleData = {};
        const fixedData = {};
        const storeData2 = {
          resizableData: void 0,
          sortData: void 0,
          visibleData: void 0,
          fixedData: void 0
        };
        if (!id2) {
          errLog("vxe.error.reqProp", ["id"]);
          return storeData2;
        }
        let hasResizable = 0;
        let hasSort = 0;
        let hasFixedt = 0;
        let hasVisible = 0;
        import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
          if (!parent) {
            collectColumn.forEach((column2) => {
              const colKey = column2.getKey();
              if (colKey) {
                hasSort = 1;
                sortData[colKey] = column2.renderSortNumber;
              }
            });
            if (column.fixed && column.fixed !== column.defaultFixed) {
              const colKey = column.getKey();
              if (colKey) {
                hasFixedt = 1;
                fixedData[colKey] = column.fixed;
              }
            }
          }
          if (column.resizeWidth) {
            const colKey = column.getKey();
            if (colKey) {
              hasResizable = 1;
              resizableData[colKey] = column.renderWidth;
            }
          }
          if (!checkMethod || checkMethod({ column })) {
            if (!column.visible && column.defaultVisible) {
              const colKey = column.getKey();
              if (colKey) {
                hasVisible = 1;
                visibleData[colKey] = false;
              }
            } else if (column.visible && !column.defaultVisible) {
              const colKey = column.getKey();
              if (colKey) {
                hasVisible = 1;
                visibleData[colKey] = true;
              }
            }
          }
        });
        if (hasResizable) {
          storeData2.resizableData = resizableData;
        }
        if (hasSort) {
          storeData2.sortData = sortData;
        }
        if (hasFixedt) {
          storeData2.fixedData = fixedData;
        }
        if (hasVisible) {
          storeData2.visibleData = visibleData;
        }
        return storeData2;
      },
      focus() {
        internalData.isActivated = true;
        return nextTick();
      },
      blur() {
        internalData.isActivated = false;
        return nextTick();
      },
      /**
       * 连接工具栏
       * @param $toolbar
       */
      connect($toolbar) {
        if ($toolbar) {
          $xeToolbar = $toolbar;
          $xeToolbar.syncUpdate({ collectColumn: internalData.collectColumn, $table: $xeTable });
        } else {
          errLog("vxe.error.barUnableLink");
        }
        return nextTick();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { editStore, ctxMenuStore, filterStore, customStore } = reactData;
      const { mouseConfig, editRules } = props;
      const el2 = refElem.value;
      const editOpts = computeEditOpts.value;
      const validOpts = computeValidOpts.value;
      const areaOpts = computeAreaOpts.value;
      const { actived } = editStore;
      const $validTooltip = refValidTooltip.value;
      const tableFilter = refTableFilter.value;
      const tableCustom = refTableCustom.value;
      const tableMenu = refTableMenu.value;
      if (tableFilter) {
        if (getEventTargetNode(evnt, el2, "vxe-cell--filter").flag) {
        } else if (getEventTargetNode(evnt, tableFilter.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearFilter", filterStore.args, tableMethods.closeFilter);
          }
        }
      }
      if (tableCustom) {
        if (customStore.btnEl === evnt.target || getEventTargetNode(evnt, document.body, "vxe-toolbar-custom-target").flag) {
        } else if (getEventTargetNode(evnt, tableCustom.$el).flag) {
        } else {
          if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
            tablePrivateMethods.preventEvent(evnt, "event.clearCustom", {}, () => {
              if ($xeTable.closeCustom) {
                $xeTable.closeCustom();
              }
            });
          }
        }
      }
      if (actived.row) {
        if (!(editOpts.autoClear === false)) {
          const cell = actived.args.cell;
          if (!cell || !getEventTargetNode(evnt, cell).flag) {
            if ($validTooltip && getEventTargetNode(evnt, $validTooltip.$el).flag) {
            } else if (!internalData._lastCallTime || internalData._lastCallTime + 50 < Date.now()) {
              if (!getEventTargetNode(evnt, document.body, "vxe-table--ignore-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearEdit", actived.args, () => {
                  let isClear;
                  if (editOpts.mode === "row") {
                    const rowTargetNode = getEventTargetNode(evnt, el2, "vxe-body--row");
                    const rowNodeRest = rowTargetNode.flag ? tableMethods.getRowNode(rowTargetNode.targetElem) : null;
                    isClear = rowNodeRest ? !$xeTable.eqRow(rowNodeRest.item, actived.args.row) : false;
                  } else {
                    isClear = !getEventTargetNode(evnt, el2, "col--edit").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el2, "vxe-header--row").flag;
                  }
                  if (!isClear) {
                    isClear = getEventTargetNode(evnt, el2, "vxe-footer--row").flag;
                  }
                  if (!isClear && props.height && !reactData.overflowY) {
                    const bodyWrapperElem = evnt.target;
                    if (hasClass(bodyWrapperElem, "vxe-table--body-wrapper")) {
                      isClear = evnt.offsetY < bodyWrapperElem.clientHeight;
                    }
                  }
                  if (isClear || // 如果点击了当前表格之外
                  !getEventTargetNode(evnt, el2).flag) {
                    setTimeout(() => {
                      $xeTable.handleClearEdit(evnt).then(() => {
                        if (!internalData.isActivated && editRules && validOpts.autoClear) {
                          reactData.validErrorMaps = {};
                        }
                      });
                    });
                  }
                });
              }
            }
          }
        }
      } else if (mouseConfig) {
        if (!getEventTargetNode(evnt, el2).flag && !($xeGrid && getEventTargetNode(evnt, $xeGrid.getRefMaps().refElem.value).flag) && !(tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) && !($xeToolbar && getEventTargetNode(evnt, $xeToolbar.getRefMaps().refElem.value).flag)) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if (areaOpts.autoClear) {
            if ($xeTable.getCellAreas) {
              const cellAreas = $xeTable.getCellAreas();
              if (cellAreas && cellAreas.length && !getEventTargetNode(evnt, document.body, "vxe-table--ignore-areas-clear").flag) {
                tablePrivateMethods.preventEvent(evnt, "event.clearAreas", {}, () => {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                  dispatchEvent2("clear-cell-area-selection", { cellAreas }, evnt);
                });
              }
            }
          }
        }
      }
      if ($xeTable.closeMenu) {
        if (ctxMenuStore.visible && tableMenu && !getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
          $xeTable.closeMenu();
        }
      }
      const isActivated = getEventTargetNode(evnt, $xeGrid ? $xeGrid.getRefMaps().refElem.value : el2).flag;
      if (!isActivated && editRules && validOpts.autoClear) {
        reactData.validErrorMaps = {};
      }
      internalData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const handleGlobalMousewheelEvent = () => {
      tableMethods.closeTooltip();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
    };
    const keydownEvent = (evnt) => {
      const { mouseConfig, keyboardConfig } = props;
      const { filterStore, ctxMenuStore, editStore } = reactData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      const isEsc = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ESCAPE);
      if (isEsc) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          dispatchEvent2("keydown-start", {}, evnt);
          if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (actived.row || filterStore.visible || ctxMenuStore.visible) {
            evnt.stopPropagation();
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          }
          dispatchEvent2("keydown", {}, evnt);
          dispatchEvent2("keydown-end", {}, evnt);
        });
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      if (internalData.isActivated) {
        tablePrivateMethods.preventEvent(evnt, "event.keydown", null, () => {
          const { mouseConfig, keyboardConfig, treeConfig, editConfig, highlightCurrentRow } = props;
          const { ctxMenuStore, editStore, currentRow } = reactData;
          const { afterFullData } = internalData;
          const isMenu = computeIsMenu.value;
          const bodyMenu = computeBodyMenu.value;
          const keyboardOpts = computeKeyboardOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const editOpts = computeEditOpts.value;
          const treeOpts = computeTreeOpts.value;
          const menuList = computeMenuList.value;
          const rowOpts = computeRowOpts.value;
          const { selected, actived } = editStore;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const keyCode = evnt.keyCode;
          const isEsc = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ESCAPE);
          const hasBackspaceKey = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.BACKSPACE);
          const isTab = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.TAB);
          const isEnter = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ENTER);
          const isSpacebar = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.SPACEBAR);
          const isLeftArrow = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_LEFT);
          const isUpArrow = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_UP);
          const isRightArrow = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_RIGHT);
          const isDwArrow = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.ARROW_DOWN);
          const hasDeleteKey = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.DELETE);
          const isF2 = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.F2);
          const isContextMenu = globalEvents3.hasKey(evnt, GLOBAL_EVENT_KEYS2.CONTEXT_MENU);
          const hasMetaKey = evnt.metaKey;
          const hasCtrlKey = evnt.ctrlKey;
          const hasShiftKey = evnt.shiftKey;
          const isAltKey = evnt.altKey;
          const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
          const operCtxMenu = isMenu && ctxMenuStore.visible && (isEnter || isSpacebar || operArrow);
          const isEditStatus = isEnableConf(editConfig) && actived.column && actived.row;
          const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
          if (operCtxMenu) {
            evnt.preventDefault();
            if (ctxMenuStore.showChild && hasChildrenList(ctxMenuStore.selected)) {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selectChild", isLeftArrow, false, ctxMenuStore.selected.children);
            } else {
              $xeTable.moveCtxMenu(evnt, ctxMenuStore, "selected", isRightArrow, true, menuList);
            }
          } else if (keyboardConfig && mouseConfig && mouseOpts.area && $xeTable.handleKeyboardCellAreaEvent) {
            $xeTable.handleKeyboardCellAreaEvent(evnt);
          } else if (isEsc) {
            if ($xeTable.closeMenu) {
              $xeTable.closeMenu();
            }
            tableMethods.closeFilter();
            if (keyboardConfig && keyboardOpts.isEsc) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => $xeTable.handleSelected(params, evnt));
                }
              }
            }
          } else if (isSpacebar && keyboardConfig && keyboardOpts.isChecked && selected.row && selected.column && (selected.column.type === "checkbox" || selected.column.type === "radio")) {
            evnt.preventDefault();
            if (selected.column.type === "checkbox") {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, selected.args);
            } else {
              tablePrivateMethods.triggerRadioRowEvent(evnt, selected.args);
            }
          } else if (isF2 && isEnableConf(editConfig)) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                evnt.preventDefault();
                $xeTable.handleEdit(selected.args, evnt);
              }
            }
          } else if (isContextMenu) {
            internalData._keyCtx = selected.row && selected.column && bodyMenu.length;
            clearTimeout(keyCtxTimeout);
            keyCtxTimeout = setTimeout(() => {
              internalData._keyCtx = false;
            }, 1e3);
          } else if (isEnter && !isAltKey && keyboardConfig && keyboardOpts.isEnter && (selected.row || actived.row || treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow)) {
            const { isLastEnterAppendRow, beforeEnterMethod, enterMethod } = keyboardOpts;
            if (hasCtrlKey) {
              if (actived.row) {
                const params = actived.args;
                $xeTable.handleClearEdit(evnt);
                if (mouseOpts.selected) {
                  nextTick(() => {
                    $xeTable.handleSelected(params, evnt);
                  });
                }
              }
            } else {
              if (selected.row || actived.row) {
                const activeParams = selected.row ? selected.args : actived.args;
                if (hasShiftKey) {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    $xeTable.moveSelected(activeParams, isLeftArrow, true, isRightArrow, false, evnt);
                  }
                } else {
                  if (keyboardOpts.enterToTab) {
                    $xeTable.moveTabSelected(activeParams, hasShiftKey, evnt);
                  } else {
                    const activeRow = selected.row || actived.row;
                    const activeColumn = selected.column || actived.column;
                    const _rowIndex = $xeTable.getVTRowIndex(activeRow);
                    const etrParams = {
                      row: activeRow,
                      rowIndex: $xeTable.getRowIndex(activeRow),
                      $rowIndex: $xeTable.getVMRowIndex(activeRow),
                      _rowIndex,
                      column: activeColumn,
                      columnIndex: $xeTable.getColumnIndex(activeColumn),
                      $columnIndex: $xeTable.getVMColumnIndex(activeColumn),
                      _columnIndex: $xeTable.getVTColumnIndex(activeColumn),
                      $table: $xeTable
                    };
                    if (!beforeEnterMethod || beforeEnterMethod(etrParams) !== false) {
                      if (isLastEnterAppendRow) {
                        if (_rowIndex >= afterFullData.length - 1) {
                          $xeTable.insertAt({}, -1).then(({ row: newRow }) => {
                            $xeTable.scrollToRow(newRow, activeColumn);
                            $xeTable.handleSelected(Object.assign(Object.assign({}, activeParams), { row: newRow }), evnt);
                          });
                          $xeTable.dispatchEvent("enter-append-row", etrParams, evnt);
                          return;
                        }
                      }
                      $xeTable.moveSelected(activeParams, isLeftArrow, false, isRightArrow, true, evnt);
                      if (enterMethod) {
                        enterMethod(etrParams);
                      }
                    }
                  }
                }
              } else if (treeConfig && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
                const childrens = currentRow[childrenField];
                if (childrens && childrens.length) {
                  evnt.preventDefault();
                  const targetRow = childrens[0];
                  const params = {
                    $table: $xeTable,
                    row: targetRow,
                    rowIndex: tableMethods.getRowIndex(targetRow),
                    $rowIndex: tableMethods.getVMRowIndex(targetRow)
                  };
                  tableMethods.setTreeExpand(currentRow, true).then(() => tableMethods.scrollToRow(targetRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
                }
              }
            }
          } else if (operArrow && keyboardConfig && keyboardOpts.isArrow) {
            if (!isEditStatus) {
              if (selected.row && selected.column) {
                $xeTable.moveSelected(selected.args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt);
              } else if ((isUpArrow || isDwArrow) && (rowOpts.isCurrent || highlightCurrentRow)) {
                $xeTable.moveCurrentRow(isUpArrow, isDwArrow, evnt);
              }
            }
          } else if (isTab && keyboardConfig && keyboardOpts.isTab) {
            if (selected.row || selected.column) {
              $xeTable.moveTabSelected(selected.args, hasShiftKey, evnt);
            } else if (actived.row || actived.column) {
              $xeTable.moveTabSelected(actived.args, hasShiftKey, evnt);
            }
          } else if (keyboardConfig && keyboardOpts.isDel && hasDeleteKey && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { delMethod } = keyboardOpts;
              const params = {
                row: selected.row,
                rowIndex: tableMethods.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: tableMethods.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              if (!beforeEditMethod || beforeEditMethod(params)) {
                if (delMethod) {
                  delMethod(params);
                } else {
                  setCellValue(selected.row, selected.column, null);
                }
                tableMethods.updateFooter();
                dispatchEvent2("cell-delete-value", params, evnt);
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && keyboardOpts.isBack && isEnableConf(editConfig) && (selected.row || selected.column)) {
            if (!isEditStatus) {
              const { backMethod } = keyboardOpts;
              if (keyboardOpts.isDel && isEnableConf(editConfig) && (selected.row || selected.column)) {
                const params = {
                  row: selected.row,
                  rowIndex: tableMethods.getRowIndex(selected.row),
                  column: selected.column,
                  columnIndex: tableMethods.getColumnIndex(selected.column),
                  $table: $xeTable,
                  $grid: $xeGrid
                };
                if (!beforeEditMethod || beforeEditMethod(params)) {
                  if (backMethod) {
                    backMethod(params);
                  } else {
                    setCellValue(selected.row, selected.column, null);
                    $xeTable.handleEdit(selected.args, evnt);
                  }
                  dispatchEvent2("cell-backspace-value", params, evnt);
                }
              }
            }
          } else if (hasBackspaceKey && keyboardConfig && treeConfig && keyboardOpts.isBack && (rowOpts.isCurrent || highlightCurrentRow) && currentRow) {
            const { parent: parentRow } = import_xe_utils27.default.findTree(internalData.afterTreeFullData, (item) => item === currentRow, { children: childrenField });
            if (parentRow) {
              evnt.preventDefault();
              const params = {
                row: parentRow,
                rowIndex: tableMethods.getRowIndex(parentRow),
                $rowIndex: tableMethods.getVMRowIndex(parentRow),
                $table: $xeTable,
                $grid: $xeGrid
              };
              tableMethods.setTreeExpand(parentRow, false).then(() => tableMethods.scrollToRow(parentRow)).then(() => tablePrivateMethods.triggerCurrentRowEvent(evnt, params));
            }
          } else if (keyboardConfig && isEnableConf(editConfig) && keyboardOpts.isEdit && !hasCtrlKey && !hasMetaKey && (isSpacebar || keyCode >= 48 && keyCode <= 57 || keyCode >= 65 && keyCode <= 90 || keyCode >= 96 && keyCode <= 111 || keyCode >= 186 && keyCode <= 192 || keyCode >= 219 && keyCode <= 222)) {
            const { editMode, editMethod } = keyboardOpts;
            if (selected.column && selected.row && isEnableConf(selected.column.editRender)) {
              const beforeEditMethod2 = editOpts.beforeEditMethod || editOpts.activeMethod;
              const params = {
                row: selected.row,
                rowIndex: tableMethods.getRowIndex(selected.row),
                column: selected.column,
                columnIndex: tableMethods.getColumnIndex(selected.column),
                $table: $xeTable,
                $grid: $xeGrid
              };
              if (!beforeEditMethod2 || beforeEditMethod2(Object.assign(Object.assign({}, selected.args), { $table: $xeTable, $grid: $xeGrid }))) {
                if (editMethod) {
                  editMethod(params);
                } else {
                  if (editMode !== "insert") {
                    setCellValue(selected.row, selected.column, null);
                  }
                  $xeTable.handleEdit(selected.args, evnt);
                }
              }
            }
          }
          dispatchEvent2("keydown", {}, evnt);
        });
      }
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handlePasteCellAreaEvent) {
            $xeTable.handlePasteCellAreaEvent(evnt);
          }
        }
        dispatchEvent2("paste", {}, evnt);
      }
    };
    const handleGlobalCopyEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCopyCellAreaEvent) {
            $xeTable.handleCopyCellAreaEvent(evnt);
          }
        }
        dispatchEvent2("copy", {}, evnt);
      }
    };
    const handleGlobalCutEvent = (evnt) => {
      const { keyboardConfig, mouseConfig } = props;
      const { editStore, filterStore } = reactData;
      const { isActivated } = internalData;
      const mouseOpts = computeMouseOpts.value;
      const keyboardOpts = computeKeyboardOpts.value;
      const { actived } = editStore;
      if (isActivated && !filterStore.visible) {
        if (!(actived.row || actived.column)) {
          if (keyboardConfig && keyboardOpts.isClip && mouseConfig && mouseOpts.area && $xeTable.handleCutCellAreaEvent) {
            $xeTable.handleCutCellAreaEvent(evnt);
          }
        }
        dispatchEvent2("cut", {}, evnt);
      }
    };
    const handleGlobalResizeEvent = () => {
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      const el2 = refElem.value;
      if (!el2 || !el2.clientWidth) {
        return nextTick();
      }
      tableMethods.recalculate(true);
      tableMethods.updateCellAreas();
    };
    const handleTargetEnterEvent = (isClear) => {
      const $tooltip = refTooltip.value;
      clearTimeout(internalData.tooltipTimeout);
      if (isClear) {
        tableMethods.closeTooltip();
      } else {
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(true);
        }
      }
    };
    const clearRowDropOrigin = () => {
      const el2 = refElem.value;
      if (el2) {
        const clss = "row--drag-origin";
        import_xe_utils27.default.arrayEach(el2.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateRowDropOrigin = (row) => {
      const el2 = refElem.value;
      if (el2) {
        const clss = "row--drag-origin";
        const rowid = getRowid($xeTable, row);
        import_xe_utils27.default.arrayEach(el2.querySelectorAll(`[rowid="${rowid}"]`), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const updateRowDropTipContent = (tdEl) => {
      const { dragConfig } = props;
      const { dragRow } = reactData;
      const rowDragOpts = computeRowDragOpts.value;
      const { tooltipMethod } = rowDragOpts;
      const rTooltipMethod = tooltipMethod || (dragConfig ? dragConfig.rowTooltipMethod : null);
      let tipContent = "";
      if (rTooltipMethod) {
        tipContent = `${rTooltipMethod({
          row: dragRow
        }) || ""}`;
      } else {
        tipContent = getI18n10("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const updateColDropOrigin = (column) => {
      const el2 = refElem.value;
      if (el2) {
        const colQuerys = [];
        import_xe_utils27.default.eachTree([column], (item) => {
          colQuerys.push(`[colid="${item.id}"]`);
        });
        const clss = "col--drag-origin";
        import_xe_utils27.default.arrayEach(el2.querySelectorAll(colQuerys.join(",")), (elem) => {
          addClass(elem, clss);
        });
      }
    };
    const clearColDropOrigin = () => {
      const el2 = refElem.value;
      if (el2) {
        const clss = "col--drag-origin";
        import_xe_utils27.default.arrayEach(el2.querySelectorAll(`.${clss}`), (elem) => {
          elem.draggable = false;
          removeClass(elem, clss);
        });
      }
    };
    const updateColDropTipContent = (tdEl) => {
      const { dragCol } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const { tooltipMethod } = columnDragOpts;
      let tipContent = "";
      if (tooltipMethod) {
        tipContent = `${tooltipMethod({
          column: dragCol
        }) || ""}`;
      } else {
        tipContent = getI18n10("vxe.table.dragTip", [tdEl.textContent || ""]);
      }
      reactData.dragTipText = tipContent;
    };
    const showDropTip = (evnt, trEl, thEl, showLine, dragPos) => {
      const el2 = refElem.value;
      if (!el2) {
        return;
      }
      const { scrollbarWidth, scrollbarHeight } = reactData;
      const { prevDragToChild } = internalData;
      const wrapperRect = el2.getBoundingClientRect();
      if (trEl) {
        const rdLineEl = refDragRowLineElem.value;
        if (rdLineEl) {
          if (showLine) {
            const trRect = trEl.getBoundingClientRect();
            rdLineEl.style.display = "block";
            rdLineEl.style.top = `${Math.max(1, trRect.y - wrapperRect.y)}px`;
            rdLineEl.style.height = `${trRect.height}px`;
            rdLineEl.style.width = `${wrapperRect.width - scrollbarWidth}px`;
            rdLineEl.setAttribute("drag-pos", dragPos);
            rdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            rdLineEl.style.display = "";
          }
        }
      } else if (thEl) {
        const cdLineEl = refDragColLineElem.value;
        if (cdLineEl) {
          if (showLine) {
            const thRect = thEl.getBoundingClientRect();
            const offsetTop = Math.max(0, thRect.y - wrapperRect.y);
            cdLineEl.style.display = "block";
            cdLineEl.style.top = `${offsetTop}px`;
            cdLineEl.style.left = `${Math.max(1, thRect.x - wrapperRect.x)}px`;
            cdLineEl.style.width = `${thRect.width}px`;
            if (prevDragToChild) {
              cdLineEl.style.height = `${thRect.height}px`;
            } else {
              cdLineEl.style.height = `${wrapperRect.height - offsetTop - scrollbarHeight}px`;
            }
            cdLineEl.setAttribute("drag-pos", dragPos);
            cdLineEl.setAttribute("drag-to-child", prevDragToChild ? "y" : "n");
          } else {
            cdLineEl.style.display = "";
          }
        }
      }
      const rdTipEl = refDragTipElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "block";
        rdTipEl.style.top = `${Math.min(el2.clientHeight - el2.scrollTop - rdTipEl.clientHeight, evnt.clientY - wrapperRect.y)}px`;
        rdTipEl.style.left = `${Math.min(el2.clientWidth - el2.scrollLeft - rdTipEl.clientWidth - 16, evnt.clientX - wrapperRect.x)}px`;
        rdTipEl.setAttribute("drag-status", showLine ? prevDragToChild ? "sub" : "normal" : "disabled");
      }
    };
    const hideDropTip = () => {
      const rdTipEl = refDragTipElem.value;
      const rdLineEl = refDragRowLineElem.value;
      const cdLineEl = refDragColLineElem.value;
      if (rdTipEl) {
        rdTipEl.style.display = "";
      }
      if (rdLineEl) {
        rdLineEl.style.display = "";
      }
      if (cdLineEl) {
        cdLineEl.style.display = "";
      }
    };
    const handleTooltip = (evnt, cell, overflowElem, tipElem, params) => {
      params.cell = cell;
      const { tooltipStore } = reactData;
      const tooltipOpts = computeTooltipOpts.value;
      const { column, row } = params;
      const { showAll, contentMethod } = tooltipOpts;
      const customContent = contentMethod ? contentMethod(params) : null;
      const useCustom = contentMethod && !import_xe_utils27.default.eqNull(customContent);
      const content = useCustom ? customContent : import_xe_utils27.default.toString(column.type === "html" ? overflowElem.innerText : overflowElem.textContent).trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      if (content && (showAll || useCustom || isCellOverflow)) {
        Object.assign(tooltipStore, {
          row,
          column,
          visible: true,
          currOpts: {}
        });
        nextTick(() => {
          const $tooltip = refTooltip.value;
          if ($tooltip && $tooltip.open) {
            $tooltip.open(isCellOverflow ? overflowElem : tipElem || overflowElem, formatText(content));
          }
        });
      }
      return nextTick();
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if ($xeGrid) {
          return $xeGrid.callSlot(slotFunc, params);
        }
        if (import_xe_utils27.default.isFunction(slotFunc)) {
          return getSlotVNs(slotFunc(params));
        }
      }
      return [];
    };
    tablePrivateMethods = {
      getSetupOptions() {
        return getConfig4();
      },
      updateAfterDataIndex,
      callSlot,
      /**
       * 获取父容器元素
       */
      getParentElem() {
        const el2 = refElem.value;
        if ($xeGrid) {
          const gridEl = $xeGrid.getRefMaps().refElem.value;
          return gridEl ? gridEl.parentNode : null;
        }
        return el2 ? el2.parentNode : null;
      },
      /**
       * 获取父容器的高度
       */
      getParentHeight() {
        const { height } = props;
        const el2 = refElem.value;
        if (el2) {
          const parentElem = el2.parentNode;
          const parentPaddingSize = height === "100%" || height === "auto" ? getPaddingTopBottomSize(parentElem) : 0;
          return Math.floor($xeGrid ? $xeGrid.getParentHeight() : import_xe_utils27.default.toNumber(getComputedStyle(parentElem).height) - parentPaddingSize);
        }
        return 0;
      },
      /**
       * 获取需要排除的高度
       * 但渲染表格高度时，需要排除工具栏或分页等相关组件的高度
       * 如果存在表尾合计滚动条，则需要排除滚动条高度
       */
      getExcludeHeight() {
        return $xeGrid ? $xeGrid.getExcludeHeight() : 0;
      },
      /**
       * 定义行数据中的列属性，如果不存在则定义
       * @param {Row} records 行数据
       */
      defineField(records) {
        const { treeConfig } = props;
        const expandOpts = computeExpandOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rowkey = getRowkey($xeTable);
        if (!import_xe_utils27.default.isArray(records)) {
          records = [records];
        }
        return records.map((record) => {
          internalData.tableFullColumn.forEach((column) => {
            const { field, editRender } = column;
            if (field && !import_xe_utils27.default.has(record, field) && !record[field]) {
              let cellValue = null;
              if (editRender) {
                const { defaultValue } = editRender;
                if (import_xe_utils27.default.isFunction(defaultValue)) {
                  cellValue = defaultValue({ column });
                } else if (!import_xe_utils27.default.isUndefined(defaultValue)) {
                  cellValue = defaultValue;
                }
              }
              import_xe_utils27.default.set(record, field, cellValue);
            }
          });
          const otherFields = [radioOpts.labelField, checkboxOpts.checkField, checkboxOpts.labelField, expandOpts.labelField];
          otherFields.forEach((key) => {
            if (key && eqEmptyValue(import_xe_utils27.default.get(record, key))) {
              import_xe_utils27.default.set(record, key, null);
            }
          });
          if (treeConfig && treeOpts.lazy && import_xe_utils27.default.isUndefined(record[childrenField])) {
            record[childrenField] = null;
          }
          if (eqEmptyValue(import_xe_utils27.default.get(record, rowkey))) {
            import_xe_utils27.default.set(record, rowkey, getRowUniqueId());
          }
          return record;
        });
      },
      handleTableData(force) {
        const { scrollYLoad } = reactData;
        const { scrollYStore, fullDataRowIdData } = internalData;
        let fullList = internalData.afterFullData;
        if (force) {
          updateAfterFullData();
          fullList = handleVirtualTreeToList();
        }
        const tableData = scrollYLoad ? fullList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullList.slice(0);
        tableData.forEach((row, $index) => {
          const rowid = getRowid($xeTable, row);
          const rest = fullDataRowIdData[rowid];
          if (rest) {
            rest.$index = $index;
          }
        });
        reactData.tableData = tableData;
        return nextTick();
      },
      /**
       * 更新数据行的 Map
       * 牺牲数据组装的耗时，用来换取使用过程中的流畅
       */
      cacheRowMap(isSource) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        const { fullAllDataRowIdData, tableFullData, tableFullTreeData } = internalData;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const hasChildField = treeOpts.hasChild || treeOpts.hasChildField;
        const rowkey = getRowkey($xeTable);
        const isLazy = treeConfig && treeOpts.lazy;
        const fullAllDataRowIdMaps = {};
        const fullDataRowIdMaps = {};
        const handleRow = (row, index2, items, path, parent, nodes) => {
          let rowid = getRowid($xeTable, row);
          const seq = treeConfig && path ? toTreePathSeq(path) : index2 + 1;
          const level = nodes ? nodes.length - 1 : 0;
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            import_xe_utils27.default.set(row, rowkey, rowid);
          }
          if (isLazy && row[hasChildField] && import_xe_utils27.default.isUndefined(row[childrenField])) {
            row[childrenField] = null;
          }
          let cacheItem = fullAllDataRowIdData[rowid];
          if (!cacheItem) {
            cacheItem = { row, rowid, seq, index: -1, _index: -1, $index: -1, items, parent, level, height: 0 };
          }
          cacheItem.row = row;
          cacheItem.items = items;
          cacheItem.parent = parent;
          cacheItem.level = level;
          cacheItem.index = treeConfig && parent ? -1 : index2;
          if (isSource) {
            fullDataRowIdMaps[rowid] = cacheItem;
          }
          fullAllDataRowIdMaps[rowid] = cacheItem;
        };
        if (isSource) {
          internalData.fullDataRowIdData = fullDataRowIdMaps;
        }
        internalData.fullAllDataRowIdData = fullAllDataRowIdMaps;
        if (treeConfig) {
          import_xe_utils27.default.eachTree(tableFullTreeData, handleRow, { children: childrenField });
        } else {
          tableFullData.forEach(handleRow);
        }
      },
      cacheSourceMap(fullData) {
        const { treeConfig } = props;
        const treeOpts = computeTreeOpts.value;
        let { sourceDataRowIdData } = internalData;
        const sourceData = import_xe_utils27.default.clone(fullData, true);
        const rowkey = getRowkey($xeTable);
        sourceDataRowIdData = internalData.sourceDataRowIdData = {};
        const handleSourceRow = (row) => {
          let rowid = getRowid($xeTable, row);
          if (eqEmptyValue(rowid)) {
            rowid = getRowUniqueId();
            import_xe_utils27.default.set(row, rowkey, rowid);
          }
          sourceDataRowIdData[rowid] = row;
        };
        if (treeConfig) {
          const childrenField = treeOpts.children || treeOpts.childrenField;
          import_xe_utils27.default.eachTree(sourceData, handleSourceRow, { children: treeOpts.transform ? treeOpts.mapChildrenField : childrenField });
        } else {
          sourceData.forEach(handleSourceRow);
        }
        internalData.tableSourceData = sourceData;
      },
      /**
       * 指定列宽的列进行拆分
       */
      analyColumnWidth() {
        const { tableFullColumn } = internalData;
        const columnOpts = computeColumnOpts.value;
        const { width: defaultWidth, minWidth: defaultMinWidth } = columnOpts;
        const resizeList = [];
        const pxList = [];
        const pxMinList = [];
        const autoMinList = [];
        const scaleList = [];
        const scaleMinList = [];
        const autoList = [];
        const remainList = [];
        tableFullColumn.forEach((column) => {
          if (defaultWidth && !column.width) {
            column.width = defaultWidth;
          }
          if (defaultMinWidth && !column.minWidth) {
            column.minWidth = defaultMinWidth;
          }
          if (column.visible) {
            if (column.resizeWidth) {
              resizeList.push(column);
            } else if (column.width === "auto") {
              autoList.push(column);
            } else if (isPx(column.width)) {
              pxList.push(column);
            } else if (isScale(column.width)) {
              scaleList.push(column);
            } else if (isPx(column.minWidth)) {
              pxMinList.push(column);
            } else if (column.minWidth === "auto") {
              autoMinList.push(column);
            } else if (isScale(column.minWidth)) {
              scaleMinList.push(column);
            } else {
              remainList.push(column);
            }
          }
        });
        Object.assign(reactData.columnStore, { resizeList, pxList, pxMinList, autoMinList, scaleList, scaleMinList, autoList, remainList });
      },
      saveCustomStore(type) {
        const { customConfig } = props;
        const tableId = computeTableId.value;
        const customOpts = computeCustomOpts.value;
        const { updateStore, storage } = customOpts;
        const isAllCustom = storage === true;
        const storageOpts = isAllCustom ? {} : Object.assign({}, storage || {});
        const isCustomResizable = isAllCustom || storageOpts.resizable;
        const isCustomVisible = isAllCustom || storageOpts.visible;
        const isCustomFixed = isAllCustom || storageOpts.fixed;
        const isCustomSort = isAllCustom || storageOpts.sort;
        if ((customConfig ? isEnableConf(customOpts) : customOpts.enabled) && (isCustomResizable || isCustomVisible || isCustomFixed || isCustomSort)) {
          if (!tableId) {
            errLog("vxe.error.reqProp", ["id"]);
            return nextTick();
          }
          const storeData2 = type === "reset" ? {
            resizableData: {},
            sortData: {},
            visibleData: {},
            fixedData: {}
          } : tableMethods.getCustomStoreData();
          if (updateStore) {
            return updateStore({
              id: tableId,
              type,
              storeData: storeData2
            });
          } else {
            setCustomStorageMap(tableId, type === "reset" ? null : storeData2);
          }
        }
        return nextTick();
      },
      handleCustom() {
        const { mouseConfig } = props;
        if (mouseConfig) {
          if ($xeTable.clearSelected) {
            $xeTable.clearSelected();
          }
          if ($xeTable.clearCellAreas) {
            $xeTable.clearCellAreas();
            $xeTable.clearCopyCellArea();
          }
        }
        tablePrivateMethods.analyColumnWidth();
        return tableMethods.refreshColumn(true);
      },
      handleUpdateDataQueue() {
        reactData.upDataFlag++;
      },
      handleRefreshColumnQueue() {
        reactData.reColumnFlag++;
      },
      preventEvent(evnt, type, args, next, end) {
        let evntList = interceptor3.get(type);
        if (!evntList.length && type === "event.clearEdit") {
          evntList = interceptor3.get("event.clearActived");
          if (true) {
            if (evntList.length) {
              warnLog("vxe.error.delEvent", ["event.clearActived", "event.clearEdit"]);
            }
          }
        }
        let rest;
        if (!evntList.some((func) => func(Object.assign({ $grid: $xeGrid, $table: $xeTable, $event: evnt }, args)) === false)) {
          if (next) {
            rest = next();
          }
        }
        if (end) {
          end();
        }
        return rest;
      },
      updateCheckboxStatus() {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
        const selectRowMaps = Object.assign({}, selectCheckboxMaps);
        const halfRowMaps = Object.assign({}, treeIndeterminateMaps);
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const { afterTreeFullData } = internalData;
        if (checkStrictly) {
          return;
        }
        if (treeConfig) {
          const childRowMaps = {};
          const childRowList = [];
          import_xe_utils27.default.eachTree(afterTreeFullData, (row) => {
            const rowid = getRowid($xeTable, row);
            const childList = row[transform2 ? mapChildrenField : childrenField];
            if (childList && childList.length && !childRowMaps[rowid]) {
              childRowMaps[rowid] = 1;
              childRowList.unshift([row, rowid, childList]);
            }
          }, { children: transform2 ? mapChildrenField : childrenField });
          childRowList.forEach((vals) => {
            const row = vals[0];
            const rowid = vals[1];
            const childList = vals[2];
            let sLen = 0;
            let hLen = 0;
            let vLen = 0;
            childList.forEach(checkMethod ? (item) => {
              const childRowid = getRowid($xeTable, item);
              const isSelect = checkField ? import_xe_utils27.default.get(item, checkField) : selectRowMaps[childRowid];
              if (checkMethod({ row: item })) {
                if (isSelect) {
                  sLen++;
                } else if (halfRowMaps[childRowid]) {
                  hLen++;
                }
                vLen++;
              } else {
                if (isSelect) {
                  sLen++;
                } else if (halfRowMaps[childRowid]) {
                  hLen++;
                }
              }
            } : (item) => {
              const childRowid = getRowid($xeTable, item);
              const isSelect = checkField ? import_xe_utils27.default.get(item, checkField) : selectRowMaps[childRowid];
              if (isSelect) {
                sLen++;
              } else if (halfRowMaps[childRowid]) {
                hLen++;
              }
              vLen++;
            });
            const isSelected = sLen >= vLen;
            const halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
            if (checkField) {
              import_xe_utils27.default.get(row, checkField, isSelected);
            }
            if (isSelected) {
              if (!checkField) {
                selectRowMaps[rowid] = row;
              }
              if (halfRowMaps[rowid]) {
                delete halfRowMaps[rowid];
              }
            } else {
              if (!checkField) {
                if (selectRowMaps[rowid]) {
                  delete selectRowMaps[rowid];
                }
              }
              if (halfSelect) {
                halfRowMaps[rowid] = row;
              } else {
                if (halfRowMaps[rowid]) {
                  delete halfRowMaps[rowid];
                }
              }
            }
          });
        }
        reactData.selectCheckboxMaps = selectRowMaps;
        reactData.treeIndeterminateMaps = halfRowMaps;
      },
      updateAllCheckboxStatus() {
        const { treeConfig } = props;
        const { selectCheckboxMaps, treeIndeterminateMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkMethod } = checkboxOpts;
        const { afterFullData, afterTreeFullData } = internalData;
        let sLen = 0;
        let hLen = 0;
        let vLen = 0;
        const rootList = treeConfig ? afterTreeFullData : afterFullData;
        rootList.forEach(checkMethod ? (row) => {
          const childRowid = getRowid($xeTable, row);
          const selected = checkField ? import_xe_utils27.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (checkMethod({ row })) {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateMaps[childRowid]) {
              hLen++;
            }
            vLen++;
          } else {
            if (selected) {
              sLen++;
            } else if (treeIndeterminateMaps[childRowid]) {
              hLen++;
            }
          }
        } : (row) => {
          const childRowid = getRowid($xeTable, row);
          const selected = checkField ? import_xe_utils27.default.get(row, checkField) : selectCheckboxMaps[childRowid];
          if (selected) {
            sLen++;
          } else if (treeIndeterminateMaps[childRowid]) {
            hLen++;
          }
          vLen++;
        });
        const isSelected = sLen >= vLen;
        const halfSelect = !isSelected && (sLen >= 1 || hLen >= 1);
        reactData.isAllSelected = isSelected;
        reactData.isIndeterminate = halfSelect;
      },
      checkSelectionStatus() {
        $xeTable.updateCheckboxStatus();
        $xeTable.updateAllCheckboxStatus();
      },
      /**
       * 切换选中
       * 多选，行选中事件
       */
      handleBatchSelectRows(rows, checked, isForce) {
        const { treeConfig } = props;
        const { selectCheckboxMaps } = reactData;
        const selectRowMaps = Object.assign({}, selectCheckboxMaps);
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, checkStrictly, checkMethod } = checkboxOpts;
        const indeterminateField = checkboxOpts.indeterminateField || checkboxOpts.halfField;
        if (checkField) {
          if (treeConfig && !checkStrictly) {
            import_xe_utils27.default.eachTree(rows, (row) => {
              if (isForce || (!checkMethod || checkMethod({ row }))) {
                import_xe_utils27.default.set(row, checkField, checked);
                if (indeterminateField) {
                  import_xe_utils27.default.set(row, indeterminateField, false);
                }
                handleCheckboxReserveRow(row, checked);
              }
            }, { children: transform2 ? mapChildrenField : childrenField });
            reactData.selectCheckboxMaps = selectRowMaps;
            return;
          } else {
            rows.forEach((row) => {
              if (isForce || (!checkMethod || checkMethod({ row }))) {
                import_xe_utils27.default.set(row, checkField, checked);
                handleCheckboxReserveRow(row, checked);
              }
            });
          }
          reactData.selectCheckboxMaps = selectRowMaps;
          return;
        }
        if (treeConfig && !checkStrictly) {
          import_xe_utils27.default.eachTree(rows, (row) => {
            const rowid = getRowid($xeTable, row);
            if (isForce || (!checkMethod || checkMethod({ row }))) {
              if (checked) {
                selectRowMaps[rowid] = row;
              } else {
                if (selectRowMaps[rowid]) {
                  delete selectRowMaps[rowid];
                }
              }
              handleCheckboxReserveRow(row, checked);
            }
          }, { children: transform2 ? mapChildrenField : childrenField });
          reactData.selectCheckboxMaps = selectRowMaps;
          return;
        }
        rows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (isForce || (!checkMethod || checkMethod({ row }))) {
            if (checked) {
              if (!selectRowMaps[rowid]) {
                selectRowMaps[rowid] = row;
              }
            } else {
              if (selectRowMaps[rowid]) {
                delete selectRowMaps[rowid];
              }
            }
            handleCheckboxReserveRow(row, checked);
          }
        });
        reactData.selectCheckboxMaps = selectRowMaps;
      },
      /**
       * 即将移除
       * @deprecated
       */
      handleSelectRow({ row }, checked, isForce) {
        $xeTable.handleBatchSelectRows([row], checked, isForce);
      },
      triggerHeaderTitleEvent(evnt, iconParams, params) {
        const tipContent = iconParams.content || iconParams.message;
        if (tipContent) {
          const { tooltipStore } = reactData;
          const { column } = params;
          const content = getFuncText(tipContent);
          handleTargetEnterEvent(true);
          tooltipStore.row = null;
          tooltipStore.column = column;
          tooltipStore.visible = true;
          tooltipStore.currOpts = iconParams;
          nextTick(() => {
            const $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.open) {
              $tooltip.open(evnt.currentTarget, content);
            }
          });
        }
      },
      /**
       * 触发表头 tooltip 事件
       */
      triggerHeaderTooltipEvent(evnt, params) {
        const { tooltipStore } = reactData;
        const { column } = params;
        const titleElem = evnt.currentTarget;
        handleTargetEnterEvent(true);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, titleElem, titleElem, null, params);
        }
      },
      /**
       * 触发单元格 tooltip 事件
       */
      triggerBodyTooltipEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const { tooltipStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const { row, column } = params;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || tooltipStore.row !== row);
        if (column.editRender && isEnableConf(editConfig)) {
          if (editOpts.mode === "row" && actived.row === row) {
            return;
          }
          if (actived.row === row && actived.column === column) {
            return;
          }
        }
        if (tooltipStore.column !== column || tooltipStore.row !== row || !tooltipStore.visible) {
          let overflowElem;
          let tipElem;
          if (column.treeNode) {
            overflowElem = cell.querySelector(".vxe-tree-cell");
            if (column.type === "html") {
              tipElem = cell.querySelector(".vxe-cell--html");
            }
          } else {
            tipElem = cell.querySelector(column.type === "html" ? ".vxe-cell--html" : ".vxe-cell--label");
          }
          handleTooltip(evnt, cell, overflowElem || cell.children[0], tipElem, params);
        }
      },
      /**
       * 触发表尾 tooltip 事件
       */
      triggerFooterTooltipEvent(evnt, params) {
        const { column } = params;
        const { tooltipStore } = reactData;
        const cell = evnt.currentTarget;
        handleTargetEnterEvent(tooltipStore.column !== column || !!tooltipStore.row);
        if (tooltipStore.column !== column || !tooltipStore.visible) {
          handleTooltip(evnt, cell, cell.querySelector(".vxe-cell--item") || cell.children[0], null, params);
        }
      },
      handleTargetLeaveEvent() {
        const tooltipOpts = computeTooltipOpts.value;
        let $tooltip = refTooltip.value;
        if ($tooltip && $tooltip.setActived) {
          $tooltip.setActived(false);
        }
        if (tooltipOpts.enterable) {
          internalData.tooltipTimeout = setTimeout(() => {
            $tooltip = refTooltip.value;
            if ($tooltip && $tooltip.isActived && !$tooltip.isActived()) {
              tableMethods.closeTooltip();
            }
          }, tooltipOpts.leaveDelay);
        } else {
          tableMethods.closeTooltip();
        }
      },
      triggerHeaderCellClickEvent(evnt, params) {
        const { _lastResizeTime } = internalData;
        const sortOpts = computeSortOpts.value;
        const columnOpts = computeColumnOpts.value;
        const { column } = params;
        const cell = evnt.currentTarget;
        const triggerResizable = _lastResizeTime && _lastResizeTime > Date.now() - 300;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        if (sortOpts.trigger === "cell" && !(triggerResizable || triggerSort || triggerFilter)) {
          tablePrivateMethods.triggerSortEvent(evnt, column, getNextSortOrder(column));
        }
        dispatchEvent2("header-cell-click", Object.assign({ triggerResizable, triggerSort, triggerFilter, cell }, params), evnt);
        if (columnOpts.isCurrent || props.highlightCurrentColumn) {
          tablePrivateMethods.triggerCurrentColumnEvent(evnt, params);
        }
      },
      triggerHeaderCellDblclickEvent(evnt, params) {
        dispatchEvent2("header-cell-dblclick", Object.assign({ cell: evnt.currentTarget }, params), evnt);
      },
      /**
       * 列点击事件
       * 如果是单击模式，则激活为编辑状态
       * 如果是双击模式，则单击后选中状态
       */
      triggerCellClickEvent(evnt, params) {
        const { highlightCurrentRow, editConfig } = props;
        const { editStore } = reactData;
        const expandOpts = computeExpandOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const keyboardOpts = computeKeyboardOpts.value;
        const rowOpts = computeRowOpts.value;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const cell = evnt.currentTarget;
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        params = Object.assign({ cell, triggerRadio, triggerCheckbox, triggerTreeNode, triggerExpandNode }, params);
        if (!triggerCheckbox && !triggerRadio) {
          if (!triggerExpandNode && (expandOpts.trigger === "row" || isExpandType && expandOpts.trigger === "cell")) {
            tablePrivateMethods.triggerRowExpandEvent(evnt, params);
          }
          if (treeOpts.trigger === "row" || treeNode && treeOpts.trigger === "cell") {
            tablePrivateMethods.triggerTreeExpandEvent(evnt, params);
          }
        }
        if (!triggerTreeNode) {
          if (!triggerExpandNode) {
            if (rowOpts.isCurrent || highlightCurrentRow) {
              if (!triggerCheckbox && !triggerRadio) {
                tablePrivateMethods.triggerCurrentRowEvent(evnt, params);
              }
            }
            if (!triggerRadio && (radioOpts.trigger === "row" || isRadioType && radioOpts.trigger === "cell")) {
              tablePrivateMethods.triggerRadioRowEvent(evnt, params);
            }
            if (!triggerCheckbox && (checkboxOpts.trigger === "row" || isCheckboxType && checkboxOpts.trigger === "cell")) {
              tablePrivateMethods.handleToggleCheckRowEvent(evnt, params);
            }
          }
          if (isEnableConf(editConfig)) {
            if (keyboardOpts.arrowCursorLock && evnt && editOpts.mode === "cell" && evnt.target && /^input|textarea$/i.test(evnt.target.tagName)) {
              focused.column = column;
              focused.row = row;
            }
            if (editOpts.trigger === "manual") {
              if (actived.args && actived.row === row && column !== actived.column) {
                handleChangeCell(evnt, params);
              }
            } else if (!actived.args || row !== actived.row || column !== actived.column) {
              if (editOpts.trigger === "click") {
                handleChangeCell(evnt, params);
              } else if (editOpts.trigger === "dblclick") {
                if (editOpts.mode === "row" && actived.row === row) {
                  handleChangeCell(evnt, params);
                }
              }
            }
          }
        }
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (actived.row && actived.column) {
            if (editOpts.mode === "row") {
              if (!$xeTable.eqRow(actived.row, row)) {
                $xeTable.handleClearEdit(evnt);
              }
            } else if (editOpts.mode === "cell") {
              if (!$xeTable.eqRow(actived.row, row) || actived.column.id !== column.id) {
                $xeTable.handleClearEdit(evnt);
              }
            }
          }
        }
        dispatchEvent2("cell-click", params, evnt);
      },
      /**
       * 列双击点击事件
       * 如果是双击模式，则激活为编辑状态
       */
      triggerCellDblclickEvent(evnt, params) {
        const { editConfig } = props;
        const { editStore } = reactData;
        const editOpts = computeEditOpts.value;
        const { actived } = editStore;
        const cell = evnt.currentTarget;
        params = Object.assign({ cell }, params);
        if (isEnableConf(editConfig) && editOpts.trigger === "dblclick") {
          if (!actived.args || evnt.currentTarget !== actived.args.cell) {
            if (editOpts.mode === "row") {
              checkValidate("blur").catch((e16) => e16).then(() => {
                $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e16) => e16);
              });
            } else if (editOpts.mode === "cell") {
              $xeTable.handleEdit(params, evnt).then(() => checkValidate("change")).catch((e16) => e16);
            }
          }
        }
        dispatchEvent2("cell-dblclick", params, evnt);
      },
      handleToggleCheckRowEvent(evnt, params) {
        const { selectCheckboxMaps } = reactData;
        const checkboxOpts = computeCheckboxOpts.value;
        const { checkField, trigger } = checkboxOpts;
        const { row } = params;
        if (trigger === "manual") {
          return;
        }
        let checked = false;
        if (checkField) {
          checked = !import_xe_utils27.default.get(row, checkField);
        } else {
          checked = !selectCheckboxMaps[getRowid($xeTable, row)];
        }
        if (evnt) {
          tablePrivateMethods.triggerCheckRowEvent(evnt, params, checked);
        } else {
          tablePrivateMethods.handleBatchSelectRows([row], checked);
          tablePrivateMethods.checkSelectionStatus();
        }
      },
      triggerCheckRowEvent(evnt, params, checked) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { row } = params;
        const { afterFullData } = internalData;
        const { checkMethod, trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        if (checkboxOpts.isShiftKey && evnt.shiftKey && !props.treeConfig) {
          const checkboxRecords = tableMethods.getCheckboxRecords();
          if (checkboxRecords.length) {
            const firstRow = checkboxRecords[0];
            const _rowIndex = tableMethods.getVTRowIndex(row);
            const _firstRowIndex = tableMethods.getVTRowIndex(firstRow);
            if (_rowIndex !== _firstRowIndex) {
              tableMethods.setAllCheckboxRow(false);
              const rangeRows = _rowIndex < _firstRowIndex ? afterFullData.slice(_rowIndex, _firstRowIndex + 1) : afterFullData.slice(_firstRowIndex, _rowIndex + 1);
              handleCheckedCheckboxRow(rangeRows, true, false);
              dispatchEvent2("checkbox-range-select", Object.assign({ rangeRecords: rangeRows }, params), evnt);
              return;
            }
          }
        }
        if (!checkMethod || checkMethod({ row })) {
          tablePrivateMethods.handleBatchSelectRows([row], checked);
          tablePrivateMethods.checkSelectionStatus();
          dispatchEvent2("checkbox-change", Object.assign({
            records: tableMethods.getCheckboxRecords(),
            reserves: tableMethods.getCheckboxReserveRecords(),
            indeterminates: tableMethods.getCheckboxIndeterminateRecords(),
            checked
          }, params), evnt);
        }
      },
      /**
       * 多选，选中所有事件
       */
      triggerCheckAllEvent(evnt, value) {
        const checkboxOpts = computeCheckboxOpts.value;
        const { trigger } = checkboxOpts;
        if (trigger === "manual") {
          return;
        }
        if (evnt) {
          evnt.stopPropagation();
        }
        handleCheckAllEvent(evnt, value);
      },
      /**
       * 单选，行选中事件
       */
      triggerRadioRowEvent(evnt, params) {
        const { selectRadioRow: oldValue } = reactData;
        const { row } = params;
        const radioOpts = computeRadioOpts.value;
        const { trigger } = radioOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        let newValue = row;
        let isChange = oldValue !== newValue;
        if (isChange) {
          handleCheckedRadioRow(newValue);
        } else if (!radioOpts.strict) {
          isChange = oldValue === newValue;
          if (isChange) {
            newValue = null;
            tableMethods.clearRadioRow();
          }
        }
        if (isChange) {
          dispatchEvent2("radio-change", Object.assign({ oldValue, newValue }, params), evnt);
        }
      },
      triggerCurrentColumnEvent(evnt, params) {
        const columnOpts = computeColumnOpts.value;
        const { currentMethod } = columnOpts;
        const { column } = params;
        if (!currentMethod || currentMethod({ column })) {
          tableMethods.setCurrentColumn(column);
        }
      },
      triggerCurrentRowEvent(evnt, params) {
        const { currentRow: oldValue } = reactData;
        const rowOpts = computeRowOpts.value;
        const { currentMethod } = rowOpts;
        const { row: newValue } = params;
        const isChange = oldValue !== newValue;
        if (!currentMethod || currentMethod({ row: newValue })) {
          tableMethods.setCurrentRow(newValue);
          if (isChange) {
            dispatchEvent2("current-change", Object.assign({ oldValue, newValue }, params), evnt);
          }
        }
      },
      /**
       * 展开行事件
       */
      triggerRowExpandEvent(evnt, params) {
        const { rowExpandLazyLoadedMaps, expandColumn: column } = reactData;
        const expandOpts = computeExpandOpts.value;
        const { row } = params;
        const { lazy, trigger } = expandOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !rowExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isRowExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setRowExpand(row, expanded);
          dispatchEvent2("toggle-row-expand", {
            expanded,
            column,
            columnIndex,
            $columnIndex,
            row,
            rowIndex: tableMethods.getRowIndex(row),
            $rowIndex: tableMethods.getVMRowIndex(row)
          }, evnt);
        }
      },
      /**
       * 展开树节点事件
       */
      triggerTreeExpandEvent(evnt, params) {
        const { treeExpandLazyLoadedMaps } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { row, column } = params;
        const { lazy, trigger } = treeOpts;
        if (trigger === "manual") {
          return;
        }
        evnt.stopPropagation();
        const rowid = getRowid($xeTable, row);
        if (!lazy || !treeExpandLazyLoadedMaps[rowid]) {
          const expanded = !tableMethods.isTreeExpandByRow(row);
          const columnIndex = tableMethods.getColumnIndex(column);
          const $columnIndex = tableMethods.getVMColumnIndex(column);
          tableMethods.setTreeExpand(row, expanded);
          dispatchEvent2("toggle-tree-expand", { expanded, column, columnIndex, $columnIndex, row }, evnt);
        }
      },
      handleColumnSortEvent(evnt, column) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const { field, sortable } = column;
        if (sortable) {
          const params = { $table: $xeTable, $event: evnt, column, field, property: field, order: column.order, sortList: tableMethods.getSortColumns(), sortTime: column.sortTime };
          if (mouseConfig && mouseOpts.area && $xeTable.handleSortEvent) {
            $xeTable.handleSortEvent(evnt, params);
          }
          dispatchEvent2("sort-change", params, evnt);
        }
      },
      /**
       * 点击排序事件
       */
      triggerSortEvent(evnt, column, order) {
        const sortOpts = computeSortOpts.value;
        const { field, sortable } = column;
        if (sortable) {
          if (!order || column.order === order) {
            tableMethods.clearSort(sortOpts.multiple ? column : null);
          } else {
            tableMethods.sort({ field, order });
          }
          $xeTable.handleColumnSortEvent(evnt, column);
        }
      },
      /**
       * 表头单元格按下事件
       */
      triggerHeaderCellMousedownEvent(evnt, params) {
        const { mouseConfig } = props;
        const mouseOpts = computeMouseOpts.value;
        const columnOpts = computeColumnOpts.value;
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, disabledMethod } = columnDragOpts;
        const cell = evnt.currentTarget;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerCheckbox = getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerSort = getEventTargetNode(evnt, cell, "vxe-cell--sort").flag;
        const triggerFilter = getEventTargetNode(evnt, cell, "vxe-cell--filter").flag;
        let triggerDrag = false;
        if (!(triggerInput || triggerCheckbox || triggerSort || triggerFilter)) {
          if (columnOpts.drag && trigger === "cell" && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleHeaderCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && mouseConfig && mouseOpts.area && $xeTable.handleHeaderCellAreaEvent) {
          $xeTable.handleHeaderCellAreaEvent(evnt, Object.assign({ cell, triggerSort, triggerFilter }, params));
        }
        $xeTable.focus();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      /**
       * 单元格按下事件
       */
      triggerCellMousedownEvent(evnt, params) {
        const { column } = params;
        const { type, treeNode } = column;
        const isRadioType = type === "radio";
        const isCheckboxType = type === "checkbox";
        const isExpandType = type === "expand";
        const rowOpts = computeRowOpts.value;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, disabledMethod } = rowDragOpts;
        const cell = evnt.currentTarget;
        params.cell = cell;
        const triggerInput = cell && cell.tagName && cell.tagName.toLowerCase() === "input";
        const triggerRadio = isRadioType && getEventTargetNode(evnt, cell, "vxe-cell--radio").flag;
        const triggerCheckbox = isCheckboxType && getEventTargetNode(evnt, cell, "vxe-cell--checkbox").flag;
        const triggerTreeNode = treeNode && getEventTargetNode(evnt, cell, "vxe-tree--btn-wrapper").flag;
        const triggerExpandNode = isExpandType && getEventTargetNode(evnt, cell, "vxe-table--expanded").flag;
        let isColDragCell = false;
        if (rowOpts.drag) {
          isColDragCell = trigger === "row" || column.dragSort && trigger === "cell";
        }
        let triggerDrag = false;
        if (!(triggerInput || triggerRadio || triggerCheckbox || triggerTreeNode || triggerExpandNode)) {
          if (isColDragCell && !(disabledMethod && disabledMethod(params))) {
            triggerDrag = true;
            $xeTable.handleCellDragMousedownEvent(evnt, params);
          }
        }
        if (!triggerDrag && $xeTable.handleCellMousedownEvent) {
          $xeTable.handleCellMousedownEvent(evnt, params);
        }
        $xeTable.focus();
        $xeTable.closeFilter();
        if ($xeTable.closeMenu) {
          $xeTable.closeMenu();
        }
      },
      /**
       * 行拖拽
       */
      handleRowDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          const img = new Image();
          img.src = tpImg;
          evnt.dataTransfer.setDragImage(img, 0, 0);
        }
      },
      handleRowDragDragendEvent(evnt) {
        const { treeConfig, dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { fullAllDataRowIdData, prevDragToChild } = internalData;
        const { isCrossDrag, isSelfToChildDrag, dragEndMethod } = rowDragOpts;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, rowField, mapChildrenField, parentField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { dragRow } = reactData;
        const { afterFullData, tableFullData, prevDragRow, prevDragPos } = internalData;
        const dEndMethod = dragEndMethod || (dragConfig ? dragConfig.dragEndMethod : null);
        const dragOffsetIndex = prevDragPos === "bottom" ? 1 : 0;
        if (prevDragRow && dragRow) {
          if (prevDragRow !== dragRow) {
            Promise.resolve(dEndMethod ? dEndMethod({
              oldRow: dragRow,
              newRow: prevDragRow,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex
            }) : true).then((status) => {
              if (!status) {
                return;
              }
              let oafIndex = -1;
              let nafIndex = -1;
              if (treeConfig) {
                if (transform2) {
                  const oldRowid = getRowid($xeTable, dragRow);
                  const oldRest = fullAllDataRowIdData[oldRowid];
                  const newRowid = getRowid($xeTable, prevDragRow);
                  const newRest = fullAllDataRowIdData[newRowid];
                  if (oldRest && newRest) {
                    const { level: oldLevel } = oldRest;
                    const { level: newLevel } = newRest;
                    const oldAllMaps = {};
                    import_xe_utils27.default.eachTree([dragRow], (item) => {
                      oldAllMaps[getRowid($xeTable, item)] = item;
                    }, { children: mapChildrenField });
                    let isSelfToChildStatus = false;
                    if (oldLevel && newLevel) {
                      if (!isCrossDrag) {
                        return;
                      }
                      if (oldAllMaps[newRowid]) {
                        isSelfToChildStatus = true;
                        if (!isSelfToChildDrag) {
                          if (VxeUI.modal) {
                            VxeUI.modal.message({
                              status: "error",
                              content: getI18n10("vxe.error.treeDragChild")
                            });
                          }
                          return;
                        }
                      }
                    } else if (oldLevel) {
                      if (!isCrossDrag) {
                        return;
                      }
                    } else if (newLevel) {
                      if (!isCrossDrag) {
                        return;
                      }
                      if (oldAllMaps[newRowid]) {
                        isSelfToChildStatus = true;
                        if (!isSelfToChildDrag) {
                          if (VxeUI.modal) {
                            VxeUI.modal.message({
                              status: "error",
                              content: getI18n10("vxe.error.treeDragChild")
                            });
                          }
                          return;
                        }
                      }
                    } else {
                    }
                    const fullList = import_xe_utils27.default.toTreeArray(internalData.afterTreeFullData, { children: childrenField });
                    const otfIndex = $xeTable.findRowIndexOf(fullList, dragRow);
                    fullList.splice(otfIndex, 1);
                    const ptfIndex = $xeTable.findRowIndexOf(fullList, prevDragRow);
                    const ntfIndex = ptfIndex + dragOffsetIndex;
                    fullList.splice(ntfIndex, 0, dragRow);
                    if (isSelfToChildStatus && isSelfToChildDrag) {
                      import_xe_utils27.default.each(dragRow[childrenField], (childRow) => {
                        childRow[parentField] = dragRow[parentField];
                      });
                    }
                    dragRow[parentField] = prevDragToChild ? prevDragRow[rowField] : prevDragRow[parentField];
                    internalData.tableFullTreeData = import_xe_utils27.default.toArrayTree(fullList, {
                      key: treeOpts.rowField,
                      parentKey: treeOpts.parentField,
                      children: childrenField,
                      mapChildren: treeOpts.mapChildrenField
                    });
                  }
                }
              } else {
                oafIndex = $xeTable.findRowIndexOf(afterFullData, dragRow);
                const otfIndex = $xeTable.findRowIndexOf(tableFullData, dragRow);
                afterFullData.splice(oafIndex, 1);
                tableFullData.splice(otfIndex, 1);
                const pafIndex = $xeTable.findRowIndexOf(afterFullData, prevDragRow);
                const ptfIndex = $xeTable.findRowIndexOf(tableFullData, prevDragRow);
                nafIndex = pafIndex + dragOffsetIndex;
                const ntfIndex = ptfIndex + dragOffsetIndex;
                afterFullData.splice(nafIndex, 0, dragRow);
                tableFullData.splice(ntfIndex, 0, dragRow);
              }
              reactData.isDragRowMove = true;
              $xeTable.handleTableData(treeConfig && transform2);
              $xeTable.cacheRowMap();
              updateScrollYStatus();
              if (!(treeConfig && transform2)) {
                $xeTable.updateAfterDataIndex();
              }
              $xeTable.checkSelectionStatus();
              if (reactData.scrollYLoad) {
                $xeTable.updateScrollYSpace();
              }
              nextTick().then(() => {
                $xeTable.updateCellAreas();
                $xeTable.recalculate();
              });
              dispatchEvent2("row-dragend", {
                oldRow: dragRow,
                newRow: prevDragRow,
                dragPos: prevDragPos,
                offsetIndex: dragOffsetIndex,
                _index: {
                  newIndex: nafIndex,
                  oldIndex: oafIndex
                }
              }, evnt);
            }).catch(() => {
            });
          }
        }
        hideDropTip();
        clearRowDropOrigin();
        internalData.prevDragToChild = false;
        reactData.dragRow = null;
        reactData.dragCol = null;
        setTimeout(() => {
          reactData.isDragRowMove = false;
        }, 500);
      },
      handleRowDragDragoverEvent(evnt) {
        const { treeConfig } = props;
        const { fullAllDataRowIdData } = internalData;
        const { dragRow } = reactData;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2 } = treeOpts;
        const rowDragOpts = computeRowDragOpts.value;
        const { isCrossDrag, isToChildDrag } = rowDragOpts;
        if (!dragRow) {
          evnt.preventDefault();
          return;
        }
        const hasCtrlKey = evnt.ctrlKey;
        const trEl = evnt.currentTarget;
        const rowid = trEl.getAttribute("rowid") || "";
        const rest = fullAllDataRowIdData[rowid];
        if (rest) {
          const row = rest.row;
          evnt.preventDefault();
          const { dragRow: dragRow2 } = reactData;
          const offsetY = evnt.clientY - trEl.getBoundingClientRect().y;
          const dragPos = offsetY < trEl.clientHeight / 2 ? "top" : "bottom";
          if ($xeTable.eqRow(dragRow2, row) || !isCrossDrag && treeConfig && rest.level) {
            showDropTip(evnt, trEl, null, false, dragPos);
            return;
          }
          internalData.prevDragToChild = !!(treeConfig && transform2 && isToChildDrag && hasCtrlKey);
          internalData.prevDragRow = row;
          internalData.prevDragPos = dragPos;
          showDropTip(evnt, trEl, null, true, dragPos);
          dispatchEvent2("row-dragover", {
            oldRow: dragRow2,
            targetRow: row,
            dragPos
          }, evnt);
        }
      },
      handleCellDragMousedownEvent(evnt, params) {
        var _a2;
        evnt.stopPropagation();
        const { dragConfig } = props;
        const rowDragOpts = computeRowDragOpts.value;
        const { trigger, dragStartMethod } = rowDragOpts;
        const { row } = params;
        const dragEl2 = evnt.currentTarget;
        const tdEl = trigger === "cell" || trigger === "row" ? dragEl2 : (_a2 = dragEl2.parentElement) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
        const trEl = tdEl.parentElement;
        const dStartMethod = dragStartMethod || (dragConfig ? dragConfig.dragStartMethod : null);
        clearRowDropOrigin();
        if (dStartMethod && !dStartMethod(params)) {
          trEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          hideDropTip();
          return;
        }
        reactData.dragRow = row;
        reactData.dragCol = null;
        trEl.draggable = true;
        updateRowDropOrigin(row);
        updateRowDropTipContent(tdEl);
        dispatchEvent2("row-dragstart", params, evnt);
      },
      handleCellDragMouseupEvent() {
        clearRowDropOrigin();
        hideDropTip();
        reactData.dragRow = null;
        reactData.dragCol = null;
        reactData.isDragRowMove = false;
      },
      /**
       * 列拖拽
       */
      handleHeaderCellDragDragstartEvent(evnt) {
        if (evnt.dataTransfer) {
          const img = new Image();
          img.src = tpImg;
          evnt.dataTransfer.setDragImage(img, 0, 0);
        }
      },
      handleColDragSwapEvent(evnt, isSyncColumn, dragCol, prevDragCol, prevDragPos, prevDragToChild) {
        const { mouseConfig } = props;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isCrossDrag, isSelfToChildDrag, isToChildDrag, dragEndMethod } = columnDragOpts;
        const { collectColumn } = internalData;
        const dragOffsetIndex = prevDragPos === "right" ? 1 : 0;
        if (prevDragCol && dragCol) {
          if (prevDragCol !== dragCol) {
            const oldColumn = dragCol;
            const newColumn = prevDragCol;
            return Promise.resolve(dragEndMethod ? dragEndMethod({
              oldColumn,
              newColumn,
              dragPos: prevDragPos,
              offsetIndex: dragOffsetIndex
            }) : true).then((status) => {
              if (!status) {
                return;
              }
              let oafIndex = -1;
              let nafIndex = -1;
              const oldAllMaps = {};
              import_xe_utils27.default.eachTree([oldColumn], (column) => {
                oldAllMaps[column.id] = column;
              });
              let isSelfToChildStatus = false;
              if (oldColumn.parentId && newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!isSelfToChildDrag) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n10("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else if (oldColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
              } else if (newColumn.parentId) {
                if (!isCrossDrag) {
                  return;
                }
                if (oldAllMaps[newColumn.id]) {
                  isSelfToChildStatus = true;
                  if (!isSelfToChildDrag) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({
                        status: "error",
                        content: getI18n10("vxe.error.treeDragChild")
                      });
                    }
                    return;
                  }
                }
              } else {
              }
              const oldewMatchRest = import_xe_utils27.default.findTree(collectColumn, (item) => item.id === oldColumn.id);
              if (isSelfToChildStatus && isSelfToChildDrag) {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex } = oldewMatchRest;
                  const childList = oldColumn.children || [];
                  childList.forEach((column) => {
                    column.parentId = oldColumn.parentId;
                  });
                  oCols.splice(oIndex, 1, ...childList);
                  oldColumn.children = [];
                }
              } else {
                if (oldewMatchRest) {
                  const { items: oCols, index: oIndex, parent: oParent } = oldewMatchRest;
                  oCols.splice(oIndex, 1);
                  if (!oParent) {
                    oafIndex = oIndex;
                  }
                }
              }
              const newMatchRest = import_xe_utils27.default.findTree(collectColumn, (item) => item.id === newColumn.id);
              if (newMatchRest) {
                const { items: nCols, index: nIndex, parent: nParent } = newMatchRest;
                if (isToChildDrag && prevDragToChild) {
                  oldColumn.parentId = newColumn.id;
                  newColumn.children = (newColumn.children || []).concat([oldColumn]);
                } else {
                  oldColumn.parentId = newColumn.parentId;
                  nCols.splice(nIndex + dragOffsetIndex, 0, oldColumn);
                }
                if (!nParent) {
                  nafIndex = nIndex;
                }
              }
              import_xe_utils27.default.eachTree(collectColumn, (column, index2, items, path, parent) => {
                if (!parent) {
                  const sortIndex = index2 + 1;
                  column.renderSortNumber = sortIndex;
                }
              });
              reactData.isDragColMove = true;
              if (mouseConfig) {
                if ($xeTable.clearSelected) {
                  $xeTable.clearSelected();
                }
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              dispatchEvent2("column-dragend", {
                oldColumn,
                newColumn,
                dragPos: prevDragPos,
                offsetIndex: dragOffsetIndex,
                _index: {
                  newIndex: nafIndex,
                  oldIndex: oafIndex
                }
              }, evnt);
              if (isSyncColumn) {
                return tableMethods.refreshColumn(true).then(() => {
                  $xeTable.updateCellAreas();
                  return $xeTable.saveCustomStore("update:sort");
                });
              }
            }).catch(() => {
            });
          }
        }
        return Promise.resolve();
      },
      handleHeaderCellDragDragendEvent(evnt) {
        const { dragCol } = reactData;
        const { prevDragCol, prevDragPos, prevDragToChild } = internalData;
        $xeTable.handleColDragSwapEvent(evnt, true, dragCol, prevDragCol, prevDragPos, prevDragToChild);
        hideDropTip();
        clearColDropOrigin();
        internalData.prevDragToChild = false;
        reactData.dragRow = null;
        reactData.dragCol = null;
        setTimeout(() => {
          reactData.isDragColMove = false;
        }, 500);
      },
      handleHeaderCellDragDragoverEvent(evnt) {
        const { dragCol } = reactData;
        const columnDragOpts = computeColumnDragOpts.value;
        const { isToChildDrag, isCrossDrag } = columnDragOpts;
        if (!dragCol) {
          evnt.preventDefault();
          return;
        }
        const hasCtrlKey = evnt.ctrlKey;
        const thEl = evnt.currentTarget;
        const colid = thEl.getAttribute("colid");
        const column = $xeTable.getColumnById(colid);
        if (column) {
          evnt.preventDefault();
          const { dragCol: dragCol2 } = reactData;
          const offsetX = evnt.clientX - thEl.getBoundingClientRect().x;
          const dragPos = offsetX < thEl.clientWidth / 2 ? "left" : "right";
          if (dragCol2 && dragCol2.id === column.id || !isCrossDrag && column.parentId) {
            showDropTip(evnt, null, thEl, false, dragPos);
            return;
          }
          internalData.prevDragToChild = !!(isToChildDrag && hasCtrlKey);
          internalData.prevDragCol = column;
          internalData.prevDragPos = dragPos;
          showDropTip(evnt, null, thEl, true, dragPos);
          dispatchEvent2("column-dragover", {
            oldColumn: dragCol2,
            targetColumn: column,
            dragPos
          }, evnt);
        }
      },
      handleHeaderCellDragMousedownEvent(evnt, params) {
        var _a2;
        evnt.stopPropagation();
        const columnDragOpts = computeColumnDragOpts.value;
        const { trigger, dragStartMethod } = columnDragOpts;
        const { column } = params;
        const dragEl2 = evnt.currentTarget;
        const thEl = trigger === "cell" ? dragEl2 : (_a2 = dragEl2.parentElement) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
        reactData.isDragColMove = false;
        clearColDropOrigin();
        if (dragStartMethod && !dragStartMethod(params)) {
          thEl.draggable = false;
          reactData.dragRow = null;
          reactData.dragCol = null;
          hideDropTip();
          return;
        }
        reactData.dragCol = column;
        reactData.dragRow = null;
        thEl.draggable = true;
        updateColDropOrigin(column);
        updateColDropTipContent(thEl);
        dispatchEvent2("column-dragstart", params, evnt);
      },
      handleHeaderCellDragMouseupEvent() {
        clearColDropOrigin();
        hideDropTip();
        reactData.dragRow = null;
        reactData.dragCol = null;
        reactData.isDragColMove = false;
      },
      handleScrollEvent(evnt, isRollY, isRollX, scrollTop, scrollLeft, params) {
        const { highlightHoverRow } = props;
        const { lastScrollLeft, lastScrollTop } = internalData;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody ? tableBody.$el : null;
        const rowOpts = computeRowOpts.value;
        const validTip = refValidTooltip.value;
        const tooltip = refTooltip.value;
        const bodyHeight = bodyElem ? bodyElem.clientHeight : 0;
        const bodyWidth = bodyElem ? bodyElem.clientWidth : 0;
        const scrollHeight = bodyElem ? bodyElem.scrollHeight : 0;
        const scrollWidth = bodyElem ? bodyElem.scrollWidth : 0;
        let isTop = false;
        let isBottom = false;
        let isLeft = false;
        let isRight = false;
        let direction = "";
        let isTopBoundary = false;
        let isBottomBoundary = false;
        let isLeftBoundary = false;
        let isRightBoundary = false;
        if (isRollX) {
          const xThreshold = computeScrollXThreshold.value;
          isLeft = scrollLeft <= 0;
          if (!isLeft) {
            isRight = scrollLeft + bodyWidth >= scrollWidth;
          }
          if (scrollLeft > lastScrollLeft) {
            direction = "right";
            if (scrollLeft + bodyWidth >= scrollWidth - xThreshold) {
              isRightBoundary = true;
            }
          } else {
            direction = "left";
            if (scrollLeft <= xThreshold) {
              isLeftBoundary = true;
            }
          }
          tablePrivateMethods.checkScrolling();
          internalData.lastScrollLeft = scrollLeft;
        }
        if (isRollY) {
          const yThreshold = computeScrollYThreshold.value;
          isTop = scrollTop <= 0;
          if (!isTop) {
            isBottom = scrollTop + bodyHeight >= scrollHeight;
          }
          if (scrollTop > lastScrollTop) {
            direction = "bottom";
            if (scrollTop + bodyHeight >= scrollHeight - yThreshold) {
              isBottomBoundary = true;
            }
          } else {
            direction = "top";
            if (scrollTop <= yThreshold) {
              isTopBoundary = true;
            }
          }
          internalData.lastScrollTop = scrollTop;
        }
        reactData.isDragColMove = false;
        reactData.isDragRowMove = false;
        reactData.lastScrollTime = Date.now();
        const evntParams = Object.assign({
          scrollTop,
          scrollLeft,
          bodyHeight,
          bodyWidth,
          scrollHeight,
          scrollWidth,
          isX: isRollX,
          isY: isRollY,
          isTop,
          isBottom,
          isLeft,
          isRight,
          direction
        }, params);
        checkLastSyncScroll(isRollX, isRollY);
        if (rowOpts.isHover || highlightHoverRow) {
          $xeTable.clearHoverRow();
        }
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (tooltip && tooltip.reactData.visible) {
          tooltip.close();
        }
        if (isBottomBoundary || isTopBoundary || isRightBoundary || isLeftBoundary) {
          dispatchEvent2("scroll-boundary", evntParams, evnt);
        }
        dispatchEvent2("scroll", evntParams, evnt);
      },
      /**
       * 横向 X 可视渲染事件处理
       */
      triggerScrollXEvent() {
        const sXOpts = computeSXOpts.value;
        if (sXOpts.immediate) {
          loadScrollXData();
        } else {
          lazyScrollXData();
        }
      },
      /**
       * 纵向 Y 可视渲染事件处理
       */
      triggerScrollYEvent() {
        const sYOpts = computeSYOpts.value;
        if (sYOpts.immediate) {
          loadScrollYData();
        } else {
          lazyScrollYData();
        }
      },
      /**
       * 对于树形结构中，可以直接滚动到指定深层节点中
       * 对于某些特定的场景可能会用到，比如定位到某一节点
       * @param {Row} row 行对象
       */
      scrollToTreeRow(row) {
        const { treeConfig } = props;
        const { tableFullData } = internalData;
        const rests = [];
        if (treeConfig) {
          const treeOpts = computeTreeOpts.value;
          const childrenField = treeOpts.children || treeOpts.childrenField;
          const matchObj = import_xe_utils27.default.findTree(tableFullData, (item) => $xeTable.eqRow(item, row), { children: childrenField });
          if (matchObj) {
            const nodes = matchObj.nodes;
            nodes.forEach((row2, index2) => {
              if (index2 < nodes.length - 1 && !tableMethods.isTreeExpandByRow(row2)) {
                rests.push(tableMethods.setTreeExpand(row2, true));
              }
            });
          }
        }
        return Promise.all(rests).then(() => rowToVisible($xeTable, row));
      },
      updateScrollYStatus,
      // 更新横向 X 可视渲染上下剩余空间大小
      updateScrollXSpace() {
        const { isGroup, scrollXLoad, scrollbarWidth } = reactData;
        const { visibleColumn, scrollXStore, elemStore, tableWidth } = internalData;
        const tableHeader = refTableHeader.value;
        const tableBody = refTableBody.value;
        const tableFooter = refTableFooter.value;
        const tableBodyElem = tableBody ? tableBody.$el : null;
        if (tableBodyElem) {
          const tableHeaderElem = tableHeader ? tableHeader.$el : null;
          const tableFooterElem = tableFooter ? tableFooter.$el : null;
          const headerElem = tableHeaderElem ? tableHeaderElem.querySelector(".vxe-table--header") : null;
          const bodyElem = tableBodyElem.querySelector(".vxe-table--body");
          const footerElem = tableFooterElem ? tableFooterElem.querySelector(".vxe-table--footer") : null;
          const leftSpaceWidth = visibleColumn.slice(0, scrollXStore.startIndex).reduce((previous, column) => previous + column.renderWidth, 0);
          let marginLeft = "";
          if (scrollXLoad) {
            marginLeft = `${leftSpaceWidth}px`;
          }
          if (headerElem) {
            headerElem.style.marginLeft = isGroup ? "" : marginLeft;
          }
          bodyElem.style.marginLeft = marginLeft;
          if (footerElem) {
            footerElem.style.marginLeft = marginLeft;
          }
          const containerList = ["main"];
          containerList.forEach((name) => {
            const layoutList = ["header", "body", "footer"];
            layoutList.forEach((layout) => {
              const xSpaceElem = getRefElem(elemStore[`${name}-${layout}-xSpace`]);
              if (xSpaceElem) {
                xSpaceElem.style.width = scrollXLoad ? `${tableWidth + (layout === "header" ? scrollbarWidth : 0)}px` : "";
              }
            });
          });
          const scrollXSpaceEl = refScrollXSpaceElem.value;
          if (scrollXSpaceEl) {
            scrollXSpaceEl.style.width = `${tableWidth + scrollbarWidth}px`;
          }
          nextTick(updateStyle);
        }
      },
      // 更新纵向 Y 可视渲染上下剩余空间大小
      updateScrollYSpace() {
        const { showOverflow } = props;
        const { scrollYLoad } = reactData;
        const { scrollYStore, elemStore, afterFullData, fullAllDataRowIdData } = internalData;
        const { startIndex, rowHeight } = scrollYStore;
        let bodyHeight = 0;
        let topSpaceHeight = 0;
        const containerList = ["main", "left", "right"];
        let marginTop = "";
        let ySpaceHeight = "";
        if (scrollYLoad) {
          if (showOverflow) {
            bodyHeight = afterFullData.length * rowHeight;
            topSpaceHeight = Math.max(0, startIndex * rowHeight);
          } else {
            for (let i = 0; i < afterFullData.length; i++) {
              const row = afterFullData[i];
              const rowid = getRowid($xeTable, row);
              const rowRest = fullAllDataRowIdData[rowid];
              if (rowRest) {
                bodyHeight += rowRest.height || rowHeight;
              }
            }
            for (let i = 0; i < startIndex; i++) {
              const row = afterFullData[i];
              const rowid = getRowid($xeTable, row);
              const rowRest = fullAllDataRowIdData[rowid];
              if (rowRest) {
                topSpaceHeight += rowRest.height || rowHeight;
              }
            }
          }
          marginTop = `${topSpaceHeight}px`;
          ySpaceHeight = `${bodyHeight}px`;
        }
        containerList.forEach((name) => {
          const layoutList = ["header", "body", "footer"];
          const tableElem = getRefElem(elemStore[`${name}-body-table`]);
          if (tableElem) {
            tableElem.style.marginTop = marginTop;
          }
          layoutList.forEach((layout) => {
            const ySpaceElem = getRefElem(elemStore[`${name}-${layout}-ySpace`]);
            if (ySpaceElem) {
              ySpaceElem.style.height = ySpaceHeight;
            }
          });
        });
        const scrollYSpaceEl = refScrollYSpaceElem.value;
        if (scrollYSpaceEl) {
          scrollYSpaceEl.style.height = ySpaceHeight;
        }
        nextTick(updateStyle);
      },
      updateScrollXData() {
        const { showOverflow } = props;
        return nextTick().then(() => {
          handleTableColumn();
          calcCellHeight();
          tablePrivateMethods.updateScrollXSpace();
          if (!showOverflow) {
            tablePrivateMethods.updateScrollYSpace();
          }
        });
      },
      updateScrollYData() {
        return nextTick().then(() => {
          tablePrivateMethods.handleTableData();
          calcCellHeight();
          tablePrivateMethods.updateScrollYSpace();
        });
      },
      /**
       * 处理固定列的显示状态
       */
      checkScrolling() {
        const leftContainerElem = refLeftContainer.value;
        const rightContainerElem = refRightContainer.value;
        const tableBody = refTableBody.value;
        const bodyElem = tableBody ? tableBody.$el : null;
        const xHandleEl = refScrollXHandleElem.value;
        const bodtTargetEl = xHandleEl || bodyElem;
        if (bodtTargetEl) {
          if (leftContainerElem) {
            if (bodtTargetEl.scrollLeft > 0) {
              addClass(leftContainerElem, "scrolling--middle");
            } else {
              removeClass(leftContainerElem, "scrolling--middle");
            }
          }
          if (rightContainerElem) {
            if (bodtTargetEl.clientWidth < bodtTargetEl.scrollWidth - Math.ceil(bodtTargetEl.scrollLeft)) {
              addClass(rightContainerElem, "scrolling--middle");
            } else {
              removeClass(rightContainerElem, "scrolling--middle");
            }
          }
        }
      },
      updateZindex() {
        if (props.zIndex) {
          internalData.tZindex = props.zIndex;
        } else if (internalData.tZindex < getLastZIndex()) {
          internalData.tZindex = nextZIndex();
        }
      },
      handleCheckedCheckboxRow,
      /**
       * 行 hover 事件
       */
      triggerHoverEvent(evnt, { row }) {
        tablePrivateMethods.setHoverRow(row);
      },
      setHoverRow(row) {
        const rowid = getRowid($xeTable, row);
        const el2 = refElem.value;
        tablePrivateMethods.clearHoverRow();
        if (el2) {
          import_xe_utils27.default.arrayEach(el2.querySelectorAll(`[rowid="${rowid}"]`), (elem) => addClass(elem, "row--hover"));
        }
        internalData.hoverRow = row;
      },
      clearHoverRow() {
        const el2 = refElem.value;
        if (el2) {
          import_xe_utils27.default.arrayEach(el2.querySelectorAll(".vxe-body--row.row--hover"), (elem) => removeClass(elem, "row--hover"));
        }
        internalData.hoverRow = null;
      },
      /**
       * 已废弃，被 getCellElement 替换
       * @deprecated
       */
      getCell(row, column) {
        return tableMethods.getCellElement(row, column);
      },
      findRowIndexOf(list, row) {
        return row ? import_xe_utils27.default.findIndexOf(list, (item) => $xeTable.eqRow(item, row)) : -1;
      },
      eqRow(row1, row2) {
        if (row1 && row2) {
          if (row1 === row2) {
            return true;
          }
          return getRowid($xeTable, row1) === getRowid($xeTable, row2);
        }
        return false;
      }
    };
    if (true) {
      "openExport,openPrint,exportData,openImport,importData,saveFile,readFile,importByFile,print".split(",").forEach((name) => {
        $xeTable[name] = function() {
          errLog("vxe.error.reqModule", ["VxeTableExportModule"]);
        };
      });
      "clearValidate,fullValidate,validate".split(",").forEach((name) => {
        $xeTable[name] = function() {
          errLog("vxe.error.reqModule", ["VxeTableValidatorModule"]);
        };
      });
    }
    Object.assign($xeTable, tableMethods, tablePrivateMethods);
    const renderFixed = (fixedType) => {
      const { showHeader, showFooter } = props;
      const { tableData, tableColumn, tableGroupColumn, columnStore, footerTableData } = reactData;
      const isFixedLeft = fixedType === "left";
      const fixedColumn = isFixedLeft ? columnStore.leftList : columnStore.rightList;
      return h("div", {
        ref: isFixedLeft ? refLeftContainer : refRightContainer,
        class: `vxe-table--fixed-${fixedType}-wrapper`
      }, [
        showHeader ? h(header_default, {
          ref: isFixedLeft ? refTableLeftHeader : refTableRightHeader,
          fixedType,
          tableData,
          tableColumn,
          tableGroupColumn,
          fixedColumn
        }) : renderEmptyElement5($xeTable),
        h(body_default, {
          ref: isFixedLeft ? refTableLeftBody : refTableRightBody,
          fixedType,
          tableData,
          tableColumn,
          fixedColumn
        }),
        showFooter ? h(footer_default, {
          ref: isFixedLeft ? refTableLeftFooter : refTableRightFooter,
          footerTableData,
          tableColumn,
          fixedColumn,
          fixedType
        }) : renderEmptyElement5($xeTable)
      ]);
    };
    const renderEmptyBody = () => {
      const emptyOpts = computeEmptyOpts.value;
      const params = { $table: $xeTable };
      if (slots.empty) {
        return slots.empty(params);
      } else {
        const compConf = emptyOpts.name ? renderer8.get(emptyOpts.name) : null;
        const rtEmptyView = compConf ? compConf.renderTableEmpty || compConf.renderTableEmptyView || compConf.renderEmpty : null;
        if (rtEmptyView) {
          return getSlotVNs(rtEmptyView(emptyOpts, params));
        }
      }
      return getFuncText(props.emptyText) || getI18n10("vxe.table.emptyText");
    };
    const renderDragTipContents = () => {
      const { dragConfig } = props;
      const { dragRow, dragCol, dragTipText } = reactData;
      const columnDragOpts = computeColumnDragOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const rowDragSlots = rowDragOpts.slots || {};
      const rTipSlot = rowDragSlots.tip || (dragConfig && dragConfig.slots ? dragConfig.slots.rowTip : null);
      const columnDragSlots = columnDragOpts.slots || {};
      const cTipSlot = columnDragSlots.tip;
      if (dragRow && rTipSlot) {
        return callSlot(rTipSlot, { row: dragRow });
      }
      if (dragCol && cTipSlot) {
        return callSlot(cTipSlot, { column: dragCol });
      }
      return [h("span", dragTipText)];
    };
    const renderDragTip = () => {
      const { dragRow } = reactData;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const rowDragOpts = computeRowDragOpts.value;
      const columnDragOpts = computeColumnDragOpts.value;
      if (rowOpts.drag || columnOpts.drag) {
        return h("div", {
          class: "vxe-table--drag-wrapper"
        }, [
          h("div", {
            ref: refDragRowLineElem,
            class: ["vxe-table--drag-row-line", {
              "is--guides": rowDragOpts.showGuidesStatus
            }]
          }),
          h("div", {
            ref: refDragColLineElem,
            class: ["vxe-table--drag-col-line", {
              "is--guides": columnDragOpts.showGuidesStatus
            }]
          }),
          h("div", {
            ref: refDragTipElem,
            class: "vxe-table--drag-sort-tip"
          }, [
            h("div", {
              class: "vxe-table--drag-sort-tip-wrapper"
            }, [
              h("div", {
                class: "vxe-table--drag-sort-tip-status"
              }, [
                h("span", {
                  class: ["vxe-table--drag-sort-tip-normal-status", dragRow ? getIcon9().TABLE_DRAG_STATUS_ROW : getIcon9().TABLE_DRAG_STATUS_COLUMN]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-sub-status", getIcon9().TABLE_DRAG_STATUS_SUB_ROW]
                }),
                h("span", {
                  class: ["vxe-table--drag-sort-tip-disabled-status", getIcon9().TABLE_DRAG_DISABLED]
                })
              ]),
              h("div", {
                class: "vxe-table--drag-sort-tip-content"
              }, renderDragTipContents())
            ])
          ])
        ]);
      }
      return renderEmptyElement5($xeTable);
    };
    function handleUupdateResize() {
      const el2 = refElem.value;
      if (el2 && el2.clientWidth && el2.clientHeight) {
        tableMethods.recalculate();
      }
    }
    const renderVN = () => {
      const { loading: loading2, stripe, showHeader, height, treeConfig, mouseConfig, showFooter, highlightCell, highlightHoverRow, highlightHoverColumn, editConfig, editRules } = props;
      const { isCalcColumn, isGroup, overflowX, overflowY, scrollXLoad, scrollYLoad, scrollbarHeight, tableData, tableColumn, tableGroupColumn, footerTableData, initStore, columnStore, filterStore, customStore, tooltipStore } = reactData;
      const { leftList, rightList } = columnStore;
      const loadingSlot = slots.loading;
      const tipConfig = computeTipConfig.value;
      const validOpts = computeValidOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const rowOpts = computeRowOpts.value;
      const columnOpts = computeColumnOpts.value;
      const vSize = computeSize.value;
      const tableBorder = computeTableBorder.value;
      const mouseOpts = computeMouseOpts.value;
      const areaOpts = computeAreaOpts.value;
      const validTipOpts = computeValidTipOpts.value;
      const loadingOpts = computeLoadingOpts.value;
      const isMenu = computeIsMenu.value;
      const currLoading = reactData._isLoading || loading2;
      const virtualScrollBars = computeVirtualScrollBars.value;
      const resizableOpts = computeResizableOpts.value;
      const isArea = mouseConfig && mouseOpts.area;
      const tableStyle = computeTableStyle.value;
      const columnDragOpts = computeColumnDragOpts.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-table", "vxe-table--render-default", `tid_${xID}`, `border--${tableBorder}`, {
          [`size--${vSize}`]: vSize,
          [`valid-msg--${validOpts.msgMode}`]: !!editRules,
          "vxe-editable": !!editConfig,
          "old-cell-valid": editRules && getConfig4().cellVaildMode === "obsolete",
          "cell--highlight": highlightCell,
          "cell--selected": mouseConfig && mouseOpts.selected,
          "cell--area": isArea,
          "header-cell--area": isArea && areaOpts.selectCellByHeader,
          "body-cell--area": isArea && areaOpts.selectCellByBody,
          "row--highlight": rowOpts.isHover || highlightHoverRow,
          "column--highlight": columnOpts.isHover || highlightHoverColumn,
          "checkbox--range": checkboxOpts.range,
          "column--calc": isCalcColumn,
          "col--drag-cell": columnOpts.drag && columnDragOpts.trigger === "cell",
          "is--header": showHeader,
          "is--footer": showFooter,
          "is--group": isGroup,
          "is--tree-line": treeConfig && (treeOpts.showLine || treeOpts.line),
          "is--fixed-left": leftList.length,
          "is--fixed-right": rightList.length,
          "is--animat": !!props.animat,
          "is--padding": props.padding,
          "is--round": props.round,
          "is--stripe": !treeConfig && stripe,
          "is--loading": currLoading,
          "is--empty": !currLoading && !tableData.length,
          "is--scroll-y": overflowY,
          "is--scroll-x": overflowX,
          "is--virtual-x": scrollXLoad,
          "is--virtual-y": scrollYLoad
        }],
        style: tableStyle,
        spellcheck: false,
        onKeydown: keydownEvent
      }, [
        /**
         * 隐藏列
         */
        h("div", {
          class: "vxe-table-slots"
        }, slots.default ? slots.default({}) : []),
        h("div", {
          key: "tw",
          class: "vxe-table--render-wrapper"
        }, [
          h("div", {
            class: "vxe-table--main-wrapper"
          }, [
            /**
             * 表头
             */
            showHeader ? h(header_default, {
              ref: refTableHeader,
              tableData,
              tableColumn,
              tableGroupColumn
            }) : renderEmptyElement5($xeTable),
            /**
             * 表体
             */
            h(body_default, {
              ref: refTableBody,
              tableData,
              tableColumn
            }),
            /**
             * 表尾
             */
            showFooter ? h(footer_default, {
              ref: refTableFooter,
              footerTableData,
              tableColumn
            }) : renderEmptyElement5($xeTable)
          ]),
          h("div", {
            class: "vxe-table--fixed-wrapper"
          }, [
            leftList && leftList.length && overflowX ? renderFixed("left") : renderEmptyElement5($xeTable),
            rightList && rightList.length && overflowX ? renderFixed("right") : renderEmptyElement5($xeTable)
          ])
        ]),
        virtualScrollBars.x ? h("div", {
          key: "vx",
          ref: refScrollXVirtualElem,
          class: "vxe-table--scroll-x-virtual"
        }, [
          h("div", {
            ref: refScrollXHandleElem,
            class: "vxe-table--scroll-x-handle",
            onScroll: scrollXEvent
          }, [
            h("div", {
              ref: refScrollXSpaceElem,
              class: "vxe-table--scroll-x-space"
            })
          ])
        ]) : renderEmptyElement5($xeTable),
        virtualScrollBars.y ? h("div", {
          key: "vy",
          ref: refScrollYVirtualElem,
          class: "vxe-table--scroll-y-virtual"
        }, [
          h("div", {
            ref: refScrollYHandleElem,
            class: "vxe-table--scroll-y-handle",
            onScroll: scrollYEvent
          }, [
            h("div", {
              ref: refScrollYSpaceElem,
              class: "vxe-table--scroll-y-space"
            })
          ])
        ]) : renderEmptyElement5($xeTable),
        /**
         * 空数据
         */
        h("div", {
          key: "tn",
          ref: refEmptyPlaceholder,
          class: "vxe-table--empty-placeholder"
        }, [
          h("div", {
            class: "vxe-table--empty-content"
          }, renderEmptyBody())
        ]),
        /**
         * 边框线
         */
        h("div", {
          key: "tl",
          class: "vxe-table--border-line"
        }),
        /**
         * 列宽线
         */
        h("div", {
          key: "cl",
          ref: refCellResizeBar,
          class: "vxe-table--resizable-bar",
          style: overflowX ? {
            "padding-bottom": `${scrollbarHeight}px`
          } : null
        }, resizableOpts.showDragTip ? [
          h("div", {
            ref: refCellResizeTip,
            class: "vxe-table--resizable-number-tip"
          }, "23432px")
        ] : []),
        /**
         * 加载中
         */
        VxeUILoadingComponent ? h(VxeUILoadingComponent, {
          key: "lg",
          class: "vxe-table--loading",
          modelValue: currLoading,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, loading: currLoading })
        } : {}) : loadingSlot ? h("div", {
          class: ["vxe-loading--custom-wrapper", {
            "is--visible": currLoading
          }]
        }, callSlot(loadingSlot, { $table: $xeTable, $grid: $xeGrid, loading: currLoading })) : renderEmptyElement5($xeTable),
        /**
         * 自定义列
         */
        initStore.custom ? h(panel_default, {
          key: "cs",
          ref: refTableCustom,
          customStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 筛选
         */
        initStore.filter ? h(panel_default2, {
          key: "tf",
          ref: refTableFilter,
          filterStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 导入
         */
        initStore.import && props.importConfig ? h(import_panel_default, {
          key: "it",
          defaultOptions: reactData.importParams,
          storeData: reactData.importStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 导出
         */
        initStore.export && (props.exportConfig || props.printConfig) ? h(export_panel_default, {
          key: "et",
          defaultOptions: reactData.exportParams,
          storeData: reactData.exportStore
        }) : renderEmptyElement5($xeTable),
        /**
         * 快捷菜单
         */
        isMenu ? h(panel_default3, {
          key: "tm",
          ref: refTableMenu
        }) : renderEmptyElement5($xeTable),
        /**
         * 拖拽排序提示
         */
        renderDragTip(),
        /**
         * 提示相关
         */
        VxeUITooltipComponent ? h("div", {}, [
          /**
           * 通用提示
           */
          h(VxeUITooltipComponent, {
            key: "ctp",
            ref: refCommTooltip,
            isArrow: false,
            enterable: false
          }),
          /**
            * 工具提示
            */
          h(VxeUITooltipComponent, Object.assign({
            key: "btp",
            ref: refTooltip
          }, tipConfig, tooltipStore.currOpts)),
          /**
            * 校验提示
            */
          props.editRules && validOpts.showMessage && (validOpts.message === "default" ? !height : validOpts.message === "tooltip") ? h(VxeUITooltipComponent, Object.assign({ key: "vtp", ref: refValidTooltip, class: [{
            "old-cell-valid": editRules && getConfig4().cellVaildMode === "obsolete"
          }, "vxe-table--valid-error"] }, validOpts.message === "tooltip" || tableData.length === 1 ? validTipOpts : {})) : renderEmptyElement5($xeTable)
        ]) : renderEmptyElement5($xeTable)
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      const { initStatus } = internalData;
      loadTableData(props.data || []).then(() => {
        const { scrollXLoad, scrollYLoad, expandColumn } = reactData;
        internalData.inited = true;
        internalData.initStatus = true;
        if (!initStatus) {
          handleLoadDefaults();
        }
        if (true) {
          if ((scrollXLoad || scrollYLoad) && expandColumn) {
            warnLog("vxe.error.scrollErrProp", ["column.type=expand"]);
          }
        }
        tableMethods.recalculate();
      });
    });
    const staticColumnFlag = ref(0);
    watch(() => reactData.staticColumns.length, () => {
      staticColumnFlag.value++;
    });
    watch(() => reactData.staticColumns, () => {
      staticColumnFlag.value++;
    });
    watch(staticColumnFlag, () => {
      handleColumn(import_xe_utils27.default.clone(reactData.staticColumns));
    });
    const tableColumnFlag = ref(0);
    watch(() => reactData.tableColumn.length, () => {
      tableColumnFlag.value++;
    });
    watch(() => reactData.tableColumn, () => {
      tableColumnFlag.value++;
    });
    watch(tableColumnFlag, () => {
      tablePrivateMethods.analyColumnWidth();
    });
    watch(() => reactData.upDataFlag, () => {
      nextTick(() => {
        tableMethods.updateData();
      });
    });
    watch(() => reactData.reColumnFlag, () => {
      nextTick(() => {
        tableMethods.refreshColumn();
      });
    });
    watch(() => props.showHeader, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    watch(() => props.showFooter, () => {
      nextTick(() => {
        tableMethods.recalculate(true).then(() => tableMethods.refreshScroll());
      });
    });
    const footFlag = ref(0);
    watch(() => props.footerData ? props.footerData.length : -1, () => {
      footFlag.value++;
    });
    watch(() => props.footerData, () => {
      footFlag.value++;
    });
    watch(footFlag, () => {
      tableMethods.updateFooter();
    });
    watch(() => props.height, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    watch(() => props.maxHeight, () => {
      nextTick(() => tableMethods.recalculate(true));
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        handleUupdateResize();
        nextTick(() => {
          handleUupdateResize();
          setTimeout(() => handleUupdateResize());
        });
      }
    });
    const mergeCellFlag = ref(0);
    watch(() => props.mergeCells ? props.mergeCells.length : -1, () => {
      mergeCellFlag.value++;
    });
    watch(() => props.mergeCells, () => {
      mergeCellFlag.value++;
    });
    watch(mergeCellFlag, () => {
      tableMethods.clearMergeCells();
      nextTick(() => {
        if (props.mergeCells) {
          tableMethods.setMergeCells(props.mergeCells);
        }
      });
    });
    const mergeFooterItemFlag = ref(0);
    watch(() => props.mergeFooterItems ? props.mergeFooterItems.length : -1, () => {
      mergeFooterItemFlag.value++;
    });
    watch(() => props.mergeFooterItems, () => {
      mergeFooterItemFlag.value++;
    });
    watch(mergeFooterItemFlag, () => {
      tableMethods.clearMergeFooterItems();
      nextTick(() => {
        if (props.mergeFooterItems) {
          tableMethods.setMergeFooterItems(props.mergeFooterItems);
        }
      });
    });
    if ($xeTabs) {
      watch(() => $xeTabs ? $xeTabs.reactData.resizeFlag : null, () => {
        handleGlobalResizeEvent();
      });
    }
    hooks3.forEach((options) => {
      const { setupTable } = options;
      if (setupTable) {
        const hookRest = setupTable($xeTable);
        if (hookRest && import_xe_utils27.default.isObject(hookRest)) {
          Object.assign($xeTable, hookRest);
        }
      }
    });
    tablePrivateMethods.preventEvent(null, "created", { $table: $xeTable });
    let resizeObserver;
    onActivated(() => {
      tableMethods.recalculate().then(() => tableMethods.refreshScroll());
      tablePrivateMethods.preventEvent(null, "activated", { $table: $xeTable });
    });
    onDeactivated(() => {
      internalData.isActivated = false;
      tablePrivateMethods.preventEvent(null, "deactivated", { $table: $xeTable });
    });
    onMounted(() => {
      nextTick(() => {
        const { data, treeConfig, showOverflow } = props;
        const { scrollXStore, scrollYStore } = internalData;
        const sYOpts = computeSYOpts.value;
        const editOpts = computeEditOpts.value;
        const treeOpts = computeTreeOpts.value;
        const radioOpts = computeRadioOpts.value;
        const checkboxOpts = computeCheckboxOpts.value;
        const expandOpts = computeExpandOpts.value;
        const rowOpts = computeRowOpts.value;
        if (true) {
          if (props.rowId) {
            warnLog("vxe.error.delProp", ["row-id", "row-config.keyField"]);
          }
          if (props.rowKey) {
            warnLog("vxe.error.delProp", ["row-key", "row-config.useKey"]);
          }
          if (props.columnKey) {
            warnLog("vxe.error.delProp", ["column-id", "column-config.useKey"]);
          }
          if (!(props.rowId || rowOpts.keyField) && (checkboxOpts.reserve || checkboxOpts.checkRowKeys || radioOpts.reserve || radioOpts.checkRowKey || expandOpts.expandRowKeys || treeOpts.expandRowKeys)) {
            warnLog("vxe.error.reqProp", ["row-config.keyField"]);
          }
          if (props.editConfig && (editOpts.showStatus || editOpts.showUpdateStatus || editOpts.showInsertStatus) && !props.keepSource) {
            warnLog("vxe.error.reqProp", ["keep-source"]);
          }
          if (treeConfig && (treeOpts.showLine || treeOpts.line) && (!(props.rowKey || rowOpts.useKey) || !showOverflow)) {
            warnLog("vxe.error.reqProp", ["row-config.useKey | show-overflow"]);
          }
          if (treeConfig && !treeOpts.transform && props.stripe) {
            warnLog("vxe.error.noTree", ["stripe"]);
          }
          if (props.showFooter && !(props.footerMethod || props.footerData)) {
            warnLog("vxe.error.reqProp", ["footer-data | footer-method"]);
          }
          const { exportConfig, importConfig } = props;
          const exportOpts = computeExportOpts.value;
          const importOpts = computeImportOpts.value;
          if (importConfig && importOpts.types && !importOpts.importMethod && !import_xe_utils27.default.includeArrays(import_xe_utils27.default.keys(importOpts._typeMaps), importOpts.types)) {
            warnLog("vxe.error.errProp", [`export-config.types=${importOpts.types.join(",")}`, importOpts.types.filter((type) => import_xe_utils27.default.includes(import_xe_utils27.default.keys(importOpts._typeMaps), type)).join(",") || import_xe_utils27.default.keys(importOpts._typeMaps).join(",")]);
          }
          if (exportConfig && exportOpts.types && !exportOpts.exportMethod && !import_xe_utils27.default.includeArrays(import_xe_utils27.default.keys(exportOpts._typeMaps), exportOpts.types)) {
            warnLog("vxe.error.errProp", [`export-config.types=${exportOpts.types.join(",")}`, exportOpts.types.filter((type) => import_xe_utils27.default.includes(import_xe_utils27.default.keys(exportOpts._typeMaps), type)).join(",") || import_xe_utils27.default.keys(exportOpts._typeMaps).join(",")]);
          }
        }
        if (true) {
          const customOpts = computeCustomOpts.value;
          const mouseOpts = computeMouseOpts.value;
          const rowOpts2 = computeRowOpts.value;
          if (!props.id) {
            if ((props.customConfig ? isEnableConf(customOpts) : customOpts.enabled) && customOpts.storage) {
              errLog("vxe.error.reqProp", ["id"]);
            }
          }
          if (props.treeConfig && checkboxOpts.range) {
            errLog("vxe.error.noTree", ["checkbox-config.range"]);
          }
          if (rowOpts2.height && !props.showOverflow) {
            warnLog("vxe.error.notProp", ["table.show-overflow"]);
          }
          if (!$xeTable.handleMousedownCellAreaEvent) {
            if (props.areaConfig) {
              warnLog("vxe.error.notProp", ["area-config"]);
            }
            if (props.clipConfig) {
              warnLog("vxe.error.notProp", ["clip-config"]);
            }
            if (props.fnrConfig) {
              warnLog("vxe.error.notProp", ["fnr-config"]);
            }
            if (mouseOpts.area) {
              errLog("vxe.error.notProp", ["mouse-config.area"]);
              return;
            }
          }
          if (props.dragConfig) {
            warnLog("vxe.error.delProp", ["drag-config", "row-drag-config"]);
          }
          if (props.treeConfig && treeOpts.children) {
            warnLog("vxe.error.delProp", ["tree-config.children", "tree-config.childrenField"]);
          }
          if (props.treeConfig && treeOpts.line) {
            warnLog("vxe.error.delProp", ["tree-config.line", "tree-config.showLine"]);
          }
          if (mouseOpts.area && mouseOpts.selected) {
            warnLog("vxe.error.errConflicts", ["mouse-config.area", "mouse-config.selected"]);
          }
          if (mouseOpts.area && (props.treeConfig && !treeOpts.transform)) {
            errLog("vxe.error.noTree", ["mouse-config.area"]);
          }
          if (props.editConfig && editOpts.activeMethod) {
            warnLog("vxe.error.delProp", ["edit-config.activeMethod", "edit-config.beforeEditMethod"]);
          }
          if (props.treeConfig && checkboxOpts.isShiftKey) {
            errLog("vxe.error.errConflicts", ["tree-config", "checkbox-config.isShiftKey"]);
          }
          if (checkboxOpts.halfField) {
            warnLog("vxe.error.delProp", ["checkbox-config.halfField", "checkbox-config.indeterminateField"]);
          }
        }
        if (true) {
          if (props.editConfig && !$xeTable.insert) {
            errLog("vxe.error.reqModule", ["Edit"]);
          }
          if (props.editRules && !$xeTable.validate) {
            errLog("vxe.error.reqModule", ["Validator"]);
          }
          if ((checkboxOpts.range || props.keyboardConfig || props.mouseConfig) && !$xeTable.handleCellMousedownEvent) {
            errLog("vxe.error.reqModule", ["Keyboard"]);
          }
          if ((props.printConfig || props.importConfig || props.exportConfig) && !$xeTable.exportData) {
            errLog("vxe.error.reqModule", ["Export"]);
          }
        }
        Object.assign(scrollYStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0,
          adaptive: sYOpts.adaptive !== false
        });
        Object.assign(scrollXStore, {
          startIndex: 0,
          endIndex: 0,
          visibleSize: 0
        });
        loadTableData(data || []).then(() => {
          if (data && data.length) {
            internalData.inited = true;
            internalData.initStatus = true;
            handleLoadDefaults();
          }
          handleInitDefaults();
          updateStyle();
        });
        if (props.autoResize) {
          const resizeOpts = computeResizeOpts.value;
          const { refreshDelay } = resizeOpts;
          const el2 = refElem.value;
          const parentEl2 = tablePrivateMethods.getParentElem();
          const handleOptimizeResize = refreshDelay ? import_xe_utils27.default.throttle(() => tableMethods.recalculate(true), refreshDelay, { leading: true, trailing: true }) : null;
          resizeObserver = globalResize3.create(handleOptimizeResize ? () => {
            if (props.autoResize) {
              handleOptimizeResize();
            }
          } : () => {
            if (props.autoResize) {
              tableMethods.recalculate(true);
            }
          });
          if (el2) {
            resizeObserver.observe(el2);
          }
          if (parentEl2) {
            resizeObserver.observe(parentEl2);
          }
        }
      });
      globalEvents3.on($xeTable, "paste", handleGlobalPasteEvent);
      globalEvents3.on($xeTable, "copy", handleGlobalCopyEvent);
      globalEvents3.on($xeTable, "cut", handleGlobalCutEvent);
      globalEvents3.on($xeTable, "mousedown", handleGlobalMousedownEvent);
      globalEvents3.on($xeTable, "blur", handleGlobalBlurEvent);
      globalEvents3.on($xeTable, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents3.on($xeTable, "keydown", handleGlobalKeydownEvent);
      globalEvents3.on($xeTable, "resize", handleGlobalResizeEvent);
      globalEvents3.on($xeTable, "contextmenu", $xeTable.handleGlobalContextmenuEvent);
      tablePrivateMethods.preventEvent(null, "mounted", { $table: $xeTable });
    });
    onBeforeUnmount(() => {
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      tableMethods.closeFilter();
      if ($xeTable.closeMenu) {
        $xeTable.closeMenu();
      }
      tablePrivateMethods.preventEvent(null, "beforeUnmount", { $table: $xeTable });
    });
    onUnmounted(() => {
      globalEvents3.off($xeTable, "paste");
      globalEvents3.off($xeTable, "copy");
      globalEvents3.off($xeTable, "cut");
      globalEvents3.off($xeTable, "mousedown");
      globalEvents3.off($xeTable, "blur");
      globalEvents3.off($xeTable, "mousewheel");
      globalEvents3.off($xeTable, "keydown");
      globalEvents3.off($xeTable, "resize");
      globalEvents3.off($xeTable, "contextmenu");
      tablePrivateMethods.preventEvent(null, "unmounted", { $table: $xeTable });
    });
    if (true) {
      nextTick(() => {
        if (props.loading) {
          if (!VxeUILoadingComponent && !slots.loading) {
            errLog("vxe.error.reqComp", ["vxe-loading"]);
          }
        }
        if (props.showOverflow === true || props.showOverflow === "tooltip" || (props.showHeaderOverflow === true || props.showHeaderOverflow === "tooltip") || (props.showFooterOverflow === true || props.showFooterOverflow === "tooltip") || props.tooltipConfig || props.editRules) {
          if (!VxeUITooltipComponent) {
            errLog("vxe.error.reqComp", ["vxe-tooltip"]);
          }
        }
      });
    }
    provide("$xeColgroup", null);
    provide("$xeTable", $xeTable);
    $xeTable.renderVN = renderVN;
    return $xeTable;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/table/src/use/cell-view.js
var import_xe_utils28 = __toESM(require_xe_utils());
function useCellView(props) {
  const currColumn = computed(() => {
    const { renderParams } = props;
    return renderParams.column;
  });
  const currRow = computed(() => {
    const { renderParams } = props;
    return renderParams.row;
  });
  const cellOptions = computed(() => {
    const { renderOpts } = props;
    return renderOpts.props || {};
  });
  const cellModel = computed({
    get() {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils28.default.get(row, column.field);
    },
    set(value) {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils28.default.set(row, column.field, value);
    }
  });
  return {
    currColumn,
    currRow,
    cellModel,
    cellOptions
  };
}

// node_modules/vxe-table/es/table/module/filter/hook.js
var import_xe_utils29 = __toESM(require_xe_utils());
var { renderer: renderer9, hooks: hooks4 } = VxeUI;
var tableFilterMethodKeys = ["openFilter", "setFilter", "clearFilter", "saveFilterPanel", "resetFilterPanel", "getCheckedFilters", "updateFilterOptionStatus"];
hooks4.add("tableFilterModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refTableHeader, refTableBody, refTableFilter } = $xeTable.getRefMaps();
    const { computeFilterOpts, computeMouseOpts } = $xeTable.getComputeMaps();
    const handleFilterConfirmFilter = (evnt) => {
      const { filterStore } = reactData;
      filterStore.options.forEach((option2) => {
        option2.checked = option2._checked;
      });
      $xeTable.confirmFilterEvent(evnt);
    };
    const changeRadioOption = (evnt, checked, item) => {
      const { filterStore } = reactData;
      filterStore.options.forEach((option2) => {
        option2._checked = false;
      });
      item._checked = checked;
      $xeTable.checkFilterOptions();
      handleFilterConfirmFilter(evnt);
    };
    const changeMultipleOption = (evnt, checked, item) => {
      item._checked = checked;
      $xeTable.checkFilterOptions();
    };
    const handleFilterResetFilter = (evnt) => {
      const { filterStore } = reactData;
      $xeTable.handleClearFilter(filterStore.column);
      $xeTable.confirmFilterEvent(evnt);
    };
    const filterPrivateMethods = {
      checkFilterOptions() {
        const { filterStore } = reactData;
        filterStore.isAllSelected = filterStore.options.every((item) => item._checked);
        filterStore.isIndeterminate = !filterStore.isAllSelected && filterStore.options.some((item) => item._checked);
      },
      /**
       * 点击筛选事件
       * 当筛选图标被点击时触发
       * 更新选项是否全部状态
       * 打开筛选面板
       * @param {Event} evnt 事件
       * @param {ColumnInfo} column 列配置
       * @param {Object} params 参数
       */
      triggerFilterEvent(evnt, column, params) {
        const { initStore, filterStore } = reactData;
        if (filterStore.column === column && filterStore.visible) {
          filterStore.visible = false;
        } else {
          const { target: targetElem, pageX } = evnt;
          const { visibleWidth } = getDomNode();
          const { filters, filterMultiple, filterRender } = column;
          const compConf = isEnableConf(filterRender) ? renderer9.get(filterRender.name) : null;
          const frMethod = column.filterRecoverMethod || (compConf ? compConf.tableFilterRecoverMethod || compConf.filterRecoverMethod : null);
          internalData._currFilterParams = params;
          Object.assign(filterStore, {
            multiple: filterMultiple,
            options: filters,
            column,
            style: null
          });
          filterStore.options.forEach((option2) => {
            const { _checked, checked } = option2;
            option2._checked = checked;
            if (!checked && _checked !== checked) {
              if (frMethod) {
                frMethod({ option: option2, column, $table: $xeTable });
              }
            }
          });
          this.checkFilterOptions();
          filterStore.visible = true;
          initStore.filter = true;
          nextTick(() => {
            const tableHeader = refTableHeader.value;
            const tableBody = refTableBody.value;
            const headerElem = tableHeader ? tableHeader.$el : null;
            const bodyElem = tableBody.$el;
            if (!bodyElem) {
              return;
            }
            const tableFilter = refTableFilter.value;
            const filterWrapperElem = tableFilter ? tableFilter.$el : null;
            if (!filterWrapperElem) {
              return;
            }
            const filterWidth = filterWrapperElem.offsetWidth;
            const filterHeight = filterWrapperElem.offsetHeight;
            const filterHeadElem = filterWrapperElem.querySelector(".vxe-table--filter-header");
            const filterFootElem = filterWrapperElem.querySelector(".vxe-table--filter-footer");
            const centerWidth = filterWidth / 2;
            const minMargin = 10;
            const maxLeft = bodyElem.clientWidth - filterWidth - minMargin;
            let left, right;
            const style = {
              top: `${targetElem.offsetTop + targetElem.offsetParent.offsetTop + targetElem.offsetHeight}px`
            };
            let maxHeight = null;
            const bodyHeight = bodyElem.clientHeight - (headerElem ? headerElem.clientHeight / 2 : 0);
            if (filterHeight >= bodyHeight) {
              maxHeight = Math.max(40, bodyHeight - (filterFootElem ? filterFootElem.offsetHeight : 0) - (filterHeadElem ? filterHeadElem.offsetHeight : 0));
            }
            if (column.fixed === "left") {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth;
            } else if (column.fixed === "right") {
              right = targetElem.offsetParent.offsetWidth - targetElem.offsetLeft + (targetElem.offsetParent.offsetParent.offsetWidth - targetElem.offsetParent.offsetLeft) - column.renderWidth - centerWidth;
            } else {
              left = targetElem.offsetLeft + targetElem.offsetParent.offsetLeft - centerWidth - bodyElem.scrollLeft;
            }
            if (left) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                left -= overflowWidth;
              }
              style.left = `${Math.min(maxLeft, Math.max(minMargin, left))}px`;
            } else if (right) {
              const overflowWidth = pageX + filterWidth - centerWidth + minMargin - visibleWidth;
              if (overflowWidth > 0) {
                right += overflowWidth;
              }
              style.right = `${Math.max(minMargin, right)}px`;
            }
            filterStore.style = style;
            filterStore.maxHeight = maxHeight;
          });
        }
        $xeTable.dispatchEvent("filter-visible", { column, field: column.field, property: column.field, filterList: $xeTable.getCheckedFilters(), visible: filterStore.visible }, evnt);
      },
      handleClearFilter(column) {
        if (column) {
          const { filters, filterRender } = column;
          if (filters) {
            const compConf = isEnableConf(filterRender) ? renderer9.get(filterRender.name) : null;
            const frMethod = column.filterResetMethod || (compConf ? compConf.tableFilterResetMethod || compConf.filterResetMethod : null);
            filters.forEach((item) => {
              item._checked = false;
              item.checked = false;
              if (!frMethod) {
                item.data = import_xe_utils29.default.clone(item.resetValue, true);
              }
            });
            if (frMethod) {
              frMethod({ options: filters, column, $table: $xeTable });
            }
          }
        }
      },
      handleColumnConfirmFilter(column, evnt) {
        const { mouseConfig } = props;
        const { scrollXLoad: oldScrollXLoad, scrollYLoad: oldScrollYLoad } = reactData;
        const filterOpts = computeFilterOpts.value;
        const mouseOpts = computeMouseOpts.value;
        const { field } = column;
        const values = [];
        const datas = [];
        column.filters.forEach((item) => {
          if (item.checked) {
            values.push(item.value);
            datas.push(item.data);
          }
        });
        const filterList = $xeTable.getCheckedFilters();
        const params = { $table: $xeTable, $event: evnt, column, field, property: field, values, datas, filters: filterList, filterList };
        if (!filterOpts.remote) {
          $xeTable.handleTableData(true);
          $xeTable.checkSelectionStatus();
        }
        if (mouseConfig && mouseOpts.area && $xeTable.handleFilterEvent) {
          $xeTable.handleFilterEvent(evnt, params);
        }
        if (evnt) {
          $xeTable.dispatchEvent("filter-change", params, evnt);
        }
        $xeTable.closeFilter();
        return $xeTable.updateFooter().then(() => {
          const { scrollXLoad, scrollYLoad } = reactData;
          if (oldScrollXLoad || scrollXLoad || (oldScrollYLoad || scrollYLoad)) {
            if (oldScrollXLoad || scrollXLoad) {
              $xeTable.updateScrollXSpace();
            }
            if (oldScrollYLoad || scrollYLoad) {
              $xeTable.updateScrollYSpace();
            }
            return $xeTable.refreshScroll();
          }
        }).then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate(true);
        }).then(() => {
          setTimeout(() => $xeTable.recalculate(), 50);
        });
      },
      /**
       * 确认筛选
       * 当筛选面板中的确定按钮被按下时触发
       * @param {Event} evnt 事件
       */
      confirmFilterEvent(evnt) {
        const { filterStore } = reactData;
        const { column } = filterStore;
        $xeTable.handleColumnConfirmFilter(column, evnt);
      },
      handleFilterChangeRadioOption: changeRadioOption,
      handleFilterChangeMultipleOption: changeMultipleOption,
      // 筛选发生改变
      handleFilterChangeOption(evnt, checked, item) {
        const { filterStore } = reactData;
        if (filterStore.multiple) {
          changeMultipleOption(evnt, checked, item);
        } else {
          changeRadioOption(evnt, checked, item);
        }
      },
      handleFilterConfirmFilter,
      handleFilterResetFilter
    };
    const filterMethods = {
      /**
       * 手动弹出筛选面板
       * @param column
       */
      openFilter(fieldOrColumn) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          const { elemStore } = internalData;
          const { fixed } = column;
          return $xeTable.scrollToColumn(column).then(() => {
            const headerWrapperElem = getRefElem(elemStore[`${fixed || "main"}-header-wrapper`] || elemStore["main-header-wrapper"]);
            if (headerWrapperElem) {
              const filterBtnElem = headerWrapperElem.querySelector(`.vxe-header--column.${column.id} .vxe-filter--btn`);
              triggerEvent2(filterBtnElem, "click");
            }
          });
        }
        return nextTick();
      },
      /**
       * 修改筛选条件列表
       * @param {ColumnInfo} fieldOrColumn 列或字段名
       * @param {Array} options 选项
       */
      setFilter(fieldOrColumn, options, isUpdate) {
        const column = handleFieldOrColumn($xeTable, fieldOrColumn);
        if (column && column.filters) {
          column.filters = toFilters(options || []);
          if (isUpdate) {
            return $xeTable.handleColumnConfirmFilter(column, new Event("click"));
          }
        }
        return nextTick();
      },
      /**
       * 清空指定列的筛选条件
       * 如果为空则清空所有列的筛选条件
       * @param {String} fieldOrColumn 列或字段名
       */
      clearFilter(fieldOrColumn) {
        const { filterStore } = reactData;
        const { tableFullColumn } = internalData;
        const filterOpts = computeFilterOpts.value;
        let column;
        if (fieldOrColumn) {
          column = handleFieldOrColumn($xeTable, fieldOrColumn);
          if (column) {
            filterPrivateMethods.handleClearFilter(column);
          }
        } else {
          tableFullColumn.forEach(filterPrivateMethods.handleClearFilter);
        }
        if (!fieldOrColumn || column !== filterStore.column) {
          Object.assign(filterStore, {
            isAllSelected: false,
            isIndeterminate: false,
            style: null,
            options: [],
            column: null,
            multiple: false,
            visible: false
          });
        }
        if (!filterOpts.remote) {
          return $xeTable.updateData();
        }
        return nextTick();
      },
      saveFilterPanel() {
        handleFilterConfirmFilter(null);
        return nextTick();
      },
      resetFilterPanel() {
        handleFilterResetFilter(null);
        return nextTick();
      },
      getCheckedFilters() {
        const { tableFullColumn } = internalData;
        const filterList = [];
        tableFullColumn.forEach((column) => {
          const { field, filters } = column;
          const valueList = [];
          const dataList = [];
          if (filters && filters.length) {
            filters.forEach((item) => {
              if (item.checked) {
                valueList.push(item.value);
                dataList.push(item.data);
              }
            });
            if (valueList.length) {
              filterList.push({ column, field, property: field, values: valueList, datas: dataList });
            }
          }
        });
        return filterList;
      },
      updateFilterOptionStatus(item, checked) {
        item._checked = checked;
        item.checked = checked;
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, filterMethods), filterPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableFilterMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/menu/hook.js
var import_xe_utils30 = __toESM(require_xe_utils());
var { menus: menus3, hooks: hooks5, globalEvents: globalEvents4, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS3 } = VxeUI;
var tableMenuMethodKeys = ["closeMenu"];
hooks5.add("tableMenuModule", {
  setupTable($xeTable) {
    const { xID, props, reactData, internalData } = $xeTable;
    const { refElem, refTableFilter, refTableMenu } = $xeTable.getRefMaps();
    const { computeMouseOpts, computeIsMenu, computeMenuOpts } = $xeTable.getComputeMaps();
    let menuMethods = {};
    let menuPrivateMethods = {};
    const handleOpenMenuEvent = (evnt, type, params) => {
      const { ctxMenuStore } = reactData;
      const isMenu = computeIsMenu.value;
      const menuOpts = computeMenuOpts.value;
      const config3 = menuOpts[type];
      const visibleMethod = menuOpts.visibleMethod;
      if (config3) {
        const { options, disabled } = config3;
        if (disabled) {
          evnt.preventDefault();
        } else if (isMenu && options && options.length) {
          params.options = options;
          $xeTable.preventEvent(evnt, "event.showMenu", params, () => {
            if (!visibleMethod || visibleMethod(params)) {
              evnt.preventDefault();
              $xeTable.updateZindex();
              const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode();
              let top = evnt.clientY + scrollTop;
              let left = evnt.clientX + scrollLeft;
              const handleVisible = () => {
                internalData._currMenuParams = params;
                Object.assign(ctxMenuStore, {
                  visible: true,
                  list: options,
                  selected: null,
                  selectChild: null,
                  showChild: false,
                  style: {
                    zIndex: internalData.tZindex,
                    top: `${top}px`,
                    left: `${left}px`
                  }
                });
                nextTick(() => {
                  const tableMenu = refTableMenu.value;
                  const ctxElem = tableMenu.getRefMaps().refElem.value;
                  const clientHeight = ctxElem.clientHeight;
                  const clientWidth = ctxElem.clientWidth;
                  const { boundingTop, boundingLeft } = getAbsolutePos(ctxElem);
                  const offsetTop = boundingTop + clientHeight - visibleHeight;
                  const offsetLeft = boundingLeft + clientWidth - visibleWidth;
                  if (offsetTop > -10) {
                    ctxMenuStore.style.top = `${Math.max(scrollTop + 2, top - clientHeight - 2)}px`;
                  }
                  if (offsetLeft > -10) {
                    ctxMenuStore.style.left = `${Math.max(scrollLeft + 2, left - clientWidth - 2)}px`;
                  }
                });
              };
              const { keyboard, row, column } = params;
              if (keyboard && row && column) {
                $xeTable.scrollToRow(row, column).then(() => {
                  const cell = $xeTable.getCellElement(row, column);
                  if (cell) {
                    const { boundingTop, boundingLeft } = getAbsolutePos(cell);
                    top = boundingTop + scrollTop + Math.floor(cell.offsetHeight / 2);
                    left = boundingLeft + scrollLeft + Math.floor(cell.offsetWidth / 2);
                  }
                  handleVisible();
                });
              } else {
                handleVisible();
              }
            } else {
              menuMethods.closeMenu();
            }
          });
        }
      }
      $xeTable.closeFilter();
    };
    menuMethods = {
      /**
       * 关闭快捷菜单
       */
      closeMenu() {
        Object.assign(reactData.ctxMenuStore, {
          visible: false,
          selected: null,
          selectChild: null,
          showChild: false
        });
        return nextTick();
      }
    };
    menuPrivateMethods = {
      /**
       * 处理菜单的移动
       */
      moveCtxMenu(evnt, ctxMenuStore, property, hasOper, operRest, menuList) {
        let selectItem;
        const selectIndex = import_xe_utils30.default.findIndexOf(menuList, (item) => ctxMenuStore[property] === item);
        if (hasOper) {
          if (operRest && hasChildrenList(ctxMenuStore.selected)) {
            ctxMenuStore.showChild = true;
          } else {
            ctxMenuStore.showChild = false;
            ctxMenuStore.selectChild = null;
          }
        } else if (globalEvents4.hasKey(evnt, GLOBAL_EVENT_KEYS3.ARROW_UP)) {
          for (let len = selectIndex - 1; len >= 0; len--) {
            if (menuList[len].visible !== false) {
              selectItem = menuList[len];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[menuList.length - 1];
        } else if (globalEvents4.hasKey(evnt, GLOBAL_EVENT_KEYS3.ARROW_DOWN)) {
          for (let index2 = selectIndex + 1; index2 < menuList.length; index2++) {
            if (menuList[index2].visible !== false) {
              selectItem = menuList[index2];
              break;
            }
          }
          ctxMenuStore[property] = selectItem || menuList[0];
        } else if (ctxMenuStore[property] && (globalEvents4.hasKey(evnt, GLOBAL_EVENT_KEYS3.ENTER) || globalEvents4.hasKey(evnt, GLOBAL_EVENT_KEYS3.SPACEBAR))) {
          menuPrivateMethods.ctxMenuLinkEvent(evnt, ctxMenuStore[property]);
        }
      },
      handleOpenMenuEvent,
      /**
       * 快捷菜单事件处理
       */
      handleGlobalContextmenuEvent(evnt) {
        const { mouseConfig, menuConfig } = props;
        const { editStore, ctxMenuStore } = reactData;
        const { visibleColumn } = internalData;
        const tableFilter = refTableFilter.value;
        const tableMenu = refTableMenu.value;
        const mouseOpts = computeMouseOpts.value;
        const menuOpts = computeMenuOpts.value;
        const el2 = refElem.value;
        const { selected } = editStore;
        const layoutList = ["header", "body", "footer"];
        if (isEnableConf(menuConfig)) {
          if (ctxMenuStore.visible && tableMenu && getEventTargetNode(evnt, tableMenu.getRefMaps().refElem.value).flag) {
            evnt.preventDefault();
            return;
          }
          if (internalData._keyCtx) {
            const type = "body";
            const params = { type, $table: $xeTable, keyboard: true, columns: visibleColumn.slice(0), $event: evnt };
            if (mouseConfig && mouseOpts.area) {
              const activeArea = $xeTable.getActiveCellArea();
              if (activeArea && activeArea.row && activeArea.column) {
                params.row = activeArea.row;
                params.column = activeArea.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            } else if (mouseConfig && mouseOpts.selected) {
              if (selected.row && selected.column) {
                params.row = selected.row;
                params.column = selected.column;
                handleOpenMenuEvent(evnt, type, params);
                return;
              }
            }
          }
          for (let index2 = 0; index2 < layoutList.length; index2++) {
            const layout = layoutList[index2];
            const columnTargetNode = getEventTargetNode(evnt, el2, `vxe-${layout}--column`, (target) => {
              return target.parentNode.parentNode.parentNode.getAttribute("xid") === xID;
            });
            const params = { type: layout, $table: $xeTable, columns: visibleColumn.slice(0), $event: evnt };
            if (columnTargetNode.flag) {
              const cell = columnTargetNode.targetElem;
              const columnNodeRest = $xeTable.getColumnNode(cell);
              const column = columnNodeRest ? columnNodeRest.item : null;
              let typePrefix = `${layout}-`;
              if (column) {
                Object.assign(params, { column, columnIndex: $xeTable.getColumnIndex(column), cell });
              }
              if (layout === "body") {
                const rowNodeRest = $xeTable.getRowNode(cell.parentNode);
                const row = rowNodeRest ? rowNodeRest.item : null;
                typePrefix = "";
                if (row) {
                  params.row = row;
                  params.rowIndex = $xeTable.getRowIndex(row);
                }
              }
              const eventType = `${typePrefix}cell-menu`;
              handleOpenMenuEvent(evnt, layout, params);
              $xeTable.dispatchEvent(eventType, params, evnt);
              return;
            } else if (getEventTargetNode(evnt, el2, `vxe-table--${layout}-wrapper`, (target) => target.getAttribute("xid") === xID).flag) {
              if (menuOpts.trigger === "cell") {
                evnt.preventDefault();
              } else {
                handleOpenMenuEvent(evnt, layout, params);
              }
              return;
            }
          }
        }
        if (tableFilter && !getEventTargetNode(evnt, tableFilter.$el).flag) {
          $xeTable.closeFilter();
        }
        menuMethods.closeMenu();
      },
      ctxMenuMouseoverEvent(evnt, item, child) {
        const menuElem = evnt.currentTarget;
        const { ctxMenuStore } = reactData;
        evnt.preventDefault();
        evnt.stopPropagation();
        ctxMenuStore.selected = item;
        ctxMenuStore.selectChild = child;
        if (!child) {
          ctxMenuStore.showChild = hasChildrenList(item);
          if (ctxMenuStore.showChild) {
            nextTick(() => {
              const childWrapperElem = menuElem.nextElementSibling;
              if (childWrapperElem) {
                const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos(menuElem);
                const posTop = boundingTop + menuElem.offsetHeight;
                const posLeft = boundingLeft + menuElem.offsetWidth;
                let left = "";
                let right = "";
                if (posLeft + childWrapperElem.offsetWidth > visibleWidth - 10) {
                  left = "auto";
                  right = `${menuElem.offsetWidth}px`;
                }
                let top = "";
                let bottom = "";
                if (posTop + childWrapperElem.offsetHeight > visibleHeight - 10) {
                  top = "auto";
                  bottom = "0";
                }
                childWrapperElem.style.left = left;
                childWrapperElem.style.right = right;
                childWrapperElem.style.top = top;
                childWrapperElem.style.bottom = bottom;
              }
            });
          }
        }
      },
      ctxMenuMouseoutEvent(evnt, item) {
        const { ctxMenuStore } = reactData;
        if (!item.children) {
          ctxMenuStore.selected = null;
        }
        ctxMenuStore.selectChild = null;
      },
      /**
       * 快捷菜单点击事件
       */
      ctxMenuLinkEvent(evnt, menu) {
        if (!menu.disabled && (menu.code || !menu.children || !menu.children.length)) {
          const gMenuOpts = menus3.get(menu.code);
          const params = Object.assign({}, internalData._currMenuParams, { menu, $table: $xeTable, $grid: $xeTable.xegrid, $event: evnt });
          const tmMethod = gMenuOpts ? gMenuOpts.tableMenuMethod || gMenuOpts.menuMethod : null;
          if (tmMethod) {
            tmMethod(params, evnt);
          }
          $xeTable.dispatchEvent("menu-click", params, evnt);
          menuMethods.closeMenu();
        }
      }
    };
    return Object.assign(Object.assign({}, menuMethods), menuPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableMenuMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/edit/hook.js
var import_xe_utils31 = __toESM(require_xe_utils());
var { getConfig: getConfig5, renderer: renderer10, hooks: hooks6, getI18n: getI18n11 } = VxeUI;
var tableEditMethodKeys = ["insert", "insertAt", "insertNextAt", "remove", "removeCheckboxRow", "removeRadioRow", "removeCurrentRow", "getRecordset", "getInsertRecords", "getRemoveRecords", "getUpdateRecords", "getEditRecord", "getActiveRecord", "getSelectedCell", "clearEdit", "clearActived", "clearSelected", "isEditByRow", "isActiveByRow", "setEditRow", "setActiveRow", "setEditCell", "setActiveCell", "setSelectCell"];
hooks6.add("tableEditModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem } = $xeTable.getRefMaps();
    const { computeMouseOpts, computeEditOpts, computeCheckboxOpts, computeTreeOpts, computeValidOpts } = $xeTable.getComputeMaps();
    let editMethods = {};
    let editPrivateMethods = {};
    const getEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender) {
        model.value = getCellValue(row, column);
        model.update = false;
      }
    };
    const setEditColumnModel = (row, column) => {
      const { model, editRender } = column;
      if (editRender && model.update) {
        setCellValue(row, column, model.value);
        model.update = false;
        model.value = null;
      }
    };
    const removeCellSelectedClass = () => {
      const el2 = refElem.value;
      if (el2) {
        const cell = el2.querySelector(".col--selected");
        if (cell) {
          removeClass(cell, "col--selected");
        }
      }
    };
    function syncActivedCell() {
      const { editStore, tableColumn } = reactData;
      const editOpts = computeEditOpts.value;
      const { actived } = editStore;
      const { row, column } = actived;
      if (row || column) {
        if (editOpts.mode === "row") {
          tableColumn.forEach((column2) => setEditColumnModel(row, column2));
        } else {
          setEditColumnModel(row, column);
        }
      }
    }
    function insertTreeRow(newRecords, isAppend) {
      const { tableFullTreeData, afterFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { rowField, parentField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const funcName = isAppend ? "push" : "unshift";
      newRecords.forEach((item) => {
        const parentRowId = item[parentField];
        const rowid = getRowid($xeTable, item);
        const matchObj = parentRowId ? import_xe_utils31.default.findTree(tableFullTreeData, (item2) => parentRowId === item2[rowField], { children: mapChildrenField }) : null;
        if (matchObj) {
          const { item: parentRow } = matchObj;
          const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
          const parentLevel = parentRest ? parentRest.level : 0;
          let parentChilds = parentRow[childrenField];
          let mapChilds = parentRow[mapChildrenField];
          if (!import_xe_utils31.default.isArray(parentChilds)) {
            parentChilds = parentRow[childrenField] = [];
          }
          if (!import_xe_utils31.default.isArray(mapChilds)) {
            mapChilds = parentRow[childrenField] = [];
          }
          parentChilds[funcName](item);
          mapChilds[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentChilds, parent: parentRow, level: parentLevel + 1, height: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        } else {
          if (true) {
            if (parentRowId) {
              warnLog("vxe.error.unableInsert");
            }
          }
          afterFullData[funcName](item);
          tableFullTreeData[funcName](item);
          const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: tableFullTreeData, parent: null, level: 0, height: 0 };
          fullDataRowIdData[rowid] = rest;
          fullAllDataRowIdData[rowid] = rest;
        }
      });
    }
    const handleInsertRowAt = (records, row, isInsertNextRow) => {
      const { treeConfig } = props;
      const { mergeList, editStore } = reactData;
      const { tableFullTreeData, afterFullData, tableFullData, fullDataRowIdData, fullAllDataRowIdData } = internalData;
      const treeOpts = computeTreeOpts.value;
      const { transform: transform2, rowField, mapChildrenField } = treeOpts;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      if (!import_xe_utils31.default.isArray(records)) {
        records = [records];
      }
      const newRecords = reactive($xeTable.defineField(records.map((record) => Object.assign(treeConfig && transform2 ? { [mapChildrenField]: [], [childrenField]: [] } : {}, record))));
      if (import_xe_utils31.default.eqNull(row)) {
        if (treeConfig && transform2) {
          insertTreeRow(newRecords, false);
        } else {
          newRecords.forEach((item) => {
            const rowid = getRowid($xeTable, item);
            const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: afterFullData, parent: null, level: 0, height: 0 };
            fullDataRowIdData[rowid] = rest;
            fullAllDataRowIdData[rowid] = rest;
            afterFullData.unshift(item);
            tableFullData.unshift(item);
          });
          mergeList.forEach((mergeItem) => {
            const { row: mergeRowIndex } = mergeItem;
            if (mergeRowIndex > 0) {
              mergeItem.row = mergeRowIndex + newRecords.length;
            }
          });
        }
      } else {
        if (row === -1) {
          if (treeConfig && transform2) {
            insertTreeRow(newRecords, true);
          } else {
            newRecords.forEach((item) => {
              const rowid = getRowid($xeTable, item);
              const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: afterFullData, parent: null, level: 0, height: 0 };
              fullDataRowIdData[rowid] = rest;
              fullAllDataRowIdData[rowid] = rest;
              afterFullData.push(item);
              tableFullData.push(item);
            });
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex + mergeRowspan > afterFullData.length) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        } else {
          if (treeConfig && transform2) {
            const matchMapObj = import_xe_utils31.default.findTree(tableFullTreeData, (item) => row[rowField] === item[rowField], { children: mapChildrenField });
            if (matchMapObj) {
              const { parent: parentRow } = matchMapObj;
              const parentMapChilds = parentRow ? parentRow[mapChildrenField] : tableFullTreeData;
              const parentRest = fullAllDataRowIdData[getRowid($xeTable, parentRow)];
              const parentLevel = parentRest ? parentRest.level : 0;
              newRecords.forEach((item, i) => {
                const rowid = getRowid($xeTable, item);
                if (true) {
                  if (item[treeOpts.parentField]) {
                    if (parentRow && item[treeOpts.parentField] !== parentRow[rowField]) {
                      errLog("vxe.error.errProp", [`${treeOpts.parentField}=${item[treeOpts.parentField]}`, `${treeOpts.parentField}=${parentRow[rowField]}`]);
                    }
                  }
                }
                if (parentRow) {
                  item[treeOpts.parentField] = parentRow[rowField];
                }
                let targetIndex = matchMapObj.index + i;
                if (isInsertNextRow) {
                  targetIndex = targetIndex + 1;
                }
                parentMapChilds.splice(targetIndex, 0, item);
                const rest = { row: item, rowid, seq: -1, index: -1, _index: -1, $index: -1, items: parentMapChilds, parent: parentRow, level: parentLevel + 1, height: 0 };
                fullDataRowIdData[rowid] = rest;
                fullAllDataRowIdData[rowid] = rest;
              });
              if (parentRow) {
                const matchObj = import_xe_utils31.default.findTree(tableFullTreeData, (item) => row[rowField] === item[rowField], { children: childrenField });
                if (matchObj) {
                  const parentChilds = matchObj.items;
                  let targetIndex = matchObj.index;
                  if (isInsertNextRow) {
                    targetIndex = targetIndex + 1;
                  }
                  parentChilds.splice(targetIndex, 0, ...newRecords);
                }
              }
            } else {
              if (true) {
                warnLog("vxe.error.unableInsert");
              }
              insertTreeRow(newRecords, true);
            }
          } else {
            if (treeConfig) {
              throw new Error(getI18n11("vxe.error.noTree", ["insert"]));
            }
            let afIndex = -1;
            if (import_xe_utils31.default.isNumber(row)) {
              if (row < afterFullData.length) {
                afIndex = row;
              }
            } else {
              afIndex = $xeTable.findRowIndexOf(afterFullData, row);
            }
            if (isInsertNextRow) {
              afIndex = Math.min(afterFullData.length, afIndex + 1);
            }
            if (afIndex === -1) {
              throw new Error(getI18n11("vxe.error.unableInsert"));
            }
            afterFullData.splice(afIndex, 0, ...newRecords);
            tableFullData.splice($xeTable.findRowIndexOf(tableFullData, row), 0, ...newRecords);
            mergeList.forEach((mergeItem) => {
              const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
              if (mergeRowIndex > afIndex) {
                mergeItem.row = mergeRowIndex + newRecords.length;
              } else if (mergeRowIndex + mergeRowspan > afIndex) {
                mergeItem.rowspan = mergeRowspan + newRecords.length;
              }
            });
          }
        }
      }
      const { insertMaps } = editStore;
      newRecords.forEach((newRow) => {
        const rowid = getRowid($xeTable, newRow);
        insertMaps[rowid] = newRow;
      });
      $xeTable.cacheRowMap();
      $xeTable.updateScrollYStatus();
      $xeTable.handleTableData(treeConfig && transform2);
      if (!(treeConfig && transform2)) {
        $xeTable.updateAfterDataIndex();
      }
      $xeTable.updateFooter();
      $xeTable.checkSelectionStatus();
      if (reactData.scrollYLoad) {
        $xeTable.updateScrollYSpace();
      }
      return nextTick().then(() => {
        $xeTable.updateCellAreas();
        return $xeTable.recalculate();
      }).then(() => {
        return {
          row: newRecords.length ? newRecords[newRecords.length - 1] : null,
          rows: newRecords
        };
      });
    };
    const handleClearEdit = (evnt, targetRow) => {
      const { mouseConfig } = props;
      const { editStore } = reactData;
      const { actived, focused } = editStore;
      const { row, column } = actived;
      const validOpts = computeValidOpts.value;
      const mouseOpts = computeMouseOpts.value;
      if (row || column) {
        if (targetRow && getRowid($xeTable, targetRow) !== getRowid($xeTable, row)) {
          return nextTick();
        }
        syncActivedCell();
        actived.args = null;
        actived.row = null;
        actived.column = null;
        $xeTable.updateFooter();
        $xeTable.dispatchEvent("edit-closed", {
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex: $xeTable.getVMRowIndex(row),
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex: $xeTable.getVMColumnIndex(column)
        }, evnt || null);
      }
      nextTick(() => {
        if (mouseConfig && mouseOpts.area && $xeTable.handleRecalculateCellAreas) {
          return $xeTable.handleRecalculateCellAreas();
        }
      });
      if (validOpts.autoClear) {
        if (validOpts.msgMode !== "full" || getConfig5().cellVaildMode === "obsolete") {
          if ($xeTable.clearValidate) {
            return $xeTable.clearValidate();
          }
        }
      }
      focused.row = null;
      focused.column = null;
      return nextTick();
    };
    editMethods = {
      /**
       * 往表格中插入临时数据
       *
       * @param {*} records
       */
      insert(records) {
        return handleInsertRowAt(records, null);
      },
      /**
       * 往表格指定行中插入临时数据
       * 如果 row 为空则从插入到顶部，如果为树结构，则插入到目标节点顶部
       * 如果 row 为 -1 则从插入到底部，如果为树结构，则插入到目标节点底部
       * 如果 row 为有效行则插入到该行的位置，如果为树结构，则有插入到效的目标节点该行的位置
       * @param {Object/Array} records 新的数据
       * @param {Row} row 指定行
       */
      insertAt(records, row) {
        return handleInsertRowAt(records, row);
      },
      insertNextAt(records, row) {
        return handleInsertRowAt(records, row, true);
      },
      /**
       * 删除指定行数据
       * 如果传 row 则删除一行
       * 如果传 rows 则删除多行
       * 如果为空则删除所有
       */
      remove(rows) {
        const { treeConfig } = props;
        const { mergeList, editStore, selectCheckboxMaps } = reactData;
        const { tableFullTreeData, afterFullData, tableFullData } = internalData;
        const checkboxOpts = computeCheckboxOpts.value;
        const treeOpts = computeTreeOpts.value;
        const { transform: transform2, mapChildrenField } = treeOpts;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const { actived, removeMaps } = editStore;
        const insertDataRowMaps = Object.assign({}, editStore.insertMaps);
        const pendingDataRowMaps = Object.assign({}, reactData.pendingRowMaps);
        const { checkField } = checkboxOpts;
        let delList = [];
        if (!rows) {
          rows = tableFullData;
        } else if (!import_xe_utils31.default.isArray(rows)) {
          rows = [rows];
        }
        rows.forEach((row) => {
          if (!$xeTable.isInsertByRow(row)) {
            const rowid = getRowid($xeTable, row);
            removeMaps[rowid] = row;
          }
        });
        if (!checkField) {
          const selectRowMaps = Object.assign({}, selectCheckboxMaps);
          rows.forEach((row) => {
            const rowid = getRowid($xeTable, row);
            if (selectRowMaps[rowid]) {
              delete selectRowMaps[rowid];
            }
          });
          reactData.selectCheckboxMaps = selectRowMaps;
        }
        if (tableFullData === rows) {
          rows = delList = tableFullData.slice(0);
          internalData.tableFullData = [];
          internalData.afterFullData = [];
          $xeTable.clearMergeCells();
        } else {
          if (treeConfig && transform2) {
            rows.forEach((row) => {
              const rowid = getRowid($xeTable, row);
              const matchMapObj = import_xe_utils31.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xeTable, item), { children: mapChildrenField });
              if (matchMapObj) {
                const rItems = matchMapObj.items.splice(matchMapObj.index, 1);
                delList.push(rItems[0]);
              }
              const matchObj = import_xe_utils31.default.findTree(tableFullTreeData, (item) => rowid === getRowid($xeTable, item), { children: childrenField });
              if (matchObj) {
                matchObj.items.splice(matchObj.index, 1);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                afterFullData.splice(afIndex, 1);
              }
            });
          } else {
            rows.forEach((row) => {
              const tfIndex = $xeTable.findRowIndexOf(tableFullData, row);
              if (tfIndex > -1) {
                const rItems = tableFullData.splice(tfIndex, 1);
                delList.push(rItems[0]);
              }
              const afIndex = $xeTable.findRowIndexOf(afterFullData, row);
              if (afIndex > -1) {
                mergeList.forEach((mergeItem) => {
                  const { row: mergeRowIndex, rowspan: mergeRowspan } = mergeItem;
                  if (mergeRowIndex > afIndex) {
                    mergeItem.row = mergeRowIndex - 1;
                  } else if (mergeRowIndex + mergeRowspan > afIndex) {
                    mergeItem.rowspan = mergeRowspan - 1;
                  }
                });
                afterFullData.splice(afIndex, 1);
              }
            });
          }
        }
        if (actived.row && $xeTable.findRowIndexOf(rows, actived.row) > -1) {
          editMethods.clearEdit();
        }
        rows.forEach((row) => {
          const rowid = getRowid($xeTable, row);
          if (insertDataRowMaps[rowid]) {
            delete insertDataRowMaps[rowid];
          }
          if (pendingDataRowMaps[rowid]) {
            delete pendingDataRowMaps[rowid];
          }
        });
        editStore.insertMaps = insertDataRowMaps;
        reactData.pendingRowMaps = pendingDataRowMaps;
        $xeTable.updateFooter();
        $xeTable.cacheRowMap();
        $xeTable.handleTableData(treeConfig && transform2);
        if (!(treeConfig && transform2)) {
          $xeTable.updateAfterDataIndex();
        }
        $xeTable.checkSelectionStatus();
        if (reactData.scrollYLoad) {
          $xeTable.updateScrollYSpace();
        }
        return nextTick().then(() => {
          $xeTable.updateCellAreas();
          return $xeTable.recalculate();
        }).then(() => {
          return { row: delList.length ? delList[delList.length - 1] : null, rows: delList };
        });
      },
      /**
       * 删除复选框选中的数据
       */
      removeCheckboxRow() {
        return editMethods.remove($xeTable.getCheckboxRecords()).then((params) => {
          $xeTable.clearCheckboxRow();
          return params;
        });
      },
      /**
       * 删除单选框选中的数据
       */
      removeRadioRow() {
        const radioRecord = $xeTable.getRadioRecord();
        return editMethods.remove(radioRecord || []).then((params) => {
          $xeTable.clearRadioRow();
          return params;
        });
      },
      /**
       * 删除当前行选中的数据
       */
      removeCurrentRow() {
        const currentRecord = $xeTable.getCurrentRecord();
        return editMethods.remove(currentRecord || []).then((params) => {
          $xeTable.clearCurrentRow();
          return params;
        });
      },
      /**
       * 获取表格数据集，包含新增、删除、修改、标记
       */
      getRecordset() {
        const removeRecords = editMethods.getRemoveRecords();
        const pendingRecords = $xeTable.getPendingRecords();
        const delRecords = removeRecords.concat(pendingRecords);
        const updateRecords = editMethods.getUpdateRecords().filter((row) => {
          return !delRecords.some((item) => $xeTable.eqRow(item, row));
        });
        return {
          insertRecords: editMethods.getInsertRecords(),
          removeRecords,
          updateRecords,
          pendingRecords
        };
      },
      /**
       * 获取新增的临时数据
       */
      getInsertRecords() {
        const { editStore } = reactData;
        const { fullAllDataRowIdData } = internalData;
        const { insertMaps } = editStore;
        const insertRecords = [];
        import_xe_utils31.default.each(insertMaps, (row, rowid) => {
          if (fullAllDataRowIdData[rowid]) {
            insertRecords.push(row);
          }
        });
        return insertRecords;
      },
      /**
       * 获取已删除的数据
       */
      getRemoveRecords() {
        const { editStore } = reactData;
        const { removeMaps } = editStore;
        const removeRecords = [];
        import_xe_utils31.default.each(removeMaps, (row) => {
          removeRecords.push(row);
        });
        return removeRecords;
      },
      /**
       * 获取更新数据
       * 只精准匹配 row 的更改
       * 如果是树表格，子节点更改状态不会影响父节点的更新状态
       */
      getUpdateRecords() {
        const { keepSource, treeConfig } = props;
        const { tableFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        if (keepSource) {
          syncActivedCell();
          if (treeConfig) {
            return import_xe_utils31.default.filterTree(tableFullData, (row) => $xeTable.isUpdateByRow(row), treeOpts);
          }
          return tableFullData.filter((row) => $xeTable.isUpdateByRow(row));
        }
        return [];
      },
      getActiveRecord() {
        if (true) {
          warnLog("vxe.error.delFunc", ["getActiveRecord", "getEditRecord"]);
        }
        return this.getEditRecord();
      },
      getEditRecord() {
        const { editStore } = reactData;
        const { afterFullData } = internalData;
        const el2 = refElem.value;
        const { args, row } = editStore.actived;
        if (args && $xeTable.findRowIndexOf(afterFullData, row) > -1 && el2.querySelectorAll(".vxe-body--column.col--active").length) {
          return Object.assign({}, args);
        }
        return null;
      },
      /**
       * 获取选中的单元格
       */
      getSelectedCell() {
        const { editStore } = reactData;
        const { args, column } = editStore.selected;
        if (args && column) {
          return Object.assign({}, args);
        }
        return null;
      },
      clearActived(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["clearActived", "clearEdit"]);
        }
        return this.clearEdit(row);
      },
      /**
       * 清除激活的编辑
       */
      clearEdit(row) {
        return handleClearEdit(null, row);
      },
      /**
       * 清除所选中源状态
       */
      clearSelected() {
        const { editStore } = reactData;
        const { selected } = editStore;
        selected.row = null;
        selected.column = null;
        removeCellSelectedClass();
        return nextTick();
      },
      isActiveByRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["isActiveByRow", "isEditByRow"]);
        }
        return this.isEditByRow(row);
      },
      /**
       * 判断行是否为激活编辑状态
       * @param {Row} row 行对象
       */
      isEditByRow(row) {
        const { editStore } = reactData;
        return editStore.actived.row === row;
      },
      setActiveRow(row) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveRow", "setEditRow"]);
        }
        return editMethods.setEditRow(row);
      },
      /**
       * 激活行编辑
       */
      setEditRow(row, fieldOrColumn) {
        const { visibleColumn } = internalData;
        let column = import_xe_utils31.default.find(visibleColumn, (column2) => isEnableConf(column2.editRender));
        if (fieldOrColumn) {
          column = import_xe_utils31.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        }
        return $xeTable.setEditCell(row, column);
      },
      setActiveCell(row, fieldOrColumn) {
        if (true) {
          warnLog("vxe.error.delFunc", ["setActiveCell", "setEditCell"]);
        }
        return editMethods.setEditCell(row, fieldOrColumn);
      },
      /**
       * 激活单元格编辑
       */
      setEditCell(row, fieldOrColumn) {
        const { editConfig } = props;
        const column = import_xe_utils31.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && isEnableConf(editConfig) && isEnableConf(column.editRender)) {
          return $xeTable.scrollToRow(row, column).then(() => {
            const cell = $xeTable.getCellElement(row, column);
            if (cell) {
              editPrivateMethods.handleEdit({
                row,
                rowIndex: $xeTable.getRowIndex(row),
                column,
                columnIndex: $xeTable.getColumnIndex(column),
                cell,
                $table: $xeTable
              });
              internalData._lastCallTime = Date.now();
            }
            return nextTick();
          });
        }
        return nextTick();
      },
      /**
       * 只对 trigger=dblclick 有效，选中单元格
       */
      setSelectCell(row, fieldOrColumn) {
        const { tableData } = reactData;
        const editOpts = computeEditOpts.value;
        const column = import_xe_utils31.default.isString(fieldOrColumn) ? $xeTable.getColumnByField(fieldOrColumn) : fieldOrColumn;
        if (row && column && editOpts.trigger !== "manual") {
          const rowIndex = $xeTable.findRowIndexOf(tableData, row);
          if (rowIndex > -1 && column) {
            const cell = $xeTable.getCellElement(row, column);
            const params = {
              row,
              rowIndex,
              column,
              columnIndex: $xeTable.getColumnIndex(column),
              cell
            };
            $xeTable.handleSelected(params, {});
          }
        }
        return nextTick();
      }
    };
    editPrivateMethods = {
      /**
       * 处理激活编辑
       */
      handleEdit(params, evnt) {
        const { editConfig, mouseConfig } = props;
        const { editStore, tableColumn } = reactData;
        const editOpts = computeEditOpts.value;
        const { mode } = editOpts;
        const { actived, focused } = editStore;
        const { row, column } = params;
        const { editRender } = column;
        const cell = params.cell || $xeTable.getCellElement(row, column);
        const beforeEditMethod = editOpts.beforeEditMethod || editOpts.activeMethod;
        params.cell = cell;
        if (cell && isEnableConf(editConfig) && isEnableConf(editRender)) {
          if (!$xeTable.isPendingByRow(row)) {
            if (actived.row !== row || (mode === "cell" ? actived.column !== column : false)) {
              let type = "edit-disabled";
              if (!beforeEditMethod || beforeEditMethod(Object.assign(Object.assign({}, params), { $table: $xeTable, $grid: $xeTable.xegrid }))) {
                if (mouseConfig) {
                  editMethods.clearSelected();
                  if ($xeTable.clearCellAreas) {
                    $xeTable.clearCellAreas();
                    $xeTable.clearCopyCellArea();
                  }
                }
                $xeTable.closeTooltip();
                if (actived.column) {
                  handleClearEdit(evnt);
                }
                type = "edit-activated";
                column.renderHeight = cell.offsetHeight;
                actived.args = params;
                actived.row = row;
                actived.column = column;
                if (mode === "row") {
                  tableColumn.forEach((column2) => getEditColumnModel(row, column2));
                } else {
                  getEditColumnModel(row, column);
                }
                const afterEditMethod = editOpts.afterEditMethod;
                nextTick(() => {
                  editPrivateMethods.handleFocus(params, evnt);
                  if (afterEditMethod) {
                    afterEditMethod(Object.assign(Object.assign({}, params), { $table: $xeTable, $grid: $xeTable.xegrid }));
                  }
                });
              }
              $xeTable.dispatchEvent(type, {
                row,
                rowIndex: $xeTable.getRowIndex(row),
                $rowIndex: $xeTable.getVMRowIndex(row),
                column,
                columnIndex: $xeTable.getColumnIndex(column),
                $columnIndex: $xeTable.getVMColumnIndex(column)
              }, evnt);
              if (type === "edit-activated") {
                $xeTable.dispatchEvent("edit-actived", {
                  row,
                  rowIndex: $xeTable.getRowIndex(row),
                  $rowIndex: $xeTable.getVMRowIndex(row),
                  column,
                  columnIndex: $xeTable.getColumnIndex(column),
                  $columnIndex: $xeTable.getVMColumnIndex(column)
                }, evnt);
              }
            } else {
              const { column: oldColumn } = actived;
              if (mouseConfig) {
                editMethods.clearSelected();
                if ($xeTable.clearCellAreas) {
                  $xeTable.clearCellAreas();
                  $xeTable.clearCopyCellArea();
                }
              }
              if (oldColumn !== column) {
                const { model: oldModel } = oldColumn;
                if (oldModel.update) {
                  setCellValue(row, oldColumn, oldModel.value);
                }
                if ($xeTable.clearValidate) {
                  $xeTable.clearValidate(row, column);
                }
              }
              column.renderHeight = cell.offsetHeight;
              actived.args = params;
              actived.column = column;
              setTimeout(() => {
                editPrivateMethods.handleFocus(params, evnt);
              });
            }
            focused.column = null;
            focused.row = null;
            $xeTable.focus();
          }
        }
        return nextTick();
      },
      /**
       * @deprecated
       */
      handleActived(params, evnt) {
        return editPrivateMethods.handleEdit(params, evnt);
      },
      /**
       * 处理取消编辑
       * @param evnt
       * @returns
       */
      handleClearEdit,
      /**
       * 处理聚焦
       */
      handleFocus(params) {
        const { row, column, cell } = params;
        const { editRender } = column;
        const editOpts = computeEditOpts.value;
        if (isEnableConf(editRender)) {
          const compRender = renderer10.get(editRender.name);
          let autoFocus = editRender.autofocus || editRender.autoFocus;
          let autoSelect = editRender.autoSelect || editRender.autoselect;
          let inputElem;
          if (editOpts.autoFocus) {
            if (!autoFocus && compRender) {
              autoFocus = compRender.tableAutoFocus || compRender.tableAutofocus || compRender.autofocus;
            }
            if (!autoSelect && compRender) {
              autoSelect = compRender.tableAutoSelect || compRender.autoselect;
            }
            if (import_xe_utils31.default.isFunction(autoFocus)) {
              inputElem = autoFocus(params);
            } else if (autoFocus) {
              if (autoFocus === true) {
                inputElem = cell.querySelector("input,textarea");
              } else {
                inputElem = cell.querySelector(autoFocus);
              }
              if (inputElem) {
                inputElem.focus();
              }
            }
          }
          if (inputElem) {
            if (autoSelect) {
              inputElem.select();
            } else {
              if (browse2.msie) {
                const textRange = inputElem.createTextRange();
                textRange.collapse(false);
                textRange.select();
              }
            }
          } else {
            if (editOpts.autoPos) {
              if (!column.fixed) {
                $xeTable.scrollToRow(row, column);
              }
            }
          }
        }
      },
      /**
       * 处理选中源
       */
      handleSelected(params, evnt) {
        const { mouseConfig } = props;
        const { editStore } = reactData;
        const mouseOpts = computeMouseOpts.value;
        const editOpts = computeEditOpts.value;
        const { actived, selected } = editStore;
        const { row, column } = params;
        const isMouseSelected = mouseConfig && mouseOpts.selected;
        const selectMethod = () => {
          if (isMouseSelected && (selected.row !== row || selected.column !== column)) {
            if (actived.row !== row || (editOpts.mode === "cell" ? actived.column !== column : false)) {
              handleClearEdit(evnt);
              editMethods.clearSelected();
              if ($xeTable.clearCellAreas) {
                $xeTable.clearCellAreas();
                $xeTable.clearCopyCellArea();
              }
              selected.args = params;
              selected.row = row;
              selected.column = column;
              if (isMouseSelected) {
                editPrivateMethods.addCellSelectedClass();
              }
              $xeTable.focus();
              if (evnt) {
                $xeTable.dispatchEvent("cell-selected", params, evnt);
              }
            }
          }
          return nextTick();
        };
        return selectMethod();
      },
      addCellSelectedClass() {
        const { editStore } = reactData;
        const { selected } = editStore;
        const { row, column } = selected;
        removeCellSelectedClass();
        if (row && column) {
          const cell = $xeTable.getCellElement(row, column);
          if (cell) {
            addClass(cell, "col--selected");
          }
        }
      }
    };
    return Object.assign(Object.assign({}, editMethods), editPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableEditMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/export/hook.js
var import_xe_utils32 = __toESM(require_xe_utils());

// node_modules/vxe-table/es/table/module/export/util.js
var defaultHtmlStyle = 'body{margin:0;padding: 0 1px;color:#333333;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function getExportBlobByContent(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
function createHtmlPage(opts, content) {
  const { style } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.sheetName}</title>`,
    '<style media="print">.vxe-page-break-before{page-break-before:always;}.vxe-page-break-after{page-break-after:always;}</style>',
    `<style>${defaultHtmlStyle}</style>`,
    style ? `<style>${style}</style>` : "",
    "</head>",
    `<body>${content}</body>`,
    "</html>"
  ].join("");
}

// node_modules/vxe-table/es/table/module/export/hook.js
var { getI18n: getI18n12, hooks: hooks7, renderer: renderer11 } = VxeUI;
var htmlCellElem;
var csvBOM = "\uFEFF";
var enterSymbol = "\r\n";
function defaultFilterExportColumn(column) {
  return column.property || ["seq", "checkbox", "radio"].indexOf(column.type) > -1;
}
var getConvertColumns = (columns) => {
  const result = [];
  columns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      result.push(column);
      result.push(...getConvertColumns(column.childNodes));
    } else {
      result.push(column);
    }
  });
  return result;
};
var convertToRows = (originColumns) => {
  let maxLevel = 1;
  const traverse = (column, parent) => {
    if (parent) {
      column._level = parent._level + 1;
      if (maxLevel < column._level) {
        maxLevel = column._level;
      }
    }
    if (column.childNodes && column.childNodes.length) {
      let colSpan = 0;
      column.childNodes.forEach((subColumn) => {
        traverse(subColumn, column);
        colSpan += subColumn._colSpan;
      });
      column._colSpan = colSpan;
    } else {
      column._colSpan = 1;
    }
  };
  originColumns.forEach((column) => {
    column._level = 1;
    traverse(column);
  });
  const rows = [];
  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }
  const allColumns = getConvertColumns(originColumns);
  allColumns.forEach((column) => {
    if (column.childNodes && column.childNodes.length) {
      column._rowSpan = 1;
    } else {
      column._rowSpan = maxLevel - column._level + 1;
    }
    rows[column._level - 1].push(column);
  });
  return rows;
};
function toTableBorder(border) {
  if (border === true) {
    return "full";
  }
  if (border) {
    return border;
  }
  return "default";
}
function getBooleanValue(cellValue) {
  return cellValue === "TRUE" || cellValue === "true" || cellValue === true;
}
function getFooterData(opts, footerTableData) {
  const { footerFilterMethod } = opts;
  return footerFilterMethod ? footerTableData.filter((items, index2) => footerFilterMethod({ items, $rowIndex: index2 })) : footerTableData;
}
function getCsvCellTypeLabel(column, cellValue) {
  if (cellValue) {
    if (column.type === "seq") {
      return `	${cellValue}`;
    }
    switch (column.cellType) {
      case "string":
        if (!isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
      case "number":
        break;
      default:
        if (cellValue.length >= 12 && !isNaN(cellValue)) {
          return `	${cellValue}`;
        }
        break;
    }
  }
  return cellValue;
}
function toTxtCellLabel(val) {
  if (/[",\s\n]/.test(val)) {
    return `"${val.replace(/"/g, '""')}"`;
  }
  return val;
}
function getElementsByTagName(elem, qualifiedName) {
  return elem.getElementsByTagName(qualifiedName);
}
function getTxtCellKey(now2) {
  return `#${now2}@${import_xe_utils32.default.uniqueId()}`;
}
function replaceTxtCell(cell, vMaps) {
  return cell.replace(/#\d+@\d+/g, (key) => import_xe_utils32.default.hasOwnProp(vMaps, key) ? vMaps[key] : key);
}
function getTxtCellValue(val, vMaps) {
  const rest = replaceTxtCell(val, vMaps);
  return rest.replace(/^"+$/g, (qVal) => '"'.repeat(Math.ceil(qVal.length / 2)));
}
function parseCsvAndTxt(columns, content, cellSeparator) {
  const list = content.split(enterSymbol);
  const rows = [];
  let fields = [];
  if (list.length) {
    const vMaps = {};
    const now2 = Date.now();
    list.forEach((rVal) => {
      if (rVal) {
        const item = {};
        rVal = rVal.replace(/("")|(\n)/g, (text, dVal) => {
          const key = getTxtCellKey(now2);
          vMaps[key] = dVal ? '"' : "\n";
          return key;
        }).replace(/"(.*?)"/g, (text, cVal) => {
          const key = getTxtCellKey(now2);
          vMaps[key] = replaceTxtCell(cVal, vMaps);
          return key;
        });
        const cells = rVal.split(cellSeparator);
        if (!fields.length) {
          fields = cells.map((val) => getTxtCellValue(val.trim(), vMaps));
        } else {
          cells.forEach((val, colIndex) => {
            if (colIndex < fields.length) {
              item[fields[colIndex]] = getTxtCellValue(val.trim(), vMaps);
            }
          });
          rows.push(item);
        }
      }
    });
  }
  return { fields, rows };
}
function parseCsv(columns, content) {
  return parseCsvAndTxt(columns, content, ",");
}
function parseTxt(columns, content) {
  return parseCsvAndTxt(columns, content, "	");
}
function parseHTML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "text/html");
  const bodyNodes = getElementsByTagName(xmlDoc, "body");
  const rows = [];
  const fields = [];
  if (bodyNodes.length) {
    const tableNodes = getElementsByTagName(bodyNodes[0], "table");
    if (tableNodes.length) {
      const theadNodes = getElementsByTagName(tableNodes[0], "thead");
      if (theadNodes.length) {
        import_xe_utils32.default.arrayEach(getElementsByTagName(theadNodes[0], "tr"), (rowNode) => {
          import_xe_utils32.default.arrayEach(getElementsByTagName(rowNode, "th"), (cellNode) => {
            fields.push(cellNode.textContent);
          });
        });
        const tbodyNodes = getElementsByTagName(tableNodes[0], "tbody");
        if (tbodyNodes.length) {
          import_xe_utils32.default.arrayEach(getElementsByTagName(tbodyNodes[0], "tr"), (rowNode) => {
            const item = {};
            import_xe_utils32.default.arrayEach(getElementsByTagName(rowNode, "td"), (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent || "";
              }
            });
            rows.push(item);
          });
        }
      }
    }
  }
  return { fields, rows };
}
function parseXML(columns, content) {
  const domParser = new DOMParser();
  const xmlDoc = domParser.parseFromString(content, "application/xml");
  const sheetNodes = getElementsByTagName(xmlDoc, "Worksheet");
  const rows = [];
  const fields = [];
  if (sheetNodes.length) {
    const tableNodes = getElementsByTagName(sheetNodes[0], "Table");
    if (tableNodes.length) {
      const rowNodes = getElementsByTagName(tableNodes[0], "Row");
      if (rowNodes.length) {
        import_xe_utils32.default.arrayEach(getElementsByTagName(rowNodes[0], "Cell"), (cellNode) => {
          fields.push(cellNode.textContent);
        });
        import_xe_utils32.default.arrayEach(rowNodes, (rowNode, index2) => {
          if (index2) {
            const item = {};
            const cellNodes = getElementsByTagName(rowNode, "Cell");
            import_xe_utils32.default.arrayEach(cellNodes, (cellNode, colIndex) => {
              if (fields[colIndex]) {
                item[fields[colIndex]] = cellNode.textContent;
              }
            });
            rows.push(item);
          }
        });
      }
    }
  }
  return { fields, rows };
}
function clearColumnConvert(columns) {
  import_xe_utils32.default.eachTree(columns, (column) => {
    delete column._level;
    delete column._colSpan;
    delete column._rowSpan;
    delete column._children;
    delete column.childNodes;
  }, { children: "children" });
}
function checkImportData(columns, fields) {
  const tableFields = [];
  columns.forEach((column) => {
    const field = column.property;
    if (field) {
      tableFields.push(field);
    }
  });
  return fields.some((field) => tableFields.indexOf(field) > -1);
}
var tableExportMethodKeys = ["exportData", "importByFile", "importData", "saveFile", "readFile", "print", "getPrintHtml", "openImport", "closeImport", "openExport", "closeExport", "openPrint", "closePrint"];
hooks7.add("tableExportModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { computeTreeOpts, computePrintOpts, computeExportOpts, computeImportOpts, computeCustomOpts, computeSeqOpts, computeRadioOpts, computeCheckboxOpts, computeColumnOpts } = $xeTable.getComputeMaps();
    const $xeGrid = inject("$xeGrid", null);
    const hasTreeChildren = (row) => {
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      return row[childrenField] && row[childrenField].length;
    };
    const getSeq = (cellValue, row, $rowIndex, column, $columnIndex) => {
      const seqOpts = computeSeqOpts.value;
      const seqMethod = seqOpts.seqMethod || column.seqMethod;
      if (seqMethod) {
        return seqMethod({
          row,
          rowIndex: $xeTable.getRowIndex(row),
          $rowIndex,
          column,
          columnIndex: $xeTable.getColumnIndex(column),
          $columnIndex
        });
      }
      return cellValue;
    };
    function getHeaderTitle(opts, column) {
      const columnOpts = computeColumnOpts.value;
      const headExportMethod = column.headerExportMethod || columnOpts.headerExportMethod;
      return headExportMethod ? headExportMethod({ column, options: opts, $table: $xeTable }) : (opts.original ? column.property : column.getTitle()) || "";
    }
    const toBooleanValue = (cellValue) => {
      return import_xe_utils32.default.isBoolean(cellValue) ? cellValue ? "TRUE" : "FALSE" : cellValue;
    };
    const getBodyLabelData = (opts, columns, datas) => {
      const { isAllExpand, mode } = opts;
      const { treeConfig } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeOpts = computeTreeOpts.value;
      const columnOpts = computeColumnOpts.value;
      if (!htmlCellElem) {
        htmlCellElem = document.createElement("div");
      }
      if (treeConfig) {
        const childrenField = treeOpts.children || treeOpts.childrenField;
        const rest = [];
        const expandMaps = /* @__PURE__ */ new Map();
        import_xe_utils32.default.eachTree(datas, (item, $rowIndex, items, path, parent, nodes) => {
          const row = item._row || item;
          const parentRow = parent && parent._row ? parent._row : parent;
          if (isAllExpand || !parentRow || expandMaps.has(parentRow) && $xeTable.isTreeExpandByRow(parentRow)) {
            const hasRowChild = hasTreeChildren(row);
            const item2 = {
              _row: row,
              _level: nodes.length - 1,
              _hasChild: hasRowChild,
              _expand: hasRowChild && $xeTable.isTreeExpandByRow(row)
            };
            columns.forEach((column, $columnIndex) => {
              let cellValue = "";
              const renderOpts = column.editRender || column.cellRender;
              let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
              if (!bodyExportMethod && renderOpts && renderOpts.name) {
                const compConf = renderer11.get(renderOpts.name);
                if (compConf) {
                  bodyExportMethod = compConf.tableExportMethod || compConf.exportMethod;
                }
              }
              if (!bodyExportMethod) {
                bodyExportMethod = columnOpts.exportMethod;
              }
              if (bodyExportMethod) {
                cellValue = bodyExportMethod({ $table: $xeTable, row, column, options: opts });
              } else {
                switch (column.type) {
                  case "seq": {
                    const seqVal = path.map((num, i) => i % 2 === 0 ? Number(num) + 1 : ".").join("");
                    cellValue = mode === "all" ? seqVal : getSeq(seqVal, row, $rowIndex, column, $columnIndex);
                    break;
                  }
                  case "checkbox":
                    cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                    item2._checkboxLabel = checkboxOpts.labelField ? import_xe_utils32.default.get(row, checkboxOpts.labelField) : "";
                    item2._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                    break;
                  case "radio":
                    cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                    item2._radioLabel = radioOpts.labelField ? import_xe_utils32.default.get(row, radioOpts.labelField) : "";
                    item2._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                    break;
                  default:
                    if (opts.original) {
                      cellValue = getCellValue(row, column);
                    } else {
                      cellValue = `${$xeTable.getCellLabel(row, column)}`;
                      if (column.type === "html") {
                        htmlCellElem.innerHTML = cellValue;
                        cellValue = htmlCellElem.innerText.trim();
                      } else {
                        const cell = $xeTable.getCellElement(row, column);
                        if (cell) {
                          cellValue = cell.innerText.trim();
                        }
                      }
                    }
                }
              }
              item2[column.id] = import_xe_utils32.default.toValueString(cellValue);
            });
            expandMaps.set(row, 1);
            rest.push(Object.assign(item2, row));
          }
        }, { children: childrenField });
        return rest;
      }
      return datas.map((row, $rowIndex) => {
        const item = {
          _row: row
        };
        columns.forEach((column, $columnIndex) => {
          let cellValue = "";
          const renderOpts = column.editRender || column.cellRender;
          let bodyExportMethod = column.exportMethod || columnOpts.exportMethod;
          if (!bodyExportMethod && renderOpts && renderOpts.name) {
            const compConf = renderer11.get(renderOpts.name);
            if (compConf) {
              bodyExportMethod = compConf.exportMethod;
            }
          }
          if (bodyExportMethod) {
            cellValue = bodyExportMethod({ $table: $xeTable, row, column, options: opts });
          } else {
            switch (column.type) {
              case "seq": {
                const seqValue = $rowIndex + 1;
                cellValue = mode === "all" ? seqValue : getSeq(seqValue, row, $rowIndex, column, $columnIndex);
                break;
              }
              case "checkbox":
                cellValue = toBooleanValue($xeTable.isCheckedByCheckboxRow(row));
                item._checkboxLabel = checkboxOpts.labelField ? import_xe_utils32.default.get(row, checkboxOpts.labelField) : "";
                item._checkboxDisabled = checkboxOpts.checkMethod && !checkboxOpts.checkMethod({ row });
                break;
              case "radio":
                cellValue = toBooleanValue($xeTable.isCheckedByRadioRow(row));
                item._radioLabel = radioOpts.labelField ? import_xe_utils32.default.get(row, radioOpts.labelField) : "";
                item._radioDisabled = radioOpts.checkMethod && !radioOpts.checkMethod({ row });
                break;
              default:
                if (opts.original) {
                  cellValue = getCellValue(row, column);
                } else {
                  cellValue = `${$xeTable.getCellLabel(row, column)}`;
                  if (column.type === "html") {
                    htmlCellElem.innerHTML = cellValue;
                    cellValue = htmlCellElem.innerText.trim();
                  } else {
                    const cell = $xeTable.getCellElement(row, column);
                    if (cell) {
                      cellValue = cell.innerText.trim();
                    }
                  }
                }
            }
          }
          item[column.id] = import_xe_utils32.default.toValueString(cellValue);
        });
        return item;
      });
    };
    const getExportData = (opts) => {
      const { columns, dataFilterMethod } = opts;
      let datas = opts.data;
      if (dataFilterMethod) {
        datas = datas.filter((row, index2) => dataFilterMethod({ row, $rowIndex: index2 }));
      }
      return getBodyLabelData(opts, columns, datas);
    };
    const getFooterCellValue = (opts, row, column) => {
      const columnOpts = computeColumnOpts.value;
      const renderOpts = column.editRender || column.cellRender;
      let footLabelMethod = column.footerExportMethod;
      if (!footLabelMethod && renderOpts && renderOpts.name) {
        const compConf = renderer11.get(renderOpts.name);
        if (compConf) {
          footLabelMethod = compConf.tableFooterExportMethod || compConf.footerExportMethod;
        }
      }
      if (!footLabelMethod) {
        footLabelMethod = columnOpts.footerExportMethod;
      }
      const _columnIndex = $xeTable.getVTColumnIndex(column);
      if (footLabelMethod) {
        return footLabelMethod({ $table: $xeTable, items: row, itemIndex: _columnIndex, row, _columnIndex, column, options: opts });
      }
      if (import_xe_utils32.default.isArray(row)) {
        return import_xe_utils32.default.toValueString(row[_columnIndex]);
      }
      return import_xe_utils32.default.get(row, column.field);
    };
    const toCsv = (opts, columns, datas) => {
      let content = csvBOM;
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join(",") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(getCsvCellTypeLabel(column, row[column.id]))).join(",") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, row, column))).join(",") + enterSymbol;
        });
      }
      return content;
    };
    const toTxt = (opts, columns, datas) => {
      let content = "";
      if (opts.isHeader) {
        content += columns.map((column) => toTxtCellLabel(getHeaderTitle(opts, column))).join("	") + enterSymbol;
      }
      datas.forEach((row) => {
        content += columns.map((column) => toTxtCellLabel(row[column.id])).join("	") + enterSymbol;
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          content += columns.map((column) => toTxtCellLabel(getFooterCellValue(opts, row, column))).join("	") + enterSymbol;
        });
      }
      return content;
    };
    const hasEllipsis = (column, property, allColumnOverflow) => {
      const columnOverflow = column[property];
      const headOverflow = import_xe_utils32.default.isUndefined(columnOverflow) || import_xe_utils32.default.isNull(columnOverflow) ? allColumnOverflow : columnOverflow;
      const showEllipsis = headOverflow === "ellipsis";
      const showTitle = headOverflow === "title";
      const showTooltip = headOverflow === true || headOverflow === "tooltip";
      let isEllipsis = showTitle || showTooltip || showEllipsis;
      const { scrollXLoad, scrollYLoad } = reactData;
      if ((scrollXLoad || scrollYLoad) && !isEllipsis) {
        isEllipsis = true;
      }
      return isEllipsis;
    };
    const toHtml = (opts, columns, datas) => {
      const { id: id2, border, treeConfig, headerAlign: allHeaderAlign, align: allAlign, footerAlign: allFooterAlign, showOverflow: allColumnOverflow, showHeaderOverflow: allColumnHeaderOverflow } = props;
      const { isAllSelected, isIndeterminate, mergeList } = reactData;
      const treeOpts = computeTreeOpts.value;
      const { print: isPrint, isHeader, isFooter, isColgroup, isMerge, colgroups, original } = opts;
      const allCls = "check-all";
      const clss = [
        "vxe-table",
        `border--${toTableBorder(border)}`,
        isPrint ? "is--print" : "",
        isHeader ? "is--header" : ""
      ].filter((cls) => cls);
      const tables = [
        `<table class="${clss.join(" ")}" border="0" cellspacing="0" cellpadding="0">`,
        `<colgroup>${columns.map((column) => `<col style="width:${column.renderWidth}px">`).join("")}</colgroup>`
      ];
      if (isHeader) {
        tables.push("<thead>");
        if (isColgroup && !original) {
          colgroups.forEach((cols) => {
            tables.push(`<tr>${cols.map((column) => {
              const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
              const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
              const cellTitle = getHeaderTitle(opts, column);
              let childWidth = 0;
              let countChild = 0;
              import_xe_utils32.default.eachTree([column], (item) => {
                if (!item.childNodes || !column.childNodes.length) {
                  countChild++;
                }
                childWidth += item.renderWidth;
              }, { children: "childNodes" });
              const cellWidth = childWidth - countChild;
              if (headAlign) {
                classNames.push(`col--${headAlign}`);
              }
              if (column.type === "checkbox") {
                return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
              }
              return `<th class="${classNames.join(" ")}" colspan="${column._colSpan}" rowspan="${column._rowSpan}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${cellWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
            }).join("")}</tr>`);
          });
        } else {
          tables.push(`<tr>${columns.map((column) => {
            const headAlign = column.headerAlign || column.align || allHeaderAlign || allAlign;
            const classNames = hasEllipsis(column, "showHeaderOverflow", allColumnHeaderOverflow) ? ["col--ellipsis"] : [];
            const cellTitle = getHeaderTitle(opts, column);
            if (headAlign) {
              classNames.push(`col--${headAlign}`);
            }
            if (column.type === "checkbox") {
              return `<th class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" class="${allCls}" ${isAllSelected ? "checked" : ""}><span>${cellTitle}</span></div></th>`;
            }
            return `<th class="${classNames.join(" ")}" title="${cellTitle}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><span>${formatText(cellTitle, true)}</span></div></th>`;
          }).join("")}</tr>`);
        }
        tables.push("</thead>");
      }
      if (datas.length) {
        tables.push("<tbody>");
        if (treeConfig) {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.treeNode) {
                let treeIcon = "";
                if (item._hasChild) {
                  treeIcon = `<i class="${item._expand ? "vxe-table--tree-fold-icon" : "vxe-table--tree-unfold-icon"}"></i>`;
                }
                classNames.push("vxe-table--tree-node");
                if (column.type === "radio") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="radio" name="radio_${id2}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></div></div></td>`;
                } else if (column.type === "checkbox") {
                  return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell"><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></div></div></td>`;
                }
                return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><div class="vxe-table--tree-node-wrapper" style="padding-left: ${item._level * treeOpts.indent}px"><div class="vxe-table--tree-icon-wrapper">${treeIcon}</div><div class="vxe-table--tree-cell">${cellValue}</div></div></div></td>`;
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id2}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        } else {
          datas.forEach((item) => {
            tables.push("<tr>" + columns.map((column) => {
              const cellAlign = column.align || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = item[column.id];
              let rowSpan = 1;
              let colSpan = 1;
              if (isMerge && mergeList.length) {
                const _rowIndex = $xeTable.getVTRowIndex(item._row);
                const _columnIndex = $xeTable.getVTColumnIndex(column);
                const spanRest = mergeBodyMethod(mergeList, _rowIndex, _columnIndex);
                if (spanRest) {
                  const { rowspan, colspan } = spanRest;
                  if (!rowspan || !colspan) {
                    return "";
                  }
                  if (rowspan > 1) {
                    rowSpan = rowspan;
                  }
                  if (colspan > 1) {
                    colSpan = colspan;
                  }
                }
              }
              if (cellAlign) {
                classNames.push(`col--${cellAlign}`);
              }
              if (column.type === "radio") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="radio" name="radio_${id2}" ${item._radioDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._radioLabel}</span></div></td>`;
              } else if (column.type === "checkbox") {
                return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}><input type="checkbox" ${item._checkboxDisabled ? "disabled " : ""}${getBooleanValue(cellValue) ? "checked" : ""}><span>${item._checkboxLabel}</span></div></td>`;
              }
              return `<td class="${classNames.join(" ")}" rowspan="${rowSpan}" colspan="${colSpan}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("") + "</tr>");
          });
        }
        tables.push("</tbody>");
      }
      if (isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        if (footers.length) {
          tables.push("<tfoot>");
          footers.forEach((row) => {
            tables.push(`<tr>${columns.map((column) => {
              const footAlign = column.footerAlign || column.align || allFooterAlign || allAlign;
              const classNames = hasEllipsis(column, "showOverflow", allColumnOverflow) ? ["col--ellipsis"] : [];
              const cellValue = getFooterCellValue(opts, row, column);
              if (footAlign) {
                classNames.push(`col--${footAlign}`);
              }
              return `<td class="${classNames.join(" ")}" title="${cellValue}"><div ${isPrint ? "" : `style="width: ${column.renderWidth}px"`}>${formatText(cellValue, true)}</div></td>`;
            }).join("")}</tr>`);
          });
          tables.push("</tfoot>");
        }
      }
      const script = !isAllSelected && isIndeterminate ? `<script>(function(){var a=document.querySelector(".${allCls}");if(a){a.indeterminate=true}})()<\/script>` : "";
      tables.push("</table>", script);
      return isPrint ? tables.join("") : createHtmlPage(opts, tables.join(""));
    };
    const toXML = (opts, columns, datas) => {
      let xml = [
        '<?xml version="1.0"?>',
        '<?mso-application progid="Excel.Sheet"?>',
        '<Workbook xmlns="urn:schemas-microsoft-com:office:spreadsheet" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns:ss="urn:schemas-microsoft-com:office:spreadsheet" xmlns:html="http://www.w3.org/TR/REC-html40">',
        '<DocumentProperties xmlns="urn:schemas-microsoft-com:office:office">',
        "<Version>16.00</Version>",
        "</DocumentProperties>",
        '<ExcelWorkbook xmlns="urn:schemas-microsoft-com:office:excel">',
        "<WindowHeight>7920</WindowHeight>",
        "<WindowWidth>21570</WindowWidth>",
        "<WindowTopX>32767</WindowTopX>",
        "<WindowTopY>32767</WindowTopY>",
        "<ProtectStructure>False</ProtectStructure>",
        "<ProtectWindows>False</ProtectWindows>",
        "</ExcelWorkbook>",
        `<Worksheet ss:Name="${opts.sheetName}">`,
        "<Table>",
        columns.map((column) => `<Column ss:Width="${column.renderWidth}"/>`).join("")
      ].join("");
      if (opts.isHeader) {
        xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getHeaderTitle(opts, column)}</Data></Cell>`).join("")}</Row>`;
      }
      datas.forEach((row) => {
        xml += "<Row>" + columns.map((column) => `<Cell><Data ss:Type="String">${row[column.id]}</Data></Cell>`).join("") + "</Row>";
      });
      if (opts.isFooter) {
        const { footerTableData } = reactData;
        const footers = getFooterData(opts, footerTableData);
        footers.forEach((row) => {
          xml += `<Row>${columns.map((column) => `<Cell><Data ss:Type="String">${getFooterCellValue(opts, row, column)}</Data></Cell>`).join("")}</Row>`;
        });
      }
      return `${xml}</Table></Worksheet></Workbook>`;
    };
    const getContent = (opts, columns, datas) => {
      if (columns.length) {
        switch (opts.type) {
          case "csv":
            return toCsv(opts, columns, datas);
          case "txt":
            return toTxt(opts, columns, datas);
          case "html":
            return toHtml(opts, columns, datas);
          case "xml":
            return toXML(opts, columns, datas);
        }
      }
      return "";
    };
    const downloadFile = (opts, content) => {
      const { filename, type, download } = opts;
      if (!download) {
        const blob = getExportBlobByContent(content, opts);
        return Promise.resolve({ type, content, blob });
      }
      if (VxeUI.saveFile) {
        VxeUI.saveFile({ filename, type, content }).then(() => {
          if (opts.message !== false) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n12("vxe.table.expSuccess"), status: "success" });
            }
          }
        });
      }
    };
    const handleExport = (opts) => {
      const { remote, columns, colgroups, exportMethod, afterExportMethod } = opts;
      return new Promise((resolve) => {
        if (remote) {
          const params = { options: opts, $table: $xeTable, $grid: $xeGrid };
          resolve(exportMethod ? exportMethod(params) : params);
        } else {
          const datas = getExportData(opts);
          resolve($xeTable.preventEvent(null, "event.export", { options: opts, columns, colgroups, datas }, () => {
            return downloadFile(opts, getContent(opts, columns, datas));
          }));
        }
      }).then((params) => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: true, options: opts, $table: $xeTable, $grid: $xeGrid });
          }
        }
        return Object.assign({ status: true }, params);
      }).catch(() => {
        clearColumnConvert(columns);
        if (!opts.print) {
          if (afterExportMethod) {
            afterExportMethod({ status: false, options: opts, $table: $xeTable, $grid: $xeGrid });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      });
    };
    const handleImport = (content, opts) => {
      const { tableFullColumn, _importResolve, _importReject } = internalData;
      let rest = { fields: [], rows: [] };
      switch (opts.type) {
        case "csv":
          rest = parseCsv(tableFullColumn, content);
          break;
        case "txt":
          rest = parseTxt(tableFullColumn, content);
          break;
        case "html":
          rest = parseHTML(tableFullColumn, content);
          break;
        case "xml":
          rest = parseXML(tableFullColumn, content);
          break;
      }
      const { fields, rows } = rest;
      const status = checkImportData(tableFullColumn, fields);
      if (status) {
        $xeTable.createData(rows).then((data) => {
          let loadRest;
          if (opts.mode === "insert" || opts.mode === "insertBottom") {
            loadRest = $xeTable.insertAt(data, -1);
          }
          if (opts.mode === "insertTop") {
            loadRest = $xeTable.insert(data);
          } else {
            loadRest = $xeTable.reloadData(data);
          }
          if (opts.message !== false) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n12("vxe.table.impSuccess", [rows.length]), status: "success" });
            }
          }
          return loadRest.then(() => {
            if (_importResolve) {
              _importResolve({ status: true });
            }
          });
        });
      } else if (opts.message !== false) {
        if (VxeUI.modal) {
          VxeUI.modal.message({ content: getI18n12("vxe.error.impFields"), status: "error" });
        }
        if (_importReject) {
          _importReject({ status: false });
        }
      }
    };
    const handleFileImport = (file, opts) => {
      const { importMethod, afterImportMethod } = opts;
      const { type, filename } = parseFile(file);
      const importOpts = computeImportOpts.value;
      if (!importMethod && !import_xe_utils32.default.includes(import_xe_utils32.default.keys(importOpts._typeMaps), type)) {
        if (opts.message !== false) {
          if (VxeUI.modal) {
            VxeUI.modal.message({ content: getI18n12("vxe.error.notType", [type]), status: "error" });
          }
        }
        const params = { status: false };
        return Promise.reject(params);
      }
      const rest = new Promise((resolve, reject) => {
        const _importResolve = (params) => {
          resolve(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        const _importReject = (params) => {
          reject(params);
          internalData._importResolve = null;
          internalData._importReject = null;
        };
        internalData._importResolve = _importResolve;
        internalData._importReject = _importReject;
        if (window.FileReader) {
          const options = Object.assign({ mode: "insertTop" }, opts, { type, filename });
          if (options.remote) {
            if (importMethod) {
              Promise.resolve(importMethod({ file, options, $table: $xeTable })).then(() => {
                _importResolve({ status: true });
              }).catch(() => {
                _importResolve({ status: true });
              });
            } else {
              _importResolve({ status: true });
            }
          } else {
            const { tableFullColumn } = internalData;
            $xeTable.preventEvent(null, "event.import", { file, options, columns: tableFullColumn }, () => {
              const reader = new FileReader();
              reader.onerror = () => {
                errLog("vxe.error.notType", [type]);
                _importReject({ status: false });
              };
              reader.onload = (e16) => {
                handleImport(e16.target.result, options);
              };
              reader.readAsText(file, options.encoding || "UTF-8");
            });
          }
        } else {
          if (true) {
            errLog("vxe.error.notExp");
          }
          _importResolve({ status: true });
        }
      });
      return rest.then(() => {
        if (afterImportMethod) {
          afterImportMethod({ status: true, options: opts, $table: $xeTable });
        }
      }).catch((e16) => {
        if (afterImportMethod) {
          afterImportMethod({ status: false, options: opts, $table: $xeTable });
        }
        return Promise.reject(e16);
      });
    };
    const handleExportAndPrint = (options, isPrint) => {
      const { treeConfig, showHeader, showFooter } = props;
      const { initStore, mergeList, isGroup, footerTableData, exportStore, exportParams } = reactData;
      const { collectColumn } = internalData;
      const exportOpts = computeExportOpts.value;
      const hasTree = treeConfig;
      const customOpts = computeCustomOpts.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      const proxyOpts = $xeGrid ? $xeGrid.getComputeMaps().computeProxyOpts.value : {};
      const hasFooter = !!footerTableData.length;
      const hasMerge = !hasTree && mergeList.length;
      const defOpts = Object.assign({
        message: true,
        isHeader: showHeader,
        isFooter: showFooter,
        current: "current",
        modes: ["current", "selected"].concat(proxyOpts.ajax && proxyOpts.ajax.queryAll ? ["all"] : [])
      }, options);
      const types = defOpts.types || import_xe_utils32.default.keys(exportOpts._typeMaps);
      const modes = defOpts.modes || [];
      const checkMethod = customOpts.checkMethod;
      const exportColumns = collectColumn.slice(0);
      const { columns } = defOpts;
      const typeList = types.map((value) => {
        return {
          value,
          label: getI18n12(`vxe.export.types.${value}`)
        };
      });
      const modeList = modes.map((item) => {
        if (item && item.value) {
          return {
            value: item.value,
            label: item.label || item.value
          };
        }
        return {
          value: item,
          label: getI18n12(`vxe.export.modes.${item}`)
        };
      });
      import_xe_utils32.default.eachTree(exportColumns, (column, index2, items, path, parent) => {
        const isColGroup = column.children && column.children.length;
        if (isColGroup || defaultFilterExportColumn(column)) {
          column.checked = columns ? columns.some((item) => {
            if (isColumnInfo(item)) {
              return column === item;
            } else if (import_xe_utils32.default.isString(item)) {
              return column.field === item;
            } else {
              const colid = item.id || item.colId;
              const type = item.type;
              const field = item.property || item.field;
              if (colid) {
                return column.id === colid;
              } else if (field && type) {
                return column.property === field && column.type === type;
              } else if (field) {
                return column.property === field;
              } else if (type) {
                return column.type === type;
              }
            }
            return false;
          }) : column.visible;
          column.halfChecked = false;
          column.disabled = parent && parent.disabled || (checkMethod ? !checkMethod({ column }) : false);
        }
      });
      Object.assign(exportStore, {
        columns: exportColumns,
        typeList,
        modeList,
        hasFooter,
        hasMerge,
        hasTree,
        isPrint,
        hasColgroup: isGroup,
        visible: true
      });
      Object.assign(exportParams, {
        mode: selectRecords.length ? "selected" : "current"
      }, defOpts);
      if (!modeList.some((item) => item.value === exportParams.mode)) {
        exportParams.mode = modeList[0].value;
      }
      if (!typeList.some((item) => item.value === exportParams.type)) {
        exportParams.type = typeList[0].value;
      }
      initStore.export = true;
      return nextTick();
    };
    const handleCloseExport = () => {
      if (VxeUI.modal) {
        return VxeUI.modal.close("VXE_EXPORT_MODAL");
      }
      return Promise.resolve();
    };
    const exportMethods = {
      /**
       * 导出文件，支持 csv/html/xml/txt
       * 如果是树表格，则默认是导出所有节点
       * 如果是启用了虚拟滚动，则只能导出数据源，可以配合 dataFilterMethod 函数自行转换数据
       * @param {Object} options 参数
       */
      exportData(options) {
        const { treeConfig } = props;
        const { isGroup, tableGroupColumn } = reactData;
        const { tableFullColumn, afterFullData } = internalData;
        const exportOpts = computeExportOpts.value;
        const treeOpts = computeTreeOpts.value;
        const opts = Object.assign({
          // filename: '',
          // sheetName: '',
          // original: false,
          // message: false,
          isHeader: true,
          isFooter: true,
          isColgroup: true,
          // isMerge: false,
          // isAllExpand: false,
          download: true,
          type: "csv",
          mode: "current"
          // data: null,
          // remote: false,
          // dataFilterMethod: null,
          // footerFilterMethod: null,
          // exportMethod: null,
          // columnFilterMethod: null,
          // beforeExportMethod: null,
          // afterExportMethod: null
        }, exportOpts, {
          print: false
        }, options);
        const { type, mode, columns, original, beforeExportMethod } = opts;
        let groups = [];
        const customCols = columns && columns.length ? columns : null;
        let columnFilterMethod = opts.columnFilterMethod;
        if (!customCols && !columnFilterMethod) {
          columnFilterMethod = original ? ({ column }) => column.property : ({ column }) => defaultFilterExportColumn(column);
        }
        if (customCols) {
          opts._isCustomColumn = true;
          groups = import_xe_utils32.default.searchTree(import_xe_utils32.default.mapTree(customCols, (item) => {
            let targetColumn;
            if (item) {
              if (isColumnInfo(item)) {
                targetColumn = item;
              } else if (import_xe_utils32.default.isString(item)) {
                targetColumn = $xeTable.getColumnByField(item);
              } else {
                const colid = item.id || item.colId;
                const type2 = item.type;
                const field = item.property || item.field;
                if (colid) {
                  targetColumn = $xeTable.getColumnById(colid);
                } else if (field && type2) {
                  targetColumn = tableFullColumn.find((column) => column.property === field && column.type === type2);
                } else if (field) {
                  targetColumn = $xeTable.getColumnByField(field);
                } else if (type2) {
                  targetColumn = tableFullColumn.find((column) => column.type === type2);
                }
              }
              return targetColumn || {};
            }
          }, {
            children: "childNodes",
            mapChildren: "_children"
          }), (column, index2) => isColumnInfo(column) && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index2 })), {
            children: "_children",
            mapChildren: "childNodes",
            original: true
          });
        } else {
          groups = import_xe_utils32.default.searchTree(isGroup ? tableGroupColumn : tableFullColumn, (column, index2) => column.visible && (!columnFilterMethod || columnFilterMethod({ column, $columnIndex: index2 })), { children: "children", mapChildren: "childNodes", original: true });
        }
        const cols = [];
        import_xe_utils32.default.eachTree(groups, (column) => {
          const isColGroup = column.children && column.children.length;
          if (!isColGroup) {
            cols.push(column);
          }
        }, { children: "childNodes" });
        opts.columns = cols;
        opts.colgroups = convertToRows(groups);
        if (!opts.filename) {
          opts.filename = getI18n12(opts.original ? "vxe.table.expOriginFilename" : "vxe.table.expFilename", [import_xe_utils32.default.toDateString(Date.now(), "yyyyMMddHHmmss")]);
        }
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        if (!opts.exportMethod && !import_xe_utils32.default.includes(import_xe_utils32.default.keys(exportOpts._typeMaps), type)) {
          errLog("vxe.error.notType", [type]);
          if (true) {
            if (["xlsx", "pdf"].includes(type)) {
              warnLog("vxe.error.reqPlugin", [4, "plugin-export-xlsx"]);
            }
          }
          const params = { status: false };
          return Promise.reject(params);
        }
        if (!opts.print) {
          if (beforeExportMethod) {
            beforeExportMethod({ options: opts, $table: $xeTable, $grid: $xeGrid });
          }
        }
        if (!opts.data) {
          opts.data = [];
          if (mode === "selected") {
            const selectRecords = $xeTable.getCheckboxRecords();
            if (["html", "pdf"].indexOf(type) > -1 && treeConfig) {
              opts.data = import_xe_utils32.default.searchTree($xeTable.getTableData().fullData, (item) => $xeTable.findRowIndexOf(selectRecords, item) > -1, Object.assign({}, treeOpts, { data: "_row" }));
            } else {
              opts.data = selectRecords;
            }
          } else if (mode === "all") {
            if (true) {
              if (!$xeGrid) {
                warnLog("vxe.error.errProp", ["all", "mode=current,selected"]);
              }
            }
            if ($xeGrid && !opts.remote) {
              const { reactData: gridReactData } = $xeGrid;
              const { computeProxyOpts } = $xeGrid.getComputeMaps();
              const { sortData } = gridReactData;
              const proxyOpts = computeProxyOpts.value;
              const { beforeQueryAll, afterQueryAll, ajax = {}, props: props2 = {} } = proxyOpts;
              const ajaxMethods = ajax.queryAll;
              const queryAllSuccessMethods = ajax.queryAllSuccess;
              const queryAllErrorMethods = ajax.queryAllError;
              if (true) {
                if (!ajaxMethods) {
                  warnLog("vxe.error.notFunc", ["proxy-config.ajax.queryAll"]);
                }
              }
              if (ajaxMethods) {
                const params = {
                  $table: $xeTable,
                  $grid: $xeGrid,
                  sort: sortData.length ? sortData[0] : {},
                  sorts: sortData,
                  filters: gridReactData.filterData,
                  form: gridReactData.formData,
                  options: opts
                };
                return Promise.resolve((beforeQueryAll || ajaxMethods)(params)).then((rest) => {
                  opts.data = (props2.list ? import_xe_utils32.default.get(rest, props2.list) : rest) || [];
                  if (afterQueryAll) {
                    afterQueryAll(params);
                  }
                  if (queryAllSuccessMethods) {
                    queryAllSuccessMethods(Object.assign(Object.assign({}, params), { response: rest }));
                  }
                  return handleExport(opts);
                }).catch((rest) => {
                  if (queryAllErrorMethods) {
                    queryAllErrorMethods(Object.assign(Object.assign({}, params), { response: rest }));
                  }
                });
              }
            }
          } else if (mode === "current") {
            opts.data = afterFullData;
          }
        }
        return handleExport(opts);
      },
      importByFile(file, options) {
        const opts = Object.assign({}, options);
        const { beforeImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xeTable });
        }
        return handleFileImport(file, opts);
      },
      importData(options) {
        const importOpts = computeImportOpts.value;
        const opts = Object.assign({
          types: import_xe_utils32.default.keys(importOpts._typeMaps)
          // beforeImportMethod: null,
          // afterImportMethod: null
        }, importOpts, options);
        const { beforeImportMethod, afterImportMethod } = opts;
        if (beforeImportMethod) {
          beforeImportMethod({ options: opts, $table: $xeTable });
        }
        return VxeUI.readFile(opts).catch((e16) => {
          if (afterImportMethod) {
            afterImportMethod({ status: false, options: opts, $table: $xeTable });
          }
          return Promise.reject(e16);
        }).then((params) => {
          const { file } = params;
          return handleFileImport(file, opts);
        });
      },
      saveFile(options) {
        return VxeUI.saveFile(options);
      },
      readFile(options) {
        return VxeUI.readFile(options);
      },
      print(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        if (!opts.sheetName) {
          opts.sheetName = document.title;
        }
        const beforePrintMethod = opts.beforePrintMethod;
        const tableHtml = opts.html || opts.content;
        return new Promise((resolve, reject) => {
          if (VxeUI.print) {
            if (tableHtml) {
              resolve(VxeUI.print({
                title: opts.sheetName,
                html: tableHtml,
                customStyle: opts.style,
                beforeMethod: beforePrintMethod ? ({ html }) => {
                  return beforePrintMethod({
                    html,
                    content: html,
                    options: opts,
                    $table: $xeTable
                  });
                } : void 0
              }));
            } else {
              resolve(exportMethods.exportData(opts).then(({ content }) => {
                return VxeUI.print({
                  title: opts.sheetName,
                  html: content,
                  customStyle: opts.style,
                  beforeMethod: beforePrintMethod ? ({ html }) => {
                    return beforePrintMethod({
                      html,
                      content: html,
                      options: opts,
                      $table: $xeTable
                    });
                  } : void 0
                });
              }));
            }
          } else {
            const e16 = { status: false };
            reject(e16);
          }
        });
      },
      getPrintHtml(options) {
        const printOpts = computePrintOpts.value;
        const opts = Object.assign({
          original: false
          // beforePrintMethod
        }, printOpts, options, {
          type: "html",
          download: false,
          remote: false,
          print: true
        });
        return exportMethods.exportData(opts).then(({ content }) => {
          return {
            html: content
          };
        });
      },
      closeImport() {
        if (VxeUI.modal) {
          return VxeUI.modal.close("VXE_IMPORT_MODAL");
        }
        return Promise.resolve();
      },
      openImport(options) {
        const { treeConfig, importConfig } = props;
        const { initStore, importStore, importParams } = reactData;
        const importOpts = computeImportOpts.value;
        const defOpts = Object.assign({
          mode: "insertTop",
          message: true,
          types: import_xe_utils32.default.keys(importOpts._typeMaps),
          modes: ["insertTop", "covering"]
        }, importOpts, options);
        const types = defOpts.types || [];
        const modes = defOpts.modes || [];
        const isTree = !!treeConfig;
        if (isTree) {
          if (defOpts.message) {
            if (VxeUI.modal) {
              VxeUI.modal.message({ content: getI18n12("vxe.error.treeNotImp"), status: "error" });
            }
          }
          return;
        }
        if (!importConfig) {
          errLog("vxe.error.reqProp", ["import-config"]);
        }
        const typeList = types.map((value) => {
          return {
            value,
            label: getI18n12(`vxe.export.types.${value}`)
          };
        });
        const modeList = modes.map((item) => {
          if (item && item.value) {
            return {
              value: item.value,
              label: item.label || item.value
            };
          }
          return {
            value: item,
            label: getI18n12(`vxe.import.modes.${item}`)
          };
        });
        Object.assign(importStore, {
          file: null,
          type: "",
          filename: "",
          modeList,
          typeList,
          visible: true
        });
        Object.assign(importParams, defOpts);
        if (!modeList.some((item) => item.value === importParams.mode)) {
          importParams.mode = modeList[0].value;
        }
        initStore.import = true;
      },
      closeExport: handleCloseExport,
      openExport(options) {
        const exportOpts = computeExportOpts.value;
        const defOpts = Object.assign({
          message: true,
          types: import_xe_utils32.default.keys(exportOpts._typeMaps)
        }, exportOpts, options);
        if (true) {
          if (!props.exportConfig) {
            errLog("vxe.error.reqProp", ["export-config"]);
          }
        }
        handleExportAndPrint(defOpts);
      },
      closePrint: handleCloseExport,
      openPrint(options) {
        const printOpts = computePrintOpts.value;
        const defOpts = Object.assign({
          message: true
        }, printOpts, options);
        if (true) {
          if (!props.printConfig) {
            errLog("vxe.error.reqProp", ["print-config"]);
          }
        }
        handleExportAndPrint(defOpts, true);
      }
    };
    return exportMethods;
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableExportMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/keyboard/hook.js
var import_xe_utils33 = __toESM(require_xe_utils());
var { hooks: hooks8 } = VxeUI;
function getTargetOffset(target, container) {
  let offsetTop = 0;
  let offsetLeft = 0;
  const triggerCheckboxLabel = !browse2.firefox && hasClass(target, "vxe-checkbox--label");
  if (triggerCheckboxLabel) {
    const checkboxLabelStyle = getComputedStyle(target);
    offsetTop -= import_xe_utils33.default.toNumber(checkboxLabelStyle.paddingTop);
    offsetLeft -= import_xe_utils33.default.toNumber(checkboxLabelStyle.paddingLeft);
  }
  while (target && target !== container) {
    offsetTop += target.offsetTop;
    offsetLeft += target.offsetLeft;
    target = target.offsetParent;
    if (triggerCheckboxLabel) {
      const checkboxStyle = getComputedStyle(target);
      offsetTop -= import_xe_utils33.default.toNumber(checkboxStyle.paddingTop);
      offsetLeft -= import_xe_utils33.default.toNumber(checkboxStyle.paddingLeft);
    }
  }
  return { offsetTop, offsetLeft };
}
hooks8.add("tableKeyboardModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refElem } = $xeTable.getRefMaps();
    const { computeEditOpts, computeCheckboxOpts, computeMouseOpts, computeTreeOpts } = $xeTable.getComputeMaps();
    function getCheckboxRangeRows(evnt, params, targetTrElem, trRect, offsetClientTop, moveRange) {
      let countHeight = 0;
      let rangeRows = [];
      let moveSize = 0;
      const isDown = moveRange > 0;
      const { scrollYLoad } = reactData;
      const { afterFullData, scrollYStore } = internalData;
      if (scrollYLoad) {
        if (isDown) {
          moveSize = offsetClientTop + moveRange;
        } else {
          moveSize = trRect.height - offsetClientTop + Math.abs(moveRange);
        }
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        if (isDown) {
          rangeRows = afterFullData.slice(_rowIndex, _rowIndex + Math.ceil(moveSize / scrollYStore.rowHeight));
        } else {
          rangeRows = afterFullData.slice(_rowIndex - Math.floor(moveSize / scrollYStore.rowHeight), _rowIndex + 1);
        }
      } else {
        if (isDown) {
          moveSize = evnt.clientY - trRect.y;
        } else {
          moveSize = trRect.y - evnt.clientY + trRect.height;
        }
        const siblingProp = isDown ? "next" : "previous";
        while (targetTrElem && countHeight < moveSize) {
          const rowNodeRest = $xeTable.getRowNode(targetTrElem);
          if (rowNodeRest) {
            rangeRows.push(rowNodeRest.item);
            countHeight += targetTrElem.offsetHeight;
            targetTrElem = targetTrElem[`${siblingProp}ElementSibling`];
          }
        }
      }
      return rangeRows;
    }
    const handleCheckboxRangeEvent = (evnt, params) => {
      const { column, cell } = params;
      if (column.type === "checkbox") {
        const el2 = refElem.value;
        const { elemStore } = internalData;
        const disX = evnt.clientX;
        const disY = evnt.clientY;
        const bodyWrapperElem = getRefElem(elemStore[`${column.fixed || "main"}-body-wrapper`] || elemStore["main-body-wrapper"]);
        if (!bodyWrapperElem) {
          return;
        }
        const checkboxRangeElem = bodyWrapperElem.querySelector(".vxe-table--checkbox-range");
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const trElem = cell.parentElement;
        const selectRecords = $xeTable.getCheckboxRecords();
        let lastRangeRows = [];
        const marginSize = 1;
        const offsetRest = getTargetOffset(evnt.target, bodyWrapperElem);
        const startTop = offsetRest.offsetTop + evnt.offsetY;
        const startLeft = offsetRest.offsetLeft + evnt.offsetX;
        const startScrollTop = bodyWrapperElem.scrollTop;
        const rowHeight = trElem.offsetHeight;
        const trRect = trElem.getBoundingClientRect();
        const offsetClientTop = disY - trRect.y;
        let mouseScrollTimeout = null;
        let isMouseScrollDown = false;
        let mouseScrollSpaceSize = 1;
        const triggerEvent3 = (type, evnt2) => {
          $xeTable.dispatchEvent(`checkbox-range-${type}`, { records: $xeTable.getCheckboxRecords(), reserves: $xeTable.getCheckboxReserveRecords() }, evnt2);
        };
        const handleChecked = (evnt2) => {
          const { clientX, clientY } = evnt2;
          const offsetLeft = clientX - disX;
          const offsetTop = clientY - disY + (bodyWrapperElem.scrollTop - startScrollTop);
          let rangeHeight = Math.abs(offsetTop);
          let rangeWidth = Math.abs(offsetLeft);
          let rangeTop = startTop;
          let rangeLeft = startLeft;
          if (offsetTop < marginSize) {
            rangeTop += offsetTop;
            if (rangeTop < marginSize) {
              rangeTop = marginSize;
              rangeHeight = startTop;
            }
          } else {
            rangeHeight = Math.min(rangeHeight, bodyWrapperElem.scrollHeight - startTop - marginSize);
          }
          if (offsetLeft < marginSize) {
            rangeLeft += offsetLeft;
            if (rangeWidth > startLeft) {
              rangeLeft = marginSize;
              rangeWidth = startLeft;
            }
          } else {
            rangeWidth = Math.min(rangeWidth, bodyWrapperElem.clientWidth - startLeft - marginSize);
          }
          checkboxRangeElem.style.height = `${rangeHeight}px`;
          checkboxRangeElem.style.width = `${rangeWidth}px`;
          checkboxRangeElem.style.left = `${rangeLeft}px`;
          checkboxRangeElem.style.top = `${rangeTop}px`;
          checkboxRangeElem.style.display = "block";
          const rangeRows = getCheckboxRangeRows(evnt2, params, trElem, trRect, offsetClientTop, offsetTop < marginSize ? -rangeHeight : rangeHeight);
          if (rangeHeight > 10 && rangeRows.length !== lastRangeRows.length) {
            lastRangeRows = rangeRows;
            if (evnt2.ctrlKey) {
              rangeRows.forEach((row) => {
                $xeTable.handleBatchSelectRows([row], selectRecords.indexOf(row) === -1);
              });
            } else {
              $xeTable.setAllCheckboxRow(false);
              $xeTable.handleCheckedCheckboxRow(rangeRows, true, false);
            }
            triggerEvent3("change", evnt2);
          }
        };
        const stopMouseScroll = () => {
          clearTimeout(mouseScrollTimeout);
          mouseScrollTimeout = null;
        };
        const startMouseScroll = (evnt2) => {
          stopMouseScroll();
          mouseScrollTimeout = setTimeout(() => {
            if (mouseScrollTimeout) {
              const { scrollLeft, scrollTop, clientHeight, scrollHeight } = bodyWrapperElem;
              const topSize = Math.ceil(mouseScrollSpaceSize * 50 / rowHeight);
              if (isMouseScrollDown) {
                if (scrollTop + clientHeight < scrollHeight) {
                  $xeTable.scrollTo(scrollLeft, scrollTop + topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              } else {
                if (scrollTop) {
                  $xeTable.scrollTo(scrollLeft, scrollTop - topSize);
                  startMouseScroll(evnt2);
                  handleChecked(evnt2);
                } else {
                  stopMouseScroll();
                }
              }
            }
          }, 50);
        };
        addClass(el2, "drag--range");
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          evnt2.stopPropagation();
          const { clientY } = evnt2;
          const { boundingTop } = getAbsolutePos(bodyWrapperElem);
          if (clientY < boundingTop) {
            isMouseScrollDown = false;
            mouseScrollSpaceSize = boundingTop - clientY;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (clientY > boundingTop + bodyWrapperElem.clientHeight) {
            isMouseScrollDown = true;
            mouseScrollSpaceSize = clientY - boundingTop - bodyWrapperElem.clientHeight;
            if (!mouseScrollTimeout) {
              startMouseScroll(evnt2);
            }
          } else if (mouseScrollTimeout) {
            stopMouseScroll();
          }
          handleChecked(evnt2);
        };
        document.onmouseup = (evnt2) => {
          stopMouseScroll();
          removeClass(el2, "drag--range");
          checkboxRangeElem.removeAttribute("style");
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          triggerEvent3("end", evnt2);
        };
        triggerEvent3("start", evnt);
      }
    };
    const handleCellMousedownEvent = (evnt, params) => {
      const { editConfig, checkboxConfig, mouseConfig } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const mouseOpts = computeMouseOpts.value;
      const editOpts = computeEditOpts.value;
      if (mouseConfig && mouseOpts.area && $xeTable.handleMousedownCellAreaEvent) {
        return $xeTable.handleMousedownCellAreaEvent(evnt, params);
      } else {
        if (checkboxConfig && checkboxOpts.range) {
          handleCheckboxRangeEvent(evnt, params);
        }
        if (mouseConfig && mouseOpts.selected) {
          if (!editConfig || editOpts.mode === "cell") {
            $xeTable.handleSelected(params, evnt);
          }
        }
      }
    };
    const keyboardMethods = {
      // 处理 Tab 键移动
      moveTabSelected(args, isLeft, evnt) {
        const { editConfig } = props;
        const { afterFullData, visibleColumn } = internalData;
        const editOpts = computeEditOpts.value;
        let targetRow;
        let targetRowIndex;
        let targetColumnIndex;
        const params = Object.assign({}, args);
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        const _columnIndex = $xeTable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isLeft) {
          if (_columnIndex <= 0) {
            if (_rowIndex > 0) {
              targetRowIndex = _rowIndex - 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = visibleColumn.length - 1;
            }
          } else {
            targetColumnIndex = _columnIndex - 1;
          }
        } else {
          if (_columnIndex >= visibleColumn.length - 1) {
            if (_rowIndex < afterFullData.length - 1) {
              targetRowIndex = _rowIndex + 1;
              targetRow = afterFullData[targetRowIndex];
              targetColumnIndex = 0;
            }
          } else {
            targetColumnIndex = _columnIndex + 1;
          }
        }
        const targetColumn = visibleColumn[targetColumnIndex];
        if (targetColumn) {
          if (targetRow) {
            params.rowIndex = targetRowIndex;
            params.row = targetRow;
          } else {
            params.rowIndex = _rowIndex;
          }
          params.columnIndex = targetColumnIndex;
          params.column = targetColumn;
          params.cell = $xeTable.getCellElement(params.row, params.column);
          if (editConfig) {
            if (editOpts.trigger === "click" || editOpts.trigger === "dblclick") {
              if (editOpts.mode === "row") {
                $xeTable.handleEdit(params, evnt);
              } else {
                $xeTable.scrollToRow(params.row, params.column).then(() => $xeTable.handleSelected(params, evnt));
              }
            }
          } else {
            $xeTable.scrollToRow(params.row, params.column).then(() => $xeTable.handleSelected(params, evnt));
          }
        }
      },
      // 处理当前行方向键移动
      moveCurrentRow(isUpArrow, isDwArrow, evnt) {
        const { treeConfig } = props;
        const { currentRow } = reactData;
        const { afterFullData } = internalData;
        const treeOpts = computeTreeOpts.value;
        const childrenField = treeOpts.children || treeOpts.childrenField;
        let targetRow;
        evnt.preventDefault();
        if (currentRow) {
          if (treeConfig) {
            const { index: index2, items } = import_xe_utils33.default.findTree(afterFullData, (item) => item === currentRow, { children: childrenField });
            if (isUpArrow && index2 > 0) {
              targetRow = items[index2 - 1];
            } else if (isDwArrow && index2 < items.length - 1) {
              targetRow = items[index2 + 1];
            }
          } else {
            const _rowIndex = $xeTable.getVTRowIndex(currentRow);
            if (isUpArrow && _rowIndex > 0) {
              targetRow = afterFullData[_rowIndex - 1];
            } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
              targetRow = afterFullData[_rowIndex + 1];
            }
          }
        } else {
          targetRow = afterFullData[0];
        }
        if (targetRow) {
          const params = {
            $table: $xeTable,
            row: targetRow,
            rowIndex: $xeTable.getRowIndex(targetRow),
            $rowIndex: $xeTable.getVMRowIndex(targetRow)
          };
          $xeTable.scrollToRow(targetRow).then(() => $xeTable.triggerCurrentRowEvent(evnt, params));
        }
      },
      // 处理可编辑方向键移动
      moveSelected(args, isLeftArrow, isUpArrow, isRightArrow, isDwArrow, evnt) {
        const { afterFullData, visibleColumn } = internalData;
        const params = Object.assign({}, args);
        const _rowIndex = $xeTable.getVTRowIndex(params.row);
        const _columnIndex = $xeTable.getVTColumnIndex(params.column);
        evnt.preventDefault();
        if (isUpArrow && _rowIndex > 0) {
          params.rowIndex = _rowIndex - 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isDwArrow && _rowIndex < afterFullData.length - 1) {
          params.rowIndex = _rowIndex + 1;
          params.row = afterFullData[params.rowIndex];
        } else if (isLeftArrow && _columnIndex) {
          params.columnIndex = _columnIndex - 1;
          params.column = visibleColumn[params.columnIndex];
        } else if (isRightArrow && _columnIndex < visibleColumn.length - 1) {
          params.columnIndex = _columnIndex + 1;
          params.column = visibleColumn[params.columnIndex];
        }
        $xeTable.scrollToRow(params.row, params.column).then(() => {
          params.cell = $xeTable.getCellElement(params.row, params.column);
          $xeTable.handleSelected(params, evnt);
        });
      },
      handleCellMousedownEvent
    };
    return keyboardMethods;
  }
});

// node_modules/vxe-table/es/table/module/validator/hook.js
var import_xe_utils34 = __toESM(require_xe_utils());
var { getConfig: getConfig6, validators: validators3, hooks: hooks9 } = VxeUI;
var Rule = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  get content() {
    return getFuncText(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var tableValidatorMethodKeys = ["fullValidate", "validate", "fullValidateField", "validateField", "clearValidate"];
hooks9.add("tableValidatorModule", {
  setupTable($xeTable) {
    const { props, reactData, internalData } = $xeTable;
    const { refValidTooltip } = $xeTable.getRefMaps();
    const { computeValidOpts, computeTreeOpts, computeEditOpts } = $xeTable.getComputeMaps();
    let validatorMethods = {};
    let validatorPrivateMethods = {};
    let validRuleErr;
    const handleValidError = (params) => {
      return new Promise((resolve) => {
        const validOpts = computeValidOpts.value;
        if (validOpts.autoPos === false) {
          $xeTable.dispatchEvent("valid-error", params, null);
          resolve();
        } else {
          $xeTable.handleEdit(params, { type: "valid-error", trigger: "call" }).then(() => {
            resolve(validatorPrivateMethods.showValidTooltip(params));
          });
        }
      });
    };
    const handleErrMsgMode = (validErrMaps) => {
      const validOpts = computeValidOpts.value;
      if (validOpts.msgMode === "single") {
        const keys = Object.keys(validErrMaps);
        const resMaps = {};
        if (keys.length) {
          const firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    };
    const beginValidate = (rows, cols, cb2, isFull) => {
      const validRest = {};
      const { editRules, treeConfig } = props;
      const { afterFullData, visibleColumn } = internalData;
      const treeOpts = computeTreeOpts.value;
      const childrenField = treeOpts.children || treeOpts.childrenField;
      const validOpts = computeValidOpts.value;
      let validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (import_xe_utils34.default.isFunction(rows)) {
          cb2 = rows;
        } else {
          validList = import_xe_utils34.default.isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        if ($xeTable.getInsertRecords) {
          validList = $xeTable.getInsertRecords().concat($xeTable.getUpdateRecords());
        } else {
          validList = [];
        }
      }
      const rowValidErrs = [];
      internalData._lastCallTime = Date.now();
      validRuleErr = false;
      validatorMethods.clearValidate();
      const validErrMaps = {};
      if (editRules) {
        const columns = cols && cols.length ? cols : $xeTable.getColumns();
        const handleVaild = (row) => {
          if (isFull || !validRuleErr) {
            const colVailds = [];
            columns.forEach((column) => {
              const field = import_xe_utils34.default.isString(column) ? column : column.field;
              if ((isFull || !validRuleErr) && import_xe_utils34.default.has(editRules, field)) {
                colVailds.push(validatorPrivateMethods.validCellRules("all", row, column).catch(({ rule, rules }) => {
                  const rest = {
                    rule,
                    rules,
                    rowIndex: $xeTable.getRowIndex(row),
                    row,
                    columnIndex: $xeTable.getColumnIndex(column),
                    column,
                    field,
                    $table: $xeTable
                  };
                  if (!validRest[field]) {
                    validRest[field] = [];
                  }
                  validErrMaps[`${getRowid($xeTable, row)}:${column.id}`] = {
                    column,
                    row,
                    rule,
                    content: rule.content
                  };
                  validRest[field].push(rest);
                  if (!isFull) {
                    validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (treeConfig) {
          import_xe_utils34.default.eachTree(validList, handleVaild, { children: childrenField });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(() => {
          const ruleProps = Object.keys(validRest);
          reactData.validErrorMaps = handleErrMsgMode(validErrMaps);
          return nextTick().then(() => {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb2) {
              cb2();
            }
          });
        }).catch((firstErrParams) => {
          return new Promise((resolve, reject) => {
            const finish = () => {
              nextTick(() => {
                if (cb2) {
                  cb2(validRest);
                  resolve();
                } else {
                  if (getConfig6().validToReject === "obsolete") {
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            const posAndFinish = () => {
              firstErrParams.cell = $xeTable.getCellElement(firstErrParams.row, firstErrParams.column);
              scrollToView(firstErrParams.cell);
              handleValidError(firstErrParams).then(finish);
            };
            if (validOpts.autoPos === false) {
              finish();
            } else {
              const row = firstErrParams.row;
              const column = firstErrParams.column;
              const rowIndex = afterFullData.indexOf(row);
              const columnIndex = visibleColumn.indexOf(column);
              const targetRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;
              const targetColumn = columnIndex > 0 ? visibleColumn[columnIndex - 1] : column;
              $xeTable.scrollToRow(targetRow, targetColumn).then(posAndFinish);
            }
          });
        });
      } else {
        reactData.validErrorMaps = {};
      }
      return nextTick().then(() => {
        if (cb2) {
          cb2();
        }
      });
    };
    validatorMethods = {
      /**
       * 完整校验行，和 validate 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidate(rows, cb2) {
        if (true) {
          if (import_xe_utils34.default.isFunction(cb2)) {
            warnLog("vxe.error.notValidators", ["fullValidate(rows, callback)", "fullValidate(rows)"]);
          }
        }
        return beginValidate(rows, null, cb2, true);
      },
      /**
       * 快速校验行，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validate(rows, cb2) {
        return beginValidate(rows, null, cb2);
      },
      /**
       * 完整校验单元格，和 validateField 的区别就是会给有效数据中的每一行进行校验
       */
      fullValidateField(rows, fieldOrColumn) {
        const colList = (import_xe_utils34.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null, true);
        }
        return nextTick();
      },
      /**
       * 快速校验单元格，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
       */
      validateField(rows, fieldOrColumn) {
        const colList = (import_xe_utils34.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        if (colList.length) {
          return beginValidate(rows, colList, null);
        }
        return nextTick();
      },
      clearValidate(rows, fieldOrColumn) {
        const { validErrorMaps } = reactData;
        const validTip = refValidTooltip.value;
        const validOpts = computeValidOpts.value;
        const rowList = import_xe_utils34.default.isArray(rows) ? rows : rows ? [rows] : [];
        const colList = (import_xe_utils34.default.isArray(fieldOrColumn) ? fieldOrColumn : fieldOrColumn ? [fieldOrColumn] : []).map((column) => handleFieldOrColumn($xeTable, column));
        let validErrMaps = {};
        if (validTip && validTip.reactData.visible) {
          validTip.close();
        }
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
          return nextTick();
        }
        if (rowList.length && colList.length) {
          validErrMaps = Object.assign({}, validErrorMaps);
          rowList.forEach((row) => {
            colList.forEach((column) => {
              const validKey = `${getRowid($xeTable, row)}:${column.id}`;
              if (validErrMaps[validKey]) {
                delete validErrMaps[validKey];
              }
            });
          });
        } else if (rowList.length) {
          const rowIdList = rowList.map((row) => `${getRowid($xeTable, row)}`);
          import_xe_utils34.default.each(validErrorMaps, (item, key) => {
            if (rowIdList.indexOf(key.split(":")[0]) > -1) {
              validErrMaps[key] = item;
            }
          });
        } else if (colList.length) {
          const colidList = colList.map((column) => `${column.id}`);
          import_xe_utils34.default.each(validErrorMaps, (item, key) => {
            if (colidList.indexOf(key.split(":")[1]) > -1) {
              validErrMaps[key] = item;
            }
          });
        }
        reactData.validErrorMaps = validErrMaps;
        return nextTick();
      }
    };
    const validErrorRuleValue2 = (rule, val) => {
      const { type, min, max, pattern } = rule;
      const isNumType = type === "number";
      const numVal = isNumType ? import_xe_utils34.default.toNumber(val) : import_xe_utils34.default.getSize(val);
      if (isNumType && isNaN(val)) {
        return true;
      }
      if (!import_xe_utils34.default.eqNull(min) && numVal < import_xe_utils34.default.toNumber(min)) {
        return true;
      }
      if (!import_xe_utils34.default.eqNull(max) && numVal > import_xe_utils34.default.toNumber(max)) {
        return true;
      }
      if (pattern && !(import_xe_utils34.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
        return true;
      }
      return false;
    };
    validatorPrivateMethods = {
      /**
       * 校验数据
       * 按表格行、列顺序依次校验（同步或异步）
       * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
       * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
       * 如果是传回调方式这返回一个校验不通过列的错误消息
       *
       * rule 配置：
       *  required=Boolean 是否必填
       *  min=Number 最小长度
       *  max=Number 最大长度
       *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
       *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
       */
      validCellRules(validType, row, column, val) {
        const { editRules } = props;
        const { field } = column;
        const errorRules = [];
        const syncValidList = [];
        if (field && editRules) {
          const rules = import_xe_utils34.default.get(editRules, field);
          if (rules) {
            const cellValue = import_xe_utils34.default.isUndefined(val) ? import_xe_utils34.default.get(row, field) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    cellValue,
                    rule,
                    rules,
                    row,
                    rowIndex: $xeTable.getRowIndex(row),
                    column,
                    columnIndex: $xeTable.getColumnIndex(column),
                    field: column.field,
                    $table: $xeTable,
                    $grid: $xeTable.xegrid
                  };
                  let customValid;
                  if (import_xe_utils34.default.isString(validator)) {
                    const gvItem = validators3.get(validator);
                    if (gvItem) {
                      const tcvMethod = gvItem.tableCellValidatorMethod || gvItem.cellValidatorMethod;
                      if (tcvMethod) {
                        customValid = tcvMethod(validParams);
                      } else {
                        if (true) {
                          warnLog("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils34.default.isError(customValid)) {
                      validRuleErr = true;
                      errorRules.push(new Rule({ type: "custom", trigger, content: customValid.message, rule: new Rule(rule) }));
                    } else if (customValid.catch) {
                      syncValidList.push(customValid.catch((e16) => {
                        validRuleErr = true;
                        errorRules.push(new Rule({ type: "custom", trigger, content: e16 && e16.message ? e16.message : rule.content || rule.message, rule: new Rule(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils34.default.isArray(cellValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !cellValue.length;
                  } else if (import_xe_utils34.default.isString(cellValue)) {
                    hasEmpty = eqEmptyValue(cellValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue(cellValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue2(rule, cellValue) : !hasEmpty && validErrorRuleValue2(rule, cellValue)) {
                    validRuleErr = true;
                    errorRules.push(new Rule(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncValidList).then(() => {
          if (errorRules.length) {
            const rest = { rules: errorRules, rule: errorRules[0] };
            return Promise.reject(rest);
          }
        });
      },
      hasCellRules(type, row, column) {
        const { editRules } = props;
        const { field } = column;
        if (field && editRules) {
          const rules = import_xe_utils34.default.get(editRules, field);
          return rules && !!import_xe_utils34.default.find(rules, (rule) => type === "all" || !rule.trigger || type === rule.trigger);
        }
        return false;
      },
      /**
       * 触发校验
       */
      triggerValidate(type) {
        const { editConfig, editRules } = props;
        const { editStore } = reactData;
        const { actived } = editStore;
        const editOpts = computeEditOpts.value;
        const validOpts = computeValidOpts.value;
        if (editRules && validOpts.msgMode === "single") {
          reactData.validErrorMaps = {};
        }
        if (editConfig && editRules && actived.row) {
          const { row, column, cell } = actived.args;
          if (validatorPrivateMethods.hasCellRules(type, row, column)) {
            return validatorPrivateMethods.validCellRules(type, row, column).then(() => {
              if (editOpts.mode === "row") {
                validatorMethods.clearValidate(row, column);
              }
            }).catch(({ rule }) => {
              if (!rule.trigger || type === rule.trigger) {
                const rest = { rule, row, column, cell };
                validatorPrivateMethods.showValidTooltip(rest);
                return Promise.reject(rest);
              }
              return Promise.resolve();
            });
          }
        }
        return Promise.resolve();
      },
      /**
       * 弹出校验错误提示
       */
      showValidTooltip(params) {
        const { height } = props;
        const { tableData, validStore, validErrorMaps } = reactData;
        const { rule, row, column, cell } = params;
        const validOpts = computeValidOpts.value;
        const validTip = refValidTooltip.value;
        const content = rule.content;
        validStore.visible = true;
        if (validOpts.msgMode === "single") {
          reactData.validErrorMaps = {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          };
        } else {
          reactData.validErrorMaps = Object.assign({}, validErrorMaps, {
            [`${getRowid($xeTable, row)}:${column.id}`]: {
              column,
              row,
              rule,
              content
            }
          });
        }
        $xeTable.dispatchEvent("valid-error", params, null);
        if (validTip) {
          if (validTip && (validOpts.message === "tooltip" || validOpts.message === "default" && !height && tableData.length < 2)) {
            return validTip.open(cell, content);
          }
        }
        return nextTick();
      }
    };
    return Object.assign(Object.assign({}, validatorMethods), validatorPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableValidatorMethodKeys);
  }
});

// node_modules/vxe-table/es/table/module/custom/hook.js
var import_xe_utils35 = __toESM(require_xe_utils());
var tableCustomMethodKeys = ["openCustom", "closeCustom", "saveCustom", "cancelCustom", "resetCustom", "toggleCustomAllCheckbox", "setCustomAllCheckbox"];
VxeUI.hooks.add("tableCustomModule", {
  setupTable($xeTable) {
    const { reactData, internalData } = $xeTable;
    const { computeCustomOpts } = $xeTable.getComputeMaps();
    const { refElem } = $xeTable.getRefMaps();
    const $xeGrid = $xeTable.xegrid;
    const calcMaxHeight = () => {
      const { customStore } = reactData;
      const el2 = refElem.value;
      let tableHeight = 0;
      if (el2) {
        tableHeight = el2.clientHeight - 28;
      }
      customStore.maxHeight = Math.max(88, tableHeight);
    };
    const openCustom = () => {
      const { initStore, customStore } = reactData;
      customStore.visible = true;
      initStore.custom = true;
      handleUpdateCustomColumn();
      checkCustomStatus();
      calcMaxHeight();
      return nextTick().then(() => calcMaxHeight());
    };
    const handleUpdateCustomColumn = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      if (customStore.visible) {
        const sortMaps = {};
        const fixedMaps = {};
        const visibleMaps = {};
        import_xe_utils35.default.eachTree(collectColumn, (column) => {
          const colid = column.getKey();
          column.renderFixed = column.fixed;
          column.renderVisible = column.visible;
          column.renderResizeWidth = column.renderWidth;
          sortMaps[colid] = column.renderSortNumber;
          fixedMaps[colid] = column.fixed;
          visibleMaps[colid] = column.visible;
        });
        customStore.oldSortMaps = sortMaps;
        customStore.oldFixedMaps = fixedMaps;
        customStore.oldVisibleMaps = visibleMaps;
        reactData.customColumnList = collectColumn.slice(0);
      }
    };
    const closeCustom = () => {
      const { customStore } = reactData;
      const customOpts = computeCustomOpts.value;
      if (customStore.visible) {
        customStore.visible = false;
        if (!customOpts.immediate) {
          $xeTable.handleCustom();
        }
      }
      return nextTick();
    };
    const saveCustom = () => {
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { allowVisible, allowSort, allowFixed, allowResizable } = customOpts;
      import_xe_utils35.default.eachTree(customColumnList, (column, index2, items, path, parent) => {
        if (parent) {
          column.fixed = parent.fixed;
        } else {
          if (allowSort) {
            const sortIndex = index2 + 1;
            column.renderSortNumber = sortIndex;
          }
          if (allowFixed) {
            column.fixed = column.renderFixed;
          }
        }
        if (allowResizable) {
          if (column.renderVisible && (!column.children || column.children.length)) {
            if (column.renderResizeWidth !== column.renderWidth) {
              column.resizeWidth = column.renderResizeWidth;
              column.renderWidth = column.renderResizeWidth;
            }
          }
        }
        if (allowVisible) {
          column.visible = column.renderVisible;
        }
      });
      reactData.isCustomStatus = true;
      reactData.isDragColMove = true;
      setTimeout(() => {
        reactData.isDragColMove = false;
      }, 1e3);
      return $xeTable.saveCustomStore("confirm");
    };
    const cancelCustom = () => {
      const { customColumnList, customStore } = reactData;
      const { oldSortMaps, oldFixedMaps, oldVisibleMaps } = customStore;
      const customOpts = computeCustomOpts.value;
      const { allowVisible, allowSort, allowFixed, allowResizable } = customOpts;
      import_xe_utils35.default.eachTree(customColumnList, (column) => {
        const colid = column.getKey();
        const visible = !!oldVisibleMaps[colid];
        const fixed = oldFixedMaps[colid] || "";
        if (allowVisible) {
          column.renderVisible = visible;
          column.visible = visible;
        }
        if (allowFixed) {
          column.renderFixed = fixed;
          column.fixed = fixed;
        }
        if (allowSort) {
          column.renderSortNumber = oldSortMaps[colid] || 0;
        }
        if (allowResizable) {
          column.renderResizeWidth = column.renderWidth;
        }
      }, { children: "children" });
      return nextTick();
    };
    const setCustomAllCheckbox = (checked) => {
      const { customStore } = reactData;
      const { customColumnList } = reactData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod, visibleMethod } = customOpts;
      const isAll = !!checked;
      if (customOpts.immediate) {
        import_xe_utils35.default.eachTree(customColumnList, (column) => {
          if (visibleMethod && !visibleMethod({ column })) {
            return;
          }
          if (checkMethod && !checkMethod({ column })) {
            return;
          }
          column.visible = isAll;
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
        reactData.isCustomStatus = true;
        $xeTable.handleCustom();
        $xeTable.saveCustomStore("update:visible");
      } else {
        import_xe_utils35.default.eachTree(customColumnList, (column) => {
          if (visibleMethod && !visibleMethod({ column })) {
            return;
          }
          if (checkMethod && !checkMethod({ column })) {
            return;
          }
          column.renderVisible = isAll;
          column.halfVisible = false;
        });
        customStore.isAll = isAll;
      }
      $xeTable.checkCustomStatus();
      return nextTick();
    };
    const customMethods = {
      openCustom,
      closeCustom,
      saveCustom,
      cancelCustom,
      resetCustom(options) {
        const { collectColumn } = internalData;
        const customOpts = computeCustomOpts.value;
        const { checkMethod } = customOpts;
        const opts = Object.assign({
          visible: true,
          resizable: options === true,
          fixed: options === true,
          sort: options === true
        }, options);
        import_xe_utils35.default.eachTree(collectColumn, (column) => {
          if (opts.resizable) {
            column.resizeWidth = 0;
          }
          if (opts.fixed) {
            column.fixed = column.defaultFixed;
          }
          if (opts.sort) {
            column.renderSortNumber = column.sortNumber;
          }
          if (!checkMethod || checkMethod({ column })) {
            column.visible = column.defaultVisible;
          }
          column.renderResizeWidth = column.renderWidth;
        });
        reactData.isCustomStatus = false;
        $xeTable.saveCustomStore("reset");
        return $xeTable.handleCustom();
      },
      toggleCustomAllCheckbox() {
        const { customStore } = reactData;
        const isAll = !customStore.isAll;
        return setCustomAllCheckbox(isAll);
      },
      setCustomAllCheckbox
    };
    const checkCustomStatus = () => {
      const { customStore } = reactData;
      const { collectColumn } = internalData;
      const customOpts = computeCustomOpts.value;
      const { checkMethod } = customOpts;
      customStore.isAll = collectColumn.every((column) => (checkMethod ? !checkMethod({ column }) : false) || column.renderVisible);
      customStore.isIndeterminate = !customStore.isAll && collectColumn.some((column) => (!checkMethod || checkMethod({ column })) && (column.renderVisible || column.halfVisible));
    };
    const emitCustomEvent = (type, evnt) => {
      const comp = $xeGrid || $xeTable;
      comp.dispatchEvent("custom", { type }, evnt);
    };
    const customPrivateMethods = {
      checkCustomStatus,
      emitCustomEvent,
      triggerCustomEvent(evnt) {
        const { customStore } = $xeTable.reactData;
        if (customStore.visible) {
          closeCustom();
          emitCustomEvent("close", evnt);
        } else {
          customStore.btnEl = evnt.target;
          openCustom();
          emitCustomEvent("open", evnt);
        }
      },
      customOpenEvent(evnt) {
        const { customStore } = reactData;
        if (!customStore.visible) {
          customStore.activeBtn = true;
          customStore.btnEl = evnt.target;
          $xeTable.openCustom();
          $xeTable.emitCustomEvent("open", evnt);
        }
      },
      customCloseEvent(evnt) {
        const { customStore } = reactData;
        if (customStore.visible) {
          customStore.activeBtn = false;
          $xeTable.closeCustom();
          $xeTable.emitCustomEvent("close", evnt);
        }
      },
      handleUpdateCustomColumn
    };
    return Object.assign(Object.assign({}, customMethods), customPrivateMethods);
  },
  setupGrid($xeGrid) {
    return $xeGrid.extendTableMethods(tableCustomMethodKeys);
  }
});

// node_modules/vxe-table/es/table/render/index.js
var import_xe_utils36 = __toESM(require_xe_utils());
var { getConfig: getConfig7, renderer: renderer12, getI18n: getI18n13 } = VxeUI;
var componentDefaultModelProp = "modelValue";
var defaultCompProps = {};
function parseDate(value, props) {
  return value && props.valueFormat ? import_xe_utils36.default.toStringDate(value, props.valueFormat) : value;
}
function getFormatDate(value, props, defaultFormat) {
  const { dateConfig = {} } = props;
  return import_xe_utils36.default.toDateString(parseDate(value, props), dateConfig.labelFormat || defaultFormat);
}
function getLabelFormatDate(value, props) {
  return getFormatDate(value, props, getI18n13(`vxe.input.date.labelFormat.${props.type || "date"}`));
}
function getOldComponentName(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent({ name }) {
  return resolveComponent(name);
}
function getOldComponent({ name }) {
  return resolveComponent(getOldComponentName(name));
}
function handleConfirmFilter(params, checked, option2) {
  const { $panel } = params;
  $panel.changeOption({}, checked, option2);
}
function getNativeAttrs(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getInputImmediateModel(renderOpts) {
  const { name, immediate, props } = renderOpts;
  if (!immediate) {
    if (name === "VxeInput" || name === "$input") {
      const { type } = props || {};
      return !(!type || type === "text" || type === "number" || type === "integer" || type === "float");
    }
    if (name === "input" || name === "textarea" || name === "$textarea") {
      return false;
    }
    return true;
  }
  return immediate;
}
function getCellEditProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils36.default.assign({ immediate: getInputImmediateModel(renderOpts) }, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function getCellEditFilterProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils36.default.assign({}, defaultCompProps, defaultProps, renderOpts.props, { [componentDefaultModelProp]: value });
}
function isImmediateCell(renderOpts, params) {
  return params.$type === "cell" || getInputImmediateModel(renderOpts);
}
function getCellLabelVNs(renderOpts, params, cellLabel) {
  const { placeholder } = renderOpts;
  return [
    h("span", {
      class: "vxe-cell--label"
    }, placeholder && isEmptyValue(cellLabel) ? [
      h("span", {
        class: "vxe-cell--placeholder"
      }, formatText(getFuncText(placeholder), 1))
    ] : formatText(cellLabel, 1))
  ];
}
function getNativeElementOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils36.default.objectEach(events, (func, key) => {
      ons[getOnName(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent(renderOpts);
  const changeEvent = getChangeEvent(renderOpts);
  const ons = {};
  import_xe_utils36.default.objectEach(events, (func, key) => {
    ons[getOnName(key)] = function(...args) {
      if (true) {
        if (!import_xe_utils36.default.isFunction(func)) {
          errLog("vxe.error.errFunc", [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { name } = renderOpts;
  const { model } = column;
  const isImmediate = isImmediateCell(renderOpts, params);
  return getComponentOns(renderOpts, params, (cellValue) => {
    model.update = true;
    model.value = cellValue;
    if (isImmediate) {
      setCellValue(row, column, cellValue);
    }
  }, (eventParams) => {
    if (!isImmediate && ["VxeInput", "VxeNumberInput", "VxeTextarea", "$input", "$textarea"].includes(name)) {
      const cellValue = eventParams.value;
      model.update = true;
      model.value = cellValue;
      $table.updateStatus(params, cellValue);
    } else {
      $table.updateStatus(params);
    }
  });
}
function getFilterOns(renderOpts, params, option2) {
  return getComponentOns(renderOpts, params, (value) => {
    option2.data = value;
  }, () => {
    handleConfirmFilter(params, !import_xe_utils36.default.eqNull(option2.data), option2);
  });
}
function getNativeEditOns(renderOpts, params) {
  const { $table, row, column } = params;
  const { model } = column;
  return getNativeElementOns(renderOpts, params, (evnt) => {
    const cellValue = evnt.target.value;
    if (isImmediateCell(renderOpts, params)) {
      setCellValue(row, column, cellValue);
    } else {
      model.update = true;
      model.value = cellValue;
    }
  }, (evnt) => {
    const cellValue = evnt.target.value;
    $table.updateStatus(params, cellValue);
  });
}
function getNativeFilterOns(renderOpts, params, option2) {
  return getNativeElementOns(renderOpts, params, (evnt) => {
    option2.data = evnt.target.value;
  }, () => {
    handleConfirmFilter(params, !import_xe_utils36.default.eqNull(option2.data), option2);
  });
}
function nativeEditRender(renderOpts, params) {
  const { row, column } = params;
  const { name } = renderOpts;
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, getNativeAttrs(renderOpts)), { value: cellValue }), getNativeEditOns(renderOpts, params)))
  ];
}
function buttonCellRender(renderOpts, params) {
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function defaultEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function radioAndCheckboxEditRender(renderOpts, params) {
  const { options } = renderOpts;
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldEditRender(renderOpts, params) {
  const { row, column } = params;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue)), getEditOns(renderOpts, params)))
  ];
}
function oldButtonEditRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
  ];
}
function oldButtonsEditRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonEditRender(childRenderOpts, params)[0]);
}
function renderNativeOptgroups(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function renderNativeOptions(options, renderOpts, params) {
  const { optionProps = {} } = renderOpts;
  const { row, column } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = isImmediateCell(renderOpts, params) ? getCellValue(row, column) : column.model.value;
  return options.map((option2, oIndex) => {
    return h("option", {
      key: oIndex,
      value: option2[valueProp],
      disabled: option2[disabledProp],
      /* eslint-disable eqeqeq */
      selected: option2[valueProp] == cellValue
    }, option2[labelProp]);
  });
}
function nativeFilterRender(renderOpts, params) {
  const { column } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs(renderOpts);
  return column.filters.map((option2, oIndex) => {
    return h(name, Object.assign(Object.assign(Object.assign({ key: oIndex, class: `vxe-default-${name}` }, attrs), { value: option2.data }), getNativeFilterOns(renderOpts, params, option2)));
  });
}
function defaultFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option2, oIndex) => {
    const optionValue = option2.data;
    return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option2)));
  });
}
function oldFilterRender(renderOpts, params) {
  const { column } = params;
  return column.filters.map((option2, oIndex) => {
    const optionValue = option2.data;
    return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, renderOpts, optionValue)), getFilterOns(renderOpts, params, option2)));
  });
}
function handleFilterMethod({ option: option2, row, column }) {
  const { data } = option2;
  const cellValue = import_xe_utils36.default.get(row, column.field);
  return cellValue == data;
}
function handleInputFilterMethod({ option: option2, row, column }) {
  const { data } = option2;
  const cellValue = import_xe_utils36.default.get(row, column.field);
  return import_xe_utils36.default.toValueString(cellValue).indexOf(data) > -1;
}
function nativeSelectEditRender(renderOpts, params) {
  return [
    h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeEditOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params))
  ];
}
function defaultSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function defaultTreeSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getDefaultComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps })), getEditOns(renderOpts, params)))
  ];
}
function oldSelectEditRender(renderOpts, params) {
  const { row, column } = params;
  const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
  const cellValue = getCellValue(row, column);
  return [
    h(getOldComponent(renderOpts), Object.assign(Object.assign({}, getCellEditProps(renderOpts, params, cellValue, { options, optionProps, optionGroups, optionGroupProps })), getEditOns(renderOpts, params)))
  ];
}
function getSelectCellValue(renderOpts, { row, column }) {
  const { options, optionGroups, optionProps = {}, optionGroupProps = {} } = renderOpts;
  const cellValue = import_xe_utils36.default.get(row, column.field);
  let selectItem;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  if (!(cellValue === null || cellValue === void 0)) {
    return import_xe_utils36.default.map(import_xe_utils36.default.isArray(cellValue) ? cellValue : [cellValue], optionGroups ? (value) => {
      const groupOptions = optionGroupProps.options || "options";
      for (let index2 = 0; index2 < optionGroups.length; index2++) {
        selectItem = import_xe_utils36.default.find(optionGroups[index2][groupOptions], (item) => item[valueProp] == value);
        if (selectItem) {
          break;
        }
      }
      return selectItem ? selectItem[labelProp] : value;
    } : (value) => {
      selectItem = import_xe_utils36.default.find(options, (item) => item[valueProp] == value);
      return selectItem ? selectItem[labelProp] : value;
    }).join(", ");
  }
  return "";
}
function handleExportSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getSelectCellValue(column.editRender || column.cellRender, params);
}
function getTreeSelectCellValue(renderOpts, { row, column }) {
  const { options, optionProps = {} } = renderOpts;
  const cellValue = import_xe_utils36.default.get(row, column.field);
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const childrenProp = optionProps.children || "children";
  if (!(cellValue === null || cellValue === void 0)) {
    const keyMaps = {};
    import_xe_utils36.default.eachTree(options, (item) => {
      keyMaps[import_xe_utils36.default.get(item, valueProp)] = item;
    }, { children: childrenProp });
    return import_xe_utils36.default.map(import_xe_utils36.default.isArray(cellValue) ? cellValue : [cellValue], (value) => {
      const item = keyMaps[value];
      return item ? import_xe_utils36.default.get(item, labelProp) : item;
    }).join(", ");
  }
  return "";
}
function handleExportTreeSelectMethod(params) {
  const { row, column, options } = params;
  return options.original ? getCellValue(row, column) : getTreeSelectCellValue(column.editRender || column.cellRender, params);
}
renderer12.mixin({
  input: {
    tableAutoFocus: "input",
    renderTableEdit: nativeEditRender,
    renderTableDefault: nativeEditRender,
    renderTableFilter: nativeFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  textarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: nativeEditRender
  },
  select: {
    renderTableEdit: nativeSelectEditRender,
    renderTableDefault: nativeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      return column.filters.map((option2, oIndex) => {
        return h("select", Object.assign(Object.assign({ key: oIndex, class: "vxe-default-select" }, getNativeAttrs(renderOpts)), getNativeFilterOns(renderOpts, params, option2)), renderOpts.optionGroups ? renderNativeOptgroups(renderOpts, params, renderNativeOptions) : renderNativeOptions(renderOpts.options, renderOpts, params));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeInput: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      var _a2;
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || ((_a2 = getConfig7().input) === null || _a2 === void 0 ? void 0 : _a2.digits) || 2;
      let cellValue = import_xe_utils36.default.get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "quarter":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils36.default.toFixed(import_xe_utils36.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  VxeNumberInput: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const { type } = props;
      let cellValue = import_xe_utils36.default.get(row, column.field);
      if (cellValue) {
        if (type === "float") {
          const digits = props.digits || getConfig7().numberInput.digits || 1;
          cellValue = import_xe_utils36.default.toFixed(import_xe_utils36.default.floor(cellValue, digits), digits);
        } else if (type === "amount") {
          const digits = props.digits || getConfig7().numberInput.digits || 2;
          cellValue = import_xe_utils36.default.commafy(import_xe_utils36.default.toNumber(cellValue), { digits });
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableFooter(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column, _columnIndex } = params;
      const { type } = props;
      const cellValue = import_xe_utils36.default.isArray(row) ? row[_columnIndex] : import_xe_utils36.default.get(row, column.field);
      if (import_xe_utils36.default.isNumber(cellValue)) {
        if (type === "float") {
          const digits = props.digits || getConfig7().numberInput.digits || 1;
          return import_xe_utils36.default.toFixed(import_xe_utils36.default.floor(cellValue, digits), digits);
        } else if (type === "amount") {
          const digits = props.digits || getConfig7().numberInput.digits || 2;
          return import_xe_utils36.default.commafy(import_xe_utils36.default.toNumber(cellValue), { digits });
        }
      }
      return getFuncText(cellValue, 1);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  VxeDatePicker: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { props = {} } = renderOpts;
      const { row, column } = params;
      let cellValue = import_xe_utils36.default.get(row, column.field);
      if (cellValue) {
        cellValue = getLabelFormatDate(cellValue, props);
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: defaultEditRender,
    renderTableFilter: defaultFilterRender,
    tableFilterDefaultMethod: handleFilterMethod
  },
  VxeTextarea: {
    tableAutoFocus: "textarea",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils36.default.get(row, column.field);
      return getCellLabelVNs(renderOpts, params, cellValue);
    }
  },
  VxeButton: {
    renderTableDefault: buttonCellRender
  },
  VxeButtonGroup: {
    renderTableDefault(renderOpts, params) {
      const { options } = renderOpts;
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ options }, getCellEditProps(renderOpts, params, null)), getComponentOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultSelectEditRender,
    renderTableDefault: defaultSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option2, oIndex) => {
        const optionValue = option2.data;
        return h(getDefaultComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option2)));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  VxeTreeSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeTableSelect: {
    tableAutoFocus: "input",
    renderTableEdit: defaultTreeSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getTreeSelectCellValue(renderOpts, params));
    },
    tableExportMethod: handleExportTreeSelectMethod
  },
  VxeIconPicker: {
    tableAutoFocus: "input",
    renderTableEdit: defaultEditRender,
    renderTableCell(renderOpts, params) {
      const { row, column } = params;
      const cellValue = import_xe_utils36.default.get(row, column.field);
      return h("i", {
        class: cellValue
      });
    }
  },
  VxeRadioGroup: {
    renderTableDefault: radioAndCheckboxEditRender
  },
  VxeCheckboxGroup: {
    renderTableDefault: radioAndCheckboxEditRender
  },
  VxeSwitch: {
    tableAutoFocus: "button",
    renderTableEdit: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeUpload: {
    renderTableEdit: defaultEditRender,
    renderTableCell: defaultEditRender,
    renderTableDefault: defaultEditRender
  },
  VxeImage: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeTextEllipsis: {
    renderTableDefault(renderOpts, params) {
      const { row, column } = params;
      const { props } = renderOpts;
      const cellValue = getCellValue(row, column);
      return [
        h(getDefaultComponent(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { content: cellValue }), getEditOns(renderOpts, params)))
      ];
    }
  },
  VxeRate: {
    renderTableDefault: defaultEditRender
  },
  VxeSlider: {
    renderTableDefault: defaultEditRender
  },
  // 以下已废弃
  $input: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: oldEditRender,
    renderTableCell(renderOpts, params) {
      var _a2;
      const { props = {} } = renderOpts;
      const { row, column } = params;
      const digits = props.digits || ((_a2 = getConfig7().input) === null || _a2 === void 0 ? void 0 : _a2.digits) || 2;
      let cellValue = import_xe_utils36.default.get(row, column.field);
      if (cellValue) {
        switch (props.type) {
          case "date":
          case "week":
          case "month":
          case "year":
            cellValue = getLabelFormatDate(cellValue, props);
            break;
          case "float":
            cellValue = import_xe_utils36.default.toFixed(import_xe_utils36.default.floor(cellValue, digits), digits);
            break;
        }
      }
      return getCellLabelVNs(renderOpts, params, cellValue);
    },
    renderTableDefault: oldEditRender,
    renderTableFilter: oldFilterRender,
    tableFilterDefaultMethod: handleInputFilterMethod
  },
  $textarea: {
    tableAutoFocus: ".vxe-textarea--inner"
  },
  $button: {
    renderTableDefault: oldButtonEditRender
  },
  $buttons: {
    renderTableDefault: oldButtonsEditRender
  },
  $select: {
    tableAutoFocus: ".vxe-input--inner",
    renderTableEdit: oldSelectEditRender,
    renderTableDefault: oldSelectEditRender,
    renderTableCell(renderOpts, params) {
      return getCellLabelVNs(renderOpts, params, getSelectCellValue(renderOpts, params));
    },
    renderTableFilter(renderOpts, params) {
      const { column } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      return column.filters.map((option2, oIndex) => {
        const optionValue = option2.data;
        return h(getOldComponent(renderOpts), Object.assign(Object.assign({ key: oIndex }, getCellEditFilterProps(renderOpts, params, optionValue, { options, optionProps, optionGroups, optionGroupProps })), getFilterOns(renderOpts, params, option2)));
      });
    },
    tableFilterDefaultMethod: handleFilterMethod,
    tableExportMethod: handleExportSelectMethod
  },
  $radio: {
    tableAutoFocus: ".vxe-radio--input"
  },
  $checkbox: {
    tableAutoFocus: ".vxe-checkbox--input"
  },
  $switch: {
    tableAutoFocus: ".vxe-switch--button",
    renderTableEdit: oldEditRender,
    renderTableDefault: oldEditRender
  }
  // 以上已废弃
});

// node_modules/vxe-table/es/table/index.js
var VxeTable = Object.assign({}, table_default, {
  install(app) {
    app.component(table_default.name, table_default);
  }
});
var tableHandle = {
  useCellView
};
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(table_default.name, table_default);
}
VxeUI.component(table_default);
VxeUI.tableHandle = tableHandle;
var Table = VxeTable;
var table_default2 = VxeTable;

// node_modules/vxe-table/es/toolbar/src/toolbar.js
var import_xe_utils37 = __toESM(require_xe_utils());
var { getConfig: getConfig8, getIcon: getIcon10, getI18n: getI18n14, renderer: renderer13, commands: commands3, createEvent: createEvent3, useFns: useFns3 } = VxeUI;
var toolbar_default = defineComponent({
  name: "VxeToolbar",
  props: {
    loading: Boolean,
    refresh: [Boolean, Object],
    import: [Boolean, Object],
    export: [Boolean, Object],
    print: [Boolean, Object],
    zoom: [Boolean, Object],
    custom: [Boolean, Object],
    buttons: {
      type: Array,
      default: () => getConfig8().toolbar.buttons
    },
    tools: {
      type: Array,
      default: () => getConfig8().toolbar.tools
    },
    perfect: {
      type: Boolean,
      default: () => getConfig8().toolbar.perfect
    },
    size: {
      type: String,
      default: () => getConfig8().toolbar.size || getConfig8().size
    },
    className: [String, Function]
  },
  emits: [
    "button-click",
    "tool-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils37.default.uniqueId();
    const VxeUIButtonComponent = VxeUI.getComponent("VxeButton");
    const { computeSize } = useFns3.useSize(props);
    const reactData = reactive({
      isRefresh: false,
      connectFlag: 0,
      columns: []
    });
    const internalData = {
      connectTable: null
    };
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeToolbar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let toolbarMethods = {};
    const $xeGrid = inject("$xeGrid", null);
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.refresh, true), props.refresh);
    });
    const computeImportOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.import, true), props.import);
    });
    const computeExportOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.export, true), props.export);
    });
    const computePrintOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.print, true), props.print);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.zoom, true), props.zoom);
    });
    const computeCustomOpts = computed(() => {
      return Object.assign({}, import_xe_utils37.default.clone(getConfig8().toolbar.custom, true), props.custom);
    });
    const computeTableCustomOpts = computed(() => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if (reactData.connectFlag || $table) {
        if ($table) {
          const { computeCustomOpts: computeCustomOpts2 } = $table.getComputeMaps();
          return computeCustomOpts2.value;
        }
      }
      return { trigger: "" };
    });
    const computeTrigger = computed(() => {
      const tableCustomOpts = computeTableCustomOpts.value;
      return tableCustomOpts.trigger;
    });
    const checkTable = () => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if ($table) {
        return true;
      }
      errLog("vxe.error.barUnableLink");
    };
    const handleClickSettingEvent = ({ $event }) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if ($table) {
        if ($table.triggerCustomEvent) {
          $table.triggerCustomEvent($event);
        } else {
          errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
        }
      }
    };
    const handleMouseenterSettingEvent = ({ $event }) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if ($table) {
        $table.customOpenEvent($event);
      } else {
        errLog("vxe.error.reqModule", ["VxeTableCustomModule"]);
      }
    };
    const handleMouseleaveSettingEvent = ({ $event }) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      if ($table) {
        const { customStore } = $table.reactData;
        customStore.activeBtn = false;
        setTimeout(() => {
          if (!customStore.activeBtn && !customStore.activeWrapper) {
            $table.customCloseEvent($event);
          }
        }, 350);
      }
    };
    const refreshEvent = ({ $event }) => {
      const { isRefresh } = reactData;
      const refreshOpts = computeRefreshOpts.value;
      if (!isRefresh) {
        const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
        if (queryMethod) {
          reactData.isRefresh = true;
          try {
            Promise.resolve(queryMethod({})).catch((e16) => e16).then(() => {
              reactData.isRefresh = false;
            });
          } catch (e16) {
            reactData.isRefresh = false;
          }
        } else if ($xeGrid) {
          reactData.isRefresh = true;
          $xeGrid.triggerToolbarCommitEvent({ code: refreshOpts.code || "reload" }, $event).catch((e16) => e16).then(() => {
            reactData.isRefresh = false;
          });
        }
      }
    };
    const zoomEvent = ({ $event }) => {
      if ($xeGrid) {
        $xeGrid.triggerZoomEvent($event);
      }
    };
    const btnEvent = (evnt, item) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      const { code: code3 } = item;
      if (code3) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarBtnEvent(item, evnt);
        } else {
          const gCommandOpts = commands3.get(code3);
          const params = { code: code3, button: item, $table, $grid: $xeGrid, $event: evnt };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code3]);
              }
            }
          }
          $xeToolbar.dispatchEvent("button-click", params, evnt);
        }
      }
    };
    const tolEvent = (evnt, item) => {
      const { connectTable } = internalData;
      const $table = connectTable;
      const { code: code3 } = item;
      if (code3) {
        if ($xeGrid) {
          $xeGrid.triggerToolbarTolEvent(item, evnt);
        } else {
          const gCommandOpts = commands3.get(code3);
          const params = { code: code3, tool: item, $table, $grid: $xeGrid, $event: evnt };
          if (gCommandOpts) {
            const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
            if (tCommandMethod) {
              tCommandMethod(params);
            } else {
              if (true) {
                errLog("vxe.error.notCommands", [code3]);
              }
            }
          }
          $xeToolbar.dispatchEvent("tool-click", params, evnt);
        }
      }
    };
    const importEvent = () => {
      if (checkTable()) {
        const { connectTable } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openImport();
        }
      }
    };
    const exportEvent = () => {
      if (checkTable()) {
        const { connectTable } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openExport();
        }
      }
    };
    const printEvent = () => {
      if (checkTable()) {
        const { connectTable } = internalData;
        const $table = connectTable;
        if ($table) {
          $table.openPrint();
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent3(evnt, { $toolbar: $xeToolbar }, params));
    };
    toolbarMethods = {
      dispatchEvent: dispatchEvent2,
      syncUpdate(params) {
        internalData.connectTable = params.$table;
        reactData.columns = params.collectColumn;
        reactData.connectFlag++;
      }
    };
    Object.assign($xeToolbar, toolbarMethods);
    const renderDropdowns = (item, isBtn) => {
      const { dropdowns } = item;
      const downVNs = [];
      if (dropdowns) {
        return dropdowns.map((child, index2) => {
          if (child.visible === false) {
            return createCommentVNode();
          }
          return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
            key: index2,
            disabled: child.disabled,
            loading: child.loading,
            type: child.type,
            mode: child.mode,
            icon: child.icon,
            circle: child.circle,
            round: child.round,
            status: child.status,
            content: child.name,
            title: child.title,
            routerLink: child.routerLink,
            permissionCode: child.permissionCode,
            prefixTooltip: child.prefixTooltip,
            suffixTooltip: child.suffixTooltip,
            onClick: ({ $event }) => isBtn ? btnEvent($event, child) : tolEvent($event, child)
          }) : createCommentVNode();
        });
      }
      return downVNs;
    };
    const renderBtns = () => {
      const { buttons } = props;
      const { connectTable } = internalData;
      const $table = connectTable;
      const btnVNs = [];
      if (buttons) {
        buttons.forEach((item) => {
          const { dropdowns, buttonRender } = item;
          if (item.visible !== false) {
            const compConf = buttonRender ? renderer13.get(buttonRender.name) : null;
            if (buttonRender && compConf && compConf.renderToolbarButton) {
              const toolbarButtonClassName = compConf.toolbarButtonClassName;
              const params = { $grid: $xeGrid, $table, button: item };
              btnVNs.push(h("span", {
                class: ["vxe-button--item", toolbarButtonClassName ? import_xe_utils37.default.isFunction(toolbarButtonClassName) ? toolbarButtonClassName(params) : toolbarButtonClassName : ""]
              }, getSlotVNs(compConf.renderToolbarButton(buttonRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push(h(VxeUIButtonComponent, {
                  disabled: item.disabled,
                  loading: item.loading,
                  type: item.type,
                  mode: item.mode,
                  icon: item.icon,
                  circle: item.circle,
                  round: item.round,
                  status: item.status,
                  content: item.name,
                  title: item.title,
                  routerLink: item.routerLink,
                  permissionCode: item.permissionCode,
                  prefixTooltip: item.prefixTooltip,
                  suffixTooltip: item.suffixTooltip,
                  destroyOnClose: item.destroyOnClose,
                  placement: item.placement,
                  transfer: item.transfer,
                  onClick: ({ $event }) => btnEvent($event, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, true)
                } : {}));
              }
            }
          }
        });
      }
      return btnVNs;
    };
    const renderRightTools = () => {
      const { tools } = props;
      const { connectTable } = internalData;
      const $table = connectTable;
      const btnVNs = [];
      if (tools) {
        tools.forEach((item, tIndex) => {
          const { dropdowns, toolRender } = item;
          if (item.visible !== false) {
            const rdName = toolRender ? toolRender.name : null;
            const compConf = toolRender ? renderer13.get(rdName) : null;
            if (toolRender && compConf && compConf.renderToolbarTool) {
              const toolbarToolClassName = compConf.toolbarToolClassName;
              const params = { $grid: $xeGrid, $table, tool: item };
              btnVNs.push(h("span", {
                key: rdName,
                class: ["vxe-tool--item", toolbarToolClassName ? import_xe_utils37.default.isFunction(toolbarToolClassName) ? toolbarToolClassName(params) : toolbarToolClassName : ""]
              }, getSlotVNs(compConf.renderToolbarTool(toolRender, params))));
            } else {
              if (VxeUIButtonComponent) {
                btnVNs.push(h(VxeUIButtonComponent, {
                  key: tIndex,
                  disabled: item.disabled,
                  loading: item.loading,
                  type: item.type,
                  mode: item.mode,
                  icon: item.icon,
                  circle: item.circle,
                  round: item.round,
                  status: item.status,
                  content: item.name,
                  title: item.title,
                  routerLink: item.routerLink,
                  permissionCode: item.permissionCode,
                  prefixTooltip: item.prefixTooltip,
                  suffixTooltip: item.suffixTooltip,
                  destroyOnClose: item.destroyOnClose,
                  placement: item.placement,
                  transfer: item.transfer,
                  onClick: ({ $event }) => tolEvent($event, item)
                }, dropdowns && dropdowns.length ? {
                  dropdowns: () => renderDropdowns(item, false)
                } : {}));
              }
            }
          }
        });
      }
      return btnVNs;
    };
    const renderToolImport = () => {
      const importOpts = computeImportOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "import",
        circle: true,
        icon: importOpts.icon || getIcon10().TOOLBAR_TOOLS_IMPORT,
        title: getI18n14("vxe.toolbar.import"),
        onClick: importEvent
      }) : createCommentVNode();
    };
    const renderToolExport = () => {
      const exportOpts = computeExportOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "export",
        circle: true,
        icon: exportOpts.icon || getIcon10().TOOLBAR_TOOLS_EXPORT,
        title: getI18n14("vxe.toolbar.export"),
        onClick: exportEvent
      }) : createCommentVNode();
    };
    const renderToolPrint = () => {
      const printOpts = computePrintOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "print",
        circle: true,
        icon: printOpts.icon || getIcon10().TOOLBAR_TOOLS_PRINT,
        title: getI18n14("vxe.toolbar.print"),
        onClick: printEvent
      }) : createCommentVNode();
    };
    const renderToolRefresh = () => {
      const refreshOpts = computeRefreshOpts.value;
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "refresh",
        circle: true,
        icon: reactData.isRefresh ? refreshOpts.iconLoading || getIcon10().TOOLBAR_TOOLS_REFRESH_LOADING : refreshOpts.icon || getIcon10().TOOLBAR_TOOLS_REFRESH,
        title: getI18n14("vxe.toolbar.refresh"),
        onClick: refreshEvent
      }) : createCommentVNode();
    };
    const renderToolZoom = () => {
      const zoomOpts = computeZoomOpts.value;
      return $xeGrid && VxeUIButtonComponent ? h(VxeUIButtonComponent, {
        key: "zoom",
        circle: true,
        icon: $xeGrid.isMaximized() ? zoomOpts.iconOut || getIcon10().TOOLBAR_TOOLS_MINIMIZE : zoomOpts.iconIn || getIcon10().TOOLBAR_TOOLS_FULLSCREEN,
        title: getI18n14(`vxe.toolbar.zoom${$xeGrid.isMaximized() ? "Out" : "In"}`),
        onClick: zoomEvent
      }) : createCommentVNode();
    };
    const renderToolCustom = () => {
      const customOpts = computeCustomOpts.value;
      const btnTrigger = computeTrigger.value;
      const customBtnOns = {};
      if (btnTrigger === "manual") {
      } else if (btnTrigger === "hover") {
        customBtnOns.onMouseenter = handleMouseenterSettingEvent;
        customBtnOns.onMouseleave = handleMouseleaveSettingEvent;
      } else {
        customBtnOns.onClick = handleClickSettingEvent;
      }
      return VxeUIButtonComponent ? h(VxeUIButtonComponent, Object.assign({ key: "custom", circle: true, icon: customOpts.icon || getIcon10().TOOLBAR_TOOLS_CUSTOM, title: getI18n14("vxe.toolbar.custom"), className: "vxe-toolbar-custom-target" }, customBtnOns)) : createCommentVNode();
    };
    const renderVN = () => {
      const { perfect, loading: loading2, refresh, zoom, custom, className } = props;
      const { connectTable } = internalData;
      const vSize = computeSize.value;
      const toolsSlot = slots.tools;
      const buttonsSlot = slots.buttons;
      const $table = connectTable;
      return h("div", {
        ref: refElem,
        class: ["vxe-toolbar", className ? import_xe_utils37.default.isFunction(className) ? className({ $toolbar: $xeToolbar }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--perfect": perfect,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          class: "vxe-buttons--wrapper"
        }, buttonsSlot ? buttonsSlot({ $grid: $xeGrid, $table }) : renderBtns()),
        h("div", {
          class: "vxe-tools--wrapper"
        }, toolsSlot ? toolsSlot({ $grid: $xeGrid, $table }) : renderRightTools()),
        h("div", {
          class: "vxe-tools--operate"
        }, [
          props.import ? renderToolImport() : createCommentVNode(),
          props.export ? renderToolExport() : createCommentVNode(),
          props.print ? renderToolPrint() : createCommentVNode(),
          refresh ? renderToolRefresh() : createCommentVNode(),
          zoom && $xeGrid ? renderToolZoom() : createCommentVNode(),
          custom ? renderToolCustom() : createCommentVNode()
        ])
      ]);
    };
    $xeToolbar.renderVN = renderVN;
    nextTick(() => {
      const { refresh } = props;
      const refreshOpts = computeRefreshOpts.value;
      const queryMethod = refreshOpts.queryMethod || refreshOpts.query;
      if (refresh && !$xeGrid && !queryMethod) {
        warnLog("vxe.error.notFunc", ["queryMethod"]);
      }
      const customOpts = computeCustomOpts.value;
      if (true) {
        if (customOpts.isFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.isFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.showFooter) {
          warnLog("vxe.error.delProp", ["toolbar.custom.showFooter", "table.custom-config.showFooter"]);
        }
        if (customOpts.immediate) {
          warnLog("vxe.error.delProp", ["toolbar.custom.immediate", "table.custom-config.immediate"]);
        }
        if (customOpts.trigger) {
          warnLog("vxe.error.delProp", ["toolbar.custom.trigger", "table.custom-config.trigger"]);
        }
      }
      if (true) {
        if (props.refresh || props.import || props.export || props.print || props.zoom) {
          if (!VxeUIButtonComponent) {
            errLog("vxe.error.reqComp", ["vxe-button"]);
          }
        }
      }
    });
    return $xeToolbar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/toolbar/index.js
var VxeToolbar = Object.assign({}, toolbar_default, {
  install(app) {
    app.component(toolbar_default.name, toolbar_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(toolbar_default.name, toolbar_default);
}
VxeUI.component(toolbar_default);
var Toolbar = VxeToolbar;
var toolbar_default2 = VxeToolbar;

// node_modules/vxe-table/es/grid/src/grid.js
var { getConfig: getConfig9, getI18n: getI18n15, commands: commands4, hooks: hooks10, useFns: useFns4, createEvent: createEvent4, globalEvents: globalEvents5, GLOBAL_EVENT_KEYS: GLOBAL_EVENT_KEYS4 } = VxeUI;
var tableComponentPropKeys = Object.keys(props_default);
var tableComponentMethodKeys = ["clearAll", "syncData", "updateData", "loadData", "reloadData", "reloadRow", "loadColumn", "reloadColumn", "getRowNode", "getColumnNode", "getRowIndex", "getVTRowIndex", "getVMRowIndex", "getColumnIndex", "getVTColumnIndex", "getVMColumnIndex", "setRow", "createData", "createRow", "revertData", "clearData", "isInsertByRow", "isUpdateByRow", "getColumns", "getColumnById", "getColumnByField", "getTableColumn", "getFullColumns", "getData", "getCheckboxRecords", "getParentRow", "getTreeParentRow", "getRowSeq", "getRowById", "getRowid", "getTableData", "getFullData", "setColumnFixed", "clearColumnFixed", "setColumnWidth", "getColumnWidth", "hideColumn", "showColumn", "resetColumn", "refreshColumn", "refreshScroll", "recalculate", "closeTooltip", "isAllCheckboxChecked", "isAllCheckboxIndeterminate", "getCheckboxIndeterminateRecords", "setCheckboxRow", "isCheckedByCheckboxRow", "isIndeterminateByCheckboxRow", "toggleCheckboxRow", "setAllCheckboxRow", "getRadioReserveRecord", "clearRadioReserve", "getCheckboxReserveRecords", "clearCheckboxReserve", "toggleAllCheckboxRow", "clearCheckboxRow", "setCurrentRow", "isCheckedByRadioRow", "setRadioRow", "clearCurrentRow", "clearRadioRow", "getCurrentRecord", "getRadioRecord", "getCurrentColumn", "setCurrentColumn", "clearCurrentColumn", "setPendingRow", "togglePendingRow", "getPendingRecords", "clearPendingRow", "sort", "setSort", "clearSort", "isSort", "getSortColumns", "closeFilter", "isFilter", "isActiveFilterByColumn", "isRowExpandLoaded", "clearRowExpandLoaded", "reloadRowExpand", "reloadRowExpand", "toggleRowExpand", "setAllRowExpand", "setRowExpand", "isExpandByRow", "isRowExpandByRow", "clearRowExpand", "clearRowExpandReserve", "getRowExpandRecords", "getTreeExpandRecords", "isTreeExpandLoaded", "clearTreeExpandLoaded", "reloadTreeExpand", "reloadTreeChilds", "toggleTreeExpand", "setAllTreeExpand", "setTreeExpand", "isTreeExpandByRow", "clearTreeExpand", "clearTreeExpandReserve", "getScroll", "scrollTo", "scrollToRow", "scrollToColumn", "clearScroll", "updateFooter", "updateStatus", "setMergeCells", "removeInsertRow", "removeMergeCells", "getMergeCells", "clearMergeCells", "setMergeFooterItems", "removeMergeFooterItems", "getMergeFooterItems", "clearMergeFooterItems", "getCustomStoreData", "openTooltip", "getCellLabel", "getCellElement", "focus", "blur", "connect"];
var gridComponentEmits = [
  ...emits_default,
  "page-change",
  "form-submit",
  "form-submit-invalid",
  "form-reset",
  "form-collapse",
  "form-toggle-collapse",
  "proxy-query",
  "proxy-delete",
  "proxy-save",
  "toolbar-button-click",
  "toolbar-tool-click",
  "zoom"
];
var grid_default = defineComponent({
  name: "VxeGrid",
  props: Object.assign(Object.assign({}, props_default), { layouts: Array, columns: Array, pagerConfig: Object, proxyConfig: Object, toolbarConfig: Object, formConfig: Object, zoomConfig: Object, size: {
    type: String,
    default: () => getConfig9().grid.size || getConfig9().size
  } }),
  emits: gridComponentEmits,
  setup(props, context) {
    var _a2;
    const { slots, emit } = context;
    const xID = import_xe_utils38.default.uniqueId();
    const VxeUIFormComponent = VxeUI.getComponent("VxeForm");
    const VxeUIPagerComponent = VxeUI.getComponent("VxePager");
    const { computeSize } = useFns4.useSize(props);
    const reactData = reactive({
      tableLoading: false,
      proxyInited: false,
      isZMax: false,
      tableData: [],
      filterData: [],
      formData: {},
      sortData: [],
      tZindex: 0,
      tablePage: {
        total: 0,
        pageSize: ((_a2 = getConfig9().pager) === null || _a2 === void 0 ? void 0 : _a2.pageSize) || 10,
        currentPage: 1
      }
    });
    const refElem = ref();
    const refTable = ref();
    const refForm = ref();
    const refToolbar = ref();
    const refPager = ref();
    const refFormWrapper = ref();
    const refToolbarWrapper = ref();
    const refTopWrapper = ref();
    const refBottomWrapper = ref();
    const refPagerWrapper = ref();
    const extendTableMethods = (methodKeys) => {
      const funcs = {};
      methodKeys.forEach((name) => {
        funcs[name] = (...args) => {
          const $xeTable = refTable.value;
          if ($xeTable && $xeTable[name]) {
            return $xeTable[name](...args);
          }
        };
      });
      return funcs;
    };
    const gridExtendTableMethods = extendTableMethods(tableComponentMethodKeys);
    tableComponentMethodKeys.forEach((name) => {
      gridExtendTableMethods[name] = (...args) => {
        const $xeTable = refTable.value;
        if ($xeTable && $xeTable[name]) {
          return $xeTable && $xeTable[name](...args);
        }
      };
    });
    const computeProxyOpts = computed(() => {
      return import_xe_utils38.default.merge({}, import_xe_utils38.default.clone(getConfig9().grid.proxyConfig, true), props.proxyConfig);
    });
    const computeIsRespMsg = computed(() => {
      const proxyOpts = computeProxyOpts.value;
      return import_xe_utils38.default.isBoolean(proxyOpts.message) ? proxyOpts.message : proxyOpts.showResponseMsg;
    });
    const computeIsActiveMsg = computed(() => {
      const proxyOpts = computeProxyOpts.value;
      return proxyOpts.showActiveMsg;
    });
    const computePagerOpts = computed(() => {
      return Object.assign({}, getConfig9().grid.pagerConfig, props.pagerConfig);
    });
    const computeFormOpts = computed(() => {
      return Object.assign({}, getConfig9().grid.formConfig, props.formConfig);
    });
    const computeToolbarOpts = computed(() => {
      return Object.assign({}, getConfig9().grid.toolbarConfig, props.toolbarConfig);
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, getConfig9().grid.zoomConfig, props.zoomConfig);
    });
    const computeStyles = computed(() => {
      return reactData.isZMax ? { zIndex: reactData.tZindex } : null;
    });
    const computeTableExtendProps = computed(() => {
      const rest = {};
      const gridProps = props;
      tableComponentPropKeys.forEach((key) => {
        rest[key] = gridProps[key];
      });
      return rest;
    });
    const computeTableProps = computed(() => {
      const { seqConfig, pagerConfig, loading: loading2, editConfig, proxyConfig } = props;
      const { isZMax, tableLoading, tablePage, tableData } = reactData;
      const tableExtendProps = computeTableExtendProps.value;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      const tableProps = Object.assign({}, tableExtendProps);
      if (isZMax) {
        if (tableExtendProps.maxHeight) {
          tableProps.maxHeight = "100%";
        } else {
          tableProps.height = "100%";
        }
      }
      if (proxyConfig && isEnableConf(proxyOpts)) {
        tableProps.loading = loading2 || tableLoading;
        tableProps.data = tableData;
        if (pagerConfig && proxyOpts.seq && isEnableConf(pagerOpts)) {
          tableProps.seqConfig = Object.assign({}, seqConfig, { startIndex: (tablePage.currentPage - 1) * tablePage.pageSize });
        }
      }
      if (editConfig) {
        tableProps.editConfig = Object.assign({}, editConfig);
      }
      return tableProps;
    });
    const computeCurrLayout = computed(() => {
      const { layouts } = props;
      if (layouts && layouts.length) {
        return layouts;
      }
      return getConfig9().grid.layouts || ["Form", "Toolbar", "Top", "Table", "Bottom", "Pager"];
    });
    const computePageConfFlag = computed(() => {
      const pagerOpts = computePagerOpts.value;
      return `${pagerOpts.currentPage}${pagerOpts.pageSize}`;
    });
    const refMaps = {
      refElem,
      refTable,
      refForm,
      refToolbar,
      refPager
    };
    const computeMaps = {
      computeProxyOpts,
      computePagerOpts,
      computeFormOpts,
      computeToolbarOpts,
      computeZoomOpts
    };
    const $xeGrid = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const initToolbar = () => {
      const toolbarOpts = computeToolbarOpts.value;
      if (props.toolbarConfig && isEnableConf(toolbarOpts)) {
        nextTick(() => {
          const $xeTable = refTable.value;
          const $xeToolbar = refToolbar.value;
          if ($xeTable && $xeToolbar) {
            $xeTable.connect($xeToolbar);
          }
        });
      }
    };
    const getFormData = () => {
      const { proxyConfig } = props;
      const { formData } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      return proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data;
    };
    const initPages = () => {
      const { tablePage } = reactData;
      const { pagerConfig } = props;
      const pagerOpts = computePagerOpts.value;
      const { currentPage, pageSize } = pagerOpts;
      if (pagerConfig && isEnableConf(pagerOpts)) {
        if (currentPage) {
          tablePage.currentPage = currentPage;
        }
        if (pageSize) {
          tablePage.pageSize = pageSize;
        }
      }
    };
    const triggerPendingEvent = (code3) => {
      const isActiveMsg = computeIsActiveMsg.value;
      const $xeTable = refTable.value;
      const selectRecords = $xeTable.getCheckboxRecords();
      if (selectRecords.length) {
        $xeTable.togglePendingRow(selectRecords);
        gridExtendTableMethods.clearCheckboxRow();
      } else {
        if (isActiveMsg) {
          if (VxeUI.modal) {
            VxeUI.modal.message({ id: code3, content: getI18n15("vxe.grid.selectOneRecord"), status: "warning" });
          }
        }
      }
    };
    const getRespMsg = (rest, defaultMsg) => {
      const proxyOpts = computeProxyOpts.value;
      const resConfigs = proxyOpts.response || proxyOpts.props || {};
      const messageProp = resConfigs.message;
      let msg;
      if (rest && messageProp) {
        msg = import_xe_utils38.default.isFunction(messageProp) ? messageProp({ data: rest, $grid: $xeGrid }) : import_xe_utils38.default.get(rest, messageProp);
      }
      return msg || getI18n15(defaultMsg);
    };
    const handleDeleteRow = (code3, alertKey, callback) => {
      const isActiveMsg = computeIsActiveMsg.value;
      const selectRecords = gridExtendTableMethods.getCheckboxRecords();
      if (isActiveMsg) {
        if (selectRecords.length) {
          if (VxeUI.modal) {
            return VxeUI.modal.confirm({ id: `cfm_${code3}`, content: getI18n15(alertKey), escClosable: true }).then((type) => {
              if (type === "confirm") {
                return callback();
              }
            });
          }
        } else {
          if (VxeUI.modal) {
            VxeUI.modal.message({ id: `msg_${code3}`, content: getI18n15("vxe.grid.selectOneRecord"), status: "warning" });
          }
        }
      } else {
        if (selectRecords.length) {
          callback();
        }
      }
      return Promise.resolve();
    };
    const pageChangeEvent = (params) => {
      const { proxyConfig } = props;
      const { tablePage } = reactData;
      const { $event, currentPage, pageSize } = params;
      const proxyOpts = computeProxyOpts.value;
      tablePage.currentPage = currentPage;
      tablePage.pageSize = pageSize;
      gridMethods.dispatchEvent("page-change", params, $event);
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("query").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", rest, $event);
        });
      }
    };
    const sortChangeEvent = (params) => {
      const $xeTable = refTable.value;
      const { proxyConfig } = props;
      const { computeSortOpts } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const sortOpts = computeSortOpts.value;
      if (sortOpts.remote) {
        reactData.sortData = params.sortList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("sort-change", params, params.$event);
    };
    const filterChangeEvent = (params) => {
      const $xeTable = refTable.value;
      const { proxyConfig } = props;
      const { computeFilterOpts } = $xeTable.getComputeMaps();
      const proxyOpts = computeProxyOpts.value;
      const filterOpts = computeFilterOpts.value;
      if (filterOpts.remote) {
        reactData.filterData = params.filterList;
        if (proxyConfig && isEnableConf(proxyOpts)) {
          reactData.tablePage.currentPage = 1;
          gridMethods.commitProxy("query").then((rest) => {
            gridMethods.dispatchEvent("proxy-query", rest, params.$event);
          });
        }
      }
      gridMethods.dispatchEvent("filter-change", params, params.$event);
    };
    const submitFormEvent = (params) => {
      const { proxyConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), params.$event);
        });
      }
      gridMethods.dispatchEvent("form-submit", params, params.$event);
    };
    const resetFormEvent = (params) => {
      const { proxyConfig } = props;
      const { $event } = params;
      const proxyOpts = computeProxyOpts.value;
      const $xeTable = refTable.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        $xeTable.clearScroll();
        gridMethods.commitProxy("reload").then((rest) => {
          gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isReload: true }), $event);
        });
      }
      gridMethods.dispatchEvent("form-reset", params, $event);
    };
    const submitInvalidEvent = (params) => {
      gridMethods.dispatchEvent("form-submit-invalid", params, params.$event);
    };
    const collapseEvent = (params) => {
      const { $event } = params;
      nextTick(() => gridExtendTableMethods.recalculate(true));
      gridMethods.dispatchEvent("form-toggle-collapse", params, $event);
      gridMethods.dispatchEvent("form-collapse", params, $event);
    };
    const handleZoom = (isMax) => {
      const { isZMax } = reactData;
      if (isMax ? !isZMax : isZMax) {
        reactData.isZMax = !isZMax;
        if (reactData.tZindex < getLastZIndex()) {
          reactData.tZindex = nextZIndex();
        }
      }
      return nextTick().then(() => gridExtendTableMethods.recalculate(true)).then(() => reactData.isZMax);
    };
    const getFuncSlot = (optSlots, slotKey) => {
      const funcSlot = optSlots[slotKey];
      if (funcSlot) {
        if (import_xe_utils38.default.isString(funcSlot)) {
          if (slots[funcSlot]) {
            return slots[funcSlot];
          } else {
            if (true) {
              errLog("vxe.error.notSlot", [funcSlot]);
            }
          }
        } else {
          return funcSlot;
        }
      }
      return null;
    };
    const renderForm = () => {
      const { formConfig, proxyConfig } = props;
      const { formData } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (formConfig && isEnableConf(formOpts) || slots.form) {
        let slotVNs = [];
        if (slots.form) {
          slotVNs = slots.form({ $grid: $xeGrid });
        } else {
          if (formOpts.items) {
            const formSlots = {};
            if (!formOpts.inited) {
              formOpts.inited = true;
              const beforeItem = proxyOpts.beforeItem;
              if (proxyOpts && beforeItem) {
                formOpts.items.forEach((item) => {
                  beforeItem({ $grid: $xeGrid, item });
                });
              }
            }
            formOpts.items.forEach((item) => {
              import_xe_utils38.default.each(item.slots, (func) => {
                if (!import_xe_utils38.default.isFunction(func)) {
                  if (slots[func]) {
                    formSlots[func] = slots[func];
                  }
                }
              });
            });
            if (VxeUIFormComponent) {
              slotVNs.push(h(VxeUIFormComponent, Object.assign(Object.assign({ ref: refForm }, Object.assign({}, formOpts, {
                data: proxyConfig && isEnableConf(proxyOpts) && proxyOpts.form ? formData : formOpts.data
              })), { onSubmit: submitFormEvent, onReset: resetFormEvent, onSubmitInvalid: submitInvalidEvent, onCollapse: collapseEvent }), formSlots));
            }
          }
        }
        return h("div", {
          ref: refFormWrapper,
          key: "form",
          class: "vxe-grid--form-wrapper"
        }, slotVNs);
      }
      return createCommentVNode();
    };
    const renderToolbar = () => {
      const { toolbarConfig } = props;
      const toolbarOpts = computeToolbarOpts.value;
      if (toolbarConfig && isEnableConf(toolbarOpts) || slots.toolbar) {
        let slotVNs = [];
        if (slots.toolbar) {
          slotVNs = slots.toolbar({ $grid: $xeGrid });
        } else {
          const toolbarOptSlots = toolbarOpts.slots;
          let buttonsSlot;
          let toolsSlot;
          const toolbarSlots = {};
          if (toolbarOptSlots) {
            buttonsSlot = getFuncSlot(toolbarOptSlots, "buttons");
            toolsSlot = getFuncSlot(toolbarOptSlots, "tools");
            if (buttonsSlot) {
              toolbarSlots.buttons = buttonsSlot;
            }
            if (toolsSlot) {
              toolbarSlots.tools = toolsSlot;
            }
          }
          slotVNs.push(h(toolbar_default2, Object.assign({ ref: refToolbar }, toolbarOpts), toolbarSlots));
        }
        return h("div", {
          ref: refToolbarWrapper,
          key: "toolbar",
          class: "vxe-grid--toolbar-wrapper"
        }, slotVNs);
      }
      return createCommentVNode();
    };
    const renderTop = () => {
      if (slots.top) {
        return h("div", {
          ref: refTopWrapper,
          key: "top",
          class: "vxe-grid--top-wrapper"
        }, slots.top({ $grid: $xeGrid }));
      }
      return createCommentVNode();
    };
    const renderTableLeft = () => {
      const leftSlot = slots.left;
      if (leftSlot) {
        return h("div", {
          class: "vxe-grid--left-wrapper"
        }, leftSlot({ $grid: $xeGrid }));
      }
      return createCommentVNode();
    };
    const renderTableRight = () => {
      const rightSlot = slots.right;
      if (rightSlot) {
        return h("div", {
          class: "vxe-grid--right-wrapper"
        }, rightSlot({ $grid: $xeGrid }));
      }
      return createCommentVNode();
    };
    const renderTable = () => {
      const { proxyConfig } = props;
      const tableProps = computeTableProps.value;
      const proxyOpts = computeProxyOpts.value;
      const tableOns = Object.assign({}, tableCompEvents);
      const emptySlot = slots.empty;
      const loadingSlot = slots.loading;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (proxyOpts.sort) {
          tableOns.onSortChange = sortChangeEvent;
        }
        if (proxyOpts.filter) {
          tableOns.onFilterChange = filterChangeEvent;
        }
      }
      const slotObj = {};
      if (emptySlot) {
        slotObj.empty = () => emptySlot({ $grid: $xeGrid });
      }
      if (loadingSlot) {
        slotObj.loading = () => loadingSlot({ $grid: $xeGrid });
      }
      return h("div", {
        class: "vxe-grid--table-wrapper"
      }, [
        h(table_default2, Object.assign(Object.assign({ ref: refTable }, tableProps), tableOns), slotObj)
      ]);
    };
    const renderBottom = () => {
      if (slots.bottom) {
        return h("div", {
          ref: refBottomWrapper,
          key: "bottom",
          class: "vxe-grid--bottom-wrapper"
        }, slots.bottom({ $grid: $xeGrid }));
      }
      return createCommentVNode();
    };
    const renderPager = () => {
      const { proxyConfig, pagerConfig } = props;
      const proxyOpts = computeProxyOpts.value;
      const pagerOpts = computePagerOpts.value;
      if (pagerConfig && isEnableConf(pagerOpts) || slots.pager) {
        let slotVNs = [];
        if (slots.pager) {
          slotVNs = slots.pager({ $grid: $xeGrid });
        } else {
          const pagerOptSlots = pagerOpts.slots;
          const pagerSlots = {};
          let leftSlot;
          let rightSlot;
          if (pagerOptSlots) {
            leftSlot = getFuncSlot(pagerOptSlots, "left");
            rightSlot = getFuncSlot(pagerOptSlots, "right");
            if (leftSlot) {
              pagerSlots.left = leftSlot;
            }
            if (rightSlot) {
              pagerSlots.right = rightSlot;
            }
          }
          if (VxeUIPagerComponent) {
            slotVNs.push(h(VxeUIPagerComponent, Object.assign(Object.assign(Object.assign({ ref: refPager }, pagerOpts), proxyConfig && isEnableConf(proxyOpts) ? reactData.tablePage : {}), { onPageChange: pageChangeEvent }), pagerSlots));
          }
        }
        return h("div", {
          ref: refPagerWrapper,
          key: "pager",
          class: "vxe-grid--pager-wrapper"
        }, slotVNs);
      }
      return createCommentVNode();
    };
    const renderLayout = () => {
      const vns = [];
      const currLayouts = computeCurrLayout.value;
      currLayouts.forEach((name) => {
        switch (name) {
          case "Form":
            vns.push(renderForm());
            break;
          case "Toolbar":
            vns.push(renderToolbar());
            break;
          case "Top":
            vns.push(renderTop());
            break;
          case "Table":
            vns.push(h("div", {
              key: "table",
              class: "vxe-grid--table-container"
            }, [
              renderTableLeft(),
              renderTable(),
              renderTableRight()
            ]));
            break;
          case "Bottom":
            vns.push(renderBottom());
            break;
          case "Pager":
            vns.push(renderPager());
            break;
          default:
            if (true) {
              errLog("vxe.error.notProp", [`layouts -> ${name}`]);
            }
            break;
        }
      });
      return vns;
    };
    const tableCompEvents = {};
    emits_default.forEach((name) => {
      const type = import_xe_utils38.default.camelCase(`on-${name}`);
      tableCompEvents[type] = (...args) => emit(name, ...args);
    });
    const initProxy = () => {
      const { proxyConfig, formConfig } = props;
      const { proxyInited } = reactData;
      const proxyOpts = computeProxyOpts.value;
      const formOpts = computeFormOpts.value;
      if (proxyConfig && isEnableConf(proxyOpts)) {
        if (formConfig && isEnableConf(formOpts) && proxyOpts.form && formOpts.items) {
          const fData = {};
          formOpts.items.forEach((item) => {
            const { field, itemRender } = item;
            if (field) {
              let itemValue = null;
              if (itemRender) {
                const { defaultValue } = itemRender;
                if (import_xe_utils38.default.isFunction(defaultValue)) {
                  itemValue = defaultValue({ item });
                } else if (!import_xe_utils38.default.isUndefined(defaultValue)) {
                  itemValue = defaultValue;
                }
              }
              fData[field] = itemValue;
            }
          });
          reactData.formData = fData;
        }
        if (!proxyInited) {
          reactData.proxyInited = true;
          if (proxyOpts.autoLoad !== false) {
            nextTick().then(() => gridMethods.commitProxy("_init")).then((rest) => {
              gridMethods.dispatchEvent("proxy-query", Object.assign(Object.assign({}, rest), { isInited: true }), new Event("init"));
            });
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const zoomOpts = computeZoomOpts.value;
      const isEsc = globalEvents5.hasKey(evnt, GLOBAL_EVENT_KEYS4.ESCAPE);
      if (isEsc && reactData.isZMax && zoomOpts.escRestore !== false) {
        gridPrivateMethods.triggerZoomEvent(evnt);
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent4(evnt, { $grid: $xeGrid }, params));
    };
    const gridMethods = {
      dispatchEvent: dispatchEvent2,
      /**
       * 提交指令，支持 code 或 button
       * @param {String/Object} code 字符串或对象
       */
      commitProxy(proxyTarget, ...args) {
        const { toolbarConfig, pagerConfig, editRules, validConfig } = props;
        const { tablePage } = reactData;
        const isActiveMsg = computeIsActiveMsg.value;
        const isRespMsg = computeIsRespMsg.value;
        const proxyOpts = computeProxyOpts.value;
        const pagerOpts = computePagerOpts.value;
        const toolbarOpts = computeToolbarOpts.value;
        const { beforeQuery, afterQuery, beforeDelete, afterDelete, beforeSave, afterSave, ajax = {} } = proxyOpts;
        const resConfigs = proxyOpts.response || proxyOpts.props || {};
        const $xeTable = refTable.value;
        const formData = getFormData();
        let button = null;
        let code3 = null;
        if (import_xe_utils38.default.isString(proxyTarget)) {
          const { buttons } = toolbarOpts;
          const matchObj = toolbarConfig && isEnableConf(toolbarOpts) && buttons ? import_xe_utils38.default.findTree(buttons, (item) => item.code === proxyTarget, { children: "dropdowns" }) : null;
          button = matchObj ? matchObj.item : null;
          code3 = proxyTarget;
        } else {
          button = proxyTarget;
          code3 = button.code;
        }
        const btnParams = button ? button.params : null;
        switch (code3) {
          case "insert":
            return $xeTable.insert({});
          case "insert_edit":
            return $xeTable.insert({}).then(({ row }) => $xeTable.setEditRow(row));
          case "insert_actived":
            return $xeTable.insert({}).then(({ row }) => $xeTable.setEditRow(row));
          case "mark_cancel":
            triggerPendingEvent(code3);
            break;
          case "remove":
            return handleDeleteRow(code3, "vxe.grid.removeSelectRecord", () => $xeTable.removeCheckboxRow());
          case "import":
            $xeTable.importData(btnParams);
            break;
          case "open_import":
            $xeTable.openImport(btnParams);
            break;
          case "export":
            $xeTable.exportData(btnParams);
            break;
          case "open_export":
            $xeTable.openExport(btnParams);
            break;
          case "reset_custom":
            return $xeTable.resetCustom(true);
          case "_init":
          case "reload":
          case "query": {
            const ajaxMethods = ajax.query;
            const querySuccessMethods = ajax.querySuccess;
            const queryErrorMethods = ajax.queryError;
            if (ajaxMethods) {
              const isInited = code3 === "_init";
              const isReload = code3 === "reload";
              let sortList = [];
              let filterList = [];
              let pageParams = {};
              if (pagerConfig) {
                if (isInited || isReload) {
                  tablePage.currentPage = 1;
                }
                if (isEnableConf(pagerOpts)) {
                  pageParams = Object.assign({}, tablePage);
                }
              }
              if (isInited) {
                let defaultSort = null;
                if ($xeTable) {
                  const { computeSortOpts } = $xeTable.getComputeMaps();
                  const sortOpts = computeSortOpts.value;
                  defaultSort = sortOpts.defaultSort;
                }
                if (defaultSort) {
                  if (!import_xe_utils38.default.isArray(defaultSort)) {
                    defaultSort = [defaultSort];
                  }
                  sortList = defaultSort.map((item) => {
                    return {
                      field: item.field,
                      property: item.field,
                      order: item.order
                    };
                  });
                }
                if ($xeTable) {
                  filterList = $xeTable.getCheckedFilters();
                }
              } else {
                if ($xeTable) {
                  if (isReload) {
                    $xeTable.clearAll();
                  } else {
                    sortList = $xeTable.getSortColumns();
                    filterList = $xeTable.getCheckedFilters();
                  }
                }
              }
              const commitParams = {
                code: code3,
                button,
                isInited,
                isReload,
                $grid: $xeGrid,
                page: pageParams,
                sort: sortList.length ? sortList[0] : {},
                sorts: sortList,
                filters: filterList,
                form: formData,
                options: ajaxMethods
              };
              reactData.sortData = sortList;
              reactData.filterData = filterList;
              reactData.tableLoading = true;
              return Promise.resolve((beforeQuery || ajaxMethods)(commitParams, ...args)).then((rest) => {
                reactData.tableLoading = false;
                if (rest) {
                  if (pagerConfig && isEnableConf(pagerOpts)) {
                    const totalProp = resConfigs.total;
                    const total = (import_xe_utils38.default.isFunction(totalProp) ? totalProp({ data: rest, $grid: $xeGrid }) : import_xe_utils38.default.get(rest, totalProp || "page.total")) || 0;
                    tablePage.total = import_xe_utils38.default.toNumber(total);
                    const resultProp = resConfigs.result;
                    reactData.tableData = (import_xe_utils38.default.isFunction(resultProp) ? resultProp({ data: rest, $grid: $xeGrid }) : import_xe_utils38.default.get(rest, resultProp || "result")) || [];
                    const pageCount = Math.max(Math.ceil(total / tablePage.pageSize), 1);
                    if (tablePage.currentPage > pageCount) {
                      tablePage.currentPage = pageCount;
                    }
                  } else {
                    const listProp = resConfigs.list;
                    reactData.tableData = (listProp ? import_xe_utils38.default.isFunction(listProp) ? listProp({ data: rest, $grid: $xeGrid }) : import_xe_utils38.default.get(rest, listProp) : rest) || [];
                  }
                } else {
                  reactData.tableData = [];
                }
                if (afterQuery) {
                  afterQuery(commitParams, ...args);
                }
                if (querySuccessMethods) {
                  querySuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                }
                return { status: true };
              }).catch((rest) => {
                reactData.tableLoading = false;
                if (queryErrorMethods) {
                  queryErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                }
                return { status: false };
              });
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.query"]);
              }
            }
            break;
          }
          case "delete": {
            const ajaxMethods = ajax.delete;
            const deleteSuccessMethods = ajax.deleteSuccess;
            const deleteErrorMethods = ajax.deleteError;
            if (ajaxMethods) {
              const selectRecords = gridExtendTableMethods.getCheckboxRecords();
              const removeRecords = selectRecords.filter((row) => !$xeTable.isInsertByRow(row));
              const body = { removeRecords };
              const commitParams = { $grid: $xeGrid, code: code3, button, body, form: formData, options: ajaxMethods };
              if (selectRecords.length) {
                return handleDeleteRow(code3, "vxe.grid.deleteSelectRecord", () => {
                  if (!removeRecords.length) {
                    return $xeTable.remove(selectRecords);
                  }
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeDelete || ajaxMethods)(commitParams, ...args)).then((rest) => {
                    reactData.tableLoading = false;
                    $xeTable.setPendingRow(removeRecords, false);
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ content: getRespMsg(rest, "vxe.grid.delSuccess"), status: "success" });
                      }
                    }
                    if (afterDelete) {
                      afterDelete(commitParams, ...args);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    if (deleteSuccessMethods) {
                      deleteSuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ id: code3, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                      }
                    }
                    if (deleteErrorMethods) {
                      deleteErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: false };
                  });
                });
              } else {
                if (isActiveMsg) {
                  if (VxeUI.modal) {
                    VxeUI.modal.message({ id: code3, content: getI18n15("vxe.grid.selectOneRecord"), status: "warning" });
                  }
                }
              }
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.delete"]);
              }
            }
            break;
          }
          case "save": {
            const ajaxMethods = ajax.save;
            const saveSuccessMethods = ajax.saveSuccess;
            const saveErrorMethods = ajax.saveError;
            if (ajaxMethods) {
              const body = $xeTable.getRecordset();
              const { insertRecords, removeRecords, updateRecords, pendingRecords } = body;
              const commitParams = { $grid: $xeGrid, code: code3, button, body, form: formData, options: ajaxMethods };
              if (insertRecords.length) {
                body.pendingRecords = pendingRecords.filter((row) => $xeTable.findRowIndexOf(insertRecords, row) === -1);
              }
              if (pendingRecords.length) {
                body.insertRecords = insertRecords.filter((row) => $xeTable.findRowIndexOf(pendingRecords, row) === -1);
              }
              let restPromise = Promise.resolve();
              if (editRules) {
                restPromise = $xeTable[validConfig && validConfig.msgMode === "full" ? "fullValidate" : "validate"](body.insertRecords.concat(updateRecords));
              }
              return restPromise.then((errMap) => {
                if (errMap) {
                  return;
                }
                if (body.insertRecords.length || removeRecords.length || updateRecords.length || body.pendingRecords.length) {
                  reactData.tableLoading = true;
                  return Promise.resolve((beforeSave || ajaxMethods)(commitParams, ...args)).then((rest) => {
                    reactData.tableLoading = false;
                    $xeTable.clearPendingRow();
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ content: getRespMsg(rest, "vxe.grid.saveSuccess"), status: "success" });
                      }
                    }
                    if (afterSave) {
                      afterSave(commitParams, ...args);
                    } else {
                      gridMethods.commitProxy("query");
                    }
                    if (saveSuccessMethods) {
                      saveSuccessMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: true };
                  }).catch((rest) => {
                    reactData.tableLoading = false;
                    if (isRespMsg) {
                      if (VxeUI.modal) {
                        VxeUI.modal.message({ id: code3, content: getRespMsg(rest, "vxe.grid.operError"), status: "error" });
                      }
                    }
                    if (saveErrorMethods) {
                      saveErrorMethods(Object.assign(Object.assign({}, commitParams), { response: rest }));
                    }
                    return { status: false };
                  });
                } else {
                  if (isActiveMsg) {
                    if (VxeUI.modal) {
                      VxeUI.modal.message({ id: code3, content: getI18n15("vxe.grid.dataUnchanged"), status: "info" });
                    }
                  }
                }
              });
            } else {
              if (true) {
                errLog("vxe.error.notFunc", ["proxy-config.ajax.save"]);
              }
            }
            break;
          }
          default: {
            const gCommandOpts = commands4.get(code3);
            if (gCommandOpts) {
              const tCommandMethod = gCommandOpts.tableCommandMethod || gCommandOpts.commandMethod;
              if (tCommandMethod) {
                tCommandMethod({ code: code3, button, $grid: $xeGrid, $table: $xeTable }, ...args);
              } else {
                if (true) {
                  errLog("vxe.error.notCommands", [code3]);
                }
              }
            }
          }
        }
        return nextTick();
      },
      zoom() {
        if (reactData.isZMax) {
          return gridMethods.revert();
        }
        return gridMethods.maximize();
      },
      isMaximized() {
        return reactData.isZMax;
      },
      maximize() {
        return handleZoom(true);
      },
      revert() {
        return handleZoom();
      },
      getFormData,
      getFormItems(itemIndex) {
        const formOpts = computeFormOpts.value;
        const { formConfig } = props;
        const { items } = formOpts;
        const itemList = [];
        import_xe_utils38.default.eachTree(formConfig && isEnableConf(formOpts) && items ? items : [], (item) => {
          itemList.push(item);
        }, { children: "children" });
        return import_xe_utils38.default.isUndefined(itemIndex) ? itemList : itemList[itemIndex];
      },
      getProxyInfo() {
        const $xeTable = refTable.value;
        if (props.proxyConfig) {
          const { sortData } = reactData;
          return {
            data: reactData.tableData,
            filter: reactData.filterData,
            form: getFormData(),
            sort: sortData.length ? sortData[0] : {},
            sorts: sortData,
            pager: reactData.tablePage,
            pendingRecords: $xeTable ? $xeTable.getPendingRecords() : []
          };
        }
        return null;
      }
      // setProxyInfo (options) {
      //   if (props.proxyConfig && options) {
      //     const { pager, form } = options
      //     const proxyOpts = computeProxyOpts.value
      //     if (pager) {
      //       if (pager.currentPage) {
      //         reactData.tablePage.currentPage = Number(pager.currentPage)
      //       }
      //       if (pager.pageSize) {
      //         reactData.tablePage.pageSize = Number(pager.pageSize)
      //       }
      //     }
      //     if (proxyOpts.form && form) {
      //       Object.assign(reactData.formData, form)
      //     }
      //   }
      //   return nextTick()
      // }
    };
    if (true) {
      gridMethods.loadColumn = (columns) => {
        const $xeTable = refTable.value;
        import_xe_utils38.default.eachTree(columns, (column) => {
          if (column.slots) {
            import_xe_utils38.default.each(column.slots, (func) => {
              if (!import_xe_utils38.default.isFunction(func)) {
                if (!slots[func]) {
                  errLog("vxe.error.notSlot", [func]);
                }
              }
            });
          }
        });
        if ($xeTable) {
          return $xeTable.loadColumn(columns);
        }
        return nextTick();
      };
      gridMethods.reloadColumn = (columns) => {
        gridExtendTableMethods.clearAll();
        return gridMethods.loadColumn(columns);
      };
    }
    const gridPrivateMethods = {
      extendTableMethods,
      callSlot(slotFunc, params) {
        if (slotFunc) {
          if (import_xe_utils38.default.isString(slotFunc)) {
            slotFunc = slots[slotFunc] || null;
          }
          if (import_xe_utils38.default.isFunction(slotFunc)) {
            return getSlotVNs(slotFunc(params));
          }
        }
        return [];
      },
      /**
       * 获取需要排除的高度
       */
      getExcludeHeight() {
        const { height } = props;
        const { isZMax } = reactData;
        const el2 = refElem.value;
        const formWrapper = refFormWrapper.value;
        const toolbarWrapper = refToolbarWrapper.value;
        const topWrapper = refTopWrapper.value;
        const bottomWrapper = refBottomWrapper.value;
        const pagerWrapper = refPagerWrapper.value;
        const parentPaddingSize = isZMax || !(height === "auto" || height === "100%") ? 0 : getPaddingTopBottomSize(el2.parentNode);
        return parentPaddingSize + getPaddingTopBottomSize(el2) + getOffsetHeight(formWrapper) + getOffsetHeight(toolbarWrapper) + getOffsetHeight(topWrapper) + getOffsetHeight(bottomWrapper) + getOffsetHeight(pagerWrapper);
      },
      getParentHeight() {
        const el2 = refElem.value;
        if (el2) {
          return (reactData.isZMax ? getDomNode().visibleHeight : import_xe_utils38.default.toNumber(getComputedStyle(el2.parentNode).height)) - gridPrivateMethods.getExcludeHeight();
        }
        return 0;
      },
      triggerToolbarCommitEvent(params, evnt) {
        const { code: code3 } = params;
        return gridMethods.commitProxy(params, evnt).then((rest) => {
          if (code3 && rest && rest.status && ["query", "reload", "delete", "save"].includes(code3)) {
            gridMethods.dispatchEvent(code3 === "delete" || code3 === "save" ? `proxy-${code3}` : "proxy-query", Object.assign(Object.assign({}, rest), { isReload: code3 === "reload" }), evnt);
          }
        });
      },
      triggerToolbarBtnEvent(button, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(button, evnt);
        gridMethods.dispatchEvent("toolbar-button-click", { code: button.code, button }, evnt);
      },
      triggerToolbarTolEvent(tool, evnt) {
        gridPrivateMethods.triggerToolbarCommitEvent(tool, evnt);
        gridMethods.dispatchEvent("toolbar-tool-click", { code: tool.code, tool }, evnt);
      },
      triggerZoomEvent(evnt) {
        gridMethods.zoom();
        gridMethods.dispatchEvent("zoom", { type: reactData.isZMax ? "max" : "revert" }, evnt);
      }
    };
    Object.assign($xeGrid, gridExtendTableMethods, gridMethods, gridPrivateMethods);
    const columnFlag = ref(0);
    watch(() => props.columns ? props.columns.length : -1, () => {
      columnFlag.value++;
    });
    watch(() => props.columns, () => {
      columnFlag.value++;
    });
    watch(columnFlag, () => {
      nextTick(() => $xeGrid.loadColumn(props.columns || []));
    });
    watch(() => props.toolbarConfig, () => {
      initToolbar();
    });
    watch(computePageConfFlag, () => {
      initPages();
    });
    watch(() => props.proxyConfig, () => {
      initProxy();
    });
    hooks10.forEach((options) => {
      const { setupGrid } = options;
      if (setupGrid) {
        const hookRest = setupGrid($xeGrid);
        if (hookRest && import_xe_utils38.default.isObject(hookRest)) {
          Object.assign($xeGrid, hookRest);
        }
      }
    });
    initPages();
    onMounted(() => {
      if (true) {
        nextTick(() => {
          if (props.formConfig) {
            if (!VxeUIFormComponent) {
              errLog("vxe.error.reqComp", ["vxe-form"]);
            }
          }
          if (props.pagerConfig) {
            if (!VxeUIPagerComponent) {
              errLog("vxe.error.reqComp", ["vxe-pager"]);
            }
          }
        });
      }
      nextTick(() => {
        const { columns } = props;
        if (columns && columns.length) {
          $xeGrid.loadColumn(columns);
        }
        initToolbar();
        initProxy();
      });
      globalEvents5.on($xeGrid, "keydown", handleGlobalKeydownEvent);
    });
    onUnmounted(() => {
      globalEvents5.off($xeGrid, "keydown");
    });
    const renderVN = () => {
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-grid", {
          [`size--${vSize}`]: vSize,
          "is--animat": !!props.animat,
          "is--round": props.round,
          "is--maximize": reactData.isZMax,
          "is--loading": props.loading || reactData.tableLoading
        }],
        style: styles
      }, renderLayout());
    };
    $xeGrid.renderVN = renderVN;
    provide("$xeGrid", $xeGrid);
    return $xeGrid;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-table/es/grid/index.js
var VxeGrid = Object.assign({}, grid_default, {
  install(app) {
    app.component(grid_default.name, grid_default);
  }
});
if (VxeUI.dynamicApp) {
  VxeUI.dynamicApp.component(grid_default.name, grid_default);
}
VxeUI.component(grid_default);
var Grid = VxeGrid;

// node_modules/vxe-table/es/locale/lang/zh-CN.js
var zh_CN_default = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      downErr: "下载失败",
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入",
      treeCrossDrag: "只能拖拽第一层级",
      treeDragChild: "父级不能拖拽到自己的子级中",
      reqPlugin: '可选扩展插件 "{1}" https://vxeui.com/other{0}/#/{1}/install'
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expError: "导出失败",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customClose: "关闭",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个",
      dragTip: "移动：{0}"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "列标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开层级",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个",
      footPropErr: "show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      uploadTypeErr: "文件类型不匹配！",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看",
      morePopup: {
        readTitle: "查看列表",
        imageTitle: "上传图片",
        fileTitle: "上传文件"
      }
    },
    empty: {
      defText: "暂无数据"
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片",
          VxeRate: "评分",
          VxeSlider: "滑块"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件",
          colPlace: "将控件拖拽进来"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件",
        editPopupTitle: "编辑查询字段"
      },
      searchPopup: {
        colTitle: "标题",
        saveBtn: "保存"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    countdown: {
      formats: {
        yyyy: "年",
        MM: "月",
        dd: "天",
        HH: "时",
        mm: "分",
        ss: "秒"
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          selectErr: "无法操作指定区域的单元格",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结到左侧",
          fixedRight: "冻结到右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};

// node_modules/vxe-table/es/components.js
var components2 = [
  VxeColumn,
  VxeColgroup,
  VxeGrid,
  VxeTable,
  VxeToolbar
];
function install(app, options) {
  VxeUI.setConfig(options);
  components2.forEach((component2) => component2.install(app));
}
if (!VxeUI.hasLanguage("zh-CN")) {
  const defaultLanguage2 = "zh-CN";
  VxeUI.setI18n(defaultLanguage2, zh_CN_default);
  VxeUI.setLanguage(defaultLanguage2);
}
VxeUI.setTheme("light");

// node_modules/vxe-table/es/index.esm.js
var index_esm_default2 = components_exports;

// node_modules/@ksware/ksw-ux/kingsware-ui/index.js
var import_chinese_lunar_calendar = __toESM(require_lunar_calendar());

// node_modules/vxe-pc-ui/es/components.js
var components_exports2 = {};
__export(components_exports2, {
  Alert: () => Alert,
  Anchor: () => Anchor,
  AnchorLink: () => AnchorLink,
  Avatar: () => Avatar,
  Badge: () => Badge,
  Breadcrumb: () => Breadcrumb,
  BreadcrumbItem: () => BreadcrumbItem,
  Button: () => Button,
  ButtonGroup: () => ButtonGroup,
  Calendar: () => Calendar,
  Card: () => Card,
  Carousel: () => Carousel,
  CarouselItem: () => CarouselItem,
  Checkbox: () => Checkbox,
  CheckboxGroup: () => CheckboxGroup,
  Col: () => Col,
  Collapse: () => Collapse,
  CollapsePane: () => CollapsePane,
  ColorPicker: () => ColorPicker,
  Countdown: () => Countdown,
  DatePicker: () => DatePicker,
  Drawer: () => Drawer,
  DrawerController: () => DrawerController,
  Empty: () => Empty,
  Form: () => Form,
  FormDesign: () => FormDesign,
  FormGather: () => FormGather,
  FormGroup: () => FormGroup,
  FormItem: () => FormItem,
  FormView: () => FormView,
  GLOBAL_EVENT_KEYS: () => GLOBAL_EVENT_KEYS,
  Icon: () => Icon,
  IconPicker: () => IconPicker,
  Image: () => Image2,
  ImageGroup: () => ImageGroup,
  ImagePreview: () => ImagePreview,
  Input: () => Input,
  LayoutAside: () => LayoutAside,
  LayoutBody: () => LayoutBody,
  LayoutContainer: () => LayoutContainer,
  LayoutFooter: () => LayoutFooter,
  LayoutHeader: () => LayoutHeader,
  Link: () => Link,
  List: () => List,
  ListDesign: () => ListDesign,
  ListView: () => ListView,
  Loading: () => Loading2,
  LoadingController: () => LoadingController,
  Menu: () => Menu,
  Modal: () => Modal,
  ModalController: () => ModalController,
  NoticeBar: () => NoticeBar,
  NumberInput: () => NumberInput,
  Optgroup: () => Optgroup,
  Option: () => Option2,
  Pager: () => Pager,
  PasswordInput: () => PasswordInput,
  Print: () => Print,
  PrintPageBreak: () => PrintPageBreak,
  Pulldown: () => Pulldown,
  Radio: () => Radio,
  RadioButton: () => RadioButton,
  RadioGroup: () => RadioGroup,
  Rate: () => Rate,
  Result: () => Result,
  Row: () => Row,
  Select: () => Select,
  Slider: () => Slider,
  Steps: () => Steps,
  Switch: () => Switch,
  TabPane: () => TabPane,
  TableSelect: () => TableSelect,
  Tabs: () => Tabs,
  Tag: () => Tag,
  Text: () => Text2,
  TextEllipsis: () => TextEllipsis,
  Textarea: () => Textarea,
  Tip: () => Tip,
  Tips: () => Tips,
  Tooltip: () => Tooltip,
  Tree: () => Tree,
  TreeSelect: () => TreeSelect,
  Upload: () => Upload,
  VxeAlert: () => VxeAlert,
  VxeAnchor: () => VxeAnchor,
  VxeAnchorLink: () => VxeAnchorLink,
  VxeAvatar: () => VxeAvatar,
  VxeBadge: () => VxeBadge,
  VxeBreadcrumb: () => VxeBreadcrumb,
  VxeBreadcrumbItem: () => VxeBreadcrumbItem,
  VxeButton: () => VxeButton,
  VxeButtonGroup: () => VxeButtonGroup,
  VxeCalendar: () => VxeCalendar,
  VxeCard: () => VxeCard,
  VxeCarousel: () => VxeCarousel,
  VxeCarouselItem: () => VxeCarouselItem,
  VxeCheckbox: () => VxeCheckbox,
  VxeCheckboxGroup: () => VxeCheckboxGroup,
  VxeCol: () => VxeCol,
  VxeCollapse: () => VxeCollapse,
  VxeCollapsePane: () => VxeCollapsePane,
  VxeColorPicker: () => VxeColorPicker,
  VxeCore: () => VxeCore,
  VxeCountdown: () => VxeCountdown,
  VxeDatePicker: () => VxeDatePicker,
  VxeDrawer: () => VxeDrawer,
  VxeEmpty: () => VxeEmpty,
  VxeForm: () => VxeForm,
  VxeFormDesign: () => VxeFormDesign,
  VxeFormGather: () => VxeFormGather,
  VxeFormGroup: () => VxeFormGroup,
  VxeFormItem: () => VxeFormItem,
  VxeFormView: () => VxeFormView,
  VxeIcon: () => VxeIcon,
  VxeIconPicker: () => VxeIconPicker,
  VxeImage: () => VxeImage,
  VxeImageGroup: () => VxeImageGroup,
  VxeImagePreview: () => VxeImagePreview,
  VxeInput: () => VxeInput,
  VxeLayoutAside: () => VxeLayoutAside,
  VxeLayoutBody: () => VxeLayoutBody,
  VxeLayoutContainer: () => VxeLayoutContainer,
  VxeLayoutFooter: () => VxeLayoutFooter,
  VxeLayoutHeader: () => VxeLayoutHeader,
  VxeLink: () => VxeLink,
  VxeList: () => VxeList,
  VxeListDesign: () => VxeListDesign,
  VxeListView: () => VxeListView,
  VxeLoading: () => VxeLoading,
  VxeMenu: () => VxeMenu,
  VxeModal: () => VxeModal,
  VxeNoticeBar: () => VxeNoticeBar,
  VxeNumberInput: () => VxeNumberInput,
  VxeOptgroup: () => VxeOptgroup,
  VxeOption: () => VxeOption,
  VxePager: () => VxePager,
  VxePasswordInput: () => VxePasswordInput,
  VxePrint: () => VxePrint,
  VxePrintPageBreak: () => VxePrintPageBreak,
  VxePulldown: () => VxePulldown,
  VxeRadio: () => VxeRadio,
  VxeRadioButton: () => VxeRadioButton,
  VxeRadioGroup: () => VxeRadioGroup,
  VxeRate: () => VxeRate,
  VxeResult: () => VxeResult,
  VxeRow: () => VxeRow,
  VxeSelect: () => VxeSelect,
  VxeSlider: () => VxeSlider,
  VxeSteps: () => VxeSteps,
  VxeSwitch: () => VxeSwitch,
  VxeTabPane: () => VxeTabPane,
  VxeTableSelect: () => VxeTableSelect,
  VxeTabs: () => VxeTabs,
  VxeTag: () => VxeTag,
  VxeText: () => VxeText,
  VxeTextEllipsis: () => VxeTextEllipsis,
  VxeTextarea: () => VxeTextarea,
  VxeTip: () => VxeTip,
  VxeTooltip: () => VxeTooltip,
  VxeTree: () => VxeTree,
  VxeTreeSelect: () => VxeTreeSelect,
  VxeUI: () => VxeUI,
  VxeUpload: () => VxeUpload,
  VxeWatermark: () => VxeWatermark,
  Watermark: () => Watermark,
  WatermarkController: () => WatermarkController,
  clipboard: () => clipboard,
  commands: () => commands,
  component: () => component,
  config: () => config2,
  coreVersion: () => coreVersion,
  createEvent: () => createEvent,
  drawer: () => drawer,
  formats: () => formats,
  getComponent: () => getComponent,
  getConfig: () => getConfig,
  getI18n: () => getI18n,
  getIcon: () => getIcon,
  getLanguage: () => getLanguage,
  getTheme: () => getTheme,
  globalEvents: () => globalEvents,
  globalResize: () => globalResize,
  globalStore: () => globalStore,
  handleCheckInfo: () => handleCheckInfo,
  hasLanguage: () => hasLanguage,
  hooks: () => hooks,
  install: () => install2,
  interceptor: () => interceptor,
  loading: () => loading,
  log: () => log,
  menus: () => menus,
  modal: () => modal2,
  permission: () => permission,
  print: () => print2,
  readFile: () => readFile2,
  renderEmptyElement: () => renderEmptyElement,
  renderer: () => renderer,
  saveFile: () => saveFile2,
  setConfig: () => setConfig,
  setI18n: () => setI18n,
  setIcon: () => setIcon,
  setLanguage: () => setLanguage,
  setTheme: () => setTheme,
  setup: () => setup2,
  use: () => use,
  useFns: () => useFns,
  usePermission: () => usePermission,
  useSize: () => useSize,
  validators: () => validators,
  version: () => version6,
  watermark: () => watermark
});

// node_modules/vxe-pc-ui/es/language/zh-CN.js
var zh_CN_default2 = {
  vxe: {
    base: {
      pleaseInput: "请输入",
      pleaseSelect: "请选择",
      comma: "，",
      fullStop: "。"
    },
    loading: {
      text: "加载中..."
    },
    error: {
      downErr: "下载失败",
      groupFixed: "如果使用分组表头，冻结列必须按组设置",
      groupMouseRange: '分组表头与 "{0}" 不能同时使用，这可能会出现错误',
      groupTag: '分组列头应该使用 "{0}" 而不是 "{1}"，这可能会出现错误',
      scrollErrProp: '启用虚拟滚动后不支持该参数 "{0}"',
      errConflicts: '参数 "{0}" 与 "{1}" 有冲突',
      unableInsert: "无法插入到指定位置，请检查参数是否正确",
      useErr: '安装 "{0}" 模块时发生错误，可能顺序不正确，依赖的模块需要在 Table 之前安装',
      barUnableLink: "工具栏无法关联表格",
      expandContent: '展开行的插槽应该是 "content"，请检查是否正确',
      reqComp: '缺少 "{0}" 组件，请检查是否正确安装。 https://vxeui.com/#/start/useGlobal',
      reqModule: '缺少 "{0}" 模块',
      reqProp: '缺少必要的 "{0}" 参数，这可能会导致出现错误',
      emptyProp: '参数 "{0}" 不允许为空',
      errProp: '不支持的参数 "{0}"，可能为 "{1}"',
      colRepet: 'column.{0}="{1}" 重复了，这可能会导致某些功能无法使用',
      notFunc: '方法 "{0}" 不存在',
      errFunc: '参数 "{0}" 不是一个方法',
      notValidators: '全局校验 "{0}" 不存在',
      notFormats: '全局格式化 "{0}" 不存在',
      notCommands: '全局指令 "{0}" 不存在',
      notSlot: '插槽 "{0}" 不存在',
      noTree: '树结构不支持 "{0}"',
      notProp: '不支持的参数 "{0}"',
      checkProp: '当数据量过大时可能会导致复选框卡顿，建议设置参数 "{0}" 提升渲染速度',
      coverProp: '"{0}" 的参数 "{1}" 重复定义，这可能会出现错误',
      uniField: '字段名 "{0}" 重复定义，这可能会出现错误',
      repeatKey: '主键重复 {0}="{1}"，这可能会出现错误',
      delFunc: '方法 "{0}" 已废弃，请使用 "{1}"',
      delProp: '参数 "{0}" 已废弃，请使用 "{1}"',
      delEvent: '事件 "{0}" 已废弃，请使用 "{1}"',
      removeProp: '参数 "{0}" 已废弃，不建议使用，这可能会导致出现错误',
      errFormat: '全局的格式化内容应该使用 "VXETable.formats" 定义，挂载 "formatter={0}" 的方式已不建议使用',
      notType: '不支持的文件类型 "{0}"',
      notExp: "该浏览器不支持导入/导出功能",
      impFields: "导入失败，请检查字段名和数据格式是否正确",
      treeNotImp: "树表格不支持导入",
      treeCrossDrag: "只能拖拽第一层级",
      treeDragChild: "父级不能拖拽到自己的子级中",
      reqPlugin: '可选扩展插件 "{1}" https://vxeui.com/other{0}/#/{1}/install'
    },
    table: {
      emptyText: "暂无数据",
      allTitle: "全选/取消",
      seqTitle: "序号",
      actionTitle: "操作",
      confirmFilter: "筛选",
      resetFilter: "重置",
      allFilter: "全部",
      sortAsc: "升序：最低到最高",
      sortDesc: "降序：最高到最低",
      filter: "对所选的列启用筛选",
      impSuccess: "成功导入 {0} 条记录",
      expLoading: "正在导出中",
      expSuccess: "导出成功",
      expError: "导出失败",
      expFilename: "导出_{0}",
      expOriginFilename: "导出_源_{0}",
      customTitle: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customClose: "关闭",
      customCancel: "取消",
      customRestore: "恢复默认",
      maxFixedCol: "最大冻结列的数量不能超过 {0} 个",
      dragTip: "移动：{0}"
    },
    grid: {
      selectOneRecord: "请至少选择一条记录！",
      deleteSelectRecord: "您确定要删除所选记录吗？",
      removeSelectRecord: "您确定要移除所选记录吗？",
      dataUnchanged: "数据未改动！",
      delSuccess: "成功删除所选记录！",
      saveSuccess: "保存成功！",
      operError: "发生错误，操作失败！"
    },
    select: {
      search: "搜索",
      loadingText: "加载中",
      emptyText: "暂无数据"
    },
    pager: {
      goto: "前往",
      gotoTitle: "页数",
      pagesize: "{0}条/页",
      total: "共 {0} 条记录",
      pageClassifier: "页",
      homePage: "首页",
      homePageTitle: "首页",
      prevPage: "上一页",
      prevPageTitle: "上一页",
      nextPage: "下一页",
      nextPageTitle: "下一页",
      prevJump: "向上跳页",
      prevJumpTitle: "向上跳页",
      nextJump: "向下跳页",
      nextJumpTitle: "向下跳页",
      endPage: "末页",
      endPageTitle: "末页"
    },
    alert: {
      title: "系统提示"
    },
    button: {
      confirm: "确认",
      cancel: "取消"
    },
    filter: {
      search: "搜索"
    },
    custom: {
      cstmTitle: "列设置",
      cstmRestore: "恢复默认",
      cstmCancel: "取消",
      cstmConfirm: "确定",
      cstmConfirmRestore: "请确认是否恢复成默认列配置？",
      cstmDragTarget: "移动：{0}",
      setting: {
        colSort: "排序",
        sortHelpTip: "点击并拖动图标可以调整列的排序",
        colTitle: "列标题",
        colResizable: "列宽（像素）",
        colVisible: "是否显示",
        colFixed: "冻结列",
        colFixedMax: "冻结列（最多 {0} 列）",
        fixedLeft: "左侧",
        fixedUnset: "不设置",
        fixedRight: "右侧"
      }
    },
    import: {
      modes: {
        covering: "覆盖方式（直接覆盖表格数据）",
        insert: "底部追加（在表格的底部追加新数据）",
        insertTop: "顶部追加（在表格的顶部追加新数据）",
        insertBottom: "底部追加（在表格的底部追加新数据）"
      },
      impTitle: "导入数据",
      impFile: "文件名",
      impSelect: "选择文件",
      impType: "文件类型",
      impOpts: "参数设置",
      impMode: "导入模式",
      impConfirm: "导入",
      impCancel: "取消"
    },
    export: {
      types: {
        csv: "CSV (逗号分隔)(*.csv)",
        html: "网页(*.html)",
        xml: "XML 数据(*.xml)",
        txt: "文本文件(制表符分隔)(*.txt)",
        xls: "Excel 97-2003 工作簿(*.xls)",
        xlsx: "Excel 工作簿(*.xlsx)",
        pdf: "PDF (*.pdf)"
      },
      modes: {
        current: "当前数据（当前页的数据）",
        selected: "选中数据（当前页选中的数据）",
        all: "全量数据（包括所有分页的数据）"
      },
      printTitle: "打印数据",
      expTitle: "导出数据",
      expName: "文件名",
      expNamePlaceholder: "请输入文件名",
      expSheetName: "标题",
      expSheetNamePlaceholder: "请输入标题",
      expType: "保存类型",
      expMode: "选择数据",
      expCurrentColumn: "全部字段",
      expColumn: "选择字段",
      expOpts: "参数设置",
      expOptHeader: "表头",
      expHeaderTitle: "是否需要表头",
      expOptFooter: "表尾",
      expFooterTitle: "是否需要表尾",
      expOptColgroup: "分组表头",
      expColgroupTitle: "如果存在，则支持带有分组结构的表头",
      expOptMerge: "合并",
      expMergeTitle: "如果存在，则支持带有合并结构的单元格",
      expOptAllExpand: "展开层级",
      expAllExpandTitle: "如果存在，则支持将带有层级结构的数据全部展开",
      expOptUseStyle: "样式",
      expUseStyleTitle: "如果存在，则支持带样式的单元格",
      expOptOriginal: "源数据",
      expOriginalTitle: "如果为源数据，则支持导入到表格中",
      expPrint: "打印",
      expConfirm: "导出",
      expCancel: "取消"
    },
    modal: {
      errTitle: "错误提示",
      zoomMin: "最小化",
      zoomIn: "最大化",
      zoomOut: "还原",
      close: "关闭",
      miniMaxSize: "最小化窗口的数量不能超过 {0} 个",
      footPropErr: "show-footer 仅用于启用表尾，需配合 show-confirm-button | show-cancel-button | 插槽使用"
    },
    drawer: {
      close: "关闭"
    },
    form: {
      folding: "收起",
      unfolding: "展开"
    },
    toolbar: {
      import: "导入",
      export: "导出",
      print: "打印",
      refresh: "刷新",
      zoomIn: "全屏",
      zoomOut: "还原",
      custom: "列设置",
      customAll: "全部",
      customConfirm: "确认",
      customRestore: "重置",
      fixedLeft: "冻结在左侧",
      fixedRight: "冻结在右侧",
      cancelFixed: "取消冻结列"
    },
    input: {
      date: {
        m1: "01 月",
        m2: "02 月",
        m3: "03 月",
        m4: "04 月",
        m5: "05 月",
        m6: "06 月",
        m7: "07 月",
        m8: "08 月",
        m9: "09 月",
        m10: "10 月",
        m11: "11 月",
        m12: "12 月",
        quarterLabel: "{0} 年",
        monthLabel: "{0} 年",
        dayLabel: "{0} 年 {1}",
        labelFormat: {
          date: "yyyy-MM-dd",
          time: "HH:mm:ss",
          datetime: "yyyy-MM-dd HH:mm:ss",
          week: "yyyy 年第 WW 周",
          month: "yyyy-MM",
          quarter: "yyyy 年第 q 季度",
          year: "yyyy"
        },
        weeks: {
          w: "周",
          w0: "周日",
          w1: "周一",
          w2: "周二",
          w3: "周三",
          w4: "周四",
          w5: "周五",
          w6: "周六"
        },
        months: {
          m0: "一月",
          m1: "二月",
          m2: "三月",
          m3: "四月",
          m4: "五月",
          m5: "六月",
          m6: "七月",
          m7: "八月",
          m8: "九月",
          m9: "十月",
          m10: "十一月",
          m11: "十二月"
        },
        quarters: {
          q1: "第一季度",
          q2: "第二季度",
          q3: "第三季度",
          q4: "第四季度"
        }
      }
    },
    numberInput: {
      currencySymbol: "￥"
    },
    imagePreview: {
      popupTitle: "预览",
      operBtn: {
        zoomOut: "缩小",
        zoomIn: "放大",
        pctFull: "等比例缩放",
        pct11: "显示原始尺寸",
        rotateLeft: "向左旋转",
        rotateRight: "向右旋转",
        print: "点击打印图片",
        download: "点击下载图片"
      }
    },
    upload: {
      fileBtnText: "点击或拖拽上传",
      imgBtnText: "点击或拖拽上传",
      dragPlaceholder: "请把文件拖放到这个区域即可上传",
      imgSizeHint: "单张{0}",
      imgCountHint: "最多{0}张",
      fileTypeHint: "支持 {0} 文件类型",
      fileSizeHint: "单个文件大小不超过{0}",
      fileCountHint: "最多可上传{0}个文件",
      uploadTypeErr: "文件类型不匹配！",
      overCountErr: "最多只能选择{0}个文件！",
      overCountExtraErr: "已超出最大数量{0}个，超出的{1}个文件将被忽略！",
      overSizeErr: "文件大小最大不能超过{0}！",
      reUpload: "重新上传",
      uploadProgress: "上传中 {0}%",
      uploadErr: "上传失败",
      uploadSuccess: "上传成功",
      moreBtnText: "更多（{0}）",
      viewItemTitle: "点击查看",
      morePopup: {
        readTitle: "查看列表",
        imageTitle: "上传图片",
        fileTitle: "上传文件"
      }
    },
    empty: {
      defText: "暂无数据"
    },
    formDesign: {
      formName: "表单名称",
      defFormTitle: "未命名的表单",
      widgetPropTab: "控件属性",
      widgetFormTab: "表单属性",
      error: {
        wdFormUni: "该类型的控件在表单中只允许添加一个",
        wdSubUni: "该类型的控件在子表中只允许添加一个"
      },
      styleSetting: {
        btn: "样式设置",
        title: "表单的样式设置",
        layoutTitle: "控件布局",
        verticalLayout: "上下布局",
        horizontalLayout: "横向布局",
        styleTitle: "标题样式",
        boldTitle: "标题加粗",
        fontBold: "加粗",
        fontNormal: "常规",
        colonTitle: "显示冒号",
        colonVisible: "显示",
        colonHidden: "隐藏",
        alignTitle: "对齐方式",
        widthTitle: "标题宽度",
        alignLeft: "居左",
        alignRight: "居右",
        unitPx: "像素",
        unitPct: "百分比"
      },
      widget: {
        group: {
          base: "基础控件",
          layout: "布局控件",
          system: "系统控件",
          module: "模块控件",
          chart: "图表控件",
          advanced: "高级控件"
        },
        copyTitle: "副本_{0}",
        component: {
          input: "输入框",
          textarea: "文本域",
          select: "下拉选择",
          row: "一行多列",
          title: "标题",
          text: "文本",
          subtable: "子表",
          VxeSwitch: "是/否",
          VxeInput: "输入框",
          VxeNumberInput: "数字",
          VxeDatePicker: "日期",
          VxeTextarea: "文本域",
          VxeSelect: "下拉选择",
          VxeTreeSelect: "树形选择",
          VxeRadioGroup: "单选框",
          VxeCheckboxGroup: "复选框",
          VxeUploadFile: "文件",
          VxeUploadImage: "图片",
          VxeRate: "评分",
          VxeSlider: "滑块"
        }
      },
      widgetProp: {
        name: "控件名称",
        placeholder: "提示语",
        required: "必填校验",
        multiple: "允许多选",
        displaySetting: {
          name: "显示设置",
          pc: "电脑端",
          mobile: "手机端",
          visible: "显示",
          hidden: "隐藏"
        },
        dataSource: {
          name: "数据源",
          defValue: "选项{0}",
          addOption: "添加选项",
          batchEditOption: "批量编辑",
          batchEditTip: "每行对应一个选项，支持从表格、Excel、WPS 中直接复制粘贴。",
          batchEditSubTip: "每行对应一个选项，如果是分组，子项可以是空格或制表键开头，支持从表格、Excel、WPS 中直接复制粘贴。",
          buildOption: "生成选项"
        },
        rowProp: {
          colSize: "列数",
          col2: "两列",
          col3: "三列",
          col4: "四列",
          col6: "六列",
          layout: "布局"
        },
        textProp: {
          name: "内容",
          alignTitle: "对齐方式",
          alignLeft: "居左",
          alignCenter: "居中",
          alignRight: "居右",
          colorTitle: "字体颜色",
          sizeTitle: "字体大小",
          boldTitle: "字体加粗",
          fontNormal: "常规",
          fontBold: "加粗"
        },
        subtableProp: {
          seqTitle: "序号",
          showSeq: "显示序号",
          showCheckbox: "允许多选",
          errSubDrag: "子表不支持该控件，请使用其他控件",
          colPlace: "将控件拖拽进来"
        },
        uploadProp: {
          limitFileCount: "文件数量限制",
          limitFileSize: "文件大小限制",
          multiFile: "允许上传多个文件",
          limitImgCount: "图片数量限制",
          limitImgSize: "图片大小限制",
          multiImg: "允许上传多张图片"
        }
      }
    },
    listDesign: {
      fieldSettingTab: "字段设置",
      listSettingTab: "参数设置",
      searchTitle: "查询条件",
      listTitle: "列表字段",
      searchField: "查询字段",
      listField: "列表字段",
      activeBtn: {
        ActionButtonUpdate: "编辑",
        ActionButtonDelete: "删除"
      },
      search: {
        addBtn: "编辑",
        emptyText: "未配置查询条件",
        editPopupTitle: "编辑查询字段"
      },
      searchPopup: {
        colTitle: "标题",
        saveBtn: "保存"
      }
    },
    text: {
      copySuccess: "已复制到剪贴板",
      copyError: "当前环境不支持该操作"
    },
    countdown: {
      formats: {
        yyyy: "年",
        MM: "月",
        dd: "天",
        HH: "时",
        mm: "分",
        ss: "秒"
      }
    },
    plugins: {
      extendCellArea: {
        area: {
          mergeErr: "无法对合并单元格进行该操作",
          multiErr: "无法对多重选择区域进行该操作",
          selectErr: "无法操作指定区域的单元格",
          extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
          pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作",
          cpInvalidErr: "该操作无法进行，您选择的区域中存在被禁止的列（{0}）"
        },
        fnr: {
          title: "查找和替换",
          findLabel: "查找",
          replaceLabel: "替换",
          findTitle: "查找内容：",
          replaceTitle: "替换为：",
          tabs: {
            find: "查找",
            replace: "替换"
          },
          filter: {
            re: "正则表达式",
            whole: "全词匹配",
            sensitive: "区分大小写"
          },
          btns: {
            findNext: "查找下一个",
            findAll: "查找全部",
            replace: "替换",
            replaceAll: "替换全部",
            cancel: "取消"
          },
          header: {
            seq: "#",
            cell: "单元格",
            value: "值"
          },
          empty: "(空值)",
          reError: "无效的正则表达式",
          recordCount: "已找到 {0} 个单元格",
          notCell: "找不到匹配的单元格",
          replaceSuccess: "成功替换 {0} 个单元格"
        }
      },
      filterComplexInput: {
        menus: {
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧"
        },
        cases: {
          equal: "等于",
          gt: "大于",
          lt: "小于",
          begin: "开头是",
          endin: "结尾是",
          include: "包含",
          isSensitive: "区分大小写"
        }
      },
      filterCombination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结左侧",
          fixedRight: "冻结右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        cases: {
          equal: "等于",
          unequal: "不等于",
          gt: "大于",
          ge: "大于或等于",
          lt: "小于",
          le: "小于或等于",
          begin: "开头是",
          notbegin: "开头不是",
          endin: "结尾是",
          notendin: "结尾不是",
          include: "包含",
          exclude: "不包含",
          between: "介于",
          custom: "自定义筛选",
          insensitive: "不区分大小写",
          isSensitive: "区分大小写"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    },
    pro: {
      area: {
        mergeErr: "无法对合并单元格进行该操作",
        multiErr: "无法对多重选择区域进行该操作",
        extendErr: "如果延伸的区域包含被合并的单元格，所有合并的单元格需大小相同",
        pasteMultiErr: "无法粘贴，需要相同大小的复制的区域和粘贴的区域才能执行此操作"
      },
      fnr: {
        title: "查找和替换",
        findLabel: "查找",
        replaceLabel: "替换",
        findTitle: "查找内容：",
        replaceTitle: "替换为：",
        tabs: {
          find: "查找",
          replace: "替换"
        },
        filter: {
          re: "正则表达式",
          whole: "全词匹配",
          sensitive: "区分大小写"
        },
        btns: {
          findNext: "查找下一个",
          findAll: "查找全部",
          replace: "替换",
          replaceAll: "替换全部",
          cancel: "取消"
        },
        header: {
          seq: "#",
          cell: "单元格",
          value: "值"
        },
        empty: "(空值)",
        reError: "无效的正则表达式",
        recordCount: "已找到 {0} 个单元格",
        notCell: "找不到匹配的单元格",
        replaceSuccess: "成功替换 {0} 个单元格"
      }
    },
    renderer: {
      search: "搜索",
      cases: {
        equal: "等于",
        unequal: "不等于",
        gt: "大于",
        ge: "大于或等于",
        lt: "小于",
        le: "小于或等于",
        begin: "开头是",
        notbegin: "开头不是",
        endin: "结尾是",
        notendin: "结尾不是",
        include: "包含",
        exclude: "不包含",
        between: "介于",
        custom: "自定义筛选",
        insensitive: "不区分大小写",
        isSensitive: "区分大小写"
      },
      combination: {
        menus: {
          clearSort: "清除排序",
          sortAsc: "升序",
          sortDesc: "降序",
          fixedColumn: "冻结列",
          fixedGroup: "冻结分组",
          cancelFixed: "取消冻结",
          fixedLeft: "冻结到左侧",
          fixedRight: "冻结到右侧",
          clearFilter: "清除筛选",
          textOption: "文本筛选",
          numberOption: "数值筛选"
        },
        popup: {
          title: "自定义筛选的方式",
          currColumnTitle: "当前列：",
          and: "与",
          or: "或",
          describeHtml: "可用 ? 代表单个字符<br/>用 * 代表任意多个字符"
        },
        empty: "(空白)",
        notData: "无匹配项"
      }
    }
  }
};

// node_modules/vxe-pc-ui/es/alert/src/alert.js
var import_xe_utils41 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/dynamics/index.js
var dynamicContainerElem;
var dynamicStore = reactive({
  modals: [],
  drawers: [],
  globalLoading: null,
  globalWatermark: null
});
var VxeDynamics = defineComponent({
  setup() {
    const VxeUIModalComponent = VxeUI.getComponent("VxeModal");
    const VxeUIDrawerComponent = VxeUI.getComponent("VxeDrawer");
    const VxeUILoadingComponent = VxeUI.getComponent("VxeLoading");
    const VxeUIWatermarkComponent = VxeUI.getComponent("VxeWatermark");
    return () => {
      const { modals, drawers, globalWatermark, globalLoading } = dynamicStore;
      return [
        modals.length ? h("div", {
          key: 1,
          class: "vxe-dynamics--modal"
        }, modals.map((item) => h(VxeUIModalComponent, item))) : createCommentVNode(),
        drawers.length ? h("div", {
          key: 2,
          class: "vxe-dynamics--drawer"
        }, drawers.map((item) => h(VxeUIDrawerComponent, item))) : createCommentVNode(),
        globalWatermark ? h(VxeUIWatermarkComponent, globalWatermark) : createCommentVNode(),
        globalLoading ? h(VxeUILoadingComponent, globalLoading) : createCommentVNode()
      ];
    };
  }
});
var dynamicApp = createApp(VxeDynamics);
function checkDynamic() {
  if (!dynamicContainerElem) {
    dynamicContainerElem = document.createElement("div");
    dynamicContainerElem.className = "vxe-dynamics";
    document.body.appendChild(dynamicContainerElem);
    dynamicApp.mount(dynamicContainerElem);
  }
}

// node_modules/vxe-pc-ui/es/ui/src/utils.js
var import_xe_utils39 = __toESM(require_xe_utils());
function isEnableConf2(conf) {
  return conf && conf.enabled !== false;
}
function nextZIndex2() {
  return index_esm_default.getNext();
}
function getLastZIndex2() {
  return index_esm_default.getCurrent();
}
function getFuncText2(content, args) {
  if (content) {
    const translate2 = getConfig().translate;
    return import_xe_utils39.default.toValueString(translate2 ? translate2("" + content, args) : content);
  }
  return "";
}
function eqEmptyValue2(cellValue) {
  return cellValue === null || cellValue === void 0 || cellValue === "";
}
function handleBooleanDefaultValue(value) {
  return import_xe_utils39.default.isBoolean(value) ? value : null;
}

// node_modules/vxe-pc-ui/es/ui/src/log.js
var version5 = `ui v${"4.3.36"}`;
var warnLog2 = log.create("warn", version5);
var errLog2 = log.create("error", version5);

// node_modules/vxe-pc-ui/es/ui/index.js
var version6 = "4.3.36";
VxeUI.version = version6;
VxeUI.uiVersion = version6;
VxeUI.tableVersion = "";
VxeUI.t = VxeUI.getI18n;
VxeUI._t = getFuncText2;
VxeUI.dynamicApp = dynamicApp;
function config2(options) {
  if (true) {
    warnLog2("vxe.error.delFunc", ["config", "setConfig"]);
  }
  return setConfig(options);
}
function setup2(options) {
  if (true) {
    warnLog2("vxe.error.delFunc", ["setup", "setConfig"]);
  }
  return setConfig(options);
}
VxeUI.config = config2;
VxeUI.setup = setup2;
setConfig({
  alert: {},
  anchor: {},
  anchorLink: {},
  avatar: {},
  badge: {},
  breadcrumb: {
    separator: "/"
  },
  breadcrumbItem: {},
  button: {
    trigger: "hover",
    prefixTooltip: {
      enterable: true
    },
    suffixTooltip: {
      enterable: true
    }
  },
  buttonGroup: {},
  calendar: {
    minDate: new Date(1900, 0, 1),
    maxDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  card: {
    border: true,
    padding: true
  },
  carousel: {
    height: 200,
    loop: true,
    interval: 5e3
  },
  carouselItem: {},
  checkbox: {},
  checkboxGroup: {},
  col: {},
  collapse: {
    padding: true,
    expandConfig: {
      showIcon: true
    }
  },
  collapsePane: {},
  countdown: {},
  datePicker: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1
  },
  drawer: {
    // size: null,
    position: "right",
    showHeader: true,
    lockView: true,
    mask: true,
    showTitleOverflow: true,
    showClose: true,
    padding: true,
    cancelClosable: true,
    confirmClosable: true
  },
  empty: {},
  form: {
    // preventSubmit: false,
    // size: null,
    // colon: false,
    validConfig: {
      showMessage: true,
      autoPos: true,
      theme: "beautify"
    },
    tooltipConfig: {
      enterable: true
    },
    titleAsterisk: true,
    titleOverflow: false,
    padding: true
  },
  formDesign: {
    height: 400,
    showHeader: true,
    showPc: true
  },
  formGather: {},
  formGroup: {},
  formItem: {},
  formView: {},
  icon: {},
  iconPicker: {
    icons: ["home", "company", "comment", "setting", "send", "envelope", "envelope-open", "bell", "search", "print", "pc", "goods", "chart-line", "edit", "delete", "save", "folder", "microphone", "flag", "link", "location", "sunny", "rmb", "usd", "user", "add-user", "add-users", "star", "unlock", "time", "text", "feedback", "calendar", "association-form", "cloud-download", "cloud-upload", "file", "subtable", "chart-bar-x", "chart-bar-y", "chart-line", "chart-pie", "chart-radar"]
  },
  image: {
    showPreview: true,
    showPrintButton: true,
    maskClosable: true
  },
  imageGroup: {
    showPreview: true,
    showPrintButton: true
  },
  imagePreview: {
    showPrintButton: true
  },
  input: {
    // size: null,
    // transfer: false
    // parseFormat: 'yyyy-MM-dd HH:mm:ss.SSS',
    // labelFormat: '',
    // valueFormat: '',
    startDate: new Date(1900, 0, 1),
    endDate: new Date(2100, 0, 1),
    startDay: 1,
    selectDay: 1,
    digits: 2,
    controls: true
  },
  layoutAside: {},
  layoutBody: {},
  layoutContainer: {},
  layoutFooter: {},
  layoutHeader: {},
  link: {
    underline: true
  },
  listDesign: {
    height: 400,
    showPc: true
  },
  listView: {},
  list: {
    // size: null,
    scrollY: {
      enabled: true,
      gt: 100
      // oSize: 0
    }
  },
  loading: {
    showIcon: true,
    showText: true
  },
  modal: {
    // size: null,
    top: 16,
    showHeader: true,
    minWidth: 340,
    minHeight: 140,
    lockView: true,
    mask: true,
    duration: 3e3,
    marginSize: 0,
    dblclickZoom: true,
    showTitleOverflow: true,
    animat: true,
    showClose: true,
    padding: true,
    draggable: true,
    showConfirmButton: null,
    cancelClosable: true,
    confirmClosable: true,
    zoomConfig: {
      minimizeMaxSize: 10,
      minimizeVerticalOffset: {
        top: -24,
        left: 0
      },
      minimizeHorizontalOffset: {
        top: 0,
        left: 32
      }
    },
    // storage: false,
    storageKey: "VXE_MODAL_POSITION"
  },
  noticeBar: {},
  numberInput: {
    // size: null,
    // transfer: false
    digits: 2,
    controls: true
  },
  optgroup: {},
  option: {},
  pager: {
    pageSizePlacement: "top"
    // size: null,
    // autoHidden: false,
    // perfect: true,
    // pageSize: 10,
    // pagerCount: 7,
    // pageSizes: [10, 15, 20, 50, 100],
    // layouts: ['PrevJump', 'PrevPage', 'Jump', 'PageCount', 'NextPage', 'NextJump', 'Sizes', 'Total']
  },
  print: {},
  passwordInput: {
    controls: true
  },
  printPageBreak: {},
  pulldown: {
    destroyOnClose: true
  },
  radio: {
    strict: true
  },
  radioButton: {
    strict: true
  },
  radioGroup: {
    strict: true
  },
  rate: {},
  result: {},
  row: {},
  select: {
    multiCharOverflow: 8,
    scrollY: {
      enabled: true,
      gt: 100,
      oSize: 2
    }
  },
  slider: {
    max: 100,
    min: 0
  },
  steps: {},
  switch: {},
  tabPane: {},
  tableSelect: {
    gridConfig: {
      showOverflow: true,
      showHeaderOverflow: true,
      showFooterOverflow: true,
      rowConfig: {
        isHover: true
      },
      scrollX: {
        enabled: true,
        gt: 0
      },
      scrollY: {
        mode: "wheel",
        enabled: true,
        gt: 0
      }
    }
  },
  tabs: {},
  tag: {},
  textEllipsis: {},
  text: {},
  textarea: {
    resize: "none"
  },
  tip: {},
  tooltip: {
    // size: null,
    // enterable: false,
    trigger: "hover",
    theme: "dark",
    enterDelay: 500,
    leaveDelay: 300,
    isArrow: true
  },
  tree: {
    indent: 20,
    minHeight: 60,
    radioConfig: {
      strict: true
    }
  },
  treeSelect: {
    treeConfig: {
      radioConfig: {},
      checkboxConfig: {}
    }
  },
  upload: {
    mode: "all",
    imageTypes: ["jpg", "jpeg", "png", "gif"],
    showList: true,
    showUploadButton: true,
    showButtonText: true,
    showRemoveButton: true,
    showButtonIcon: true,
    showPreview: true,
    dragToUpload: true
    // imageConfig: {}
  },
  watermark: {
    rotate: -30,
    gap: [100, 100]
  },
  table: {},
  colgroup: {},
  column: {},
  toolbar: {},
  grid: {}
});
var iconPrefix2 = "vxe-icon-";
setIcon({
  // loading
  LOADING: iconPrefix2 + "spinner roll vxe-loading--default-icon",
  // button
  BUTTON_DROPDOWN: iconPrefix2 + "arrow-down",
  BUTTON_LOADING: iconPrefix2 + "spinner roll",
  BUTTON_TOOLTIP_ICON: iconPrefix2 + "question-circle-fill",
  // menu
  MENU_ITEM_EXPAND_OPEN: iconPrefix2 + "arrow-down rotate180",
  MENU_ITEM_EXPAND_CLOSE: iconPrefix2 + "arrow-down",
  // select
  SELECT_LOADED: iconPrefix2 + "spinner roll",
  SELECT_OPEN: iconPrefix2 + "caret-down rotate180",
  SELECT_CLOSE: iconPrefix2 + "caret-down",
  // icon-picker
  ICON_PICKER_OPEN: iconPrefix2 + "caret-down rotate180",
  ICON_PICKER_CLOSE: iconPrefix2 + "caret-down",
  // pager
  PAGER_HOME: iconPrefix2 + "home-page",
  PAGER_END: iconPrefix2 + "end-page",
  PAGER_JUMP_PREV: iconPrefix2 + "arrow-double-left",
  PAGER_JUMP_NEXT: iconPrefix2 + "arrow-double-right",
  PAGER_PREV_PAGE: iconPrefix2 + "arrow-left",
  PAGER_NEXT_PAGE: iconPrefix2 + "arrow-right",
  PAGER_JUMP_MORE: iconPrefix2 + "ellipsis-h",
  // radio
  RADIO_CHECKED: iconPrefix2 + "radio-checked-fill",
  RADIO_UNCHECKED: iconPrefix2 + "radio-unchecked",
  // checkbox
  CHECKBOX_INDETERMINATE: iconPrefix2 + "checkbox-indeterminate-fill",
  CHECKBOX_CHECKED: iconPrefix2 + "checkbox-checked-fill",
  CHECKBOX_UNCHECKED: iconPrefix2 + "checkbox-unchecked",
  // input
  INPUT_CLEAR: iconPrefix2 + "error-circle-fill",
  INPUT_SEARCH: iconPrefix2 + "search",
  // number-picker
  NUMBER_INPUT_PREV_NUM: iconPrefix2 + "caret-up",
  NUMBER_INPUT_NEXT_NUM: iconPrefix2 + "caret-down",
  // date-picker
  DATE_PICKER_DATE: iconPrefix2 + "calendar",
  // password-input
  PASSWORD_INPUT_SHOW_PWD: iconPrefix2 + "eye-fill-close",
  PASSWORD_INPUT_HIDE_PWD: iconPrefix2 + "eye-fill",
  // modal
  MODAL_ZOOM_MIN: iconPrefix2 + "minus",
  MODAL_ZOOM_REVERT: iconPrefix2 + "recover",
  MODAL_ZOOM_IN: iconPrefix2 + "square",
  MODAL_ZOOM_OUT: iconPrefix2 + "maximize",
  MODAL_CLOSE: iconPrefix2 + "close",
  MODAL_INFO: iconPrefix2 + "info-circle-fill",
  MODAL_SUCCESS: iconPrefix2 + "success-circle-fill",
  MODAL_WARNING: iconPrefix2 + "warning-circle-fill",
  MODAL_ERROR: iconPrefix2 + "error-circle-fill",
  MODAL_QUESTION: iconPrefix2 + "question-circle-fill",
  MODAL_LOADING: iconPrefix2 + "spinner roll",
  // drawer
  DRAWER_CLOSE: iconPrefix2 + "close",
  // form
  FORM_PREFIX: iconPrefix2 + "question-circle-fill",
  FORM_SUFFIX: iconPrefix2 + "question-circle-fill",
  FORM_FOLDING: iconPrefix2 + "arrow-up rotate180",
  FORM_UNFOLDING: iconPrefix2 + "arrow-up",
  // form-design
  FORM_DESIGN_STYLE_SETTING: iconPrefix2 + "layout",
  FORM_DESIGN_PROPS_PC: iconPrefix2 + "pc",
  FORM_DESIGN_PROPS_MOBILE: iconPrefix2 + "mobile",
  FORM_DESIGN_PROPS_ADD: iconPrefix2 + "add",
  FORM_DESIGN_PROPS_EDIT: iconPrefix2 + "edit",
  FORM_DESIGN_WIDGET_ADD: iconPrefix2 + "square-plus-fill",
  FORM_DESIGN_WIDGET_COPY: iconPrefix2 + "copy",
  FORM_DESIGN_WIDGET_DELETE: iconPrefix2 + "delete",
  FORM_DESIGN_WIDGET_SWAP_LR: iconPrefix2 + "swap",
  FORM_DESIGN_WIDGET_OPTION_DELETE: iconPrefix2 + "delete",
  FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN: iconPrefix2 + "square-plus",
  FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE: iconPrefix2 + "square-minus",
  // list-design
  LIST_DESIGN_FIELD_SETTING: iconPrefix2 + "custom-column",
  LIST_DESIGN_LIST_SETTING: iconPrefix2 + "menu",
  LIST_DESIGN_LIST_SETTING_SEARCH_DELETE: iconPrefix2 + "delete",
  LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE: iconPrefix2 + "delete",
  // upload
  UPLOAD_FILE_ERROR: iconPrefix2 + "warning-circle-fill",
  UPLOAD_FILE_ADD: iconPrefix2 + "upload",
  UPLOAD_FILE_REMOVE: iconPrefix2 + "delete",
  UPLOAD_FILE_DOWNLOAD: iconPrefix2 + "download",
  UPLOAD_IMAGE_RE_UPLOAD: iconPrefix2 + "repeat",
  UPLOAD_IMAGE_ADD: iconPrefix2 + "add",
  UPLOAD_IMAGE_REMOVE: iconPrefix2 + "close",
  UPLOAD_LOADING: iconPrefix2 + "spinner roll vxe-loading--default-icon",
  UPLOAD_FILE_TYPE_DEFAULT: iconPrefix2 + "file",
  UPLOAD_FILE_TYPE_XLSX: iconPrefix2 + "file-excel",
  UPLOAD_FILE_TYPE_XLS: iconPrefix2 + "file-excel",
  UPLOAD_FILE_TYPE_PDF: iconPrefix2 + "file-pdf",
  UPLOAD_FILE_TYPE_PNG: iconPrefix2 + "file-image",
  UPLOAD_FILE_TYPE_GIF: iconPrefix2 + "file-image",
  UPLOAD_FILE_TYPE_JPG: iconPrefix2 + "file-image",
  UPLOAD_FILE_TYPE_JPEG: iconPrefix2 + "file-image",
  UPLOAD_FILE_TYPE_MD: iconPrefix2 + "file-markdown",
  UPLOAD_FILE_TYPE_PPD: iconPrefix2 + "file-ppt",
  UPLOAD_FILE_TYPE_DOCX: iconPrefix2 + "file-word",
  UPLOAD_FILE_TYPE_DOC: iconPrefix2 + "file-word",
  UPLOAD_FILE_TYPE_ZIP: iconPrefix2 + "file-zip",
  UPLOAD_FILE_TYPE_TXT: iconPrefix2 + "file-txt",
  // image-preview
  IMAGE_PREVIEW_CLOSE: iconPrefix2 + "close",
  IMAGE_PREVIEW_PREVIOUS: iconPrefix2 + "arrow-left",
  IMAGE_PREVIEW_NEXT: iconPrefix2 + "arrow-right",
  IMAGE_PREVIEW_PCT_FULL: iconPrefix2 + "pct-full",
  IMAGE_PREVIEW_PCT_1_1: iconPrefix2 + "pct-1-1",
  IMAGE_PREVIEW_ZOOM_OUT: iconPrefix2 + "search-zoom-out",
  IMAGE_PREVIEW_ZOOM_IN: iconPrefix2 + "search-zoom-in",
  IMAGE_PREVIEW_ROTATE_LEFT: iconPrefix2 + "rotate-left",
  IMAGE_PREVIEW_ROTATE_RIGHT: iconPrefix2 + "rotate-right",
  IMAGE_PREVIEW_PRINT: iconPrefix2 + "print",
  IMAGE_PREVIEW_DOWNLOAD: iconPrefix2 + "download",
  // alert
  ALERT_CLOSE: iconPrefix2 + "close",
  ALERT_INFO: iconPrefix2 + "info-circle-fill",
  ALERT_SUCCESS: iconPrefix2 + "success-circle-fill",
  ALERT_WARNING: iconPrefix2 + "warning-circle-fill",
  ALERT_ERROR: iconPrefix2 + "error-circle-fill",
  // tree
  TREE_NODE_OPEN: iconPrefix2 + "caret-right rotate90",
  TREE_NODE_CLOSE: iconPrefix2 + "caret-right",
  TREE_NODE_LOADED: iconPrefix2 + "spinner roll",
  // tree-select
  TREE_SELECT_LOADED: iconPrefix2 + "spinner roll",
  TREE_SELECT_OPEN: iconPrefix2 + "caret-down rotate180",
  TREE_SELECT_CLOSE: iconPrefix2 + "caret-down",
  // table-select
  TABLE_SELECT_LOADED: iconPrefix2 + "spinner roll",
  TABLE_SELECT_OPEN: iconPrefix2 + "caret-down rotate180",
  TABLE_SELECT_CLOSE: iconPrefix2 + "caret-down",
  // tabs
  TABS_TAB_BUTTON_LEFT: iconPrefix2 + "arrow-left",
  TABS_TAB_BUTTON_RIGHT: iconPrefix2 + "arrow-right",
  TABS_TAB_CLOSE: iconPrefix2 + "close",
  TABS_TAB_REFRESH: iconPrefix2 + "refresh",
  TABS_TAB_REFRESH_LOADING: iconPrefix2 + "refresh roll",
  // text
  TEXT_COPY: iconPrefix2 + "copy",
  TEXT_LOADING: iconPrefix2 + "spinner roll",
  // carousel
  CAROUSEL_HORIZONTAL_PREVIOUS: iconPrefix2 + "arrow-left",
  CAROUSEL_HORIZONTAL_NEXT: iconPrefix2 + "arrow-right",
  CAROUSEL_VERTICAL_PREVIOUS: iconPrefix2 + "arrow-up",
  CAROUSEL_VERTICAL_NEXT: iconPrefix2 + "arrow-down",
  // collapse
  COLLAPSE_OPEN: iconPrefix2 + "arrow-right rotate90",
  COLLAPSE_CLOSE: iconPrefix2 + "arrow-right",
  // empty
  EMPTY_DEFAULT: iconPrefix2 + "empty",
  // result
  RESULT_INFO: iconPrefix2 + "info-circle-fill",
  RESULT_SUCCESS: iconPrefix2 + "success-circle-fill",
  RESULT_WARNING: iconPrefix2 + "warning-circle-fill",
  RESULT_ERROR: iconPrefix2 + "error-circle-fill",
  RESULT_QUESTION: iconPrefix2 + "question-circle-fill",
  RESULT_LOADING: iconPrefix2 + "spinner roll",
  // rate
  RATE_CHECKED: iconPrefix2 + "star-fill",
  RATE_UNCHECKED: iconPrefix2 + "star"
});

// node_modules/vxe-pc-ui/es/ui/src/vn.js
var import_xe_utils40 = __toESM(require_xe_utils());
function getOnName2(type) {
  return "on" + type.substring(0, 1).toLocaleUpperCase() + type.substring(1);
}
function getModelEvent2(name) {
  switch (name) {
    case "input":
    case "textarea":
      return "input";
    case "select":
      return "change";
  }
  return "update:modelValue";
}
function getChangeEvent2(name) {
  switch (name) {
    case "input":
    case "textarea":
    case "VxeInput":
    case "VxeTextarea":
    case "$input":
    case "$textarea":
      return "input";
  }
  return "change";
}
function getSlotVNs2(vns) {
  if (import_xe_utils40.default.isArray(vns)) {
    return vns;
  }
  return vns ? [vns] : [];
}

// node_modules/vxe-pc-ui/es/alert/src/alert.js
var alert_default = defineComponent({
  name: "VxeAlert",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().alert.title
    },
    content: [String, Number],
    status: String,
    showIcon: Boolean,
    showClose: Boolean,
    icon: {
      type: String,
      default: () => getConfig().alert.icon
    }
  },
  emits: [
    "close"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils41.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeAlert = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const alertMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $alert: $xeAlert }, params));
      }
    };
    const closeEvent = (evnt) => {
      alertMethods.dispatchEvent("close", {}, evnt);
    };
    const alertPrivateMethods = {};
    Object.assign($xeAlert, alertMethods, alertPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title, showIcon, showClose } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      return h("div", {
        ref: refElem,
        class: ["vxe-alert", {
          [`theme--${status}`]: status
        }]
      }, [
        iconSlot || showIcon && status || icon ? h("div", {
          class: "vxe-alert--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon || getIcon()[`ALERT_${status === null || status === void 0 ? void 0 : status.toUpperCase()}`]
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-alert--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-alert--title"
          }, titleSlot ? getSlotVNs2(titleSlot({})) : import_xe_utils41.default.toValueString(title)) : createCommentVNode(),
          h("div", {
            class: "vxe-alert--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : import_xe_utils41.default.toValueString(content))
        ]),
        showClose ? h("div", {
          class: "vxe-alert--close-btn",
          onClick: closeEvent
        }, [
          h("i", {
            class: getIcon().ALERT_CLOSE
          })
        ]) : createCommentVNode()
      ]);
    };
    $xeAlert.renderVN = renderVN;
    return $xeAlert;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/alert/index.js
var VxeAlert = Object.assign({}, alert_default, {
  install(app) {
    app.component(alert_default.name, alert_default);
  }
});
dynamicApp.use(VxeAlert);
VxeUI.component(alert_default);
var Alert = VxeAlert;
var alert_default2 = VxeAlert;

// node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var import_xe_utils45 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/ui/src/dom.js
var import_xe_utils42 = __toESM(require_xe_utils());
var browse3 = import_xe_utils42.default.browse();
var tpImg2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=";
var reClsMap2 = {};
function getClsRE2(cls) {
  if (!reClsMap2[cls]) {
    reClsMap2[cls] = new RegExp(`(?:^|\\s)${cls}(?!\\S)`, "g");
  }
  return reClsMap2[cls];
}
function getNodeOffset2(elem, container, rest) {
  if (elem) {
    const parentElem = elem.parentNode;
    rest.top += elem.offsetTop;
    rest.left += elem.offsetLeft;
    if (parentElem && parentElem !== document.documentElement && parentElem !== document.body) {
      rest.top -= parentElem.scrollTop;
      rest.left -= parentElem.scrollLeft;
    }
    if (container && (elem === container || elem.offsetParent === container) ? 0 : elem.offsetParent) {
      return getNodeOffset2(elem.offsetParent, container, rest);
    }
  }
  return rest;
}
function hasClass2(elem, cls) {
  return elem && elem.className && elem.className.match && elem.className.match(getClsRE2(cls));
}
function removeClass2(elem, cls) {
  if (elem && hasClass2(elem, cls)) {
    elem.className = elem.className.replace(getClsRE2(cls), "");
  }
}
function addClass2(elem, cls) {
  if (elem && !hasClass2(elem, cls)) {
    removeClass2(elem, cls);
    elem.className = `${elem.className} ${cls}`;
  }
}
function toCssUnit(val, unit = "px") {
  if (import_xe_utils42.default.isNumber(val) || /^\d+$/.test(`${val}`)) {
    return `${val}${unit}`;
  }
  return `${val || ""}`;
}
function getDomNode2() {
  const documentElement = document.documentElement;
  const bodyElem = document.body;
  return {
    scrollTop: documentElement.scrollTop || bodyElem.scrollTop,
    scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft,
    visibleHeight: documentElement.clientHeight || bodyElem.clientHeight,
    visibleWidth: documentElement.clientWidth || bodyElem.clientWidth
  };
}
function getEventTargetNode2(evnt, container, queryCls, queryMethod) {
  let targetElem;
  let target = evnt.target.shadowRoot && evnt.composed ? evnt.composedPath()[0] || evnt.target : evnt.target;
  while (target && target.nodeType && target !== document) {
    if (queryCls && hasClass2(target, queryCls) && (!queryMethod || queryMethod(target))) {
      targetElem = target;
    } else if (target === container) {
      return { flag: queryCls ? !!targetElem : true, container, targetElem };
    }
    target = target.parentNode;
  }
  return { flag: false };
}
function getOffsetPos2(elem, container) {
  return getNodeOffset2(elem, container, { left: 0, top: 0 });
}
function getAbsolutePos2(elem) {
  const bounding = elem.getBoundingClientRect();
  const boundingTop = bounding.top;
  const boundingLeft = bounding.left;
  const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = getDomNode2();
  return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth };
}
var scrollIntoViewIfNeeded2 = "scrollIntoViewIfNeeded";
var scrollIntoView2 = "scrollIntoView";
function scrollToView2(elem) {
  if (elem) {
    if (elem[scrollIntoViewIfNeeded2]) {
      elem[scrollIntoViewIfNeeded2]();
    } else if (elem[scrollIntoView2]) {
      elem[scrollIntoView2]();
    }
  }
}

// node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var import_xe_utils44 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/anchor/src/util.js
var import_xe_utils43 = __toESM(require_xe_utils());
function assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const parentElem = elem.parentNode;
  const parentLinkConfig = $xeParentAnchorLink ? $xeParentAnchorLink.linkConfig : null;
  const parentLinks = parentLinkConfig ? parentLinkConfig.children : staticLinks;
  if (parentElem && parentLinks) {
    parentLinks.splice(import_xe_utils43.default.arrayIndexOf(parentElem.children, elem), 0, linkConfig);
    $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
  }
}
function destroyAnchorLink($xeAnchor, linkConfig) {
  const staticLinks = $xeAnchor.reactData.staticLinks;
  const matchObj = import_xe_utils43.default.findTree(staticLinks, (item) => item.id === linkConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeAnchor.reactData.staticLinks = staticLinks.slice(0);
}

// node_modules/vxe-pc-ui/es/anchor/src/anchor-link.js
var anchor_link_default = defineComponent({
  name: "VxeAnchorLink",
  props: {
    content: [String, Number],
    title: [String, Number],
    href: String
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const $xeAnchor = inject("$xeAnchor", null);
    const $xeParentAnchorLink = inject("$xeAnchorLink", null);
    const xID = import_xe_utils44.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const linkConfig = reactive({
      id: xID,
      href: props.href,
      children: []
    });
    const refMaps = {
      refElem
    };
    const computeIsActive = computed(() => {
      const { href } = props;
      if ($xeAnchor) {
        return $xeAnchor.reactData.activeHref === href;
      }
      return null;
    });
    const computeMaps = {};
    const $xeAnchorLink = {
      xID,
      props,
      context,
      reactData,
      linkConfig,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (event) => {
      const { href } = props;
      if ($xeAnchor) {
        $xeAnchor.handleClickLink(event, href);
      }
    };
    watch(() => props.href, (val) => {
      linkConfig.href = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeAnchor && elem) {
        assembleAnchorLink($xeAnchor, elem, linkConfig, $xeParentAnchorLink);
      }
    });
    onUnmounted(() => {
      if ($xeAnchor) {
        destroyAnchorLink($xeAnchor, linkConfig);
      }
    });
    const renderVN = () => {
      const { href, content, title } = props;
      const defaultSlot = slots.default;
      const subSlot = slots.sub;
      const isActive = computeIsActive.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor-link", {
          "is--active": isActive
        }]
      }, [
        h("a", {
          class: "vxe-anchor-link--item",
          href,
          title,
          onClick: clickEvent
        }, defaultSlot ? defaultSlot({}) : import_xe_utils44.default.toValueString(content)),
        subSlot ? h("div", {
          class: "vxe-anchor-link--sub-items"
        }, subSlot({})) : createCommentVNode()
      ]);
    };
    provide("$xeAnchorLink", $xeAnchorLink);
    $xeAnchorLink.renderVN = renderVN;
    return $xeAnchorLink;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/anchor/src/anchor.js
var anchor_default = defineComponent({
  name: "VxeAnchor",
  props: {
    modelValue: String,
    options: Array,
    container: [String, Object, Function],
    showMarker: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils45.default.uniqueId();
    const refElem = ref();
    const refMarkerElem = ref();
    const reactData = reactive({
      activeHref: null,
      staticLinks: [],
      containerElem: null
    });
    const refMaps = {
      refElem
    };
    const computeAllHrefList = computed(() => {
      const list = [];
      import_xe_utils45.default.eachTree(reactData.staticLinks, (item) => {
        list.push(item.href || "");
      }, { children: "children" });
      return list;
    });
    const computeMaps = {};
    const $xeAnchor = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const anchorMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $anchor: $xeAnchor }, params));
      }
    };
    const getContainerElem = () => {
      const { container } = props;
      if (container) {
        if (import_xe_utils45.default.isElement(container)) {
          return container;
        }
        if (import_xe_utils45.default.isString(container)) {
          return document.querySelector(container);
        }
        if (import_xe_utils45.default.isFunction(container)) {
          return container({ $anchor: $xeAnchor });
        }
      }
      return null;
    };
    const emitEvent = (value) => {
      reactData.activeHref = value;
      emit("update:modelValue", value);
    };
    const handleContainerScrollEvent = () => {
      const allHrefList = computeAllHrefList.value;
      const { containerElem } = reactData;
      if (containerElem) {
        const wrapperElList = containerElem.querySelectorAll(allHrefList.map((href) => `${href}`).join(","));
        for (let i = 0; i < wrapperElList.length; i++) {
          const wrapperEl = wrapperElList[i];
          const wrapperRect = wrapperEl.getBoundingClientRect();
          if (wrapperRect.top > 0) {
            const href = wrapperEl.id;
            reactData.activeHref = `#${href}`;
            break;
          }
        }
      }
    };
    const removeContainerElemScroll = () => {
      const { containerElem } = reactData;
      if (containerElem) {
        containerElem.removeEventListener("scroll", handleContainerScrollEvent);
      }
    };
    const updateContainerElem = () => {
      const containerElem = getContainerElem();
      reactData.containerElem = containerElem;
      if (containerElem) {
        containerElem.addEventListener("scroll", handleContainerScrollEvent, {
          passive: false
        });
      }
    };
    const updateMarkerPos = () => {
      nextTick(() => {
        const { activeHref } = reactData;
        const elem = refElem.value;
        const markerEl = refMarkerElem.value;
        if (elem && markerEl) {
          if (activeHref) {
            const linkEl = elem.querySelector(`[href="${activeHref}"]`);
            if (linkEl) {
              const { top } = getOffsetPos2(linkEl, elem);
              markerEl.style.top = `${top}px`;
            }
          }
        }
      });
    };
    const anchorPrivateMethods = {
      handleClickLink(evnt, href) {
        evnt.preventDefault();
        const targetEl = document.getElementById(`${href}`.replace("#", ""));
        if (targetEl) {
          targetEl.scrollIntoView({
            behavior: "smooth"
          });
        }
        emitEvent(href);
        anchorMethods.dispatchEvent("click", { href }, evnt);
      }
    };
    Object.assign($xeAnchor, anchorMethods, anchorPrivateMethods);
    const renderSubItems = (options) => {
      const itemVNs = [];
      if (options) {
        options.forEach((item) => {
          const subItems = item.children;
          if (subItems && subItems.length) {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }, {
              sub: () => renderSubItems(subItems)
            }));
          } else {
            itemVNs.push(h(anchor_link_default, {
              content: item.content,
              title: item.title,
              href: item.href
            }));
          }
        });
      }
      return itemVNs;
    };
    const renderVN = () => {
      const { options, showMarker } = props;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-anchor", {
          "is--marker": showMarker
        }]
      }, [
        h("div", {
          class: "vxe-anchor--list"
        }, defaultSlot ? defaultSlot({}) : renderSubItems(options)),
        showMarker ? h("div", {
          ref: refMarkerElem,
          class: "vxe-anchor--marker"
        }) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeHref = val;
    });
    watch(() => reactData.activeHref, () => {
      updateMarkerPos();
    });
    watch(() => props.container, () => {
      removeContainerElemScroll();
      updateContainerElem();
    });
    onMounted(() => {
      nextTick(() => {
        updateContainerElem();
      });
    });
    onBeforeUnmount(() => {
      removeContainerElemScroll();
    });
    provide("$xeAnchor", $xeAnchor);
    $xeAnchor.renderVN = renderVN;
    return $xeAnchor;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/anchor/index.js
var VxeAnchor = Object.assign({}, anchor_default, {
  install(app) {
    app.component(anchor_default.name, anchor_default);
  }
});
dynamicApp.use(VxeAnchor);
VxeUI.component(anchor_default);
var Anchor = VxeAnchor;
var anchor_default2 = VxeAnchor;

// node_modules/vxe-pc-ui/es/anchor-link/index.js
var VxeAnchorLink = Object.assign({}, anchor_link_default, {
  install(app) {
    app.component(anchor_link_default.name, anchor_link_default);
  }
});
dynamicApp.use(VxeAnchorLink);
VxeUI.component(anchor_link_default);
var AnchorLink = VxeAnchorLink;
var anchor_link_default2 = VxeAnchorLink;

// node_modules/vxe-pc-ui/es/avatar/src/avatar.js
var import_xe_utils46 = __toESM(require_xe_utils());
var avatar_default = defineComponent({
  name: "VxeAvatar",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    icon: String,
    src: String,
    width: [String, Number],
    height: [String, Number],
    circle: {
      type: Boolean,
      default: () => getConfig().avatar.circle
    },
    status: {
      type: String,
      default: () => getConfig().avatar.status
    },
    size: {
      type: String,
      default: () => getConfig().avatar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils46.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeAvatarStyle = computed(() => {
      const { width, height } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeCountNum = computed(() => {
      const { count } = props;
      return count ? import_xe_utils46.default.toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeAvatar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $avatar: $xeAvatar }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeAvatar, collapsePaneMethods, collapsePanePrivateMethods);
    const renderContent = () => {
      const { icon, content, src } = props;
      if (icon) {
        return h("span", {
          class: "vxe-avatar--icon"
        }, [
          h("i", {
            class: icon
          })
        ]);
      }
      if (content) {
        return h("span", {
          class: "vxe-avatar--content"
        }, `${content}`);
      }
      if (src) {
        return h("img", {
          class: "vxe-avatar--img",
          src
        });
      }
      return renderEmptyElement($xeAvatar);
    };
    const renderVN = () => {
      const { circle, dot, status } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const avatarStyle = computeAvatarStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-avatar", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--circle": circle,
          "is--dot": dot
        }],
        style: avatarStyle
      }, [
        renderContent(),
        countNum ? h("span", {
          class: "vxe-avatar--count"
        }, countNum > 99 ? "99+" : `${countNum}`) : renderEmptyElement($xeAvatar)
      ]);
    };
    $xeAvatar.renderVN = renderVN;
    return $xeAvatar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/avatar/index.js
var VxeAvatar = Object.assign({}, avatar_default, {
  install(app) {
    app.component(avatar_default.name, avatar_default);
  }
});
dynamicApp.use(VxeAvatar);
VxeUI.component(avatar_default);
var Avatar = VxeAvatar;
var avatar_default2 = VxeAvatar;

// node_modules/vxe-pc-ui/es/badge/src/badge.js
var import_xe_utils47 = __toESM(require_xe_utils());
var badge_default = defineComponent({
  name: "VxeBadge",
  props: {
    count: [String, Number],
    dot: Boolean,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().badge.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils47.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCountNum = computed(() => {
      const { count } = props;
      return count ? import_xe_utils47.default.toNumber(count) : 0;
    });
    const computeMaps = {};
    const $xeBadge = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $badge: $xeBadge }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeBadge, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { dot, content } = props;
      const vSize = computeSize.value;
      const countNum = computeCountNum.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-badge", {
          [`size--${vSize}`]: vSize,
          "is--dot": dot
        }]
      }, [
        defaultSlot || content ? h("div", {
          class: "vxe-badge--content"
        }, defaultSlot ? defaultSlot({}) : `${content || ""}`) : [],
        countNum ? h("span", {
          class: "vxe-badge--count"
        }, countNum > 99 ? "99+" : `${countNum}`) : renderEmptyElement($xeBadge)
      ]);
    };
    $xeBadge.renderVN = renderVN;
    return $xeBadge;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/badge/index.js
var VxeBadge = Object.assign({}, badge_default, {
  install(app) {
    app.component(badge_default.name, badge_default);
  }
});
dynamicApp.use(VxeBadge);
VxeUI.component(badge_default);
var Badge = VxeBadge;
var badge_default2 = VxeBadge;

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var import_xe_utils49 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb-item.js
var import_xe_utils48 = __toESM(require_xe_utils());
var breadcrumb_item_default = defineComponent({
  name: "VxeBreadcrumbItem",
  props: {
    title: String,
    routerLink: Object
  },
  emits: [],
  setup(props, context) {
    const { slots } = context;
    const xID = import_xe_utils48.default.uniqueId();
    const refElem = ref();
    const $xeBreadcrumb = inject("$xeBreadcrumb", null);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeSeparator = computed(() => {
      if ($xeBreadcrumb) {
        return $xeBreadcrumb.props.separator;
      }
      return "";
    });
    const clickEvent = (evnt) => {
      if ($xeBreadcrumb) {
        const item = {
          title: props.title,
          routerLink: props.routerLink
        };
        $xeBreadcrumb.handleClickLink(evnt, item);
      }
    };
    const computeMaps = {};
    const $xeBreadcrumbItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const renderVN = () => {
      const { title, routerLink } = props;
      const separator = computeSeparator.value;
      const defaultSlot = slots.default;
      return h("span", {
        ref: refElem,
        class: "vxe-breadcrumb-item",
        onClick: clickEvent
      }, [
        h("span", {
          class: "vxe-breadcrumb-item--content"
        }, [
          routerLink ? h(resolveComponent("router-link"), {
            class: "vxe-breadcrumb-item--content-link",
            title,
            to: routerLink
          }, {
            default() {
              return h("span", {
                class: "vxe-breadcrumb-item--content-text"
              }, defaultSlot ? defaultSlot({}) : `${title || ""}`);
            }
          }) : h("span", {
            class: "vxe-breadcrumb-item--content-text"
          }, defaultSlot ? defaultSlot({}) : `${title || ""}`)
        ]),
        separator ? h("span", {
          class: "vxe-breadcrumb-item--separator"
        }, `${separator}`) : createCommentVNode()
      ]);
    };
    $xeBreadcrumbItem.renderVN = renderVN;
    return $xeBreadcrumbItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/breadcrumb/src/breadcrumb.js
var breadcrumb_default = defineComponent({
  name: "VxeBreadcrumb",
  props: {
    separator: {
      type: String,
      default: () => getConfig().breadcrumb.separator
    },
    options: Array
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils49.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeBreadcrumb = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const breadcrumbMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $breadcrumb: $xeBreadcrumb }, params));
      }
    };
    const breadcrumbPrivateMethods = {
      handleClickLink(evnt, option2) {
        breadcrumbMethods.dispatchEvent("click", { option: option2 }, evnt);
      }
    };
    Object.assign($xeBreadcrumb, breadcrumbMethods, breadcrumbPrivateMethods);
    const renderItems = () => {
      const { options } = props;
      if (options && options.length) {
        return options.map((item) => {
          return h(breadcrumb_item_default, {
            title: item.title,
            routerLink: item.routerLink
          });
        });
      }
      return [];
    };
    const renderVN = () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: "vxe-breadcrumb"
      }, defaultSlot ? defaultSlot({}) : renderItems());
    };
    provide("$xeBreadcrumb", $xeBreadcrumb);
    $xeBreadcrumb.renderVN = renderVN;
    return $xeBreadcrumb;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/breadcrumb/index.js
var VxeBreadcrumb = Object.assign({}, breadcrumb_default, {
  install(app) {
    app.component(breadcrumb_default.name, breadcrumb_default);
  }
});
dynamicApp.use(VxeBreadcrumb);
VxeUI.component(breadcrumb_default);
var Breadcrumb = VxeBreadcrumb;
var breadcrumb_default2 = VxeBreadcrumb;

// node_modules/vxe-pc-ui/es/breadcrumb-item/index.js
var VxeBreadcrumbItem = Object.assign({}, breadcrumb_item_default, {
  install(app) {
    app.component(breadcrumb_item_default.name, breadcrumb_item_default);
  }
});
dynamicApp.use(VxeBreadcrumbItem);
VxeUI.component(breadcrumb_item_default);
var BreadcrumbItem = VxeBreadcrumbItem;
var breadcrumb_item_default2 = VxeBreadcrumbItem;

// node_modules/vxe-pc-ui/es/button/src/button.js
var import_xe_utils51 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/tooltip/src/tooltip.js
var import_xe_utils50 = __toESM(require_xe_utils());
var tooltip_default = defineComponent({
  name: "VxeTooltip",
  props: {
    modelValue: Boolean,
    size: {
      type: String,
      default: () => getConfig().tooltip.size || getConfig().size
    },
    selector: String,
    trigger: {
      type: String,
      default: () => getConfig().tooltip.trigger || "hover"
    },
    theme: {
      type: String,
      default: () => getConfig().tooltip.theme || "dark"
    },
    content: {
      type: [String, Number],
      default: null
    },
    useHTML: Boolean,
    zIndex: [String, Number],
    popupClassName: [String, Function],
    isArrow: {
      type: Boolean,
      default: () => getConfig().tooltip.isArrow
    },
    enterable: {
      type: Boolean,
      default: () => getConfig().tooltip.enterable
    },
    enterDelay: {
      type: Number,
      default: () => getConfig().tooltip.enterDelay
    },
    leaveDelay: {
      type: Number,
      default: () => getConfig().tooltip.leaveDelay
    }
  },
  emits: [
    "update:modelValue"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils50.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      target: null,
      isUpdate: false,
      visible: false,
      tipContent: "",
      tipActive: false,
      tipTarget: null,
      tipZindex: 0,
      tipStore: {
        style: {},
        placement: "",
        arrowStyle: {}
      }
    });
    const internalData = {};
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeTooltip = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let tooltipMethods = {};
    const updateTipStyle = () => {
      const { tipTarget, tipStore } = reactData;
      if (tipTarget) {
        const { scrollTop, scrollLeft, visibleWidth } = getDomNode2();
        const { top, left } = getAbsolutePos2(tipTarget);
        const el2 = refElem.value;
        const marginSize = 6;
        const offsetHeight = el2.offsetHeight;
        const offsetWidth = el2.offsetWidth;
        let tipLeft = left;
        let tipTop = top - offsetHeight - marginSize;
        tipLeft = Math.max(marginSize, left + Math.floor((tipTarget.offsetWidth - offsetWidth) / 2));
        if (tipLeft + offsetWidth + marginSize > scrollLeft + visibleWidth) {
          tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize;
        }
        if (top - offsetHeight < scrollTop + marginSize) {
          tipStore.placement = "bottom";
          tipTop = top + tipTarget.offsetHeight + marginSize;
        }
        tipStore.style.top = `${tipTop}px`;
        tipStore.style.left = `${tipLeft}px`;
        tipStore.arrowStyle.left = `${left - tipLeft + tipTarget.offsetWidth / 2}px`;
      }
    };
    const updateValue = (value) => {
      if (value !== reactData.visible) {
        reactData.visible = value;
        reactData.isUpdate = true;
        emit("update:modelValue", value);
      }
    };
    const updateZindex = () => {
      if (reactData.tipZindex < getLastZIndex2()) {
        reactData.tipZindex = nextZIndex2();
      }
    };
    const clickEvent = () => {
      if (reactData.visible) {
        tooltipMethods.close();
      } else {
        handleVisible(reactData.target || getSelectorEl(), props.content);
      }
    };
    const targetMouseenterEvent = () => {
      handleVisible(reactData.target || getSelectorEl(), props.content);
    };
    const targetMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      } else {
        tooltipMethods.close();
      }
    };
    const wrapperMouseenterEvent = () => {
      reactData.tipActive = true;
    };
    const wrapperMouseleaveEvent = () => {
      const { trigger, enterable, leaveDelay } = props;
      reactData.tipActive = false;
      if (enterable && trigger === "hover") {
        setTimeout(() => {
          if (!reactData.tipActive) {
            tooltipMethods.close();
          }
        }, leaveDelay);
      }
    };
    const showTip = () => {
      const { tipStore } = reactData;
      const el2 = refElem.value;
      if (el2) {
        const parentNode = el2.parentNode;
        if (!parentNode) {
          document.body.appendChild(el2);
        }
      }
      updateValue(true);
      updateZindex();
      tipStore.placement = "top";
      tipStore.style = { width: "auto", left: 0, top: 0, zIndex: props.zIndex || reactData.tipZindex };
      tipStore.arrowStyle = { left: "50%" };
      return tooltipMethods.updatePlacement();
    };
    const handleDelayFn = () => {
      internalData.showDelayTip = import_xe_utils50.default.debounce(() => {
        if (reactData.tipActive) {
          showTip();
        }
      }, props.enterDelay, { leading: false, trailing: true });
    };
    const handleVisible = (target, content) => {
      const contentSlot = slots.content;
      if (!contentSlot && (content === "" || import_xe_utils50.default.eqNull(content))) {
        return nextTick();
      }
      if (target) {
        const { showDelayTip } = internalData;
        const { trigger, enterDelay } = props;
        reactData.tipActive = true;
        reactData.tipTarget = target;
        reactData.tipContent = content;
        if (enterDelay && trigger === "hover") {
          if (showDelayTip) {
            showDelayTip();
          }
        } else {
          return showTip();
        }
      }
      return nextTick();
    };
    const getSelectorEl = () => {
      const { selector } = props;
      if (selector) {
        if (import_xe_utils50.default.isElement(selector)) {
          return selector;
        }
        if (import_xe_utils50.default.isString(selector)) {
          return document.querySelector(selector);
        }
      }
      return null;
    };
    tooltipMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $tooltip: $xeTooltip }, params));
      },
      open(target, content) {
        return handleVisible(target || reactData.target || getSelectorEl(), content);
      },
      close() {
        reactData.tipTarget = null;
        reactData.tipActive = false;
        Object.assign(reactData.tipStore, {
          style: {},
          placement: "",
          arrowStyle: null
        });
        updateValue(false);
        return nextTick();
      },
      toVisible(target, content) {
        return handleVisible(target, content);
      },
      updatePlacement() {
        return nextTick().then(() => {
          const { tipTarget } = reactData;
          const el2 = refElem.value;
          if (tipTarget && el2) {
            updateTipStyle();
            return nextTick().then(() => {
              updateTipStyle();
            });
          }
        });
      },
      isActived() {
        return reactData.tipActive;
      },
      setActived(active) {
        reactData.tipActive = !!active;
      }
    };
    Object.assign($xeTooltip, tooltipMethods);
    const renderContent = () => {
      const { useHTML } = props;
      const { tipContent } = reactData;
      const contentSlot = slots.content;
      if (contentSlot) {
        return h("div", {
          key: 1,
          class: "vxe-table--tooltip-content"
        }, getSlotVNs2(contentSlot({})));
      }
      if (useHTML) {
        return h("div", {
          key: 2,
          class: "vxe-table--tooltip-content",
          innerHTML: tipContent
        });
      }
      return h("div", {
        key: 3,
        class: "vxe-table--tooltip-content"
      }, `${tipContent}`);
    };
    const renderVN = () => {
      const { popupClassName, theme, isArrow, enterable } = props;
      const { tipActive, visible, tipStore } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      let ons;
      if (enterable) {
        ons = {
          onMouseenter: wrapperMouseenterEvent,
          onMouseleave: wrapperMouseleaveEvent
        };
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-table--tooltip-wrapper", `theme--${theme}`, popupClassName ? import_xe_utils50.default.isFunction(popupClassName) ? popupClassName({ $tooltip: $xeTooltip }) : popupClassName : "", {
        [`size--${vSize}`]: vSize,
        [`placement--${tipStore.placement}`]: tipStore.placement,
        "is--enterable": enterable,
        "is--visible": visible,
        "is--arrow": isArrow,
        "is--active": tipActive
      }], style: tipStore.style }, ons), [
        renderContent(),
        h("div", {
          class: "vxe-table--tooltip-arrow",
          style: tipStore.arrowStyle
        }),
        ...defaultSlot ? getSlotVNs2(defaultSlot({})) : []
      ]);
    };
    watch(() => props.enterDelay, () => {
      handleDelayFn();
    });
    watch(() => props.content, (val) => {
      reactData.tipContent = val;
    });
    watch(() => props.modelValue, (val) => {
      if (!reactData.isUpdate) {
        if (val) {
          handleVisible(reactData.target || getSelectorEl(), props.content);
        } else {
          tooltipMethods.close();
        }
      }
      reactData.isUpdate = false;
    });
    onMounted(() => {
      nextTick(() => {
        const { trigger, content } = props;
        const wrapperElem = refElem.value;
        if (wrapperElem) {
          const parentNode = wrapperElem.parentNode;
          if (parentNode) {
            reactData.tipContent = content;
            reactData.tipZindex = nextZIndex2();
            import_xe_utils50.default.arrayEach(wrapperElem.children, (elem, index2) => {
              if (index2 > 1) {
                parentNode.insertBefore(elem, wrapperElem);
                if (!reactData.target) {
                  reactData.target = elem;
                }
              }
            });
            parentNode.removeChild(wrapperElem);
            const { target } = reactData;
            if (target) {
              if (trigger === "hover") {
                target.onmouseenter = targetMouseenterEvent;
                target.onmouseleave = targetMouseleaveEvent;
              } else if (trigger === "click") {
                target.onclick = clickEvent;
              }
            }
            if (props.modelValue) {
              handleVisible(target || getSelectorEl(), content);
            }
          }
        }
      });
    });
    onBeforeUnmount(() => {
      const { target } = reactData;
      const wrapperElem = refElem.value;
      if (target) {
        target.onmouseenter = null;
        target.onmouseleave = null;
        target.onclick = null;
      }
      if (wrapperElem) {
        const parentNode = wrapperElem.parentNode;
        if (parentNode) {
          parentNode.removeChild(wrapperElem);
        }
      }
    });
    handleDelayFn();
    $xeTooltip.renderVN = renderVN;
    return $xeTooltip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/button/src/button.js
var button_default = defineComponent({
  name: "VxeButton",
  props: {
    /**
     * 按钮类型
     */
    type: String,
    mode: String,
    className: [String, Function],
    popupClassName: [String, Function],
    /**
     * 按钮尺寸
     */
    size: {
      type: String,
      default: () => getConfig().button.size || getConfig().size
    },
    /**
     * 用来标识这一项
     */
    name: [String, Number],
    routerLink: Object,
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    /**
     * 按钮内容
     */
    content: String,
    /**
     * 固定显示下拉面板的方向
     */
    placement: String,
    /**
     * 按钮状态
     */
    status: String,
    /**
     * 标题
     */
    title: String,
    /**
     * 按钮的图标
     */
    icon: String,
    /**
     * 圆角边框
     */
    round: Boolean,
    /**
     * 圆角按钮
     */
    circle: Boolean,
    /**
     * 是否禁用
     */
    disabled: Boolean,
    /**
     * 是否加载中
     */
    loading: Boolean,
    trigger: {
      type: String,
      default: () => getConfig().button.trigger
    },
    align: String,
    prefixTooltip: Object,
    suffixTooltip: Object,
    /**
     * 在下拉面板关闭时销毁内容
     */
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().button.destroyOnClose
    },
    /**
     * 是否将弹框容器插入于 body 内
     */
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "click",
    "mouseenter",
    "mouseleave",
    "dropdown-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const $xeButtonGroup = inject("$xeButtonGroup", null);
    const xID = import_xe_utils51.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const reactData = reactive({
      initialized: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: ""
    });
    const internalData = {
      showTime: void 0,
      tooltipTimeout: void 0
    };
    const refElem = ref();
    const refButton = ref();
    const refBtnPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeButton = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let buttonMethods = {};
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().button.transfer;
        if (import_xe_utils51.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeBtnDisabled = computed(() => {
      const { disabled } = props;
      const permissionInfo = computePermissionInfo.value;
      return disabled || permissionInfo.disabled;
    });
    const computeIsFormBtn = computed(() => {
      const { type } = props;
      if (type) {
        return ["submit", "reset", "button"].indexOf(type) > -1;
      }
      return false;
    });
    const computeBtnMode = computed(() => {
      const { type, mode } = props;
      if (mode === "text" || type === "text" || $xeButtonGroup && $xeButtonGroup.props.mode === "text") {
        return "text";
      }
      return "button";
    });
    const computeBtnStatus = computed(() => {
      const { status } = props;
      if (status) {
        return status;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.status;
      }
      return "";
    });
    const computeBtnRound = computed(() => {
      const { round } = props;
      if (round) {
        return round;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.round;
      }
      return false;
    });
    const computeBtnCircle = computed(() => {
      const { circle } = props;
      if (circle) {
        return circle;
      }
      if ($xeButtonGroup) {
        return $xeButtonGroup.props.circle;
      }
      return false;
    });
    const computePrefixTipOpts = computed(() => {
      return Object.assign({}, props.prefixTooltip);
    });
    const computeSuffixTipOpts = computed(() => {
      return Object.assign({}, props.suffixTooltip);
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refButton.value;
        const panelElem = refBtnPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && targetElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { top, left, boundingTop, visibleHeight, visibleWidth } = getAbsolutePos2(targetElem);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let btnLeft = left + targetWidth - panelWidth;
            let btnTop = top + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              btnTop = top - panelHeight;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                btnTop = top - panelHeight;
              }
              if (btnTop < marginSize) {
                panelPlacement = "bottom";
                btnTop = top + targetHeight;
              }
            }
            if (btnLeft + panelWidth + marginSize > visibleWidth) {
              btnLeft -= btnLeft + panelWidth + marginSize - visibleWidth;
            }
            if (btnLeft < marginSize) {
              btnLeft = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${btnLeft}px`,
              right: "auto",
              top: `${btnTop}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const clickEvent = (evnt) => {
      if ($xeButtonGroup) {
        $xeButtonGroup.handleClick({ name: props.name }, evnt);
      } else {
        dispatchEvent2("click", { $event: evnt }, evnt);
      }
    };
    const mousedownDropdownEvent = (evnt) => {
      const isLeftBtn = evnt.button === 0;
      if (isLeftBtn) {
        evnt.stopPropagation();
      }
    };
    const clickDropdownEvent = (evnt) => {
      const dropdownElem = evnt.currentTarget;
      const panelElem = refBtnPanel.value;
      const { flag, targetElem } = getEventTargetNode2(evnt, dropdownElem, "vxe-button");
      if (flag) {
        if (panelElem) {
          panelElem.dataset.active = "N";
        }
        reactData.visiblePanel = false;
        setTimeout(() => {
          if (!panelElem || panelElem.dataset.active !== "Y") {
            reactData.isAniVisible = false;
          }
        }, 350);
        dispatchEvent2("dropdown-click", { name: targetElem.getAttribute("name"), $event: evnt }, evnt);
      }
    };
    const mouseenterDropdownEvent = () => {
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        reactData.isAniVisible = true;
        setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            reactData.visiblePanel = true;
            updateZindex();
            updatePlacement();
            setTimeout(() => {
              if (reactData.visiblePanel) {
                updatePlacement();
              }
            }, 50);
          }
        }, 20);
      }
    };
    const mouseenterTargetEvent = (evnt) => {
      const { loading: loading2 } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading2)) {
        openPanel();
        mouseenterEvent(evnt);
      }
    };
    const mouseleaveTargetEvent = (evnt) => {
      closePanel();
      mouseleaveEvent(evnt);
    };
    const mouseenterEvent = (evnt) => {
      dispatchEvent2("mouseenter", {}, evnt);
    };
    const mouseleaveEvent = (evnt) => {
      dispatchEvent2("mouseleave", {}, evnt);
    };
    const clickTargetEvent = (evnt) => {
      const { loading: loading2, trigger } = props;
      const btnDisabled = computeBtnDisabled.value;
      if (!(btnDisabled || loading2)) {
        if (trigger === "click") {
          if (reactData.visiblePanel) {
            closePanel();
          } else {
            openPanel();
          }
        }
        clickEvent(evnt);
      }
    };
    const openPanel = () => {
      const { trigger } = props;
      const panelElem = refBtnPanel.value;
      if (panelElem) {
        panelElem.dataset.active = "Y";
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        internalData.showTime = setTimeout(() => {
          if (panelElem.dataset.active === "Y") {
            mouseenterDropdownEvent();
          } else {
            reactData.isAniVisible = false;
          }
        }, trigger === "click" ? 50 : 250);
      }
      return nextTick();
    };
    const closePanel = () => {
      const panelElem = refBtnPanel.value;
      clearTimeout(internalData.showTime);
      if (panelElem) {
        panelElem.dataset.active = "N";
        setTimeout(() => {
          if (panelElem.dataset.active !== "Y") {
            reactData.visiblePanel = false;
            setTimeout(() => {
              if (panelElem.dataset.active !== "Y") {
                reactData.isAniVisible = false;
              }
            }, 350);
          }
        }, 100);
      } else {
        reactData.isAniVisible = false;
        reactData.visiblePanel = false;
      }
      return nextTick();
    };
    const mouseleaveDropdownEvent = () => {
      closePanel();
    };
    const renderTooltipIcon = (tipOpts, type) => {
      return h(tooltip_default, {
        useHTML: tipOpts.useHTML,
        content: tipOpts.content,
        enterable: tipOpts.enterable,
        theme: tipOpts.theme
      }, {
        default() {
          return h("i", {
            class: [`vxe-button--tooltip-${type}-icon`, tipOpts.icon || getIcon().BUTTON_TOOLTIP_ICON]
          });
        }
      });
    };
    const renderContent = () => {
      const { content, icon, loading: loading2, prefixTooltip, suffixTooltip } = props;
      const prefixTipOpts = computePrefixTipOpts.value;
      const suffixTipOpts = computeSuffixTipOpts.value;
      const iconSlot = slots.icon;
      const defaultSlot = slots.default;
      const contVNs = [];
      if (prefixTooltip) {
        contVNs.push(renderTooltipIcon(prefixTipOpts, "prefix"));
      }
      if (loading2) {
        contVNs.push(h("i", {
          class: ["vxe-button--loading-icon", getIcon().BUTTON_LOADING]
        }));
      } else if (iconSlot) {
        contVNs.push(h("span", {
          class: "vxe-button--custom-icon"
        }, iconSlot({})));
      } else if (icon) {
        contVNs.push(h("i", {
          class: ["vxe-button--icon", icon]
        }));
      }
      if (defaultSlot) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, defaultSlot({})));
      } else if (content) {
        contVNs.push(h("span", {
          class: "vxe-button--content"
        }, getFuncText2(content)));
      }
      if (suffixTooltip) {
        contVNs.push(renderTooltipIcon(suffixTipOpts, "suffix"));
      }
      return contVNs;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $button: $xeButton }, params));
    };
    buttonMethods = {
      dispatchEvent: dispatchEvent2,
      openPanel,
      closePanel,
      focus() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.focus();
        }
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        return nextTick();
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const panelElem = refBtnPanel.value;
      if (reactData.visiblePanel && !getEventTargetNode2(evnt, panelElem).flag) {
        closePanel();
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const btnDisabled = computeBtnDisabled.value;
      const { visiblePanel } = reactData;
      if (!btnDisabled) {
        const el2 = refElem.value;
        const panelElem = refBtnPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          closePanel();
        }
      }
    };
    Object.assign($xeButton, buttonMethods);
    const renderVN = () => {
      const { className, popupClassName, align, trigger, title, routerLink, type, destroyOnClose, name, loading: loading2 } = props;
      const { initialized, isAniVisible, visiblePanel } = reactData;
      const isFormBtn = computeIsFormBtn.value;
      const btnMode = computeBtnMode.value;
      const btnStatus = computeBtnStatus.value;
      const btnRound = computeBtnRound.value;
      const btnCircle = computeBtnCircle.value;
      const btnTransfer = computeBtnTransfer.value;
      const btnDisabled = computeBtnDisabled.value;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      const downsSlot = slots.dropdowns;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      if (downsSlot) {
        const btnOns = {};
        const panelOns = {};
        if (trigger === "hover") {
          btnOns.onMouseenter = mouseenterTargetEvent;
          btnOns.onMouseleave = mouseleaveTargetEvent;
          panelOns.onMouseenter = mouseenterDropdownEvent;
          panelOns.onMouseleave = mouseleaveDropdownEvent;
        }
        return h("div", {
          ref: refElem,
          class: ["vxe-button--dropdown", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
            [`size--${vSize}`]: vSize,
            "is--active": visiblePanel
          }]
        }, [
          routerLink ? h(resolveComponent("router-link"), Object.assign({
            ref: refButton,
            class: ["vxe-button", "vxe-button--link", `type--${btnMode}`, align ? `align--${align}` : "", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": btnDisabled || loading2,
              "is--loading": loading2
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: btnDisabled || loading2,
            to: routerLink,
            onClick: clickTargetEvent
          }, btnOns), {
            default() {
              return renderContent().concat([
                h("i", {
                  class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
                })
              ]);
            }
          }) : h("button", Object.assign({
            ref: refButton,
            class: ["vxe-button", `type--${btnMode}`, align ? `align--${align}` : "", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
              [`size--${vSize}`]: vSize,
              [`theme--${btnStatus}`]: btnStatus,
              "is--round": btnRound,
              "is--circle": btnCircle,
              "is--disabled": btnDisabled || loading2,
              "is--loading": loading2
            }],
            title,
            name,
            type: isFormBtn ? type : "button",
            disabled: btnDisabled || loading2,
            onClick: clickTargetEvent
          }, btnOns), renderContent().concat([
            h("i", {
              class: `vxe-button--dropdown-arrow ${getIcon().BUTTON_DROPDOWN}`
            })
          ])),
          h(Teleport, {
            to: "body",
            disabled: btnTransfer ? !initialized : true
          }, [
            h("div", Object.assign({ ref: refBtnPanel, class: ["vxe-button--dropdown-panel", popupClassName ? import_xe_utils51.default.isFunction(popupClassName) ? popupClassName({ $button: $xeButton }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }], placement: reactData.panelPlacement, style: reactData.panelStyle }, panelOns), initialized && (visiblePanel || isAniVisible) ? [
              h("div", {
                class: "vxe-button--dropdown-wrapper",
                onMousedown: mousedownDropdownEvent,
                onClick: clickDropdownEvent
              }, destroyOnClose && !visiblePanel ? [] : downsSlot({}))
            ] : [])
          ])
        ]);
      }
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          ref: refButton,
          class: ["vxe-button", "vxe-button--link", `type--${btnMode}`, align ? `align--${align}` : "", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
            [`size--${vSize}`]: vSize,
            [`theme--${btnStatus}`]: btnStatus,
            "is--round": btnRound,
            "is--circle": btnCircle,
            "is--disabled": btnDisabled || loading2,
            "is--loading": loading2
          }],
          title,
          name,
          type: isFormBtn ? type : "button",
          disabled: btnDisabled || loading2,
          to: routerLink,
          onClick: clickEvent,
          onMouseenter: mouseenterEvent,
          onMouseleave: mouseleaveEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("button", {
        ref: refButton,
        class: ["vxe-button", `type--${btnMode}`, align ? `align--${align}` : "", className ? import_xe_utils51.default.isFunction(className) ? className({ $button: $xeButton }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`theme--${btnStatus}`]: btnStatus,
          "is--round": btnRound,
          "is--circle": btnCircle,
          "is--disabled": btnDisabled || loading2,
          "is--loading": loading2
        }],
        title,
        name,
        type: isFormBtn ? type : "button",
        disabled: btnDisabled || loading2,
        onClick: clickEvent,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, renderContent());
    };
    $xeButton.renderVN = renderVN;
    onMounted(() => {
      if (true) {
        if (props.type === "text") {
          warnLog2("vxe.error.delProp", ["type=text", "mode=text"]);
        }
      }
      globalEvents.on($xeButton, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeButton, "mousedown", handleGlobalMousedownEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeButton, "mousewheel");
      globalEvents.off($xeButton, "mousedown");
    });
    return $xeButton;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/button/index.js
var VxeButton = Object.assign({}, button_default, {
  install(app) {
    app.component(button_default.name, button_default);
  }
});
dynamicApp.use(VxeButton);
VxeUI.component(button_default);
var Button = VxeButton;
var button_default2 = VxeButton;

// node_modules/vxe-pc-ui/es/button/src/button-group.js
var import_xe_utils52 = __toESM(require_xe_utils());
var button_group_default = defineComponent({
  name: "VxeButtonGroup",
  props: {
    options: Array,
    mode: String,
    status: String,
    round: Boolean,
    circle: Boolean,
    className: [String, Function],
    disabled: Boolean,
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().buttonGroup.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils52.default.uniqueId();
    const computeMaps = {};
    const $xeButtonGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const buttonGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $buttonGroup: $xeButtonGroup }, params));
      }
    };
    const buttonGroupPrivateMethods = {
      handleClick(params, evnt) {
        const { options } = props;
        const { name } = params;
        const option2 = options ? options.find((item) => item.name === name) : null;
        buttonGroupMethods.dispatchEvent("click", Object.assign(Object.assign({}, params), { option: option2 }), evnt);
      }
    };
    Object.assign($xeButtonGroup, buttonGroupMethods, buttonGroupPrivateMethods);
    const renderVN = () => {
      const { className, options } = props;
      const permissionInfo = computePermissionInfo.value;
      const defaultSlot = slots.default;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      return h("div", {
        class: ["vxe-button-group", className ? import_xe_utils52.default.isFunction(className) ? className({ $buttonGroup: $xeButtonGroup }) : className : ""]
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item, index2) => {
        return h(button_default, Object.assign({ key: index2 }, item));
      }) : []);
    };
    $xeButtonGroup.renderVN = renderVN;
    provide("$xeButtonGroup", $xeButtonGroup);
    return $xeButtonGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/button-group/index.js
var VxeButtonGroup = Object.assign({}, button_group_default, {
  install(app) {
    app.component(button_group_default.name, button_group_default);
  }
});
dynamicApp.use(VxeButtonGroup);
VxeUI.component(button_group_default);
var ButtonGroup = VxeButtonGroup;
var button_group_default2 = VxeButtonGroup;

// node_modules/vxe-pc-ui/es/date-picker/src/util.js
var import_xe_utils53 = __toESM(require_xe_utils());
function toStringTimeDate(str) {
  if (str) {
    const rest = /* @__PURE__ */ new Date();
    let h10 = 0;
    let m = 0;
    let s = 0;
    if (import_xe_utils53.default.isDate(str)) {
      h10 = str.getHours();
      m = str.getMinutes();
      s = str.getSeconds();
    } else {
      str = import_xe_utils53.default.toValueString(str);
      const parses = str.match(/^(\d{1,2})(:(\d{1,2}))?(:(\d{1,2}))?/);
      if (parses) {
        h10 = import_xe_utils53.default.toNumber(parses[1]);
        m = import_xe_utils53.default.toNumber(parses[3]);
        s = import_xe_utils53.default.toNumber(parses[5]);
      }
    }
    rest.setHours(h10);
    rest.setMinutes(m);
    rest.setSeconds(s);
    return rest;
  }
  return /* @__PURE__ */ new Date("");
}
function getDateQuarter(date) {
  const month = date.getMonth();
  if (month < 3) {
    return 1;
  } else if (month < 6) {
    return 2;
  } else if (month < 9) {
    return 3;
  }
  return 4;
}

// node_modules/vxe-pc-ui/es/calendar/src/calendar.js
var import_xe_utils54 = __toESM(require_xe_utils());
var calendar_default = defineComponent({
  name: "VxeCalendar",
  props: {
    modelValue: [String, Number, Date],
    type: {
      type: String,
      default: "date"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().calendar.size || getConfig().size
    },
    multiple: Boolean,
    width: [String, Number],
    height: [String, Number],
    // date、week、month、quarter、year
    minDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.minDate
    },
    maxDate: {
      type: [String, Number, Date],
      default: () => getConfig().calendar.maxDate
    },
    startDay: {
      type: [String, Number],
      default: () => getConfig().calendar.startDay
    },
    labelFormat: String,
    valueFormat: String,
    festivalMethod: {
      type: Function,
      default: () => getConfig().calendar.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().calendar.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().calendar.selectDay
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils54.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      selectValue: props.modelValue,
      inputValue: props.modelValue,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8
    };
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const $xeCalendar = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let calendarMethods = {};
    const computeCalendarStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeIsDisabled = computed(() => {
      return false;
    });
    const computeIsCalendarType = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateStartTime = computed(() => {
      return props.minDate ? import_xe_utils54.default.toStringDate(props.minDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.maxDate ? import_xe_utils54.default.toStringDate(props.maxDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { multiple } = props;
      const { selectValue } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && selectValue && isCalendarType) {
        return import_xe_utils54.default.toValueString(selectValue).split(",").map((item) => {
          const date = parseDate2(item, dateValueFormat);
          if (import_xe_utils54.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils54.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils54.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { selectValue } = reactData;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (selectValue && isCalendarType) {
        const date = parseDate2(selectValue, dateValueFormat);
        if (import_xe_utils54.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      return dateValue ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isCalendarType = computeIsCalendarType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (isCalendarType) {
        return labelFormat || dateValueFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { yearSize } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index2 = -4; index2 < yearSize + 4; index2++) {
          const date = import_xe_utils54.default.getWhatYear(startYearDate, index2, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index2 < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index2 >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return getI18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return getI18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return getI18n("vxe.input.date.dayLabel", [year, month ? getI18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay } = props;
      return import_xe_utils54.default.toNumber(startDay);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index2 = 0; index2 < 6; index2++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils54.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { quarterSize } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils54.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index2 = -2; index2 < quarterSize - 2; index2++) {
          const date = import_xe_utils54.default.getWhatQuarter(firstYear, index2);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils54.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { monthSize } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils54.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index2 = -4; index2 < monthSize - 4; index2++) {
          const date = import_xe_utils54.default.getWhatYear(selectMonth, 0, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils54.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils54.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index2 = 0; index2 < 42; index2++) {
          const date = import_xe_utils54.default.getWhatDay(startDayDate, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils54.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils54.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const parseDate2 = (value, format4) => {
      return import_xe_utils54.default.toStringDate(value, format4);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils54.default.toValueString(props.modelValue) !== value) {
        calendarMethods.dispatchEvent("change", { value }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate2(value, dateValueFormat);
      }
      if (import_xe_utils54.default.isValidDate(dValue)) {
        dLabel = import_xe_utils54.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils54.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      const { inputValue } = reactData;
      if (isCalendarType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        changeValue();
      }
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils54.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils54.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils54.default.toNumber(props.selectDay);
        date = import_xe_utils54.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      }
      const inpVal = import_xe_utils54.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      reactData.selectValue = date;
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (dateMultipleValue.some((val) => import_xe_utils54.default.isEqual(val, inpVal))) {
          handleChange(dateMultipleValue.filter((val) => !import_xe_utils54.default.isEqual(val, inpVal)).join(","), { type: "update" });
        } else {
          handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
        }
      } else {
        if (!import_xe_utils54.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils54.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils54.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const { yearSize } = internalData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, -1, "first");
          } else {
            reactData.selectMonth = import_xe_utils54.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        calendarMethods.dispatchEvent("date-prev", { type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
      }
      calendarMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth } = reactData;
      const { yearSize } = internalData;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        if (type === "year") {
          reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            reactData.selectMonth = import_xe_utils54.default.getWhatYear(selectMonth, 1, "first");
          } else {
            reactData.selectMonth = import_xe_utils54.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        calendarMethods.dispatchEvent("date-next", { type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      return disabledMethod && disabledMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $calendar: $xeCalendar });
    };
    const dateSelectItem = (date) => {
      const { type } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
        }
      } else if (type === "year") {
        dateChange(date);
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils54.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils54.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils54.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils54.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const dateConfirmEvent = () => {
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils54.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $calendar: $xeCalendar });
        const festivalItem = festivalRest ? import_xe_utils54.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils54.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-calendar--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label || ""}`),
            h("span", {
              class: ["vxe-calendar--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils54.default.toValueString(extraItem.label))
          ] : [`${label || ""}`])
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils54.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-calendar--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-calendar--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-calendar--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return `${label || ""}`;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tr", dateHeaders.map((item) => {
            return h("th", {
              class: "vxe-calendar--view-th"
            }, item.label);
          })),
          ...dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          })
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tr", weekHeaders.map((item) => {
            return h("td", {
              class: "vxe-calendar--view-th"
            }, item.label);
          })),
          ...weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                }],
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          })
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-calendar--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: ["vxe-calendar--view-td", {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils54.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils54.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils54.default.isDateSame(datePanelValue, item.date, matchFormat)
                }],
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-calendar--header"
        }, [
          h("div", {
            class: "vxe-calendar--type-wrapper"
          }, [
            h(button_default, {
              disabled: datePanelType === "year",
              content: selectDatePanelLabel,
              onClick: dateToggleTypeEvent
            })
          ]),
          h("div", {
            class: "vxe-calendar--btn-wrapper"
          }, [
            h(button_default, {
              disabled: isDisabledPrevDateBtn,
              icon: "vxe-icon-caret-left",
              onClick: datePrevEvent
            }),
            h(button_default, {
              icon: "vxe-icon-dot",
              onClick: dateTodayMonthEvent
            }),
            h(button_default, {
              disabled: isDisabledNextDateBtn,
              icon: "vxe-icon-caret-right",
              onClick: dateNextEvent
            }),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-calendar--btn vxe-calendar--confirm-btn"
            }, [
              h("button", {
                class: "vxe-calendar--confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-calendar--body"
        }, renderDateTable())
      ];
    };
    calendarMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $input: $xeCalendar }, params));
      }
    };
    Object.assign($xeCalendar, calendarMethods);
    const renderVN = () => {
      const { className, type } = props;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const calendarStyle = computeCalendarStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-calendar", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        style: calendarStyle
      }, [
        renderDatePanel()
      ]);
    };
    $xeCalendar.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        selectValue: null,
        inputValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
      dateOpenPanel();
    });
    watch(computeDateLabelFormat, () => {
      const isCalendarType = computeIsCalendarType.value;
      if (isCalendarType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    onMounted(() => {
      dateOpenPanel();
    });
    initValue();
    return $xeCalendar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/calendar/index.js
var VxeCalendar = Object.assign({}, calendar_default, {
  install(app) {
    app.component(calendar_default.name, calendar_default);
  }
});
dynamicApp.use(VxeCalendar);
VxeUI.component(calendar_default);
var Calendar = VxeCalendar;
var calendar_default2 = VxeCalendar;

// node_modules/vxe-pc-ui/es/loading/src/loading.js
var import_xe_utils55 = __toESM(require_xe_utils());
var loading_default = defineComponent({
  name: "VxeLoading",
  props: {
    modelValue: Boolean,
    icon: {
      type: String,
      default: () => getConfig().loading.icon
    },
    showIcon: {
      type: Boolean,
      default: () => getConfig().loading.showIcon
    },
    text: {
      type: String,
      default: () => getConfig().loading.text
    },
    showText: {
      type: Boolean,
      default: () => getConfig().loading.showText
    },
    status: String,
    size: {
      type: String,
      default: () => getConfig().loading.size || getConfig().size
    }
  },
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils55.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false
    });
    const computeMaps = {
      computeSize
    };
    const $xeLoading = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    const computeLoadingIcon = computed(() => {
      return props.icon || getIcon().LOADING;
    });
    const computeLoadingText = computed(() => {
      const { text } = props;
      return import_xe_utils55.default.isString(text) ? text : getI18n("vxe.loading.text");
    });
    const handleInit = () => {
      if (!reactData.initialized) {
        reactData.initialized = !!reactData.initialized;
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $loading: $xeLoading }, params));
    };
    const loadingMethods = {
      dispatchEvent: dispatchEvent2
    };
    const loadingPrivateMethods = {};
    Object.assign($xeLoading, loadingMethods, loadingPrivateMethods);
    const renderVN = () => {
      const { modelValue, showIcon, status } = props;
      const { initialized } = reactData;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const textSlot = slots.text;
      const iconSlot = slots.icon;
      const loadingIcon = computeLoadingIcon.value;
      const loadingText = computeLoadingText.value;
      if (!initialized && !modelValue) {
        return createCommentVNode();
      }
      return h("div", {
        class: ["vxe-loading", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--visible": modelValue
        }]
      }, defaultSlot ? [
        h("div", {
          class: "vxe-loading--wrapper"
        }, getSlotVNs2(defaultSlot({})))
      ] : [
        h("div", {
          class: "vxe-loading--chunk"
        }, [
          showIcon && (iconSlot || loadingIcon) ? h("div", {
            class: "vxe-loading--icon"
          }, iconSlot ? getSlotVNs2(iconSlot({})) : [
            h("i", {
              class: loadingIcon
            })
          ]) : h("div", {
            class: "vxe-loading--spinner"
          }),
          textSlot || loadingText ? h("div", {
            class: "vxe-loading--text"
          }, textSlot ? getSlotVNs2(textSlot({})) : `${loadingText}`) : null
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      handleInit();
    });
    handleInit();
    $xeLoading.renderVN = renderVN;
    return $xeLoading;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/card/src/card.js
var import_xe_utils56 = __toESM(require_xe_utils());
var card_default = defineComponent({
  name: "VxeCard",
  props: {
    title: String,
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().card.showTitleOverflow
    },
    width: [String, Number],
    height: [String, Number],
    border: {
      type: Boolean,
      default: () => getConfig().card.border
    },
    loading: Boolean,
    shadow: {
      type: Boolean,
      default: () => getConfig().card.shadow
    },
    padding: {
      type: Boolean,
      default: () => getConfig().card.padding
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils56.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeCardStyle = computed(() => {
      const { height, width } = props;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCard = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $card: $xeCard }, params));
    };
    const cardMethods = {
      dispatchEvent: dispatchEvent2
    };
    const cardPrivateMethods = {};
    Object.assign($xeCard, cardMethods, cardPrivateMethods);
    const renderVN = () => {
      const { title, border, shadow, padding, loading: loading2, showTitleOverflow } = props;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const footerSlot = slots.footer;
      const leftSlot = slots.left;
      const rightSlot = slots.right;
      const cardStyle = computeCardStyle.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-card", {
          "is--border": border,
          "is--shadow": shadow,
          "is--padding": padding
        }],
        style: cardStyle
      }, [
        title || titleSlot || headerSlot ? h("div", {
          class: "vxe-card--header"
        }, headerSlot ? getSlotVNs2(headerSlot({})) : [
          h("div", {
            class: ["vxe-card--header-title", {
              "is--ellipsis": showTitleOverflow
            }]
          }, titleSlot ? getSlotVNs2(titleSlot({})) : `${title || ""}`),
          extraSlot ? h("div", {
            class: "vxe-card--header-extra"
          }, getSlotVNs2(extraSlot({}))) : createCommentVNode()
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-card--body"
        }, [
          leftSlot ? h("div", {
            class: "vxe-card--body-left"
          }, getSlotVNs2(leftSlot({}))) : createCommentVNode(),
          h("div", {
            class: "vxe-card--body-content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : []),
          rightSlot ? h("div", {
            class: "vxe-card--body-right"
          }, getSlotVNs2(rightSlot({}))) : createCommentVNode()
        ]),
        footerSlot ? h("div", {
          class: "vxe-card--footer"
        }, getSlotVNs2(footerSlot({}))) : createCommentVNode(),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-card--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeCard.renderVN = renderVN;
    return $xeCard;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/card/index.js
var VxeCard = Object.assign({}, card_default, {
  install(app) {
    app.component(card_default.name, card_default);
  }
});
dynamicApp.use(VxeCard);
VxeUI.component(card_default);
var Card = VxeCard;
var card_default2 = VxeCard;

// node_modules/vxe-pc-ui/es/carousel/src/carousel.js
var import_xe_utils57 = __toESM(require_xe_utils());
var carousel_default = defineComponent({
  name: "VxeCarousel",
  props: {
    modelValue: [String, Number],
    options: Array,
    loading: Boolean,
    height: {
      type: [Number, String],
      default: () => getConfig().carousel.height
    },
    width: {
      type: [Number, String],
      default: () => getConfig().carousel.width
    },
    autoPlay: {
      type: Boolean,
      default: () => getConfig().carousel.autoPlay
    },
    interval: {
      type: [Number, String],
      default: () => getConfig().carousel.interval
    },
    loop: {
      type: Boolean,
      default: () => getConfig().carousel.loop
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().carousel.vertical
    },
    showIndicators: {
      type: Boolean,
      default: () => getConfig().carousel.showIndicators
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils57.default.uniqueId();
    const refElem = ref();
    const refWrapperElem = ref();
    const reactData = reactive({
      activeName: "",
      staticItems: [],
      itemWidth: 0,
      itemHeight: 0
    });
    const internalData = {
      apTimeout: void 0,
      stopFlag: false
    };
    const refMaps = {
      refElem
    };
    const computeListStyle = computed(() => {
      const { vertical, options } = props;
      const { activeName, itemWidth, itemHeight, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const activeIndex = Math.max(0, import_xe_utils57.default.findIndexOf(list, (item) => item.name === activeName));
      const stys = {};
      if (vertical) {
        stys.transform = `translateY(-${activeIndex * itemHeight}px)`;
      } else {
        stys.width = `${itemWidth * list.length}px`;
        stys.transform = `translateX(-${activeIndex * itemWidth}px)`;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeCarousel = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const updateStyle = () => {
      nextTick(() => {
        const wrapperElem = refWrapperElem.value;
        if (wrapperElem) {
          reactData.itemWidth = wrapperElem.clientWidth;
          reactData.itemHeight = wrapperElem.clientHeight;
        }
      });
    };
    const clickItemEvent = (evnt, item) => {
      const value = item.name;
      reactData.activeName = item.name;
      emit("update:modelValue", value);
      emit("change", { value }, evnt);
      updateStyle();
    };
    const initDefaultActive = (list) => {
      let activeName = null;
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          if (activeName === item.name) {
            validVal = true;
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCarousel }, params));
    };
    const handlePrevNext = (isNext) => {
      const { options, loop } = props;
      const { activeName, staticItems } = reactData;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      const index2 = Math.max(0, import_xe_utils57.default.findIndexOf(list, (item) => item.name === activeName));
      if (index2 > -1) {
        let item = null;
        if (isNext) {
          if (index2 < list.length - 1) {
            item = list[index2 + 1];
          } else {
            if (loop) {
              item = list[0];
            }
          }
        } else {
          if (index2 > 0) {
            item = list[index2 - 1];
          } else {
            if (loop) {
              item = list[list.length - 1];
            }
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit("update:modelValue", value);
          return true;
        }
      }
      return false;
    };
    const carouselMethods = {
      dispatchEvent: dispatchEvent2,
      prev() {
        if (handlePrevNext(false)) {
          handleAutoPlay();
        }
        return nextTick();
      },
      next() {
        if (handlePrevNext(true)) {
          handleAutoPlay();
        }
        return nextTick();
      }
    };
    const prevEvent = (evnt) => {
      if (handlePrevNext(false)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const nextEvent = (evnt) => {
      if (handlePrevNext(true)) {
        const value = reactData.activeName;
        emit("change", { value }, evnt);
      }
    };
    const stopAutoPlay = () => {
      const { apTimeout } = internalData;
      internalData.stopFlag = true;
      if (apTimeout) {
        clearTimeout(apTimeout);
        internalData.apTimeout = void 0;
      }
    };
    const handleAutoPlay = () => {
      const { autoPlay, interval } = props;
      const { stopFlag } = internalData;
      stopAutoPlay();
      if (autoPlay) {
        internalData.stopFlag = false;
        internalData.apTimeout = setTimeout(() => {
          if (!stopFlag) {
            handlePrevNext(true);
          }
        }, import_xe_utils57.default.toNumber(interval) || 300);
      }
    };
    const mouseenterEvent = () => {
      stopAutoPlay();
    };
    const mouseleaveEvent = () => {
      handleAutoPlay();
    };
    const carouselPrivateMethods = {};
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils57.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils57.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    Object.assign($xeCarousel, carouselMethods, carouselPrivateMethods);
    const renderItemWrapper = (list) => {
      const { height } = props;
      const { activeName } = reactData;
      const listStyle = computeListStyle.value;
      return h("div", {
        class: "vxe-carousel--list",
        style: listStyle
      }, list.map((item) => {
        const { name, url, slots: slots2 } = item;
        const defaultSlot = slots2 ? slots2.default : null;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--item-inner", {
            "is--active": activeName === name
          }],
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, defaultSlot ? callSlot(defaultSlot, {}) : [
          h("img", {
            class: "vxe-carousel--item-img",
            src: url
          })
        ]);
      }));
    };
    const renderIndicators = (list) => {
      const { activeName } = reactData;
      return h("div", {
        class: "vxe-carousel--indicators"
      }, list.map((item) => {
        const { name } = item;
        return h("div", {
          key: `${name}`,
          class: ["vxe-carousel--indicators-item", {
            "is--active": activeName === name
          }],
          onClick(evnt) {
            clickItemEvent(evnt, item);
          }
        });
      }));
    };
    const renderVN = () => {
      const { loading: loading2, height, width, showIndicators, vertical, options } = props;
      const { staticItems } = reactData;
      const defaultSlot = slots.default;
      const list = (staticItems && staticItems.length ? staticItems : options) || [];
      return h("div", {
        ref: refElem,
        class: ["vxe-carousel", `is--${vertical ? "vertical" : "horizontal"}`],
        style: width ? {
          width: toCssUnit(width)
        } : null,
        onMouseenter: mouseenterEvent,
        onMouseleave: mouseleaveEvent
      }, [
        h("div", {
          class: "vxe-carousel--slots"
        }, defaultSlot ? defaultSlot({}) : []),
        h("div", {
          ref: refWrapperElem,
          class: "vxe-carousel--item-wrapper",
          style: height ? {
            height: toCssUnit(height)
          } : null
        }, [
          renderItemWrapper(list)
        ]),
        showIndicators ? renderIndicators(list) : createCommentVNode(),
        h("div", {
          class: "vxe-carousel--btn-wrapper"
        }, [
          h("div", {
            class: "vxe-carousel--previous-btn",
            onClick: prevEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_PREVIOUS : getIcon().CAROUSEL_HORIZONTAL_PREVIOUS
            })
          ]),
          h("div", {
            class: "vxe-carousel--next-btn",
            onClick: nextEvent
          }, [
            h("i", {
              class: vertical ? getIcon().CAROUSEL_VERTICAL_NEXT : getIcon().CAROUSEL_HORIZONTAL_NEXT
            })
          ])
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-carousel--loading",
          modelValue: loading2
        })
      ]);
    };
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultActive(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticItems ? reactData.staticItems.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultActive(reactData.staticItems);
    });
    watch(() => props.autoPlay, () => {
      handleAutoPlay();
    });
    initDefaultActive(reactData.staticItems.length ? reactData.staticItems : props.options);
    onMounted(() => {
      handleAutoPlay();
      updateStyle();
    });
    onUnmounted(() => {
      stopAutoPlay();
    });
    provide("$xeCarousel", $xeCarousel);
    $xeCarousel.renderVN = renderVN;
    return $xeCarousel;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/carousel/index.js
var VxeCarousel = Object.assign({}, carousel_default, {
  install(app) {
    app.component(carousel_default.name, carousel_default);
  }
});
dynamicApp.use(VxeCarousel);
VxeUI.component(carousel_default);
var Carousel = VxeCarousel;
var carousel_default2 = VxeCarousel;

// node_modules/vxe-pc-ui/es/carousel/src/util.js
var import_xe_utils58 = __toESM(require_xe_utils());
function assembleCarouselItem($xeCarousel, elem, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticItems.splice(import_xe_utils58.default.arrayIndexOf(parentElem.children, elem), 0, itemConfig);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}
function destroyCarouselItem($xeCarousel, itemConfig) {
  const staticItems = $xeCarousel.reactData.staticItems;
  const index2 = import_xe_utils58.default.findIndexOf(staticItems, (item) => item.id === itemConfig.id);
  if (index2 > -1) {
    staticItems.splice(index2, 1);
  }
  $xeCarousel.reactData.staticItems = staticItems.slice(0);
}

// node_modules/vxe-pc-ui/es/carousel/src/carousel-item.js
var import_xe_utils59 = __toESM(require_xe_utils());
var carousel_item_default = defineComponent({
  name: "VxeCarouselItem",
  props: {
    name: [String, Number],
    className: String,
    url: String
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeCarousel = inject("$xeCarousel", null);
    const xID = import_xe_utils59.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const itemConfig = reactive({
      id: xID,
      name: props.name,
      url: props.url,
      className: props.className,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCarouselItem = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carouselItem: $xeCarouselItem }, params));
    };
    const carouselItemMethods = {
      dispatchEvent: dispatchEvent2
    };
    const carouselItemPrivateMethods = {};
    Object.assign($xeCarouselItem, carouselItemMethods, carouselItemPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    watch(() => props.name, (val) => {
      itemConfig.name = val;
    });
    watch(() => props.url, (val) => {
      itemConfig.url = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeCarousel && elem) {
        assembleCarouselItem($xeCarousel, elem, itemConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCarousel) {
        destroyCarouselItem($xeCarousel, itemConfig);
      }
    });
    $xeCarouselItem.renderVN = renderVN;
    return $xeCarouselItem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/carousel-item/index.js
var VxeCarouselItem = Object.assign({}, carousel_item_default, {
  install(app) {
    app.component(carousel_item_default.name, carousel_item_default);
  }
});
dynamicApp.use(VxeCarouselItem);
VxeUI.component(carousel_item_default);
var CarouselItem = VxeCarouselItem;
var carousel_item_default2 = VxeCarouselItem;

// node_modules/vxe-pc-ui/es/checkbox/src/checkbox.js
var import_xe_utils60 = __toESM(require_xe_utils());
var checkbox_default = defineComponent({
  name: "VxeCheckbox",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number],
      default: null
    },
    indeterminate: Boolean,
    title: [String, Number],
    checkedValue: {
      type: [String, Number, Boolean],
      default: true
    },
    uncheckedValue: {
      type: [String, Number, Boolean],
      default: false
    },
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkbox.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeCheckboxGroup = inject("$xeCheckboxGroup", null);
    const xID = import_xe_utils60.default.uniqueId();
    const reactData = reactive({});
    const $xeCheckbox = {
      xID,
      props,
      context,
      reactData
    };
    let checkboxMethods = {};
    const { computeSize } = useSize(props);
    const computeIsChecked = computed(() => {
      if ($xeCheckboxGroup) {
        return import_xe_utils60.default.includes($xeCheckboxGroup.props.modelValue, props.label);
      }
      return props.modelValue === props.checkedValue;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      const isChecked = computeIsChecked.value;
      if (disabled === null) {
        if ($xeCheckboxGroup) {
          const { computeIsDisabled: computeIsGroupDisabled, computeIsMaximize: computeIsGroupMaximize } = $xeCheckboxGroup.getComputeMaps();
          const isGroupDisabled = computeIsGroupDisabled.value;
          const isGroupMaximize = computeIsGroupMaximize.value;
          return isGroupDisabled || isGroupMaximize && !isChecked;
        }
      }
      return disabled;
    });
    const changeEvent = (evnt) => {
      const { checkedValue, uncheckedValue } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const checked = evnt.target.checked;
        const value = checked ? checkedValue : uncheckedValue;
        const params = { checked, value, label: props.label };
        if ($xeCheckboxGroup) {
          $xeCheckboxGroup.handleChecked(params, evnt);
        } else {
          emit("update:modelValue", value);
          checkboxMethods.dispatchEvent("change", params, evnt);
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $checkbox: $xeCheckbox }, params));
    };
    checkboxMethods = {
      dispatchEvent: dispatchEvent2
    };
    Object.assign($xeCheckbox, checkboxMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isChecked = computeIsChecked.value;
      const indeterminate = !isChecked && props.indeterminate;
      return h("label", {
        class: ["vxe-checkbox", {
          [`size--${vSize}`]: vSize,
          "is--indeterminate": indeterminate,
          "is--disabled": isDisabled,
          "is--checked": isChecked
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-checkbox--input",
          type: "checkbox",
          disabled: isDisabled,
          checked: isChecked,
          onChange: changeEvent
        }),
        h("span", {
          class: ["vxe-checkbox--icon", indeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
        }),
        h("span", {
          class: "vxe-checkbox--label"
        }, slots.default ? slots.default({}) : getFuncText2(props.content))
      ]);
    };
    $xeCheckbox.renderVN = renderVN;
    return $xeCheckbox;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/checkbox/index.js
var VxeCheckbox = Object.assign(checkbox_default, {
  install(app) {
    app.component(checkbox_default.name, checkbox_default);
  }
});
dynamicApp.use(VxeCheckbox);
VxeUI.component(checkbox_default);
var Checkbox = VxeCheckbox;
var checkbox_default2 = VxeCheckbox;

// node_modules/vxe-pc-ui/es/checkbox/src/group.js
var import_xe_utils61 = __toESM(require_xe_utils());
var group_default2 = defineComponent({
  name: "VxeCheckboxGroup",
  props: {
    modelValue: Array,
    options: Array,
    optionProps: Object,
    disabled: {
      type: Boolean,
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().checkboxGroup.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils61.default.uniqueId();
    const reactData = reactive({});
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, max } = props;
      if (max) {
        return (modelValue ? modelValue.length : 0) >= import_xe_utils61.default.toNumber(max);
      }
      return false;
    });
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const computeMaps = {
      computeIsMaximize,
      computeIsDisabled
    };
    const $xeCheckboxGroup = {
      xID,
      props,
      context,
      reactData,
      getComputeMaps: () => computeMaps
    };
    useSize(props);
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $checkboxGroup: $xeCheckboxGroup }, params));
    };
    const checkboxGroupMethods = {
      dispatchEvent: dispatchEvent2
    };
    const checkboxGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const { checked, label } = params;
        const checklist = props.modelValue || [];
        const checkIndex = checklist.indexOf(label);
        if (checked) {
          if (checkIndex === -1) {
            checklist.push(label);
          }
        } else {
          checklist.splice(checkIndex, 1);
        }
        emit("update:modelValue", checklist);
        $xeCheckboxGroup.dispatchEvent("change", Object.assign({ checklist }, params), evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, checklist);
        }
      }
    };
    Object.assign($xeCheckboxGroup, checkboxGroupMethods, checkboxGroupPrivateMethods);
    const renderVN = () => {
      const { options } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      return h("div", {
        class: "vxe-checkbox-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(checkbox_default, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    provide("$xeCheckboxGroup", $xeCheckboxGroup);
    $xeCheckboxGroup.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/checkbox-group/index.js
var VxeCheckboxGroup = Object.assign(group_default2, {
  install(app) {
    app.component(group_default2.name, group_default2);
  }
});
dynamicApp.use(VxeCheckboxGroup);
VxeUI.component(group_default2);
var CheckboxGroup = VxeCheckboxGroup;
var checkbox_group_default = VxeCheckboxGroup;

// node_modules/vxe-pc-ui/es/row/src/col.js
var import_xe_utils62 = __toESM(require_xe_utils());
var col_default = defineComponent({
  name: "VxeCol",
  props: {
    span: [Number, String],
    align: String,
    width: [Number, String],
    fill: Boolean,
    ellipsis: Boolean,
    size: {
      type: String,
      default: () => getConfig().col.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils62.default.uniqueId();
    useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const $xeRow = inject("$xeRow", null);
    const computeRowGutter = computed(() => {
      if ($xeRow) {
        return $xeRow.props.gutter;
      }
      return null;
    });
    const computeRowVertical = computed(() => {
      if ($xeRow) {
        return $xeRow.props.vertical;
      }
      return null;
    });
    const computeColStyle = computed(() => {
      const { width } = props;
      const rowGutter = computeRowGutter.value;
      const rowVertical = computeRowVertical.value;
      const style = {};
      if (rowGutter) {
        let [lrGutter, tbGutter] = import_xe_utils62.default.isArray(rowGutter) ? rowGutter : [rowGutter];
        if (rowVertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const padding = import_xe_utils62.default.isNumber(lrGutter) ? toCssUnit(lrGutter / 2) : `calc(${toCssUnit(lrGutter)} / 2)`;
          style.paddingLeft = padding;
          style.paddingRight = padding;
        }
        if (tbGutter) {
          const padding = import_xe_utils62.default.isNumber(tbGutter) ? toCssUnit(tbGutter / 2) : `calc(${toCssUnit(tbGutter)} / 2)`;
          style.paddingTop = padding;
          style.paddingBottom = padding;
        }
      }
      if (width) {
        style.width = toCssUnit(width);
      }
      return style;
    });
    const computeMaps = {};
    const $xeCol = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $col: $xeCol }, params));
    };
    const colMethods = {
      dispatchEvent: dispatchEvent2
    };
    const colPrivateMethods = {};
    Object.assign($xeCol, colMethods, colPrivateMethods);
    const renderVN = () => {
      const { span, fill, align, ellipsis } = props;
      const colStyle = computeColStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-col", span ? `span${span}` : "", align ? `align--${align}` : "", {
          "is--span": span,
          "is--fill": fill,
          "is--ellipsis": ellipsis
        }],
        style: colStyle
      }, [
        h("div", {
          class: "vxe-col--inner"
        }, defaultSlot ? defaultSlot({}) : [])
      ]);
    };
    $xeCol.renderVN = renderVN;
    return $xeCol;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/col/index.js
var VxeCol = Object.assign({}, col_default, {
  install(app) {
    app.component(col_default.name, col_default);
  }
});
dynamicApp.use(VxeCol);
VxeUI.component(col_default);
var Col = VxeCol;
var col_default2 = VxeCol;

// node_modules/vxe-pc-ui/es/collapse/src/collapse.js
var import_xe_utils63 = __toESM(require_xe_utils());
var collapse_default = defineComponent({
  name: "VxeCollapse",
  props: {
    modelValue: Array,
    options: Array,
    padding: {
      type: Boolean,
      default: () => getConfig().collapse.padding
    },
    expandConfig: Object,
    size: {
      type: String,
      default: () => getConfig().collapse.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "collapse-load"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils63.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      staticPanes: [],
      activeNames: [],
      initNames: [],
      cachePaneMaps: {}
    });
    const refMaps = {
      refElem
    };
    const computeItemOptions = computed(() => {
      const { options } = props;
      return (options || []).filter((item) => handleFilterItem(item));
    });
    const computeItemStaticOptions = computed(() => {
      const { staticPanes } = reactData;
      return staticPanes.filter((item) => handleFilterItem(item));
    });
    const computeExpandOpts = computed(() => {
      return Object.assign({}, getConfig().collapse.expandConfig, props.expandConfig);
    });
    const computeMaps = {};
    const $xeCollapse = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterItem = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const addInitName = (name) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      const { activeNames } = reactData;
      const nameMaps = {};
      if (list && list.length) {
        list.forEach((item) => {
          const { name, preload } = item || {};
          if (name) {
            const isActive = activeNames.includes(name);
            nameMaps[`${name}`] = {
              loading: false
            };
            if (isActive) {
              addInitName(name);
            }
            if (preload) {
              if (!isActive) {
                activeNames.push(name);
              }
            }
          }
        });
      }
      reactData.activeNames = activeNames ? activeNames.slice(0) : [];
      reactData.cachePaneMaps = nameMaps;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $collapse: $xeCollapse }, params));
    };
    const collapseMethods = {
      dispatchEvent: dispatchEvent2
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils63.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils63.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const handleClickEvent = (evnt, item) => {
      const { activeNames } = reactData;
      const { name } = item;
      if (name) {
        const aIndex = activeNames.indexOf(name);
        if (aIndex === -1) {
          activeNames.push(name);
        } else {
          activeNames.splice(aIndex, 1);
        }
        addInitName(name);
      }
    };
    const collapsePrivateMethods = {};
    Object.assign($xeCollapse, collapseMethods, collapsePrivateMethods);
    const renderList2 = (itemList) => {
      const { activeNames, initNames } = reactData;
      const expandOpts = computeExpandOpts.value;
      return itemList.map((item) => {
        const { icon, name, title, slots: slots2 } = item;
        const titleSlot = slots2 ? slots2.title : null;
        const defaultSlot = slots2 ? slots2.default : null;
        const isActive = name && activeNames.includes(name);
        return h("div", {
          class: "vxe-collapse-item"
        }, [
          h("div", {
            class: "vxe-collapse--item-header",
            onClick(evnt) {
              handleClickEvent(evnt, item);
            }
          }, [
            expandOpts.showIcon ? h("span", {
              class: "vxe-collapse--item-switch"
            }, [
              h("i", {
                class: isActive ? getIcon().COLLAPSE_OPEN : getIcon().COLLAPSE_CLOSE
              })
            ]) : renderEmptyElement($xeCollapse),
            icon ? h("span", {
              class: "vxe-collapse--item-icon"
            }, [
              h("i", {
                class: icon
              })
            ]) : renderEmptyElement($xeCollapse),
            h("span", {
              class: "vxe-collapse--item-name"
            }, titleSlot ? callSlot(titleSlot, { name, title }) : `${title}`)
          ]),
          h("div", {
            class: ["vxe-collapse--item-content", {
              "is--visible": isActive
            }]
          }, [
            name && initNames.includes(name) ? h("div", {
              class: "vxe-collapse--item-inner"
            }, [
              defaultSlot ? callSlot(defaultSlot, { name, title }) : ""
            ]) : renderEmptyElement($xeCollapse)
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { padding } = props;
      const vSize = computeSize.value;
      const itemOptions = computeItemOptions.value;
      const itemStaticOptions = computeItemStaticOptions.value;
      const defaultSlot = slots.default;
      const itemList = defaultSlot ? itemStaticOptions : itemOptions;
      return h("div", {
        ref: refElem,
        class: ["vxe-collapse", {
          [`size--${vSize}`]: vSize,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-collapse-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderList2(itemList)
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeNames = val || [];
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
    });
    const stFlag = ref(0);
    watch(() => reactData.staticPanes ? reactData.staticPanes.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticPanes, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticPanes);
    });
    reactData.activeNames = props.modelValue || [];
    initDefaultName(reactData.staticPanes.length ? reactData.staticPanes : props.options);
    provide("$xeCollapse", $xeCollapse);
    $xeCollapse.renderVN = renderVN;
    return $xeCollapse;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/collapse/index.js
var VxeCollapse = Object.assign({}, collapse_default, {
  install(app) {
    app.component(collapse_default.name, collapse_default);
  }
});
dynamicApp.use(VxeCollapse);
VxeUI.component(collapse_default);
var Collapse = VxeCollapse;
var collapse_default2 = VxeCollapse;

// node_modules/vxe-pc-ui/es/collapse/src/collapse-pane.js
var import_xe_utils65 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/collapse/src/util.js
var import_xe_utils64 = __toESM(require_xe_utils());
function assembleCollapseItem($xeCollapse, elem, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticPanes.splice(import_xe_utils64.default.arrayIndexOf(parentElem.children, elem), 0, collapseConfig);
    $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
  }
}
function destroyCollapseItem($xeCollapse, collapseConfig) {
  const staticPanes = $xeCollapse.reactData.staticPanes;
  const matchObj = import_xe_utils64.default.findTree(staticPanes, (item) => item.id === collapseConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeCollapse.reactData.staticPanes = staticPanes.slice(0);
}

// node_modules/vxe-pc-ui/es/collapse/src/collapse-pane.js
var collapse_pane_default = defineComponent({
  name: "VxeCollapsePane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils65.default.uniqueId();
    const $xeCollapse = inject("$xeCollapse", null);
    const refElem = ref();
    const reactData = reactive({});
    const collapseConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeCollapsePane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $collapsePane: $xeCollapsePane }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeCollapsePane, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    watch(() => props.title, (val) => {
      collapseConfig.title = val;
    });
    watch(() => props.name, (val) => {
      collapseConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      collapseConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      collapseConfig.permissionCode = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeCollapse && elem) {
        assembleCollapseItem($xeCollapse, elem, collapseConfig);
      }
    });
    onUnmounted(() => {
      if ($xeCollapse) {
        destroyCollapseItem($xeCollapse, collapseConfig);
      }
    });
    $xeCollapsePane.renderVN = renderVN;
    return $xeCollapsePane;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/collapse-pane/index.js
var VxeCollapsePane = Object.assign({}, collapse_pane_default, {
  install(app) {
    app.component(collapse_pane_default.name, collapse_pane_default);
  }
});
dynamicApp.use(VxeCollapsePane);
VxeUI.component(collapse_pane_default);
var CollapsePane = VxeCollapsePane;
var collapse_pane_default2 = VxeCollapsePane;

// node_modules/vxe-pc-ui/es/color-picker/src/color-picker.js
var import_xe_utils66 = __toESM(require_xe_utils());
var color_picker_default = defineComponent({
  name: "VxeColorPicker",
  props: {},
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils66.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeColorPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $colorPicker: $xeColorPicker }, params));
    };
    const colorPickerMethods = {
      dispatchEvent: dispatchEvent2
    };
    const colorPickerPrivateMethods = {};
    Object.assign($xeColorPicker, colorPickerMethods, colorPickerPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem,
        class: "vxe-color-picker"
      }, []);
    };
    $xeColorPicker.renderVN = renderVN;
    return $xeColorPicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/color-picker/index.js
var VxeColorPicker = Object.assign({}, color_picker_default, {
  install(app) {
    app.component(color_picker_default.name, color_picker_default);
  }
});
dynamicApp.use(VxeColorPicker);
VxeUI.component(color_picker_default);
var ColorPicker = VxeColorPicker;
var color_picker_default2 = VxeColorPicker;

// node_modules/vxe-pc-ui/es/text/src/text.js
var import_xe_utils67 = __toESM(require_xe_utils());
var text_default = defineComponent({
  name: "VxeText",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    loading: Boolean,
    content: [String, Number],
    clickToCopy: Boolean,
    size: {
      type: String,
      default: () => getConfig().text.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils67.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const clickIconEvent = () => {
      const { content, clickToCopy } = props;
      if (clickToCopy) {
        const contentEl = refContentElem.value;
        const copyVal = (contentEl ? contentEl.textContent : "") || content;
        if (copyVal) {
          if (VxeUI.clipboard.copy(copyVal)) {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.text.copySuccess"),
                status: "success"
              });
            }
          } else {
            if (VxeUI.modal) {
              VxeUI.modal.message({
                content: getI18n("vxe.text.copyError"),
                status: "error"
              });
            }
          }
        }
      }
    };
    const $xeText = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $text: $xeText }, params));
    };
    const textMethods = {
      dispatchEvent: dispatchEvent2
    };
    const clickEvent = (evnt) => {
      const { loading: loading2 } = props;
      if (!loading2) {
        dispatchEvent2("click", {}, evnt);
      }
    };
    const textPrivateMethods = {};
    Object.assign($xeText, textMethods, textPrivateMethods);
    const renderContent = () => {
      const { loading: loading2, icon, content, clickToCopy } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [
        loading2 ? h("span", {
          class: "vxe-text--loading"
        }, [
          h("i", {
            class: getIcon().TEXT_LOADING
          })
        ]) : iconSlot || icon || clickToCopy ? h("span", {
          class: "vxe-text--icon",
          onClick: clickIconEvent
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon || getIcon().TEXT_COPY
          })
        ]) : createCommentVNode(),
        h("span", {
          ref: refContentElem,
          class: "vxe-text--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils67.default.toValueString(content))
      ];
    };
    const renderVN = () => {
      const { loading: loading2, status, title, clickToCopy } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        title,
        class: ["vxe-text", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--copy": clickToCopy,
          "is--loading": loading2
        }],
        onClick: clickEvent
      }, renderContent());
    };
    $xeText.renderVN = renderVN;
    return $xeText;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/countdown/src/countdown.js
var import_xe_utils68 = __toESM(require_xe_utils());
var countdown_default = defineComponent({
  name: "VxeCountdown",
  props: {
    modelValue: [Number, String],
    format: String,
    prefixConfig: Object,
    suffixConfig: Object,
    size: {
      type: String,
      default: () => getConfig().countdown.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "start",
    "end"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils68.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      currNum: 0,
      secondNum: 0
    });
    const internalData = {
      dnTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeTimeFormats = computed(() => {
      const { secondNum } = reactData;
      if (secondNum >= 316224e5) {
        return ["yyyy", "MM", "dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 26784e5) {
        return ["MM", "dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 864e5) {
        return ["dd", "HH", "mm", "ss"];
      }
      if (secondNum >= 36e5) {
        return ["HH", "mm", "ss"];
      }
      if (secondNum >= 6e4) {
        return ["mm", "ss"];
      }
      return ["ss"];
    });
    const computeDiffConf = computed(() => {
      const { currNum } = reactData;
      return import_xe_utils68.default.getDateDiff(Date.now(), Date.now() + currNum);
    });
    const computeFormatLabel = computed(() => {
      const { format: format4 } = props;
      const diffConf = computeDiffConf.value;
      let rest = "";
      if (format4) {
        rest = `${format4}`;
        import_xe_utils68.default.each(diffConf, (val, key) => {
          rest = rest.replace(new RegExp(key, "g"), import_xe_utils68.default.padStart(val, key.length, "0"));
        });
        return rest;
      }
      return rest;
    });
    const computePrefixOpts = computed(() => {
      return Object.assign({}, props.prefixConfig, getConfig().countdown.prefixConfig);
    });
    const computeSuffixOpts = computed(() => {
      return Object.assign({}, props.suffixConfig, getConfig().countdown.suffixConfig);
    });
    const computeMaps = {
      computeSize
    };
    const $xeCountdown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $carousel: $xeCountdown }, params));
    };
    const updateCount = () => {
      const secondNum = import_xe_utils68.default.toNumber(props.modelValue || 0);
      reactData.secondNum = secondNum;
      reactData.currNum = secondNum;
    };
    const handleTime = () => {
      const { currNum } = reactData;
      if (currNum > 1e3) {
        reactData.currNum -= 1e3;
        internalData.dnTimeout = setTimeout(() => {
          handleTime();
        }, 1e3);
      } else {
        reactData.currNum = 0;
        handleStop();
      }
    };
    const countdownMethods = {
      dispatchEvent: dispatchEvent2
    };
    const handleStart = () => {
      dispatchEvent2("start", {}, null);
      handleTime();
    };
    const handleStop = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
        dispatchEvent2("end", {}, null);
      }
    };
    const countdownPrivateMethods = {};
    Object.assign($xeCountdown, countdownMethods, countdownPrivateMethods);
    const renderDefaultContentVNs = () => {
      const { format: format4 } = props;
      const timeFormats = computeTimeFormats.value;
      const diffConf = computeDiffConf.value;
      const formatLabel = computeFormatLabel.value;
      if (format4) {
        return [
          h("div", {
            key: "format",
            class: "vxe-countdown--content-format"
          }, formatLabel)
        ];
      }
      return timeFormats.map((key, index2) => {
        return h("div", {
          key: index2,
          class: "vxe-countdown--content-item"
        }, [
          h("div", {
            class: "vxe-countdown--content-num"
          }, `${diffConf[key] || 0}`),
          h("div", {
            class: "vxe-countdown--content-unit"
          }, getI18n(`vxe.countdown.formats.${key}`))
        ]);
      });
    };
    const renderVN = () => {
      const { prefixConfig, suffixConfig } = props;
      const { currNum } = reactData;
      const vSize = computeSize.value;
      const diffConf = computeDiffConf.value;
      const prefixOpts = computePrefixOpts.value;
      const suffixOpts = computeSuffixOpts.value;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-countdown", diffConf.done ? "is--progress" : "is-end", {
          [`size--${vSize}`]: vSize
        }]
      }, [
        prefixSlot || prefixConfig ? h("div", {
          class: "vxe-countdown--prefix"
        }, prefixSlot ? getSlotVNs2(prefixSlot({ currentValue: currNum, diffConf })) : [
          h(text_default, {
            content: prefixOpts.content,
            icon: prefixOpts.icon,
            status: prefixOpts.status
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-countdown--content"
        }, defaultSlot ? getSlotVNs2(defaultSlot({ currentValue: currNum, diffConf })) : renderDefaultContentVNs()),
        suffixSlot || suffixConfig ? h("div", {
          class: "vxe-countdown--suffix"
        }, suffixSlot ? getSlotVNs2(suffixSlot({ currentValue: currNum, diffConf })) : [
          h(text_default, {
            content: suffixOpts.content,
            icon: suffixOpts.icon,
            status: suffixOpts.status
          })
        ]) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, () => {
      updateCount();
      handleStop();
      handleStart();
    });
    onUnmounted(() => {
      handleStop();
    });
    onMounted(() => {
      handleStart();
    });
    updateCount();
    $xeCountdown.renderVN = renderVN;
    return $xeCountdown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/countdown/index.js
var VxeCountdown = Object.assign({}, countdown_default, {
  install(app) {
    app.component(countdown_default.name, countdown_default);
  }
});
dynamicApp.use(VxeCountdown);
VxeUI.component(countdown_default);
var Countdown = VxeCountdown;
var countdown_default2 = VxeCountdown;

// node_modules/vxe-pc-ui/es/date-picker/src/date-picker.js
var import_xe_utils69 = __toESM(require_xe_utils());
var date_picker_default = defineComponent({
  name: "VxeDatePicker",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "date"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().datePicker.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().datePicker.size || getConfig().size
    },
    multiple: Boolean,
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().datePicker.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    startDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().datePicker.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().datePicker.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().datePicker.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils69.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: "",
      isActivated: false,
      inputValue: "",
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeDatePicker = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let datePickerMethods = {};
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().datePicker.transfer;
        if (import_xe_utils69.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils69.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils69.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils69.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate2(item, dateValueFormat);
          if (import_xe_utils69.default.isValidDate(date)) {
            return date;
          }
          return date;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils69.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils69.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === "time") {
        return "HH:mm:ss";
      }
      if (type === "datetime") {
        return "yyyy-MM-dd HH:mm:ss";
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate2(modelValue, dateValueFormat);
        if (import_xe_utils69.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return import_xe_utils69.default.toDateString(datetimePanelValue, hasTimeSecond ? "HH:mm:ss" : "HH:mm");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return null;
    });
    const computeYearList = computed(() => {
      const { yearSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index2 = -4; index2 < yearSize + 4; index2++) {
          const date = import_xe_utils69.default.getWhatYear(startYearDate, index2, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index2 < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index2 >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return getI18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return getI18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return getI18n("vxe.input.date.dayLabel", [year, month ? getI18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils69.default.toNumber(import_xe_utils69.default.isNumber(startDay) || import_xe_utils69.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index2 = 0; index2 < 6; index2++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils69.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { quarterSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils69.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index2 = -2; index2 < quarterSize - 2; index2++) {
          const date = import_xe_utils69.default.getWhatQuarter(firstYear, index2);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils69.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { monthSize } = internalData;
      const { selectMonth, currentDate } = reactData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils69.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index2 = -4; index2 < monthSize - 4; index2++) {
          const date = import_xe_utils69.default.getWhatYear(selectMonth, 0, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils69.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils69.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index2 = 0; index2 < 42; index2++) {
          const date = import_xe_utils69.default.getWhatDay(startDayDate, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils69.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils69.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index2 = 0; index2 < 24; index2++) {
          list.push({
            value: index2,
            label: ("" + index2).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index2 = 0; index2 < 60; index2++) {
          list.push({
            value: index2,
            label: ("" + index2).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeDatePickerType = computed(() => {
      return "text";
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().datePicker.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const updateModelValue = (modelValue) => {
      let val = "";
      if (modelValue) {
        if (import_xe_utils69.default.isNumber(modelValue) && /^[0-9]{11,15}$/.test(`${modelValue}`)) {
          val = new Date(modelValue);
        } else {
          val = modelValue;
        }
      }
      reactData.inputValue = val;
    };
    const parseDate2 = (value, format4) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      return import_xe_utils69.default.toStringDate(value, format4);
    };
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      datePickerMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils69.default.toValueString(props.modelValue) !== value) {
        datePickerMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      const inputElem = evnt.target;
      const value = inputElem.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          handleChange(value, evnt);
        } else {
          datePickerMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent3(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent3(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        datePickerMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = window.setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      handleChange("", evnt);
      datePickerMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        datePickerMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate2(value, dateValueFormat);
      }
      if (import_xe_utils69.default.isValidDate(dValue)) {
        dLabel = import_xe_utils69.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils69.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      updateModelValue(props.modelValue);
      if (isDatePickerType) {
        changeValue();
      }
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils69.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils69.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils69.default.toNumber(props.selectDay);
        date = import_xe_utils69.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        if (datetimePanelValue) {
          date.setHours(datetimePanelValue.getHours());
          date.setMinutes(datetimePanelValue.getMinutes());
          date.setSeconds(datetimePanelValue.getSeconds());
        }
      }
      const inpVal = import_xe_utils69.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils69.default.findIndexOf(dateListValue, (val) => import_xe_utils69.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              if (datetimePanelValue) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
              }
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map((date2) => import_xe_utils69.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils69.default.isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter((val) => !import_xe_utils69.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils69.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (inputValue) {
          let inpDateVal = parseDate2(inputValue, dateLabelFormat);
          if (import_xe_utils69.default.isValidDate(inpDateVal)) {
            if (type === "time") {
              inpDateVal = import_xe_utils69.default.toDateString(inpDateVal, dateLabelFormat);
              if (inputValue !== inpDateVal) {
                handleChange(inpDateVal, { type: "check" });
              }
              reactData.inputValue = inpDateVal;
            } else {
              let isChange = false;
              const firstDayOfWeek = computeFirstDayOfWeek.value;
              if (type === "datetime") {
                const dateValue = computeDateValue.value;
                if (inputValue !== import_xe_utils69.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils69.default.toDateString(inpDateVal, dateLabelFormat)) {
                  isChange = true;
                  if (datetimePanelValue) {
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                }
              } else {
                isChange = true;
              }
              reactData.inputValue = import_xe_utils69.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
              if (isChange) {
                dateChange(inpDateVal);
              }
            }
          } else {
            dateRevert();
          }
        } else {
          handleChange("", { type: "check" });
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      datePickerMethods.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const keydownEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const wheelEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils69.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils69.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, -1, "first");
          } else {
            viewDate = import_xe_utils69.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        datePickerMethods.dispatchEvent("date-prev", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      datePickerMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils69.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils69.default.getWhatYear(selectMonth, 1, "first");
          } else {
            viewDate = import_xe_utils69.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        datePickerMethods.dispatchEvent("date-next", { viewType: datePanelType, value, type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const { date } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      if (disabledMethod) {
        return disabledMethod({ type: datePanelType, viewType: datePanelType, date, $datePicker: $xeDatePicker });
      }
      return false;
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils69.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils69.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils69.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils69.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      const { datetimePanelValue } = reactData;
      reactData.datetimePanelValue = datetimePanelValue ? new Date(datetimePanelValue.getTime()) : /* @__PURE__ */ new Date();
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setHours(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                if (datetimePanelValue) {
                  item.setHours(datetimePanelValue.getHours());
                  item.setMinutes(datetimePanelValue.getMinutes());
                  item.setSeconds(datetimePanelValue.getSeconds());
                }
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map((date) => import_xe_utils69.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setMinutes(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      const { datetimePanelValue } = reactData;
      if (datetimePanelValue) {
        datetimePanelValue.setSeconds(item.value);
      }
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils69.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils69.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils69.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils69.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils69.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils69.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils69.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils69.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils69.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils69.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils69.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils69.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils69.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils69.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils69.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils69.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils69.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils69.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils69.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils69.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils69.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils69.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils69.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), (elem) => {
            updateTimePos(elem);
          });
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(targetElem);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.top = "";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
          internalData.hpTimeout = void 0;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const formReadonly = computeFormReadonly.value;
      if (!formReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el2 = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode2(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $datePicker: $xeDatePicker }, params));
    };
    datePickerMethods = {
      dispatchEvent: dispatchEvent2,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeDatePicker, datePickerMethods);
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $datePicker: $xeDatePicker });
        const festivalItem = festivalRest ? import_xe_utils69.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils69.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-date-picker--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label}`),
            h("span", {
              class: ["vxe-date-picker--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils69.default.toValueString(extraItem.label))
          ] : `${label}`)
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils69.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-date-picker--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-date-picker--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-date-picker--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return label;
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-date-picker--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils69.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils69.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils69.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-date-picker--date-picker-header"
        }, [
          h("div", {
            class: "vxe-date-picker--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-date-picker--date-picker-label"
            }, selectDatePanelLabel) : h("span", {
              class: "vxe-date-picker--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h("div", {
            class: "vxe-date-picker--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-date-picker--date-picker-btn vxe-date-picker--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-date-picker--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-date-picker--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-date-picker--time-picker-header"
        }, [
          hasTimeMinute ? h("div", {
            class: "vxe-date-picker--time-picker-title"
          }, dateTimeLabel) : createCommentVNode(),
          h("div", {
            class: "vxe-date-picker--time-picker-btn"
          }, [
            h("button", {
              class: "vxe-date-picker--time-picker-confirm",
              type: "button",
              onClick: dateConfirmEvent
            }, getI18n("vxe.button.confirm"))
          ])
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-date-picker--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-date-picker--time-picker-hour-list"
          }, hourList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-date-picker--time-picker-minute-list"
          }, minuteList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode(),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-date-picker--time-picker-second-list"
          }, secondList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode()
        ])
      ];
    };
    const renderPanel = () => {
      const { type } = props;
      const { initialized, isAniVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const btnTransfer = computeBtnTransfer.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-date-picker--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-date-picker--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            key: type || "default",
            ref: refPanelWrapper,
            class: "vxe-date-picker--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-date-picker--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, initialized && (visiblePanel || isAniVisible) ? renders : [])
        ]);
      }
      return createCommentVNode();
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-date-picker--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-date-picker--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-date-picker--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils69.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-date-picker--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-date-picker--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]);
    };
    const renderExtraSuffixIcon = () => {
      return h("div", {
        class: "vxe-date-picker--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-date-picker--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderVN = () => {
      const { className, type, align, name, autocomplete, autoComplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-date-picker--readonly", `type--${type}`, className]
        }, inputValue);
      }
      const inputReadonly = computeInputReadonly.value;
      const inputType = computeDatePickerType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-date-picker", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils69.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-date-picker--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-date-picker--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode(),
        // 下拉面板
        renderPanel()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      updateModelValue(val);
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: "",
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    nextTick(() => {
      globalEvents.on($xeDatePicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeDatePicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeDatePicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeDatePicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeDatePicker, "mousewheel");
      globalEvents.off($xeDatePicker, "mousedown");
      globalEvents.off($xeDatePicker, "keydown");
      globalEvents.off($xeDatePicker, "blur");
    });
    initValue();
    $xeDatePicker.renderVN = renderVN;
    return $xeDatePicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/date-picker/index.js
var VxeDatePicker = Object.assign({}, date_picker_default, {
  install(app) {
    app.component(date_picker_default.name, date_picker_default);
    app.component("VxeDateInput", date_picker_default);
  }
});
dynamicApp.use(VxeDatePicker);
VxeUI.component(date_picker_default);
var DatePicker = VxeDatePicker;
var date_picker_default2 = VxeDatePicker;

// node_modules/vxe-pc-ui/es/drawer/index.js
var import_xe_utils71 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/drawer/src/drawer.js
var import_xe_utils70 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/loading/index.js
var VxeLoading = Object.assign({}, loading_default, {
  install(app) {
    app.component(loading_default.name, loading_default);
  }
});
var LoadingController = {
  open(options) {
    const opts = Object.assign({}, options);
    dynamicStore.globalLoading = {
      modelValue: true,
      text: opts.text,
      icon: opts.icon
    };
    checkDynamic();
  },
  close() {
    dynamicStore.globalLoading = null;
  }
};
dynamicApp.use(VxeLoading);
VxeUI.component(loading_default);
VxeUI.loading = LoadingController;
var Loading2 = VxeLoading;
var loading_default2 = VxeLoading;

// node_modules/vxe-pc-ui/es/drawer/src/drawer.js
var allActiveDrawers = [];
var drawer_default = defineComponent({
  name: "VxeDrawer",
  props: {
    modelValue: Boolean,
    id: String,
    title: String,
    loading: {
      type: Boolean,
      default: null
    },
    className: String,
    position: {
      type: [String, Object],
      default: () => getConfig().drawer.position
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().drawer.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().drawer.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().drawer.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().drawer.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().drawer.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().drawer.confirmClosable
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().drawer.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().drawer.showFooter
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().drawer.showClose
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().drawer.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().drawer.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().drawer.confirmButtonText
    },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().drawer.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().drawer.showTitleOverflow
    },
    width: [Number, String],
    height: [Number, String],
    resize: {
      type: Boolean,
      default: () => getConfig().drawer.resize
    },
    zIndex: Number,
    transfer: {
      type: Boolean,
      default: () => getConfig().drawer.transfer
    },
    padding: {
      type: Boolean,
      default: () => getConfig().drawer.padding
    },
    size: {
      type: String,
      default: () => getConfig().drawer.size || getConfig().size
    },
    beforeHideMethod: {
      type: Function,
      default: () => getConfig().drawer.beforeHideMethod
    },
    slots: Object
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "resize"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils70.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refDrawerBox = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      drawerZIndex: 0
    });
    const refMaps = {
      refElem
    };
    const computeDragType = computed(() => {
      switch (props.position) {
        case "top":
          return "sb";
        case "bottom":
          return "st";
        case "left":
          return "wr";
      }
      return "wl";
    });
    const computeMaps = {};
    const $xeDrawer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getBox = () => {
      const boxElem = refDrawerBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = toCssUnit(width);
        boxElem.style.height = toCssUnit(height);
      }
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { drawerZIndex } = reactData;
      if (zIndex) {
        reactData.drawerZIndex = zIndex;
      } else if (drawerZIndex < getLastZIndex2()) {
        reactData.drawerZIndex = nextZIndex2();
      }
    };
    const closeDrawer2 = (type) => {
      const { beforeHideMethod } = props;
      const { visible } = reactData;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideMethod ? beforeHideMethod(params) : null).then((rest) => {
          if (!import_xe_utils70.default.isError(rest)) {
            reactData.contentVisible = false;
            import_xe_utils70.default.remove(allActiveDrawers, (item) => item === $xeDrawer);
            dispatchEvent2("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              dispatchEvent2("hide", params, null);
            }, 200);
          }
        }).catch((e16) => e16);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      dispatchEvent2(type, { type }, evnt);
      closeDrawer2(type);
    };
    const confirmEvent = (evnt) => {
      const { confirmClosable } = props;
      const type = "confirm";
      dispatchEvent2(type, { type }, evnt);
      if (confirmClosable) {
        closeDrawer2(type);
      }
    };
    const cancelEvent = (evnt) => {
      const { cancelClosable } = props;
      const type = "cancel";
      dispatchEvent2(type, { type }, evnt);
      if (cancelClosable) {
        closeDrawer2(type);
      }
    };
    const openDrawer2 = () => {
      const { showFooter } = props;
      const { initialized, visible } = reactData;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveDrawers.push($xeDrawer);
        setTimeout(() => {
          recalculate();
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            dispatchEvent2("show", params, null);
          });
        }, 10);
      }
      return nextTick();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $drawer: $xeDrawer }, params));
    };
    const drawerMethods = {
      dispatchEvent: dispatchEvent2,
      open: openDrawer2,
      close() {
        return closeDrawer2("close");
      },
      getBox
    };
    const selfClickEvent = (evnt) => {
      const el2 = refElem.value;
      if (props.maskClosable && evnt.target === el2) {
        const type = "mask";
        closeDrawer2(type);
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastDrawer = import_xe_utils70.default.max(allActiveDrawers, (item) => item.reactData.drawerZIndex);
        if (lastDrawer) {
          setTimeout(() => {
            if (lastDrawer === $xeDrawer && lastDrawer.props.escClosable) {
              const type = "exit";
              dispatchEvent2("close", { type }, evnt);
              closeDrawer2(type);
            }
          }, 10);
        }
      }
    };
    const boxMousedownEvent = () => {
      const { drawerZIndex } = reactData;
      if (allActiveDrawers.some((comp) => comp.reactData.visible && comp.reactData.drawerZIndex > drawerZIndex)) {
        updateZindex();
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { visibleHeight, visibleWidth } = getDomNode2();
      const marginSize = 0;
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = 0;
      const minHeight = 0;
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        dispatchEvent2("resize", params, evnt2);
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    const formDesignPrivateMethods = {};
    Object.assign($xeDrawer, drawerMethods, formDesignPrivateMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, title } = props;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      return [
        h("div", {
          class: "vxe-drawer--header-title"
        }, titleSlot ? getSlotVNs2(titleSlot({ $drawer: $xeDrawer })) : title ? getFuncText2(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-drawer--header-right"
        }, [
          cornerSlot ? h("div", {
            class: "vxe-drawer--corner-wrapper"
          }, getSlotVNs2(cornerSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
          showClose ? h("div", {
            class: ["vxe-drawer--close-btn", "trigger--btn"],
            title: getI18n("vxe.drawer.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().DRAWER_CLOSE
            })
          ]) : renderEmptyElement($xeDrawer)
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showTitleOverflow } = props;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        return h("div", {
          class: ["vxe-drawer--header", {
            "is--ellipsis": showTitleOverflow
          }]
        }, headerSlot ? getSlotVNs2(headerSlot({ $drawer: $xeDrawer })) : renderTitles());
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderBody = () => {
      const { slots: propSlots = {}, content } = props;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      return h("div", {
        class: "vxe-drawer--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-drawer--body-left"
        }, getSlotVNs2(leftSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
        h("div", {
          class: "vxe-drawer--body-default"
        }, [
          h("div", {
            class: "vxe-drawer--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({ $drawer: $xeDrawer })) : getFuncText2(content))
        ]),
        rightSlot ? h("div", {
          class: "vxe-drawer--body-right"
        }, getSlotVNs2(rightSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
        h(loading_default2, {
          class: "vxe-drawer--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton, loading: loading2 } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (showCancelButton) {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (showConfirmButton) {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading2,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-drawer--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-drawer--footer-left"
        }, lfSlot ? getSlotVNs2(lfSlot({ $drawer: $xeDrawer })) : []),
        h("div", {
          class: "vxe-drawer--footer-right"
        }, rfSlot ? getSlotVNs2(rfSlot({ $drawer: $xeDrawer })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-drawer--footer"
        }, footerSlot ? getSlotVNs2(footerSlot({ $drawer: $xeDrawer })) : [renderDefaultFooter()]);
      }
      return renderEmptyElement($xeDrawer);
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, position, loading: loading2, lockScroll, padding, lockView, mask, resize, destroyOnClose } = props;
      const { initialized, contentVisible, visible } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const dragType = computeDragType.value;
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !initialized : true
      }, [
        h("div", {
          ref: refElem,
          class: ["vxe-drawer--wrapper", `pos--${position}`, className || "", {
            [`size--${vSize}`]: vSize,
            "is--padding": padding,
            "lock--scroll": lockScroll,
            "lock--view": lockView,
            "is--resize": resize,
            "is--mask": mask,
            "is--visible": contentVisible,
            "is--active": visible,
            "is--loading": loading2
          }],
          style: {
            zIndex: reactData.drawerZIndex
          },
          onClick: selfClickEvent
        }, [
          h("div", {
            ref: refDrawerBox,
            class: "vxe-drawer--box",
            onMousedown: boxMousedownEvent
          }, [
            asideSlot ? h("div", {
              class: "vxe-drawer--aside"
            }, getSlotVNs2(asideSlot({ $drawer: $xeDrawer }))) : renderEmptyElement($xeDrawer),
            h("div", {
              class: "vxe-drawer--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter(),
              resize ? h("span", {
                class: "vxe-drawer--resize"
              }, [
                h("span", {
                  class: `${dragType}-resize`,
                  type: dragType,
                  onMousedown: dragEvent
                })
              ]) : renderEmptyElement($xeDrawer)
            ])
          ])
        ])
      ]);
    };
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openDrawer2();
      } else {
        closeDrawer2("model");
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (props.modelValue) {
          openDrawer2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeDrawer, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeDrawer, "keydown");
    });
    provide("$xeDrawer", "$xeDrawer");
    $xeDrawer.renderVN = renderVN;
    return $xeDrawer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/drawer/index.js
function handleDrawer(options) {
  checkDynamic();
  return new Promise((resolve) => {
    if (options && options.id && allActiveDrawers.some((comp) => comp.props.id === options.id)) {
      resolve("exist");
    } else {
      const _onHide = options.onHide;
      const drawerOpts = Object.assign(options, {
        key: import_xe_utils71.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const drawerList = dynamicStore.drawers;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.drawers = drawerList.filter((item) => item.key !== drawerOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.drawers.push(drawerOpts);
    }
  });
}
function getDrawer(id2) {
  return import_xe_utils71.default.find(allActiveDrawers, ($drawer) => $drawer.props.id === id2);
}
function closeDrawer(id2) {
  const drawers = id2 ? [getDrawer(id2)] : allActiveDrawers;
  const restPromises = [];
  drawers.forEach(($drawer) => {
    if ($drawer) {
      restPromises.push($drawer.close());
    }
  });
  return Promise.all(restPromises);
}
function openDrawer(options) {
  return handleDrawer(Object.assign({}, options));
}
var DrawerController = {
  get: getDrawer,
  close: closeDrawer,
  open: openDrawer
};
var VxeDrawer = Object.assign(drawer_default, {
  install: function(app) {
    app.component(drawer_default.name, drawer_default);
  }
});
VxeUI.drawer = DrawerController;
dynamicApp.use(VxeDrawer);
VxeUI.component(drawer_default);
var Drawer = VxeDrawer;
var drawer_default2 = VxeDrawer;

// node_modules/vxe-pc-ui/es/empty/src/empty.js
var import_xe_utils72 = __toESM(require_xe_utils());
var empty_default = defineComponent({
  name: "VxeEmpty",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    status: String,
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils72.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeEmpty = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $empty: $xeEmpty }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeEmpty, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { imageUrl, imageStyle, icon, status, content } = props;
      return h("div", {
        ref: refElem,
        class: ["vxe-empty", {
          [`theme--${status}`]: status
        }]
      }, [
        h("div", {
          class: "vxe-empty--inner"
        }, [
          imageUrl ? h("div", {
            class: "vxe-empty--img-wrapper"
          }, [
            h("img", {
              src: imageUrl,
              style: imageStyle
            })
          ]) : h("div", {
            class: "vxe-empty--icon-wrapper"
          }, [
            h("i", {
              class: icon || getIcon().EMPTY_DEFAULT
            })
          ]),
          h("div", {
            class: "vxe-empty--content-wrapper"
          }, `${content || getI18n("vxe.empty.defText")}`)
        ])
      ]);
    };
    $xeEmpty.renderVN = renderVN;
    return $xeEmpty;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/empty/index.js
var VxeEmpty = Object.assign({}, empty_default, {
  install(app) {
    app.component(empty_default.name, empty_default);
  }
});
dynamicApp.use(VxeEmpty);
VxeUI.component(empty_default);
var Empty = VxeEmpty;
var empty_default2 = VxeEmpty;

// node_modules/vxe-pc-ui/es/form/src/form.js
var import_xe_utils78 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form/src/util.js
var import_xe_utils74 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form/src/itemInfo.js
var import_xe_utils73 = __toESM(require_xe_utils());
var ItemInfo = class {
  constructor($xeForm, item) {
    Object.assign(this, {
      id: import_xe_utils73.default.uniqueId("item_"),
      title: item.title,
      field: item.field,
      span: item.span,
      align: item.align,
      verticalAlign: item.verticalAlign,
      titleBackground: item.titleBackground,
      titleBold: item.titleBold,
      titleAlign: item.titleAlign,
      titleWidth: item.titleWidth,
      titleColon: item.titleColon,
      vertical: item.vertical,
      padding: item.padding,
      titleAsterisk: item.titleAsterisk,
      titlePrefix: item.titlePrefix,
      titleSuffix: item.titleSuffix,
      titleOverflow: item.titleOverflow,
      showTitle: item.showTitle,
      resetValue: item.resetValue,
      visibleMethod: item.visibleMethod,
      visible: item.visible,
      showContent: item.showContent,
      folding: item.folding,
      collapseNode: item.collapseNode,
      className: item.className,
      contentClassName: item.contentClassName,
      contentStyle: item.contentStyle,
      titleClassName: item.titleClassName,
      titleStyle: item.titleStyle,
      itemRender: item.itemRender,
      rules: item.rules,
      // 渲染属性
      showError: false,
      errRule: null,
      slots: item.slots,
      children: []
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/vxe-pc-ui/es/form/src/util.js
function isFormItem(item) {
  return item instanceof ItemInfo;
}
function createItem($xeForm, _vm) {
  return isFormItem(_vm) ? _vm : new ItemInfo($xeForm, _vm);
}
function handleFieldOrItem($xeForm, fieldOrItem) {
  if (fieldOrItem) {
    return import_xe_utils74.default.isString(fieldOrItem) ? $xeForm.getItemByField(fieldOrItem) : fieldOrItem;
  }
  return null;
}
function isHiddenItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { collapseAll } = reactData;
  const { folding, visible } = formItem;
  return visible === false || folding && collapseAll;
}
function isActiveItem($xeForm, formItem) {
  let { visibleMethod, itemRender, visible, field } = formItem;
  if (visible === false) {
    return visible;
  }
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const fiVisibleMethod = compConf ? compConf.formItemVisibleMethod || compConf.itemVisibleMethod : null;
  if (!visibleMethod && fiVisibleMethod) {
    visibleMethod = fiVisibleMethod;
  }
  if (!visibleMethod) {
    return true;
  }
  const formProps = $xeForm.props;
  const { data } = formProps;
  return visibleMethod({ data, field, property: field, item: formItem, $form: $xeForm, $grid: $xeForm.xegrid });
}
function watchItem(props, formItem) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      formItem.update(name, value);
    });
  });
}
function assembleItem($xeForm, el2, formItem, formGroup) {
  const { reactData } = $xeForm;
  const formProps = $xeForm.props;
  const { customLayout } = formProps;
  const { staticItems } = reactData;
  if (customLayout) {
    if (!staticItems.some((item) => item.id === formItem.id)) {
      staticItems.push(formItem);
    }
  } else {
    if (el2) {
      const parentElem = el2.parentNode;
      const parentItem = formGroup ? formGroup.formItem : null;
      const parentItems = parentItem ? parentItem.children : staticItems;
      if (parentElem) {
        parentItems.splice(import_xe_utils74.default.arrayIndexOf(parentElem.children, el2), 0, formItem);
        reactData.staticItems = staticItems.slice(0);
      }
    }
  }
}
function destroyItem($xeForm, formItem) {
  const { reactData } = $xeForm;
  const { staticItems } = reactData;
  const index2 = import_xe_utils74.default.findIndexOf(staticItems, (item) => item.id === formItem.id);
  if (index2 > -1) {
    staticItems.splice(index2, 1);
  }
  reactData.staticItems = staticItems.slice(0);
}

// node_modules/vxe-pc-ui/es/icon/src/icon.js
var import_xe_utils75 = __toESM(require_xe_utils());
var icon_default = defineComponent({
  name: "VxeIcon",
  props: {
    name: String,
    className: String,
    roll: Boolean,
    status: String,
    size: {
      type: String,
      default: () => getConfig().icon.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils75.default.uniqueId();
    const { computeSize } = useSize(props);
    const $xeIcon = {
      xID,
      props,
      context
    };
    const clickEvent = (evnt) => {
      emit("click", createEvent(evnt, {}));
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $icon: $xeIcon }, params));
    };
    const iconMethods = {
      dispatchEvent: dispatchEvent2
    };
    const iconPrivateMethods = {};
    Object.assign($xeIcon, iconMethods, iconPrivateMethods);
    const renderVN = () => {
      const { name, roll, status, className } = props;
      const vSize = computeSize.value;
      return h("i", {
        class: ["vxe-icon", `vxe-icon-${name}`, `${className || ""}`, {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          roll
        }],
        onClick: clickEvent
      });
    };
    $xeIcon.renderVN = renderVN;
    return $xeIcon;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/src/render.js
var import_xe_utils76 = __toESM(require_xe_utils());
function renderPrefixIcon(titlePrefix) {
  return h("span", {
    class: "vxe-form--item-title-prefix"
  }, [
    h(icon_default, {
      class: titlePrefix.icon || getIcon().FORM_PREFIX,
      status: titlePrefix.iconStatus
    })
  ]);
}
function renderSuffixIcon(titleSuffix) {
  return h("span", {
    class: "vxe-form--item-title-suffix"
  }, [
    h(icon_default, {
      class: titleSuffix.icon || getIcon().FORM_SUFFIX,
      status: titleSuffix.iconStatus
    })
  ]);
}
var getItemClass = ($xeForm, item, isGroup) => {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const { data, rules, readonly, disabled, span: allSpan, titleBackground: allTitleBackground, titleBold: allTitleBold, titleColon: allTitleColon, titleAsterisk: allTitleAsterisk, vertical: allVertical, padding: allPadding } = formProps;
  const { collapseAll } = formReactData;
  const { folding, field, itemRender, showError, className, vertical, padding, children, showContent } = item;
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const itemClassName = compConf ? compConf.formItemClassName || compConf.itemClassName : "";
  const span = item.span || allSpan;
  const itemPadding = import_xe_utils76.default.eqNull(padding) ? allPadding : padding;
  const itemVertical = import_xe_utils76.default.eqNull(vertical) ? allVertical : vertical;
  const titleBackground = import_xe_utils76.default.eqNull(item.titleBackground) ? allTitleBackground : item.titleBackground;
  const titleBold = import_xe_utils76.default.eqNull(item.titleBold) ? allTitleBold : item.titleBold;
  const titleColon = import_xe_utils76.default.eqNull(item.titleColon) ? allTitleColon : item.titleColon;
  const titleAsterisk = import_xe_utils76.default.eqNull(item.titleAsterisk) ? allTitleAsterisk : item.titleAsterisk;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  const hasGroup = children && children.length > 0;
  let isRequired = false;
  let isValid = false;
  if (!readonly && rules) {
    const itemRules = rules[field];
    if (itemRules && itemRules.length) {
      isValid = true;
      isRequired = itemRules.some((rule) => rule.required);
    }
  }
  return [
    isGroup || hasGroup ? "vxe-form--group" : "",
    "vxe-form--item",
    item.id,
    span ? `vxe-form--item-col_${span} is--span` : "",
    className ? import_xe_utils76.default.isFunction(className) ? className(params) : className : "",
    itemClassName ? import_xe_utils76.default.isFunction(itemClassName) ? itemClassName(params) : itemClassName : "",
    {
      "is--colon": titleColon,
      "is--tbg": titleBackground,
      "is--bold": titleBold,
      "is--padding": itemPadding,
      "is--vertical": itemVertical,
      "is--asterisk": titleAsterisk,
      "hide--content": showContent === false,
      "is--valid": isValid,
      "is--required": isRequired,
      "is--hidden": folding && collapseAll,
      "is--active": isActiveItem($xeForm, item),
      "is--error": showError
    }
  ];
};
var getItemContentClass = ($xeForm, item, isGroup) => {
  const formProps = $xeForm.props;
  const { data, readonly, disabled, align: allAlign, verticalAlign: allVerticalAlign } = formProps;
  const { field, itemRender, contentClassName, children } = item;
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const itemContentClassName = compConf ? compConf.formItemContentClassName || compConf.itemContentClassName : "";
  const align = import_xe_utils76.default.eqNull(item.align) ? allAlign : item.align;
  const verticalAlign = import_xe_utils76.default.eqNull(item.verticalAlign) ? allVerticalAlign : item.verticalAlign;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  const hasGroup = children && children.length > 0;
  return [
    isGroup || hasGroup ? "vxe-form--group-content vxe-form--item-row" : "",
    "vxe-form--item-content",
    align ? `align--${align}` : "",
    verticalAlign ? `vertical-align--${verticalAlign}` : "",
    itemContentClassName ? import_xe_utils76.default.isFunction(itemContentClassName) ? itemContentClassName(params) : itemContentClassName : "",
    contentClassName ? import_xe_utils76.default.isFunction(contentClassName) ? contentClassName(params) : contentClassName : ""
  ];
};
function renderTitle($xeForm, item, isGroup) {
  const formProps = $xeForm.props;
  const { data, readonly, disabled, titleAlign: allTitleAlign, titleWidth: allTitleWidth, titleOverflow: allTitleOverflow, vertical: allVertical } = formProps;
  const { slots, title, field, itemRender, titleOverflow, vertical, showTitle, titleClassName, titleStyle, titlePrefix, titleSuffix, children, showContent } = item;
  const { computeTooltipOpts } = $xeForm.getComputeMaps();
  const tooltipOpts = computeTooltipOpts.value;
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const itemTitleClassName = compConf ? compConf.formItemTitleClassName || compConf.itemTitleClassName : "";
  const itemTitleStyle = compConf ? compConf.formItemTitleStyle || compConf.itemTitleStyle : null;
  const itemVertical = import_xe_utils76.default.eqNull(vertical) ? allVertical : vertical;
  const titleAlign = import_xe_utils76.default.eqNull(item.titleAlign) ? allTitleAlign : item.titleAlign;
  const titleWidth = itemVertical ? null : import_xe_utils76.default.eqNull(item.titleWidth) ? allTitleWidth : item.titleWidth;
  const itemOverflow = import_xe_utils76.default.eqNull(titleOverflow) ? allTitleOverflow : titleOverflow;
  const ovEllipsis = itemOverflow === "ellipsis";
  const ovTitle = itemOverflow === "title";
  const ovTooltip = itemOverflow === true || itemOverflow === "tooltip";
  const hasEllipsis = ovTitle || ovTooltip || ovEllipsis;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  const titleSlot = slots ? slots.title : null;
  const extraSlot = slots ? slots.extra : null;
  const isTitle = showTitle !== false && (title || titleSlot);
  const hasGroup = children && children.length > 0;
  const titVNs = [];
  if (titlePrefix) {
    titVNs.push(titlePrefix.content || titlePrefix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titlePrefix), { content: getFuncText2(titlePrefix.content || titlePrefix.message) }), {
      default: () => renderPrefixIcon(titlePrefix)
    }) : renderPrefixIcon(titlePrefix));
  }
  const rftTitle = compConf ? compConf.renderFormItemTitle || compConf.renderItemTitle : null;
  titVNs.push(h("span", {
    class: "vxe-form--item-title-label"
  }, titleSlot ? $xeForm.callSlot(titleSlot, params) : rftTitle ? getSlotVNs2(rftTitle(itemRender, params)) : getFuncText2(item.title)));
  const fixVNs = [];
  if (titleSuffix) {
    fixVNs.push(titleSuffix.content || titleSuffix.message ? h(tooltip_default, Object.assign(Object.assign(Object.assign({}, tooltipOpts), titleSuffix), { content: getFuncText2(titleSuffix.content || titleSuffix.message) }), {
      default: () => renderSuffixIcon(titleSuffix)
    }) : renderSuffixIcon(titleSuffix));
  }
  const ons = ovTooltip ? {
    onMouseenter(evnt) {
      $xeForm.triggerTitleTipEvent(evnt, params);
    },
    onMouseleave: $xeForm.handleTitleTipLeaveEvent
  } : {};
  return isTitle ? h("div", Object.assign({ class: [
    isGroup || hasGroup ? "vxe-form--group-title" : "",
    "vxe-form--item-title",
    titleAlign ? `align--${titleAlign}` : "",
    hasEllipsis ? "is--ellipsis" : "",
    itemTitleClassName ? import_xe_utils76.default.isFunction(itemTitleClassName) ? itemTitleClassName(params) : itemTitleClassName : "",
    titleClassName ? import_xe_utils76.default.isFunction(titleClassName) ? titleClassName(params) : titleClassName : ""
  ], style: Object.assign({}, import_xe_utils76.default.isFunction(itemTitleStyle) ? itemTitleStyle(params) : itemTitleStyle, import_xe_utils76.default.isFunction(titleStyle) ? titleStyle(params) : titleStyle, titleWidth && showContent !== false ? {
    width: toCssUnit(titleWidth)
  } : null), title: ovTitle ? getFuncText2(title) : null }, ons), [
    h("div", {
      class: "vxe-form--item-title-content"
    }, titVNs),
    h("div", {
      class: "vxe-form--item-title-postfix"
    }, fixVNs),
    extraSlot ? h("div", {
      class: "vxe-form--item-title-extra"
    }, $xeForm.callSlot(extraSlot, params)) : createCommentVNode()
  ]) : createCommentVNode();
}
var renderItemContent = ($xeForm, item) => {
  const formProps = $xeForm.props;
  const formReactData = $xeForm.reactData;
  const { computeCollapseOpts, computeValidOpts } = $xeForm.getComputeMaps();
  const { data, readonly, disabled } = formProps;
  const { collapseAll } = formReactData;
  const { slots, field, itemRender, collapseNode, errRule } = item;
  const defaultSlot = slots ? slots.default : null;
  const validSlot = slots ? slots.valid : null;
  const collapseOpts = computeCollapseOpts.value;
  const validOpts = computeValidOpts.value;
  const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
  const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
  let contentVNs = [];
  const rftContent = compConf ? compConf.renderFormItemContent || compConf.renderItemContent : null;
  if (defaultSlot) {
    contentVNs = $xeForm.callSlot(defaultSlot, params);
  } else if (rftContent) {
    contentVNs = getSlotVNs2(rftContent(itemRender, params));
  } else if (field) {
    contentVNs = [`${import_xe_utils76.default.get(data, field)}`];
  }
  if (collapseNode) {
    contentVNs.push(h("div", {
      class: "vxe-form--item-trigger-node",
      onClick: $xeForm.toggleCollapseEvent
    }, [
      h("span", {
        class: "vxe-form--item-trigger-text"
      }, collapseAll ? collapseOpts.unfoldButtonText || getI18n("vxe.form.unfolding") : collapseOpts.foldButtonText || getI18n("vxe.form.folding")),
      h("i", {
        class: ["vxe-form--item-trigger-icon", collapseAll ? collapseOpts.foldIcon || getIcon().FORM_FOLDING : collapseOpts.unfoldIcon || getIcon().FORM_UNFOLDING]
      })
    ]));
  }
  if (errRule && validOpts.showMessage) {
    const validParams = Object.assign(Object.assign({}, params), { rule: errRule });
    contentVNs.push(h("div", {
      class: "vxe-form-item--valid-error-tip",
      style: errRule.maxWidth ? {
        width: toCssUnit(errRule.maxWidth)
      } : null
    }, [
      h("div", {
        class: `vxe-form-item--valid-error-wrapper vxe-form-item--valid-error-theme-${validOpts.theme || "normal"}`
      }, [
        validSlot ? $xeForm.callSlot(validSlot, validParams) : [
          h("span", {
            class: "vxe-form--item--valid-error-msg"
          }, errRule.content || errRule.message)
        ]
      ])
    ]));
  }
  return h("div", {
    class: "vxe-form--item-inner"
  }, contentVNs);
};

// node_modules/vxe-pc-ui/es/form/src/form-config-item.js
var import_xe_utils77 = __toESM(require_xe_utils());
var VxeFormConfigItem = defineComponent({
  name: "VxeFormConfigItem",
  props: {
    itemConfig: Object
  },
  setup(props) {
    const $xeForm = inject("$xeForm", {});
    const xeformiteminfo = { itemConfig: props.itemConfig };
    provide("xeFormItemInfo", xeformiteminfo);
    const renderItem = ($xeForm2, item) => {
      const formProps = $xeForm2.props;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle, children, showContent } = item;
      const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeForm2.xegrid };
      const hasGroup = children && children.length > 0;
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        key: item.id,
        class: getItemClass($xeForm2, item),
        style: import_xe_utils77.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm2, item),
        showContent === false ? createCommentVNode() : h("div", {
          class: getItemContentClass($xeForm2, item),
          style: Object.assign({}, import_xe_utils77.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils77.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, hasGroup ? children.map((childItem) => renderItem($xeForm2, childItem)) : [
          renderItemContent($xeForm2, item)
        ])
      ]);
    };
    const renderVN = () => {
      return renderItem($xeForm, props.itemConfig);
    };
    const $xeFormconfigitem = {
      renderVN
    };
    provide("$xeFormGroup", null);
    return $xeFormconfigitem;
  },
  render() {
    return this.renderVN();
  }
});
var form_config_item_default = VxeFormConfigItem;

// node_modules/vxe-pc-ui/es/form/src/form.js
var Rule2 = class {
  constructor(rule) {
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.min,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }
  get content() {
    return getFuncText2(this.$options.content || this.$options.message);
  }
  get message() {
    return this.content;
  }
};
var validErrorRuleValue = (rule, val) => {
  const { type, min, max, pattern } = rule;
  const isNumType = type === "number";
  const numVal = isNumType ? import_xe_utils78.default.toNumber(val) : import_xe_utils78.default.getSize(val);
  if (isNumType && isNaN(val)) {
    return true;
  }
  if (!import_xe_utils78.default.eqNull(min) && numVal < import_xe_utils78.default.toNumber(min)) {
    return true;
  }
  if (!import_xe_utils78.default.eqNull(max) && numVal > import_xe_utils78.default.toNumber(max)) {
    return true;
  }
  if (pattern && !(import_xe_utils78.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
};
var form_default = defineComponent({
  name: "VxeForm",
  props: {
    collapseStatus: {
      type: Boolean,
      default: true
    },
    loading: Boolean,
    data: Object,
    size: {
      type: String,
      default: () => getConfig().form.size || getConfig().size
    },
    span: {
      type: [String, Number],
      default: () => getConfig().form.span
    },
    align: {
      type: String,
      default: () => getConfig().form.align
    },
    verticalAlign: {
      type: String,
      default: () => getConfig().form.verticalAlign
    },
    border: {
      type: Boolean,
      default: () => getConfig().form.border
    },
    titleBackground: {
      type: Boolean,
      default: () => getConfig().form.titleBackground
    },
    titleBold: {
      type: Boolean,
      default: () => getConfig().form.titleBold
    },
    titleAlign: {
      type: String,
      default: () => getConfig().form.titleAlign
    },
    titleWidth: {
      type: [String, Number],
      default: () => getConfig().form.titleWidth
    },
    titleColon: {
      type: Boolean,
      default: () => getConfig().form.titleColon
    },
    titleAsterisk: {
      type: Boolean,
      default: () => getConfig().form.titleAsterisk
    },
    titleOverflow: {
      type: [Boolean, String],
      default: () => getConfig().form.titleOverflow
    },
    vertical: {
      type: Boolean,
      default: () => getConfig().form.vertical
    },
    padding: {
      type: Boolean,
      default: () => getConfig().form.padding
    },
    className: [String, Function],
    readonly: Boolean,
    disabled: Boolean,
    items: Array,
    rules: Object,
    preventSubmit: {
      type: Boolean,
      default: () => getConfig().form.preventSubmit
    },
    validConfig: Object,
    tooltipConfig: Object,
    collapseConfig: Object,
    customLayout: {
      type: Boolean,
      default: () => getConfig().form.customLayout
    }
  },
  emits: [
    "update:collapseStatus",
    "collapse",
    "toggle-collapse",
    "submit",
    "submit-invalid",
    "reset"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils78.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      collapseAll: props.collapseStatus,
      staticItems: [],
      formItems: []
    });
    const internalData = reactive({
      meTimeout: void 0,
      stTimeout: void 0,
      tooltipStore: {
        item: null,
        visible: false
      }
    });
    provide("xeFormItemInfo", null);
    const $xeGrid = inject("$xeGrid", null);
    const refElem = ref();
    const refTooltip = ref();
    let formMethods = {};
    const computeValidOpts = computed(() => {
      return Object.assign({}, getConfig().form.validConfig, props.validConfig);
    });
    const computeTooltipOpts = computed(() => {
      return Object.assign({}, getConfig().tooltip, getConfig().form.tooltipConfig, props.tooltipConfig);
    });
    const computeCollapseOpts = computed(() => {
      return Object.assign({}, getConfig().form.collapseConfig, props.collapseConfig);
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize,
      computeValidOpts,
      computeTooltipOpts,
      computeCollapseOpts
    };
    const $xeForm = {
      xID,
      props,
      context,
      reactData,
      xegrid: $xeGrid,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils78.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils78.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const loadItem = (list) => {
      if (list.length) {
        if (true) {
          list.forEach((item) => {
            if (item.slots) {
              import_xe_utils78.default.each(item.slots, (func) => {
                if (!import_xe_utils78.default.isFunction(func)) {
                  if (!slots[func]) {
                    errLog2("vxe.error.notSlot", [func]);
                  }
                }
              });
            }
          });
        }
      }
      reactData.staticItems = import_xe_utils78.default.mapTree(list, (item) => createItem($xeForm, item), { children: "children" });
      return nextTick();
    };
    const getItems = () => {
      const itemList = [];
      import_xe_utils78.default.eachTree(reactData.formItems, (item) => {
        itemList.push(item);
      }, { children: "children" });
      return itemList;
    };
    const getItemByField = (field) => {
      const rest = import_xe_utils78.default.findTree(reactData.formItems, (item) => item.field === field, { children: "children" });
      return rest ? rest.item : null;
    };
    const getCollapseStatus = () => {
      return reactData.collapseAll;
    };
    const toggleCollapse = () => {
      const status = !getCollapseStatus();
      reactData.collapseAll = status;
      emit("update:collapseStatus", status);
      return nextTick();
    };
    const toggleCollapseEvent = (evnt) => {
      toggleCollapse();
      const status = getCollapseStatus();
      formMethods.dispatchEvent("toggle-collapse", { status, collapse: status, data: props.data }, evnt);
      formMethods.dispatchEvent("collapse", { status, collapse: status, data: props.data }, evnt);
    };
    const clearValidate = (fieldOrItem) => {
      if (fieldOrItem) {
        let fields = fieldOrItem;
        if (!import_xe_utils78.default.isArray(fieldOrItem)) {
          fields = [fieldOrItem];
        }
        fields.forEach((field) => {
          if (field) {
            const item = handleFieldOrItem($xeForm, field);
            if (item) {
              item.showError = false;
            }
          }
        });
      } else {
        getItems().forEach((item) => {
          item.showError = false;
        });
      }
      return nextTick();
    };
    const getResetValue = (item, data) => {
      const { field, resetValue } = item;
      const itemValue = import_xe_utils78.default.get(data, field);
      if (import_xe_utils78.default.isFunction(resetValue)) {
        return resetValue({ field, item, data, $form: $xeForm, $grid: $xeForm.xegrid });
      } else if (resetValue === null) {
        if (import_xe_utils78.default.isArray(itemValue)) {
          return [];
        }
      }
    };
    const reset = () => {
      const { data } = props;
      const itemList = getItems();
      if (data) {
        itemList.forEach((item) => {
          const { field, itemRender } = item;
          if (isEnableConf2(itemRender)) {
            const compConf = renderer.get(itemRender.name);
            const fiResetMethod = compConf ? compConf.formItemResetMethod || compConf.itemResetMethod : null;
            if (compConf && fiResetMethod) {
              fiResetMethod({ data, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid });
            } else if (field) {
              import_xe_utils78.default.set(data, field, getResetValue(item, data));
            }
          }
        });
      }
      return clearValidate();
    };
    const resetEvent = (evnt) => {
      evnt.preventDefault();
      reset();
      formMethods.dispatchEvent("reset", { data: props.data }, evnt);
    };
    const handleFocus = (fields) => {
      const el2 = refElem.value;
      if (el2) {
        for (let i = 0; i < fields.length; i++) {
          const field = fields[i];
          const item = getItemByField(field);
          if (item && isEnableConf2(item.itemRender)) {
            const { itemRender } = item;
            const compConf = renderer.get(itemRender.name);
            if (!i) {
              scrollToView2(el2.querySelector(`.${item.id}`));
            }
            let inputElem = null;
            const autoFocus = itemRender.autoFocus || itemRender.autofocus || (compConf ? compConf.formItemAutoFocus : null);
            if (import_xe_utils78.default.isFunction(autoFocus)) {
              inputElem = autoFocus({ $form: $xeForm, $grid: $xeGrid, item, data: props.data, field });
            } else {
              if (autoFocus === true) {
                inputElem = el2.querySelector(`.${item.id} input,textarea`);
              } else if (autoFocus) {
                inputElem = el2.querySelector(`.${item.id} ${autoFocus}`);
              }
            }
            if (inputElem) {
              inputElem.focus();
              break;
            }
          }
        }
      }
    };
    const validItemRules = (validType, fields, val) => {
      const { data, rules: formRules } = props;
      const errorMaps = {};
      if (!import_xe_utils78.default.isArray(fields)) {
        fields = [fields];
      }
      return Promise.all(fields.map((property) => {
        const errorRules = [];
        const syncVailds = [];
        if (property && formRules) {
          const rules = import_xe_utils78.default.get(formRules, property);
          if (rules) {
            const itemValue = import_xe_utils78.default.isUndefined(val) ? import_xe_utils78.default.get(data, property) : val;
            rules.forEach((rule) => {
              const { type, trigger, required, validator } = rule;
              if (validType === "all" || !trigger || validType === trigger) {
                if (validator) {
                  const validParams = {
                    itemValue,
                    rule,
                    rules,
                    data,
                    field: property,
                    property,
                    $form: $xeForm
                  };
                  let customValid;
                  if (import_xe_utils78.default.isString(validator)) {
                    const gvItem = validators.get(validator);
                    if (gvItem) {
                      const validatorMethod = gvItem.formItemValidatorMethod || gvItem.itemValidatorMethod;
                      if (validatorMethod) {
                        customValid = validatorMethod(validParams);
                      } else {
                        if (true) {
                          warnLog2("vxe.error.notValidators", [validator]);
                        }
                      }
                    } else {
                      if (true) {
                        errLog2("vxe.error.notValidators", [validator]);
                      }
                    }
                  } else {
                    customValid = validator(validParams);
                  }
                  if (customValid) {
                    if (import_xe_utils78.default.isError(customValid)) {
                      errorRules.push(new Rule2({ type: "custom", trigger, content: customValid.message, rule: new Rule2(rule) }));
                    } else if (customValid.catch) {
                      syncVailds.push(customValid.catch((e16) => {
                        errorRules.push(new Rule2({ type: "custom", trigger, content: e16 ? e16.message : rule.content || rule.message, rule: new Rule2(rule) }));
                      }));
                    }
                  }
                } else {
                  const isArrType = type === "array";
                  const isArrVal = import_xe_utils78.default.isArray(itemValue);
                  let hasEmpty = true;
                  if (isArrType || isArrVal) {
                    hasEmpty = !isArrVal || !itemValue.length;
                  } else if (import_xe_utils78.default.isString(itemValue)) {
                    hasEmpty = eqEmptyValue2(itemValue.trim());
                  } else {
                    hasEmpty = eqEmptyValue2(itemValue);
                  }
                  if (required ? hasEmpty || validErrorRuleValue(rule, itemValue) : !hasEmpty && validErrorRuleValue(rule, itemValue)) {
                    errorRules.push(new Rule2(rule));
                  }
                }
              }
            });
          }
        }
        return Promise.all(syncVailds).then(() => {
          if (errorRules.length) {
            errorMaps[property] = errorRules.map((rule) => {
              return {
                $form: $xeForm,
                rule,
                data,
                field: property,
                property
              };
            });
          }
        });
      })).then(() => {
        if (!import_xe_utils78.default.isEmpty(errorMaps)) {
          return Promise.reject(errorMaps);
        }
      });
    };
    const beginValidate = (itemList, type, callback) => {
      const { data, rules: formRules } = props;
      const validOpts = computeValidOpts.value;
      const validRest = {};
      const validFields = [];
      const itemValids = [];
      clearTimeout(internalData.meTimeout);
      if (data && formRules) {
        itemList.forEach((item) => {
          const { field } = item;
          if (field && !isHiddenItem($xeForm, item) && isActiveItem($xeForm, item)) {
            itemValids.push(validItemRules(type || "all", field).then(() => {
              item.errRule = null;
            }).catch((errorMaps) => {
              const rest = errorMaps[field];
              if (!validRest[field]) {
                validRest[field] = [];
              }
              validRest[field].push(rest);
              validFields.push(field);
              item.errRule = rest[0].rule;
              return Promise.reject(rest);
            }));
          }
        });
        return Promise.all(itemValids).then(() => {
          if (callback) {
            callback();
          }
        }).catch(() => {
          return new Promise((resolve) => {
            internalData.meTimeout = window.setTimeout(() => {
              itemList.forEach((item) => {
                if (item.errRule) {
                  item.showError = true;
                }
              });
            }, 20);
            if (validOpts.autoPos !== false) {
              nextTick(() => {
                handleFocus(validFields);
              });
            }
            if (callback) {
              callback(validRest);
              resolve();
            } else {
              resolve(validRest);
            }
          });
        });
      }
      if (callback) {
        callback();
      }
      return Promise.resolve();
    };
    const validate = (callback) => {
      const { readonly } = props;
      clearValidate();
      if (readonly) {
        return nextTick();
      }
      return beginValidate(getItems(), "", callback);
    };
    const validateField = (fieldOrItem, callback) => {
      const { readonly } = props;
      if (readonly) {
        return nextTick();
      }
      let fields = [];
      if (fieldOrItem) {
        if (import_xe_utils78.default.isArray(fieldOrItem)) {
          fields = fieldOrItem;
        } else {
          fields = [fieldOrItem];
        }
      }
      return beginValidate(fields.map((field) => handleFieldOrItem($xeForm, field)), "", callback);
    };
    const submitEvent = (evnt) => {
      const { readonly } = props;
      evnt.preventDefault();
      if (!props.preventSubmit) {
        clearValidate();
        if (readonly) {
          formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          return;
        }
        beginValidate(getItems()).then((errMap) => {
          if (errMap) {
            formMethods.dispatchEvent("submit-invalid", { data: props.data, errMap }, evnt);
          } else {
            formMethods.dispatchEvent("submit", { data: props.data }, evnt);
          }
        });
      }
    };
    const closeTooltip = () => {
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      if (tooltipStore.visible) {
        Object.assign(tooltipStore, {
          item: null,
          visible: false
        });
        if ($tooltip) {
          $tooltip.close();
        }
      }
      return nextTick();
    };
    const triggerTitleTipEvent = (evnt, params) => {
      const { item } = params;
      const { tooltipStore } = internalData;
      const $tooltip = refTooltip.value;
      const overflowElem = evnt.currentTarget.children[0];
      const content = (overflowElem.textContent || "").trim();
      const isCellOverflow = overflowElem.scrollWidth > overflowElem.clientWidth;
      clearTimeout(internalData.stTimeout);
      if (tooltipStore.item !== item) {
        closeTooltip();
      }
      if (content && isCellOverflow) {
        Object.assign(tooltipStore, {
          item,
          visible: true
        });
        if ($tooltip) {
          $tooltip.open(overflowElem, content);
        }
      }
    };
    const handleTitleTipLeaveEvent = () => {
      const tooltipOpts = computeTooltipOpts.value;
      let $tooltip = refTooltip.value;
      if ($tooltip) {
        $tooltip.setActived(false);
      }
      if (tooltipOpts.enterable) {
        internalData.stTimeout = setTimeout(() => {
          $tooltip = refTooltip.value;
          if ($tooltip && !$tooltip.isActived()) {
            closeTooltip();
          }
        }, tooltipOpts.leaveDelay);
      } else {
        closeTooltip();
      }
    };
    const triggerItemEvent = (evnt, field, itemValue) => {
      if (field) {
        return validItemRules(evnt ? ["blur"].includes(evnt.type) ? "blur" : "change" : "all", field, itemValue).then(() => {
          clearValidate(field);
        }).catch((errorMaps) => {
          const rest = errorMaps[field];
          const item = getItemByField(field);
          if (rest && item) {
            item.showError = true;
            item.errRule = rest[0].rule;
          }
        });
      }
      return nextTick();
    };
    const updateStatus = (scope, itemValue) => {
      const { field } = scope;
      return triggerItemEvent(new Event("change"), field, itemValue);
    };
    formMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $form: $xeForm, $grid: $xeGrid }, params));
      },
      reset,
      validate,
      validateField,
      clearValidate,
      updateStatus,
      toggleCollapse,
      getItems,
      getItemByField,
      closeTooltip
    };
    const formPrivateMethods = {
      callSlot,
      triggerItemEvent,
      toggleCollapseEvent,
      triggerTitleTipEvent,
      handleTitleTipLeaveEvent
    };
    Object.assign($xeForm, formMethods, formPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, border, className, data, customLayout } = props;
      const { formItems } = reactData;
      const vSize = computeSize.value;
      const tooltipOpts = computeTooltipOpts.value;
      const defaultSlot = slots.default;
      return h("form", {
        ref: refElem,
        class: ["vxe-form", className ? import_xe_utils78.default.isFunction(className) ? className({ items: formItems, data, $form: $xeForm }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--border": border,
          "custom--layout": customLayout,
          "is--loading": loading2
        }],
        onSubmit: submitEvent,
        onReset: resetEvent
      }, [
        h("div", {
          class: "vxe-form--wrapper vxe-form--item-row"
        }, customLayout ? defaultSlot ? defaultSlot({}) : [] : formItems.map((item, index2) => {
          return h(form_config_item_default, {
            key: index2,
            itemConfig: item
          });
        })),
        h("div", {
          class: "vxe-form-slots",
          ref: "hideItem"
        }, customLayout ? [] : defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-form--loading",
          modelValue: loading2
        }),
        /**
         * 工具提示
         */
        h(tooltip_default, Object.assign({ ref: refTooltip }, tooltipOpts))
      ]);
    };
    const staticItemFlag = ref(0);
    watch(() => reactData.staticItems.length, () => {
      staticItemFlag.value++;
    });
    watch(() => reactData.staticItems, () => {
      staticItemFlag.value++;
    });
    watch(staticItemFlag, () => {
      reactData.formItems = reactData.staticItems;
    });
    const itemFlag = ref(0);
    watch(() => props.items ? props.items.length : -1, () => {
      itemFlag.value++;
    });
    watch(() => props.items, () => {
      itemFlag.value++;
    });
    watch(itemFlag, () => {
      loadItem(props.items || []);
    });
    watch(() => props.collapseStatus, (value) => {
      reactData.collapseAll = !!value;
    });
    watch(() => props.readonly, () => {
      clearValidate();
    });
    watch(() => props.disabled, () => {
      clearValidate();
    });
    onMounted(() => {
      nextTick(() => {
        if (true) {
          if (props.customLayout && props.items) {
            errLog2("vxe.error.errConflicts", ["custom-layout", "items"]);
          }
        }
      });
    });
    if (props.items) {
      loadItem(props.items);
    }
    provide("$xeForm", $xeForm);
    provide("$xeFormGroup", null);
    provide("$xeFormItem", null);
    $xeForm.renderVN = renderVN;
    return $xeForm;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/render/index.js
var import_xe_utils79 = __toESM(require_xe_utils());
var componentDefaultModelProp2 = "modelValue";
function getOldComponentName2(name) {
  return `vxe-${name.replace("$", "")}`;
}
function getDefaultComponent2({ name }) {
  return resolveComponent(name);
}
function getOldComponent2({ name }) {
  return resolveComponent(getOldComponentName2(name));
}
function getNativeAttrs2(renderOpts) {
  let { name, attrs } = renderOpts;
  if (name === "input") {
    attrs = Object.assign({ type: "text" }, attrs);
  }
  return attrs;
}
function getComponentFormItemProps(renderOpts, params, value, defaultProps) {
  return import_xe_utils79.default.assign({}, defaultProps, renderOpts.props, { [componentDefaultModelProp2]: value });
}
function getNativeElementOns2(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent2(renderOpts.name);
  const changeEvent = getChangeEvent2(renderOpts.name);
  const isSameEvent = changeEvent === modelEvent;
  const ons = {};
  if (events) {
    import_xe_utils79.default.objectEach(events, (func, key) => {
      ons[getOnName2(key)] = function(...args) {
        func(params, ...args);
      };
    });
  }
  if (modelFunc) {
    ons[getOnName2(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (isSameEvent && changeFunc) {
        changeFunc(targetEvnt);
      }
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (!isSameEvent && changeFunc) {
    ons[getOnName2(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getComponentOns2(renderOpts, params, modelFunc, changeFunc) {
  const { events } = renderOpts;
  const modelEvent = getModelEvent2(renderOpts.name);
  const changeEvent = getChangeEvent2(renderOpts.name);
  const ons = {};
  import_xe_utils79.default.objectEach(events, (func, key) => {
    ons[getOnName2(key)] = function(...args) {
      if (true) {
        if (!import_xe_utils79.default.isFunction(func)) {
          errLog2("vxe.error.errFunc", [func]);
        }
      }
      func(params, ...args);
    };
  });
  if (modelFunc) {
    ons[getOnName2(modelEvent)] = function(targetEvnt) {
      modelFunc(targetEvnt);
      if (events && events[modelEvent]) {
        events[modelEvent](params, targetEvnt);
      }
    };
  }
  if (changeFunc) {
    ons[getOnName2(changeEvent)] = function(...args) {
      changeFunc(...args);
      if (events && events[changeEvent]) {
        events[changeEvent](params, ...args);
      }
    };
  }
  return ons;
}
function getItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getComponentOns2(renderOpts, params, (value) => {
    import_xe_utils79.default.set(data, field, value);
  }, () => {
    $form.updateStatus(params);
  });
}
function getNativeItemOns(renderOpts, params) {
  const { $form, data, field } = params;
  return getNativeElementOns2(renderOpts, params, (evnt) => {
    const itemValue = evnt.target.value;
    import_xe_utils79.default.set(data, field, itemValue);
  }, () => {
    $form.updateStatus(params);
  });
}
function renderNativeOptgroup(renderOpts, params, renderOptionsMethods) {
  const { optionGroups, optionGroupProps = {} } = renderOpts;
  const groupOptions = optionGroupProps.options || "options";
  const groupLabel = optionGroupProps.label || "label";
  return optionGroups.map((group, gIndex) => {
    return h("optgroup", {
      key: gIndex,
      label: group[groupLabel]
    }, renderOptionsMethods(group[groupOptions], renderOpts, params));
  });
}
function nativeItemRender(renderOpts, params) {
  const { data, field } = params;
  const { name } = renderOpts;
  const attrs = getNativeAttrs2(renderOpts);
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(name, Object.assign(Object.assign(Object.assign({ class: `vxe-default-${name}` }, attrs), { value: attrs && name === "input" && (attrs.type === "submit" || attrs.type === "reset") ? null : itemValue }), getNativeItemOns(renderOpts, params)))
  ];
}
function defaultItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(getOldComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldButtonItemRender(renderOpts, params) {
  return [
    h(resolveComponent("vxe-button"), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, null)), getComponentOns2(renderOpts, params)))
  ];
}
function oldButtonsItemRender(renderOpts, params) {
  return renderOpts.children.map((childRenderOpts) => oldButtonItemRender(childRenderOpts, params)[0]);
}
function renderNativeFormOptions(options, renderOpts, params) {
  const { data, field } = params;
  const { optionProps = {} } = renderOpts;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const cellValue = import_xe_utils79.default.get(data, field);
  return options.map((item, oIndex) => {
    return h("option", {
      key: oIndex,
      value: item[valueProp],
      disabled: item[disabledProp],
      /* eslint-disable eqeqeq */
      selected: item[valueProp] == cellValue
    }, item[labelProp]);
  });
}
function defaultFormItemRender(renderOpts, params) {
  const { data, field } = params;
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function formItemRadioAndCheckboxRender(renderOpts, params) {
  const { options, optionProps } = renderOpts;
  const { data, field } = params;
  const itemValue = import_xe_utils79.default.get(data, field);
  return [
    h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({
      options,
      optionProps
    }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
function oldFormItemRadioAndCheckboxRender(renderOpts, params) {
  const { name, options, optionProps = {} } = renderOpts;
  const { data, field } = params;
  const labelProp = optionProps.label || "label";
  const valueProp = optionProps.value || "value";
  const disabledProp = optionProps.disabled || "disabled";
  const itemValue = import_xe_utils79.default.get(data, field);
  const compName = getOldComponentName2(name);
  if (options) {
    return [
      h(resolveComponent(`${compName}-group`), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)), {
        default: () => {
          return options.map((item, index2) => {
            return h(resolveComponent(compName), {
              key: index2,
              label: item[valueProp],
              content: item[labelProp],
              disabled: item[disabledProp]
            });
          });
        }
      })
    ];
  }
  return [
    h(resolveComponent(compName), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
  ];
}
renderer.mixin({
  input: {
    formItemAutoFocus: "input",
    renderFormItemContent: nativeItemRender
  },
  textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: nativeItemRender
  },
  select: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      return [
        h("select", Object.assign(Object.assign({ class: "vxe-default-select" }, getNativeAttrs2(renderOpts)), getNativeItemOns(renderOpts, params)), renderOpts.optionGroups ? renderNativeOptgroup(renderOpts, params, renderNativeFormOptions) : renderNativeFormOptions(renderOpts.options, renderOpts, params))
      ];
    }
  },
  VxeInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeNumberInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxePasswordInput: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeTextarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: defaultItemRender
  },
  VxeDatePicker: {
    formItemAutoFocus: "input",
    renderFormItemContent: defaultItemRender
  },
  VxeButton: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeButtonGroup: {
    renderFormItemContent(renderOpts, params) {
      const { options } = renderOpts;
      const { data, field } = params;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({ options }, getComponentFormItemProps(renderOpts, params, itemValue)), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTreeSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeTableSelect: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeIconPicker: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeRadio: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeRadioGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeCheckbox: {
    renderFormItemContent: defaultFormItemRender
  },
  VxeCheckboxGroup: {
    renderFormItemContent: formItemRadioAndCheckboxRender
  },
  VxeSwitch: {
    renderFormItemContent: defaultItemRender
  },
  VxeRate: {
    renderFormItemContent: defaultItemRender
  },
  VxeSlider: {
    renderFormItemContent: defaultItemRender
  },
  VxeImage: {
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { src: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeImageGroup: {
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { props } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getDefaultComponent2(renderOpts), Object.assign(Object.assign(Object.assign({}, props), { urlList: itemValue }), getItemOns(renderOpts, params)))
      ];
    }
  },
  VxeUpload: {
    renderFormItemContent: defaultItemRender
  },
  // 以下已废弃
  $input: {
    formItemAutoFocus: "input",
    renderFormItemContent: oldItemRender
  },
  $textarea: {
    formItemAutoFocus: "textarea",
    renderFormItemContent: oldItemRender
  },
  $button: {
    renderFormItemContent: oldButtonItemRender
  },
  $buttons: {
    renderFormItemContent: oldButtonsItemRender
  },
  $select: {
    formItemAutoFocus: "input",
    renderFormItemContent(renderOpts, params) {
      const { data, field } = params;
      const { options, optionProps, optionGroups, optionGroupProps } = renderOpts;
      const itemValue = import_xe_utils79.default.get(data, field);
      return [
        h(getOldComponent2(renderOpts), Object.assign(Object.assign({}, getComponentFormItemProps(renderOpts, params, itemValue, { options, optionProps, optionGroups, optionGroupProps })), getItemOns(renderOpts, params)))
      ];
    }
  },
  $radio: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $checkbox: {
    renderFormItemContent: oldFormItemRadioAndCheckboxRender
  },
  $switch: {
    renderFormItemContent: oldItemRender
  }
  // 以上已废弃
});

// node_modules/vxe-pc-ui/es/form/index.js
var VxeForm = Object.assign(form_default, {
  install(app) {
    app.component(form_default.name, form_default);
  }
});
dynamicApp.use(VxeForm);
VxeUI.component(form_default);
var Form = VxeForm;
var form_default2 = VxeForm;

// node_modules/vxe-pc-ui/es/form-design/src/util.js
var import_xe_utils80 = __toESM(require_xe_utils());
var maxWidgetId = 1e5;
function getNewWidgetId(widgetObjList) {
  import_xe_utils80.default.eachTree(widgetObjList, (item) => {
    if (item) {
      maxWidgetId = Math.max(maxWidgetId, item.id);
    }
  }, { children: "children" });
  return ++maxWidgetId;
}
var hasFormDesignLayoutType = (widget) => {
  if (widget) {
    const widgetConf = getWidgetConfig(widget.name);
    return widgetConf.group === "layout";
  }
  return false;
};

// node_modules/vxe-pc-ui/es/form-design/src/widget-info.js
var import_xe_utils81 = __toESM(require_xe_utils());
var refWidgetReactConfigMaps = ref({});
var getWidgetConfig = (name) => {
  const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
  return widgetReactConfigMaps[name] || {};
};
function getWidgetConfigTitle(name, $xeFormDesign) {
  const widgetConf = getWidgetConfig(name);
  if (widgetConf) {
    const configTitle = widgetConf.title;
    const params = { name, $formDesign: $xeFormDesign };
    return import_xe_utils81.default.toValueString(import_xe_utils81.default.isFunction(configTitle) ? configTitle(params) : configTitle);
  }
  return name;
}
function getWidgetConfigCustomGroup(name, $xeFormDesign) {
  const widgetConf = getWidgetConfig(name);
  if (widgetConf) {
    const configCustomGroup = widgetConf.customGroup;
    const params = { name, $formDesign: $xeFormDesign };
    return import_xe_utils81.default.toValueString(import_xe_utils81.default.isFunction(configCustomGroup) ? configCustomGroup(params) : configCustomGroup);
  }
  return name;
}
var validWidgetUniqueField = (field, widgetObjList) => {
  return !import_xe_utils81.default.findTree(widgetObjList, (item) => item.field === field, { children: "children" });
};
var FormDesignWidgetInfo = class {
  constructor($xeFormDesign, name, widgetObjList) {
    Object.defineProperty(this, "id", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 0
    });
    Object.defineProperty(this, "field", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "title", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: ""
    });
    Object.defineProperty(this, "required", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "hidden", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: false
    });
    Object.defineProperty(this, "options", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {}
    });
    Object.defineProperty(this, "children", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: []
    });
    Object.defineProperty(this, "model", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: {
        update: false,
        value: ""
      }
    });
    let customField = "";
    if (name) {
      const compConf = renderer.get(name) || {};
      if (compConf) {
        const widgetReactConfigMaps = refWidgetReactConfigMaps.value;
        const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
        if (createWidgetFormConfig) {
          const params = { name, $formDesign: $xeFormDesign };
          const widgetConfig = createWidgetFormConfig(params) || {};
          const titleConf = widgetConfig.title;
          const fieldConf = widgetConfig.field;
          this.title = import_xe_utils81.default.toValueString(import_xe_utils81.default.isFunction(titleConf) ? titleConf(params) : titleConf);
          this.options = widgetConfig.options || {};
          this.children = widgetConfig.children || [];
          if (fieldConf) {
            if (import_xe_utils81.default.isFunction(fieldConf)) {
              customField = fieldConf({ name, $formDesign: $xeFormDesign });
            } else {
              customField = fieldConf;
            }
          }
          if (!widgetReactConfigMaps[name]) {
            widgetReactConfigMaps[name] = Object.assign({}, widgetConfig);
            refWidgetReactConfigMaps.value = Object.assign({}, widgetReactConfigMaps);
          }
        }
      }
    }
    const widgetId = getNewWidgetId(widgetObjList);
    if (customField) {
      if (!validWidgetUniqueField(customField, widgetObjList)) {
        errLog2("vxe.error.uniField", [customField]);
      }
    }
    this.id = widgetId;
    this.field = customField || `${name}${widgetId}`;
    this.name = name;
  }
};
function configToWidget(conf) {
  const widget = new FormDesignWidgetInfo(null, conf.name, []);
  widget.id = conf.id;
  widget.title = conf.title || "";
  widget.field = conf.field || "";
  widget.required = conf.required || false;
  widget.hidden = conf.hidden || false;
  widget.options = Object.assign({}, widget.options, conf.options);
  widget.children = conf.children ? conf.children.map((item) => configToWidget(item)) : [];
  return widget;
}

// node_modules/vxe-pc-ui/es/form-design/src/form-design.js
var import_xe_utils99 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form-design/src/layout-widget.js
var import_xe_utils82 = __toESM(require_xe_utils());
var layout_widget_default = defineComponent({
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const dragstartEvent = (evnt) => {
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetName = divEl.getAttribute("data-widget-name") || "";
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        if (dataTransfer) {
          dataTransfer.setData("text/plain", widgetName);
        }
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = dragWidget;
      } else {
        evnt.preventDefault();
      }
    };
    const dragendEvent = (evnt) => {
      evnt.preventDefault();
      if (formDesignReactData.dragWidget) {
        const newWidget = formDesignReactData.dragWidget;
        formDesignReactData.activeWidget = newWidget;
        $xeFormDesign.dispatchEvent("add-widget", { newWidget }, evnt);
      }
      formDesignReactData.dragWidget = null;
      formDesignReactData.sortWidget = null;
    };
    const cancelDragoverItem = (evnt, group) => {
      const { widgetObjList, dragWidget } = formDesignReactData;
      if (dragWidget) {
        if (group.children.some((widget) => widget.name === dragWidget.name)) {
          const rest = import_xe_utils82.default.findTree(widgetObjList, (item) => item && item.id === dragWidget.id, { children: "children" });
          if (rest) {
            rest.items.splice(rest.index, 1);
          }
        }
      }
    };
    const addNewWidget = (evnt, widgetName) => {
      if ($xeFormDesign.validWidgetUnique(widgetName)) {
        const { widgetObjList } = formDesignReactData;
        const dragWidget = $xeFormDesign.createWidget(widgetName);
        widgetObjList.push(dragWidget);
        formDesignReactData.activeWidget = dragWidget;
        formDesignReactData.sortWidget = null;
        formDesignReactData.dragWidget = null;
        $xeFormDesign.dispatchEvent("add-widget", { newWidget: dragWidget }, evnt);
      }
    };
    const renderWidgetList = (group) => {
      const widgetVNs = [];
      if (group.children) {
        group.children.forEach((widget, index2) => {
          const { name } = widget;
          const configTitle = getWidgetConfigTitle(name, $xeFormDesign);
          const compConf = renderer.get(name) || {};
          const widgetConf = getWidgetConfig(name);
          const renderWidgetItem = compConf.renderFormDesignWidgetItem;
          widgetVNs.push(h("div", {
            key: index2,
            class: "vxe-form-design--widget-item"
          }, h("div", {
            class: "vxe-form-design--widget-box",
            "data-widget-name": name,
            title: configTitle,
            draggable: true,
            onDragstart: dragstartEvent,
            onDragend: dragendEvent
          }, renderWidgetItem ? getSlotVNs2(renderWidgetItem({}, { $formDesign: $xeFormDesign })) : [
            h("i", {
              class: ["vxe-form-design--widget-item-icon", widgetConf ? widgetConf.icon || "" : ""]
            }),
            h("span", {
              class: "vxe-form-design--widget-item-name"
            }, configTitle),
            h("span", {
              class: "vxe-form-design--widget-item-add",
              onClick(evnt) {
                addNewWidget(evnt, name);
              }
            }, [
              h("i", {
                class: getIcon().FORM_DESIGN_WIDGET_ADD
              })
            ])
          ])));
        });
      }
      return widgetVNs;
    };
    const renderWidgetGroups = () => {
      const { widgetConfigs } = formDesignReactData;
      return widgetConfigs.map((config3, gIndex) => {
        const { title, group } = config3;
        return h("div", {
          key: gIndex,
          class: "vxe-form-design--widget-group"
        }, [
          h("div", {
            class: "vxe-form-design--widget-title"
          }, group ? getI18n(`vxe.formDesign.widget.group.${group}`) : `${title || ""}`),
          h("div", {
            class: "vxe-form-design--widget-list",
            onDragover(evnt) {
              cancelDragoverItem(evnt, config3);
            }
          }, renderWidgetList(config3))
        ]);
      });
    };
    return () => {
      return h("div", {
        class: "vxe-form-design--widget"
      }, renderWidgetGroups());
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/layout-view-item.js
var import_xe_utils83 = __toESM(require_xe_utils());
var ViewItemComponent = defineComponent({
  name: "FormDesignLayoutViewItem",
  props: {
    item: {
      type: Object,
      default: () => ({})
    },
    itemIndex: {
      type: Number,
      default: 0
    },
    items: {
      type: Array,
      default: () => []
    }
  },
  emits: [],
  setup(props, { slots }) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const sortDragstartEvent = (evnt) => {
      const { widgetObjList } = formDesignReactData;
      const divEl = evnt.currentTarget;
      const widgetId = Number(divEl.getAttribute("data-widget-id"));
      const currRest = import_xe_utils83.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
      if (currRest) {
        formDesignReactData.dragWidget = null;
        formDesignReactData.sortWidget = currRest.item;
      }
    };
    const sortDragendEvent = () => {
      formDesignReactData.activeWidget = formDesignReactData.sortWidget;
      formDesignReactData.sortWidget = null;
    };
    const sortDragenterEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      const formDesignInternalData = $xeFormDesign.internalData;
      const { lastDragTime } = formDesignInternalData;
      if (lastDragTime && lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        const divEl = evnt.currentTarget;
        evnt.preventDefault();
        const widgetId = Number(divEl.getAttribute("data-widget-id"));
        if (widgetId !== sortWidget.id) {
          const targetRest = import_xe_utils83.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
          if (targetRest) {
            const currRest = import_xe_utils83.default.findTree(widgetObjList, (item) => item && item.id === sortWidget.id, { children: "children" });
            if (currRest) {
              if (currRest.parent && currRest.parent.name === "row") {
                currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
              } else {
                currRest.items.splice(currRest.index, 1);
              }
              targetRest.items.splice(targetRest.index, 0, currRest.item);
              formDesignInternalData.lastDragTime = Date.now();
              $xeFormDesign.dispatchEvent("drag-widget", { widget: currRest.item }, evnt);
            }
          }
        }
      }
    };
    const handleClickEvent = (evnt, item) => {
      $xeFormDesign.handleClickWidget(evnt, item);
    };
    return () => {
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      const { item } = props;
      const { name } = item;
      const isActive = activeWidget && activeWidget.id === item.id;
      const defaultSlot = slots.default;
      return h("div", {
        key: item.id,
        "data-widget-id": item.id,
        draggable: true,
        class: ["vxe-form-design--preview-item", `widget-${import_xe_utils83.default.kebabCase(name)}`, {
          "is--active": isActive,
          "is--sort": sortWidget && sortWidget.id === item.id,
          "is--drag": dragWidget && dragWidget.id === item.id
        }],
        onDragstart: sortDragstartEvent,
        onDragend: sortDragendEvent,
        onDragenter: sortDragenterEvent,
        // onDragover: dragoverItemEvent,
        onClick(evnt) {
          handleClickEvent(evnt, item);
        }
      }, [
        h("div", {
          class: "vxe-form-design--preview-item-view vxe-form--item-row"
        }, defaultSlot ? defaultSlot({}) : []),
        isActive ? h("div", {
          class: "vxe-form-design--preview-item-operate"
        }, [
          h(button_default, {
            icon: getIcon().FORM_DESIGN_WIDGET_COPY,
            status: "primary",
            size: "mini",
            circle: true,
            onClick(params) {
              $xeFormDesign.handleCopyWidget(params.$event, item);
            }
          }),
          h(button_default, {
            icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
            status: "danger",
            size: "mini",
            circle: true,
            onClick(params) {
              $xeFormDesign.handleRemoveWidget(params.$event, item);
            }
          })
        ]) : createCommentVNode()
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/layout-preview.js
var import_xe_utils84 = __toESM(require_xe_utils());
var layout_preview_default = defineComponent({
  name: "FormDesignLayoutPreview",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const dragenterEvent = (evnt) => {
      const { widgetObjList, dragWidget } = formDesignReactData;
      if (dragWidget) {
        evnt.preventDefault();
        const rest = import_xe_utils84.default.findTree(widgetObjList, (item) => item && item.id === dragWidget.id, { children: "children" });
        if (!rest) {
          formDesignReactData.sortWidget = dragWidget;
          widgetObjList.push(dragWidget);
          $xeFormDesign.dispatchEvent("drag-widget", { widget: dragWidget }, evnt);
        }
      }
    };
    const dragoverEvent = (evnt) => {
      evnt.preventDefault();
    };
    let lastDragTime = Date.now();
    const handleDragenterTopPlaceEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      evnt.stopPropagation();
      if (lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        const currRest = import_xe_utils84.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (currRest) {
          const { item, index: index2, items, parent } = currRest;
          if (parent && parent.name === "row") {
            currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
          } else {
            items.splice(index2, 1);
          }
          widgetObjList.unshift(item);
          lastDragTime = Date.now();
          $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
        }
      }
    };
    const handleDragenterBottomPlaceEvent = (evnt) => {
      const { widgetObjList, sortWidget } = formDesignReactData;
      evnt.stopPropagation();
      if (lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        const currRest = import_xe_utils84.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (currRest) {
          const { item, index: index2, items, parent } = currRest;
          if (parent && parent.name === "row") {
            currRest.items[currRest.index] = $xeFormDesign.createEmptyWidget();
          } else {
            items.splice(index2, 1);
          }
          widgetObjList.push(item);
          lastDragTime = Date.now();
          $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
        }
      }
    };
    return () => {
      const { widgetObjList } = formDesignReactData;
      return h("div", {
        class: "vxe-form-design--preview",
        onDragenter: dragenterEvent,
        onDragover: dragoverEvent
      }, [
        h("div", {
          class: "vxe-form-design--preview-wrapper"
        }, [
          h("div", {
            class: "vxe-form-design--preview-place-widget",
            onDragenter: handleDragenterTopPlaceEvent
          }),
          h(form_default, {
            customLayout: true,
            span: 24,
            vertical: true
          }, {
            default() {
              return h(TransitionGroup, {
                class: "vxe-form-design--preview-list",
                tag: "div",
                name: "vxe-form-design--preview-list"
              }, {
                default: () => {
                  return widgetObjList.map((widget, widgetIndex) => {
                    return h(ViewItemComponent, {
                      key: widget.id,
                      item: widget,
                      itemIndex: widgetIndex,
                      items: widgetObjList
                    }, {
                      default() {
                        const { name } = widget;
                        const compConf = renderer.get(name) || {};
                        const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
                        const renderOpts = widget;
                        const isEditMode = true;
                        const params = { widget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: null };
                        return renderWidgetDesignView ? getSlotVNs2(renderWidgetDesignView(renderOpts, params)) : [];
                      }
                    });
                  });
                }
              });
            }
          }),
          h("div", {
            class: "vxe-form-design--preview-place-widget",
            onDragenter: handleDragenterBottomPlaceEvent
          })
        ])
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/tabs/src/tabs.js
var import_xe_utils85 = __toESM(require_xe_utils());
var tabs_default = defineComponent({
  name: "VxeTabs",
  props: {
    modelValue: [String, Number, Boolean],
    options: Array,
    height: [String, Number],
    destroyOnClose: Boolean,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    type: String,
    showClose: Boolean,
    padding: {
      type: Boolean,
      default: () => getConfig().tabs.padding
    },
    trigger: String,
    beforeChangeMethod: Function,
    closeConfig: Object,
    refreshConfig: Object,
    // 已废弃
    beforeCloseMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "tab-change",
    "tab-change-fail",
    "tab-close",
    "tab-close-fail",
    "tab-click",
    "tab-load"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils85.default.uniqueId();
    const $xeParentTabs = inject("$xeTabs", null);
    const refElem = ref();
    const refHeadWrapperElem = ref();
    const reactData = reactive({
      staticTabs: [],
      activeName: null,
      initNames: [],
      lintLeft: 0,
      lintWidth: 0,
      isTabOver: false,
      resizeFlag: 1,
      cacheTabMaps: {}
    });
    const internalData = {
      slTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeCloseOpts = computed(() => {
      return Object.assign({}, getConfig().tabs.closeConfig, props.closeConfig);
    });
    const computeRefreshOpts = computed(() => {
      return Object.assign({}, getConfig().tabs.refreshConfig, props.refreshConfig);
    });
    const computeTabOptions = computed(() => {
      const { options } = props;
      return (options || []).filter((item) => handleFilterTab(item));
    });
    const computeTabStaticOptions = computed(() => {
      const { staticTabs } = reactData;
      return staticTabs.filter((item) => handleFilterTab(item));
    });
    const computeMaps = {};
    const $xeTabs = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const handleFilterTab = (item) => {
      const { permissionCode } = item;
      if (permissionCode) {
        if (!permission.checkVisible(permissionCode)) {
          return false;
        }
      }
      return true;
    };
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils85.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils85.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const updateTabStyle = () => {
      nextTick(() => {
        const { type } = props;
        const { activeName } = reactData;
        const tabOptions = computeTabOptions.value;
        const tabStaticOptions = computeTabStaticOptions.value;
        const headerWrapperEl = refHeadWrapperElem.value;
        let lintWidth = 0;
        let lintLeft = 0;
        let isOver = false;
        if (headerWrapperEl) {
          const index2 = import_xe_utils85.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === activeName);
          const { children, scrollWidth, clientWidth } = headerWrapperEl;
          isOver = scrollWidth !== clientWidth;
          if (index2 > -1) {
            const tabEl = children[index2];
            const tabWidth = tabEl.clientWidth;
            if (type) {
              if (type === "card") {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft;
              } else if (type === "border-card") {
                lintWidth = tabWidth + 2;
                lintLeft = tabEl.offsetLeft - 1;
              }
            } else {
              lintWidth = Math.max(4, Math.floor(tabWidth * 0.6));
              lintLeft = tabEl.offsetLeft + Math.floor((tabWidth - lintWidth) / 2);
            }
          }
        }
        reactData.lintLeft = lintLeft;
        reactData.lintWidth = lintWidth;
        reactData.isTabOver = isOver;
      });
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabs: $xeTabs }, params));
    };
    const addInitName = (name, evnt) => {
      const { initNames } = reactData;
      if (name && !initNames.includes(name)) {
        dispatchEvent2("tab-load", { name }, evnt);
        initNames.push(name);
        return true;
      }
      return false;
    };
    const initDefaultName = (list) => {
      let activeName = null;
      const nameMaps = {};
      if (list && list.length) {
        let validVal = false;
        activeName = props.modelValue;
        list.forEach((item) => {
          const { name, preload } = item || {};
          if (name) {
            nameMaps[`${name}`] = {
              loading: false
            };
            if (activeName === name) {
              validVal = true;
            }
            if (preload) {
              addInitName(name, null);
            }
          }
        });
        if (!validVal) {
          activeName = list[0].name;
          addInitName(activeName, null);
          emit("update:modelValue", activeName);
        }
      }
      reactData.activeName = activeName;
      reactData.cacheTabMaps = nameMaps;
    };
    const clickEvent = (evnt, item) => {
      const { trigger } = props;
      const beforeMethod = props.beforeChangeMethod || getConfig().tabs.beforeChangeMethod;
      const { activeName } = reactData;
      const { name } = item;
      const value = name;
      dispatchEvent2("tab-click", { name }, evnt);
      if (trigger === "manual") {
        return;
      }
      if (name !== activeName) {
        Promise.resolve(!beforeMethod || beforeMethod({ $tabs: $xeTabs, name, oldName: activeName, newName: name, option: item })).then((status) => {
          if (status) {
            reactData.activeName = name;
            emit("update:modelValue", value);
            addInitName(name, evnt);
            dispatchEvent2("change", { value, name, oldName: activeName, newName: name, option: item }, evnt);
            dispatchEvent2("tab-change", { value, name, oldName: activeName, newName: name, option: item }, evnt);
          } else {
            dispatchEvent2("tab-change-fail", { value, name, oldName: activeName, newName: name, option: item }, evnt);
          }
        }).catch(() => {
          dispatchEvent2("tab-change-fail", { value, name, oldName: activeName, newName: name, option: item }, evnt);
        });
      }
    };
    const handleRefreshTabEvent = (evnt, item) => {
      evnt.stopPropagation();
      const { activeName, cacheTabMaps } = reactData;
      const { name } = item;
      const refreshOpts = computeRefreshOpts.value;
      const { queryMethod } = refreshOpts;
      const cacheItem = name ? cacheTabMaps[`${name}`] : null;
      if (cacheItem) {
        if (queryMethod) {
          cacheItem.loading = true;
          Promise.resolve(queryMethod({ $tabs: $xeTabs, value: activeName, name, option: item })).finally(() => {
            cacheItem.loading = false;
          });
        } else {
          errLog2("vxe.error.notFunc", ["refresh-config.queryMethod"]);
        }
      }
    };
    const handleCloseTabEvent = (evnt, item, index2, list) => {
      evnt.stopPropagation();
      const { activeName } = reactData;
      const closeOpts = computeCloseOpts.value;
      const beforeMethod = closeOpts.beforeMethod || props.beforeCloseMethod || getConfig().tabs.beforeCloseMethod;
      const { name } = item;
      const value = activeName;
      let nextName = value;
      if (activeName === name) {
        const nextItem = index2 < list.length - 1 ? list[index2 + 1] : list[index2 - 1];
        nextName = nextItem ? nextItem.name : null;
      }
      Promise.resolve(!beforeMethod || beforeMethod({ $tabs: $xeTabs, value, name, nextName, option: item })).then((status) => {
        if (status) {
          dispatchEvent2("tab-close", { value, name, nextName }, evnt);
        } else {
          dispatchEvent2("tab-close-fail", { value, name, nextName }, evnt);
        }
      }).catch(() => {
        dispatchEvent2("tab-close-fail", { value, name, nextName }, evnt);
      });
    };
    const startScrollAnimation = (offsetPos, offsetSize) => {
      const { slTimeout } = internalData;
      let offsetLeft = offsetSize;
      let scrollCount = 6;
      let delayNum = 35;
      if (slTimeout) {
        clearTimeout(slTimeout);
        internalData.slTimeout = void 0;
      }
      const scrollAnimate = () => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (scrollCount > 0) {
          scrollCount--;
          if (headerWrapperEl) {
            const { clientWidth, scrollWidth, scrollLeft } = headerWrapperEl;
            offsetLeft = Math.floor(offsetLeft / 2);
            if (offsetPos > 0) {
              if (clientWidth + scrollLeft < scrollWidth) {
                headerWrapperEl.scrollLeft += offsetLeft;
                delayNum -= 4;
                internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
              }
            } else {
              if (scrollLeft > 0) {
                headerWrapperEl.scrollLeft -= offsetLeft;
                delayNum -= 4;
                internalData.slTimeout = setTimeout(scrollAnimate, delayNum);
              }
            }
            updateTabStyle();
          }
        }
      };
      scrollAnimate();
    };
    const handleScrollToLeft = (offsetPos) => {
      const headerWrapperEl = refHeadWrapperElem.value;
      if (headerWrapperEl) {
        const offsetSize = Math.floor(headerWrapperEl.clientWidth * 0.75);
        startScrollAnimation(offsetPos, offsetSize);
      }
    };
    const scrollLeftEvent = () => {
      handleScrollToLeft(-1);
    };
    const scrollRightEvent = () => {
      handleScrollToLeft(1);
    };
    const scrollToTab = (name) => {
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      return nextTick().then(() => {
        const headerWrapperEl = refHeadWrapperElem.value;
        if (headerWrapperEl) {
          const index2 = import_xe_utils85.default.findIndexOf(tabStaticOptions.length ? tabStaticOptions : tabOptions, (item) => item.name === name);
          if (index2 > -1) {
            const { scrollLeft, clientWidth, children } = headerWrapperEl;
            const tabEl = children[index2];
            if (tabEl) {
              const tabOffsetLeft = tabEl.offsetLeft;
              const tabClientWidth = tabEl.clientWidth;
              const overSize = tabOffsetLeft + tabClientWidth - (scrollLeft + clientWidth);
              if (overSize > 0) {
                headerWrapperEl.scrollLeft += overSize;
              }
              if (tabOffsetLeft < scrollLeft) {
                headerWrapperEl.scrollLeft = tabOffsetLeft;
              }
            }
          }
          updateTabStyle();
        }
      });
    };
    const handlePrevNext = (isNext) => {
      const { activeName } = reactData;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const list = tabStaticOptions.length ? tabStaticOptions : tabOptions;
      const index2 = import_xe_utils85.default.findIndexOf(list, (item) => item.name === activeName);
      if (index2 > -1) {
        let item = null;
        if (isNext) {
          if (index2 < list.length - 1) {
            item = list[index2 + 1];
          }
        } else {
          if (index2 > 0) {
            item = list[index2 - 1];
          }
        }
        if (item) {
          const name = item.name;
          const value = name;
          reactData.activeName = name;
          emit("update:modelValue", value);
          addInitName(name, null);
        }
      }
      return nextTick();
    };
    const tabsMethods = {
      dispatchEvent: dispatchEvent2,
      scrollToTab,
      prev() {
        return handlePrevNext(false);
      },
      next() {
        return handlePrevNext(true);
      },
      prevTab() {
        if (true) {
          warnLog2("vxe.error.delFunc", ["prevTab", "prev"]);
        }
        return tabsMethods.prev();
      },
      nextTab() {
        if (true) {
          warnLog2("vxe.error.delFunc", ["nextTab", "next"]);
        }
        return tabsMethods.next();
      }
    };
    const tabsPrivateMethods = {};
    Object.assign($xeTabs, tabsMethods, tabsPrivateMethods);
    const renderTabHeader = (tabList) => {
      const { type, titleWidth: allTitleWidth, titleAlign: allTitleAlign, showClose, closeConfig, refreshConfig } = props;
      const { activeName, lintLeft, lintWidth, isTabOver, cacheTabMaps } = reactData;
      const extraSlot = slots.extra;
      const closeOpts = computeCloseOpts.value;
      const closeVisibleMethod = closeOpts.visibleMethod;
      const refreshOpts = computeRefreshOpts.value;
      const refreshVisibleMethod = refreshOpts.visibleMethod;
      return h("div", {
        class: "vxe-tabs-header"
      }, [
        isTabOver ? h("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--left-bar",
          onClick: scrollLeftEvent
        }, [
          h("span", {
            class: getIcon().TABS_TAB_BUTTON_LEFT
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-tabs-header--wrapper"
        }, [
          h("div", {
            ref: refHeadWrapperElem,
            class: "vxe-tabs-header--item-wrapper"
          }, tabList.map((item, index2) => {
            const { title, titleWidth, titleAlign, icon, name, slots: slots2 } = item;
            const titleSlot = slots2 ? slots2.title || slots2.tab : null;
            const itemWidth = titleWidth || allTitleWidth;
            const itemAlign = titleAlign || allTitleAlign;
            const params = { $tabs: $xeTabs, value: activeName, name, option: item };
            const isActive = activeName === name;
            const cacheItem = name ? cacheTabMaps[`${name}`] : null;
            const isLoading = cacheItem ? cacheItem.loading : false;
            return h("div", {
              key: `${name}`,
              class: ["vxe-tabs-header--item", itemAlign ? `align--${itemAlign}` : "", {
                "is--active": isActive
              }],
              style: itemWidth ? {
                width: toCssUnit(itemWidth)
              } : null,
              onClick(evnt) {
                clickEvent(evnt, item);
              }
            }, [
              h("div", {
                class: "vxe-tabs-header--item-inner"
              }, [
                h("div", {
                  class: "vxe-tabs-header--item-content"
                }, [
                  icon ? h("span", {
                    class: "vxe-tabs-header--item-icon"
                  }, [
                    h("i", {
                      class: icon
                    })
                  ]) : createCommentVNode(),
                  h("span", {
                    class: "vxe-tabs-header--item-name"
                  }, titleSlot ? callSlot(titleSlot, { name, title }) : `${title}`)
                ]),
                (isEnableConf2(refreshConfig) || refreshOpts.enabled) && (refreshVisibleMethod ? refreshVisibleMethod(params) : isActive) ? h("div", {
                  class: "vxe-tabs-header--refresh-btn",
                  onClick(evnt) {
                    handleRefreshTabEvent(evnt, item);
                  }
                }, [
                  h("i", {
                    class: isLoading ? getIcon().TABS_TAB_REFRESH_LOADING : getIcon().TABS_TAB_REFRESH
                  })
                ]) : createCommentVNode(),
                (showClose || (isEnableConf2(closeConfig) || closeOpts.enabled)) && (!closeVisibleMethod || closeVisibleMethod(params)) ? h("div", {
                  class: "vxe-tabs-header--close-btn",
                  onClick(evnt) {
                    handleCloseTabEvent(evnt, item, index2, tabList);
                  }
                }, [
                  h("i", {
                    class: getIcon().TABS_TAB_CLOSE
                  })
                ]) : createCommentVNode()
              ])
            ]);
          }).concat([
            h("span", {
              key: "line",
              class: `vxe-tabs-header--active-line type--${type || "default"}`,
              style: {
                left: `${lintLeft}px`,
                width: `${lintWidth}px`
              }
            })
          ]))
        ]),
        isTabOver ? h("div", {
          class: "vxe-tabs-header--bar vxe-tabs-header--right-bar",
          onClick: scrollRightEvent
        }, [
          h("span", {
            class: getIcon().TABS_TAB_BUTTON_RIGHT
          })
        ]) : createCommentVNode(),
        extraSlot ? h("div", {
          class: "vxe-tabs-header--extra"
        }, getSlotVNs2(extraSlot({}))) : createCommentVNode()
      ]);
    };
    const renderTabPane = (item) => {
      const { initNames, activeName } = reactData;
      const { name, slots: slots2 } = item;
      const defaultSlot = slots2 ? slots2.default : null;
      return name && initNames.includes(name) ? h("div", {
        key: `${name}`,
        class: ["vxe-tabs-pane--item", {
          "is--visible": activeName === name,
          "has--content": !!defaultSlot
        }]
      }, defaultSlot ? callSlot(defaultSlot, { name }) : []) : createCommentVNode();
    };
    const renderTabContent = (tabList) => {
      const { destroyOnClose } = props;
      const { activeName } = reactData;
      const activeDefaultTab = tabList.find((item) => item.name === activeName);
      if (destroyOnClose) {
        return [activeDefaultTab ? renderTabPane(activeDefaultTab) : createCommentVNode()];
      }
      return tabList.map((item) => renderTabPane(item));
    };
    const renderVN = () => {
      const { type, height, padding, trigger } = props;
      const tabOptions = computeTabOptions.value;
      const tabStaticOptions = computeTabStaticOptions.value;
      const defaultSlot = slots.default;
      const footerSlot = slots.footer;
      const tabList = defaultSlot ? tabStaticOptions : tabOptions;
      return h("div", {
        ref: refElem,
        class: ["vxe-tabs", `vxe-tabs--${type || "default"}`, `trigger--${trigger === "manual" ? "trigger" : "default"}`, {
          "is--padding": padding,
          "is--height": height
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-tabs-slots"
        }, defaultSlot ? defaultSlot({}) : []),
        renderTabHeader(tabList),
        h("div", {
          class: "vxe-tabs-pane"
        }, renderTabContent(tabList)),
        footerSlot ? h("div", {
          class: "vxe-tabs-footer"
        }, callSlot(footerSlot, {})) : renderEmptyElement($xeTabs)
      ]);
    };
    watch(() => props.modelValue, (val) => {
      addInitName(val, null);
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, (val) => {
      scrollToTab(val);
      nextTick(() => {
        reactData.resizeFlag++;
      });
    });
    const optsFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optsFlag.value++;
    });
    watch(() => props.options, () => {
      optsFlag.value++;
    });
    watch(optsFlag, () => {
      initDefaultName(props.options);
      updateTabStyle();
    });
    const stFlag = ref(0);
    watch(() => reactData.staticTabs ? reactData.staticTabs.length : -1, () => {
      stFlag.value++;
    });
    watch(() => reactData.staticTabs, () => {
      stFlag.value++;
    });
    watch(stFlag, () => {
      initDefaultName(reactData.staticTabs);
      updateTabStyle();
    });
    if ($xeParentTabs) {
      watch(() => $xeParentTabs ? $xeParentTabs.reactData.resizeFlag : null, () => {
        reactData.resizeFlag++;
      });
    }
    watch(() => reactData.resizeFlag, () => {
      nextTick(() => {
        updateTabStyle();
      });
    });
    onMounted(() => {
      globalEvents.on($xeTabs, "resize", updateTabStyle);
      updateTabStyle();
    });
    onUnmounted(() => {
      globalEvents.off($xeTabs, "resize");
    });
    provide("$xeTabs", $xeTabs);
    addInitName(props.modelValue, null);
    initDefaultName(reactData.staticTabs.length ? reactData.staticTabs : props.options);
    $xeTabs.renderVN = renderVN;
    return $xeTabs;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var import_xe_utils87 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/tabs/src/util.js
var import_xe_utils86 = __toESM(require_xe_utils());
function assembleTabItem($xeTabs, elem, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const parentElem = elem.parentNode;
  if (parentElem) {
    staticTabs.splice(import_xe_utils86.default.arrayIndexOf(parentElem.children, elem), 0, tabConfig);
    $xeTabs.reactData.staticTabs = staticTabs.slice(0);
  }
}
function destroyTabItem($xeTabs, tabConfig) {
  const staticTabs = $xeTabs.reactData.staticTabs;
  const matchObj = import_xe_utils86.default.findTree(staticTabs, (item) => item.id === tabConfig.id, { children: "children" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  $xeTabs.reactData.staticTabs = staticTabs.slice(0);
}

// node_modules/vxe-pc-ui/es/tabs/src/tab-pane.js
var tab_pane_default = defineComponent({
  name: "VxeTabPane",
  props: {
    title: [String, Number],
    name: [String, Number],
    icon: String,
    titleWidth: [String, Number],
    titleAlign: [String, Number],
    preload: Boolean,
    permissionCode: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils87.default.uniqueId();
    const refElem = ref();
    const $xeTabs = inject("$xeTabs", null);
    const reactData = reactive({});
    const tabConfig = reactive({
      id: xID,
      title: props.title,
      name: props.name,
      icon: props.icon,
      titleWidth: props.titleWidth,
      titleAlign: props.titleAlign,
      preload: props.preload,
      permissionCode: props.permissionCode,
      slots
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTabPane = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tabPane: $xeTabPane }, params));
    };
    const tabPaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const tabPanePrivateMethods = {};
    Object.assign($xeTabPane, tabPaneMethods, tabPanePrivateMethods);
    watch(() => props.title, (val) => {
      tabConfig.title = val;
    });
    watch(() => props.name, (val) => {
      tabConfig.name = val;
    });
    watch(() => props.icon, (val) => {
      tabConfig.icon = val;
    });
    watch(() => props.permissionCode, (val) => {
      tabConfig.permissionCode = val;
    });
    onMounted(() => {
      const elem = refElem.value;
      if ($xeTabs && elem) {
        assembleTabItem($xeTabs, elem, tabConfig);
      }
    });
    onUnmounted(() => {
      if ($xeTabs) {
        destroyTabItem($xeTabs, tabConfig);
      }
    });
    const renderVN = () => {
      return h("div", {
        ref: refElem
      }, []);
    };
    $xeTabPane.renderVN = renderVN;
    return $xeTabPane;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form/src/form-item.js
var import_xe_utils88 = __toESM(require_xe_utils());
var formItemProps = {
  title: String,
  field: String,
  span: {
    type: [String, Number],
    default: null
  },
  align: {
    type: String,
    default: null
  },
  verticalAlign: {
    type: String,
    default: null
  },
  titleBackground: {
    type: Boolean,
    default: null
  },
  titleBold: {
    type: Boolean,
    default: null
  },
  titleAlign: {
    type: String,
    default: null
  },
  titleWidth: {
    type: [String, Number],
    default: null
  },
  titleColon: {
    type: Boolean,
    default: null
  },
  titleAsterisk: {
    type: Boolean,
    default: null
  },
  showTitle: {
    type: Boolean,
    default: true
  },
  vertical: {
    type: Boolean,
    default: null
  },
  padding: {
    type: Boolean,
    default: null
  },
  className: [String, Function],
  contentClassName: [String, Function],
  contentStyle: [Object, Function],
  titleClassName: [String, Function],
  titleStyle: [Object, Function],
  titleOverflow: {
    type: [Boolean, String],
    default: null
  },
  titlePrefix: Object,
  titleSuffix: Object,
  resetValue: { default: null },
  visibleMethod: Function,
  visible: {
    type: Boolean,
    default: null
  },
  showContent: {
    type: Boolean,
    default: null
  },
  folding: Boolean,
  collapseNode: Boolean,
  itemRender: Object,
  rules: Array
};
var form_item_default = defineComponent({
  name: "VxeFormItem",
  props: formItemProps,
  setup(props, { slots }) {
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const $xeFormGroup = inject("$xeFormGroup", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    const renderItem = ($xeForm2, item) => {
      const formProps = $xeForm2.props;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle, showContent } = item;
      const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm2, $grid: $xeForm2.xegrid };
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        key: item.id,
        class: getItemClass($xeForm2, item),
        style: import_xe_utils88.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm2, item),
        showContent === false ? createCommentVNode() : h("div", {
          class: getItemContentClass($xeForm2, item),
          style: Object.assign({}, import_xe_utils88.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils88.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, [
          renderItemContent($xeForm2, item)
        ])
      ]);
    };
    const renderVN = () => {
      const customLayout = $xeForm ? $xeForm.props.customLayout : false;
      const item = formItem;
      return customLayout ? renderItem($xeForm, item) : h("div", {
        ref: refElem
      });
    };
    const $xeFormitem = {
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    onMounted(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeFormGroup);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    provide("$xeFormItem", $xeFormitem);
    provide("$xeFormGroup", null);
    return $xeFormitem;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/switch/src/switch.js
var import_xe_utils89 = __toESM(require_xe_utils());
var switch_default = defineComponent({
  name: "VxeSwitch",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().switch.size || getConfig().size
    },
    openLabel: String,
    closeLabel: String,
    openValue: {
      type: [String, Number, Boolean],
      default: true
    },
    closeValue: {
      type: [String, Number, Boolean],
      default: false
    },
    openIcon: String,
    closeIcon: String,
    openActiveIcon: String,
    closeActiveIcon: String
  },
  emits: [
    "update:modelValue",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils89.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isActivated: false,
      hasAnimat: false,
      offsetLeft: 0
    });
    const internalData = {};
    const $xeSwitch = {
      xID,
      props,
      context,
      reactData,
      internalData
    };
    const refButton = ref();
    let switchMethods = {};
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeOnShowLabel = computed(() => {
      return getFuncText2(props.openLabel);
    });
    const computeOffShowLabel = computed(() => {
      return getFuncText2(props.closeLabel);
    });
    const computeIsChecked = computed(() => {
      return props.modelValue === props.openValue;
    });
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const isChecked = computeIsChecked.value;
        clearTimeout(internalData.atTimeout);
        const value = isChecked ? props.closeValue : props.openValue;
        reactData.hasAnimat = true;
        emitModel(value);
        switchMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
        internalData.atTimeout = setTimeout(() => {
          reactData.hasAnimat = false;
          internalData.atTimeout = void 0;
        }, 400);
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $switch: $xeSwitch }, params));
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      switchMethods.dispatchEvent("focus", { value: props.modelValue }, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      switchMethods.dispatchEvent("blur", { value: props.modelValue }, evnt);
    };
    switchMethods = {
      dispatchEvent: dispatchEvent2,
      focus() {
        const btnElem = refButton.value;
        reactData.isActivated = true;
        if (btnElem) {
          btnElem.focus();
        }
        return nextTick();
      },
      blur() {
        const btnElem = refButton.value;
        if (btnElem) {
          btnElem.blur();
        }
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeSwitch, switchMethods);
    const renderVN = () => {
      const { openIcon, closeIcon, openActiveIcon, closeActiveIcon } = props;
      const vSize = computeSize.value;
      const isChecked = computeIsChecked.value;
      const onShowLabel = computeOnShowLabel.value;
      const offShowLabel = computeOffShowLabel.value;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      return h("div", {
        class: ["vxe-switch", isChecked ? "is--on" : "is--off", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled,
          "is--readonly": isReadonly,
          "is--animat": reactData.hasAnimat
        }]
      }, [
        h("button", {
          ref: refButton,
          class: "vxe-switch--button",
          type: "button",
          disabled: isDisabled || isReadonly,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent
        }, [
          h("span", {
            class: "vxe-switch--label vxe-switch--label-on"
          }, [
            openIcon ? h("i", {
              class: ["vxe-switch--label-icon", openIcon]
            }) : createCommentVNode(),
            onShowLabel
          ]),
          h("span", {
            class: "vxe-switch--label vxe-switch--label-off"
          }, [
            closeIcon ? h("i", {
              class: ["vxe-switch--label-icon", closeIcon]
            }) : createCommentVNode(),
            offShowLabel
          ]),
          h("span", {
            class: ["vxe-switch--icon"]
          }, openActiveIcon || closeActiveIcon ? [
            h("i", {
              class: isChecked ? openActiveIcon : closeActiveIcon
            })
          ] : [])
        ])
      ]);
    };
    $xeSwitch.renderVN = renderVN;
    return $xeSwitch;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/default-setting-form.js
var DefaultSettingFormComponent = defineComponent({
  name: "DefaultSettingForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { props: formDesignProps } = $xeFormDesign;
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          const { showPc, showMobile } = formDesignProps;
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.formName"),
              field: "title",
              itemRender: { name: "VxeInput", props: { placeholder: getI18n("vxe.formDesign.defFormTitle") } }
            }),
            showPc && showMobile ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.displaySetting.name")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    h("div", {
                      class: "vxe-form-design--widget-form-item-pc"
                    }, [
                      h(text_default, {
                        icon: getIcon().FORM_DESIGN_PROPS_PC,
                        content: getI18n("vxe.formDesign.widgetProp.displaySetting.pc")
                      }),
                      h(switch_default, {
                        modelValue: formData.pcVisible,
                        openLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(val) {
                          formData.pcVisible = val;
                        }
                      })
                    ]),
                    h("div", {
                      class: "vxe-form-design--widget-form-item-mobile"
                    }, [
                      h(text_default, {
                        icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                        content: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile")
                      }),
                      h(switch_default, {
                        modelValue: formData.mobileVisible,
                        openLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.visible"),
                        closeLabel: getI18n("vxe.formDesign.widgetProp.displaySetting.hidden"),
                        "onUpdate:modelValue"(val) {
                          formData.mobileVisible = val;
                        }
                      })
                    ])
                  ])
                ];
              }
            }) : createCommentVNode()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/layout-setting.js
var layout_setting_default = defineComponent({
  name: "FormDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { props: formDesignProps, reactData: formDesignReactData } = $xeFormDesign;
    const activeTab = ref(1);
    const renderSettingWidgetForm = () => {
      const { activeWidget } = formDesignReactData;
      if (activeWidget) {
        const compConf = renderer.get(activeWidget.name);
        const renderWidgetFormView = compConf ? compConf.renderFormDesignWidgetFormView : null;
        if (renderWidgetFormView) {
          const isEditMode = true;
          return h("div", {
            class: "vxe-form-design--custom-widget-form-view"
          }, getSlotVNs2(renderWidgetFormView(activeWidget, { isEditMode, isViewMode: !isEditMode, widget: activeWidget, $formDesign: $xeFormDesign, $formView: null })));
        }
      }
      return createCommentVNode();
    };
    const renderSettingConfigForm = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingView = compConf ? compConf.renderFormDesignSettingFormView : null;
        if (renderSettingView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-form-view"
          }, getSlotVNs2(renderSettingView({}, { $formDesign: $xeFormDesign })));
        }
      }
      return h(DefaultSettingFormComponent, {
        formData
      });
    };
    watch(() => formDesignReactData.activeWidget, () => {
      activeTab.value = 1;
    });
    return () => {
      return h("div", {
        class: "vxe-form-design--setting"
      }, [
        h("div", {
          class: "vxe-form-design--setting-form"
        }, [
          h(tabs_default, {
            modelValue: activeTab.value,
            titleWidth: "50%",
            titleAlign: "center",
            padding: true,
            class: "vxe-form-design--setting-form-tabs",
            "onUpdate:modelValue"(val) {
              activeTab.value = val;
            }
          }, {
            default() {
              return [
                h(tab_pane_default, {
                  title: getI18n("vxe.formDesign.widgetPropTab"),
                  name: 1
                }, {
                  default() {
                    return renderSettingWidgetForm();
                  }
                }),
                h(tab_pane_default, {
                  title: getI18n("vxe.formDesign.widgetFormTab"),
                  name: 2
                }, {
                  default() {
                    return renderSettingConfigForm();
                  }
                })
              ];
            }
          })
        ])
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/modal/src/modal.js
var import_xe_utils90 = __toESM(require_xe_utils());
var allActiveModals = [];
var msgQueue = [];
var notifyQueue = [];
var lockScrollAttrKey = "data-vxe-lock-scroll";
var lockScrollCssWidthKey = "--vxe-ui-modal-lock-scroll-view-width";
var modal_default = defineComponent({
  name: "VxeModal",
  props: {
    modelValue: Boolean,
    id: String,
    type: {
      type: String,
      default: "modal"
    },
    loading: {
      type: Boolean,
      default: null
    },
    status: String,
    iconStatus: String,
    className: String,
    top: {
      type: [Number, String],
      default: () => getConfig().modal.top
    },
    position: [String, Object],
    title: String,
    duration: {
      type: [Number, String],
      default: () => getConfig().modal.duration
    },
    content: [Number, String],
    showCancelButton: {
      type: Boolean,
      default: null
    },
    cancelButtonText: {
      type: String,
      default: () => getConfig().modal.cancelButtonText
    },
    showConfirmButton: {
      type: Boolean,
      default: () => getConfig().modal.showConfirmButton
    },
    confirmButtonText: {
      type: String,
      default: () => getConfig().modal.confirmButtonText
    },
    lockView: {
      type: Boolean,
      default: () => getConfig().modal.lockView
    },
    lockScroll: Boolean,
    mask: {
      type: Boolean,
      default: () => getConfig().modal.mask
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().modal.maskClosable
    },
    escClosable: {
      type: Boolean,
      default: () => getConfig().modal.escClosable
    },
    cancelClosable: {
      type: Boolean,
      default: () => getConfig().modal.cancelClosable
    },
    confirmClosable: {
      type: Boolean,
      default: () => getConfig().modal.confirmClosable
    },
    resize: Boolean,
    showHeader: {
      type: Boolean,
      default: () => getConfig().modal.showHeader
    },
    showFooter: {
      type: Boolean,
      default: () => getConfig().modal.showFooter
    },
    showZoom: Boolean,
    zoomConfig: Object,
    showMaximize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMaximize)
    },
    showMinimize: {
      type: Boolean,
      default: () => handleBooleanDefaultValue(getConfig().modal.showMinimize)
    },
    showClose: {
      type: Boolean,
      default: () => getConfig().modal.showClose
    },
    dblclickZoom: {
      type: Boolean,
      default: () => getConfig().modal.dblclickZoom
    },
    width: [Number, String],
    height: [Number, String],
    minWidth: {
      type: [Number, String],
      default: () => getConfig().modal.minWidth
    },
    minHeight: {
      type: [Number, String],
      default: () => getConfig().modal.minHeight
    },
    zIndex: Number,
    marginSize: {
      type: [Number, String],
      default: () => getConfig().modal.marginSize
    },
    fullscreen: Boolean,
    draggable: {
      type: Boolean,
      default: () => getConfig().modal.draggable
    },
    remember: { type: Boolean, default: () => getConfig().modal.remember },
    destroyOnClose: {
      type: Boolean,
      default: () => getConfig().modal.destroyOnClose
    },
    showTitleOverflow: {
      type: Boolean,
      default: () => getConfig().modal.showTitleOverflow
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().modal.transfer
    },
    storage: {
      type: Boolean,
      default: () => getConfig().modal.storage
    },
    storageKey: {
      type: String,
      default: () => getConfig().modal.storageKey
    },
    padding: {
      type: Boolean,
      default: () => getConfig().modal.padding
    },
    size: {
      type: String,
      default: () => getConfig().modal.size || getConfig().size
    },
    beforeHideMethod: Function,
    slots: Object,
    /**
     * 已废弃
     * @deprecated
     */
    message: [Number, String],
    /**
     * 已废弃
     * @deprecated
     */
    animat: {
      type: Boolean,
      default: () => getConfig().modal.animat
    }
  },
  emits: [
    "update:modelValue",
    "show",
    "hide",
    "before-hide",
    "close",
    "confirm",
    "cancel",
    "zoom",
    "resize",
    "move"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils90.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      visible: false,
      contentVisible: false,
      modalTop: 0,
      modalZindex: 0,
      prevZoomStatus: "",
      zoomStatus: "",
      revertLocat: null,
      prevLocat: null,
      firstOpen: true
    });
    const internalData = {
      msgTimeout: void 0
    };
    const refElem = ref();
    const refModalBox = ref();
    const refHeaderElem = ref();
    const refConfirmBtn = ref();
    const refCancelBtn = ref();
    const refMaps = {
      refElem
    };
    const computeIsMsg = computed(() => {
      return props.type === "message" || props.type === "notification";
    });
    const computeIsMinimizeStatus = computed(() => {
      return reactData.zoomStatus === "minimize";
    });
    const computeIsMaximizeStatus = computed(() => {
      return reactData.zoomStatus === "maximize";
    });
    const computeZoomOpts = computed(() => {
      return Object.assign({}, getConfig().modal.zoomConfig, props.zoomConfig);
    });
    const computeMaps = {
      computeSize,
      computeZoomOpts
    };
    const $xeModal = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    let modalMethods = {};
    const getBox = () => {
      const boxElem = refModalBox.value;
      return boxElem;
    };
    const recalculate = () => {
      const { width, height } = props;
      const boxElem = getBox();
      if (boxElem) {
        boxElem.style.width = toCssUnit(width);
        boxElem.style.height = toCssUnit(height);
      }
      return nextTick();
    };
    const updateZindex = () => {
      const { zIndex } = props;
      const { modalZindex } = reactData;
      if (zIndex) {
        reactData.modalZindex = zIndex;
      } else if (modalZindex < getLastZIndex2()) {
        reactData.modalZindex = nextZIndex2();
      }
    };
    const updatePosition = () => {
      return nextTick().then(() => {
        const { position } = props;
        const marginSize = import_xe_utils90.default.toNumber(props.marginSize);
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const clientVisibleWidth = document.documentElement.clientWidth || document.body.clientWidth;
        const clientVisibleHeight = document.documentElement.clientHeight || document.body.clientHeight;
        const isPosCenter = position === "center";
        const { top, left } = import_xe_utils90.default.isString(position) ? { top: position, left: position } : Object.assign({}, position);
        const topCenter = isPosCenter || top === "center";
        const leftCenter = isPosCenter || left === "center";
        let posTop = "";
        let posLeft = "";
        if (left && !leftCenter) {
          posLeft = isNaN(left) ? left : `${left}px`;
        } else {
          posLeft = `${Math.max(marginSize, clientVisibleWidth / 2 - boxElem.offsetWidth / 2)}px`;
        }
        if (top && !topCenter) {
          posTop = isNaN(top) ? top : `${top}px`;
        } else {
          posTop = `${Math.max(marginSize, clientVisibleHeight / 2 - boxElem.offsetHeight / 2)}px`;
        }
        boxElem.style.top = posTop;
        boxElem.style.left = posLeft;
      });
    };
    const updateStyle = () => {
      nextTick(() => {
        const { type } = props;
        const queueList = type === "notification" ? notifyQueue : msgQueue;
        let offsetTop = 0;
        queueList.forEach((comp) => {
          const boxElem = comp.getBox();
          if (boxElem) {
            offsetTop += import_xe_utils90.default.toNumber(comp.props.top);
            comp.reactData.modalTop = offsetTop;
            offsetTop += boxElem.clientHeight;
          }
        });
      });
    };
    const removeMsgQueue = () => {
      const { type } = props;
      const queueList = type === "notification" ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) > -1) {
        import_xe_utils90.default.remove(queueList, (comp) => comp === $xeModal);
      }
      updateStyle();
    };
    const closeModal2 = (type) => {
      const { remember } = props;
      const { visible } = reactData;
      const isMsg = computeIsMsg.value;
      const beforeHideFn = props.beforeHideMethod || getConfig().modal.beforeHideMethod;
      const params = { type };
      if (visible) {
        Promise.resolve(beforeHideFn ? beforeHideFn(params) : null).then((rest) => {
          if (!import_xe_utils90.default.isError(rest)) {
            if (isMsg) {
              removeMsgQueue();
            }
            reactData.contentVisible = false;
            if (!remember) {
              handleRevert();
            }
            import_xe_utils90.default.remove(allActiveModals, (item) => item === $xeModal);
            dispatchEvent2("before-hide", params, null);
            setTimeout(() => {
              reactData.visible = false;
              emit("update:modelValue", false);
              dispatchEvent2("hide", params, null);
            }, 200);
            removeBodyLockScroll();
          }
        }).catch((e16) => e16);
      }
      return nextTick();
    };
    const closeEvent = (evnt) => {
      const type = "close";
      dispatchEvent2(type, { type }, evnt);
      closeModal2(type);
    };
    const confirmEvent = (evnt) => {
      const { confirmClosable } = props;
      const type = "confirm";
      dispatchEvent2(type, { type }, evnt);
      if (confirmClosable) {
        closeModal2(type);
      }
    };
    const cancelEvent = (evnt) => {
      const { cancelClosable } = props;
      const type = "cancel";
      dispatchEvent2(type, { type }, evnt);
      if (cancelClosable) {
        closeModal2(type);
      }
    };
    const getStorageMap = (key) => {
      const version7 = getConfig().version;
      const rest = import_xe_utils90.default.toStringJSON(localStorage.getItem(key) || "");
      return rest && rest._v === version7 ? rest : { _v: version7 };
    };
    const hasPosStorage = () => {
      const { id: id2, remember, storage, storageKey } = props;
      return !!(id2 && remember && storage && getStorageMap(storageKey)[id2]);
    };
    const restorePosStorage = () => {
      const { id: id2, remember, storage, storageKey } = props;
      if (id2 && remember && storage) {
        const posStorage = getStorageMap(storageKey)[id2];
        if (posStorage) {
          const boxElem = getBox();
          const [left, top, width, height, zoomLeft, zoomTop, zoomWidth, zoomHeight] = posStorage.split(",");
          if (boxElem) {
            if (left) {
              boxElem.style.left = `${left}px`;
            }
            if (top) {
              boxElem.style.top = `${top}px`;
            }
            if (width) {
              boxElem.style.width = `${width}px`;
            }
            if (height) {
              boxElem.style.height = `${height}px`;
            }
          }
          if (zoomLeft && zoomTop) {
            reactData.revertLocat = {
              left: zoomLeft,
              top: zoomTop,
              width: zoomWidth,
              height: zoomHeight
            };
          }
        }
      }
    };
    const addMsgQueue = () => {
      const { type } = props;
      const queueList = type === "notification" ? notifyQueue : msgQueue;
      if (queueList.indexOf($xeModal) === -1) {
        queueList.push($xeModal);
      }
      updateStyle();
    };
    const savePosStorage = () => {
      const { id: id2, remember, storage, storageKey } = props;
      const { revertLocat } = reactData;
      if (id2 && remember && storage) {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const posStorageMap = getStorageMap(storageKey);
        posStorageMap[id2] = [
          boxElem.style.left,
          boxElem.style.top,
          boxElem.style.width,
          boxElem.style.height
        ].concat(revertLocat ? [
          revertLocat.left,
          revertLocat.top,
          revertLocat.width,
          revertLocat.height
        ] : []).map((val) => val ? import_xe_utils90.default.toNumber(val) : "").join(",");
        localStorage.setItem(storageKey, import_xe_utils90.default.toJSONString(posStorageMap));
      }
    };
    const handleMinimize = () => {
      const zoomOpts = computeZoomOpts.value;
      const { minimizeLayout, minimizeMaxSize, minimizeHorizontalOffset, minimizeVerticalOffset, minimizeOffsetMethod } = zoomOpts;
      const isHorizontalLayout = minimizeLayout === "horizontal";
      const prevZoomStatus = reactData.zoomStatus;
      const hlMList = [];
      const vlMList = [];
      allActiveModals.forEach((item) => {
        if (item.xID !== $xeModal.xID && item.props.type === "modal" && item.reactData.zoomStatus === "minimize") {
          const itemZoomOpts = item.getComputeMaps().computeZoomOpts.value;
          if (itemZoomOpts.minimizeLayout === "horizontal") {
            hlMList.push(item);
          } else {
            vlMList.push(item);
          }
        }
      });
      const mList = isHorizontalLayout ? hlMList : vlMList;
      if (minimizeMaxSize && mList.length >= minimizeMaxSize) {
        if (VxeUI.modal) {
          VxeUI.modal.message({
            status: "error",
            content: getI18n("vxe.modal.miniMaxSize", [minimizeMaxSize])
          });
        }
        return nextTick();
      }
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = "minimize";
      return nextTick().then(() => {
        const boxElem = getBox();
        if (!boxElem) {
          return;
        }
        const headerEl = refHeaderElem.value;
        if (!headerEl) {
          return;
        }
        const { visibleHeight } = getDomNode2();
        if (!prevZoomStatus) {
          reactData.revertLocat = {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft,
            width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
            height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
          };
        }
        const targetModal = import_xe_utils90.default[isHorizontalLayout ? "max" : "min"](mList, ($modal) => {
          const boxElem2 = $modal.getBox();
          return boxElem2 ? import_xe_utils90.default.toNumber(boxElem2.style[isHorizontalLayout ? "left" : "top"]) : 0;
        });
        let targetTop = visibleHeight - headerEl.offsetHeight - 16;
        let targetLeft = 16;
        if (targetModal) {
          const minBoxElem = targetModal.getBox();
          if (minBoxElem) {
            const boxLeft = import_xe_utils90.default.toNumber(minBoxElem.style.left);
            const boxTop = import_xe_utils90.default.toNumber(minBoxElem.style.top);
            let offsetObj = {};
            if (isHorizontalLayout) {
              offsetObj = Object.assign({}, minimizeHorizontalOffset);
            } else {
              offsetObj = Object.assign({}, minimizeVerticalOffset);
            }
            targetLeft = boxLeft + import_xe_utils90.default.toNumber(offsetObj.left);
            targetTop = boxTop + import_xe_utils90.default.toNumber(offsetObj.top);
            if (minimizeOffsetMethod) {
              offsetObj = minimizeOffsetMethod({
                $modal: $xeModal,
                left: targetLeft,
                top: targetTop
              });
              targetLeft = import_xe_utils90.default.toNumber(offsetObj.left);
              targetTop = import_xe_utils90.default.toNumber(offsetObj.top);
            }
          }
        }
        Object.assign(boxElem.style, {
          top: `${targetTop}px`,
          left: `${targetLeft}px`,
          width: "200px",
          height: `${headerEl.offsetHeight}px`
        });
        savePosStorage();
      });
    };
    const handleMaximize = () => {
      const prevZoomStatus = reactData.zoomStatus;
      reactData.prevZoomStatus = prevZoomStatus;
      reactData.zoomStatus = "maximize";
      return nextTick().then(() => {
        const boxElem = getBox();
        if (boxElem) {
          if (!prevZoomStatus) {
            reactData.revertLocat = {
              top: boxElem.offsetTop,
              left: boxElem.offsetLeft,
              width: boxElem.offsetWidth + (boxElem.style.width ? 0 : 1),
              height: boxElem.offsetHeight + (boxElem.style.height ? 0 : 1)
            };
          }
          Object.assign(boxElem.style, {
            top: "0",
            left: "0",
            width: "100%",
            height: "100%"
          });
        }
        savePosStorage();
      });
    };
    const handleMsgAutoClose = () => {
      const { duration } = props;
      if (duration !== -1) {
        internalData.msgTimeout = setTimeout(() => closeModal2("close"), import_xe_utils90.default.toNumber(duration));
      }
    };
    const removeBodyLockScroll = () => {
      const htmlElem = document.documentElement;
      const lockData = htmlElem.getAttribute(lockScrollAttrKey);
      if (lockData) {
        const lockList = lockData.split(",").filter((key) => key !== xID);
        if (lockList.length) {
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(","));
        } else {
          htmlElem.removeAttribute(lockScrollAttrKey);
          htmlElem.style.removeProperty(lockScrollCssWidthKey);
        }
      }
    };
    const addBodyLockScroll = () => {
      const { lockScroll } = props;
      const isMsg = computeIsMsg.value;
      if (lockScroll && !isMsg) {
        const htmlElem = document.documentElement;
        const clientWidth = document.body.clientWidth;
        const lockData = htmlElem.getAttribute(lockScrollAttrKey);
        const lockList = lockData ? lockData.split(",") : [];
        if (!lockList.includes(xID)) {
          lockList.push(xID);
          htmlElem.setAttribute(lockScrollAttrKey, lockList.join(","));
        }
        htmlElem.style.setProperty(lockScrollCssWidthKey, `${clientWidth}px`);
      }
    };
    const openModal2 = () => {
      const { remember, showFooter } = props;
      const { initialized, visible } = reactData;
      const isMsg = computeIsMsg.value;
      if (!initialized) {
        reactData.initialized = true;
      }
      if (!visible) {
        addBodyLockScroll();
        reactData.visible = true;
        reactData.contentVisible = false;
        updateZindex();
        allActiveModals.push($xeModal);
        if (!remember) {
          nextTick(() => {
            recalculate();
          });
        }
        setTimeout(() => {
          reactData.contentVisible = true;
          nextTick(() => {
            if (showFooter) {
              const confirmBtn = refConfirmBtn.value;
              const cancelBtn = refCancelBtn.value;
              const operBtn = confirmBtn || cancelBtn;
              if (operBtn) {
                operBtn.focus();
              }
            }
            const type = "";
            const params = { type };
            emit("update:modelValue", true);
            dispatchEvent2("show", params, null);
          });
        }, 10);
        if (isMsg) {
          addMsgQueue();
          handleMsgAutoClose();
        } else {
          nextTick(() => {
            const { fullscreen } = props;
            const { firstOpen } = reactData;
            if (!remember || firstOpen) {
              updatePosition().then(() => {
                setTimeout(() => updatePosition(), 20);
              });
            }
            if (firstOpen) {
              reactData.firstOpen = false;
              if (hasPosStorage()) {
                restorePosStorage();
              } else if (fullscreen) {
                nextTick(() => handleMaximize());
              }
            } else {
              if (fullscreen) {
                nextTick(() => handleMaximize());
              }
            }
          });
        }
      }
      return nextTick();
    };
    const selfClickEvent = (evnt) => {
      const el2 = refElem.value;
      if (props.maskClosable && evnt.target === el2) {
        const type = "mask";
        closeModal2(type);
      }
    };
    const selfMouseoverEvent = () => {
      const { msgTimeout } = internalData;
      if (!msgTimeout) {
        return;
      }
      const isMsg = computeIsMsg.value;
      if (isMsg) {
        clearTimeout(msgTimeout);
        internalData.msgTimeout = void 0;
      }
    };
    const selfMouseoutEvent = () => {
      const { msgTimeout } = internalData;
      if (!msgTimeout) {
        const isMsg = computeIsMsg.value;
        if (isMsg) {
          handleMsgAutoClose();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      if (isEsc) {
        const lastModal = import_xe_utils90.default.max(allActiveModals, (item) => item.reactData.modalZindex);
        if (lastModal) {
          setTimeout(() => {
            if (lastModal === $xeModal && lastModal.props.escClosable) {
              const type = "exit";
              dispatchEvent2("close", { type }, evnt);
              closeModal2(type);
            }
          }, 10);
        }
      }
    };
    const isMinimized = () => {
      return reactData.zoomStatus === "minimize";
    };
    const isMaximized = () => {
      return reactData.zoomStatus === "maximize";
    };
    const handleRevert = () => {
      reactData.prevZoomStatus = reactData.zoomStatus;
      reactData.zoomStatus = "";
      return nextTick().then(() => {
        const { revertLocat } = reactData;
        if (revertLocat) {
          const boxElem = getBox();
          reactData.revertLocat = null;
          if (boxElem) {
            Object.assign(boxElem.style, {
              top: `${revertLocat.top}px`,
              left: `${revertLocat.left}px`,
              width: `${revertLocat.width}px`,
              height: `${revertLocat.height}px`
            });
          }
          savePosStorage();
          return nextTick();
        }
      });
    };
    const handleZoom = (type) => {
      const { zoomStatus } = reactData;
      return new Promise((resolve) => {
        if (type) {
          if (type === "maximize") {
            resolve(handleMaximize());
            return;
          }
          if (type === "minimize") {
            resolve(handleMinimize());
            return;
          }
          resolve(handleRevert());
          return;
        }
        resolve(zoomStatus ? handleRevert() : handleMaximize());
      }).then(() => {
        return reactData.zoomStatus || "revert";
      });
    };
    const toggleZoomMinEvent = (evnt) => {
      const { zoomStatus, prevZoomStatus } = reactData;
      return handleZoom(zoomStatus === "minimize" ? prevZoomStatus || "revert" : "minimize").then((type) => {
        const params = { type };
        dispatchEvent2("zoom", params, evnt);
      });
    };
    const toggleZoomMaxEvent = (evnt) => {
      return handleZoom().then((type) => {
        const params = { type };
        dispatchEvent2("zoom", params, evnt);
      });
    };
    const getPosition = () => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          return {
            top: boxElem.offsetTop,
            left: boxElem.offsetLeft
          };
        }
      }
      return null;
    };
    const setPosition = (top, left) => {
      const isMsg = computeIsMsg.value;
      if (!isMsg) {
        const boxElem = getBox();
        if (boxElem) {
          if (import_xe_utils90.default.isNumber(top)) {
            boxElem.style.top = `${top}px`;
          }
          if (import_xe_utils90.default.isNumber(left)) {
            boxElem.style.left = `${left}px`;
          }
        }
      }
      return nextTick();
    };
    const boxMousedownEvent = () => {
      const { modalZindex } = reactData;
      if (allActiveModals.some((comp) => comp.reactData.visible && comp.reactData.modalZindex > modalZindex)) {
        updateZindex();
      }
    };
    const mousedownEvent = (evnt) => {
      const { remember, storage } = props;
      const { zoomStatus } = reactData;
      const marginSize = import_xe_utils90.default.toNumber(props.marginSize);
      const boxElem = getBox();
      if (!boxElem) {
        return;
      }
      if (zoomStatus !== "maximize" && evnt.button === 0 && !getEventTargetNode2(evnt, boxElem, "trigger--btn").flag) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        const disX = evnt.clientX - boxElem.offsetLeft;
        const disY = evnt.clientY - boxElem.offsetTop;
        const { visibleHeight, visibleWidth } = getDomNode2();
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const offsetWidth = boxElem.offsetWidth;
          const offsetHeight = boxElem.offsetHeight;
          const minX = marginSize;
          const maxX = visibleWidth - offsetWidth - marginSize - 1;
          const minY = marginSize;
          const maxY = visibleHeight - offsetHeight - marginSize - 1;
          let left = evnt2.clientX - disX;
          let top = evnt2.clientY - disY;
          if (left > maxX) {
            left = maxX;
          }
          if (left < minX) {
            left = minX;
          }
          if (top > maxY) {
            top = maxY;
          }
          if (top < minY) {
            top = minY;
          }
          boxElem.style.left = `${left}px`;
          boxElem.style.top = `${top}px`;
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
          dispatchEvent2("move", { type: "move" }, evnt2);
        };
        document.onmouseup = () => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          if (remember && storage) {
            nextTick(() => {
              savePosStorage();
            });
          }
          setTimeout(() => {
            boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
          }, 50);
        };
      }
    };
    const dragEvent = (evnt) => {
      evnt.preventDefault();
      const { remember, storage } = props;
      const { visibleHeight, visibleWidth } = getDomNode2();
      const marginSize = import_xe_utils90.default.toNumber(props.marginSize);
      const targetElem = evnt.target;
      const type = targetElem.getAttribute("type");
      const minWidth = import_xe_utils90.default.toNumber(props.minWidth);
      const minHeight = import_xe_utils90.default.toNumber(props.minHeight);
      const maxWidth = visibleWidth;
      const maxHeight = visibleHeight;
      const boxElem = getBox();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const clientWidth = boxElem.clientWidth;
      const clientHeight = boxElem.clientHeight;
      const disX = evnt.clientX;
      const disY = evnt.clientY;
      const offsetTop = boxElem.offsetTop;
      const offsetLeft = boxElem.offsetLeft;
      const params = { type: "resize" };
      document.onmousemove = (evnt2) => {
        evnt2.preventDefault();
        let dragLeft;
        let dragTop;
        let width;
        let height;
        switch (type) {
          case "wl":
            dragLeft = disX - evnt2.clientX;
            width = dragLeft + clientWidth;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            break;
          case "swst":
            dragLeft = disX - evnt2.clientX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "swlb":
            dragLeft = disX - evnt2.clientX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft - dragLeft > marginSize) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
                boxElem.style.left = `${offsetLeft - dragLeft}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "st":
            dragTop = disY - evnt2.clientY;
            height = clientHeight + dragTop;
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "wr":
            dragLeft = evnt2.clientX - disX;
            width = dragLeft + clientWidth;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            break;
          case "sest":
            dragLeft = evnt2.clientX - disX;
            dragTop = disY - evnt2.clientY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop - dragTop > marginSize) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
                boxElem.style.top = `${offsetTop - dragTop}px`;
              }
            }
            break;
          case "selb":
            dragLeft = evnt2.clientX - disX;
            dragTop = evnt2.clientY - disY;
            width = dragLeft + clientWidth;
            height = dragTop + clientHeight;
            if (offsetLeft + width + marginSize < visibleWidth) {
              if (width > minWidth) {
                boxElem.style.width = `${width < maxWidth ? width : maxWidth}px`;
              }
            }
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
          case "sb":
            dragTop = evnt2.clientY - disY;
            height = dragTop + clientHeight;
            if (offsetTop + height + marginSize < visibleHeight) {
              if (height > minHeight) {
                boxElem.style.height = `${height < maxHeight ? height : maxHeight}px`;
              }
            }
            break;
        }
        boxElem.className = boxElem.className.replace(/\s?is--drag/, "") + " is--drag";
        if (remember && storage) {
          savePosStorage();
        }
        dispatchEvent2("resize", params, evnt2);
      };
      document.onmouseup = () => {
        reactData.revertLocat = null;
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        setTimeout(() => {
          boxElem.className = boxElem.className.replace(/\s?is--drag/, "");
        }, 50);
      };
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $modal: $xeModal }, params));
    };
    modalMethods = {
      dispatchEvent: dispatchEvent2,
      open: openModal2,
      close() {
        return closeModal2("close");
      },
      getBox,
      getPosition,
      setPosition,
      isMinimized,
      isMaximized,
      zoom: handleZoom,
      minimize: handleMinimize,
      maximize: handleMaximize,
      revert: handleRevert
    };
    Object.assign($xeModal, modalMethods);
    const renderTitles = () => {
      const { slots: propSlots = {}, showClose, showZoom, showMaximize, showMinimize, title } = props;
      const { zoomStatus } = reactData;
      const titleSlot = slots.title || propSlots.title;
      const cornerSlot = slots.corner || propSlots.corner;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const isMaximizeStatus = computeIsMaximizeStatus.value;
      return [
        h("div", {
          class: "vxe-modal--header-title"
        }, titleSlot ? getSlotVNs2(titleSlot({
          $modal: $xeModal,
          minimized: isMinimizeStatus,
          maximized: isMaximizeStatus
        })) : title ? getFuncText2(title) : getI18n("vxe.alert.title")),
        h("div", {
          class: "vxe-modal--header-right"
        }, [
          cornerSlot && !isMinimizeStatus ? h("div", {
            class: "vxe-modal--corner-wrapper"
          }, getSlotVNs2(cornerSlot({ $modal: $xeModal }))) : createCommentVNode(),
          (import_xe_utils90.default.isBoolean(showMinimize) ? showMinimize : showZoom) ? h("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: getI18n(`vxe.modal.zoom${zoomStatus === "minimize" ? "Out" : "Min"}`),
            onClick: toggleZoomMinEvent
          }, [
            h("i", {
              class: zoomStatus === "minimize" ? getIcon().MODAL_ZOOM_REVERT : getIcon().MODAL_ZOOM_MIN
            })
          ]) : createCommentVNode(),
          (import_xe_utils90.default.isBoolean(showMaximize) ? showMaximize : showZoom) && zoomStatus !== "minimize" ? h("div", {
            class: ["vxe-modal--zoom-btn", "trigger--btn"],
            title: getI18n(`vxe.modal.zoom${zoomStatus === "maximize" ? "Out" : "In"}`),
            onClick: toggleZoomMaxEvent
          }, [
            h("i", {
              class: zoomStatus === "maximize" ? getIcon().MODAL_ZOOM_OUT : getIcon().MODAL_ZOOM_IN
            })
          ]) : createCommentVNode(),
          showClose ? h("div", {
            class: ["vxe-modal--close-btn", "trigger--btn"],
            title: getI18n("vxe.modal.close"),
            onClick: closeEvent
          }, [
            h("i", {
              class: getIcon().MODAL_CLOSE
            })
          ]) : createCommentVNode()
        ])
      ];
    };
    const renderHeader = () => {
      const { slots: propSlots = {}, showZoom, showMaximize, draggable } = props;
      const isMsg = computeIsMsg.value;
      const headerSlot = slots.header || propSlots.header;
      if (props.showHeader) {
        const headerOns = {};
        if (draggable) {
          headerOns.onMousedown = mousedownEvent;
        }
        if ((import_xe_utils90.default.isBoolean(showMaximize) ? showMaximize : showZoom) && props.dblclickZoom && props.type === "modal") {
          headerOns.onDblclick = toggleZoomMaxEvent;
        }
        return h("div", Object.assign({ ref: refHeaderElem, class: ["vxe-modal--header", {
          "is--ellipsis": !isMsg && props.showTitleOverflow
        }] }, headerOns), headerSlot ? getSlotVNs2(headerSlot({ $modal: $xeModal })) : renderTitles());
      }
      return createCommentVNode();
    };
    const renderBody = () => {
      const { slots: propSlots = {}, status, message, iconStatus } = props;
      const content = props.content || message;
      const isMsg = computeIsMsg.value;
      const defaultSlot = slots.default || propSlots.default;
      const leftSlot = slots.left || propSlots.left;
      const rightSlot = slots.right || propSlots.right;
      const contVNs = [];
      if (!isMsg && (status || iconStatus)) {
        contVNs.push(h("div", {
          class: "vxe-modal--status-wrapper"
        }, [
          h("i", {
            class: ["vxe-modal--status-icon", iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
          })
        ]));
      }
      contVNs.push(h("div", {
        class: "vxe-modal--content"
      }, defaultSlot ? getSlotVNs2(defaultSlot({ $modal: $xeModal })) : getFuncText2(content)));
      return h("div", {
        class: "vxe-modal--body"
      }, [
        leftSlot ? h("div", {
          class: "vxe-modal--body-left"
        }, getSlotVNs2(leftSlot({ $modal: $xeModal }))) : createCommentVNode(),
        h("div", {
          class: "vxe-modal--body-default"
        }, contVNs),
        rightSlot ? h("div", {
          class: "vxe-modal--body-right"
        }, getSlotVNs2(rightSlot({ $modal: $xeModal }))) : createCommentVNode(),
        isMsg ? createCommentVNode() : h(loading_default2, {
          class: "vxe-modal--loading",
          modelValue: props.loading
        })
      ]);
    };
    const renderDefaultFooter = () => {
      const { slots: propSlots = {}, showCancelButton, showConfirmButton, type, loading: loading2 } = props;
      const lfSlot = slots.leftfoot || propSlots.leftfoot;
      const rfSlot = slots.rightfoot || propSlots.rightfoot;
      const btnVNs = [];
      if (import_xe_utils90.default.isBoolean(showCancelButton) ? showCancelButton : type === "confirm") {
        btnVNs.push(h(button_default, {
          key: 1,
          ref: refCancelBtn,
          content: props.cancelButtonText || getI18n("vxe.button.cancel"),
          onClick: cancelEvent
        }));
      }
      if (import_xe_utils90.default.isBoolean(showConfirmButton) ? showConfirmButton : type === "confirm" || type === "alert") {
        btnVNs.push(h(button_default, {
          key: 2,
          ref: refConfirmBtn,
          loading: loading2,
          status: "primary",
          content: props.confirmButtonText || getI18n("vxe.button.confirm"),
          onClick: confirmEvent
        }));
      }
      return h("div", {
        class: "vxe-modal--footer-wrapper"
      }, [
        h("div", {
          class: "vxe-modal--footer-left"
        }, lfSlot ? getSlotVNs2(lfSlot({ $modal: $xeModal })) : []),
        h("div", {
          class: "vxe-modal--footer-right"
        }, rfSlot ? getSlotVNs2(rfSlot({ $modal: $xeModal })) : btnVNs)
      ]);
    };
    const renderFooter = () => {
      const { slots: propSlots = {} } = props;
      const footerSlot = slots.footer || propSlots.footer;
      if (props.showFooter) {
        return h("div", {
          class: "vxe-modal--footer"
        }, footerSlot ? getSlotVNs2(footerSlot({ $modal: $xeModal })) : [renderDefaultFooter()]);
      }
      return createCommentVNode();
    };
    const renderVN = () => {
      const { slots: propSlots = {}, className, type, animat, draggable, iconStatus, position, loading: loading2, destroyOnClose, status, lockScroll, padding, lockView, mask, resize } = props;
      const { initialized, modalTop, contentVisible, visible, zoomStatus } = reactData;
      const asideSlot = slots.aside || propSlots.aside;
      const vSize = computeSize.value;
      const isMsg = computeIsMsg.value;
      const isMinimizeStatus = computeIsMinimizeStatus.value;
      const ons = {};
      if (isMsg) {
        ons.onMouseover = selfMouseoverEvent;
        ons.onMouseout = selfMouseoutEvent;
      }
      return h(Teleport, {
        to: "body",
        disabled: props.transfer ? !initialized : true
      }, [
        h("div", Object.assign({ ref: refElem, class: ["vxe-modal--wrapper", `type--${type}`, `zoom--${zoomStatus || "revert"}`, className || "", position ? `pos--${position}` : "", {
          [`size--${vSize}`]: vSize,
          [`status--${status}`]: status,
          "is--padding": padding,
          "is--animat": animat,
          "lock--scroll": lockScroll,
          "lock--view": lockView,
          "is--draggable": draggable,
          "is--resize": resize,
          "is--mask": mask,
          "is--visible": contentVisible,
          "is--active": visible,
          "is--loading": loading2
        }], style: {
          zIndex: reactData.modalZindex,
          top: modalTop ? `${modalTop}px` : null
        }, onClick: selfClickEvent }, ons), [
          h("div", {
            ref: refModalBox,
            class: "vxe-modal--box",
            onMousedown: boxMousedownEvent
          }, [
            (isMsg || asideSlot) && !isMinimizeStatus ? h("div", {
              class: "vxe-modal--aside"
            }, asideSlot ? getSlotVNs2(asideSlot({ $modal: $xeModal })) : [
              status || iconStatus ? h("div", {
                class: "vxe-modal--status-wrapper"
              }, [
                h("i", {
                  class: ["vxe-modal--status-icon", iconStatus || getIcon()[`MODAL_${status}`.toLocaleUpperCase()]]
                })
              ]) : createCommentVNode()
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-modal--container"
            }, !reactData.initialized || destroyOnClose && !reactData.visible ? [] : [
              renderHeader(),
              renderBody(),
              renderFooter(),
              !isMsg && resize ? h("span", {
                class: "vxe-modal--resize"
              }, ["wl", "wr", "swst", "sest", "st", "swlb", "selb", "sb"].map((type2) => {
                return h("span", {
                  class: `${type2}-resize`,
                  type: type2,
                  onMousedown: dragEvent
                });
              })) : createCommentVNode()
            ])
          ])
        ])
      ]);
    };
    $xeModal.renderVN = renderVN;
    watch(() => props.width, recalculate);
    watch(() => props.height, recalculate);
    watch(() => props.modelValue, (value) => {
      if (value) {
        openModal2();
      } else {
        closeModal2("model");
      }
    });
    onMounted(() => {
      if (true) {
        if (props.type === "modal" && props.showFooter && !(props.showConfirmButton || props.showCancelButton || slots.footer)) {
          warnLog2("vxe.modal.footPropErr");
        }
      }
      nextTick(() => {
        if (props.storage && !props.id) {
          errLog2("vxe.error.reqProp", ["modal.id"]);
        }
        if (props.modelValue) {
          openModal2();
        }
        recalculate();
      });
      if (props.escClosable) {
        globalEvents.on($xeModal, "keydown", handleGlobalKeydownEvent);
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeModal, "keydown");
      removeMsgQueue();
      removeBodyLockScroll();
    });
    provide("$xeModal", $xeModal);
    return $xeModal;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/form-view.js
var import_xe_utils92 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/form-design/src/default-setting-data.js
var getDefaultSettingFormData = (defOpts) => {
  return {
    title: "",
    pcVisible: defOpts ? !!defOpts.pcVisible : true,
    pcVertical: true,
    pcTitleBold: true,
    pcTitleColon: false,
    pcTitleAlign: "",
    pcTitleWidth: "",
    pcTitleWidthUnit: "",
    mobileVisible: defOpts ? !!defOpts.mobileVisible : true,
    mobileVertical: true,
    mobileTitleBold: true,
    mobileTitleColon: false,
    mobileTitleAlign: "",
    mobileTitleWidth: "",
    mobileTitleWidthUnit: ""
  };
};
var createDefaultFormViewPCFormConfig = (params) => {
  const { formConfig } = params;
  return {
    vertical: formConfig.pcVertical,
    titleBold: formConfig.pcTitleBold,
    titleColon: formConfig.pcTitleColon,
    titleAlign: formConfig.pcTitleAlign,
    titleWidth: formConfig.pcTitleWidth
  };
};
var createDefaultFormViewMobileFormConfig = (params) => {
  const { formConfig } = params;
  return {
    vertical: formConfig.mobileVertical,
    titleBold: formConfig.mobileTitleBold,
    titleColon: formConfig.mobileTitleColon,
    titleAlign: formConfig.mobileTitleAlign,
    titleWidth: formConfig.mobileTitleWidth
  };
};

// node_modules/vxe-pc-ui/es/form/src/form-group.js
var import_xe_utils91 = __toESM(require_xe_utils());
var form_group_default = defineComponent({
  name: "VxeFormGroup",
  props: formItemProps,
  setup(props, context) {
    const { slots } = context;
    const refElem = ref();
    const $xeForm = inject("$xeForm", {});
    const $xeParentFormGroup = inject("$xeFormGroup", null);
    const formItem = reactive(createItem($xeForm, props));
    formItem.slots = slots;
    formItem.children = [];
    const formItemInfo = { itemConfig: formItem };
    provide("xeFormItemInfo", formItemInfo);
    const renderVN = () => {
      const formProps = $xeForm.props;
      const item = formItem;
      const { data, readonly, disabled } = formProps;
      const { visible, field, itemRender, contentStyle } = item;
      const compConf = isEnableConf2(itemRender) ? renderer.get(itemRender.name) : null;
      const itemStyle = compConf ? compConf.formItemStyle || compConf.itemStyle : null;
      const itemContentStyle = compConf ? compConf.formItemContentStyle || compConf.itemContentStyle : null;
      const defaultSlot = slots ? slots.default : null;
      const params = { data, disabled, readonly, field, property: field, item, $form: $xeForm, $grid: $xeForm.xegrid };
      if (visible === false) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        key: item.id,
        class: getItemClass($xeForm, item, true),
        style: import_xe_utils91.default.isFunction(itemStyle) ? itemStyle(params) : itemStyle
      }, [
        renderTitle($xeForm, item, true),
        h("div", {
          class: getItemContentClass($xeForm, item, true),
          style: Object.assign({}, import_xe_utils91.default.isFunction(itemContentStyle) ? itemContentStyle(params) : itemContentStyle, import_xe_utils91.default.isFunction(contentStyle) ? contentStyle(params) : contentStyle)
        }, defaultSlot ? defaultSlot({}) : [])
      ]);
    };
    const $xeFormGroup = {
      formItem,
      renderVN
    };
    watchItem(props, formItem);
    onMounted(() => {
      const elem = refElem.value;
      assembleItem($xeForm, elem, formItem, $xeParentFormGroup);
    });
    onUnmounted(() => {
      destroyItem($xeForm, formItem);
    });
    provide("$xeFormGroup", $xeFormGroup);
    provide("$xeFormItem", null);
    return $xeFormGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/form-view.js
var form_view_default = defineComponent({
  name: "VxeFormView",
  props: {
    modelValue: Object,
    config: Object,
    readonly: Boolean,
    disabled: Boolean,
    viewRender: Object,
    formOptions: Object,
    createFormConfig: Function,
    size: {
      type: String,
      default: () => getConfig().formView.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "submit",
    "reset"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils92.default.uniqueId();
    const refElem = ref();
    const formRef = ref();
    const { computeSize } = useSize(props);
    const $xeFormDesignLayoutStyle = inject("$xeFormDesignLayoutStyle", null);
    const reactData = reactive({
      formConfig: {},
      formRules: {},
      widgetObjList: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeFormView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clearConfig = () => {
      return loadConfig({
        formConfig: {},
        widgetData: []
      });
    };
    const loadConfig = (config3) => {
      if (config3) {
        const { formConfig, widgetData } = config3;
        loadFormConfig(formConfig || {});
        loadWidgetData(widgetData || []);
      }
      return nextTick();
    };
    const parseConfig = (config3) => {
      const { formConfig, widgetData } = config3 || {};
      const widgetObjList = parseWidgetData(widgetData || []);
      return Object.assign(Object.assign({}, parseForm(widgetObjList)), { formConfig: parseFormConfig(formConfig || {}), widgetData: widgetObjList });
    };
    const parseFormConfig = (formConfig) => {
      const { viewRender, createFormConfig, formOptions } = props;
      const params = { viewRender, formConfig };
      if (createFormConfig) {
        return createFormConfig(params);
      }
      const { name } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      return Object.assign({}, createPCFormConfig ? createPCFormConfig(params) : createDefaultFormViewPCFormConfig(params), formOptions);
    };
    const loadFormConfig = (formConfig) => {
      reactData.formConfig = parseFormConfig(formConfig);
      return nextTick();
    };
    const parseForm = (widgetObjList) => {
      const formData = {};
      const formRules = {};
      import_xe_utils92.default.eachTree(widgetObjList, (widget) => {
        const { name, field, required } = widget;
        const compConf = renderer.get(name) || {};
        const createWidgetFieldValue = compConf.createFormDesignWidgetFieldValue;
        const createWidgetFieldRules = compConf.createFormDesignWidgetFieldRules;
        formData[field] = createWidgetFieldValue ? createWidgetFieldValue({ widget, $formView: $xeFormView }) : getWidgetDefaultValue(widget);
        if (createWidgetFieldRules) {
          const rules = createWidgetFieldRules({ widget, $formView: $xeFormView });
          if (rules && rules.length) {
            formRules[field] = rules;
          }
        } else if (required) {
          formRules[field] = getWidgetDefaultRule();
        }
      }, { children: "children" });
      return {
        formData,
        formRules
      };
    };
    const parseWidgetData = (widgetData) => {
      return (widgetData || []).map((item) => configToWidget(item));
    };
    const loadWidgetData = (widgetData) => {
      const widgetObjList = parseWidgetData(widgetData);
      reactData.widgetObjList = widgetObjList;
      const { formData, formRules } = parseForm(widgetObjList);
      reactData.formRules = formRules;
      emit("update:modelValue", Object.assign(formData, props.modelValue));
      return nextTick();
    };
    const getWidgetDefaultValue = (widget) => {
      switch (widget.name) {
        case "subtable":
          return [];
      }
      return null;
    };
    const getWidgetDefaultRule = () => {
      return [
        { required: true, content: "该填写该字段！" }
      ];
    };
    const updateWidgetStatus = (widget, value) => {
      const { field } = widget;
      const $form = formRef.value;
      if ($form) {
        $form.updateStatus({ field }, value);
      }
      return nextTick();
    };
    const setItemValue = (widget, value) => {
      const { modelValue } = props;
      const { field } = widget;
      const $form = formRef.value;
      if (modelValue) {
        modelValue[field] = value;
      }
      if ($form) {
        $form.updateStatus({ field }, value);
      }
      return nextTick();
    };
    const getItemValue = (widget) => {
      const { modelValue } = props;
      if (modelValue) {
        return modelValue[widget.field];
      }
      return null;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $formView: $xeFormView }, params));
    };
    const toWidgetFields = (widget) => {
      if (widget) {
        if (import_xe_utils92.default.isArray(widget)) {
          return widget.map((item) => item.name);
        } else {
          return [widget.name];
        }
      }
      return null;
    };
    const formViewMethods = {
      dispatchEvent: dispatchEvent2,
      clearConfig,
      loadConfig,
      parseConfig,
      loadFormConfig,
      loadWidgetData,
      updateWidgetStatus,
      setItemValue,
      getItemValue,
      validate() {
        const $form = formRef.value;
        if ($form) {
          return $form.validate();
        }
        return nextTick();
      },
      validateWidget(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.validateField(toWidgetFields(widget));
        }
        return nextTick();
      },
      clearValidate(widget) {
        const $form = formRef.value;
        if ($form) {
          return $form.clearValidate(toWidgetFields(widget));
        }
        return nextTick();
      },
      reset() {
        const { widgetObjList } = reactData;
        const { formData } = parseForm(widgetObjList);
        emit("update:modelValue", Object.assign({}, formData));
        return nextTick();
      },
      /**
       * 已废弃
       * @deprecated
       */
      updateItemStatus(widget, value) {
        if (true) {
          warnLog2("vxe.error.delFunc", ["updateItemStatus", "updateWidgetStatus"]);
        }
        return updateWidgetStatus(widget, value);
      }
    };
    const handleSubmit = (params) => {
      dispatchEvent2("submit", params, params.$event);
    };
    const handleReset = (params) => {
      dispatchEvent2("reset", params, params.$event);
    };
    const formViewPrivateMethods = {};
    Object.assign($xeFormView, formViewMethods, formViewPrivateMethods);
    const renderVN = () => {
      const { readonly, disabled, modelValue } = props;
      const { formConfig, formRules, widgetObjList } = reactData;
      const vSize = computeSize.value;
      const topSlot = slots.top;
      const bottomSlot = slots.bottom;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: ["vxe-form-view", {
          [`size--${vSize}`]: vSize
        }]
      }, [
        topSlot ? h("div", {
          class: "vxe-form-view--top"
        }, getSlotVNs2(topSlot({ $formView: $xeFormView }))) : createCommentVNode(),
        h(form_default, Object.assign(Object.assign({ ref: formRef }, formConfig), {
          data: modelValue,
          customLayout: true,
          readonly,
          disabled,
          span: 24,
          rules: formRules,
          onSubmit: handleSubmit,
          onReset: handleReset
        }), {
          default() {
            const { readonly: readonly2, disabled: disabled2 } = props;
            return [
              headerSlot ? h(form_item_default, {}, {
                default() {
                  return headerSlot({});
                }
              }) : createCommentVNode(),
              ...widgetObjList.map((widget) => {
                const { name } = widget;
                const compConf = renderer.get(name) || {};
                const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                const renderWidgetDesignPreview = compConf.renderFormDesignWidgetPreview;
                const renderWidgetDesignMobilePreview = compConf.renderFormDesignWidgetMobilePreview;
                const isEditMode = !!$xeFormDesignLayoutStyle;
                const renderOpts = widget;
                const params = { widget, readonly: !!readonly2, disabled: !!disabled2, isEditMode, isViewMode: !isEditMode, $formDesign: null, $formView: $xeFormView };
                return h(form_group_default, {
                  key: widget.id
                }, {
                  default() {
                    if ($xeFormDesignLayoutStyle) {
                      if ($xeFormDesignLayoutStyle.reactData.activeTab === 2) {
                        if (renderWidgetDesignMobilePreview) {
                          return getSlotVNs2(renderWidgetDesignMobilePreview(renderOpts, params));
                        }
                      } else {
                        if (renderWidgetDesignPreview) {
                          return getSlotVNs2(renderWidgetDesignPreview(renderOpts, params));
                        }
                      }
                    }
                    return renderWidgetDesignView ? getSlotVNs2(renderWidgetDesignView(renderOpts, params)) : [];
                  }
                });
              }),
              footerSlot ? h(form_group_default, {
                span: 24
              }, {
                default() {
                  return footerSlot({});
                }
              }) : createCommentVNode()
            ];
          }
        }),
        bottomSlot ? h("div", {
          class: "vxe-form-view--bottom"
        }, getSlotVNs2(bottomSlot({ $formView: $xeFormView }))) : createCommentVNode()
      ]);
    };
    $xeFormView.renderVN = renderVN;
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeFormView", $xeFormView);
    return $xeFormView;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/input/src/input.js
var import_xe_utils94 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/number-input/src/util.js
var import_xe_utils93 = __toESM(require_xe_utils());
function handleNumber(val) {
  return import_xe_utils93.default.isString(val) ? val.replace(/,/g, "") : val;
}
function toFloatValueFixed(inputValue, digitsValue) {
  if (/^-/.test("" + inputValue)) {
    return import_xe_utils93.default.toFixed(import_xe_utils93.default.ceil(inputValue, digitsValue), digitsValue);
  }
  return import_xe_utils93.default.toFixed(import_xe_utils93.default.floor(inputValue, digitsValue), digitsValue);
}

// node_modules/vxe-pc-ui/es/input/src/input.js
var input_default = defineComponent({
  name: "VxeInput",
  props: {
    modelValue: [String, Number, Date],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "text"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().input.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().input.size || getConfig().size
    },
    multiple: Boolean,
    // text
    showWordCount: Boolean,
    countMethod: Function,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().input.exponential
    },
    // number、integer、float、password
    controls: {
      type: Boolean,
      default: () => getConfig().input.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: () => getConfig().input.digits
    },
    // date、week、month、quarter、year
    startDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.startDate
    },
    endDate: {
      type: [String, Number, Date],
      default: () => getConfig().input.endDate
    },
    minDate: [String, Number, Date],
    maxDate: [String, Number, Date],
    // 已废弃 startWeek，被 startDay 替换
    startWeek: Number,
    startDay: {
      type: [String, Number],
      default: () => getConfig().input.startDay
    },
    labelFormat: String,
    valueFormat: String,
    editable: {
      type: Boolean,
      default: true
    },
    festivalMethod: {
      type: Function,
      default: () => getConfig().input.festivalMethod
    },
    disabledMethod: {
      type: Function,
      default: () => getConfig().input.disabledMethod
    },
    // week
    selectDay: {
      type: [String, Number],
      default: () => getConfig().input.selectDay
    },
    prefixIcon: String,
    suffixIcon: String,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    },
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "search-click",
    "toggle-visible",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click",
    "date-prev",
    "date-today",
    "date-next"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeSelect = inject("$xeSelect", null);
    const $xeTreeSelect = inject("$xeTreeSelect", null);
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils94.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      showPwd: false,
      visiblePanel: false,
      isAniVisible: false,
      panelStyle: {},
      panelPlacement: "",
      isActivated: false,
      inputValue: props.modelValue,
      datetimePanelValue: null,
      datePanelValue: null,
      datePanelLabel: "",
      datePanelType: "day",
      selectMonth: null,
      currentDate: null
    });
    const internalData = {
      yearSize: 12,
      monthSize: 20,
      quarterSize: 8,
      hpTimeout: void 0,
      dnTimeout: void 0
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refPanelWrapper = ref();
    const refInputTimeBody = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let inputMethods = {};
    const parseDate2 = (value, format4) => {
      const { type } = props;
      if (type === "time") {
        return toStringTimeDate(value);
      }
      return import_xe_utils94.default.toStringDate(value, format4);
    };
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().input.transfer;
        if (import_xe_utils94.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeFormReadonly = computed(() => {
      if ($xeForm) {
        return $xeForm.props.readonly;
      }
      return false;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      const maxLen = maxLength || maxlength;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        if (!import_xe_utils94.default.toNumber(maxLen)) {
          return 16;
        }
      }
      return maxLen;
    });
    const computeIsDateTimeType = computed(() => {
      const { type } = props;
      return type === "time" || type === "datetime";
    });
    const computeIsNumType = computed(() => {
      return ["number", "integer", "float"].indexOf(props.type) > -1;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils94.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils94.default.toNumber(inpMaxLength);
    });
    const computeIsDatePickerType = computed(() => {
      const isDateTimeType = computeIsDateTimeType.value;
      return isDateTimeType || ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeIsPawdType = computed(() => {
      return props.type === "password";
    });
    const computeIsSearchType = computed(() => {
      return props.type === "search";
    });
    const computeDigitsValue = computed(() => {
      return import_xe_utils94.default.toInteger(props.digits) || 1;
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils94.default.toInteger(step) || 1;
      } else if (type === "float") {
        return import_xe_utils94.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils94.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      return props.clearable && (isPawdType || isNumType || isDatePickerType || type === "text" || type === "search");
    });
    const computeDateStartTime = computed(() => {
      return props.startDate ? import_xe_utils94.default.toStringDate(props.startDate) : null;
    });
    const computeDateEndTime = computed(() => {
      return props.endDate ? import_xe_utils94.default.toStringDate(props.endDate) : null;
    });
    const computeSupportMultiples = computed(() => {
      return ["date", "week", "month", "quarter", "year"].indexOf(props.type) > -1;
    });
    const computeDateListValue = computed(() => {
      const { modelValue, multiple } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      if (multiple && modelValue && isDatePickerType) {
        return import_xe_utils94.default.toValueString(modelValue).split(",").map((item) => {
          const date = parseDate2(item, dateValueFormat);
          if (import_xe_utils94.default.isValidDate(date)) {
            return date;
          }
          return null;
        });
      }
      return [];
    });
    const computeDateMultipleValue = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateValueFormat = computeDateValueFormat.value;
      return dateListValue.map((date) => import_xe_utils94.default.toDateString(date, dateValueFormat));
    });
    const computeDateMultipleLabel = computed(() => {
      const dateListValue = computeDateListValue.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      return dateListValue.map((date) => import_xe_utils94.default.toDateString(date, dateLabelFormat)).join(", ");
    });
    const computeDateValueFormat = computed(() => {
      const { type, valueFormat } = props;
      if (valueFormat) {
        return valueFormat;
      }
      if (type === "time") {
        return "HH:mm:ss";
      }
      if (type === "datetime") {
        return "yyyy-MM-dd HH:mm:ss";
      }
      return "yyyy-MM-dd";
    });
    const computeDateValue = computed(() => {
      const { modelValue } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateValueFormat = computeDateValueFormat.value;
      let val = null;
      if (modelValue && isDatePickerType) {
        const date = parseDate2(modelValue, dateValueFormat);
        if (import_xe_utils94.default.isValidDate(date)) {
          val = date;
        }
      }
      return val;
    });
    const computeIsDisabledPrevDateBtn = computed(() => {
      const dateStartTime = computeDateStartTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateStartTime) {
        return selectMonth <= dateStartTime;
      }
      return false;
    });
    const computeIsDisabledNextDateBtn = computed(() => {
      const dateEndTime = computeDateEndTime.value;
      const { selectMonth } = reactData;
      if (selectMonth && dateEndTime) {
        return selectMonth >= dateEndTime;
      }
      return false;
    });
    const computeDateTimeLabel = computed(() => {
      const { datetimePanelValue } = reactData;
      const hasTimeSecond = computeHasTimeSecond.value;
      if (datetimePanelValue) {
        return import_xe_utils94.default.toDateString(datetimePanelValue, hasTimeSecond ? "HH:mm:ss" : "HH:mm");
      }
      return "";
    });
    const computeDateHMSTime = computed(() => {
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      return dateValue && isDateTimeType ? (dateValue.getHours() * 3600 + dateValue.getMinutes() * 60 + dateValue.getSeconds()) * 1e3 : 0;
    });
    const computeDateLabelFormat = computed(() => {
      const { labelFormat } = props;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        return labelFormat || getI18n(`vxe.input.date.labelFormat.${props.type}`);
      }
      return "";
    });
    const computeYearList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { yearSize } = internalData;
      const years = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const selectFullYear = selectMonth.getFullYear();
        const startYearDate = new Date(selectFullYear - selectFullYear % yearSize, 0, 1);
        for (let index2 = -4; index2 < yearSize + 4; index2++) {
          const date = import_xe_utils94.default.getWhatYear(startYearDate, index2, "first");
          const itemFullYear = date.getFullYear();
          years.push({
            date,
            isCurrent: true,
            isPrev: index2 < 0,
            isNow: currFullYear === itemFullYear,
            isNext: index2 >= yearSize,
            year: itemFullYear
          });
        }
      }
      return years;
    });
    const computeSelectDatePanelLabel = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const { datePanelType, selectMonth } = reactData;
        const yearList = computeYearList.value;
        let year = "";
        let month;
        if (selectMonth) {
          year = selectMonth.getFullYear();
          month = selectMonth.getMonth() + 1;
        }
        if (datePanelType === "quarter") {
          return getI18n("vxe.input.date.quarterLabel", [year]);
        } else if (datePanelType === "month") {
          return getI18n("vxe.input.date.monthLabel", [year]);
        } else if (datePanelType === "year") {
          return yearList.length ? `${yearList[0].year} - ${yearList[yearList.length - 1].year}` : "";
        }
        return getI18n("vxe.input.date.dayLabel", [year, month ? getI18n(`vxe.input.date.m${month}`) : "-"]);
      }
      return "";
    });
    const computeFirstDayOfWeek = computed(() => {
      const { startDay, startWeek } = props;
      return import_xe_utils94.default.toNumber(import_xe_utils94.default.isNumber(startDay) || import_xe_utils94.default.isString(startDay) ? startDay : startWeek);
    });
    const computeWeekDatas = computed(() => {
      const weeks = [];
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        let sWeek = computeFirstDayOfWeek.value;
        weeks.push(sWeek);
        for (let index2 = 0; index2 < 6; index2++) {
          if (sWeek >= 6) {
            sWeek = 0;
          } else {
            sWeek++;
          }
          weeks.push(sWeek);
        }
      }
      return weeks;
    });
    const computeDateHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const weekDatas = computeWeekDatas.value;
        return weekDatas.map((day) => {
          return {
            value: day,
            label: getI18n(`vxe.input.date.weeks.w${day}`)
          };
        });
      }
      return [];
    });
    const computeWeekHeaders = computed(() => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        const dateHeaders = computeDateHeaders.value;
        return [{ label: getI18n("vxe.input.date.weeks.w") }].concat(dateHeaders);
      }
      return [];
    });
    const computeYearDatas = computed(() => {
      const yearList = computeYearList.value;
      return import_xe_utils94.default.chunk(yearList, 4);
    });
    const computeQuarterList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { quarterSize } = internalData;
      const quarters = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currQuarter = getDateQuarter(currentDate);
        const firstYear = import_xe_utils94.default.getWhatYear(selectMonth, 0, "first");
        const selFullYear = firstYear.getFullYear();
        for (let index2 = -2; index2 < quarterSize - 2; index2++) {
          const date = import_xe_utils94.default.getWhatQuarter(firstYear, index2);
          const itemFullYear = date.getFullYear();
          const itemQuarter = getDateQuarter(date);
          const isPrev = itemFullYear < selFullYear;
          quarters.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemQuarter === currQuarter,
            isNext: !isPrev && itemFullYear > selFullYear,
            quarter: itemQuarter
          });
        }
      }
      return quarters;
    });
    const computeQuarterDatas = computed(() => {
      const quarterList = computeQuarterList.value;
      return import_xe_utils94.default.chunk(quarterList, 2);
    });
    const computeMonthList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const { monthSize } = internalData;
      const months = [];
      if (selectMonth && currentDate) {
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const selFullYear = import_xe_utils94.default.getWhatYear(selectMonth, 0, "first").getFullYear();
        for (let index2 = -4; index2 < monthSize - 4; index2++) {
          const date = import_xe_utils94.default.getWhatYear(selectMonth, 0, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const isPrev = itemFullYear < selFullYear;
          months.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth,
            isNext: !isPrev && itemFullYear > selFullYear,
            month: itemMonth
          });
        }
      }
      return months;
    });
    const computeMonthDatas = computed(() => {
      const monthList = computeMonthList.value;
      return import_xe_utils94.default.chunk(monthList, 4);
    });
    const computeDayList = computed(() => {
      const { selectMonth, currentDate } = reactData;
      const days = [];
      if (selectMonth && currentDate) {
        const dateHMSTime = computeDateHMSTime.value;
        const weekDatas = computeWeekDatas.value;
        const currFullYear = currentDate.getFullYear();
        const currMonth = currentDate.getMonth();
        const currDate = currentDate.getDate();
        const selFullYear = selectMonth.getFullYear();
        const selMonth = selectMonth.getMonth();
        const selDay = selectMonth.getDay();
        const prevOffsetDate = -weekDatas.indexOf(selDay);
        const startDayDate = new Date(import_xe_utils94.default.getWhatDay(selectMonth, prevOffsetDate).getTime() + dateHMSTime);
        for (let index2 = 0; index2 < 42; index2++) {
          const date = import_xe_utils94.default.getWhatDay(startDayDate, index2);
          const itemFullYear = date.getFullYear();
          const itemMonth = date.getMonth();
          const itemDate = date.getDate();
          const isPrev = date < selectMonth;
          days.push({
            date,
            isPrev,
            isCurrent: itemFullYear === selFullYear && itemMonth === selMonth,
            isNow: itemFullYear === currFullYear && itemMonth === currMonth && itemDate === currDate,
            isNext: !isPrev && selMonth !== itemMonth,
            label: itemDate
          });
        }
      }
      return days;
    });
    const computeDayDatas = computed(() => {
      const dayList = computeDayList.value;
      return import_xe_utils94.default.chunk(dayList, 7);
    });
    const computeWeekDates = computed(() => {
      const dayDatas = computeDayDatas.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      return dayDatas.map((list) => {
        const firstItem = list[0];
        const item = {
          date: firstItem.date,
          isWeekNumber: true,
          isPrev: false,
          isCurrent: false,
          isNow: false,
          isNext: false,
          label: import_xe_utils94.default.getYearWeek(firstItem.date, firstDayOfWeek)
        };
        return [item].concat(list);
      });
    });
    const computeHourList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index2 = 0; index2 < 24; index2++) {
          list.push({
            value: index2,
            label: ("" + index2).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeMinuteList = computed(() => {
      const list = [];
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        for (let index2 = 0; index2 < 60; index2++) {
          list.push({
            value: index2,
            label: ("" + index2).padStart(2, "0")
          });
        }
      }
      return list;
    });
    const computeHasTimeMinute = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /mm/.test(dateValueFormat);
    });
    const computeHasTimeSecond = computed(() => {
      const dateValueFormat = computeDateValueFormat.value;
      return !/HH/.test(dateValueFormat) || /ss/.test(dateValueFormat);
    });
    const computeSecondList = computed(() => {
      const minuteList = computeMinuteList.value;
      return minuteList;
    });
    const computeInputReadonly = computed(() => {
      const { type, editable, multiple } = props;
      const isReadonly = computeIsReadonly.value;
      return isReadonly || multiple || !editable || type === "week" || type === "quarter";
    });
    const computeInputType = computed(() => {
      const { type } = props;
      const { showPwd } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      if (isDatePickerType || isNumType || isPawdType && showPwd || type === "number") {
        return "text";
      }
      return type;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().input.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpImmediate = computed(() => {
      const { type, immediate } = props;
      return immediate || !(type === "text" || type === "number" || type === "integer" || type === "float");
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        return type === "integer" ? import_xe_utils94.default.toInteger(handleNumber(inputValue)) : import_xe_utils94.default.toNumber(handleNumber(inputValue));
      }
      return 0;
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && min !== null) {
        return numValue <= import_xe_utils94.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const isNumType = computeIsNumType.value;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && isNumType && max !== null) {
        return numValue >= import_xe_utils94.default.toNumber(max);
      }
      return false;
    });
    const getNumberValue = (val) => {
      const { type, exponential } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const restVal = type === "float" ? toFloatValueFixed(val, digitsValue) : import_xe_utils94.default.toValueString(val);
      if (exponential && (val === restVal || import_xe_utils94.default.toValueString(val).toLowerCase() === import_xe_utils94.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      inputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      inputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils94.default.toValueString(props.modelValue) !== value) {
        inputMethods.dispatchEvent("change", { value }, evnt);
        if (!$xeSelect && !$xeTreeSelect) {
          if ($xeForm && formItemInfo) {
            $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
          }
        }
      }
    };
    const emitInputEvent = (value, evnt) => {
      const isDatePickerType = computeIsDatePickerType.value;
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (!isDatePickerType) {
        if (inpImmediate) {
          handleChange(value, evnt);
        } else {
          inputMethods.dispatchEvent("input", { value }, evnt);
        }
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent3(evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue;
      if (!inpImmediate) {
        handleChange(value, evnt);
      }
      afterCheckValue();
      if (!reactData.visiblePanel) {
        reactData.isActivated = false;
      }
      inputMethods.dispatchEvent("blur", { value }, evnt);
      if (!$xeSelect && !$xeTreeSelect) {
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        datePickerOpenEvent(evnt);
      }
      triggerEvent3(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const hidePanel = () => {
      return new Promise((resolve) => {
        reactData.visiblePanel = false;
        internalData.hpTimeout = window.setTimeout(() => {
          reactData.isAniVisible = false;
          resolve();
        }, 350);
      });
    };
    const clearValueEvent = (evnt, value) => {
      const { type } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        hidePanel();
      }
      if (isNumType || ["text", "search", "password"].indexOf(type) > -1) {
        focus();
      }
      handleChange("", evnt);
      inputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        inputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const dateParseValue = (value) => {
      const { type } = props;
      const dateLabelFormat = computeDateLabelFormat.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      let dValue = null;
      let dLabel = "";
      if (value) {
        dValue = parseDate2(value, dateValueFormat);
      }
      if (import_xe_utils94.default.isValidDate(dValue)) {
        dLabel = import_xe_utils94.default.toDateString(dValue, dateLabelFormat, { firstDay: firstDayOfWeek });
        if (dateLabelFormat && type === "week") {
          const firstWeekDate = import_xe_utils94.default.getWhatWeek(dValue, 0, firstDayOfWeek, firstDayOfWeek);
          if (firstWeekDate.getFullYear() < dValue.getFullYear()) {
            const yyIndex = dateLabelFormat.indexOf("yyyy");
            if (yyIndex > -1) {
              const yyNum = Number(dLabel.substring(yyIndex, yyIndex + 4));
              if (yyNum && !isNaN(yyNum)) {
                dLabel = dLabel.replace(`${yyNum}`, `${yyNum - 1}`);
              }
            }
          }
        }
      } else {
        dValue = null;
      }
      reactData.datePanelValue = dValue;
      reactData.datePanelLabel = dLabel;
    };
    const changeValue = () => {
      const isDatePickerType = computeIsDatePickerType.value;
      const { inputValue } = reactData;
      if (isDatePickerType) {
        dateParseValue(inputValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    };
    const initValue = () => {
      const { type } = props;
      const { inputValue } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const digitsValue = computeDigitsValue.value;
      if (isDatePickerType) {
        changeValue();
      } else if (type === "float") {
        if (inputValue) {
          const validValue = toFloatValueFixed(inputValue, digitsValue);
          if (inputValue !== validValue) {
            handleChange(validValue, { type: "init" });
          }
        }
      }
    };
    const validMaxNum = (num) => {
      return props.max === null || import_xe_utils94.default.toNumber(num) <= import_xe_utils94.default.toNumber(props.max);
    };
    const validMinNum = (num) => {
      return props.min === null || import_xe_utils94.default.toNumber(num) >= import_xe_utils94.default.toNumber(props.min);
    };
    const dateRevert = () => {
      reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
    };
    const dateCheckMonth = (date) => {
      const month = import_xe_utils94.default.getWhatMonth(date, 0, "first");
      if (!import_xe_utils94.default.isEqual(month, reactData.selectMonth)) {
        reactData.selectMonth = month;
      }
    };
    const dateChange = (date) => {
      const { modelValue, multiple } = props;
      const { datetimePanelValue } = reactData;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValueFormat = computeDateValueFormat.value;
      const firstDayOfWeek = computeFirstDayOfWeek.value;
      if (props.type === "week") {
        const sWeek = import_xe_utils94.default.toNumber(props.selectDay);
        date = import_xe_utils94.default.getWhatWeek(date, 0, sWeek, firstDayOfWeek);
      } else if (isDateTimeType) {
        date.setHours(datetimePanelValue.getHours());
        date.setMinutes(datetimePanelValue.getMinutes());
        date.setSeconds(datetimePanelValue.getSeconds());
      }
      const inpVal = import_xe_utils94.default.toDateString(date, dateValueFormat, { firstDay: firstDayOfWeek });
      dateCheckMonth(date);
      if (multiple) {
        const dateMultipleValue = computeDateMultipleValue.value;
        if (isDateTimeType) {
          const dateListValue = [...computeDateListValue.value];
          const datetimeRest = [];
          const eqIndex = import_xe_utils94.default.findIndexOf(dateListValue, (val) => import_xe_utils94.default.isDateSame(date, val, "yyyyMMdd"));
          if (eqIndex === -1) {
            dateListValue.push(date);
          } else {
            dateListValue.splice(eqIndex, 1);
          }
          dateListValue.forEach((item) => {
            if (item) {
              item.setHours(datetimePanelValue.getHours());
              item.setMinutes(datetimePanelValue.getMinutes());
              item.setSeconds(datetimePanelValue.getSeconds());
              datetimeRest.push(item);
            }
          });
          handleChange(datetimeRest.map((date2) => import_xe_utils94.default.toDateString(date2, dateValueFormat)).join(","), { type: "update" });
        } else {
          if (dateMultipleValue.some((val) => import_xe_utils94.default.isEqual(val, inpVal))) {
            handleChange(dateMultipleValue.filter((val) => !import_xe_utils94.default.isEqual(val, inpVal)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.concat([inpVal]).join(","), { type: "update" });
          }
        }
      } else {
        if (!import_xe_utils94.default.isEqual(modelValue, inpVal)) {
          handleChange(inpVal, { type: "update" });
        }
      }
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue, datetimePanelValue } = reactData;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const dateLabelFormat = computeDateLabelFormat.value;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (isNumType) {
          if (inputValue) {
            let inpNumVal = type === "integer" ? import_xe_utils94.default.toInteger(handleNumber(inputValue)) : import_xe_utils94.default.toNumber(handleNumber(inputValue));
            if (!validMinNum(inpNumVal)) {
              inpNumVal = min;
            } else if (!validMaxNum(inpNumVal)) {
              inpNumVal = max;
            }
            if (exponential) {
              const inpStringVal = import_xe_utils94.default.toValueString(inputValue).toLowerCase();
              if (inpStringVal === import_xe_utils94.default.toNumber(inpNumVal).toExponential()) {
                inpNumVal = inpStringVal;
              }
            }
            handleChange(getNumberValue(inpNumVal), { type: "check" });
          }
        } else if (isDatePickerType) {
          if (inputValue) {
            let inpDateVal = parseDate2(inputValue, dateLabelFormat);
            if (import_xe_utils94.default.isValidDate(inpDateVal)) {
              if (type === "time") {
                inpDateVal = import_xe_utils94.default.toDateString(inpDateVal, dateLabelFormat);
                if (inputValue !== inpDateVal) {
                  handleChange(inpDateVal, { type: "check" });
                }
                reactData.inputValue = inpDateVal;
              } else {
                let isChange = false;
                const firstDayOfWeek = computeFirstDayOfWeek.value;
                if (type === "datetime") {
                  const dateValue = computeDateValue.value;
                  if (inputValue !== import_xe_utils94.default.toDateString(dateValue, dateLabelFormat) || inputValue !== import_xe_utils94.default.toDateString(inpDateVal, dateLabelFormat)) {
                    isChange = true;
                    datetimePanelValue.setHours(inpDateVal.getHours());
                    datetimePanelValue.setMinutes(inpDateVal.getMinutes());
                    datetimePanelValue.setSeconds(inpDateVal.getSeconds());
                  }
                } else {
                  isChange = true;
                }
                reactData.inputValue = import_xe_utils94.default.toDateString(inpDateVal, dateLabelFormat, { firstDay: firstDayOfWeek });
                if (isChange) {
                  dateChange(inpDateVal);
                }
              }
            } else {
              dateRevert();
            }
          } else {
            handleChange("", { type: "check" });
          }
        }
      }
    };
    const passwordToggleEvent = (evnt) => {
      const { showPwd } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!isDisabled && !isReadonly) {
        reactData.showPwd = !showPwd;
      }
      inputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const searchEvent = (evnt) => {
      inputMethods.dispatchEvent("search-click", {}, evnt);
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils94.default.toInteger(handleNumber(inputValue)) : import_xe_utils94.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils94.default.add(numValue, stepValue) : import_xe_utils94.default.subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberNextEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      inputMethods.dispatchEvent("next-number", { value: reactData.inputValue }, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      internalData.dnTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      numberStopDown();
      if (!isDisabled && !isReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      inputMethods.dispatchEvent("prev-number", { value: reactData.inputValue }, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { exponential, controls } = props;
      const isNumType = computeIsNumType.value;
      if (isNumType) {
        const isCtrlKey = evnt.ctrlKey;
        const isShiftKey = evnt.shiftKey;
        const isAltKey = evnt.altKey;
        const keyCode = evnt.keyCode;
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (!isCtrlKey && !isShiftKey && !isAltKey && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
          evnt.preventDefault();
        }
        if (isEsc) {
          afterCheckValue();
        } else if (isUpArrow || isDwArrow) {
          if (controls) {
            numberKeydownEvent(evnt);
          }
        }
      }
      triggerEvent3(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const numberStopDown = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
      }
    };
    const numberDownPrevEvent = (evnt) => {
      internalData.dnTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass2(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        internalData.dnTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      const isNumType = computeIsNumType.value;
      if (isNumType && props.controls) {
        if (reactData.isActivated) {
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
          evnt.preventDefault();
        }
      }
      triggerEvent3(evnt);
    };
    const dateMonthHandle = (date, offsetMonth) => {
      reactData.selectMonth = import_xe_utils94.default.getWhatMonth(date, offsetMonth, "first");
    };
    const dateNowHandle = () => {
      const currentDate = import_xe_utils94.default.getWhatDay(Date.now(), 0, "first");
      reactData.currentDate = currentDate;
      dateMonthHandle(currentDate, 0);
    };
    const dateToggleTypeEvent = () => {
      let { datePanelType } = reactData;
      if (datePanelType === "month" || datePanelType === "quarter") {
        datePanelType = "year";
      } else {
        datePanelType = "month";
      }
      reactData.datePanelType = datePanelType;
    };
    const datePrevEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      if (!isDisabledPrevDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -yearSize, "first");
          } else {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, -1, "first");
          } else {
            viewDate = import_xe_utils94.default.getWhatMonth(selectMonth, -1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent("date-prev", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const dateTodayMonthEvent = (evnt) => {
      dateNowHandle();
      if (!props.multiple) {
        dateChange(reactData.currentDate);
        hidePanel();
      }
      inputMethods.dispatchEvent("date-today", { type: props.type }, evnt);
    };
    const dateNextEvent = (evnt) => {
      const { type } = props;
      const { datePanelType, selectMonth, inputValue } = reactData;
      const { yearSize } = internalData;
      const value = inputValue;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      if (!isDisabledNextDateBtn) {
        let viewDate;
        if (type === "year") {
          viewDate = import_xe_utils94.default.getWhatYear(selectMonth, yearSize, "first");
        } else if (type === "month" || type === "quarter") {
          if (datePanelType === "year") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, yearSize, "first");
          } else {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, 1, "first");
          }
        } else {
          if (datePanelType === "year") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, yearSize, "first");
          } else if (datePanelType === "month") {
            viewDate = import_xe_utils94.default.getWhatYear(selectMonth, 1, "first");
          } else {
            viewDate = import_xe_utils94.default.getWhatMonth(selectMonth, 1, "first");
          }
        }
        reactData.selectMonth = viewDate;
        inputMethods.dispatchEvent("date-next", { viewType: datePanelType, viewDate, value, type }, evnt);
      }
    };
    const isDateDisabled = (item) => {
      const { disabledMethod } = props;
      const { datePanelType } = reactData;
      const dateStartTime = computeDateStartTime.value;
      const dateEndTime = computeDateEndTime.value;
      const { date } = item;
      if (dateStartTime && dateStartTime.getTime() > date.getTime()) {
        return true;
      }
      if (dateEndTime && dateEndTime.getTime() < date.getTime()) {
        return true;
      }
      if (disabledMethod) {
        return disabledMethod({ type: datePanelType, viewType: datePanelType, date, $input: $xeInput });
      }
      return false;
    };
    const dateSelectItem = (date) => {
      const { type, multiple } = props;
      const { datePanelType } = reactData;
      if (type === "month") {
        if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else if (type === "year") {
        dateChange(date);
        if (!multiple) {
          hidePanel();
        }
      } else if (type === "quarter") {
        if (datePanelType === "year") {
          reactData.datePanelType = "quarter";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (!multiple) {
            hidePanel();
          }
        }
      } else {
        if (datePanelType === "month") {
          reactData.datePanelType = type === "week" ? type : "day";
          dateCheckMonth(date);
        } else if (datePanelType === "year") {
          reactData.datePanelType = "month";
          dateCheckMonth(date);
        } else {
          dateChange(date);
          if (type === "datetime") {
          } else {
            if (!multiple) {
              hidePanel();
            }
          }
        }
      }
    };
    const dateSelectEvent = (item) => {
      if (!isDateDisabled(item)) {
        dateSelectItem(item.date);
      }
    };
    const dateMoveDay = (offsetDay) => {
      if (!isDateDisabled({ date: offsetDay })) {
        const dayList = computeDayList.value;
        if (!dayList.some((item) => import_xe_utils94.default.isDateSame(item.date, offsetDay, "yyyyMMdd"))) {
          dateCheckMonth(offsetDay);
        }
        dateParseValue(offsetDay);
      }
    };
    const dateMoveYear = (offsetYear) => {
      if (!isDateDisabled({ date: offsetYear })) {
        const yearList = computeYearList.value;
        if (!yearList.some((item) => import_xe_utils94.default.isDateSame(item.date, offsetYear, "yyyy"))) {
          dateCheckMonth(offsetYear);
        }
        dateParseValue(offsetYear);
      }
    };
    const dateMoveQuarter = (offsetQuarter) => {
      if (!isDateDisabled({ date: offsetQuarter })) {
        const quarterList = computeQuarterList.value;
        if (!quarterList.some((item) => import_xe_utils94.default.isDateSame(item.date, offsetQuarter, "yyyyq"))) {
          dateCheckMonth(offsetQuarter);
        }
        dateParseValue(offsetQuarter);
      }
    };
    const dateMoveMonth = (offsetMonth) => {
      if (!isDateDisabled({ date: offsetMonth })) {
        const monthList = computeMonthList.value;
        if (!monthList.some((item) => import_xe_utils94.default.isDateSame(item.date, offsetMonth, "yyyyMM"))) {
          dateCheckMonth(offsetMonth);
        }
        dateParseValue(offsetMonth);
      }
    };
    const dateMouseenterEvent = (item) => {
      if (!isDateDisabled(item)) {
        const { datePanelType } = reactData;
        if (datePanelType === "month") {
          dateMoveMonth(item.date);
        } else if (datePanelType === "quarter") {
          dateMoveQuarter(item.date);
        } else if (datePanelType === "year") {
          dateMoveYear(item.date);
        } else {
          dateMoveDay(item.date);
        }
      }
    };
    const updateTimePos = (liElem) => {
      if (liElem) {
        const height = liElem.offsetHeight;
        const ulElem = liElem.parentNode;
        ulElem.scrollTop = liElem.offsetTop - height * 4;
      }
    };
    const dateTimeChangeEvent = (evnt) => {
      reactData.datetimePanelValue = new Date(reactData.datetimePanelValue.getTime());
      updateTimePos(evnt.currentTarget);
    };
    const dateHourEvent = (evnt, item) => {
      reactData.datetimePanelValue.setHours(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateConfirmEvent = () => {
      const { multiple } = props;
      const { datetimePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const isDateTimeType = computeIsDateTimeType.value;
      if (isDateTimeType) {
        const dateValueFormat = computeDateValueFormat.value;
        if (multiple) {
          const dateMultipleValue = computeDateMultipleValue.value;
          if (isDateTimeType) {
            const dateListValue = [...computeDateListValue.value];
            const datetimeRest = [];
            dateListValue.forEach((item) => {
              if (item) {
                item.setHours(datetimePanelValue.getHours());
                item.setMinutes(datetimePanelValue.getMinutes());
                item.setSeconds(datetimePanelValue.getSeconds());
                datetimeRest.push(item);
              }
            });
            handleChange(datetimeRest.map((date) => import_xe_utils94.default.toDateString(date, dateValueFormat)).join(","), { type: "update" });
          } else {
            handleChange(dateMultipleValue.join(","), { type: "update" });
          }
        } else {
          dateChange(dateValue || reactData.currentDate);
        }
      }
      hidePanel();
    };
    const dateMinuteEvent = (evnt, item) => {
      reactData.datetimePanelValue.setMinutes(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateSecondEvent = (evnt, item) => {
      reactData.datetimePanelValue.setSeconds(item.value);
      dateTimeChangeEvent(evnt);
    };
    const dateOffsetEvent = (evnt) => {
      const { isActivated, datePanelValue, datePanelType } = reactData;
      if (isActivated) {
        evnt.preventDefault();
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        if (datePanelType === "year") {
          let offsetYear = import_xe_utils94.default.getWhatYear(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetYear = import_xe_utils94.default.getWhatYear(offsetYear, -1);
          } else if (isUpArrow) {
            offsetYear = import_xe_utils94.default.getWhatYear(offsetYear, -4);
          } else if (isRightArrow) {
            offsetYear = import_xe_utils94.default.getWhatYear(offsetYear, 1);
          } else if (isDwArrow) {
            offsetYear = import_xe_utils94.default.getWhatYear(offsetYear, 4);
          }
          dateMoveYear(offsetYear);
        } else if (datePanelType === "quarter") {
          let offsetQuarter = import_xe_utils94.default.getWhatQuarter(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetQuarter = import_xe_utils94.default.getWhatQuarter(offsetQuarter, -1);
          } else if (isUpArrow) {
            offsetQuarter = import_xe_utils94.default.getWhatQuarter(offsetQuarter, -2);
          } else if (isRightArrow) {
            offsetQuarter = import_xe_utils94.default.getWhatQuarter(offsetQuarter, 1);
          } else if (isDwArrow) {
            offsetQuarter = import_xe_utils94.default.getWhatQuarter(offsetQuarter, 2);
          }
          dateMoveQuarter(offsetQuarter);
        } else if (datePanelType === "month") {
          let offsetMonth = import_xe_utils94.default.getWhatMonth(datePanelValue || Date.now(), 0, "first");
          if (isLeftArrow) {
            offsetMonth = import_xe_utils94.default.getWhatMonth(offsetMonth, -1);
          } else if (isUpArrow) {
            offsetMonth = import_xe_utils94.default.getWhatMonth(offsetMonth, -4);
          } else if (isRightArrow) {
            offsetMonth = import_xe_utils94.default.getWhatMonth(offsetMonth, 1);
          } else if (isDwArrow) {
            offsetMonth = import_xe_utils94.default.getWhatMonth(offsetMonth, 4);
          }
          dateMoveMonth(offsetMonth);
        } else {
          let offsetDay = datePanelValue || import_xe_utils94.default.getWhatDay(Date.now(), 0, "first");
          const firstDayOfWeek = computeFirstDayOfWeek.value;
          if (isLeftArrow) {
            offsetDay = import_xe_utils94.default.getWhatDay(offsetDay, -1);
          } else if (isUpArrow) {
            offsetDay = import_xe_utils94.default.getWhatWeek(offsetDay, -1, firstDayOfWeek);
          } else if (isRightArrow) {
            offsetDay = import_xe_utils94.default.getWhatDay(offsetDay, 1);
          } else if (isDwArrow) {
            offsetDay = import_xe_utils94.default.getWhatWeek(offsetDay, 1, firstDayOfWeek);
          }
          dateMoveDay(offsetDay);
        }
      }
    };
    const datePgOffsetEvent = (evnt) => {
      const { isActivated } = reactData;
      if (isActivated) {
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        evnt.preventDefault();
        if (isPgUp) {
          datePrevEvent(evnt);
        } else {
          dateNextEvent(evnt);
        }
      }
    };
    const dateOpenPanel = () => {
      const { type } = props;
      const isDateTimeType = computeIsDateTimeType.value;
      const dateValue = computeDateValue.value;
      if (["year", "quarter", "month", "week"].indexOf(type) > -1) {
        reactData.datePanelType = type;
      } else {
        reactData.datePanelType = "day";
      }
      reactData.currentDate = import_xe_utils94.default.getWhatDay(Date.now(), 0, "first");
      if (dateValue) {
        dateMonthHandle(dateValue, 0);
        dateParseValue(dateValue);
      } else {
        dateNowHandle();
      }
      if (isDateTimeType) {
        reactData.datetimePanelValue = reactData.datePanelValue || import_xe_utils94.default.getWhatDay(Date.now(), 0, "first");
        nextTick(() => {
          const timeBodyElem = refInputTimeBody.value;
          import_xe_utils94.default.arrayEach(timeBodyElem.querySelectorAll("li.is--selected"), (elem) => {
            updateTimePos(elem);
          });
        });
      }
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const targetElem = refInputTarget.value;
        const panelElem = refInputPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (targetElem && panelElem) {
          const targetHeight = targetElem.offsetHeight;
          const targetWidth = targetElem.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(targetElem);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              panelStyle.top = `${targetHeight}px`;
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.top = "";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showPanel = () => {
      const { visiblePanel } = reactData;
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled && !visiblePanel) {
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (isDatePickerType) {
          dateOpenPanel();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        return updatePlacement();
      }
      return nextTick();
    };
    const datePickerOpenEvent = (evnt) => {
      const isReadonly = computeIsReadonly.value;
      if (!isReadonly) {
        evnt.preventDefault();
        showPanel();
      }
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel, isActivated } = reactData;
      const isDatePickerType = computeIsDatePickerType.value;
      const el2 = refElem.value;
      const panelWrapperElem = refPanelWrapper.value;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelWrapperElem).flag;
        if (!reactData.isActivated) {
          if (isDatePickerType) {
            if (visiblePanel) {
              hidePanel();
              afterCheckValue();
            }
          } else {
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      const isDatePickerType = computeIsDatePickerType.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isPgUp = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_UP);
        const isPgDn = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.PAGE_DOWN);
        const operArrow = isLeftArrow || isUpArrow || isRightArrow || isDwArrow;
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        } else if (operArrow) {
          if (isDatePickerType) {
            if (isActivated) {
              if (visiblePanel) {
                dateOffsetEvent(evnt);
              } else if (isUpArrow || isDwArrow) {
                datePickerOpenEvent(evnt);
              }
            }
          }
        } else if (isEnter) {
          if (isDatePickerType) {
            if (visiblePanel) {
              if (reactData.datePanelValue) {
                dateSelectItem(reactData.datePanelValue);
              } else {
                hidePanel();
              }
            } else if (isActivated) {
              datePickerOpenEvent(evnt);
            }
          }
        } else if (isPgUp || isPgDn) {
          if (isDatePickerType) {
            if (isActivated) {
              datePgOffsetEvent(evnt);
            }
          }
        }
        if (isTab || isEsc) {
          if (visiblePanel) {
            hidePanel();
          }
        } else if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelWrapperElem = refPanelWrapper.value;
          if (getEventTargetNode2(evnt, panelWrapperElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            afterCheckValue();
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated, visiblePanel } = reactData;
      if (visiblePanel) {
        hidePanel();
        afterCheckValue();
      } else if (isActivated) {
        afterCheckValue();
      }
    };
    const renderDateLabel = (item, label) => {
      const { festivalMethod } = props;
      if (festivalMethod) {
        const { datePanelType } = reactData;
        const festivalRest = festivalMethod({ type: datePanelType, viewType: datePanelType, date: item.date, $input: $xeInput });
        const festivalItem = festivalRest ? import_xe_utils94.default.isString(festivalRest) ? { label: festivalRest } : festivalRest : {};
        const extraItem = festivalItem.extra ? import_xe_utils94.default.isString(festivalItem.extra) ? { label: festivalItem.extra } : festivalItem.extra : null;
        const labels = [
          h("span", {
            class: ["vxe-input--date-label", {
              "is-notice": festivalItem.notice
            }]
          }, extraItem && extraItem.label ? [
            h("span", `${label || ""}`),
            h("span", {
              class: ["vxe-input--date-label--extra", extraItem.important ? "is-important" : "", extraItem.className],
              style: extraItem.style
            }, import_xe_utils94.default.toValueString(extraItem.label))
          ] : [`${label || ""}`])
        ];
        const festivalLabel = festivalItem.label;
        if (festivalLabel) {
          const festivalLabels = import_xe_utils94.default.toValueString(festivalLabel).split(",");
          labels.push(h("span", {
            class: ["vxe-input--date-festival", festivalItem.important ? "is-important" : "", festivalItem.className],
            style: festivalItem.style
          }, [
            festivalLabels.length > 1 ? h("span", {
              class: ["vxe-input--date-festival--overlap", `overlap--${festivalLabels.length}`]
            }, festivalLabels.map((label2) => h("span", label2.substring(0, 3)))) : h("span", {
              class: "vxe-input--date-festival--label"
            }, festivalLabels[0].substring(0, 3))
          ]));
        }
        return labels;
      }
      return [`${label || ""}`];
    };
    const renderDateDayTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const dateHeaders = computeDateHeaders.value;
      const dayDatas = computeDayDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", dateHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", dayDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateWeekTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const weekHeaders = computeWeekHeaders.value;
      const weekDates = computeWeekDates.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMMdd";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("thead", [
            h("tr", weekHeaders.map((item) => {
              return h("th", item.label);
            }))
          ]),
          h("tbody", weekDates.map((rows) => {
            const isSelected = multiple ? rows.some((item) => dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat))) : rows.some((item) => import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat));
            const isHover = rows.some((item) => import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat));
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": isSelected,
                  "is--hover": isHover
                },
                // event
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.label));
            }));
          }))
        ])
      ];
    };
    const renderDateMonthTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const monthDatas = computeMonthDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyMM";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", monthDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.months.m${item.month}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateQuarterTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const quarterDatas = computeQuarterDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyyq";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", quarterDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, getI18n(`vxe.input.date.quarters.q${item.quarter}`)));
            }));
          }))
        ])
      ];
    };
    const renderDateYearTable = () => {
      const { multiple } = props;
      const { datePanelType, datePanelValue } = reactData;
      const dateValue = computeDateValue.value;
      const yearDatas = computeYearDatas.value;
      const dateListValue = computeDateListValue.value;
      const matchFormat = "yyyy";
      return [
        h("table", {
          class: `vxe-input--date-${datePanelType}-view`,
          cellspacing: 0,
          cellpadding: 0,
          border: 0
        }, [
          h("tbody", yearDatas.map((rows) => {
            return h("tr", rows.map((item) => {
              return h("td", {
                class: {
                  "is--prev": item.isPrev,
                  "is--current": item.isCurrent,
                  "is--now": item.isNow,
                  "is--next": item.isNext,
                  "is--disabled": isDateDisabled(item),
                  "is--selected": multiple ? dateListValue.some((val) => import_xe_utils94.default.isDateSame(val, item.date, matchFormat)) : import_xe_utils94.default.isDateSame(dateValue, item.date, matchFormat),
                  "is--hover": import_xe_utils94.default.isDateSame(datePanelValue, item.date, matchFormat)
                },
                onClick: () => dateSelectEvent(item),
                onMouseenter: () => dateMouseenterEvent(item)
              }, renderDateLabel(item, item.year));
            }));
          }))
        ])
      ];
    };
    const renderDateTable = () => {
      const { datePanelType } = reactData;
      switch (datePanelType) {
        case "week":
          return renderDateWeekTable();
        case "month":
          return renderDateMonthTable();
        case "quarter":
          return renderDateQuarterTable();
        case "year":
          return renderDateYearTable();
      }
      return renderDateDayTable();
    };
    const renderDatePanel = () => {
      const { multiple } = props;
      const { datePanelType } = reactData;
      const isDisabledPrevDateBtn = computeIsDisabledPrevDateBtn.value;
      const isDisabledNextDateBtn = computeIsDisabledNextDateBtn.value;
      const selectDatePanelLabel = computeSelectDatePanelLabel.value;
      return [
        h("div", {
          class: "vxe-input--date-picker-header"
        }, [
          h("div", {
            class: "vxe-input--date-picker-type-wrapper"
          }, [
            datePanelType === "year" ? h("span", {
              class: "vxe-input--date-picker-label"
            }, selectDatePanelLabel) : h("span", {
              class: "vxe-input--date-picker-btn",
              onClick: dateToggleTypeEvent
            }, selectDatePanelLabel)
          ]),
          h("div", {
            class: "vxe-input--date-picker-btn-wrapper"
          }, [
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-prev-btn", {
                "is--disabled": isDisabledPrevDateBtn
              }],
              onClick: datePrevEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-left"
              })
            ]),
            h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-current-btn",
              onClick: dateTodayMonthEvent
            }, [
              h("i", {
                class: "vxe-icon-dot"
              })
            ]),
            h("span", {
              class: ["vxe-input--date-picker-btn vxe-input--date-picker-next-btn", {
                "is--disabled": isDisabledNextDateBtn
              }],
              onClick: dateNextEvent
            }, [
              h("i", {
                class: "vxe-icon-caret-right"
              })
            ]),
            multiple && computeSupportMultiples.value ? h("span", {
              class: "vxe-input--date-picker-btn vxe-input--date-picker-confirm-btn"
            }, [
              h("button", {
                class: "vxe-input--date-picker-confirm",
                type: "button",
                onClick: dateConfirmEvent
              }, getI18n("vxe.button.confirm"))
            ]) : null
          ])
        ]),
        h("div", {
          class: "vxe-input--date-picker-body"
        }, renderDateTable())
      ];
    };
    const renderTimePanel = () => {
      const { datetimePanelValue } = reactData;
      const dateTimeLabel = computeDateTimeLabel.value;
      const hourList = computeHourList.value;
      const hasTimeMinute = computeHasTimeMinute.value;
      const minuteList = computeMinuteList.value;
      const hasTimeSecond = computeHasTimeSecond.value;
      const secondList = computeSecondList.value;
      return [
        h("div", {
          class: "vxe-input--time-picker-header"
        }, [
          hasTimeMinute ? h("span", {
            class: "vxe-input--time-picker-title"
          }, dateTimeLabel) : createCommentVNode(),
          h("div", {
            class: "vxe-input--time-picker-btn"
          }, [
            h("button", {
              class: "vxe-input--time-picker-confirm",
              type: "button",
              onClick: dateConfirmEvent
            }, getI18n("vxe.button.confirm"))
          ])
        ]),
        h("div", {
          ref: refInputTimeBody,
          class: "vxe-input--time-picker-body"
        }, [
          h("ul", {
            class: "vxe-input--time-picker-hour-list"
          }, hourList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getHours() === item.value
              },
              onClick: (evnt) => dateHourEvent(evnt, item)
            }, item.label);
          })),
          hasTimeMinute ? h("ul", {
            class: "vxe-input--time-picker-minute-list"
          }, minuteList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getMinutes() === item.value
              },
              onClick: (evnt) => dateMinuteEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode(),
          hasTimeMinute && hasTimeSecond ? h("ul", {
            class: "vxe-input--time-picker-second-list"
          }, secondList.map((item, index2) => {
            return h("li", {
              key: index2,
              class: {
                "is--selected": datetimePanelValue && datetimePanelValue.getSeconds() === item.value
              },
              onClick: (evnt) => dateSecondEvent(evnt, item)
            }, item.label);
          })) : createCommentVNode()
        ])
      ];
    };
    const renderPanel = () => {
      const { type } = props;
      const { initialized, isAniVisible, visiblePanel, panelPlacement, panelStyle } = reactData;
      const vSize = computeSize.value;
      const btnTransfer = computeBtnTransfer.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const renders = [];
      if (isDatePickerType) {
        if (type === "datetime") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-input--panel-layout-wrapper"
          }, [
            h("div", {
              class: "vxe-input--panel-left-wrapper"
            }, renderDatePanel()),
            h("div", {
              class: "vxe-input--panel-right-wrapper"
            }, renderTimePanel())
          ]));
        } else if (type === "time") {
          renders.push(h("div", {
            key: type,
            ref: refPanelWrapper,
            class: "vxe-input--panel-wrapper"
          }, renderTimePanel()));
        } else {
          renders.push(h("div", {
            key: type || "default",
            ref: refPanelWrapper,
            class: "vxe-input--panel-wrapper"
          }, renderDatePanel()));
        }
        return h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refInputPanel,
            class: ["vxe-table--ignore-clear vxe-input--panel", `type--${type}`, {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, visiblePanel || isAniVisible ? renders : [])
        ]);
      }
      return createCommentVNode();
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("div", {
        class: "vxe-input--control-icon"
      }, [
        h("div", {
          class: "vxe-input--number-icon"
        }, [
          h("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": isDisabledAddNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_PREV_NUM
            })
          ]),
          h("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": isDisabledSubtractNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_NEXT_NUM
            })
          ])
        ])
      ]);
    };
    const renderDatePickerIcon = () => {
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: datePickerOpenEvent
      }, [
        h("i", {
          class: ["vxe-input--date-picker-icon", getIcon().DATE_PICKER_DATE]
        })
      ]);
    };
    const renderSearchIcon = () => {
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: searchEvent
      }, [
        h("i", {
          class: ["vxe-input--search-icon", getIcon().INPUT_SEARCH]
        })
      ]);
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "vxe-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      const isClearable = computeIsClearable.value;
      const isExtraBtn = isPawdType || isNumType || isDatePickerType || isSearchType;
      return isClearable || suffixSlot || suffixIcon || isExtraBtn ? h("div", {
        class: ["vxe-input--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils94.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        isExtraBtn ? renderExtraSuffixIcon() : createCommentVNode(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]) : null;
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      const isNumType = computeIsNumType.value;
      const isDatePickerType = computeIsDatePickerType.value;
      const isPawdType = computeIsPawdType.value;
      const isSearchType = computeIsSearchType.value;
      if (isPawdType) {
        return renderPasswordIcon();
      }
      if (isNumType) {
        if (controls) {
          return renderNumberIcon();
        }
      }
      if (isDatePickerType) {
        return renderDatePickerIcon();
      }
      if (isSearchType) {
        return renderSearchIcon();
      }
      return createCommentVNode();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $input: $xeInput }, params));
    };
    inputMethods = {
      dispatchEvent: dispatchEvent2,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      },
      showPanel,
      hidePanel,
      updatePlacement
    };
    Object.assign($xeInput, inputMethods);
    const renderVN = () => {
      const { className, controls, type, align, showWordCount, countMethod, name, autoComplete, autocomplete } = props;
      const { inputValue, visiblePanel, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-input--readonly", `type--${type}`, className]
        }, inputValue);
      }
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const isWordCount = showWordCount && ["text", "search"].includes(type);
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--visible": visiblePanel,
          "is--count": isWordCount,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils94.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            maxlength: inpMaxLength,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode(),
        // 下拉面板
        renderPanel(),
        // 字数统计
        isWordCount ? h("span", {
          class: ["vxe-input--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ""}`) : createCommentVNode()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      changeValue();
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue,
        datetimePanelValue: null,
        datePanelValue: null,
        datePanelLabel: "",
        datePanelType: "day",
        selectMonth: null,
        currentDate: null
      });
      initValue();
    });
    watch(computeDateLabelFormat, () => {
      const isDatePickerType = computeIsDatePickerType.value;
      if (isDatePickerType) {
        dateParseValue(reactData.datePanelValue);
        reactData.inputValue = props.multiple ? computeDateMultipleLabel.value : reactData.datePanelLabel;
      }
    });
    onMounted(() => {
      globalEvents.on($xeInput, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeInput, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeInput, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeInput, "blur", handleGlobalBlurEvent);
    });
    onBeforeUnmount(() => {
      numberStopDown();
      afterCheckValue();
      globalEvents.off($xeInput, "mousewheel");
      globalEvents.off($xeInput, "mousedown");
      globalEvents.off($xeInput, "keydown");
      globalEvents.off($xeInput, "blur");
    });
    initValue();
    $xeInput.renderVN = renderVN;
    return $xeInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/radio/src/group.js
var import_xe_utils97 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/radio/src/radio.js
var import_xe_utils95 = __toESM(require_xe_utils());
var radio_default = defineComponent({
  name: "VxeRadio",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    name: String,
    strict: {
      type: Boolean,
      default: () => getConfig().radio.strict
    },
    size: {
      type: String,
      default: () => getConfig().radio.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeRadioGroup = inject("$xeRadioGroup", null);
    const xID = import_xe_utils95.default.uniqueId();
    const reactData = reactive({});
    const $xeRadio = {
      xID,
      props,
      context,
      reactData
    };
    const { computeSize } = useSize(props);
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const { computeIsDisabled: computeIsDisabled2 } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled2.value;
        }
      }
      return disabled;
    });
    const computeName = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : props.name;
    });
    const computeStrict = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { label } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : props.modelValue === label;
    });
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        dispatchEvent2("change", { label }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $radio: $xeRadio }, params));
    };
    const radioMethods = {
      dispatchEvent: dispatchEvent2
    };
    const radioPrivateMethods = {};
    Object.assign($xeRadio, radioMethods, radioPrivateMethods);
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", {
          [`size--${vSize}`]: vSize,
          "is--checked": isChecked,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText2(props.content))
      ]);
    };
    $xeRadio.renderVN = renderVN;
    return $xeRadio;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/radio/src/button.js
var import_xe_utils96 = __toESM(require_xe_utils());
var button_default3 = defineComponent({
  name: "VxeRadioButton",
  props: {
    modelValue: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: null
    },
    title: [String, Number],
    content: [String, Number],
    disabled: {
      type: Boolean,
      default: null
    },
    strict: {
      type: Boolean,
      default: () => getConfig().radioButton.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioButton.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const $xeRadioGroup = inject("$xeRadioGroup", null);
    const xID = import_xe_utils96.default.uniqueId();
    const reactData = reactive({});
    const { computeSize } = useSize(props);
    const $xeRadioButton = {
      xID,
      props,
      context,
      reactData
    };
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeRadioGroup) {
          const { computeIsDisabled: computeIsDisabled2 } = $xeRadioGroup.getComputeMaps();
          return computeIsDisabled2.value;
        }
      }
      return disabled;
    });
    const computeName = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.name : null;
    });
    const computeStrict = computed(() => {
      return $xeRadioGroup ? $xeRadioGroup.props.strict : props.strict;
    });
    const computeChecked = computed(() => {
      const { label } = props;
      return $xeRadioGroup ? $xeRadioGroup.props.modelValue === label : props.modelValue === label;
    });
    const radioButtonMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $radioButton: $xeRadioButton }, params));
      }
    };
    const radioButtonPrivateMethods = {};
    Object.assign($xeRadioButton, radioButtonMethods, radioButtonPrivateMethods);
    const handleValue = (label, evnt) => {
      if ($xeRadioGroup) {
        $xeRadioGroup.handleChecked({ label }, evnt);
      } else {
        emit("update:modelValue", label);
        radioButtonMethods.dispatchEvent("change", { label }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, label);
        }
      }
    };
    const changeEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        handleValue(props.label, evnt);
      }
    };
    const clickEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const isStrict = computeStrict.value;
      if (!isDisabled && !isStrict) {
        if (props.label === ($xeRadioGroup ? $xeRadioGroup.props.modelValue : props.modelValue)) {
          handleValue(null, evnt);
        }
      }
    };
    const renderVN = () => {
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const name = computeName.value;
      const isChecked = computeChecked.value;
      return h("label", {
        class: ["vxe-radio", "vxe-radio-button", {
          [`size--${vSize}`]: vSize,
          "is--disabled": isDisabled
        }],
        title: props.title
      }, [
        h("input", {
          class: "vxe-radio--input",
          type: "radio",
          name,
          checked: isChecked,
          disabled: isDisabled,
          onChange: changeEvent,
          onClick: clickEvent
        }),
        h("span", {
          class: "vxe-radio--label"
        }, slots.default ? slots.default({}) : getFuncText2(props.content))
      ]);
    };
    $xeRadioButton.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/radio/src/group.js
var group_default3 = defineComponent({
  name: "VxeRadioGroup",
  props: {
    modelValue: [String, Number, Boolean],
    disabled: {
      type: Boolean,
      default: null
    },
    type: String,
    options: Array,
    optionProps: Object,
    strict: {
      type: Boolean,
      default: () => getConfig().radioGroup.strict
    },
    size: {
      type: String,
      default: () => getConfig().radioGroup.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils97.default.uniqueId();
    useSize(props);
    const reactData = reactive({});
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaps = {
      computeIsDisabled
    };
    const $xeRadioGroup = {
      xID,
      props,
      context,
      reactData,
      name: import_xe_utils97.default.uniqueId("xe_group_"),
      getComputeMaps: () => computeMaps
    };
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeDisabledField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.disabled || "disabled";
    });
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $radioGroup: $xeRadioGroup }, params));
    };
    const radioGroupMethods = {
      dispatchEvent: dispatchEvent2
    };
    const radioGroupPrivateMethods = {
      handleChecked(params, evnt) {
        const value = params.label;
        emit("update:modelValue", value);
        dispatchEvent2("change", params, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRadioGroup, radioGroupMethods, radioGroupPrivateMethods);
    const renderVN = () => {
      const { options, type } = props;
      const defaultSlot = slots.default;
      const valueField = computeValueField.value;
      const labelField = computeLabelField.value;
      const disabledField = computeDisabledField.value;
      const btnComp = type === "button" ? button_default3 : radio_default;
      return h("div", {
        class: "vxe-radio-group"
      }, defaultSlot ? defaultSlot({}) : options ? options.map((item) => {
        return h(btnComp, {
          label: item[valueField],
          content: item[labelField],
          disabled: item[disabledField]
        });
      }) : []);
    };
    provide("$xeRadioGroup", $xeRadioGroup);
    $xeRadioGroup.renderVN = renderVN;
    return $xeRadioGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/select/src/select.js
var import_xe_utils98 = __toESM(require_xe_utils());
function isOptionVisible(option2) {
  return option2.visible !== false;
}
function getOptUniqueId() {
  return import_xe_utils98.default.uniqueId("opt_");
}
var select_default = defineComponent({
  name: "VxeSelect",
  props: {
    modelValue: [String, Number, Boolean, Array],
    clearable: Boolean,
    placeholder: String,
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    multiCharOverflow: {
      type: [Number, String],
      default: () => getConfig().select.multiCharOverflow
    },
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    optionGroups: Array,
    optionGroupProps: Object,
    optionConfig: Object,
    className: [String, Function],
    popupClassName: [String, Function],
    max: {
      type: [String, Number],
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    filterable: Boolean,
    filterMethod: Function,
    remote: Boolean,
    remoteMethod: Function,
    emptyText: String,
    transfer: {
      type: Boolean,
      default: null
    },
    scrollY: Object,
    // 已废弃，被 option-config.keyField 替换
    optionId: {
      type: String,
      default: () => getConfig().select.optionId
    },
    // 已废弃，被 option-config.useKey 替换
    optionKey: Boolean
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils98.default.uniqueId();
    const refElem = ref();
    const refInput = ref();
    const refInpSearch = ref();
    const refVirtualWrapper = ref();
    const refOptionPanel = ref();
    const refVirtualBody = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      optList: [],
      afterVisibleList: [],
      staticOptions: [],
      reactFlag: 0,
      currentOption: null,
      searchValue: "",
      searchLoading: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      synchData: [],
      fullData: [],
      optGroupKeyMaps: {},
      optFullValMaps: {},
      remoteValMaps: {},
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      },
      lastScrollTime: 0,
      hpTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const $xeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils98.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computePropsOpts = computed(() => {
      return Object.assign({}, props.optionProps);
    });
    const computeGroupPropsOpts = computed(() => {
      return Object.assign({}, props.optionGroupProps);
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeGroupLabelField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.label || "label";
    });
    const computeGroupOptionsField = computed(() => {
      const groupPropsOpts = computeGroupPropsOpts.value;
      return groupPropsOpts.options || "options";
    });
    const computeIsMaximize = computed(() => {
      const { modelValue, multiple, max } = props;
      if (multiple && max) {
        return (import_xe_utils98.default.isArray(modelValue) ? modelValue.length : import_xe_utils98.default.eqNull(modelValue) ? 0 : 1) >= import_xe_utils98.default.toNumber(max);
      }
      return false;
    });
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig().select.scrollY, props.scrollY);
    });
    const computeOptionOpts = computed(() => {
      return Object.assign({}, getConfig().select.optionConfig, props.optionConfig);
    });
    const computeMultiMaxCharNum = computed(() => {
      return import_xe_utils98.default.toNumber(props.multiCharOverflow);
    });
    const computeSelectLabel = computed(() => {
      const { modelValue, remote, multiple } = props;
      const multiMaxCharNum = computeMultiMaxCharNum.value;
      if (import_xe_utils98.default.eqNull(modelValue)) {
        return "";
      }
      const vals = import_xe_utils98.default.isArray(modelValue) ? modelValue : [modelValue];
      if (remote) {
        return vals.map((val) => getRemoteSelectLabel(val)).join(", ");
      }
      return vals.map((val) => {
        const label = getSelectLabel(val);
        if (multiple && multiMaxCharNum > 0 && label.length > multiMaxCharNum) {
          return `${label.substring(0, multiMaxCharNum)}...`;
        }
        return label;
      }).join(", ");
    });
    const callSlot = (slotFunc, params) => {
      if (slotFunc) {
        if (import_xe_utils98.default.isString(slotFunc)) {
          slotFunc = slots[slotFunc] || null;
        }
        if (import_xe_utils98.default.isFunction(slotFunc)) {
          return getSlotVNs2(slotFunc(params));
        }
      }
      return [];
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $select: $xeSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const getOptKey = () => {
      const optionOpts = computeOptionOpts.value;
      return optionOpts.keyField || props.optionId || "_X_OPTION_KEY";
    };
    const getOptId = (option2) => {
      const optid = option2[getOptKey()];
      return optid ? encodeURIComponent(optid) : "";
    };
    const getRemoteSelectLabel = (value) => {
      const { remoteValMaps } = internalData;
      const labelField = computeLabelField.value;
      const remoteItem = remoteValMaps[value];
      const item = remoteItem ? remoteItem.item : null;
      return import_xe_utils98.default.toValueString(item ? item[labelField] : value);
    };
    const getSelectLabel = (value) => {
      const { optFullValMaps } = internalData;
      const labelField = computeLabelField.value;
      const cacheItem = reactData.reactFlag ? optFullValMaps[value] : null;
      return cacheItem ? cacheItem.item[labelField] : import_xe_utils98.default.toValueString(value);
    };
    const cacheItemMap = (datas) => {
      const groupOptionsField = computeGroupOptionsField.value;
      const valueField = computeValueField.value;
      const key = getOptKey();
      const groupKeyMaps = {};
      const fullKeyMaps = {};
      const list = [];
      const handleOptItem = (item) => {
        list.push(item);
        let optid = getOptId(item);
        if (!optid) {
          optid = getOptUniqueId();
          item[key] = optid;
        }
        fullKeyMaps[item[valueField]] = {
          key: optid,
          item,
          _index: -1
        };
      };
      datas.forEach((group) => {
        handleOptItem(group);
        if (group[groupOptionsField]) {
          groupKeyMaps[group[key]] = group;
          group[groupOptionsField].forEach(handleOptItem);
        }
      });
      internalData.fullData = list;
      internalData.optGroupKeyMaps = groupKeyMaps;
      internalData.optFullValMaps = fullKeyMaps;
      reactData.reactFlag++;
      handleOption();
    };
    const handleOption = () => {
      const { filterable, filterMethod } = props;
      const { searchValue } = reactData;
      const { fullData, optFullValMaps } = internalData;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const searchStr = `${searchValue || ""}`.toLowerCase();
      let avList = [];
      if (filterable && filterMethod) {
        avList = fullData.filter((option2) => isOptionVisible(option2) && filterMethod({ group: null, option: option2, searchValue: searchStr }));
      } else if (filterable) {
        avList = fullData.filter((option2) => isOptionVisible(option2) && (!searchStr || `${option2[labelField]}`.toLowerCase().indexOf(searchStr) > -1));
      } else {
        avList = fullData.filter(isOptionVisible);
      }
      avList.forEach((item, index2) => {
        const cacheItem = optFullValMaps[item[valueField]];
        if (cacheItem) {
          cacheItem._index = index2;
        }
      });
      reactData.afterVisibleList = avList;
      return nextTick();
    };
    const setCurrentOption = (option2) => {
      if (option2) {
        reactData.currentOption = option2;
      }
    };
    const updateZIndex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el2) {
          const targetHeight = el2.offsetHeight;
          const targetWidth = el2.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(el2);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2, filterable } = props;
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        if (filterable) {
          handleOption();
          updateYData();
        }
        setTimeout(() => {
          reactData.visiblePanel = true;
          handleFocusSearch();
          recalculate().then(() => refreshScroll());
        }, 10);
        setTimeout(() => {
          recalculate().then(() => refreshScroll());
        }, 100);
        updateZIndex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.searchValue = "";
      reactData.searchLoading = false;
      reactData.visiblePanel = false;
      internalData.hpTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        dispatchEvent2("change", { value: selectValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      internalData.remoteValMaps = {};
      changeEvent(evnt, selectValue);
      dispatchEvent2("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const changeOptionEvent = (evnt, option2) => {
      const { modelValue, multiple } = props;
      const { remoteValMaps } = internalData;
      const valueField = computeValueField.value;
      const selectValue = option2[valueField];
      const remoteItem = remoteValMaps[selectValue];
      if (remoteItem) {
        remoteItem.item = option2;
      } else {
        remoteValMaps[selectValue] = {
          key: getOptId(option2),
          item: option2,
          _index: -1
        };
      }
      if (multiple) {
        let multipleValue = [];
        const selectVals = import_xe_utils98.default.eqNull(modelValue) ? [] : import_xe_utils98.default.isArray(modelValue) ? modelValue : [modelValue];
        const index2 = import_xe_utils98.default.findIndexOf(selectVals, (val) => val === selectValue);
        if (index2 === -1) {
          multipleValue = selectVals.concat([selectValue]);
        } else {
          multipleValue = selectVals.filter((val) => val !== selectValue);
        }
        changeEvent(evnt, multipleValue);
      } else {
        changeEvent(evnt, selectValue);
        hideOptionPanel();
      }
      reactData.reactFlag++;
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const validOffsetOption = (option2) => {
      const isDisabled = option2.disabled;
      const optid = getOptId(option2);
      if (!isDisabled && !hasOptGroupById(optid)) {
        return true;
      }
      return false;
    };
    const findOffsetOption = (option2, isDwArrow) => {
      const { afterVisibleList } = reactData;
      const { optFullValMaps } = internalData;
      const valueField = computeValueField.value;
      if (!option2) {
        for (let i = 0; i < afterVisibleList.length - 1; i++) {
          const item = afterVisibleList[i];
          if (validOffsetOption(item)) {
            return item;
          }
        }
      }
      const cacheItem = optFullValMaps[option2[valueField]];
      if (cacheItem) {
        const avIndex = cacheItem._index;
        if (avIndex > -1) {
          if (isDwArrow) {
            for (let i = avIndex + 1; i <= afterVisibleList.length - 1; i++) {
              const item = afterVisibleList[i];
              if (validOffsetOption(item)) {
                return item;
              }
            }
          } else {
            if (avIndex > 0) {
              for (let len = avIndex - 1; len >= 0; len--) {
                const item = afterVisibleList[len];
                if (validOffsetOption(item)) {
                  return item;
                }
              }
            }
          }
        }
      }
      return null;
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel, currentOption } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
            changeOptionEvent(evnt, currentOption);
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
            const offsetOption = findOffsetOption(currentOption, isDwArrow);
            if (offsetOption) {
              setCurrentOption(offsetOption);
              handleScrollToOption(offsetOption, isDwArrow);
            }
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const handleFocusSearch = () => {
      if (props.filterable) {
        nextTick(() => {
          const inpSearch = refInpSearch.value;
          if (inpSearch) {
            inpSearch.focus();
          }
        });
      }
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent2("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent2("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent2("blur", {}, evnt);
    };
    const modelSearchEvent = (value) => {
      reactData.searchValue = value;
    };
    const focusSearchEvent = () => {
      reactData.isActivated = true;
    };
    const handleSearchEvent = () => {
      const { remote, remoteMethod } = props;
      const { searchValue } = reactData;
      if (remote && remoteMethod) {
        reactData.searchLoading = true;
        Promise.resolve(remoteMethod({ searchValue })).then(() => nextTick()).catch(() => nextTick()).finally(() => {
          reactData.searchLoading = false;
          handleOption();
          updateYData();
        });
      } else {
        handleOption();
        updateYData();
      }
    };
    const triggerSearchEvent = import_xe_utils98.default.debounce(handleSearchEvent, 350, { trailing: true });
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const checkOptionDisabled = (isSelected, option2, group) => {
      if (option2.disabled) {
        return true;
      }
      if (group && group.disabled) {
        return true;
      }
      const isMaximize = computeIsMaximize.value;
      if (isMaximize && !isSelected) {
        return true;
      }
      return false;
    };
    const updateYSpace = () => {
      const { scrollYLoad, afterVisibleList } = reactData;
      const { scrollYStore } = internalData;
      reactData.bodyHeight = scrollYLoad ? afterVisibleList.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad, afterVisibleList } = reactData;
      const { scrollYStore } = internalData;
      reactData.optList = scrollYLoad ? afterVisibleList.slice(scrollYStore.startIndex, scrollYStore.endIndex) : afterVisibleList.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, scrollBodyElem ? Math.ceil(scrollBodyElem.clientHeight / rowHeight) : 0);
          const offsetYSize = Math.max(0, Math.min(2, import_xe_utils98.default.toNumber(sYOpts.oSize)));
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const handleScrollToOption = (option2, isDwArrow) => {
      const { scrollYLoad } = reactData;
      const { optFullValMaps, scrollYStore } = internalData;
      const valueField = computeValueField.value;
      const cacheItem = optFullValMaps[option2[valueField]];
      if (cacheItem) {
        const optid = cacheItem.key;
        const avIndex = cacheItem._index;
        if (avIndex > -1) {
          const optWrapperElem = refVirtualWrapper.value;
          const panelElem = refOptionPanel.value;
          const optElem = panelElem.querySelector(`[optid='${optid}']`);
          if (optWrapperElem) {
            if (optElem) {
              const wrapperHeight = optWrapperElem.offsetHeight;
              const offsetPadding = 1;
              if (isDwArrow) {
                if (optElem.offsetTop + optElem.offsetHeight - optWrapperElem.scrollTop > wrapperHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop + optElem.offsetHeight - wrapperHeight;
                }
              } else {
                if (optElem.offsetTop + offsetPadding < optWrapperElem.scrollTop || optElem.offsetTop + offsetPadding > optWrapperElem.scrollTop + optWrapperElem.clientHeight) {
                  optWrapperElem.scrollTop = optElem.offsetTop - offsetPadding;
                }
              }
            } else if (scrollYLoad) {
              if (isDwArrow) {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight - optWrapperElem.clientHeight + scrollYStore.rowHeight;
              } else {
                optWrapperElem.scrollTop = avIndex * scrollYStore.rowHeight;
              }
            }
          }
        }
      }
    };
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        if (import_xe_utils98.default.isNumber(scrollLeft)) {
          scrollBodyElem.scrollLeft = scrollLeft;
        }
        if (import_xe_utils98.default.isNumber(scrollTop)) {
          scrollBodyElem.scrollTop = scrollTop;
        }
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el2 = refElem.value;
      if (el2 && el2.clientWidth && el2.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const isVMScrollProcess = () => {
      const delayHover = 250;
      const { lastScrollTime } = internalData;
      return !!(lastScrollTime && Date.now() < lastScrollTime + delayHover);
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      internalData.lastScrollTime = Date.now();
      dispatchEvent2("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    const loadData = (datas) => {
      cacheItemMap(datas || []);
      const { fullData, scrollYStore } = internalData;
      const sYOpts = computeSYOpts.value;
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.synchData = datas || [];
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      handleData();
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
        scrollBodyElem.scrollLeft = 0;
      }
      internalData.lastScrollTop = 0;
      internalData.lastScrollLeft = 0;
      return nextTick();
    };
    const hasOptGroupById = (optid) => {
      const { optGroupKeyMaps } = internalData;
      return !!optGroupKeyMaps[optid];
    };
    const selectMethods = {
      dispatchEvent: dispatchEvent2,
      loadData,
      reloadData(datas) {
        clearScroll();
        return loadData(datas);
      },
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      refreshOption() {
        handleOption();
        updateYData();
        return nextTick();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      recalculate,
      clearScroll
    };
    Object.assign($xeSelect, selectMethods);
    const renderOption = (list, group) => {
      const { optionKey, modelValue } = props;
      const { currentOption } = reactData;
      const optionOpts = computeOptionOpts.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const groupLabelField = computeGroupLabelField.value;
      const { useKey } = optionOpts;
      const optionSlot = slots.option;
      return list.map((option2, cIndex) => {
        const { slots: slots2, className } = option2;
        const optid = getOptId(option2);
        const optionValue = option2[valueField];
        const isOptGroup = hasOptGroupById(optid);
        const isSelected = import_xe_utils98.default.isArray(modelValue) ? modelValue.indexOf(optionValue) > -1 : modelValue === optionValue;
        const isVisible = !isOptGroup || isOptionVisible(option2);
        const isDisabled = checkOptionDisabled(isSelected, option2, group);
        const defaultSlot = slots2 ? slots2.default : null;
        const optParams = { option: option2, group: null, $select: $xeSelect };
        return isVisible ? h("div", {
          key: useKey || optionKey ? optid : cIndex,
          class: ["vxe-select-option", className ? import_xe_utils98.default.isFunction(className) ? className(optParams) : className : "", {
            "vxe-select-optgroup": isOptGroup,
            "is--disabled": isDisabled,
            "is--selected": isSelected,
            "is--hover": currentOption && getOptId(currentOption) === optid
          }],
          // attrs
          optid,
          // event
          onMousedown: (evnt) => {
            const isLeftBtn = evnt.button === 0;
            if (isLeftBtn) {
              evnt.stopPropagation();
            }
          },
          onClick: (evnt) => {
            if (!isDisabled && !isOptGroup) {
              changeOptionEvent(evnt, option2);
            }
          },
          onMouseenter: () => {
            if (!isDisabled && !isOptGroup && !isVMScrollProcess()) {
              setCurrentOption(option2);
            }
          }
        }, optionSlot ? callSlot(optionSlot, optParams) : defaultSlot ? callSlot(defaultSlot, optParams) : getFuncText2(option2[isOptGroup ? groupLabelField : labelField])) : createCommentVNode();
      });
    };
    const renderOpts = () => {
      const { optList, searchLoading } = reactData;
      if (searchLoading) {
        return [
          h("div", {
            class: "vxe-select--search-loading"
          }, [
            h("i", {
              class: ["vxe-select--search-icon", getIcon().SELECT_LOADED]
            }),
            h("span", {
              class: "vxe-select--search-text"
            }, getI18n("vxe.select.loadingText"))
          ])
        ];
      }
      if (optList.length) {
        return renderOption(optList);
      }
      return [
        h("div", {
          class: "vxe-select--empty-placeholder"
        }, props.emptyText || getI18n("vxe.select.emptyText"))
      ];
    };
    const renderVN = () => {
      const { className, popupClassName, loading: loading2, filterable } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, bodyHeight, topSpaceHeight } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-select--readonly", className]
        }, [
          h("div", {
            class: "vxe-select-slots",
            ref: "hideOption"
          }, defaultSlot ? defaultSlot({}) : []),
          h("span", {
            class: "vxe-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-select", className ? import_xe_utils98.default.isFunction(className) ? className({ $select: $xeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--filter": filterable,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-select-slots",
          ref: "hideOption"
        }, defaultSlot ? defaultSlot({}) : []),
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: inpPlaceholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().SELECT_LOADED : visiblePanel ? getIcon().SELECT_OPEN : getIcon().SELECT_CLOSE,
          modelValue: selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-select--panel", popupClassName ? import_xe_utils98.default.isFunction(popupClassName) ? popupClassName({ $select: $xeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized && (visiblePanel || isAniVisible) ? [
            h("div", {
              class: "vxe-select--panel-wrapper"
            }, [
              filterable ? h("div", {
                class: "vxe-select--panel-search"
              }, [
                h(input_default, {
                  ref: refInpSearch,
                  class: "vxe-select-search--input",
                  modelValue: reactData.searchValue,
                  clearable: true,
                  disabled: false,
                  readonly: false,
                  placeholder: getI18n("vxe.select.search"),
                  prefixIcon: getIcon().INPUT_SEARCH,
                  "onUpdate:modelValue": modelSearchEvent,
                  onFocus: focusSearchEvent,
                  onChange: triggerSearchEvent,
                  onSearch: triggerSearchEvent
                })
              ]) : createCommentVNode(),
              headerSlot ? h("div", {
                class: "vxe-select--panel-header"
              }, headerSlot({})) : createCommentVNode(),
              h("div", {
                class: "vxe-select--panel-body"
              }, [
                h("div", {
                  ref: refVirtualWrapper,
                  class: "vxe-select-option--wrapper",
                  onScroll: scrollEvent
                }, [
                  h("div", {
                    class: "vxe-select--y-space",
                    style: {
                      height: bodyHeight ? `${bodyHeight}px` : ""
                    }
                  }),
                  h("div", {
                    ref: refVirtualBody,
                    class: "vxe-select--body",
                    style: {
                      marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
                    }
                  }, renderOpts())
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-select--panel-footer"
              }, footerSlot({})) : createCommentVNode()
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => reactData.staticOptions, (val) => {
      loadData(val);
    });
    watch(() => props.options, (val) => {
      loadData(val || []);
    });
    watch(() => props.optionGroups, (val) => {
      loadData(val || []);
    });
    onMounted(() => {
      nextTick(() => {
        const { options, optionGroups } = props;
        if (optionGroups) {
          loadData(optionGroups);
        } else if (options) {
          loadData(options);
        }
      });
      globalEvents.on($xeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeSelect, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeSelect, "mousewheel");
      globalEvents.off($xeSelect, "mousedown");
      globalEvents.off($xeSelect, "keydown");
      globalEvents.off($xeSelect, "blur");
    });
    provide("$xeSelect", $xeSelect);
    $xeSelect.renderVN = renderVN;
    return $xeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/default-style-form.js
var getBoldOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.fontNormal"), value: false },
    { label: getI18n("vxe.formDesign.styleSetting.fontBold"), value: true }
  ];
};
var getColonOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.colonVisible"), value: true },
    { label: getI18n("vxe.formDesign.styleSetting.colonHidden"), value: false }
  ];
};
var getAlignOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.alignLeft"), value: "" },
    { label: getI18n("vxe.formDesign.styleSetting.alignRight"), value: "right" }
  ];
};
var getWidthUnitOptions = () => {
  return [
    { label: getI18n("vxe.formDesign.styleSetting.unitPx"), value: "" },
    { label: getI18n("vxe.formDesign.styleSetting.unitPct"), value: "%" }
  ];
};
var renderLayoutOption = (formData, field, type, changeEvent) => {
  const isVertical = type === "vertical";
  return h("div", {
    class: ["vxe-form-design--widget-form-item-option", `is--${type}`, {
      "is--active": isVertical ? formData[field] : !formData[field]
    }],
    onClick() {
      formData[field] = isVertical;
      changeEvent();
    }
  }, [
    h("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    h("div", {
      class: "vxe-form-design--widget-form-item-option-row"
    }),
    h("div", {}, isVertical ? getI18n("vxe.formDesign.styleSetting.verticalLayout") : getI18n("vxe.formDesign.styleSetting.horizontalLayout"))
  ]);
};
var DefaultPCStyleFormComponent = defineComponent({
  name: "DefaultPCStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const verticalField = "pcVertical";
    const refBoldOpts = ref(getBoldOptions());
    const refColonOpts = ref(getColonOptions());
    const refAlignOpts = ref(getAlignOptions());
    const refWidthUnitOpts = ref(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const { formData } = props;
      if (!formData.pcTitleWidth) {
        formData.pcTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.layoutTitle"),
              field: verticalField
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    renderLayoutOption(formData, verticalField, "vertical", changeLayoutEvent),
                    renderLayoutOption(formData, verticalField, "horizontal", changeLayoutEvent)
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.boldTitle")),
                    h(group_default3, {
                      modelValue: formData.pcTitleBold,
                      options: refBoldOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleBold = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.colonTitle")),
                    h(group_default3, {
                      modelValue: formData.pcTitleColon,
                      options: refColonOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleColon = val;
                      }
                    })
                  ]),
                  formData.pcVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.alignTitle")),
                    h(group_default3, {
                      modelValue: formData.pcTitleAlign,
                      options: refAlignOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleAlign = val;
                      }
                    })
                  ]),
                  formData.pcVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.widthTitle")),
                    h(input_default, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: formData.pcTitleWidth,
                      type: "integer",
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleWidth = val;
                      }
                    }),
                    h(select_default, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: formData.pcTitleWidthUnit,
                      options: refWidthUnitOpts.value,
                      transfer: true,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.pcTitleWidthUnit = val;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
});
var DefaultMobileStyleFormComponent = defineComponent({
  name: "DefaultMobileStyleForm",
  props: {
    formData: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const verticalField = "mobileVertical";
    const refBoldOpts = ref(getBoldOptions());
    const refColonOpts = ref(getColonOptions());
    const refAlignOpts = ref(getAlignOptions());
    const refWidthUnitOpts = ref(getWidthUnitOptions());
    const refreshPreview = () => {
      if ($xeFormDesign) {
        $xeFormDesign.refreshPreviewView();
      }
    };
    const changeLayoutEvent = () => {
      const { formData } = props;
      if (!formData.mobileTitleWidth) {
        formData.mobileTitleWidth = 100;
      }
      refreshPreview();
    };
    return () => {
      const { formData } = props;
      return h(form_default, {
        data: formData,
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.layoutTitle"),
              field: verticalField
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-layout"
                  }, [
                    renderLayoutOption(formData, verticalField, "vertical", changeLayoutEvent),
                    renderLayoutOption(formData, verticalField, "horizontal", changeLayoutEvent)
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.styleSetting.styleTitle")
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.boldTitle")),
                    h(group_default3, {
                      modelValue: formData.mobileTitleBold,
                      options: refBoldOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleBold = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.colonTitle")),
                    h(group_default3, {
                      modelValue: formData.mobileTitleColon,
                      options: refColonOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleColon = val;
                      }
                    })
                  ]),
                  formData.mobileVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.alignTitle")),
                    h(group_default3, {
                      modelValue: formData.mobileTitleAlign,
                      options: refAlignOpts.value,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleAlign = val;
                      }
                    })
                  ]),
                  formData.mobileVertical ? createCommentVNode() : h("div", {
                    class: "vxe-form-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, getI18n("vxe.formDesign.styleSetting.widthTitle")),
                    h(input_default, {
                      class: "vxe-form-design--widget-form-item-prop-width",
                      modelValue: formData.mobileTitleWidth,
                      type: "integer",
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleWidth = val;
                      }
                    }),
                    h(select_default, {
                      class: "vxe-form-design--widget-form-item-prop-unit",
                      modelValue: formData.mobileTitleWidthUnit,
                      options: refWidthUnitOpts.value,
                      transfer: true,
                      onChange: refreshPreview,
                      "onUpdate:modelValue"(val) {
                        formData.mobileTitleWidthUnit = val;
                      }
                    })
                  ])
                ];
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/layout-style.js
var layout_style_default = defineComponent({
  name: "FormDesignLayoutStyle",
  props: {},
  emits: [],
  setup() {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const reactData = reactive({
      activeTab: 1
    });
    const $xeFormDesignLayoutStyle = {
      reactData,
      renderVN() {
        return [];
      }
    };
    if (!$xeFormDesign) {
      return $xeFormDesignLayoutStyle;
    }
    const { props: formDesignProps, reactData: formDesignReactData } = $xeFormDesign;
    const settingVisible = ref(false);
    const settingConfig = ref(null);
    const settingFormData = ref({});
    const updatePreviewView = () => {
      settingConfig.value = $xeFormDesign.getConfig();
    };
    const createFormViewFormConfig = (params) => {
      const { viewRender } = params;
      const { activeTab } = reactData;
      const { name } = viewRender || {};
      const compConf = renderer.get(name) || {};
      const createPCFormConfig = compConf ? compConf.createFormViewFormConfig : null;
      const createMobileFormConfig = compConf ? compConf.createFormViewMobileFormConfig : null;
      if (activeTab === 2) {
        if (createMobileFormConfig) {
          return createMobileFormConfig(params);
        }
        return createDefaultFormViewMobileFormConfig(params);
      }
      if (createPCFormConfig) {
        return createPCFormConfig(params);
      }
      return createDefaultFormViewPCFormConfig(params);
    };
    const formDesignLayoutStyleMethod = {
      updatePreviewView,
      openStylePreview() {
        const { showPc } = formDesignProps;
        updatePreviewView();
        reactData.activeTab = showPc ? 1 : 2;
        settingVisible.value = true;
      }
    };
    Object.assign($xeFormDesignLayoutStyle, formDesignLayoutStyleMethod);
    const renderStylePreview = () => {
      const { activeTab } = reactData;
      return h("div", {
        class: ["vxe-form-design--layout-style-preview", `is--${activeTab === 2 ? "mobile" : "pc"}`]
      }, [
        h(form_view_default, {
          modelValue: settingFormData.value,
          config: settingConfig.value,
          createFormConfig: createFormViewFormConfig,
          "onUpdate:modelValue"(val) {
            settingFormData.value = val;
          }
        })
      ]);
    };
    const renderMobileStyle = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderSettingMobileFormView = compConf ? compConf.renderFormDesignMobileStyleFormView : null;
        if (renderSettingMobileFormView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-mobile-form-view"
          }, getSlotVNs2(renderSettingMobileFormView({}, { $formDesign: $xeFormDesign, formConfig: formData })));
        }
      }
      return h(DefaultMobileStyleFormComponent, {
        formData
      });
    };
    const renderPCStyle = () => {
      const { formRender } = formDesignProps;
      const { formData } = formDesignReactData;
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const renderStylePCFormView = compConf ? compConf.renderFormDesignStyleFormView : null;
        if (renderStylePCFormView) {
          return h("div", {
            class: "vxe-form-design--custom-setting-pc-form-view"
          }, getSlotVNs2(renderStylePCFormView({}, { $formDesign: $xeFormDesign, formConfig: formData })));
        }
      }
      return h(DefaultPCStyleFormComponent, {
        formData
      });
    };
    const renderStyleSetting = () => {
      const { showPc, showMobile } = formDesignProps;
      const { activeTab } = reactData;
      return h("div", {
        class: "vxe-form-design--layout-style-setting"
      }, [
        h(tabs_default, {
          modelValue: activeTab,
          titleWidth: showPc && showMobile ? "50%" : "100%",
          titleAlign: "center",
          padding: true,
          onChange: updatePreviewView,
          "onUpdate:modelValue"(val) {
            reactData.activeTab = val;
          }
        }, {
          default() {
            const tabVNs = [];
            if (showPc) {
              tabVNs.push(h(tab_pane_default, {
                title: getI18n("vxe.formDesign.widgetProp.displaySetting.pc"),
                icon: getIcon().FORM_DESIGN_PROPS_PC,
                k: 1,
                name: 1
              }, {
                default() {
                  return renderPCStyle();
                }
              }));
            }
            if (showMobile) {
              tabVNs.push(h(tab_pane_default, {
                title: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile"),
                icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                key: 2,
                name: 2
              }, {
                default() {
                  return renderMobileStyle();
                }
              }));
            }
            return tabVNs;
          }
        })
      ]);
    };
    const renderVN = () => {
      const { showPc, showMobile } = formDesignProps;
      return h(modal_default, {
        modelValue: settingVisible.value,
        title: getI18n("vxe.formDesign.styleSetting.title"),
        height: "90vh",
        width: "90vw",
        escClosable: true,
        maskClosable: true,
        destroyOnClose: true,
        showMaximize: true,
        transfer: true,
        "onUpdate:modelValue"(val) {
          settingVisible.value = val;
        }
      }, {
        default() {
          return h("div", {
            class: "vxe-form-design--layout-style"
          }, [
            renderStylePreview(),
            showPc || showMobile ? renderStyleSetting() : createCommentVNode()
          ]);
        }
      });
    };
    $xeFormDesignLayoutStyle.renderVN = renderVN;
    provide("$xeFormDesignLayoutStyle", $xeFormDesignLayoutStyle);
    return $xeFormDesignLayoutStyle;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/form-design.js
var form_design_default = defineComponent({
  name: "VxeFormDesign",
  props: {
    size: {
      type: String,
      default: () => getConfig().formDesign.size || getConfig().size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().formDesign.height
    },
    widgets: {
      type: Array,
      default: () => import_xe_utils99.default.clone(getConfig().formDesign.widgets) || []
    },
    showHeader: {
      type: Boolean,
      default: () => getConfig().formDesign.showHeader
    },
    showPc: {
      type: Boolean,
      default: () => getConfig().formDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().formDesign.showMobile
    },
    formRender: Object
  },
  emits: [
    "click-widget",
    "add-widget",
    "copy-widget",
    "remove-widget",
    "drag-widget"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils99.default.uniqueId();
    const refElem = ref();
    const refLayoutStyle = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formData: {},
      widgetConfigs: [],
      widgetObjList: [],
      dragWidget: null,
      sortWidget: null,
      activeWidget: null
    });
    const internalData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeFormDesign = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const createWidget = (name) => {
      return new FormDesignWidgetInfo($xeFormDesign, name, reactData.widgetObjList);
    };
    const createEmptyWidget = () => {
      return new FormDesignWidgetInfo($xeFormDesign, "", reactData.widgetObjList);
    };
    const loadConfig = (config3) => {
      if (config3) {
        const { formConfig, widgetData } = config3;
        if (formConfig) {
          loadFormConfig(formConfig);
        }
        if (widgetData) {
          loadWidgetData(widgetData);
        }
      }
      const { activeWidget, widgetObjList } = reactData;
      if (activeWidget) {
        const rest = import_xe_utils99.default.findTree(widgetObjList, (item) => item.id === activeWidget.id, { children: "children" });
        if (rest) {
          reactData.activeWidget = rest.item;
        } else {
          reactData.activeWidget = widgetObjList[0] || null;
        }
      } else {
        reactData.activeWidget = widgetObjList[0] || null;
      }
      return nextTick();
    };
    const reloadConfig = (config3) => {
      clearConfig();
      return loadConfig(config3);
    };
    const getFormConfig = () => {
      return import_xe_utils99.default.clone(reactData.formData, true);
    };
    const loadFormConfig = (data) => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return nextTick();
    };
    const getWidgetById = (id2) => {
      const { widgetObjList } = reactData;
      if (id2) {
        const widgetId = import_xe_utils99.default.toNumber(id2);
        const rest = import_xe_utils99.default.findTree(widgetObjList, (item) => item && item.id === widgetId, { children: "children" });
        if (rest) {
          return rest.item;
        }
      }
      return null;
    };
    const getWidgetData = () => {
      const objList = import_xe_utils99.default.clone(reactData.widgetObjList, true);
      import_xe_utils99.default.eachTree(objList, (item) => {
        item.model.value = null;
      }, { children: "children" });
      return objList;
    };
    const loadWidgetData = (widgetData) => {
      reactData.widgetObjList = (widgetData || []).map((item) => configToWidget(item));
      return nextTick();
    };
    const openStyleSetting = () => {
      const $layoutStyle = refLayoutStyle.value;
      if ($layoutStyle) {
        $layoutStyle.openStylePreview();
      }
      return nextTick();
    };
    const clearConfig = () => {
      reactData.widgetObjList = [];
      initSettingForm();
      return nextTick();
    };
    const formDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $xeFormDesign }, params));
      },
      createWidget,
      createEmptyWidget,
      getConfig() {
        return {
          formConfig: getFormConfig(),
          widgetData: getWidgetData()
        };
      },
      clearConfig,
      loadConfig,
      reloadConfig,
      getFormConfig,
      loadFormConfig,
      getWidgetById,
      getFormData() {
        const { widgetObjList } = reactData;
        const formData = {};
        import_xe_utils99.default.eachTree(widgetObjList, (widget) => {
          formData[widget.field] = null;
        }, { children: "children" });
        return formData;
      },
      getWidgetData,
      loadWidgetData,
      refreshPreviewView() {
        const $layoutStyle = refLayoutStyle.value;
        if ($layoutStyle) {
          $layoutStyle.updatePreviewView();
        }
        return nextTick();
      },
      openStyleSetting
    };
    const updateWidgetConfigs = () => {
      const { widgets } = props;
      const widgetConfs = [];
      const baseWidgets = [];
      const layoutWidgets = [];
      const advancedWidgets = [];
      const customGroups = [];
      renderer.forEach((item, name) => {
        const { createFormDesignWidgetConfig } = item;
        if (createFormDesignWidgetConfig) {
          const widthItem = createWidget(name);
          const widgetConf = getWidgetConfig(name);
          const widgetCustomGroup = getWidgetConfigCustomGroup(name, $xeFormDesign);
          if (widgetCustomGroup) {
            const cusGroup = customGroups.find((item2) => item2.title === widgetCustomGroup);
            if (cusGroup) {
              cusGroup.children.push(widthItem);
            } else {
              customGroups.push({
                title: widgetCustomGroup,
                children: [widthItem]
              });
            }
          } else {
            switch (widgetConf.group) {
              case "layout":
                layoutWidgets.push(widthItem);
                break;
              case "advanced":
                advancedWidgets.push(widthItem);
                break;
              default:
                if (!["title"].includes(widthItem.name)) {
                  baseWidgets.push(widthItem);
                }
                break;
            }
          }
        }
      });
      if (baseWidgets.length) {
        widgetConfs.push({
          group: "base",
          children: baseWidgets
        });
      }
      if (layoutWidgets.length) {
        widgetConfs.push({
          group: "layout",
          children: layoutWidgets
        });
      }
      if (advancedWidgets.length) {
        widgetConfs.push({
          group: "advanced",
          children: advancedWidgets
        });
      }
      if (customGroups.length) {
        widgetConfs.push(...customGroups);
      }
      if (widgets && widgets.length) {
        reactData.widgetConfigs = props.widgets.map((config3) => {
          return {
            title: config3.customGroup,
            group: config3.group,
            children: config3.children ? config3.children.map((name) => {
              const widthItem = createWidget(name);
              return widthItem;
            }) : []
          };
        });
      } else {
        reactData.widgetConfigs = widgetConfs;
      }
    };
    const validWidgetUnique = (widgetName) => {
      const { widgetObjList } = reactData;
      const widgetConf = getWidgetConfig(widgetName);
      if (widgetConf.unique) {
        const existWidgetList = [];
        import_xe_utils99.default.eachTree(widgetObjList, (obj) => {
          if (obj.name === widgetName) {
            existWidgetList.push(obj);
          }
        }, { children: "children" });
        const status = existWidgetList.length < 1;
        if (!status) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.formDesign.error.wdFormUni"),
              status: "error",
              id: "wdFormUni"
            });
          }
        }
        return status;
      }
      return true;
    };
    const formDesignPrivateMethods = {
      validWidgetUnique,
      handleClickWidget(evnt, item) {
        if (item && item.name) {
          evnt.stopPropagation();
          reactData.activeWidget = item;
          formDesignMethods.dispatchEvent("click-widget", { widget: item }, evnt);
        }
      },
      handleCopyWidget(evnt, widget) {
        const { widgetObjList } = reactData;
        const rest = import_xe_utils99.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          evnt.stopPropagation();
          if (validWidgetUnique(widget.name)) {
            const { path } = rest;
            const rootIndex = Number(path[0]);
            const newWidget = createWidget(widget.name);
            if (newWidget.title) {
              newWidget.title = getI18n("vxe.formDesign.widget.copyTitle", [`${widget.title}`.replace(getI18n("vxe.formDesign.widget.copyTitle", [""]), "")]);
            }
            if (rootIndex >= widgetObjList.length - 1) {
              widgetObjList.push(newWidget);
            } else {
              widgetObjList.splice(rootIndex + 1, 0, newWidget);
            }
            reactData.activeWidget = newWidget;
            reactData.widgetObjList = [...widgetObjList];
            formDesignMethods.dispatchEvent("copy-widget", { widget, newWidget }, evnt);
          }
        }
      },
      handleRemoveWidget(evnt, widget) {
        const { widgetObjList } = reactData;
        const rest = import_xe_utils99.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          const { index: index2, parent, items } = rest;
          evnt.stopPropagation();
          if (index2 >= items.length - 1) {
            reactData.activeWidget = items[index2 - 1];
          } else {
            reactData.activeWidget = items[index2 + 1] || null;
          }
          if (parent && parent.name === "row") {
            items[index2] = createEmptyWidget();
          } else {
            items.splice(index2, 1);
          }
          reactData.widgetObjList = [...widgetObjList];
          formDesignMethods.dispatchEvent("remove-widget", { widget }, evnt);
        }
      }
    };
    const createSettingForm = () => {
      const { formRender, showPc, showMobile } = props;
      let conf = getDefaultSettingFormData({
        pcVisible: showPc,
        mobileVisible: showMobile
      });
      if (formRender) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createFormDesignSettingFormConfig : null;
        conf = (createFormConfig ? createFormConfig({}) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const openStylePreviewEvent = () => {
      openStyleSetting();
    };
    Object.assign($xeFormDesign, formDesignMethods, formDesignPrivateMethods);
    const renderLayoutHeader = () => {
      const extraSlot = slots.extra;
      return h("div", {
        class: "vxe-form-design--header-wrapper"
      }, [
        h("div", {
          class: "vxe-form-design--header-left"
        }),
        h("div", {
          class: "vxe-form-design--header-middle"
        }),
        h("div", {
          class: "vxe-form-design--header-right"
        }, [
          extraSlot ? h("div", {
            class: "vxe-form-design--header-extra"
          }, extraSlot({})) : renderEmptyElement($xeFormDesign),
          h("div", {
            class: "vxe-form-design--header-setting"
          }, [
            h(button_default, {
              mode: "text",
              status: "primary",
              icon: getIcon().FORM_DESIGN_STYLE_SETTING,
              content: getI18n("vxe.formDesign.styleSetting.btn"),
              onClick: openStylePreviewEvent
            })
          ])
        ])
      ]);
    };
    const renderVN = () => {
      const { height, showHeader } = props;
      const vSize = computeSize.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      return h("div", {
        ref: refElem,
        class: ["vxe-form-design", {
          [`size--${vSize}`]: vSize
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        showHeader || headerSlot ? h("div", {
          class: "vxe-form-design--header"
        }, headerSlot ? headerSlot({}) : renderLayoutHeader()) : createCommentVNode(),
        h("div", {
          class: "vxe-form-design--body"
        }, [
          h(layout_widget_default),
          h(layout_preview_default),
          h(layout_setting_default),
          h(layout_style_default, {
            ref: refLayoutStyle
          })
        ]),
        footerSlot ? h("div", {
          class: "vxe-form-design--footer"
        }, footerSlot ? footerSlot({}) : []) : createCommentVNode()
      ]);
    };
    $xeFormDesign.renderVN = renderVN;
    watch(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    watch(() => props.widgets, () => {
      updateWidgetConfigs();
    });
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    initSettingForm();
    updateWidgetConfigs();
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeFormDesign", $xeFormDesign);
    return $xeFormDesign;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/use/widget-name.js
var import_xe_utils100 = __toESM(require_xe_utils());
function useWidgetName(props) {
  const computeKebabCaseName = computed(() => {
    const { renderOpts } = props;
    return renderOpts ? import_xe_utils100.default.kebabCase(renderOpts.name) : "";
  });
  return {
    computeKebabCaseName
  };
}

// node_modules/vxe-pc-ui/es/form-design/src/use/widget-view.js
function useWidgetView(props) {
  const currWidget = computed(() => {
    const { renderParams } = props;
    return renderParams.widget;
  });
  const isEditMode = computed(() => {
    const { renderParams } = props;
    return renderParams.isEditMode || false;
  });
  const isViewMode = computed(() => {
    const { renderParams } = props;
    return renderParams.isViewMode || false;
  });
  const widgetOptions = computed(() => {
    const { renderParams } = props;
    const { widget } = renderParams;
    return widget ? widget.options : {};
  });
  const widgetModel = computed({
    get() {
      const { renderParams } = props;
      const { $formView, widget } = renderParams;
      return $formView ? $formView.getItemValue(widget) : null;
    },
    set(value) {
      const { renderParams } = props;
      const { $formView, widget } = renderParams;
      if ($formView) {
        $formView.setItemValue(widget, value);
      }
    }
  });
  return {
    currWidget,
    widgetOptions,
    widgetModel,
    isEditMode,
    isViewMode
  };
}

// node_modules/vxe-pc-ui/es/form-design/src/use/widget-subtable-view.js
var import_xe_utils101 = __toESM(require_xe_utils());
function useSubtableView(props) {
  const currWidget = computed(() => {
    const { renderParams } = props;
    return renderParams.widget;
  });
  const currColumn = computed(() => {
    const { renderParams } = props;
    return renderParams.column;
  });
  const currRow = computed(() => {
    const { renderParams } = props;
    return renderParams.row;
  });
  const widgetOptions = computed(() => {
    const { renderParams } = props;
    const { widget } = renderParams;
    return widget ? widget.options : {};
  });
  const cellModel = computed({
    get() {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils101.default.get(row, column.field);
    },
    set(value) {
      const { renderParams } = props;
      const { row, column } = renderParams;
      return import_xe_utils101.default.set(row, column.field, value);
    }
  });
  return {
    currColumn,
    currRow,
    currWidget,
    widgetOptions,
    cellModel
  };
}

// node_modules/vxe-pc-ui/es/textarea/src/textarea.js
var import_xe_utils102 = __toESM(require_xe_utils());
var autoTxtElem;
var textarea_default = defineComponent({
  name: "VxeTextarea",
  props: {
    modelValue: [String, Number],
    className: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    readonly: {
      type: Boolean,
      default: null
    },
    editable: {
      type: Boolean,
      default: true
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    rows: {
      type: [String, Number],
      default: null
    },
    cols: {
      type: [String, Number],
      default: null
    },
    showWordCount: Boolean,
    countMethod: Function,
    autosize: [Boolean, Object],
    form: String,
    resize: {
      type: String,
      default: () => getConfig().textarea.resize
    },
    size: {
      type: String,
      default: () => getConfig().textarea.size || getConfig().size
    },
    // 已废弃
    maxlength: [String, Number]
  },
  emits: [
    "update:modelValue",
    "input",
    "keydown",
    "keyup",
    "click",
    "change",
    "focus",
    "blur"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils102.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refTextarea = ref();
    const refMaps = {
      refElem,
      refTextarea
    };
    const $xeTextarea = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let textareaMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeInputReadonly = computed(() => {
      const { editable } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || !editable;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().textarea.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      return maxLength || maxlength;
    });
    const computeInputCount = computed(() => {
      return import_xe_utils102.default.getSize(reactData.inputValue);
    });
    const computeIsCountError = computed(() => {
      const inputCount = computeInputCount.value;
      const inpMaxLength = computeInpMaxLength.value;
      return inpMaxLength && inputCount > import_xe_utils102.default.toNumber(inpMaxLength);
    });
    const computeSizeOpts = computed(() => {
      return Object.assign({ minRows: 1, maxRows: 10 }, getConfig().textarea.autosize, props.autosize);
    });
    const updateAutoTxt = () => {
      const { size, autosize } = props;
      const { inputValue } = reactData;
      if (autosize) {
        if (!autoTxtElem) {
          autoTxtElem = document.createElement("div");
        }
        if (!autoTxtElem.parentNode) {
          document.body.appendChild(autoTxtElem);
        }
        const textElem = refTextarea.value;
        if (!textElem) {
          return;
        }
        const textStyle = getComputedStyle(textElem);
        autoTxtElem.className = ["vxe-textarea--autosize", size ? `size--${size}` : ""].join(" ");
        autoTxtElem.style.width = `${textElem.clientWidth}px`;
        autoTxtElem.style.padding = textStyle.padding;
        autoTxtElem.innerText = ("" + (inputValue || "　")).replace(/\n$/, "\n　");
      }
    };
    const handleResize = () => {
      if (props.autosize) {
        nextTick(() => {
          const sizeOpts = computeSizeOpts.value;
          const { minRows, maxRows } = sizeOpts;
          const textElem = refTextarea.value;
          if (!textElem) {
            return;
          }
          const sizeHeight = autoTxtElem.clientHeight;
          const textStyle = getComputedStyle(textElem);
          const lineHeight = import_xe_utils102.default.toNumber(textStyle.lineHeight);
          const paddingTop = import_xe_utils102.default.toNumber(textStyle.paddingTop);
          const paddingBottom = import_xe_utils102.default.toNumber(textStyle.paddingBottom);
          const borderTopWidth = import_xe_utils102.default.toNumber(textStyle.borderTopWidth);
          const borderBottomWidth = import_xe_utils102.default.toNumber(textStyle.borderBottomWidth);
          const intervalHeight = paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
          const rowNum = (sizeHeight - intervalHeight) / lineHeight;
          const textRows = rowNum && /[0-9]/.test("" + rowNum) ? rowNum : Math.floor(rowNum) + 1;
          let vaildRows = textRows;
          if (textRows < minRows) {
            vaildRows = minRows;
          } else if (textRows > maxRows) {
            vaildRows = maxRows;
          }
          textElem.style.height = `${vaildRows * lineHeight + intervalHeight}px`;
        });
      }
    };
    const triggerEvent3 = (evnt) => {
      const value = reactData.inputValue;
      $xeTextarea.dispatchEvent(evnt.type, { value }, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      if (import_xe_utils102.default.toValueString(props.modelValue) !== value) {
        textareaMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const inputEvent = (evnt) => {
      const { immediate } = props;
      const textElem = evnt.target;
      const value = textElem.value;
      reactData.inputValue = value;
      if (immediate) {
        handleChange(value, evnt);
      }
      $xeTextarea.dispatchEvent("input", { value }, evnt);
      handleResize();
    };
    const changeEvent = (evnt) => {
      const { immediate } = props;
      if (immediate) {
        triggerEvent3(evnt);
      } else {
        handleChange(reactData.inputValue, evnt);
      }
    };
    const blurEvent = (evnt) => {
      const { immediate } = props;
      const { inputValue } = reactData;
      if (!immediate) {
        handleChange(inputValue, evnt);
      }
      $xeTextarea.dispatchEvent("blur", { value: inputValue }, evnt);
    };
    textareaMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $textarea: $xeTextarea }, params));
      },
      focus() {
        const textElem = refTextarea.value;
        textElem.focus();
        return nextTick();
      },
      blur() {
        const textElem = refTextarea.value;
        textElem.blur();
        return nextTick();
      }
    };
    Object.assign($xeTextarea, textareaMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
      updateAutoTxt();
    });
    watch(computeSizeOpts, () => {
      updateAutoTxt();
      handleResize();
    });
    nextTick(() => {
      const { autosize } = props;
      if (autosize) {
        updateAutoTxt();
        handleResize();
      }
    });
    const renderVN = () => {
      const { className, resize, autosize, showWordCount, countMethod, rows, cols } = props;
      const { inputValue } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const isCountError = computeIsCountError.value;
      const inputCount = computeInputCount.value;
      const inputReadonly = computeInputReadonly.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const inpMaxLength = computeInpMaxLength.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-textarea--readonly", className]
        }, inputValue);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-textarea", className, {
          [`size--${vSize}`]: vSize,
          "is--autosize": autosize,
          "is--count": showWordCount,
          "is--disabled": isDisabled,
          "is--rows": !import_xe_utils102.default.eqNull(rows),
          "is--cols": !import_xe_utils102.default.eqNull(cols)
        }],
        spellcheck: false
      }, [
        h("textarea", {
          ref: refTextarea,
          class: "vxe-textarea--inner",
          value: inputValue,
          name: props.name,
          placeholder: inpPlaceholder,
          maxlength: inpMaxLength,
          readonly: inputReadonly,
          disabled: isDisabled,
          rows,
          cols,
          style: resize ? {
            resize
          } : null,
          onInput: inputEvent,
          onChange: changeEvent,
          onKeydown: triggerEvent3,
          onKeyup: triggerEvent3,
          onClick: triggerEvent3,
          onFocus: triggerEvent3,
          onBlur: blurEvent
        }),
        showWordCount ? h("span", {
          class: ["vxe-textarea--count", {
            "is--error": isCountError
          }]
        }, countMethod ? `${countMethod({ value: inputValue })}` : `${inputCount}${inpMaxLength ? `/${inpMaxLength}` : ""}`) : null
      ]);
    };
    $xeTextarea.renderVN = renderVN;
    return $xeTextarea;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tip/src/tip.js
var import_xe_utils103 = __toESM(require_xe_utils());
var tip_default = defineComponent({
  name: "VxeTip",
  props: {
    title: {
      type: [String, Number],
      default: () => getConfig().tip.title
    },
    content: [String, Number],
    status: String,
    icon: {
      type: String,
      default: () => getConfig().tip.icon
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tip.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils103.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTip = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tip: $xeTip }, params));
    };
    const tipMethods = {
      dispatchEvent: dispatchEvent2
    };
    const tipPrivateMethods = {};
    Object.assign($xeTip, tipMethods, tipPrivateMethods);
    const renderVN = () => {
      const { status, content, icon, title } = props;
      const defaultSlot = slots.default;
      const titleSlot = slots.title;
      const iconSlot = slots.icon;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tip", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "has--title": !!(titleSlot || title)
        }]
      }, [
        iconSlot || icon ? h("div", {
          class: "vxe-tip--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-tip--body"
        }, [
          titleSlot || title ? h("div", {
            class: "vxe-tip--title"
          }, titleSlot ? getSlotVNs2(titleSlot({})) : import_xe_utils103.default.toValueString(title)) : createCommentVNode(),
          h("div", {
            class: "vxe-tip--content"
          }, defaultSlot ? getSlotVNs2(defaultSlot({})) : import_xe_utils103.default.toValueString(content))
        ])
      ]);
    };
    $xeTip.renderVN = renderVN;
    return $xeTip;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/src/use/widget-prop-data-source.js
function useWidgetPropDataSource(props, renderConfig) {
  const renConf = Object.assign({}, renderConfig);
  const isSubOption = renConf.isSubOption;
  const optionsContent = ref("");
  const expandIndexList = ref([]);
  const addOptionEvent = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const options = widget.options.options || [];
    options.push({
      value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [options.length + 1])
    });
    widget.options.options = [...options];
  };
  const subRE = /^(\s|\t)+/;
  const hasSubOption = (str) => {
    return subRE.test(str);
  };
  const expandAllOption = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const options = widget.options.options || [];
    const indexList = [];
    options.forEach((group, gIndex) => {
      const { options: options2 } = group;
      if (options2 && options2.length) {
        indexList.push(gIndex);
      }
    });
    expandIndexList.value = indexList;
  };
  const toggleExpandOption = (item, gIndex) => {
    if (expandIndexList.value.includes(gIndex)) {
      expandIndexList.value = expandIndexList.value.filter((num) => num !== gIndex);
    } else {
      expandIndexList.value.push(gIndex);
    }
  };
  const removeOptionEvent = (item, group) => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const { options } = widget;
    if (group) {
      if (group.options) {
        group.options = group.options.filter((obj) => obj !== item);
      }
    } else {
      options.options = options.options.filter((obj) => obj !== item);
    }
  };
  const confirmBatchAddOptionEvent = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const optList = [];
    const rowList = optionsContent.value.split("\n");
    let prevGroup = null;
    if (isSubOption) {
      rowList.forEach((str, index2) => {
        const nextStr = rowList[index2 + 1];
        const value = str.trim();
        if (!value) {
          return;
        }
        const item = {
          value
        };
        if (prevGroup) {
          if (hasSubOption(str)) {
            prevGroup.options.push(item);
            return;
          }
          prevGroup = null;
          optList.push(item);
        } else {
          optList.push(item);
        }
        if (nextStr) {
          if (hasSubOption(nextStr)) {
            prevGroup = Object.assign(item, { options: [] });
          }
        }
      });
    } else {
      rowList.forEach((str) => {
        optList.push({
          value: str.trim()
        });
      });
    }
    widget.options.options = optList;
    expandAllOption();
  };
  const openPopupEditEvent = () => {
    var _a2;
    const { renderParams } = props;
    const { widget } = renderParams;
    const contList = [];
    (_a2 = widget.options.options) === null || _a2 === void 0 ? void 0 : _a2.forEach((group) => {
      var _a3;
      contList.push(group.value);
      (_a3 = group.options) === null || _a3 === void 0 ? void 0 : _a3.forEach((item) => {
        contList.push(`	${item.value}`);
      });
    });
    optionsContent.value = contList.join("\n");
    VxeUI.modal.open({
      title: `${widget.title} - ${getI18n("vxe.formDesign.widgetProp.dataSource.batchEditOption")}`,
      width: 500,
      height: "50vh ",
      resize: true,
      showFooter: true,
      showCancelButton: true,
      showConfirmButton: true,
      confirmButtonText: getI18n("vxe.formDesign.widgetProp.dataSource.buildOption"),
      onConfirm: confirmBatchAddOptionEvent,
      slots: {
        default() {
          return h("div", {
            class: "vxe-form-design--widget-form-item-data-source-popup"
          }, [
            h(tip_default, {
              status: "primary",
              title: "",
              content: getI18n(`vxe.formDesign.widgetProp.dataSource.${isSubOption ? "batchEditSubTip" : "batchEditTip"}`)
            }),
            h(textarea_default, {
              resize: "none",
              modelValue: optionsContent.value,
              "onUpdate:modelValue"(val) {
                optionsContent.value = val;
              }
            })
          ]);
        }
      }
    });
  };
  const renderOption = (item, group, isExpand, gIndex, hasSub, isFirst, isLast) => {
    const hasFirstLevel = !group;
    return h("div", {
      class: ["vxe-form-design--widget-form-item-data-source-option", {
        "is--first": isFirst,
        "is--last": isLast
      }]
    }, [
      h("div", {
        class: "vxe-form-design--widget-expand-btn"
      }, hasFirstLevel && hasSub ? [
        h("i", {
          class: isExpand ? getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_CLOSE : getIcon().FORM_DESIGN_WIDGET_OPTION_EXPAND_OPEN,
          onClick() {
            toggleExpandOption(item, gIndex);
          }
        })
      ] : []),
      h("input", {
        class: "vxe-default-input",
        value: item.value,
        onInput(evnt) {
          item.value = evnt.target.value;
        }
      }),
      h(button_default, {
        status: "danger",
        mode: "text",
        icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
        onClick() {
          removeOptionEvent(item, group);
        }
      })
    ]);
  };
  const renderOptions = () => {
    const { renderParams } = props;
    const { widget } = renderParams;
    const { options } = widget;
    const groups = options.options;
    const optVNs = [];
    if (groups) {
      groups.forEach((group, gIndex) => {
        const { options: options2 } = group;
        const isExpand = expandIndexList.value.includes(gIndex);
        if (options2 && options2.length) {
          optVNs.push(renderOption(group, null, isExpand, gIndex, true, gIndex === 0, gIndex === groups.length - 1));
          if (isExpand) {
            optVNs.push(h("div", {
              class: "vxe-form-design--widget-form-item-data-source-sub-option"
            }, options2.map((item) => renderOption(item, group, isExpand, 0, false, false, false))));
          }
        } else {
          optVNs.push(renderOption(group, null, isExpand, gIndex, false, gIndex === 0, gIndex === groups.length - 1));
        }
      });
    }
    return optVNs;
  };
  watch(() => props.renderParams.widget, () => {
    expandAllOption();
  });
  onMounted(() => {
    expandAllOption();
  });
  const renderDataSourceFormItemContent = () => {
    return [
      h("div", {}, [
        h(button_default, {
          status: "primary",
          mode: "text",
          content: getI18n("vxe.formDesign.widgetProp.dataSource.addOption"),
          onClick: addOptionEvent
        }),
        h(button_default, {
          status: "primary",
          mode: "text",
          content: getI18n("vxe.formDesign.widgetProp.dataSource.batchEditOption"),
          onClick: openPopupEditEvent
        })
      ]),
      h("div", {
        class: "vxe-form-design--widget-form-item-data-source-wrapper"
      }, renderOptions())
    ];
  };
  return {
    renderDataSourceFormItem() {
      return h(form_item_default, {
        title: getI18n("vxe.formDesign.widgetProp.dataSource.name"),
        field: "options"
      }, {
        default() {
          return renderDataSourceFormItemContent();
        }
      });
    },
    renderDataSourceFormItemContent
  };
}

// node_modules/vxe-pc-ui/es/form-design/render/util.js
var getFormDesignWidgetName = (name) => {
  return getI18n(`vxe.formDesign.widget.component.${name}`);
};
var handleGetFormDesignWidgetName = (params) => {
  return getFormDesignWidgetName(params.name);
};

// node_modules/vxe-pc-ui/es/form-design/widget-text/text-data.js
var getWidgetTextConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-text",
    group: "layout",
    options: {
      color: "",
      align: "",
      bold: false,
      fontSize: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-text/text-form.js
var import_xe_utils104 = __toESM(require_xe_utils());
var getFontSizeOptions = () => {
  return import_xe_utils104.default.range(12, 27).map((num) => {
    return { label: `${num}px`, value: `${num}px` };
  });
};
var getAlignOptions2 = () => {
  return [
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignLeft"), value: "" },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignCenter"), value: "center" },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.alignRight"), value: "right" }
  ];
};
var getBoldOptions2 = () => {
  return [
    { label: getI18n("vxe.formDesign.widgetProp.textProp.fontNormal"), value: false },
    { label: getI18n("vxe.formDesign.widgetProp.textProp.fontBold"), value: true }
  ];
};
var WidgetTextFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const alignOpts = ref(getAlignOptions2());
    const boldOpts = ref(getBoldOptions2());
    const fontSizeOpts = ref(getFontSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.boldTitle"),
              field: "bold",
              itemRender: { name: "VxeRadioGroup", options: boldOpts.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.alignTitle"),
              field: "align",
              itemRender: { name: "VxeRadioGroup", options: alignOpts.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.textProp.sizeTitle"),
              field: "fontSize",
              itemRender: { name: "VxeSelect", options: fontSizeOpts.value }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-text/text-view.js
var WidgetTextViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        align: options.align
      }, {
        default() {
          return h("div", {
            style: {
              fontSize: options.fontSize,
              fontWeight: options.bold ? "bold" : ""
            }
          }, widget.title);
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-row/row-data.js
var import_xe_utils105 = __toESM(require_xe_utils());
var getWidgetRowConfig = (params) => {
  const { $formDesign } = params;
  const defaultColSize = 2;
  return {
    title: handleGetFormDesignWidgetName,
    group: "layout",
    icon: "vxe-icon-row-col",
    options: {
      colSize: defaultColSize,
      colSpan: "12,12"
    },
    children: $formDesign ? import_xe_utils105.default.range(0, defaultColSize).map(() => {
      return $formDesign.createEmptyWidget();
    }) : []
  };
};

// node_modules/vxe-pc-ui/es/row/src/row.js
var import_xe_utils106 = __toESM(require_xe_utils());
var row_default = defineComponent({
  name: "VxeRow",
  props: {
    gutter: [Number, String, Array],
    wrap: {
      type: Boolean,
      default: () => getConfig().row.wrap
    },
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().row.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils106.default.uniqueId();
    useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeRowStyle = computed(() => {
      const { gutter, vertical } = props;
      const style = {};
      if (gutter) {
        let [lrGutter, tbGutter] = import_xe_utils106.default.isArray(gutter) ? gutter : [gutter];
        if (vertical) {
          tbGutter = lrGutter;
          lrGutter = "";
        }
        if (lrGutter) {
          const offsetSize = import_xe_utils106.default.isNumber(lrGutter) ? toCssUnit(-(lrGutter / 2)) : `calc(${toCssUnit(lrGutter)} / 2 * -1)`;
          style.marginLeft = offsetSize;
          style.marginRight = offsetSize;
        }
        if (tbGutter) {
          const offsetSize = import_xe_utils106.default.isNumber(tbGutter) ? toCssUnit(-(tbGutter / 2)) : `calc(${toCssUnit(tbGutter)} / 2 * -1)`;
          style.marginTop = offsetSize;
          style.marginBottom = offsetSize;
        }
      }
      return style;
    });
    const computeMaps = {};
    const $xeRow = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const clickEvent = (evnt) => {
      dispatchEvent2("click", {}, evnt);
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $row: $xeRow }, params));
    };
    const rowMethods = {
      dispatchEvent: dispatchEvent2
    };
    const rowPrivateMethods = {};
    Object.assign($xeRow, rowMethods, rowPrivateMethods);
    const renderVN = () => {
      const { vertical, wrap } = props;
      const rowStyle = computeRowStyle.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-row", {
          "is--vertical": vertical,
          "is--wrap": wrap
        }],
        style: rowStyle,
        onClick: clickEvent
      }, defaultSlot ? defaultSlot({}) : []);
    };
    provide("$xeRow", $xeRow);
    $xeRow.renderVN = renderVN;
    return $xeRow;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-row/row-form.js
var import_xe_utils107 = __toESM(require_xe_utils());
var WidgetRowFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { computeKebabCaseName } = useWidgetName(props);
    const spanOptions = ref([
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col2"),
        value: 2,
        list: [
          { value: "12,12", spans: [12, 12] },
          { value: "8,16", spans: [8, 16] },
          { value: "16,8", spans: [16, 8] },
          { value: "6,18", spans: [6, 18] },
          { value: "18,6", spans: [18, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col3"),
        value: 3,
        list: [
          { value: "8,8,8", spans: [8, 8, 8] },
          { value: "6,6,12", spans: [6, 6, 12] },
          { value: "12,6,6", spans: [12, 6, 6] },
          { value: "6,12,6", spans: [6, 12, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col4"),
        value: 4,
        list: [
          { value: "6,6,6,6", spans: [6, 6, 6, 6] }
        ]
      },
      {
        label: getI18n("vxe.formDesign.widgetProp.rowProp.col6"),
        value: 6,
        list: [
          { value: "4,4,4,4,4,4", spans: [4, 4, 4, 4, 4, 4] }
        ]
      }
    ]);
    const labelMaps = {
      18: "3/4",
      16: "2/3",
      12: "1/2",
      8: "1/3",
      6: "1/4",
      4: "1/6"
    };
    const computeSelectSpanItem = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      return spanOptions.value.find((item) => item.value === options.colSize);
    });
    const changeColSpan = (item) => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { reactData: formDesignReactData } = $xeFormDesign;
      const { widgetObjList } = formDesignReactData;
      const oldChildList = widget.children.filter((item2) => item2.name);
      const overList = oldChildList.slice(options.colSize);
      if (overList.length) {
        const rest = import_xe_utils107.default.findTree(widgetObjList, (obj) => obj.id === widget.id, { children: "children" });
        if (rest) {
          const { items, index: index2 } = rest;
          if (index2 >= items.length - 1) {
            items.push(...overList);
          } else {
            items.splice(index2 + 1, 0, ...overList);
          }
        }
      }
      options.colSpan = item.value;
      widget.children = import_xe_utils107.default.range(0, options.colSize).map((num, index2) => {
        return oldChildList[index2] || $xeFormDesign.createEmptyWidget();
      });
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.rowProp.colSize"),
              field: "colSize",
              itemRender: { name: "VxeRadioGroup", options: spanOptions.value, props: { type: "button" } }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.rowProp.layout")
            }, {
              default() {
                const selectSpanItem = computeSelectSpanItem.value;
                if (selectSpanItem) {
                  return selectSpanItem.list.map((item, rIndex) => {
                    return h(row_default, {
                      key: rIndex,
                      class: [`vxe-form-design--widget-${kebabCaseName}-form-row`, {
                        "is--active": item.value === widget.options.colSpan
                      }],
                      onClick() {
                        changeColSpan(item);
                      }
                    }, {
                      default() {
                        return item.spans.map((span, sIndex) => {
                          return h(col_default, {
                            key: `${rIndex}${sIndex}`,
                            class: `vxe-form-design--widget-${kebabCaseName}-form-col`,
                            span
                          }, {
                            default() {
                              return h("div", {}, `${labelMaps[span]}`);
                            }
                          });
                        });
                      }
                    });
                  });
                }
                return [];
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-row/row-view.js
var import_xe_utils108 = __toESM(require_xe_utils());
var ViewColItemComponent = defineComponent({
  name: "ViewColItem",
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    span: Number,
    colItemIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const handleDragstartColItemEvent = (evnt) => {
      evnt.stopPropagation();
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetId = divEl.getAttribute("data-widget-id") || "";
      const dragWidget = $xeFormDesign.getWidgetById(widgetId);
      if (dataTransfer) {
        dataTransfer.setData("text/plain", widgetId);
      }
      formDesignReactData.sortWidget = dragWidget;
      formDesignReactData.dragWidget = null;
    };
    const sortDragenterColItemEvent = (evnt) => {
      const { parentWidget, colItemIndex } = props;
      const { widgetObjList, sortWidget } = formDesignReactData;
      const targetWidget = parentWidget.children[colItemIndex];
      const formDesignInternalData = $xeFormDesign.internalData;
      evnt.stopPropagation();
      if (sortWidget && parentWidget && sortWidget.id !== parentWidget.id) {
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        if (!hasFormDesignLayoutType(targetWidget)) {
          const currRest = import_xe_utils108.default.findTree(widgetObjList, (item) => item && item.id === sortWidget.id, { children: "children" });
          if (currRest) {
            const { item, index: index2, items, parent } = currRest;
            if (parentWidget.children.length !== parentWidget.options.colSize) {
              parentWidget.children = import_xe_utils108.default.range(0, parentWidget.options.colSize).map((index3) => {
                return parentWidget.children[index3] || $xeFormDesign.createEmptyWidget();
              });
            }
            if (parent && parent.id === parentWidget.id) {
              parentWidget.children[colItemIndex] = item;
              parentWidget.children[index2] = targetWidget;
            } else {
              if (targetWidget && targetWidget.name) {
                return;
              }
              parentWidget.children[colItemIndex] = item;
              items.splice(index2, 1);
            }
            evnt.preventDefault();
            formDesignInternalData.lastDragTime = Date.now();
            $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
          }
        }
      }
    };
    return () => {
      const { widget, span } = props;
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      return h(form_item_default, {
        span,
        padding: false
      }, {
        default() {
          const name = widget ? widget.name : "";
          const compConf = renderer.get(name) || {};
          const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
          const renderOpts = widget || { name };
          const params = { widget, readonly: false, disabled: false, isEditMode: true, isViewMode: false, $formDesign: $xeFormDesign, $formView: null };
          const isActive = activeWidget && widget && activeWidget.id === widget.id;
          const isEmptyWidget = !renderWidgetDesignView;
          return h("div", {
            class: "vxe-form-design--widget-row-view",
            "data-widget-id": widget.id,
            draggable: !isEmptyWidget,
            onDragstart: handleDragstartColItemEvent,
            onDragenter: sortDragenterColItemEvent,
            onClick(evnt) {
              if (widget) {
                $xeFormDesign.handleClickWidget(evnt, widget);
              }
            }
          }, [
            h("div", {
              class: ["vxe-form-design--widget-row-view-item-inner", {
                "is--empty": isEmptyWidget,
                "is--active": isActive,
                "is--sort": sortWidget && widget && sortWidget.id === widget.id,
                "is--drag": dragWidget && widget && dragWidget.id === widget.id
              }]
            }, [
              renderWidgetDesignView ? h("div", {
                class: "vxe-form-design--widget-row-view-item-wrapper"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-row-view-item-box vxe-form--item-row"
                }, getSlotVNs2(renderWidgetDesignView(renderOpts, params))),
                isActive ? h("div", {
                  class: "vxe-form-design--preview-item-operate"
                }, [
                  h(button_default, {
                    icon: getIcon().FORM_DESIGN_WIDGET_COPY,
                    status: "primary",
                    size: "mini",
                    circle: true,
                    onClick(params2) {
                      $xeFormDesign.handleCopyWidget(params2.$event, widget);
                    }
                  }),
                  h(button_default, {
                    icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
                    status: "danger",
                    size: "mini",
                    circle: true,
                    onClick(params2) {
                      $xeFormDesign.handleRemoveWidget(params2.$event, widget);
                    }
                  })
                ]) : createCommentVNode()
              ]) : h("div", {
                class: "vxe-form-design--widget-row-view-empty"
              }, "控件位置")
            ])
          ]);
        }
      });
    };
  }
});
var WidgetRowEditComponent = defineComponent({
  name: "WidgetRowEdit",
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const computedColObjList = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { colSpan } = options;
      const colList = colSpan ? `${colSpan}`.split(",") : [];
      const rest = colList.map((span) => Number(span));
      return rest;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      return h(form_group_default, {
        field: widget.field
      }, {
        default() {
          const colObjList = computedColObjList.value;
          return colObjList.map((span, colItemIndex) => {
            return h(ViewColItemComponent, {
              key: colItemIndex,
              parentWidget: widget,
              widget: widget.children[colItemIndex],
              span,
              colItemIndex
            });
          });
        }
      });
    };
  }
});
var WidgetRowViewComponent = defineComponent({
  name: "WidgetRowView",
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const $xeFormView = inject("$xeFormView", null);
    const computedColObjList = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const { colSpan } = options;
      const colList = colSpan ? `${colSpan}`.split(",") : [];
      const rest = colList.map((span) => Number(span));
      return rest;
    });
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const colObjList = computedColObjList.value;
      return h(row_default, {}, {
        default() {
          return colObjList.map((span, colItemIndex) => {
            return h(col_default, {
              key: colItemIndex,
              class: "vxe-form--item-row",
              span
            }, {
              default() {
                const subWidget = widget.children[colItemIndex];
                if (subWidget) {
                  const { name } = subWidget;
                  const compConf = renderer.get(name) || {};
                  const renderWidgetDesignView = compConf.renderFormDesignWidgetView;
                  const renderOpts = subWidget;
                  const isEditMode = !!$xeFormDesign;
                  const params = { widget: subWidget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: $xeFormView };
                  if (renderWidgetDesignView) {
                    return getSlotVNs2(renderWidgetDesignView(renderOpts, params));
                  }
                }
                return createCommentVNode();
              }
            });
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-data.js
var getWidgetSubtableConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    group: "layout",
    icon: "vxe-icon-subtable",
    options: {
      showCheckbox: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-form.js
var WidgetSubtableFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: `vxe-form-design--widget-${kebabCaseName}-form`,
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.subtableProp.showCheckbox"),
              field: "showCheckbox"
            }, {
              default() {
                return h(switch_default, {
                  modelValue: options.showCheckbox,
                  "onUpdate:modelValue"(val) {
                    options.showCheckbox = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-subtable/subtable-view.js
var import_xe_utils109 = __toESM(require_xe_utils());
var ViewSubItemComponent = defineComponent({
  props: {
    parentWidget: {
      type: Object,
      default: () => ({})
    },
    widget: {
      type: Object,
      default: () => ({})
    },
    childIndex: {
      type: Number,
      default: 0
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    const $xeFormView = inject("$xeFormView", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const sortDragstartSubItemEvent = (evnt) => {
      evnt.stopPropagation();
      const divEl = evnt.currentTarget;
      const dataTransfer = evnt.dataTransfer;
      const widgetId = divEl.getAttribute("data-widget-id") || "";
      const dragWidget = $xeFormDesign.getWidgetById(widgetId);
      if (dataTransfer) {
        dataTransfer.setData("text/plain", widgetId);
      }
      formDesignReactData.sortWidget = dragWidget;
      formDesignReactData.dragWidget = null;
    };
    const sortDragenterSubItemEvent = (evnt) => {
      const { parentWidget, childIndex } = props;
      const { widgetObjList, sortWidget } = formDesignReactData;
      const targetWidget = parentWidget.children[childIndex];
      const formDesignInternalData = $xeFormDesign.internalData;
      const { lastDragTime } = formDesignInternalData;
      evnt.stopPropagation();
      if (lastDragTime && lastDragTime > Date.now() - 300) {
        evnt.preventDefault();
        return;
      }
      if (sortWidget && targetWidget && parentWidget) {
        if (sortWidget.id === parentWidget.id) {
          return;
        }
        if (sortWidget.id === targetWidget.id) {
          return;
        }
        if (hasFormDesignLayoutType(sortWidget)) {
          return;
        }
        if (targetWidget && !hasFormDesignLayoutType(targetWidget)) {
          const currRest = import_xe_utils109.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
          if (currRest) {
            const { item, index: index2, items, parent } = currRest;
            if (parent && parent.id === parentWidget.id) {
              parentWidget.children[childIndex] = item;
              parentWidget.children[index2] = targetWidget;
            } else {
              parentWidget.children.splice(childIndex, 0, item);
              items.splice(index2, 1);
            }
            formDesignInternalData.lastDragTime = Date.now();
            $xeFormDesign.dispatchEvent("drag-widget", { widget: item }, evnt);
          }
        }
      }
    };
    return () => {
      const { widget } = props;
      const { dragWidget, activeWidget, sortWidget } = formDesignReactData;
      const name = widget ? widget.name : "";
      const compConf = renderer.get(name) || {};
      const renderSubtableView = compConf.renderFormDesignWidgetSubtableEditView || compConf.renderFormDesignWidgetSubtableCellView || compConf.renderFormDesignWidgetSubtableDefaultView;
      const renderWidgetDesignView = compConf.renderFormDesignWidgetEdit || compConf.renderFormDesignWidgetView;
      const renderOpts = widget || { name };
      const isEditMode = !!$xeFormDesign;
      const defParams = { widget, readonly: false, disabled: false, isEditMode, isViewMode: !isEditMode, $formDesign: $xeFormDesign, $formView: $xeFormView };
      const isActive = activeWidget && widget && activeWidget.id === widget.id;
      const subOpts = { name };
      const subParams = {
        $table: null,
        $grid: null,
        seq: "",
        column: {
          field: widget.field,
          title: widget.title
        },
        columnIndex: 0,
        $columnIndex: 0,
        _columnIndex: 0,
        rowid: "",
        row: {},
        rowIndex: 0,
        $rowIndex: 0,
        _rowIndex: 0,
        isEdit: false,
        isHidden: false,
        fixed: null,
        type: "",
        level: 1,
        visibleData: [],
        items: [],
        data: [],
        widget
      };
      return h("div", {
        class: ["vxe-form-design--widget-subtable-view-item", {
          "is--active": isActive,
          "is--sort": sortWidget && widget && sortWidget.id === widget.id,
          "is--drag": dragWidget && widget && dragWidget.id === widget.id
        }],
        draggable: true,
        "data-widget-id": widget.id,
        onDragstart: sortDragstartSubItemEvent,
        onDragenter: sortDragenterSubItemEvent,
        onClick(evnt) {
          if (widget) {
            $xeFormDesign.handleClickWidget(evnt, widget);
          }
        }
      }, [
        h("div", {
          class: "vxe-form-design--widget-subtable-view-item-wrapper"
        }, [
          h("div", {
            class: "vxe-form-design--widget-subtable-view-item-box vxe-form--item-row"
          }, renderSubtableView ? h(form_item_default, {
            class: ["vxe-form-design--widget-render-form-item"],
            title: widget.title,
            field: widget.field,
            itemRender: {}
          }, {
            default() {
              return getSlotVNs2(renderSubtableView(subOpts, subParams));
            }
          }) : renderWidgetDesignView ? getSlotVNs2(renderWidgetDesignView(renderOpts, defParams)) : []),
          isActive ? h("div", {
            class: "vxe-form-design--preview-item-operate"
          }, [
            h(button_default, {
              icon: getIcon().FORM_DESIGN_WIDGET_COPY,
              status: "primary",
              size: "mini",
              circle: true,
              onClick(params) {
                $xeFormDesign.handleCopyWidget(params.$event, widget);
              }
            }),
            h(button_default, {
              icon: getIcon().FORM_DESIGN_WIDGET_DELETE,
              status: "danger",
              size: "mini",
              circle: true,
              onClick(params) {
                $xeFormDesign.handleRemoveWidget(params.$event, widget);
              }
            })
          ]) : createCommentVNode()
        ])
      ]);
    };
  }
});
var WidgetSubtableEditComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormDesign = inject("$xeFormDesign", null);
    if (!$xeFormDesign) {
      return () => [];
    }
    const { reactData: formDesignReactData } = $xeFormDesign;
    const handleDragoverWrapperEvent = (evnt) => {
      const { sortWidget, widgetObjList } = formDesignReactData;
      const { renderParams } = props;
      const { widget } = renderParams;
      evnt.stopPropagation();
      if (!sortWidget || !widget || widget.id === sortWidget.id) {
        return;
      }
      if (hasFormDesignLayoutType(sortWidget)) {
        if (VxeUI.modal) {
          VxeUI.modal.message({
            content: getI18n("vxe.formDesign.widgetProp.subtableProp.errSubDrag"),
            status: "error",
            id: "errSubDrag"
          });
        }
        return;
      }
      if (widget.name && !widget.children.some((item) => item.id === sortWidget.id)) {
        const rest = import_xe_utils109.default.findTree(widgetObjList, (item) => item.id === sortWidget.id, { children: "children" });
        if (rest) {
          const { item, index: index2, items } = rest;
          formDesignReactData.sortWidget = null;
          formDesignReactData.activeWidget = item;
          widget.children.push(item);
          items.splice(index2, 1);
          formDesignReactData.sortWidget = item;
        }
      }
    };
    const handleDragenterWrapperEvent = (evnt) => {
      evnt.stopPropagation();
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { title, children, options } = widget;
      const { showCheckbox } = options;
      return h(form_item_default, {
        title,
        className: "vxe-form-design--widget-subtable-form-item"
      }, {
        default() {
          return h("div", {
            class: "vxe-form-design--widget-subtable-view",
            onDragenter: handleDragenterWrapperEvent,
            onDragover: handleDragoverWrapperEvent
          }, [
            h("div", {
              class: "vxe-form-design--widget-subtable-view-left"
            }, [
              showCheckbox ? h("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, [
                  h(checkbox_default)
                ]),
                h("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, [
                  h(checkbox_default)
                ])
              ]) : createCommentVNode(),
              h("div", {
                class: "vxe-form-design--widget-subtable-col"
              }, [
                h("div", {
                  class: "vxe-form-design--widget-subtable-head"
                }, getI18n("vxe.formDesign.widgetProp.subtableProp.seqTitle")),
                h("div", {
                  class: "vxe-form-design--widget-subtable-body"
                }, "1")
              ])
            ]),
            h("div", {
              class: "vxe-form-design--widget-subtable-view-right"
            }, [
              h("div", {
                class: "vxe-form-design--widget-subtable-view-wrapper"
              }, [
                h(TransitionGroup, {
                  class: "vxe-form-design--widget-subtable-view-list",
                  tag: "div",
                  name: "vxe-form-design--widget-subtable-view-list"
                }, {
                  default: () => {
                    return children ? children.map((childWidget, childIndex) => {
                      return h(ViewSubItemComponent, {
                        key: childWidget.id,
                        parentWidget: widget,
                        widget: childWidget,
                        childIndex
                      });
                    }) : [];
                  }
                }),
                h("div", {
                  key: "empty",
                  class: "vxe-form-design--widget-subtable-view-empty"
                }, getI18n("vxe.formDesign.widgetProp.subtableProp.colPlace"))
              ])
            ])
          ]);
        }
      });
    };
  }
});
var WidgetSubtableViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const refGrid = ref();
    const defaultDataList = ref([
      {}
    ]);
    const computeFormReadonly = computed(() => {
      if ($xeFormView) {
        return $xeFormView.props.readonly;
      }
      return false;
    });
    const computeSubtableColumns = computed(() => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { children, options } = widget;
      const formReadonly = computeFormReadonly.value;
      const columns = [];
      if (options.showCheckbox) {
        columns.push({
          type: "checkbox",
          width: 60,
          fixed: "left"
        });
      }
      columns.push({
        type: "seq",
        width: 60,
        fixed: "left"
      });
      if (children) {
        children.forEach((childWidget) => {
          const { name } = childWidget;
          const compConf = renderer.get(name) || {};
          const parseSubtableColumn = compConf.parseFormDesignWidgetSubtableColumn;
          let colConf = {
            field: childWidget.field,
            title: childWidget.title
          };
          if (parseSubtableColumn) {
            colConf = Object.assign(colConf, parseSubtableColumn({
              $formView: $xeFormView,
              name: childWidget.name,
              widget: childWidget,
              readonly: !!formReadonly
            }));
          } else {
            if (formReadonly) {
              colConf.cellRender = {
                name: childWidget.name,
                props: childWidget.options
              };
            } else {
              colConf.editRender = {
                name: childWidget.name,
                props: childWidget.options
              };
            }
          }
          const renderSubtableDefaultView = compConf.renderFormDesignWidgetSubtableDefaultView;
          const renderSubtableCellView = compConf.renderFormDesignWidgetSubtableCellView || renderSubtableDefaultView;
          const renderSubtableEditView = compConf.renderFormDesignWidgetSubtableEditView;
          const colSlots = {};
          if (renderSubtableDefaultView || renderSubtableCellView) {
            colSlots.default = (slotParams) => {
              const { isEdit, column } = slotParams;
              const { editRender, cellRender } = column;
              const params = Object.assign({ widget: childWidget }, slotParams);
              if (isEdit && editRender) {
                if (renderSubtableCellView) {
                  return getSlotVNs2(renderSubtableCellView(editRender, params));
                }
              }
              if (renderSubtableDefaultView) {
                return getSlotVNs2(renderSubtableDefaultView(cellRender || {}, params));
              }
              return [];
            };
          }
          if (renderSubtableEditView) {
            colSlots.edit = (slotParams) => {
              const { column } = slotParams;
              const { editRender } = column;
              const params = Object.assign({ widget: childWidget }, slotParams);
              return getSlotVNs2(renderSubtableEditView(editRender, params));
            };
          }
          colConf.slots = colSlots;
          columns.push(colConf);
        });
      }
      if (!formReadonly) {
        columns.push({
          field: "action",
          title: "操作",
          fixed: "right",
          width: 80,
          slots: {
            default({ row }) {
              return h(button_default, {
                mode: "text",
                icon: "vxe-icon-delete",
                status: "error",
                onClick() {
                  removeSubRow(row);
                }
              });
            }
          }
        });
      }
      return columns;
    });
    const computeGridOptions = computed(() => {
      const { renderParams } = props;
      const { widget, isEditMode } = renderParams;
      const subtableColumns = computeSubtableColumns.value;
      const formReadonly = computeFormReadonly.value;
      const gridConf = {
        border: true,
        showOverflow: true,
        height: 300,
        columnConfig: {
          resizable: true,
          minWidth: 140
        },
        rowConfig: {
          keyField: "_id"
        },
        data: isEditMode ? defaultDataList.value : $xeFormView ? $xeFormView.getItemValue(widget) : null,
        columns: subtableColumns,
        toolbarConfig: {
          zoom: true,
          custom: false,
          slots: {
            buttons: "toolbarButtons"
          }
        }
      };
      if (!formReadonly) {
        gridConf.keepSource = true;
        gridConf.editConfig = {
          mode: "row",
          trigger: "click",
          showStatus: true
        };
      }
      return gridConf;
    });
    const getSubRecord = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const record = {
        _id: Date.now()
      };
      import_xe_utils109.default.each(widget.children, (childWidget) => {
        record[childWidget.field] = null;
      });
      return record;
    };
    const addSubRowEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        let list = $xeFormView.getItemValue(widget);
        if (!import_xe_utils109.default.isArray(list)) {
          list = [];
        }
        const newRow = getSubRecord();
        list.unshift(newRow);
        $xeFormView.setItemValue(widget, list.slice(0)).then(() => {
          return nextTick().then(() => {
            const $grid = refGrid.value;
            if ($grid) {
              $grid.setEditRow(newRow);
            }
          });
        });
      }
    };
    const removeSubRow = (row) => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const list = $xeFormView.getItemValue(widget);
        if (list) {
          $xeFormView.setItemValue(widget, list.filter((item) => item._id !== row._id));
        }
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      const gridOptions = computeGridOptions.value;
      const formReadonly = computeFormReadonly.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        span: 24
      }, {
        default() {
          return VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign(Object.assign({}, gridOptions), { ref: refGrid }), {
            toolbarButtons() {
              return formReadonly ? [] : [
                h(button_default, {
                  content: "新增",
                  icon: "vxe-icon-add",
                  status: "primary",
                  onClick: addSubRowEvent
                })
              ];
            }
          }) : createCommentVNode();
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-input/input-data.js
var getWidgetInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-input",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-input/input-form.js
var WidgetInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-input/input-view.js
var WidgetInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h("input", {
            class: "vxe-default-input",
            type: "text",
            placeholder: options.placeholder || getI18n("vxe.base.pleaseInput"),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-data.js
var getWidgetTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-textarea",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-form.js
var WidgetTextareaFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-textarea/textarea-view.js
var WidgetTextareaViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h("textarea", {
            class: "vxe-default-textarea",
            placeholder: options.placeholder || getI18n("vxe.base.pleaseInput"),
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            onInput(evnt) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, evnt.target.value);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-select/select-data.js
var import_xe_utils110 = __toESM(require_xe_utils());
var getWidgetSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-select",
    query: true,
    options: {
      options: import_xe_utils110.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-select/select-form.js
var WidgetSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: true
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-select/select-view.js
var WidgetSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    const renderOptions = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget.options;
      return options ? options.map((group) => {
        if (group.options) {
          return h("optgroup", {
            label: group.value
          }, group.options.map((item) => {
            return h("option", {
              value: item.value
            }, item.value);
          }));
        }
        return h("option", {}, group.value);
      }) : [];
    };
    return () => {
      const { renderParams } = props;
      const { widget, isViewMode } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h("select", {
            class: "vxe-default-select",
            value: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent
          }, isViewMode ? renderOptions() : []);
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-data.js
var getWidgetVxeInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-input",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-form.js
var WidgetVxeInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-input/vxe-input-view.js
var WidgetVxeInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(input_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-data.js
var getWidgetVxeNumberInputConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-number",
    query: true,
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-form.js
var WidgetVxeNumberInputFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/number-input/src/number-input.js
var import_xe_utils111 = __toESM(require_xe_utils());
var number_input_default = defineComponent({
  name: "VxeNumberInput",
  props: {
    modelValue: [String, Number],
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    type: {
      type: String,
      default: "number"
    },
    clearable: {
      type: Boolean,
      default: () => getConfig().numberInput.clearable
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    placeholder: String,
    maxLength: [String, Number],
    autoComplete: {
      type: String,
      default: "off"
    },
    align: String,
    form: String,
    className: String,
    size: {
      type: String,
      default: () => getConfig().numberInput.size || getConfig().size
    },
    multiple: Boolean,
    // number、integer、float
    min: {
      type: [String, Number],
      default: null
    },
    max: {
      type: [String, Number],
      default: null
    },
    step: [String, Number],
    exponential: {
      type: Boolean,
      default: () => getConfig().numberInput.exponential
    },
    showCurrency: {
      type: Boolean,
      default: () => getConfig().numberInput.showCurrency
    },
    currencySymbol: {
      type: String,
      default: () => getConfig().numberInput.currencySymbol
    },
    // number、integer、float
    controls: {
      type: Boolean,
      default: () => getConfig().numberInput.controls
    },
    // float
    digits: {
      type: [String, Number],
      default: null
    },
    prefixIcon: String,
    suffixIcon: String,
    // 已废弃
    maxlength: [String, Number],
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "keydown",
    "keyup",
    "wheel",
    "click",
    "focus",
    "blur",
    "clear",
    "prev-number",
    "next-number",
    "prefix-click",
    "suffix-click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils111.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      isFocus: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const internalData = {
      // dnTimeout: undefined,
      // isUM: undefined
    };
    const refElem = ref();
    const refInputTarget = ref();
    const refInputPanel = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xeNumberInput = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let numberInputMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeDigitsValue = computed(() => {
      const { type, digits } = props;
      let defDigits = digits;
      if (defDigits === null) {
        defDigits = getConfig().numberInput.digits;
        if (defDigits === null) {
          if (type === "amount") {
            defDigits = 2;
          }
        }
      }
      return import_xe_utils111.default.toInteger(defDigits) || 1;
    });
    const computeDecimalsType = computed(() => {
      const { type } = props;
      return type === "float" || type === "amount";
    });
    const computeStepValue = computed(() => {
      const { type } = props;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      const step = props.step;
      if (type === "integer") {
        return import_xe_utils111.default.toInteger(step) || 1;
      } else if (decimalsType) {
        return import_xe_utils111.default.toNumber(step) || 1 / Math.pow(10, digitsValue);
      }
      return import_xe_utils111.default.toNumber(step) || 1;
    });
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInputReadonly = computed(() => {
      const { multiple } = props;
      const formReadonly = computeFormReadonly.value;
      return formReadonly || multiple;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().numberInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInpMaxLength = computed(() => {
      const { maxLength, maxlength } = props;
      return import_xe_utils111.default.toNumber(maxLength || maxlength) || 16;
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const computeNumValue = computed(() => {
      const { type } = props;
      const { inputValue } = reactData;
      return type === "integer" ? import_xe_utils111.default.toInteger(handleNumber(inputValue)) : import_xe_utils111.default.toNumber(handleNumber(inputValue));
    });
    const computeNumLabel = computed(() => {
      const { type, showCurrency, currencySymbol } = props;
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      if (type === "amount") {
        const amountLabel = import_xe_utils111.default.commafy(import_xe_utils111.default.toNumber(inputValue), { digits: digitsValue });
        if (showCurrency) {
          return `${currencySymbol || getI18n("vxe.numberInput.currencySymbol") || ""}${amountLabel}`;
        }
        return amountLabel;
      }
      return import_xe_utils111.default.toString(inputValue);
    });
    const computeIsDisabledSubtractNumber = computed(() => {
      const { min } = props;
      const { inputValue } = reactData;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && min !== null) {
        return numValue <= import_xe_utils111.default.toNumber(min);
      }
      return false;
    });
    const computeIsDisabledAddNumber = computed(() => {
      const { max } = props;
      const { inputValue } = reactData;
      const numValue = computeNumValue.value;
      if ((inputValue || inputValue === 0) && max !== null) {
        return numValue >= import_xe_utils111.default.toNumber(max);
      }
      return false;
    });
    const handleNumberString = (val) => {
      if (import_xe_utils111.default.eqNull(val)) {
        return "";
      }
      return `${val}`;
    };
    const getNumberValue = (val) => {
      const { exponential } = props;
      const inpMaxLength = computeInpMaxLength.value;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      const restVal = decimalsType ? toFloatValueFixed(val, digitsValue) : handleNumberString(val);
      if (exponential && (val === restVal || handleNumberString(val).toLowerCase() === import_xe_utils111.default.toNumber(restVal).toExponential())) {
        return val;
      }
      return restVal.slice(0, inpMaxLength);
    };
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      numberInputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const handleChange = (val, inputValue, evnt) => {
      const value = eqEmptyValue2(val) ? null : Number(val);
      const isChange = value !== props.modelValue;
      internalData.isUM = true;
      if (isChange) {
        emit("update:modelValue", value);
      }
      if (reactData.inputValue !== inputValue) {
        nextTick(() => {
          reactData.inputValue = inputValue || "";
        });
      }
      numberInputMethods.dispatchEvent("input", { value }, evnt);
      if (isChange) {
        numberInputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const emitInputEvent = (inputValue, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue === "" || import_xe_utils111.default.eqNull(inputValue) ? null : import_xe_utils111.default.toNumber(inputValue);
      reactData.inputValue = inputValue;
      if (inpImmediate) {
        handleChange(value, inputValue, evnt);
      } else {
        numberInputMethods.dispatchEvent("input", { value }, evnt);
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const changeEvent = (evnt) => {
      const inpImmediate = computeInpImmediate.value;
      if (!inpImmediate) {
        triggerEvent3(evnt);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isFocus = true;
      reactData.isActivated = true;
      triggerEvent3(evnt);
    };
    const clickPrefixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        numberInputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange(null, "", evnt);
      numberInputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const { inputValue } = reactData;
        numberInputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const updateModel = (val) => {
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (decimalsType) {
        if (val) {
          let textValue = "";
          if (val) {
            textValue = toFloatValueFixed(val, digitsValue);
          }
          if (textValue !== inputValue) {
            reactData.inputValue = textValue;
          }
        }
      }
    };
    const initValue = () => {
      const { inputValue } = reactData;
      const digitsValue = computeDigitsValue.value;
      const decimalsType = computeDecimalsType.value;
      if (decimalsType) {
        if (inputValue) {
          let textValue = "";
          let validValue = null;
          if (inputValue) {
            textValue = toFloatValueFixed(inputValue, digitsValue);
            validValue = Number(textValue);
          }
          if (inputValue !== validValue) {
            handleChange(validValue, textValue, { type: "init" });
          }
        }
      }
    };
    const validMaxNum = (num) => {
      return props.max === null || import_xe_utils111.default.toNumber(num) <= import_xe_utils111.default.toNumber(props.max);
    };
    const validMinNum = (num) => {
      return props.min === null || import_xe_utils111.default.toNumber(num) >= import_xe_utils111.default.toNumber(props.min);
    };
    const afterCheckValue = () => {
      const { type, min, max, exponential } = props;
      const { inputValue } = reactData;
      const inputReadonly = computeInputReadonly.value;
      if (!inputReadonly) {
        if (eqEmptyValue2(inputValue)) {
          let inpNumVal = null;
          let inpValue = inputValue;
          if (min || min === 0) {
            inpNumVal = import_xe_utils111.default.toNumber(min);
            inpValue = `${inpNumVal}`;
          }
          handleChange(inpNumVal, `${inpValue || ""}`, { type: "check" });
          return;
        }
        if (inputValue || (min || max)) {
          let inpNumVal = type === "integer" ? import_xe_utils111.default.toInteger(handleNumber(inputValue)) : import_xe_utils111.default.toNumber(handleNumber(inputValue));
          if (!validMinNum(inpNumVal)) {
            inpNumVal = min;
          } else if (!validMaxNum(inpNumVal)) {
            inpNumVal = max;
          }
          if (exponential) {
            const inpStringVal = handleNumberString(inputValue).toLowerCase();
            if (inpStringVal === import_xe_utils111.default.toNumber(inpNumVal).toExponential()) {
              inpNumVal = inpStringVal;
            }
          }
          const inpValue = getNumberValue(inpNumVal);
          handleChange(eqEmptyValue2(inpValue) ? null : Number(inpValue), inpValue, { type: "check" });
        }
      }
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const inpImmediate = computeInpImmediate.value;
      const value = inputValue ? Number(inputValue) : null;
      if (!inpImmediate) {
        handleChange(value, handleNumberString(inputValue), evnt);
      }
      afterCheckValue();
      reactData.isFocus = false;
      reactData.isActivated = false;
      numberInputMethods.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const numberChange = (isPlus, evnt) => {
      const { min, max, type } = props;
      const { inputValue } = reactData;
      const stepValue = computeStepValue.value;
      const numValue = type === "integer" ? import_xe_utils111.default.toInteger(handleNumber(inputValue)) : import_xe_utils111.default.toNumber(handleNumber(inputValue));
      const newValue = isPlus ? import_xe_utils111.default.add(numValue, stepValue) : import_xe_utils111.default.subtract(numValue, stepValue);
      let restNum;
      if (!validMinNum(newValue)) {
        restNum = min;
      } else if (!validMaxNum(newValue)) {
        restNum = max;
      } else {
        restNum = newValue;
      }
      emitInputEvent(getNumberValue(restNum), evnt);
    };
    const numberNextEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      numberStopDown();
      if (!isDisabled && !formReadonly && !isDisabledSubtractNumber) {
        numberChange(false, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent("next-number", { value: reactData.inputValue }, evnt);
    };
    const numberDownNextEvent = (evnt) => {
      internalData.dnTimeout = window.setTimeout(() => {
        numberNextEvent(evnt);
        numberDownNextEvent(evnt);
      }, 60);
    };
    const numberPrevEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      numberStopDown();
      if (!isDisabled && !formReadonly && !isDisabledAddNumber) {
        numberChange(true, evnt);
      }
      reactData.isActivated = true;
      numberInputMethods.dispatchEvent("prev-number", { value: reactData.inputValue }, evnt);
    };
    const numberKeydownEvent = (evnt) => {
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (isUpArrow || isDwArrow) {
        evnt.preventDefault();
        if (isUpArrow) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
      }
    };
    const keydownEvent = (evnt) => {
      const { exponential, controls } = props;
      const isCtrlKey = evnt.ctrlKey;
      const isShiftKey = evnt.shiftKey;
      const isAltKey = evnt.altKey;
      const keyCode = evnt.keyCode;
      const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      if (!isCtrlKey && !isShiftKey && !isAltKey && (globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR) || (!exponential || keyCode !== 69) && (keyCode >= 65 && keyCode <= 90) || keyCode >= 186 && keyCode <= 188 || keyCode >= 191)) {
        evnt.preventDefault();
      }
      if (isEsc) {
        afterCheckValue();
      } else if (isUpArrow || isDwArrow) {
        if (controls) {
          numberKeydownEvent(evnt);
        }
      }
      triggerEvent3(evnt);
    };
    const keyupEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const numberStopDown = () => {
      const { dnTimeout } = internalData;
      if (dnTimeout) {
        clearTimeout(dnTimeout);
        internalData.dnTimeout = void 0;
      }
    };
    const numberDownPrevEvent = (evnt) => {
      internalData.dnTimeout = window.setTimeout(() => {
        numberPrevEvent(evnt);
        numberDownPrevEvent(evnt);
      }, 60);
    };
    const numberMousedownEvent = (evnt) => {
      numberStopDown();
      if (evnt.button === 0) {
        const isPrevNumber = hasClass2(evnt.currentTarget, "is--prev");
        if (isPrevNumber) {
          numberPrevEvent(evnt);
        } else {
          numberNextEvent(evnt);
        }
        internalData.dnTimeout = window.setTimeout(() => {
          if (isPrevNumber) {
            numberDownPrevEvent(evnt);
          } else {
            numberDownNextEvent(evnt);
          }
        }, 500);
      }
    };
    const wheelEvent = (evnt) => {
      if (props.controls) {
        if (reactData.isActivated) {
          evnt.stopPropagation();
          evnt.preventDefault();
          const delta = evnt.deltaY;
          if (delta > 0) {
            numberNextEvent(evnt);
          } else if (delta < 0) {
            numberPrevEvent(evnt);
          }
        }
      }
      triggerEvent3(evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { isActivated } = reactData;
      const el2 = refElem.value;
      const panelElem = refInputPanel.value;
      const isDisabled = computeIsDisabled.value;
      const inpImmediate = computeInpImmediate.value;
      if (!isDisabled && isActivated) {
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (!reactData.isActivated) {
          if (!inpImmediate) {
            const { inputValue } = reactData;
            const value = inputValue ? Number(inputValue) : null;
            handleChange(value, handleNumberString(inputValue), evnt);
          }
          afterCheckValue();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        let isActivated = reactData.isActivated;
        if (isTab) {
          if (isActivated) {
            afterCheckValue();
          }
          isActivated = false;
          reactData.isActivated = isActivated;
        }
        if (isDel && clearable) {
          if (isActivated) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      const { isActivated } = reactData;
      if (isActivated) {
        afterCheckValue();
      }
    };
    const renderNumberIcon = () => {
      const isDisabledAddNumber = computeIsDisabledAddNumber.value;
      const isDisabledSubtractNumber = computeIsDisabledSubtractNumber.value;
      return h("div", {
        class: "vxe-input--control-icon"
      }, [
        h("div", {
          class: "vxe-input--number-icon"
        }, [
          h("div", {
            class: ["vxe-input--number-btn is--prev", {
              "is--disabled": isDisabledAddNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_PREV_NUM
            })
          ]),
          h("div", {
            class: ["vxe-input--number-btn is--next", {
              "is--disabled": isDisabledSubtractNumber
            }],
            onMousedown: numberMousedownEvent,
            onMouseup: numberStopDown,
            onMouseleave: numberStopDown
          }, [
            h("i", {
              class: getIcon().NUMBER_INPUT_NEXT_NUM
            })
          ])
        ])
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-number-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-number-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { suffixIcon } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isDisabled = computeIsDisabled.value;
      const isClearable = computeIsClearable.value;
      return h("div", {
        class: ["vxe-number-input--suffix", {
          "is--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils111.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-number-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        renderExtraSuffixIcon(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-number-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]);
    };
    const renderExtraSuffixIcon = () => {
      const { controls } = props;
      if (controls) {
        return renderNumberIcon();
      }
      return createCommentVNode();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $numberInput: $xeNumberInput }, params));
    };
    numberInputMethods = {
      dispatchEvent: dispatchEvent2,
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xeNumberInput, numberInputMethods);
    const renderVN = () => {
      const { className, controls, type, align, name, autocomplete, autoComplete } = props;
      const { inputValue, isFocus, isActivated } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const numLabel = computeNumLabel.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-number-input--readonly", `type--${type}`, className]
        }, numLabel);
      }
      const inputReadonly = computeInputReadonly.value;
      const inpMaxLength = computeInpMaxLength.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-number-input", `type--${type}`, className, {
          [`size--${vSize}`]: vSize,
          [`is--${align}`]: align,
          "is--controls": controls,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--disabled": isDisabled,
          "is--active": isActivated,
          "show--clear": isClearable && !isDisabled && !(inputValue === "" || import_xe_utils111.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-number-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-number-input--inner",
            value: !isFocus && type === "amount" ? numLabel : inputValue,
            name,
            type: "text",
            placeholder: inpPlaceholder,
            maxlength: inpMaxLength,
            readonly: inputReadonly,
            disabled: isDisabled,
            autocomplete: autoComplete || autocomplete,
            onKeydown: keydownEvent,
            onKeyup: keyupEvent,
            onWheel: wheelEvent,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode()
      ]);
    };
    $xeNumberInput.renderVN = renderVN;
    watch(() => props.modelValue, (val) => {
      if (!internalData.isUM) {
        updateModel(val);
      }
      internalData.isUM = false;
    });
    watch(() => props.type, () => {
      Object.assign(reactData, {
        inputValue: props.modelValue
      });
      initValue();
    });
    onMounted(() => {
      globalEvents.on($xeNumberInput, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeNumberInput, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeNumberInput, "blur", handleGlobalBlurEvent);
    });
    onBeforeUnmount(() => {
      reactData.isFocus = false;
      numberStopDown();
      afterCheckValue();
      globalEvents.off($xeNumberInput, "mousedown");
      globalEvents.off($xeNumberInput, "keydown");
      globalEvents.off($xeNumberInput, "blur");
    });
    initValue();
    return $xeNumberInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-number-input/vxe-number-input-view.js
var WidgetVxeNumberInputViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(number_input_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-data.js
var getWidgetVxeDatePickerConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-calendar",
    options: {
      placeholder: "",
      defaultValue: {
        type: "",
        value: ""
      }
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-form.js
var WidgetVxeDatePickerFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            // renderDefaultValueFormItem(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-date-picker/vxe-date-picker-view.js
var WidgetVxeDatePickerViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(date_picker_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-data.js
var getWidgetVxeTextareaConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-textarea",
    options: {
      placeholder: ""
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-form.js
var WidgetVxeTextareaFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-textarea/vxe-textarea-view.js
var WidgetVxeTextareaViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(textarea_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder,
            resize: "node",
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-data.js
var getWidgetVxeSwitchConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-switch",
    query: true,
    options: {}
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-form.js
var WidgetVxeSwitchFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-switch/vxe-switch-view.js
var WidgetVxeSwitchViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(switch_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-data.js
var import_xe_utils112 = __toESM(require_xe_utils());
var getWidgetVxeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-select",
    query: true,
    options: {
      placeholder: "",
      options: import_xe_utils112.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      }),
      multiple: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-form.js
var WidgetVxeSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            renderDataSourceFormItem(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-select/vxe-select-view.js
var WidgetVxeSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget, isViewMode } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(select_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || getI18n("vxe.base.pleaseSelect"),
            options: isViewMode ? options.options : [],
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-data.js
var import_xe_utils113 = __toESM(require_xe_utils());
var getWidgetVxeTreeSelectConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-tree-select",
    query: true,
    options: {
      placeholder: "",
      options: import_xe_utils113.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      }),
      multiple: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-form.js
var WidgetVxeTreeSelectFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.multiple"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
var import_xe_utils115 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/tree/src/tree.js
var import_xe_utils114 = __toESM(require_xe_utils());
function getNodeUniqueId() {
  return import_xe_utils114.default.uniqueId("node_");
}
var tree_default = defineComponent({
  name: "VxeTree",
  props: {
    data: Array,
    height: [String, Number],
    minHeight: {
      type: [String, Number],
      default: () => getConfig().tree.minHeight
    },
    loading: Boolean,
    loadingConfig: Object,
    accordion: {
      type: Boolean,
      default: () => getConfig().tree.accordion
    },
    childrenField: {
      type: String,
      default: () => getConfig().tree.childrenField
    },
    valueField: {
      type: String,
      default: () => getConfig().tree.valueField
    },
    keyField: {
      type: String,
      default: () => getConfig().tree.keyField
    },
    parentField: {
      type: String,
      default: () => getConfig().tree.parentField
    },
    titleField: {
      type: String,
      default: () => getConfig().tree.titleField
    },
    hasChildField: {
      type: String,
      default: () => getConfig().tree.hasChildField
    },
    // mapChildrenField: {
    //   type: String as PropType<VxeTreePropTypes.MapChildrenField>,
    //   default: () => getConfig().tree.mapChildrenField
    // },
    transform: Boolean,
    // 已废弃
    isCurrent: Boolean,
    // 已废弃
    isHover: Boolean,
    showLine: {
      type: Boolean,
      default: () => getConfig().tree.showLine
    },
    trigger: String,
    indent: {
      type: Number,
      default: () => getConfig().tree.indent
    },
    showRadio: {
      type: Boolean,
      default: () => getConfig().tree.showRadio
    },
    checkNodeKey: {
      type: [String, Number],
      default: () => getConfig().tree.checkNodeKey
    },
    radioConfig: Object,
    showCheckbox: {
      type: Boolean,
      default: () => getConfig().tree.showCheckbox
    },
    checkNodeKeys: {
      type: Array,
      default: () => getConfig().tree.checkNodeKeys
    },
    checkboxConfig: Object,
    nodeConfig: Object,
    lazy: Boolean,
    toggleMethod: Function,
    loadMethod: Function,
    showIcon: {
      type: Boolean,
      default: true
    },
    iconOpen: {
      type: String,
      default: () => getConfig().tree.iconOpen
    },
    iconClose: {
      type: String,
      default: () => getConfig().tree.iconClose
    },
    iconLoaded: {
      type: String,
      default: () => getConfig().tree.iconLoaded
    },
    size: {
      type: String,
      default: () => getConfig().tree.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "update:checkNodeKey",
    "update:checkNodeKeys",
    "node-click",
    "node-dblclick",
    "current-change",
    "radio-change",
    "checkbox-change",
    "load-success",
    "load-error"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils114.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      currentNode: null,
      nodeMaps: {},
      selectRadioKey: props.checkNodeKey,
      treeList: [],
      treeExpandedMaps: {},
      treeExpandLazyLoadedMaps: {},
      selectCheckboxMaps: {},
      indeterminateCheckboxMaps: {}
    });
    const internalData = {};
    const refMaps = {
      refElem
    };
    const computeTitleField = computed(() => {
      return props.titleField || "title";
    });
    const computeKeyField = computed(() => {
      return props.keyField || "id";
    });
    const computeValueField = computed(() => {
      const keyField = computeKeyField.value;
      return props.valueField || keyField;
    });
    const computeParentField = computed(() => {
      return props.parentField || "parentId";
    });
    const computeChildrenField = computed(() => {
      return props.childrenField || "children";
    });
    const computeHasChildField = computed(() => {
      return props.hasChildField || "hasChild";
    });
    const computeIsRowCurrent = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isCurrent } = nodeOpts;
      if (import_xe_utils114.default.isBoolean(isCurrent)) {
        return isCurrent;
      }
      return props.isCurrent;
    });
    const computeIsRowHover = computed(() => {
      const nodeOpts = computeNodeOpts.value;
      const { isHover } = nodeOpts;
      if (import_xe_utils114.default.isBoolean(isHover)) {
        return isHover;
      }
      return props.isHover;
    });
    const computeRadioOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.radioConfig, props.radioConfig);
    });
    const computeCheckboxOpts = computed(() => {
      return Object.assign({ showIcon: true }, getConfig().tree.checkboxConfig, props.checkboxConfig);
    });
    const computeNodeOpts = computed(() => {
      return Object.assign({}, getConfig().tree.nodeConfig, props.nodeConfig);
    });
    const computeLoadingOpts = computed(() => {
      return Object.assign({}, getConfig().tree.loadingConfig, props.loadingConfig);
    });
    const computeTreeStyle = computed(() => {
      const { height, minHeight } = props;
      const stys = {};
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (minHeight) {
        stys.minHeight = toCssUnit(minHeight);
      }
      return stys;
    });
    const computeMaps = {
      computeRadioOpts,
      computeCheckboxOpts,
      computeNodeOpts
    };
    const $xeTree = {
      xID,
      props,
      context,
      internalData,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getNodeId = (node) => {
      const valueField = computeValueField.value;
      const nodeid = import_xe_utils114.default.get(node, valueField);
      return import_xe_utils114.default.eqNull(nodeid) ? "" : encodeURIComponent(nodeid);
    };
    const isExpandByNode = (node) => {
      const { treeExpandedMaps } = reactData;
      const nodeid = getNodeId(node);
      return !!treeExpandedMaps[nodeid];
    };
    const isCheckedByRadioNodeId = (nodeid) => {
      const { selectRadioKey } = reactData;
      return selectRadioKey === nodeid;
    };
    const isCheckedByRadioNode = (node) => {
      return isCheckedByRadioNodeId(getNodeId(node));
    };
    const isCheckedByCheckboxNodeId = (nodeid) => {
      const { selectCheckboxMaps } = reactData;
      return !!selectCheckboxMaps[nodeid];
    };
    const isCheckedByCheckboxNode = (node) => {
      return isCheckedByCheckboxNodeId(getNodeId(node));
    };
    const isIndeterminateByCheckboxNodeid = (nodeid) => {
      const { indeterminateCheckboxMaps } = reactData;
      return !!indeterminateCheckboxMaps[nodeid];
    };
    const isIndeterminateByCheckboxNode = (node) => {
      return isIndeterminateByCheckboxNodeid(getNodeId(node));
    };
    const emitCheckboxMode = (value) => {
      emit("update:checkNodeKeys", value);
    };
    const emitRadioMode = (value) => {
      emit("update:checkNodeKey", value);
    };
    const setRadioNode = (node) => {
      if (node) {
        reactData.selectRadioKey = getNodeId(node);
      }
      return nextTick();
    };
    const setCheckboxNode = (nodeList, checked) => {
      if (nodeList) {
        if (!import_xe_utils114.default.isArray(nodeList)) {
          nodeList = [nodeList];
        }
        handleCheckedCheckboxNode(nodeList.map((item) => getNodeId(item)), checked);
      }
      return nextTick();
    };
    const setCheckboxByNodeId = (nodeIds, checked) => {
      if (nodeIds) {
        if (!import_xe_utils114.default.isArray(nodeIds)) {
          nodeIds = [nodeIds];
        }
        handleCheckedCheckboxNode(nodeIds, checked);
      }
      return nextTick();
    };
    const handleCheckedCheckboxNode = (nodeIds, checked) => {
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      nodeIds.forEach((key) => {
        if (checked) {
          selectKeyMaps[key] = true;
        } else if (selectKeyMaps[key]) {
          delete selectKeyMaps[key];
        }
      });
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const updateCheckboxChecked = (nodeIds) => {
      const selectKeyMaps = {};
      if (nodeIds) {
        nodeIds.forEach((key) => {
          selectKeyMaps[key] = true;
        });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
    };
    const handleSetExpand = (nodeid, expanded, expandedMaps) => {
      if (expanded) {
        if (!expandedMaps[nodeid]) {
          expandedMaps[nodeid] = true;
        }
      } else {
        if (expandedMaps[nodeid]) {
          delete expandedMaps[nodeid];
        }
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tree: $xeTree }, params));
    };
    const createNode = (records) => {
      const valueField = computeValueField.value;
      return Promise.resolve(records.map((obj) => {
        const item = Object.assign({}, obj);
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils114.default.set(item, valueField, nodeid);
        }
        return item;
      }));
    };
    const treeMethods = {
      dispatchEvent: dispatchEvent2,
      clearCurrentNode() {
        reactData.currentNode = null;
        return nextTick();
      },
      getCurrentNodeId() {
        const { currentNode } = reactData;
        if (currentNode) {
          return getNodeId(currentNode);
        }
        return null;
      },
      getCurrentNode() {
        const { currentNode, nodeMaps } = reactData;
        if (currentNode) {
          const nodeItem = nodeMaps[currentNode];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setCurrentNodeId(nodeKey) {
        const { nodeMaps } = reactData;
        const nodeItem = nodeMaps[nodeKey];
        reactData.currentNode = nodeItem ? nodeItem.item : null;
        return nextTick();
      },
      setCurrentNode(node) {
        reactData.currentNode = node;
        return nextTick();
      },
      clearRadioNode() {
        reactData.selectRadioKey = null;
        return nextTick();
      },
      getRadioNodeId() {
        return reactData.selectRadioKey || null;
      },
      getRadioNode() {
        const { selectRadioKey, nodeMaps } = reactData;
        if (selectRadioKey) {
          const nodeItem = nodeMaps[selectRadioKey];
          if (nodeItem) {
            return nodeItem.item;
          }
        }
        return null;
      },
      setRadioNodeId(nodeKey) {
        reactData.selectRadioKey = nodeKey;
        return nextTick();
      },
      setRadioNode,
      setCheckboxNode,
      setCheckboxByNodeId,
      getCheckboxNodeIds() {
        const { selectCheckboxMaps } = reactData;
        return Object.keys(selectCheckboxMaps);
      },
      getCheckboxNodes() {
        const { nodeMaps, selectCheckboxMaps } = reactData;
        const list = [];
        import_xe_utils114.default.each(selectCheckboxMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      clearCheckboxNode() {
        reactData.selectCheckboxMaps = {};
        return nextTick();
      },
      setAllCheckboxNode(checked) {
        const selectMaps = {};
        const childrenField = computeChildrenField.value;
        if (checked) {
          import_xe_utils114.default.eachTree(reactData.treeList, (node) => {
            const nodeid = getNodeId(node);
            selectMaps[nodeid] = true;
          }, { children: childrenField });
        }
        reactData.selectCheckboxMaps = selectMaps;
        return nextTick();
      },
      clearExpandNode() {
        return treeMethods.clearAllExpandNode();
      },
      clearAllExpandNode() {
        import_xe_utils114.default.each(reactData.nodeMaps, (nodeItem) => {
          nodeItem.treeLoaded = false;
        });
        reactData.treeExpandedMaps = {};
        return nextTick();
      },
      setExpandByNodeId(nodeids, expanded) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodeids) {
          if (!import_xe_utils114.default.isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach((nodeid) => {
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      getExpandNodeIds() {
        const { treeExpandedMaps } = reactData;
        return Object.keys(treeExpandedMaps);
      },
      getExpandNodes() {
        const { nodeMaps, treeExpandedMaps } = reactData;
        const list = [];
        import_xe_utils114.default.each(treeExpandedMaps, (item, nodeid) => {
          const nodeItem = nodeMaps[nodeid];
          if (nodeItem) {
            list.push(nodeItem.item);
          }
        });
        return list;
      },
      setExpandNode(nodes, expanded) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodes) {
          if (!import_xe_utils114.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, expanded, expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      toggleExpandByNodeId(nodeids) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodeids) {
          if (!import_xe_utils114.default.isArray(nodeids)) {
            nodeids = [nodeids];
          }
          nodeids.forEach((nodeid) => {
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      toggleExpandNode(nodes) {
        const expandedMaps = Object.assign({}, reactData.treeExpandedMaps);
        if (nodes) {
          if (!import_xe_utils114.default.isArray(nodes)) {
            nodes = [nodes];
          }
          nodes.forEach((node) => {
            const nodeid = getNodeId(node);
            handleSetExpand(nodeid, !expandedMaps[nodeid], expandedMaps);
          });
          reactData.treeExpandedMaps = expandedMaps;
        }
        return nextTick();
      },
      setAllExpandNode(expanded) {
        const expandedMaps = {};
        const childrenField = computeChildrenField.value;
        if (expanded) {
          import_xe_utils114.default.eachTree(reactData.treeList, (node) => {
            const childList = import_xe_utils114.default.get(node, childrenField);
            const hasChild = childList && childList.length;
            if (hasChild) {
              const nodeid = getNodeId(node);
              expandedMaps[nodeid] = true;
            }
          }, { children: childrenField });
        }
        reactData.treeExpandedMaps = expandedMaps;
        return nextTick();
      },
      reloadExpandNode(node) {
        const { lazy } = props;
        if (lazy) {
          treeMethods.clearExpandLoaded(node);
          return handleAsyncTreeExpandChilds(node);
        }
        return nextTick();
      },
      clearExpandLoaded(node) {
        const { lazy } = props;
        const { nodeMaps } = reactData;
        if (lazy) {
          const nodeItem = nodeMaps[getNodeId(node)];
          if (nodeItem) {
            nodeItem.treeLoaded = false;
          }
        }
        return nextTick();
      },
      /**
       * 用于树结构，给行数据加载子节点
       */
      loadChildrenNode(node, childRecords) {
        const { lazy, transform: transform2 } = props;
        const { nodeMaps } = reactData;
        if (!lazy) {
          return Promise.resolve([]);
        }
        const childrenField = computeChildrenField.value;
        const parentNodeItem = nodeMaps[getNodeId(node)];
        const parentLevel = parentNodeItem ? parentNodeItem.level : 0;
        const parentNodes = parentNodeItem ? parentNodeItem.nodes : [];
        return createNode(childRecords).then((nodeList) => {
          import_xe_utils114.default.eachTree(nodeList, (childRow, index2, items, path, parent, nodes) => {
            const itemNodeId = getNodeId(childRow);
            nodeMaps[itemNodeId] = {
              item: node,
              itemIndex: -1,
              items,
              parent: parent || parentNodeItem.item,
              nodes: parentNodes.concat(nodes),
              level: parentLevel + nodes.length,
              lineCount: 0,
              treeLoaded: false
            };
          }, { children: childrenField });
          node[childrenField] = nodeList;
          if (transform2) {
            node[childrenField] = nodeList;
          }
          updateNodeLine(node);
          return nodeList;
        });
      },
      isExpandByNode,
      isCheckedByRadioNodeId,
      isCheckedByRadioNode,
      isCheckedByCheckboxNodeId,
      isIndeterminateByCheckboxNode,
      isCheckedByCheckboxNode
    };
    const cacheNodeMap = () => {
      const { treeList } = reactData;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const keyMaps = {};
      import_xe_utils114.default.eachTree(treeList, (item, itemIndex, items, path, parent, nodes) => {
        let nodeid = getNodeId(item);
        if (!nodeid) {
          nodeid = getNodeUniqueId();
          import_xe_utils114.default.set(item, valueField, nodeid);
        }
        keyMaps[nodeid] = {
          item,
          itemIndex,
          items,
          parent,
          nodes,
          level: nodes.length,
          lineCount: 0,
          treeLoaded: false
        };
      }, { children: childrenField });
      reactData.nodeMaps = keyMaps;
    };
    const updateData = (list) => {
      const { transform: transform2 } = props;
      const keyField = computeKeyField.value;
      const parentField = computeParentField.value;
      const childrenField = computeChildrenField.value;
      if (transform2) {
        reactData.treeList = import_xe_utils114.default.toArrayTree(list, { key: keyField, parentKey: parentField, mapChildren: childrenField });
      } else {
        reactData.treeList = list ? list.slice(0) : [];
      }
      cacheNodeMap();
    };
    const handleCountLine = (item, isRoot, nodeItem) => {
      const { treeExpandedMaps } = reactData;
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(item);
      nodeItem.lineCount++;
      if (treeExpandedMaps[nodeid]) {
        import_xe_utils114.default.arrayEach(item[childrenField], (childItem, childIndex, childList) => {
          if (!isRoot || childIndex < childList.length - 1) {
            handleCountLine(childItem, false, nodeItem);
          }
        });
      }
    };
    const updateNodeLine = (node) => {
      const { nodeMaps } = reactData;
      if (node) {
        const nodeid = getNodeId(node);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          import_xe_utils114.default.lastArrayEach(nodeItem.nodes, (childItem) => {
            const nodeid2 = getNodeId(childItem);
            const nodeItem2 = nodeMaps[nodeid2];
            if (nodeItem2) {
              nodeItem2.lineCount = 0;
              handleCountLine(childItem, true, nodeItem2);
            }
          });
        }
      }
    };
    const handleNodeClickEvent = (evnt, node) => {
      const { showRadio, showCheckbox, trigger } = props;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const isRowCurrent = computeIsRowCurrent.value;
      let triggerCurrent = false;
      let triggerRadio = false;
      let triggerCheckbox = false;
      let triggerExpand = false;
      if (isRowCurrent) {
        triggerCurrent = true;
        changeCurrentEvent(evnt, node);
      } else if (reactData.currentNode) {
        reactData.currentNode = null;
      }
      if (trigger === "node") {
        triggerExpand = true;
        toggleExpandEvent(evnt, node);
      }
      if (showRadio && radioOpts.trigger === "node") {
        triggerRadio = true;
        changeRadioEvent(evnt, node);
      }
      if (showCheckbox && checkboxOpts.trigger === "node") {
        triggerCheckbox = true;
        changeCheckboxEvent(evnt, node);
      }
      dispatchEvent2("node-click", { node, triggerCurrent, triggerRadio, triggerCheckbox, triggerExpand }, evnt);
    };
    const handleNodeDblclickEvent = (evnt, node) => {
      dispatchEvent2("node-dblclick", { node }, evnt);
    };
    const handleAsyncTreeExpandChilds = (node) => {
      const checkboxOpts = computeCheckboxOpts.value;
      const { loadMethod } = props;
      const { checkStrictly } = checkboxOpts;
      return new Promise((resolve) => {
        if (loadMethod) {
          const tempExpandLazyLoadedMaps = Object.assign({}, reactData.treeExpandLazyLoadedMaps);
          const { nodeMaps } = reactData;
          const nodeid = getNodeId(node);
          const nodeItem = nodeMaps[nodeid];
          tempExpandLazyLoadedMaps[nodeid] = true;
          reactData.treeExpandLazyLoadedMaps = tempExpandLazyLoadedMaps;
          Promise.resolve(loadMethod({ $tree: $xeTree, node })).then((childRecords) => {
            const { treeExpandLazyLoadedMaps } = reactData;
            nodeItem.treeLoaded = true;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            if (!import_xe_utils114.default.isArray(childRecords)) {
              childRecords = [];
            }
            if (childRecords) {
              return treeMethods.loadChildrenNode(node, childRecords).then((childRows) => {
                const tempExpandedMaps = Object.assign({}, reactData.treeExpandedMaps);
                if (childRows.length && !tempExpandedMaps[nodeid]) {
                  tempExpandedMaps[nodeid] = true;
                }
                reactData.treeExpandedMaps = tempExpandedMaps;
                if (!checkStrictly && treeMethods.isCheckedByCheckboxNodeId(nodeid)) {
                  handleCheckedCheckboxNode(childRows.map((item) => getNodeId(item)), true);
                }
                updateNodeLine(node);
                dispatchEvent2("load-success", { node, data: childRecords }, new Event("load-success"));
                return nextTick();
              });
            } else {
              updateNodeLine(node);
              dispatchEvent2("load-success", { node, data: childRecords }, new Event("load-success"));
            }
          }).catch((e16) => {
            const { treeExpandLazyLoadedMaps } = reactData;
            nodeItem.treeLoaded = false;
            if (treeExpandLazyLoadedMaps[nodeid]) {
              treeExpandLazyLoadedMaps[nodeid] = false;
            }
            updateNodeLine(node);
            dispatchEvent2("load-error", { node, data: e16 }, new Event("load-error"));
          }).finally(() => {
            return nextTick();
          });
        } else {
          resolve();
        }
      });
    };
    const handleBaseTreeExpand = (nodeList, expanded) => {
      const { lazy, accordion, toggleMethod } = props;
      const { nodeMaps, treeExpandLazyLoadedMaps } = reactData;
      const tempExpandedMaps = Object.assign({}, reactData.treeExpandedMaps);
      const childrenField = computeChildrenField.value;
      const hasChildField = computeHasChildField.value;
      const result = [];
      let validNodes = toggleMethod ? nodeList.filter((node) => toggleMethod({ $tree: $xeTree, expanded, node })) : nodeList;
      if (accordion) {
        validNodes = validNodes.length ? [validNodes[validNodes.length - 1]] : [];
        const nodeid = getNodeId(validNodes[0]);
        const nodeItem = nodeMaps[nodeid];
        if (nodeItem) {
          nodeItem.items.forEach((item) => {
            const itemNodeId = getNodeId(item);
            if (tempExpandedMaps[itemNodeId]) {
              delete tempExpandedMaps[itemNodeId];
            }
          });
        }
      }
      const expandNodes = [];
      if (expanded) {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (!tempExpandedMaps[itemNodeId]) {
            const nodeItem = nodeMaps[itemNodeId];
            const isLoad = lazy && item[hasChildField] && !nodeItem.treeLoaded && !treeExpandLazyLoadedMaps[itemNodeId];
            if (isLoad) {
              result.push(handleAsyncTreeExpandChilds(item));
            } else {
              if (item[childrenField] && item[childrenField].length) {
                tempExpandedMaps[itemNodeId] = true;
                expandNodes.push(item);
              }
            }
          }
        });
      } else {
        validNodes.forEach((item) => {
          const itemNodeId = getNodeId(item);
          if (tempExpandedMaps[itemNodeId]) {
            delete tempExpandedMaps[itemNodeId];
            expandNodes.push(item);
          }
        });
      }
      reactData.treeExpandedMaps = tempExpandedMaps;
      expandNodes.forEach(updateNodeLine);
      return Promise.all(result);
    };
    const toggleExpandEvent = (evnt, node) => {
      const { lazy } = props;
      const { treeExpandedMaps, treeExpandLazyLoadedMaps } = reactData;
      const nodeid = getNodeId(node);
      const expanded = !treeExpandedMaps[nodeid];
      evnt.stopPropagation();
      if (!lazy || !treeExpandLazyLoadedMaps[nodeid]) {
        handleBaseTreeExpand([node], expanded);
      }
    };
    const handleNodeCheckboxStatus = (node, selectKeyMaps, indeterminateMaps) => {
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils114.default.get(node, childrenField);
      const nodeid = getNodeId(node);
      if (childList && childList.length) {
        let checkSome = false;
        let checkSize = 0;
        childList.forEach((childNode) => {
          const childNodeid = getNodeId(childNode);
          const isChecked = selectKeyMaps[childNodeid];
          if (isChecked || indeterminateMaps[childNodeid]) {
            if (isChecked) {
              checkSize++;
            }
            checkSome = true;
          }
        });
        const checkAll = checkSize === childList.length;
        if (checkAll) {
          if (!selectKeyMaps[nodeid]) {
            selectKeyMaps[nodeid] = true;
          }
          if (indeterminateMaps[nodeid]) {
            delete indeterminateMaps[nodeid];
          }
        } else {
          if (selectKeyMaps[nodeid]) {
            delete selectKeyMaps[nodeid];
          }
          indeterminateMaps[nodeid] = checkSome;
        }
      } else {
        if (indeterminateMaps[nodeid]) {
          delete indeterminateMaps[nodeid];
        }
      }
    };
    const updateCheckboxStatus = () => {
      const { treeList } = reactData;
      const childrenField = computeChildrenField.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly } = checkboxOpts;
      if (!checkStrictly) {
        const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
        const indeterminateMaps = {};
        import_xe_utils114.default.eachTree(treeList, (node, index2, items, path, parent, nodes) => {
          const childList = import_xe_utils114.default.get(node, childrenField);
          if (!childList || !childList.length) {
            handleNodeCheckboxStatus(node, selectKeyMaps, indeterminateMaps);
          }
          if (index2 === items.length - 1) {
            for (let len = nodes.length - 2; len >= 0; len--) {
              const parentItem = nodes[len];
              handleNodeCheckboxStatus(parentItem, selectKeyMaps, indeterminateMaps);
            }
          }
        });
        reactData.selectCheckboxMaps = selectKeyMaps;
        reactData.indeterminateCheckboxMaps = indeterminateMaps;
      }
    };
    const changeCheckboxEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const checkboxOpts = computeCheckboxOpts.value;
      const { checkStrictly, checkMethod } = checkboxOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const selectKeyMaps = Object.assign({}, reactData.selectCheckboxMaps);
      const childrenField = computeChildrenField.value;
      const nodeid = getNodeId(node);
      let isChecked = false;
      if (selectKeyMaps[nodeid]) {
        delete selectKeyMaps[nodeid];
      } else {
        isChecked = true;
        selectKeyMaps[nodeid] = isChecked;
      }
      if (!checkStrictly) {
        import_xe_utils114.default.eachTree(import_xe_utils114.default.get(node, childrenField), (childNode) => {
          const childNodeid = getNodeId(childNode);
          if (isChecked) {
            if (!selectKeyMaps[childNodeid]) {
              selectKeyMaps[childNodeid] = true;
            }
          } else {
            if (selectKeyMaps[childNodeid]) {
              delete selectKeyMaps[childNodeid];
            }
          }
        }, { children: childrenField });
      }
      reactData.selectCheckboxMaps = selectKeyMaps;
      updateCheckboxStatus();
      const value = Object.keys(reactData.selectCheckboxMaps);
      emitCheckboxMode(value);
      dispatchEvent2("checkbox-change", { node, value, checked: isChecked }, evnt);
    };
    const changeCurrentEvent = (evnt, node) => {
      evnt.preventDefault();
      const nodeOpts = computeNodeOpts.value;
      const { currentMethod, trigger } = nodeOpts;
      const childrenField = computeChildrenField.value;
      const childList = import_xe_utils114.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      let isDisabled = !!currentMethod;
      if (trigger === "child") {
        if (hasChild) {
          return;
        }
      } else if (trigger === "parent") {
        if (!hasChild) {
          return;
        }
      }
      if (currentMethod) {
        isDisabled = !currentMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      reactData.currentNode = node;
      dispatchEvent2("current-change", { node, checked: isChecked }, evnt);
    };
    const changeRadioEvent = (evnt, node) => {
      evnt.preventDefault();
      evnt.stopPropagation();
      const radioOpts = computeRadioOpts.value;
      const { checkMethod } = radioOpts;
      let isDisabled = !!checkMethod;
      if (checkMethod) {
        isDisabled = !checkMethod({ node });
      }
      if (isDisabled) {
        return;
      }
      const isChecked = true;
      const value = getNodeId(node);
      reactData.selectRadioKey = value;
      emitRadioMode(value);
      dispatchEvent2("radio-change", { node, value, checked: isChecked }, evnt);
    };
    const treePrivateMethods = {};
    Object.assign($xeTree, treeMethods, treePrivateMethods);
    const renderRadio = (node, nodeid, isChecked) => {
      const { showRadio } = props;
      const radioOpts = computeRadioOpts.value;
      const { showIcon, checkMethod, visibleMethod } = radioOpts;
      const isVisible = !visibleMethod || visibleMethod({ node });
      let isDisabled = !!checkMethod;
      if (showRadio && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ node });
        }
        return h("div", {
          class: ["vxe-tree--radio-option", {
            "is--checked": isChecked,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeRadioEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-radio--icon", isChecked ? getIcon().RADIO_CHECKED : getIcon().RADIO_UNCHECKED]
          })
        ]);
      }
      return createCommentVNode();
    };
    const renderCheckbox = (node, nodeid, isChecked) => {
      const { showCheckbox } = props;
      const checkboxOpts = computeCheckboxOpts.value;
      const { showIcon, checkMethod, visibleMethod } = checkboxOpts;
      const isIndeterminate = isIndeterminateByCheckboxNodeid(nodeid);
      const isVisible = !visibleMethod || visibleMethod({ node });
      let isDisabled = !!checkMethod;
      if (showCheckbox && showIcon && isVisible) {
        if (checkMethod) {
          isDisabled = !checkMethod({ node });
        }
        return h("div", {
          class: ["vxe-tree--checkbox-option", {
            "is--checked": isChecked,
            "is--indeterminate": isIndeterminate,
            "is--disabled": isDisabled
          }],
          onClick: (evnt) => {
            if (!isDisabled) {
              changeCheckboxEvent(evnt, node);
            }
          }
        }, [
          h("span", {
            class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
          })
        ]);
      }
      return createCommentVNode();
    };
    const renderNode = (node) => {
      const { lazy, showRadio, showCheckbox, showLine, indent, iconOpen, iconClose, iconLoaded, showIcon } = props;
      const { nodeMaps, treeExpandedMaps, currentNode, selectRadioKey, treeExpandLazyLoadedMaps } = reactData;
      const childrenField = computeChildrenField.value;
      const titleField = computeTitleField.value;
      const hasChildField = computeHasChildField.value;
      const childList = import_xe_utils114.default.get(node, childrenField);
      const hasChild = childList && childList.length;
      const titleSlot = slots.title;
      const extraSlot = slots.extra;
      const nodeid = getNodeId(node);
      const isExpand = treeExpandedMaps[nodeid];
      const nodeItem = nodeMaps[nodeid];
      const nodeValue = import_xe_utils114.default.get(node, titleField);
      const childVns = [];
      if (hasChild && treeExpandedMaps[nodeid]) {
        if (showLine) {
          childVns.push(h("div", {
            key: "line",
            class: "vxe-tree--node-child-line",
            style: {
              height: `calc(${nodeItem.lineCount} * var(--vxe-ui-tree-node-height) - var(--vxe-ui-tree-node-height) / 2)`,
              left: `${(nodeItem.level + 1) * (indent || 1)}px`
            }
          }));
        }
        childList.forEach((childItem) => {
          childVns.push(renderNode(childItem));
        });
      }
      let isRadioChecked = false;
      if (showRadio) {
        isRadioChecked = nodeid == selectRadioKey;
      }
      let isCheckboxChecked = false;
      if (showCheckbox) {
        isCheckboxChecked = isCheckedByCheckboxNodeId(nodeid);
      }
      let hasLazyChilds = false;
      let isLazyLoading = false;
      let isLazyLoaded = false;
      if (lazy) {
        isLazyLoading = !!treeExpandLazyLoadedMaps[nodeid];
        hasLazyChilds = node[hasChildField];
        isLazyLoaded = !!nodeItem.treeLoaded;
      }
      return h("div", {
        class: ["vxe-tree--node-wrapper", `node--level-${nodeItem.level}`],
        nodeid
      }, [
        h("div", {
          class: ["vxe-tree--node-item", {
            "is--current": currentNode && nodeid === getNodeId(currentNode),
            "is-radio--checked": isRadioChecked,
            "is-checkbox--checked": isCheckboxChecked
          }],
          style: {
            paddingLeft: `${(nodeItem.level - 1) * (indent || 1)}px`
          },
          onClick(evnt) {
            handleNodeClickEvent(evnt, node);
          },
          onDblclick(evnt) {
            handleNodeDblclickEvent(evnt, node);
          }
        }, [
          showIcon || showLine ? h("div", {
            class: "vxe-tree--node-item-switcher"
          }, showIcon && (lazy ? isLazyLoaded ? hasChild : hasLazyChilds : hasChild) ? [
            h("div", {
              class: "vxe-tree--node-item-icon",
              onClick(evnt) {
                toggleExpandEvent(evnt, node);
              }
            }, [
              h("i", {
                class: isLazyLoading ? iconLoaded || getIcon().TREE_NODE_LOADED : isExpand ? iconOpen || getIcon().TREE_NODE_OPEN : iconClose || getIcon().TREE_NODE_CLOSE
              })
            ])
          ] : []) : createCommentVNode(),
          renderRadio(node, nodeid, isRadioChecked),
          renderCheckbox(node, nodeid, isCheckboxChecked),
          h("div", {
            class: "vxe-tree--node-item-inner"
          }, [
            h("div", {
              class: "vxe-tree--node-item-title"
            }, titleSlot ? getSlotVNs2(titleSlot({ node })) : `${nodeValue}`),
            extraSlot ? h("div", {
              class: "vxe-tree--node-item-extra"
            }, getSlotVNs2(extraSlot({ node }))) : createCommentVNode()
          ])
        ]),
        hasChild && treeExpandedMaps[nodeid] ? h("div", {
          class: "vxe-tree--node-child-wrapper"
        }, childVns) : createCommentVNode()
      ]);
    };
    const renderNodeList = () => {
      const { treeList } = reactData;
      return h("div", {
        class: "vxe-tree--node-list-wrapper"
      }, treeList.map((node) => renderNode(node)));
    };
    const renderVN = () => {
      const { loading: loading2, trigger, showLine } = props;
      const vSize = computeSize.value;
      const radioOpts = computeRadioOpts.value;
      const checkboxOpts = computeCheckboxOpts.value;
      const treeStyle = computeTreeStyle.value;
      const loadingOpts = computeLoadingOpts.value;
      const isRowHover = computeIsRowHover.value;
      const loadingSlot = slots.loading;
      return h("div", {
        ref: refElem,
        class: ["vxe-tree", {
          [`size--${vSize}`]: vSize,
          "show--line": showLine,
          "checkbox--highlight": checkboxOpts.highlight,
          "radio--highlight": radioOpts.highlight,
          "node--hover": isRowHover,
          "node--trigger": trigger === "node",
          "is--loading": loading2
        }],
        style: treeStyle
      }, [
        renderNodeList(),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-tree--loading",
          modelValue: loading2,
          icon: loadingOpts.icon,
          text: loadingOpts.text
        }, loadingSlot ? {
          default: () => loadingSlot({ $tree: $xeTree })
        } : {})
      ]);
    };
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : 0, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      updateData(props.data || []);
    });
    watch(() => props.checkNodeKey, (val) => {
      reactData.selectRadioKey = val;
    });
    const checkboxFlag = ref(0);
    watch(() => props.checkNodeKeys ? props.checkNodeKeys.length : 0, () => {
      checkboxFlag.value++;
    });
    watch(() => props.checkNodeKeys, () => {
      checkboxFlag.value++;
    });
    watch(checkboxFlag, () => {
      updateCheckboxChecked(props.checkNodeKeys || []);
    });
    onUnmounted(() => {
      reactData.treeList = [];
      reactData.treeExpandedMaps = {};
      reactData.nodeMaps = {};
    });
    updateData(props.data || []);
    updateCheckboxChecked(props.checkNodeKeys || []);
    $xeTree.renderVN = renderVN;
    return $xeTree;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tree-select/src/tree-select.js
function getOptUniqueId2() {
  return import_xe_utils115.default.uniqueId("node_");
}
var tree_select_default = defineComponent({
  name: "VxeTreeSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils115.default.eqNull(getConfig().treeSelect.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().treeSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    popupClassName: [String, Function],
    prefixIcon: String,
    placement: String,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    remote: Boolean,
    remoteMethod: Function,
    popupConfig: Object,
    treeConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click",
    "node-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils115.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refTreeWrapper = ref();
    const refOptionPanel = ref();
    const reactData = reactive({
      initialized: false,
      fullOptionList: [],
      fullNodeMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils115.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePopupOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.popupConfig, props.popupConfig);
    });
    const computeTreeOpts = computed(() => {
      return Object.assign({}, getConfig().treeSelect.treeConfig, props.treeConfig, { data: void 0 });
    });
    const computeTreeNodeOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({ isHover: true }, treeOpts.nodeConfig);
    });
    const computeTreeCheckboxOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showCheckbox
      }, treeOpts.checkboxConfig, {
        trigger: "node"
      });
    });
    const computeTreeRadioOpts = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return Object.assign({
        showIcon: !!treeOpts.showRadio
      }, treeOpts.radioConfig, {
        trigger: "node"
      });
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeNodeKeyField = computed(() => {
      const treeOpts = computeTreeOpts.value;
      return treeOpts.keyField || "id";
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computeChildrenField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.children || "children";
    });
    const computeParentField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.parent || "parentField";
    });
    const computeHasChildField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.hasChild || "hasChild";
    });
    const computeSelectLabel = computed(() => {
      const { modelValue } = props;
      const { fullNodeMaps } = reactData;
      const labelField = computeLabelField.value;
      return (import_xe_utils115.default.isArray(modelValue) ? modelValue : [modelValue]).map((val) => {
        const cacheItem = fullNodeMaps[val];
        return cacheItem ? cacheItem.item[labelField] : val;
      }).join(", ");
    });
    const computePopupWrapperStyle = computed(() => {
      const popupOpts = computePopupOpts.value;
      const { height, width } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
        stys.maxHeight = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTreeSelect = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $treeSelect: $xeTreeSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const treeSelectMethods = {
      dispatchEvent: dispatchEvent2
    };
    const getNodeid = (option2) => {
      const nodeKeyField = computeNodeKeyField.value;
      const nodeid = option2[nodeKeyField];
      return nodeid ? encodeURIComponent(nodeid) : "";
    };
    const cacheDataMap = () => {
      const { options } = props;
      const nodeKeyField = computeNodeKeyField.value;
      const childrenField = computeChildrenField.value;
      const valueField = computeValueField.value;
      const nodeMaps = {};
      const keyMaps = {};
      import_xe_utils115.default.eachTree(options, (item, index2, items, path, parent, nodes) => {
        let nodeid = getNodeid(item);
        if (!nodeid) {
          nodeid = getOptUniqueId2();
        }
        if (keyMaps[nodeid]) {
          errLog2("vxe.error.repeatKey", [nodeKeyField, nodeid]);
        }
        keyMaps[nodeid] = true;
        const value = item[valueField];
        if (nodeMaps[value]) {
          errLog2("vxe.error.repeatKey", [valueField, value]);
        }
        nodeMaps[value] = { item, index: index2, items, parent, nodes };
      }, { children: childrenField });
      reactData.fullOptionList = options || [];
      reactData.fullNodeMaps = nodeMaps;
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el2) {
          const targetHeight = el2.offsetHeight;
          const targetWidth = el2.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(el2);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2 } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        clearTimeout(internalData.hpTimeout);
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      const { fullNodeMaps } = reactData;
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        const cacheItem = fullNodeMaps[selectValue];
        dispatchEvent2("change", { value: selectValue, option: cacheItem ? cacheItem.item : null }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent2("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent2("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent2("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent2("blur", {}, evnt);
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const nodeClickEvent = (params) => {
      const { $event } = params;
      dispatchEvent2("node-click", params, $event);
    };
    const radioChangeEvent = (params) => {
      const { value, $event } = params;
      changeEvent($event, value);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { value, $event } = params;
      changeEvent($event, value);
    };
    const loadSuccessEvent = () => {
      cacheDataMap();
    };
    const treeSelectPrivateMethods = {};
    Object.assign($xeTreeSelect, treeSelectMethods, treeSelectPrivateMethods);
    const renderVN = () => {
      const { className, modelValue, multiple, options, loading: loading2 } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      const popupOpts = computePopupOpts.value;
      const popupClassName = popupOpts.className || props.popupClassName;
      const treeOpts = computeTreeOpts.value;
      const treeNodeOpts = computeTreeNodeOpts.value;
      const treeCheckboxOpts = computeTreeCheckboxOpts.value;
      const treeRadioOpts = computeTreeRadioOpts.value;
      const nodeKeyField = computeNodeKeyField.value;
      const labelField = computeLabelField.value;
      const valueField = computeValueField.value;
      const childrenField = computeChildrenField.value;
      const parentField = computeParentField.value;
      const hasChildField = computeHasChildField.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-tree-select--readonly", className]
        }, [
          h("span", {
            class: "vxe-tree-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-tree-select", className ? import_xe_utils115.default.isFunction(className) ? className({ $treeSelect: $xeTreeSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: loading2 ? getI18n("vxe.select.loadingText") : props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TREE_SELECT_LOADED : visiblePanel ? getIcon().TREE_SELECT_OPEN : getIcon().TREE_SELECT_CLOSE,
          modelValue: loading2 ? "" : selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-tree-select--panel", popupClassName ? import_xe_utils115.default.isFunction(popupClassName) ? popupClassName({ $treeSelect: $xeTreeSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-tree-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-tree-select--panel-header"
              }, headerSlot({})) : renderEmptyElement($xeTreeSelect),
              h("div", {
                class: "vxe-tree-select--panel-body"
              }, [
                h("div", {
                  ref: refTreeWrapper,
                  class: "vxe-tree-select-tree--wrapper",
                  style: popupWrapperStyle
                }, [
                  h(tree_default, {
                    class: "vxe-tree-select--tree",
                    data: options,
                    indent: treeOpts.indent,
                    showRadio: !multiple,
                    radioConfig: treeRadioOpts,
                    checkNodeKey: multiple ? null : modelValue,
                    showCheckbox: !!multiple,
                    checkNodeKeys: multiple ? modelValue : null,
                    checkboxConfig: treeCheckboxOpts,
                    titleField: labelField,
                    valueField,
                    keyField: nodeKeyField,
                    childrenField: treeOpts.childrenField || childrenField,
                    parentField: treeOpts.parentField || parentField,
                    hasChildField: treeOpts.hasChildField || hasChildField,
                    accordion: treeOpts.accordion,
                    nodeConfig: treeNodeOpts,
                    lazy: treeOpts.lazy,
                    loadMethod: treeOpts.loadMethod,
                    toggleMethod: treeOpts.toggleMethod,
                    transform: treeOpts.transform,
                    trigger: treeOpts.trigger,
                    showIcon: treeOpts.showIcon,
                    showLine: treeOpts.showLine,
                    iconOpen: treeOpts.iconOpen,
                    iconLoaded: treeOpts.iconLoaded,
                    iconClose: treeOpts.iconClose,
                    onNodeClick: nodeClickEvent,
                    onRadioChange: radioChangeEvent,
                    onCheckboxChange: checkboxChangeEvent,
                    onLoadSuccess: loadSuccessEvent
                  })
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-tree-select--panel-footer"
              }, footerSlot({})) : renderEmptyElement($xeTreeSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => props.options, () => {
      cacheDataMap();
    });
    cacheDataMap();
    onMounted(() => {
      globalEvents.on($xeTreeSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTreeSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTreeSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTreeSelect, "mousewheel");
      globalEvents.off($xeTreeSelect, "mousedown");
      globalEvents.off($xeTreeSelect, "blur");
    });
    provide("$xeTreeSelect", $xeTreeSelect);
    $xeTreeSelect.renderVN = renderVN;
    return $xeTreeSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-tree-select/vxe-tree-select-view.js
var WidgetVxeTreeSelectViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(tree_select_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            placeholder: options.placeholder || getI18n("vxe.base.pleaseSelect"),
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-data.js
var import_xe_utils116 = __toESM(require_xe_utils());
var getWidgetVxeRadioGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-radio-checked",
    options: {
      options: import_xe_utils116.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-form.js
var WidgetVxeRadioGroupFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-radio-group/vxe-radio-group-view.js
var WidgetVxeRadioGroupViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(group_default3, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-data.js
var import_xe_utils117 = __toESM(require_xe_utils());
var getWidgetVxeCheckboxGroupConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-checkbox-checked",
    options: {
      options: import_xe_utils117.default.range(0, 3).map((v, i) => {
        return {
          value: getI18n("vxe.formDesign.widgetProp.dataSource.defValue", [i + 1])
        };
      })
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-form.js
var WidgetVxeCheckboxGroupFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { renderDataSourceFormItem } = useWidgetPropDataSource(props, {
      isSubOption: false
    });
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.placeholder"),
              field: "placeholder",
              itemRender: { name: "VxeInput" }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            }),
            renderDataSourceFormItem()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-checkbox-group/vxe-checkbox-group-view.js
var WidgetVxeCheckboxGroupViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(group_default2, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            options: options.options,
            optionProps: { label: "value", value: "value" },
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-data.js
function getLimitSizeOptions() {
  const sizeOpts = [
    { label: "无限制", value: "" }
  ];
  const sizeList = [1, 2, 5, 10, 20, 50, 100, 200, 500];
  sizeList.forEach((num) => {
    sizeOpts.push({ label: `${num}M`, value: num });
  });
  return sizeOpts;
}
var getWidgetVxeUploadFileConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-file",
    options: {
      limitCount: "",
      limitSize: 100,
      multiple: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-form.js
var WidgetVxeUploadFileFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const limitSizeOptions = ref(getLimitSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.multiFile"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            options.multiple ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitFileCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: true } }
            }) : createCommentVNode(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitFileSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: limitSizeOptions.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/upload/src/upload.js
var import_xe_utils119 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/upload/src/util.js
var import_xe_utils118 = __toESM(require_xe_utils());
var fileForm = null;
var fileInput = null;
function parseFile2(file) {
  const name = file.name;
  const tIndex = import_xe_utils118.default.lastIndexOf(name, ".");
  const type = name.substring(tIndex + 1, name.length).toLowerCase();
  const filename = name.substring(0, tIndex);
  return { filename, type };
}
var readLocalFile = (options) => {
  const opts = Object.assign({}, options);
  return new Promise((resolve, reject) => {
    if (!fileInput) {
      fileInput = document.createElement("input");
      fileInput.name = "file";
      fileInput.type = "file";
    }
    if (!fileForm) {
      fileForm = document.createElement("form");
      fileForm.style.display = "none";
      fileForm.appendChild(fileInput);
      document.body.appendChild(fileForm);
    }
    const types = opts.types || [];
    const isAllType = !types.length || types.some((type) => type === "*");
    fileInput.multiple = !!opts.multiple;
    fileInput.accept = isAllType ? "" : `.${types.join(", .")}`;
    fileInput.onchange = (evnt) => {
      const eventTarget = evnt.target;
      const files = Array.from(eventTarget.files || []);
      const file = files[0];
      let errType = "";
      if (!isAllType) {
        for (let fIndex = 0; fIndex < files.length; fIndex++) {
          const { type } = parseFile2(files[fIndex]);
          if (!import_xe_utils118.default.includes(types, type)) {
            errType = type;
            break;
          }
        }
      }
      if (!errType) {
        resolve({ status: true, files, file });
      } else {
        if (opts.message !== false) {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.error.notType", [errType]),
              status: "error"
            });
          }
        }
        const params = { status: false, files, file };
        reject(params);
      }
    };
    fileForm.reset();
    fileInput.click();
  });
};
function getExportBlobByContent2(content, options) {
  return new Blob([content], { type: `text/${options.type};charset=utf-8;` });
}
var saveLocalFile = (options) => {
  const opts = Object.assign({ type: "" }, options);
  const { filename, type, content } = opts;
  const name = type ? `${filename}.${type}` : `${filename}`;
  if (window.Blob) {
    const blob = content instanceof Blob ? content : getExportBlobByContent2(import_xe_utils118.default.toValueString(content), opts);
    const winNavigator = window.navigator;
    if (winNavigator.msSaveBlob) {
      winNavigator.msSaveBlob(blob, name);
    } else {
      const url = URL.createObjectURL(blob);
      const linkElem = document.createElement("a");
      linkElem.target = "_blank";
      linkElem.download = name;
      linkElem.href = url;
      document.body.appendChild(linkElem);
      linkElem.click();
      requestAnimationFrame(() => {
        if (linkElem.parentNode) {
          linkElem.parentNode.removeChild(linkElem);
        }
        URL.revokeObjectURL(url);
      });
    }
    return Promise.resolve();
  }
  return Promise.reject(new Error(getI18n("vxe.error.notExp")));
};

// node_modules/vxe-pc-ui/es/upload/src/upload.js
var upload_default = defineComponent({
  name: "VxeUpload",
  props: {
    modelValue: [Array, String, Object],
    showList: {
      type: Boolean,
      default: () => getConfig().upload.showList
    },
    moreConfig: Object,
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    mode: {
      type: String,
      default: () => getConfig().upload.mode
    },
    imageTypes: {
      type: Array,
      default: () => import_xe_utils119.default.clone(getConfig().upload.imageTypes, true)
    },
    imageConfig: {
      type: Object,
      default: () => import_xe_utils119.default.clone(getConfig().upload.imageConfig, true)
    },
    /**
     * 已废弃，被 image-config 替换
     * @deprecated
     */
    imageStyle: {
      type: Object,
      default: () => import_xe_utils119.default.clone(getConfig().upload.imageStyle, true)
    },
    fileTypes: {
      type: Array,
      default: () => import_xe_utils119.default.clone(getConfig().upload.fileTypes, true)
    },
    dragSort: Boolean,
    dragToUpload: {
      type: Boolean,
      default: () => import_xe_utils119.default.clone(getConfig().upload.dragToUpload, true)
    },
    pasteToUpload: {
      type: Boolean,
      default: () => import_xe_utils119.default.clone(getConfig().upload.pasteToUpload, true)
    },
    keyField: String,
    singleMode: Boolean,
    urlMode: Boolean,
    multiple: Boolean,
    limitSize: {
      type: [String, Number],
      default: () => getConfig().upload.limitSize
    },
    limitCount: {
      type: [String, Number],
      default: () => getConfig().upload.limitCount
    },
    nameField: {
      type: String,
      default: () => getConfig().upload.nameField
    },
    typeField: {
      type: String,
      default: () => getConfig().upload.typeField
    },
    urlField: {
      type: String,
      default: () => getConfig().upload.urlField
    },
    sizeField: {
      type: String,
      default: () => getConfig().upload.sizeField
    },
    showErrorStatus: {
      type: Boolean,
      default: () => getConfig().upload.showErrorStatus
    },
    showProgress: {
      type: Boolean,
      default: () => getConfig().upload.showProgress
    },
    progressText: {
      type: String,
      default: () => getConfig().upload.progressText
    },
    autoHiddenButton: {
      type: Boolean,
      default: () => getConfig().upload.autoHiddenButton
    },
    showUploadButton: {
      type: Boolean,
      default: () => getConfig().upload.showUploadButton
    },
    buttonText: {
      type: String,
      default: () => getConfig().upload.buttonText
    },
    buttonIcon: {
      type: String,
      default: () => getConfig().upload.buttonIcon
    },
    showButtonText: {
      type: Boolean,
      default: () => getConfig().upload.showButtonText
    },
    showButtonIcon: {
      type: Boolean,
      default: () => getConfig().upload.showButtonIcon
    },
    showRemoveButton: {
      type: Boolean,
      default: () => getConfig().upload.showRemoveButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().upload.showDownloadButton
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().upload.showPreview
    },
    tipText: String,
    hintText: String,
    previewMethod: Function,
    uploadMethod: Function,
    beforeRemoveMethod: Function,
    removeMethod: Function,
    beforeDownloadMethod: Function,
    downloadMethod: Function,
    getUrlMethod: Function,
    getThumbnailUrlMethod: Function,
    size: {
      type: String,
      default: () => getConfig().upload.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "add",
    "remove",
    "remove-fail",
    "download",
    "download-fail",
    "upload-success",
    "upload-error",
    "sort-dragend"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils119.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refPopupElem = ref();
    const refDragLineElem = ref();
    const refModalDragLineElem = ref();
    const reactData = reactive({
      isDragUploadStatus: false,
      showMorePopup: false,
      isActivated: false,
      fileList: [],
      fileCacheMaps: {},
      isDragMove: false,
      dragIndex: -1,
      dragTipText: ""
    });
    const internalData = {
      imagePreviewTypes: ["jpg", "jpeg", "png", "gif"],
      prevDragIndex: -1
      // prevDragPos: ''
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeKeyField = computed(() => {
      return props.keyField || "_X_KEY";
    });
    const computeIsImage = computed(() => {
      return props.mode === "image";
    });
    const computeNameProp = computed(() => {
      return props.nameField || "name";
    });
    const computeTypeProp = computed(() => {
      return props.typeField || "type";
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeSizeProp = computed(() => {
      return props.sizeField || "size";
    });
    const computeLimitMaxSizeB = computed(() => {
      return import_xe_utils119.default.toNumber(props.limitSize) * 1024 * 1024;
    });
    const computeLimitMaxCount = computed(() => {
      return props.multiple ? import_xe_utils119.default.toNumber(props.limitCount) : 1;
    });
    const computeOverCount = computed(() => {
      const { multiple } = props;
      const { fileList } = reactData;
      const limitMaxCount = computeLimitMaxCount.value;
      if (multiple) {
        if (limitMaxCount) {
          return fileList.length >= limitMaxCount;
        }
        return true;
      }
      return fileList.length >= 1;
    });
    const computeLimitSizeUnit = computed(() => {
      const limitSize = import_xe_utils119.default.toNumber(props.limitSize);
      if (limitSize) {
        if (limitSize > 1048576) {
          return `${limitSize / 1048576}T`;
        }
        if (limitSize > 1024) {
          return `${limitSize / 1024}G`;
        }
        return `${limitSize}M`;
      }
      return "";
    });
    const computedDefHintText = computed(() => {
      const { limitSize, fileTypes, multiple, limitCount } = props;
      const tipText = props.tipText || props.hintText;
      const isImage = computeIsImage.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      if (import_xe_utils119.default.isString(tipText)) {
        return tipText;
      }
      const defHints = [];
      if (isImage) {
        if (multiple && limitCount) {
          defHints.push(getI18n("vxe.upload.imgCountHint", [limitCount]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push(getI18n("vxe.upload.imgSizeHint", [limitSizeUnit]));
        }
      } else {
        if (fileTypes && fileTypes.length) {
          defHints.push(getI18n("vxe.upload.fileTypeHint", [fileTypes.join("/")]));
        }
        if (limitSize && limitSizeUnit) {
          defHints.push(getI18n("vxe.upload.fileSizeHint", [limitSizeUnit]));
        }
        if (multiple && limitCount) {
          defHints.push(getI18n("vxe.upload.fileCountHint", [limitCount]));
        }
      }
      return defHints.join(getI18n("vxe.base.comma"));
    });
    const computeImageOpts = computed(() => {
      return Object.assign({}, props.imageConfig || props.imageStyle);
    });
    const computeImgStyle = computed(() => {
      const imageOpts = computeImageOpts.value;
      const { width, height } = imageOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMoreOpts = computed(() => {
      return Object.assign({ showMoreButton: true }, props.moreConfig);
    });
    const computeMaps = {};
    const $xeUpload = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getUniqueKey = () => {
      return import_xe_utils119.default.uniqueId();
    };
    const getFieldKey = (item) => {
      const keyField = computeKeyField.value;
      return item[keyField];
    };
    const updateFileList = () => {
      const { modelValue, multiple } = props;
      const formReadonly = computeFormReadonly.value;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const fileList = modelValue ? (modelValue ? import_xe_utils119.default.isArray(modelValue) ? modelValue : [modelValue] : []).map((item) => {
        if (!item || import_xe_utils119.default.isString(item)) {
          const url = `${item || ""}`;
          const name2 = parseFileName(url);
          return {
            [nameProp]: name2,
            [typeProp]: parseFileType(name2),
            [urlProp]: url,
            [sizeProp]: 0,
            [keyField]: getUniqueKey()
          };
        }
        const name = item[nameProp] || "";
        item[nameProp] = name;
        item[typeProp] = item[typeProp] || parseFileType(name);
        item[urlProp] = item[urlProp] || "";
        item[sizeProp] = item[sizeProp] || 0;
        item[keyField] = item[keyField] || getUniqueKey();
        return item;
      }) : [];
      reactData.fileList = formReadonly || multiple ? fileList : fileList.slice(0, 1);
    };
    const parseFileName = (url) => {
      return decodeURIComponent(`${url || ""}`).split("/").pop() || "";
    };
    const parseFileType = (name) => {
      const index2 = name ? name.indexOf(".") : -1;
      if (index2 > -1) {
        return name.substring(index2 + 1, name.length).toLowerCase();
      }
      return "";
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $upload: $xeUpload }, params));
    };
    const handleChange = (value) => {
      const { singleMode, urlMode } = props;
      const urlProp = computeUrlProp.value;
      let restList = value ? value.slice(0) : [];
      if (urlMode) {
        restList = restList.map((item) => item[urlProp]);
      }
      emit("update:modelValue", singleMode ? restList[0] || null : restList);
    };
    const getThumbnailFileUrl = (item) => {
      const getThumbnailUrlFn = props.getThumbnailUrlMethod || getConfig().upload.getThumbnailUrlMethod;
      if (getThumbnailUrlFn) {
        return getThumbnailUrlFn({
          $upload: $xeUpload,
          option: item
        });
      }
      return getFileUrl(item);
    };
    const getFileUrl = (item) => {
      const getUrlFn = props.getUrlMethod || getConfig().upload.getUrlMethod;
      const urlProp = computeUrlProp.value;
      return getUrlFn ? getUrlFn({
        $upload: $xeUpload,
        option: item
      }) : item[urlProp];
    };
    const handleDefaultFilePreview = (item) => {
      const { imageTypes, showDownloadButton } = props;
      const typeProp = computeTypeProp.value;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const { imagePreviewTypes } = internalData;
      if (imagePreviewTypes.concat(imageTypes || []).some((type) => `${type}`.toLowerCase() === `${item[typeProp]}`.toLowerCase())) {
        if (VxeUI.previewImage) {
          VxeUI.previewImage({
            urlList: [getFileUrl(item)],
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? () => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: item
              });
            } : void 0
          });
        }
      }
    };
    const handlePreviewFileEvent = (evnt, item) => {
      const previewFn = props.previewMethod || getConfig().upload.previewMethod;
      if (props.showPreview) {
        if (previewFn) {
          previewFn({
            $upload: $xeUpload,
            option: item
          });
        } else {
          handleDefaultFilePreview(item);
        }
      }
    };
    const handlePreviewImageEvent = (evnt, item, index2) => {
      const { showDownloadButton } = props;
      const { fileList } = reactData;
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      if (props.showPreview) {
        if (VxeUI.previewImage) {
          VxeUI.previewImage({
            urlList: fileList.map((item2) => getFileUrl(item2)),
            activeIndex: index2,
            showDownloadButton,
            beforeDownloadMethod: beforeDownloadFn ? ({ index: index3 }) => {
              return beforeDownloadFn({
                $upload: $xeUpload,
                option: fileList[index3]
              });
            } : void 0
          });
        }
      }
    };
    const handleUploadResult = (item, file) => {
      const { showErrorStatus } = props;
      const fileKey = getFieldKey(item);
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn) {
        return Promise.resolve(uploadFn({
          $upload: $xeUpload,
          file,
          option: item,
          updateProgress(percentNum) {
            const { fileCacheMaps } = reactData;
            const cacheItem = fileCacheMaps[getFieldKey(item)];
            if (cacheItem) {
              cacheItem.percent = Math.max(0, Math.min(99, import_xe_utils119.default.toNumber(percentNum)));
            }
          }
        })).then((res) => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.percent = 100;
          }
          Object.assign(item, res);
          dispatchEvent2("upload-success", { option: item, data: res }, null);
        }).catch((res) => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.status = "error";
          }
          if (showErrorStatus) {
            Object.assign(item, res);
          } else {
            reactData.fileList = reactData.fileList.filter((obj) => getFieldKey(obj) !== fileKey);
          }
          dispatchEvent2("upload-error", { option: item, data: res }, null);
        }).finally(() => {
          const { fileCacheMaps } = reactData;
          const cacheItem = fileCacheMaps[fileKey];
          if (cacheItem) {
            cacheItem.loading = false;
          }
        });
      } else {
        const { fileCacheMaps } = reactData;
        const cacheItem = fileCacheMaps[fileKey];
        if (cacheItem) {
          cacheItem.loading = false;
        }
      }
      return Promise.resolve();
    };
    const handleReUpload = (item) => {
      const { uploadMethod, urlMode } = props;
      const { fileCacheMaps } = reactData;
      const fileKey = getFieldKey(item);
      const cacheItem = fileCacheMaps[fileKey];
      const uploadFn = uploadMethod || getConfig().upload.uploadMethod;
      if (uploadFn && cacheItem) {
        const file = cacheItem.file;
        cacheItem.loading = true;
        cacheItem.status = "";
        cacheItem.percent = 0;
        handleUploadResult(item, file).then(() => {
          if (urlMode) {
            handleChange(reactData.fileList);
          }
        });
      }
    };
    const uploadFile = (files, evnt) => {
      const { multiple, urlMode } = props;
      const { fileList } = reactData;
      const uploadFn = props.uploadMethod || getConfig().upload.uploadMethod;
      const keyField = computeKeyField.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const urlProp = computeUrlProp.value;
      const sizeProp = computeSizeProp.value;
      const limitMaxSizeB = computeLimitMaxSizeB.value;
      const limitMaxCount = computeLimitMaxCount.value;
      const limitSizeUnit = computeLimitSizeUnit.value;
      let selectFiles = files;
      if (multiple && limitMaxCount) {
        if (fileList.length >= limitMaxCount) {
          if (VxeUI.modal) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              content: getI18n("vxe.upload.overCountErr", [limitMaxCount])
            });
          }
          return;
        }
        const overNum = selectFiles.length - (limitMaxCount - fileList.length);
        if (overNum > 0) {
          const overExtraList = selectFiles.slice(limitMaxCount - fileList.length);
          if (VxeUI.modal) {
            VxeUI.modal.notification({
              title: getI18n("vxe.modal.errTitle"),
              status: "error",
              slots: {
                default() {
                  return h("div", {
                    class: "vxe-upload--file-message-over-error"
                  }, [
                    h("div", {}, getI18n("vxe.upload.overCountExtraErr", [limitMaxCount, overNum])),
                    h("div", {
                      class: "vxe-upload--file-message-over-extra"
                    }, overExtraList.map((file, index2) => {
                      return h("div", {
                        key: index2,
                        class: "vxe-upload--file-message-over-extra-item"
                      }, file.name);
                    }))
                  ]);
                }
              }
            });
          }
        }
        selectFiles = selectFiles.slice(0, limitMaxCount - fileList.length);
      }
      if (limitMaxSizeB) {
        for (let i = 0; i < files.length; i++) {
          const file = files[0];
          if (file.size > limitMaxSizeB) {
            if (VxeUI.modal) {
              VxeUI.modal.notification({
                title: getI18n("vxe.modal.errTitle"),
                status: "error",
                content: getI18n("vxe.upload.overSizeErr", [limitSizeUnit])
              });
            }
            return;
          }
        }
      }
      const cacheMaps = Object.assign({}, reactData.fileCacheMaps);
      const newFileList = multiple ? fileList : [];
      const uploadPromiseRests = [];
      selectFiles.forEach((file) => {
        const { name } = file;
        const fileKey = getUniqueKey();
        const fileObj = {
          [nameProp]: name,
          [typeProp]: parseFileType(name),
          [sizeProp]: file.size,
          [urlProp]: "",
          [keyField]: fileKey
        };
        if (uploadFn) {
          cacheMaps[fileKey] = {
            file,
            loading: true,
            status: "",
            percent: 0
          };
        }
        const item = reactive(fileObj);
        if (uploadFn) {
          uploadPromiseRests.push(handleUploadResult(item, file));
        }
        newFileList.push(item);
        dispatchEvent2("add", { option: item }, evnt);
      });
      reactData.fileList = newFileList;
      reactData.fileCacheMaps = cacheMaps;
      Promise.all(urlMode ? uploadPromiseRests : []).then(() => {
        handleChange(newFileList);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, newFileList);
        }
      });
    };
    const handleChoose = (evnt) => {
      const { multiple, imageTypes, fileTypes } = props;
      const isDisabled = computeIsDisabled.value;
      const isImage = computeIsImage.value;
      if (isDisabled) {
        return Promise.resolve({
          status: false,
          files: [],
          file: null
        });
      }
      return readLocalFile({
        multiple,
        types: isImage ? imageTypes : fileTypes
      }).then((params) => {
        uploadFile(params.files, evnt);
        return params;
      });
    };
    const clickEvent = (evnt) => {
      handleChoose(evnt).catch(() => {
      });
    };
    const handleRemoveEvent = (evnt, item, index2) => {
      const { fileList } = reactData;
      fileList.splice(index2, 1);
      handleChange(fileList);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, fileList);
      }
      dispatchEvent2("remove", { option: item }, evnt);
    };
    const removeFileEvent = (evnt, item, index2) => {
      const beforeRemoveFn = props.beforeRemoveMethod || getConfig().upload.beforeRemoveMethod;
      const removeFn = props.removeMethod || getConfig().upload.removeMethod;
      Promise.resolve(beforeRemoveFn ? beforeRemoveFn({
        $upload: $xeUpload,
        option: item
      }) : true).then((status) => {
        if (status) {
          if (removeFn) {
            Promise.resolve(removeFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleRemoveEvent(evnt, item, index2);
            }).catch((e16) => e16);
          } else {
            handleRemoveEvent(evnt, item, index2);
          }
        } else {
          dispatchEvent2("remove-fail", { option: item }, evnt);
        }
      });
    };
    const handleDownloadEvent = (evnt, item) => {
      dispatchEvent2("download", { option: item }, evnt);
    };
    const downloadFileEvent = (evnt, item) => {
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().upload.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || getConfig().upload.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $upload: $xeUpload,
        option: item
      }) : true).then((status) => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $upload: $xeUpload,
              option: item
            })).then(() => {
              handleDownloadEvent(evnt, item);
            }).catch((e16) => e16);
          } else {
            handleDownloadEvent(evnt, item);
          }
        } else {
          dispatchEvent2("download-fail", { option: item }, evnt);
        }
      });
    };
    const handleUploadDragleaveEvent = (evnt) => {
      const targetElem = evnt.currentTarget;
      const { clientX, clientY } = evnt;
      if (targetElem) {
        const { x: targetX, y: targetY, height: targetHeight, width: targetWidth } = targetElem.getBoundingClientRect();
        if (clientX < targetX || clientX > targetX + targetWidth || clientY < targetY || clientY > targetY + targetHeight) {
          reactData.isDragUploadStatus = false;
        }
      }
    };
    const handleUploadDragoverEvent = (evnt) => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const { items } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          reactData.isDragUploadStatus = true;
        }
      }
    };
    const uploadTransferFileEvent = (evnt, files) => {
      const { imageTypes } = props;
      const { imagePreviewTypes } = internalData;
      const isImage = computeIsImage.value;
      if (isImage) {
        const pasteImgTypes = imagePreviewTypes.concat(imageTypes && imageTypes.length ? imageTypes : []);
        files = files.filter((file) => {
          const fileType = `${file.type.split("/")[1] || ""}`.toLowerCase();
          if (pasteImgTypes.some((type) => `${type}`.toLowerCase() === fileType)) {
            return true;
          }
          return false;
        });
      }
      if (!files.length) {
        if (VxeUI.modal) {
          VxeUI.modal.notification({
            title: getI18n("vxe.modal.errTitle"),
            status: "error",
            content: getI18n("vxe.upload.uploadTypeErr")
          });
        }
        return;
      }
      uploadFile(files, evnt);
    };
    const handleUploadDropEvent = (evnt) => {
      const dataTransfer = evnt.dataTransfer;
      if (dataTransfer) {
        const { items } = dataTransfer;
        if (items && items.length) {
          evnt.preventDefault();
          const files = handleTransferFiles(items);
          if (files.length) {
            uploadTransferFileEvent(evnt, files);
          }
        }
      }
      reactData.isDragUploadStatus = false;
    };
    const handleTransferFiles = (items) => {
      const files = [];
      import_xe_utils119.default.arrayEach(items, (item) => {
        const file = item.getAsFile();
        if (file) {
          files.push(file);
        }
      });
      return files;
    };
    const handleMoreEvent = () => {
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      if (VxeUI.modal) {
        VxeUI.modal.open({
          title: formReadonly ? getI18n("vxe.upload.morePopup.readTitle") : getI18n(`vxe.upload.morePopup.${isImage ? "imageTitle" : "fileTitle"}`),
          width: 660,
          height: 500,
          escClosable: true,
          showMaximize: true,
          resize: true,
          maskClosable: true,
          slots: {
            default() {
              const { showErrorStatus, dragToUpload, dragSort } = props;
              const { isDragMove, isDragUploadStatus, dragIndex } = reactData;
              const { fileList } = reactData;
              const isDisabled = computeIsDisabled.value;
              const ons = {};
              if (dragToUpload && dragIndex === -1) {
                ons.onDragover = handleUploadDragoverEvent;
                ons.onDragleave = handleUploadDragleaveEvent;
                ons.onDrop = handleUploadDropEvent;
              }
              return h("div", Object.assign({ ref: refPopupElem, class: ["vxe-upload--more-popup", {
                "is--readonly": formReadonly,
                "is--disabled": isDisabled,
                "show--error": showErrorStatus,
                "is--drag": isDragUploadStatus
              }] }, ons), [
                isImage ? dragSort ? h(TransitionGroup, {
                  name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
                  tag: "div",
                  class: "vxe-upload--image-more-list"
                }, {
                  default: () => renderImageItemList(fileList, true).concat(renderImageAction(true))
                }) : h("div", {
                  class: "vxe-upload--image-more-list"
                }, renderImageItemList(fileList, true).concat(renderImageAction(true))) : h("div", {
                  class: "vxe-upload--file-more-list"
                }, [
                  renderFileAction(true),
                  dragSort ? h(TransitionGroup, {
                    name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
                    tag: "div",
                    class: "vxe-upload--file-list"
                  }, {
                    default: () => renderFileItemList(fileList, false)
                  }) : h("div", {
                    class: "vxe-upload--file-list"
                  }, renderFileItemList(fileList, true))
                ]),
                dragSort ? h("div", {
                  ref: refModalDragLineElem,
                  class: "vxe-upload--drag-line"
                }) : renderEmptyElement($xeUpload),
                isDragUploadStatus ? h("div", {
                  class: "vxe-upload--drag-placeholder"
                }, getI18n("vxe.upload.dragPlaceholder")) : renderEmptyElement($xeUpload)
              ]);
            }
          },
          onShow() {
            reactData.showMorePopup = true;
          },
          onHide() {
            reactData.showMorePopup = false;
          }
        });
      }
    };
    const showDropTip = (evnt, dragEl2, dragPos) => {
      const { showMorePopup } = reactData;
      const el2 = refElem.value;
      const popupEl = refPopupElem.value;
      const wrapperEl = showMorePopup ? popupEl : el2;
      if (!wrapperEl) {
        return;
      }
      const wrapperRect = wrapperEl.getBoundingClientRect();
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      const currDLineEl = showMorePopup ? mdLineEl : ddLineEl;
      if (currDLineEl) {
        const dragRect = dragEl2.getBoundingClientRect();
        currDLineEl.style.display = "block";
        currDLineEl.style.top = `${Math.max(1, dragRect.y - wrapperRect.y)}px`;
        currDLineEl.style.left = `${Math.max(1, dragRect.x - wrapperRect.x)}px`;
        currDLineEl.style.height = `${dragRect.height}px`;
        currDLineEl.style.width = `${dragRect.width - 1}px`;
        currDLineEl.setAttribute("drag-pos", dragPos);
      }
    };
    const hideDropTip = () => {
      const ddLineEl = refDragLineElem.value;
      const mdLineEl = refModalDragLineElem.value;
      if (ddLineEl) {
        ddLineEl.style.display = "";
      }
      if (mdLineEl) {
        mdLineEl.style.display = "";
      }
    };
    const handleDragSortDragstartEvent = (evnt) => {
      if (evnt.dataTransfer) {
        const img = new Image();
        img.src = tpImg2;
        evnt.dataTransfer.setDragImage(img, 0, 0);
      }
      const dragEl2 = evnt.currentTarget;
      const parentEl2 = dragEl2.parentElement;
      const dragIndex = import_xe_utils119.default.findIndexOf(Array.from(parentEl2.children), (item) => dragEl2 === item);
      reactData.isDragMove = true;
      reactData.dragIndex = dragIndex;
      setTimeout(() => {
        reactData.isDragMove = false;
      }, 500);
    };
    const handleDragSortDragoverEvent = (evnt) => {
      evnt.preventDefault();
      const { dragIndex } = reactData;
      if (dragIndex === -1) {
        return;
      }
      const isImage = computeIsImage.value;
      const dragEl2 = evnt.currentTarget;
      const parentEl2 = dragEl2.parentElement;
      const currIndex = import_xe_utils119.default.findIndexOf(Array.from(parentEl2.children), (item) => dragEl2 === item);
      let dragPos = "";
      if (isImage) {
        const offsetX = evnt.clientX - dragEl2.getBoundingClientRect().x;
        dragPos = offsetX < dragEl2.clientWidth / 2 ? "left" : "right";
      } else {
        const offsetY = evnt.clientY - dragEl2.getBoundingClientRect().y;
        dragPos = offsetY < dragEl2.clientHeight / 2 ? "top" : "bottom";
      }
      if (dragIndex === currIndex) {
        showDropTip(evnt, dragEl2, dragPos);
        return;
      }
      showDropTip(evnt, dragEl2, dragPos);
      internalData.prevDragIndex = currIndex;
      internalData.prevDragPos = dragPos;
    };
    const handleDragSortDragendEvent = (evnt) => {
      const { fileList, dragIndex } = reactData;
      const { prevDragIndex, prevDragPos } = internalData;
      const oldIndex2 = dragIndex;
      const targetIndex = prevDragIndex;
      const dragOffsetIndex = prevDragPos === "bottom" || prevDragPos === "right" ? 1 : 0;
      const oldItem = fileList[oldIndex2];
      const newItem = fileList[targetIndex];
      if (oldItem && newItem) {
        fileList.splice(oldIndex2, 1);
        const ptfIndex = import_xe_utils119.default.findIndexOf(fileList, (item) => newItem === item);
        const nIndex = ptfIndex + dragOffsetIndex;
        fileList.splice(nIndex, 0, oldItem);
        dispatchEvent2("sort-dragend", {
          oldItem,
          newItem,
          dragPos: prevDragPos,
          offsetIndex: dragOffsetIndex,
          _index: {
            newIndex: nIndex,
            oldIndex: oldIndex2
          }
        }, evnt);
      }
      hideDropTip();
      reactData.dragIndex = -1;
    };
    const handleGlobalPasteEvent = (evnt) => {
      const { pasteToUpload } = props;
      const { isActivated } = reactData;
      if (!isActivated || !pasteToUpload) {
        return;
      }
      const clipboardData = evnt.clipboardData || evnt.originalEvent.clipboardData;
      if (!clipboardData) {
        return;
      }
      const { items } = clipboardData;
      if (!items) {
        return;
      }
      const files = handleTransferFiles(items);
      if (files.length) {
        evnt.preventDefault();
        uploadTransferFileEvent(evnt, files);
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const el2 = refElem.value;
      const isActivated = getEventTargetNode2(evnt, el2).flag;
      reactData.isActivated = isActivated;
    };
    const handleGlobalBlurEvent = () => {
      reactData.isActivated = false;
    };
    const uploadMethods = {
      dispatchEvent: dispatchEvent2,
      choose() {
        return handleChoose(null);
      }
    };
    const uploadPrivateMethods = {};
    Object.assign($xeUpload, uploadMethods, uploadPrivateMethods);
    const renderFileItemList = (currList, isMoreView) => {
      const { showRemoveButton, showDownloadButton, showProgress, progressText, showPreview, showErrorStatus, dragSort } = props;
      const { fileCacheMaps } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const nameProp = computeNameProp.value;
      const typeProp = computeTypeProp.value;
      const cornerSlot = slots.corner;
      const ons = {};
      if (dragSort) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index2) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        const isLoading = cacheItem && cacheItem.loading;
        const isError = cacheItem && cacheItem.status === "error";
        return h("div", Object.assign({ key: dragSort ? fileKey : index2, class: ["vxe-upload--file-item", {
          "is--preview": showPreview,
          "is--loading": isLoading,
          "is--error": isError
        }], fileid: fileKey, draggable: dragSort ? true : null }, ons), [
          h("div", {
            class: "vxe-upload--file-item-icon"
          }, [
            h("i", {
              class: getIcon()[`UPLOAD_FILE_TYPE_${`${item[typeProp]}`.toLocaleUpperCase()}`] || getIcon().UPLOAD_FILE_TYPE_DEFAULT
            })
          ]),
          h("div", {
            class: "vxe-upload--file-item-name",
            onClick(evnt) {
              if (!isLoading && !isError) {
                handlePreviewFileEvent(evnt, item);
              }
            }
          }, `${item[nameProp] || ""}`),
          isLoading ? h("div", {
            class: "vxe-upload--file-item-loading-icon"
          }, [
            h("i", {
              class: getIcon().UPLOAD_LOADING
            })
          ]) : createCommentVNode(),
          showProgress && isLoading && cacheItem ? h("div", {
            class: "vxe-upload--file-item-loading-text"
          }, progressText ? import_xe_utils119.default.toFormatString(progressText, { percent: cacheItem.percent }) : getI18n("vxe.upload.uploadProgress", [cacheItem.percent])) : createCommentVNode(),
          showErrorStatus && isError ? h("div", {
            class: "vxe-upload--image-item-error"
          }, [
            h(button_default, {
              icon: getIcon().UPLOAD_IMAGE_RE_UPLOAD,
              mode: "text",
              status: "primary",
              content: getI18n("vxe.upload.reUpload"),
              onClick() {
                handleReUpload(item);
              }
            })
          ]) : createCommentVNode(),
          h("div", {
            class: "vxe-upload--file-item-btn-wrapper"
          }, [
            cornerSlot ? h("div", {
              class: "vxe-upload--file-item-corner"
            }, getSlotVNs2(cornerSlot({ option: item, isMoreView, readonly: formReadonly }))) : createCommentVNode(),
            showDownloadButton && !isLoading ? h("div", {
              class: "vxe-upload--file-item-download-btn",
              onClick(evnt) {
                downloadFileEvent(evnt, item);
              }
            }, [
              h("i", {
                class: getIcon().UPLOAD_FILE_DOWNLOAD
              })
            ]) : createCommentVNode(),
            showRemoveButton && !formReadonly && !isDisabled && !isLoading ? h("div", {
              class: "vxe-upload--file-item-remove-btn",
              onClick(evnt) {
                removeFileEvent(evnt, item, index2);
              }
            }, [
              h("i", {
                class: getIcon().UPLOAD_FILE_REMOVE
              })
            ]) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderFileAction = (isMoreView) => {
      const { showUploadButton, buttonText, buttonIcon, showButtonText, showButtonIcon, autoHiddenButton } = props;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const defaultSlot = slots.default;
      const tipSlot = slots.tip || slots.hint;
      if (formReadonly || !showUploadButton) {
        return createCommentVNode();
      }
      return h("div", {
        class: "vxe-upload--file-action"
      }, [
        autoHiddenButton && overCount ? createCommentVNode() : h("div", {
          class: "vxe-upload--file-action-btn",
          onClick: clickEvent
        }, defaultSlot ? getSlotVNs2(defaultSlot({ $upload: $xeUpload })) : [
          h(button_default, {
            class: "vxe-upload--file-action-button",
            content: isMoreView || showButtonText ? buttonText ? `${buttonText}` : getI18n("vxe.upload.fileBtnText") : "",
            icon: showButtonIcon ? buttonIcon || getIcon().UPLOAD_FILE_ADD : "",
            disabled: isDisabled
          })
        ]),
        isMoreView && (defHintText || tipSlot) ? h("div", {
          class: "vxe-upload--file-action-tip"
        }, tipSlot ? getSlotVNs2(tipSlot({ $upload: $xeUpload })) : defHintText) : createCommentVNode()
      ]);
    };
    const renderAllMode = () => {
      const { moreConfig, dragSort } = props;
      const { fileList, isDragMove } = reactData;
      const moreOpts = computeMoreOpts.value;
      const { maxCount, showMoreButton, layout } = moreOpts;
      const isHorizontal = layout === "horizontal";
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return h("div", {
        key: "all",
        class: "vxe-upload--file-wrapper"
      }, [
        showMoreButton && moreConfig && isHorizontal ? createCommentVNode() : renderFileAction(true),
        currList.length || showMoreButton && isHorizontal ? h("div", {
          class: ["vxe-upload--file-list-wrapper", {
            "is--horizontal": isHorizontal
          }]
        }, [
          currList.length ? dragSort ? h(TransitionGroup, {
            name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
            tag: "div",
            class: "vxe-upload--file-list"
          }, {
            default: () => renderFileItemList(currList, false)
          }) : h("div", {
            class: "vxe-upload--file-list"
          }, renderFileItemList(currList, false)) : createCommentVNode(),
          showMoreButton && overMaxNum ? h("div", {
            class: "vxe-upload--file-over-more"
          }, [
            h(button_default, {
              mode: "text",
              content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
              status: "primary",
              onClick: handleMoreEvent
            })
          ]) : createCommentVNode(),
          showMoreButton && moreConfig && isHorizontal ? renderFileAction(false) : createCommentVNode()
        ]) : createCommentVNode()
      ]);
    };
    const renderImageItemList = (currList, isMoreView) => {
      const { showRemoveButton, showProgress, progressText, showPreview, showErrorStatus, dragSort } = props;
      const { fileCacheMaps } = reactData;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const imageOpts = computeImageOpts.value;
      const imgStyle = computeImgStyle.value;
      const cornerSlot = slots.corner;
      const ons = {};
      if (dragSort) {
        ons.onDragstart = handleDragSortDragstartEvent;
        ons.onDragover = handleDragSortDragoverEvent;
        ons.onDragend = handleDragSortDragendEvent;
      }
      return currList.map((item, index2) => {
        const fileKey = getFieldKey(item);
        const cacheItem = fileCacheMaps[fileKey];
        const isLoading = cacheItem && cacheItem.loading;
        const isError = cacheItem && cacheItem.status === "error";
        return h("div", Object.assign({ key: dragSort ? fileKey : index2, class: ["vxe-upload--image-item", {
          "is--preview": showPreview,
          "is--circle": imageOpts.circle,
          "is--loading": isLoading,
          "is--error": isError
        }], fileid: fileKey, draggable: dragSort ? true : null }, ons), [
          h("div", {
            class: "vxe-upload--image-item-box",
            style: isMoreView ? null : imgStyle,
            title: getI18n("vxe.upload.viewItemTitle"),
            onClick(evnt) {
              if (!isLoading && !isError) {
                handlePreviewImageEvent(evnt, item, index2);
              }
            }
          }, [
            isLoading && cacheItem ? h("div", {
              class: "vxe-upload--image-item-loading"
            }, [
              h("div", {
                class: "vxe-upload--image-item-loading-icon"
              }, [
                h("i", {
                  class: getIcon().UPLOAD_LOADING
                })
              ]),
              showProgress ? h("div", {
                class: "vxe-upload--image-item-loading-text"
              }, progressText ? import_xe_utils119.default.toFormatString(progressText, { percent: cacheItem.percent }) : getI18n("vxe.upload.uploadProgress", [cacheItem.percent])) : createCommentVNode()
            ]) : createCommentVNode(),
            !isLoading ? isError && showErrorStatus ? h("div", {
              class: "vxe-upload--image-item-error"
            }, [
              h(button_default, {
                icon: getIcon().UPLOAD_IMAGE_RE_UPLOAD,
                mode: "text",
                status: "primary",
                content: getI18n("vxe.upload.reUpload"),
                onClick() {
                  handleReUpload(item);
                }
              })
            ]) : h("div", {
              class: "vxe-upload--image-item-img-wrapper"
            }, [
              h("img", {
                class: "vxe-upload--image-item-img",
                src: getThumbnailFileUrl(item)
              })
            ]) : createCommentVNode(),
            h("div", {
              class: "vxe-upload--image-item-btn-wrapper",
              onClick(evnt) {
                evnt.stopPropagation();
              }
            }, [
              cornerSlot ? h("div", {
                class: "vxe-upload--file-item-corner"
              }, getSlotVNs2(cornerSlot({ option: item, isMoreView, readonly: formReadonly }))) : createCommentVNode(),
              showRemoveButton && !formReadonly && !isDisabled && !isLoading ? h("div", {
                class: "vxe-upload--image-item-remove-btn",
                onClick(evnt) {
                  evnt.stopPropagation();
                  removeFileEvent(evnt, item, index2);
                }
              }, [
                h("i", {
                  class: getIcon().UPLOAD_IMAGE_REMOVE
                })
              ]) : createCommentVNode()
            ])
          ])
        ]);
      });
    };
    const renderImageAction = (isMoreView) => {
      const { showUploadButton, buttonText, buttonIcon, showButtonText, showButtonIcon, autoHiddenButton } = props;
      const formReadonly = computeFormReadonly.value;
      const defHintText = computedDefHintText.value;
      const overCount = computeOverCount.value;
      const imgStyle = computeImgStyle.value;
      const defaultSlot = slots.default;
      const hintSlot = slots.hint;
      if (formReadonly || !showUploadButton || autoHiddenButton && overCount) {
        return createCommentVNode();
      }
      return h("div", {
        key: "action",
        class: "vxe-upload--image-action"
      }, [
        h("div", {
          class: "vxe-upload--image-action-btn",
          onClick: clickEvent
        }, defaultSlot ? defaultSlot({ $upload: $xeUpload }) : [
          h("div", {
            class: "vxe-upload--image-action-box",
            style: isMoreView ? null : imgStyle
          }, [
            showButtonIcon ? h("div", {
              class: "vxe-upload--image-action-icon"
            }, [
              h("i", {
                class: buttonIcon || getIcon().UPLOAD_IMAGE_ADD
              })
            ]) : createCommentVNode(),
            isMoreView || showButtonText ? h("div", {
              class: "vxe-upload--image-action-content"
            }, buttonText ? `${buttonText}` : getI18n("vxe.upload.imgBtnText")) : createCommentVNode(),
            isMoreView && (defHintText || hintSlot) ? h("div", {
              class: "vxe-upload--image-action-hint"
            }, hintSlot ? getSlotVNs2(hintSlot({ $upload: $xeUpload })) : defHintText) : createCommentVNode()
          ])
        ])
      ]);
    };
    const renderImageMode = () => {
      const { dragSort } = props;
      const { fileList, isDragMove } = reactData;
      const moreOpts = computeMoreOpts.value;
      const { maxCount, showMoreButton } = moreOpts;
      let currList = fileList;
      let overMaxNum = 0;
      if (maxCount && fileList.length > maxCount) {
        overMaxNum = fileList.length - maxCount;
        currList = fileList.slice(0, maxCount);
      }
      return h("div", {
        key: "image",
        class: "vxe-upload--image-wrapper"
      }, [
        dragSort ? h(TransitionGroup, {
          name: `vxe-upload--drag-list${isDragMove ? "" : "-disabled"}`,
          tag: "div",
          class: "vxe-upload--image-list"
        }, {
          default: () => renderImageItemList(currList, false).concat([
            showMoreButton && overMaxNum ? h("div", {
              key: "om",
              class: "vxe-upload--image-over-more"
            }, [
              h(button_default, {
                mode: "text",
                content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
                status: "primary",
                onClick: handleMoreEvent
              })
            ]) : createCommentVNode(),
            renderImageAction(false)
          ])
        }) : h("div", {
          class: "vxe-upload--image-list"
        }, renderImageItemList(currList, false).concat([
          showMoreButton && overMaxNum ? h("div", {
            class: "vxe-upload--image-over-more"
          }, [
            h(button_default, {
              mode: "text",
              content: getI18n("vxe.upload.moreBtnText", [fileList.length]),
              status: "primary",
              onClick: handleMoreEvent
            })
          ]) : createCommentVNode(),
          renderImageAction(false)
        ]))
      ]);
    };
    const renderVN = () => {
      const { showErrorStatus, dragToUpload, pasteToUpload, dragSort } = props;
      const { isDragUploadStatus, showMorePopup, isActivated, dragIndex } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const formReadonly = computeFormReadonly.value;
      const isImage = computeIsImage.value;
      const ons = {};
      if (dragToUpload && dragIndex === -1) {
        ons.onDragover = handleUploadDragoverEvent;
        ons.onDragleave = handleUploadDragleaveEvent;
        ons.onDrop = handleUploadDropEvent;
      }
      return h("div", Object.assign({ ref: refElem, class: ["vxe-upload", {
        [`size--${vSize}`]: vSize,
        "is--active": isActivated,
        "is--readonly": formReadonly,
        "is--disabled": isDisabled,
        "is--paste": pasteToUpload,
        "show--error": showErrorStatus,
        "is--drag": isDragUploadStatus
      }] }, ons), [
        isImage ? renderImageMode() : renderAllMode(),
        dragSort ? h("div", {
          ref: refDragLineElem,
          class: "vxe-upload--drag-line"
        }) : renderEmptyElement($xeUpload),
        isDragUploadStatus && !showMorePopup ? h("div", {
          class: "vxe-upload--drag-placeholder"
        }, getI18n("vxe.upload.dragPlaceholder")) : renderEmptyElement($xeUpload)
      ]);
    };
    const listFlag = ref(0);
    watch(() => props.modelValue ? props.modelValue.length : 0, () => {
      listFlag.value++;
    });
    watch(() => props.modelValue, () => {
      listFlag.value++;
    });
    watch(listFlag, () => {
      updateFileList();
    });
    onMounted(() => {
      if (true) {
        if (props.multiple && props.singleMode) {
          errLog2("vxe.error.errConflicts", ["multiple", "single-mode"]);
        }
        if (props.imageStyle) {
          warnLog2("vxe.error.delProp", ["image-style", "image-config"]);
        }
      }
      globalEvents.on($xeUpload, "paste", handleGlobalPasteEvent);
      globalEvents.on($xeUpload, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeUpload, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      reactData.isDragUploadStatus = false;
      globalEvents.off($xeUpload, "paste");
      globalEvents.off($xeUpload, "mousedown");
      globalEvents.off($xeUpload, "blur");
    });
    updateFileList();
    $xeUpload.renderVN = renderVN;
    return $xeUpload;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-file/vxe-upload-file-view.js
var WidgetVxeUploadFileViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(upload_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: "all",
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-data.js
var getWidgetVxeUploadImageConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-file-image",
    options: {
      limitCount: 9,
      limitSize: 10,
      multiple: false
    }
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-form.js
var WidgetVxeUploadImageFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    const limitSizeOptions = ref(getLimitSizeOptions());
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.multiImg"),
              field: "multiple",
              itemRender: { name: "VxeSwitch" }
            }),
            options.multiple ? h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitImgCount"),
              field: "limitCount",
              itemRender: { name: "VxeInput", props: { type: "integer", min: 1, clearable: true } }
            }) : createCommentVNode(),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.uploadProp.limitImgSize"),
              field: "limitSize",
              itemRender: { name: "VxeSelect", options: limitSizeOptions.value }
            }),
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.required")
            }, {
              default() {
                return h(switch_default, {
                  modelValue: widget.required,
                  "onUpdate:modelValue"(val) {
                    widget.required = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-upload-image/vxe-upload-image-view.js
var WidgetVxeUploadImageViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const { options } = widget;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        title: widget.title,
        field: widget.field,
        itemRender: {}
      }, {
        default() {
          return h(upload_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            mode: "image",
            multiple: options.multiple,
            limitCount: options.limitCount,
            limitSize: options.limitSize,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-data.js
var getWidgetVxeRateConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-star",
    query: true,
    options: {}
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-form.js
var WidgetVxeRateFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/rate/src/rate.js
var import_xe_utils120 = __toESM(require_xe_utils());
var rate_default = defineComponent({
  name: "VxeRate",
  props: {
    modelValue: [Number, String],
    disabled: {
      type: Boolean,
      default: null
    },
    readonly: {
      type: Boolean,
      default: null
    },
    size: {
      type: String,
      default: () => getConfig().rate.size || getConfig().size
    },
    status: String
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils120.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({
      activeValue: null
    });
    const refMaps = {
      refElem
    };
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeIsReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly || $xeForm.props.disabled;
        }
        return false;
      }
      return readonly;
    });
    const computeNumVal = computed(() => {
      const { modelValue } = props;
      const { activeValue } = reactData;
      return import_xe_utils120.default.toNumber(activeValue === null ? modelValue : activeValue);
    });
    const computeItemList = computed(() => {
      return [1, 2, 3, 4, 5].map((num) => {
        return {
          value: num,
          label: num
        };
      });
    });
    const computeMaps = {};
    const $xeRate = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $rate: $xeRate }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const mouseenterEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        reactData.activeValue = value;
      }
    };
    const mouseleaveEvent = () => {
      reactData.activeValue = null;
    };
    const clickEvent = (evnt, item) => {
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      if (!(isDisabled || isReadonly)) {
        const value = item.value;
        emitModel(value);
        dispatchEvent2("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    Object.assign($xeRate, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { status } = props;
      const isDisabled = computeIsDisabled.value;
      const isReadonly = computeIsReadonly.value;
      const itemList = computeItemList.value;
      const vSize = computeSize.value;
      const numVal = computeNumVal.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-rate", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--disabled": isDisabled,
          "is--readonly": isReadonly
        }]
      }, itemList.map((item) => {
        const isChecked = numVal >= item.value;
        return h("div", {
          class: ["vxe-rte--item", {
            "is--checked": isChecked
          }],
          onMouseenter(evnt) {
            if (!(isDisabled || isReadonly)) {
              mouseenterEvent(evnt, item);
            }
          },
          onMouseleave: mouseleaveEvent,
          onClick(evnt) {
            if (!(isDisabled || isReadonly)) {
              clickEvent(evnt, item);
            }
          }
        }, [
          h("i", {
            class: isChecked ? getIcon().RATE_CHECKED : getIcon().RATE_UNCHECKED
          })
        ]);
      }));
    };
    $xeRate.renderVN = renderVN;
    return $xeRate;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-rate/vxe-rate-view.js
var WidgetVxeRateViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(rate_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-data.js
var getWidgetVxeSliderConfig = () => {
  return {
    title: handleGetFormDesignWidgetName,
    icon: "vxe-icon-slider",
    query: true,
    options: {}
  };
};

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-form.js
var WidgetVxeSliderFormComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const { computeKebabCaseName } = useWidgetName(props);
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_default, {
        class: ["vxe-form-design--widget-render-form-wrapper", `widget-${kebabCaseName}`],
        vertical: true,
        span: 24,
        titleBold: true,
        titleOverflow: true,
        data: widget.options
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.formDesign.widgetProp.name")
            }, {
              default() {
                return h(input_default, {
                  modelValue: widget.title,
                  "onUpdate:modelValue"(val) {
                    widget.title = val;
                  }
                });
              }
            })
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/slider/src/slider.js
var import_xe_utils121 = __toESM(require_xe_utils());
var slider_default = defineComponent({
  name: "VxeSlider",
  props: {
    modelValue: [String, Number, Array],
    vertical: Boolean,
    max: {
      type: [String, Number],
      default: () => getConfig().slider.max
    },
    min: {
      type: [String, Number],
      default: () => getConfig().slider.min
    },
    step: {
      type: [String, Number],
      default: () => getConfig().slider.step
    },
    size: {
      type: String,
      default: () => getConfig().slider.size || getConfig().size
    },
    range: {
      type: Boolean,
      default: () => getConfig().slider.range
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils121.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refBarElem = ref();
    const refTrackElem = ref();
    const refStartBtnElem = ref();
    const refEndBtnElem = ref();
    const reactData = reactive({
      startValue: 0,
      endValue: 0
    });
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeMaxNum = computed(() => {
      return import_xe_utils121.default.toNumber(props.max || 0);
    });
    const computeMinNum = computed(() => {
      return import_xe_utils121.default.toNumber(props.min || 0);
    });
    const computeMaps = {};
    const $xeSlider = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $slider: $xeSlider }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const getStartPercent = (startValue) => {
      const { range } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return range ? import_xe_utils121.default.floor((startValue - minNum) / import_xe_utils121.default.toNumber(maxNum - minNum) * 100) : 0;
    };
    const getEndPercent = (startValue, endValue) => {
      const { range } = props;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      return import_xe_utils121.default.floor((endValue - (range ? startValue : 0) - minNum) / import_xe_utils121.default.toNumber(maxNum - minNum) * 100);
    };
    const updateModel = () => {
      const { modelValue } = props;
      if (import_xe_utils121.default.isArray(modelValue)) {
        const [sVal, eVal] = import_xe_utils121.default.clone(modelValue, true).sort();
        reactData.startValue = import_xe_utils121.default.floor(import_xe_utils121.default.toNumber(sVal || 0));
        reactData.endValue = import_xe_utils121.default.floor(import_xe_utils121.default.toNumber(eVal || 0));
      } else {
        reactData.startValue = 0;
        reactData.endValue = import_xe_utils121.default.floor(import_xe_utils121.default.toNumber(modelValue || 0));
      }
    };
    const updateBarStyle = () => {
      const { startValue, endValue } = reactData;
      const trackElem = refTrackElem.value;
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = refEndBtnElem.value;
      let startPercent = 0;
      let endPercent = 0;
      if (startValue > endValue) {
        startPercent = getStartPercent(endValue);
        endPercent = getEndPercent(endValue, startValue);
      } else {
        startPercent = getStartPercent(startValue);
        endPercent = getEndPercent(startValue, endValue);
      }
      if (trackElem) {
        trackElem.style.left = `${startPercent}%`;
        trackElem.style.width = `${endPercent}%`;
      }
      if (startBtnElem) {
        startBtnElem.style.left = `${startPercent}%`;
      }
      if (endBtnElem) {
        endBtnElem.style.left = `${import_xe_utils121.default.floor(startPercent + endPercent)}%`;
      }
    };
    const changeEvent = (evnt) => {
      const { range } = props;
      const { startValue, endValue } = reactData;
      const value = range ? [startValue, endValue].sort() : endValue;
      emitModel(value);
      dispatchEvent2("change", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const handleMousedownEvent = (evnt, isEnd) => {
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      const maxNum = computeMaxNum.value;
      const minNum = computeMinNum.value;
      if (!(formReadonly || isDisabled)) {
        evnt.preventDefault();
        const domMousemove = document.onmousemove;
        const domMouseup = document.onmouseup;
        document.onmousemove = (evnt2) => {
          evnt2.preventDefault();
          const el2 = refElem.value;
          const barElem = refBarElem.value;
          if (el2 && barElem) {
            const barRect = barElem.getBoundingClientRect();
            const trackWidth = (evnt2.clientX - barRect.left) / barRect.width;
            if (isEnd) {
              reactData.endValue = import_xe_utils121.default.floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum) + minNum)));
            } else {
              reactData.startValue = import_xe_utils121.default.floor(Math.max(minNum, Math.min(maxNum, trackWidth * (maxNum - minNum))));
            }
          }
          updateBarStyle();
        };
        document.onmouseup = (evnt2) => {
          document.onmousemove = domMousemove;
          document.onmouseup = domMouseup;
          changeEvent(evnt2);
          updateBarStyle();
        };
      }
    };
    const handleStartMousedownEvent = (evnt) => {
      const endBtnElem = refEndBtnElem.value;
      const startBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, endBtnElem ? endBtnElem.offsetLeft < startBtnElem.offsetLeft : false);
    };
    const handleEndMousedownEvent = (evnt) => {
      const startBtnElem = refStartBtnElem.value;
      const endBtnElem = evnt.currentTarget;
      handleMousedownEvent(evnt, startBtnElem ? endBtnElem.offsetLeft > startBtnElem.offsetLeft : true);
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeSlider, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { vertical, range } = props;
      const vSize = computeSize.value;
      const formReadonly = computeFormReadonly.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-slider", {
          [`size--${vSize}`]: vSize,
          "is--vertical": vertical,
          "is--readonly": formReadonly,
          "is--disabled": isDisabled
        }]
      }, [
        h("div", {
          class: "vxe-slider--inner"
        }, [
          h("div", {
            ref: refBarElem,
            class: "vxe-slider--bar-wrapper"
          }),
          h("div", {
            ref: refTrackElem,
            class: "vxe-slider--bar-track"
          }),
          formReadonly || !range ? renderEmptyElement($xeSlider) : h("div", {
            ref: refStartBtnElem,
            class: "vxe-slider--bar-btn vxe-slider--start-btn",
            onMousedown: handleStartMousedownEvent
          }),
          formReadonly ? renderEmptyElement($xeSlider) : h("div", {
            ref: refEndBtnElem,
            class: "vxe-slider--bar-btn vxe-slider--end-btn",
            onMousedown: handleEndMousedownEvent
          })
        ])
      ]);
    };
    watch(() => props.modelValue, () => {
      updateModel();
    });
    onMounted(() => {
      updateBarStyle();
    });
    updateModel();
    $xeSlider.renderVN = renderVN;
    return $xeSlider;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/form-design/widget-vxe-slider/vxe-slider-view.js
var WidgetVxeSliderViewComponent = defineComponent({
  props: {
    renderOpts: {
      type: Object,
      default: () => ({})
    },
    renderParams: {
      type: Object,
      default: () => ({})
    }
  },
  emits: [],
  setup(props) {
    const $xeFormView = inject("$xeFormView", null);
    const { computeKebabCaseName } = useWidgetName(props);
    const changeEvent = () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      if ($xeFormView) {
        const itemValue = $xeFormView ? $xeFormView.getItemValue(widget) : null;
        $xeFormView.updateWidgetStatus(widget, itemValue);
      }
    };
    return () => {
      const { renderParams } = props;
      const { widget } = renderParams;
      const kebabCaseName = computeKebabCaseName.value;
      return h(form_item_default, {
        class: ["vxe-form-design--widget-render-form-item", `widget-${kebabCaseName}`],
        field: widget.field,
        title: widget.title,
        itemRender: {}
      }, {
        default() {
          return h(slider_default, {
            modelValue: $xeFormView ? $xeFormView.getItemValue(widget) : null,
            onChange: changeEvent,
            "onUpdate:modelValue"(val) {
              if ($xeFormView) {
                $xeFormView.setItemValue(widget, val);
              }
            }
          });
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/form-design/render/index.js
renderer.mixin({
  text: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextFormComponent, { renderOpts, renderParams });
    }
  },
  /**
   * 已废弃
   */
  title: {
    createFormDesignWidgetConfig: getWidgetTextConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextFormComponent, { renderOpts, renderParams });
    }
  },
  row: {
    createFormDesignWidgetConfig: getWidgetRowConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return h(WidgetRowEditComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetRowViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetRowFormComponent, { renderOpts, renderParams });
    }
  },
  subtable: {
    createFormDesignWidgetConfig: getWidgetSubtableConfig,
    renderFormDesignWidgetEdit(renderOpts, renderParams) {
      return h(WidgetSubtableEditComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetSubtableViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetSubtableFormComponent, { renderOpts, renderParams });
    }
  },
  input: {
    createFormDesignWidgetConfig: getWidgetInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetInputFormComponent, { renderOpts, renderParams });
    }
  },
  textarea: {
    createFormDesignWidgetConfig: getWidgetTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetTextareaViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetTextareaFormComponent, { renderOpts, renderParams });
    }
  },
  select: {
    createFormDesignWidgetConfig: getWidgetSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeInput: {
    createFormDesignWidgetConfig: getWidgetVxeInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeInputFormComponent, { renderOpts, renderParams });
    }
  },
  VxeNumberInput: {
    createFormDesignWidgetConfig: getWidgetVxeNumberInputConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeNumberInputViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeNumberInputFormComponent, { renderOpts, renderParams });
    }
  },
  VxeDatePicker: {
    createFormDesignWidgetConfig: getWidgetVxeDatePickerConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeDatePickerViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeDatePickerFormComponent, { renderOpts, renderParams });
    }
  },
  VxeTextarea: {
    createFormDesignWidgetConfig: getWidgetVxeTextareaConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeTextareaViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeTextareaFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSwitch: {
    createFormDesignWidgetConfig: getWidgetVxeSwitchConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSwitchViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSwitchFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeTreeSelect: {
    createFormDesignWidgetConfig: getWidgetVxeTreeSelectConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeTreeSelectViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeTreeSelectFormComponent, { renderOpts, renderParams });
    }
  },
  VxeRadioGroup: {
    createFormDesignWidgetConfig: getWidgetVxeRadioGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeRadioGroupViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeRadioGroupFormComponent, { renderOpts, renderParams });
    }
  },
  VxeCheckboxGroup: {
    createFormDesignWidgetConfig: getWidgetVxeCheckboxGroupConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeCheckboxGroupViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeCheckboxGroupFormComponent, { renderOpts, renderParams });
    }
  },
  VxeUploadFile: {
    createFormDesignWidgetConfig: getWidgetVxeUploadFileConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeUploadFileViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeUploadFileFormComponent, { renderOpts, renderParams });
    }
  },
  VxeUploadImage: {
    createFormDesignWidgetConfig: getWidgetVxeUploadImageConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeUploadImageViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeUploadImageFormComponent, { renderOpts, renderParams });
    }
  },
  VxeRate: {
    createFormDesignWidgetConfig: getWidgetVxeRateConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeRateViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeRateFormComponent, { renderOpts, renderParams });
    }
  },
  VxeSlider: {
    createFormDesignWidgetConfig: getWidgetVxeSliderConfig,
    renderFormDesignWidgetView(renderOpts, renderParams) {
      return h(WidgetVxeSliderViewComponent, { renderOpts, renderParams });
    },
    renderFormDesignWidgetFormView(renderOpts, renderParams) {
      return h(WidgetVxeSliderFormComponent, { renderOpts, renderParams });
    }
  }
});

// node_modules/vxe-pc-ui/es/form-design/index.js
var VxeFormDesign = Object.assign({}, form_design_default, {
  install(app) {
    app.component(form_design_default.name, form_design_default);
  }
});
var formDesignHandle = {
  useWidgetName,
  useWidgetView,
  useSubtableView,
  useWidgetPropDataSource
};
dynamicApp.use(VxeFormDesign);
VxeUI.component(form_design_default);
VxeUI.formDesignHandle = formDesignHandle;
VxeUI.formDesign = formDesignHandle;
var FormDesign = VxeFormDesign;
var form_design_default2 = VxeFormDesign;

// node_modules/vxe-pc-ui/es/form-gather/index.js
var VxeFormGatherComponent = Object.assign({}, form_group_default, { name: "VxeFormGather" });
var VxeFormGather = Object.assign(VxeFormGatherComponent, {
  install(app) {
    app.component(VxeFormGatherComponent.name, VxeFormGatherComponent);
  }
});
dynamicApp.use(VxeFormGather);
VxeUI.component(VxeFormGatherComponent);
var FormGather = VxeFormGather;
var form_gather_default = VxeFormGather;

// node_modules/vxe-pc-ui/es/form-group/index.js
var VxeFormGroup = Object.assign(form_group_default, {
  install(app) {
    app.component(form_group_default.name, form_group_default);
  }
});
dynamicApp.use(VxeFormGroup);
VxeUI.component(form_group_default);
var FormGroup = VxeFormGroup;
var form_group_default2 = VxeFormGroup;

// node_modules/vxe-pc-ui/es/form-item/index.js
var VxeFormItem = Object.assign(form_item_default, {
  install(app) {
    app.component(form_item_default.name, form_item_default);
  }
});
dynamicApp.use(VxeFormItem);
VxeUI.component(form_item_default);
var FormItem = VxeFormItem;
var form_item_default2 = VxeFormItem;

// node_modules/vxe-pc-ui/es/form-view/index.js
var VxeFormView = Object.assign(form_view_default, {
  install: function(app) {
    app.component(form_view_default.name, form_view_default);
  }
});
dynamicApp.use(VxeFormView);
VxeUI.component(form_view_default);
var FormView = VxeFormView;
var form_view_default2 = VxeFormView;

// node_modules/vxe-pc-ui/es/icon/index.js
var VxeIcon = Object.assign({}, icon_default, {
  install(app) {
    app.component(icon_default.name, icon_default);
  }
});
dynamicApp.use(VxeIcon);
VxeUI.component(icon_default);
var Icon = VxeIcon;
var icon_default2 = VxeIcon;

// node_modules/vxe-pc-ui/es/icon-picker/src/icon-picker.js
var import_xe_utils122 = __toESM(require_xe_utils());
var icon_picker_default = defineComponent({
  name: "VxeIconPicker",
  props: {
    modelValue: String,
    placeholder: String,
    clearable: Boolean,
    size: {
      type: String,
      default: () => getConfig().iconPicker.size || getConfig().size
    },
    className: [String, Function],
    popupClassName: [String, Function],
    showIconTitle: {
      type: Boolean,
      default: () => getConfig().iconPicker.showIconTitle
    },
    readonly: {
      type: Boolean,
      default: null
    },
    disabled: {
      type: Boolean,
      default: null
    },
    icons: Array,
    placement: String,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils122.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      selectIcon: `${props.modelValue || ""}`,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refElem = ref();
    const refInput = ref();
    const refOptionPanel = ref();
    const refMaps = {
      refElem
    };
    const $xeIconPicker = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let iconPickerMethods = {};
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().iconPicker.transfer;
        if (import_xe_utils122.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().select.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseSelect");
    });
    const computeIconList = computed(() => {
      let { icons } = props;
      if (!icons || !icons.length) {
        icons = getConfig().iconPicker.icons || [];
      }
      return icons.map((name) => {
        return {
          title: name,
          icon: `vxe-icon-${name}`
        };
      });
    });
    const computeIconGroupList = computed(() => {
      const iconList = computeIconList.value;
      return import_xe_utils122.default.chunk(iconList, 4);
    });
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el2) {
          const targetHeight = el2.offsetHeight;
          const targetWidth = el2.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(el2);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { hpTimeout } = internalData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (hpTimeout) {
          clearTimeout(hpTimeout);
          internalData.hpTimeout = void 0;
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        setTimeout(() => {
          reactData.visiblePanel = true;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      internalData.hpTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      reactData.selectIcon = selectValue;
      if (selectValue !== props.modelValue) {
        emit("update:modelValue", selectValue);
        iconPickerMethods.dispatchEvent("change", { value: selectValue }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const focusEvent = () => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
      }
    };
    const blurEvent = () => {
      reactData.isActivated = false;
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      iconPickerMethods.dispatchEvent("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const togglePanelEvent = (evnt) => {
      evnt.preventDefault();
      if (reactData.visiblePanel) {
        hideOptionPanel();
      } else {
        showOptionPanel();
      }
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      iconPickerMethods.dispatchEvent("click", {}, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const { clearable } = props;
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const isTab = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.TAB);
        const isEnter = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ENTER);
        const isEsc = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ESCAPE);
        const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
        const isDwArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
        const isDel = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.DELETE);
        const isSpacebar = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.SPACEBAR);
        if (isTab) {
          reactData.isActivated = false;
        }
        if (visiblePanel) {
          if (isEsc || isTab) {
            hideOptionPanel();
          } else if (isEnter) {
            evnt.preventDefault();
            evnt.stopPropagation();
          } else if (isUpArrow || isDwArrow) {
            evnt.preventDefault();
          } else if (isSpacebar) {
            evnt.preventDefault();
          }
        } else if ((isUpArrow || isDwArrow || isEnter || isSpacebar) && reactData.isActivated) {
          evnt.preventDefault();
          showOptionPanel();
        }
        if (reactData.isActivated) {
          if (isDel && clearable) {
            clearValueEvent(evnt, null);
          }
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $iconPicker: $xeIconPicker }, params));
    };
    iconPickerMethods = {
      dispatchEvent: dispatchEvent2,
      isPanelVisible() {
        return reactData.visiblePanel;
      },
      togglePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
        return nextTick();
      },
      hidePanel() {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        }
        return nextTick();
      },
      showPanel() {
        if (!reactData.visiblePanel) {
          showOptionPanel();
        }
        return nextTick();
      },
      focus() {
        const $input = refInput.value;
        reactData.isActivated = true;
        $input.blur();
        return nextTick();
      },
      blur() {
        const $input = refInput.value;
        $input.blur();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    const handleClickIconEvent = (evnt, item) => {
      const value = item.icon;
      changeEvent(evnt, value);
      hideOptionPanel();
    };
    Object.assign($xeIconPicker, iconPickerMethods);
    const renderIconWrapper = () => {
      const { showIconTitle } = props;
      const iconGroupList = computeIconGroupList.value;
      const isDisabled = computeIsDisabled.value;
      return h("div", {
        class: "vxe-ico-picker--list-wrapper"
      }, iconGroupList.map((list) => {
        return h("div", {
          class: "vxe-ico-picker--list"
        }, list.map((item) => {
          return h("div", {
            class: "vxe-ico-picker--item",
            onClick(evnt) {
              if (!isDisabled) {
                handleClickIconEvent(evnt, item);
              }
            }
          }, [
            h("div", {
              class: "vxe-ico-picker--item-icon"
            }, [
              h("i", {
                class: item.icon || ""
              })
            ]),
            showIconTitle ? h("div", {
              class: "vxe-ico-picker--item-title"
            }, `${item.title || ""}`) : createCommentVNode()
          ]);
        }));
      }));
    };
    const renderVN = () => {
      const { className, popupClassName, clearable } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, selectIcon } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-ico-picker--readonly", className]
        }, [
          h("i", {
            class: selectIcon
          })
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-ico-picker", className ? import_xe_utils122.default.isFunction(className) ? className({ $iconPicker: $xeIconPicker }) : className : "", {
          [`size--${vSize}`]: vSize,
          "show--clear": clearable && !isDisabled && !!selectIcon,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          class: "vxe-ico-picker--inner",
          onClick: clickEvent
        }, [
          h("input", {
            ref: refInput,
            class: "vxe-ico-picker--input",
            onFocus: focusEvent,
            onBlur: blurEvent
          }),
          selectIcon ? h("div", {
            class: "vxe-ico-picker--icon"
          }, [
            h("i", {
              class: selectIcon
            })
          ]) : h("div", {
            class: "vxe-ico-picker--placeholder"
          }, inpPlaceholder),
          h("div", {
            class: "vxe-ico-picker--suffix"
          }, [
            h("div", {
              class: "vxe-ico-picker--clear-icon",
              onClick: clearEvent
            }, [
              h("i", {
                class: getIcon().INPUT_CLEAR
              })
            ]),
            h("div", {
              class: "vxe-ico-picker--suffix-icon"
            }, [
              h("i", {
                class: visiblePanel ? getIcon().ICON_PICKER_OPEN : getIcon().ICON_PICKER_CLOSE
              })
            ])
          ])
        ]),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-ico-picker--panel", popupClassName ? import_xe_utils122.default.isFunction(popupClassName) ? popupClassName({ $iconPicker: $xeIconPicker }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, [
            initialized && (visiblePanel || isAniVisible) ? h("div", {
              class: "vxe-ico-picker--panel-wrapper"
            }, [
              renderIconWrapper()
            ]) : createCommentVNode()
          ])
        ])
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.selectIcon = `${val || ""}`;
    });
    onMounted(() => {
      globalEvents.on($xeIconPicker, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeIconPicker, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeIconPicker, "keydown", handleGlobalKeydownEvent);
      globalEvents.on($xeIconPicker, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeIconPicker, "mousewheel");
      globalEvents.off($xeIconPicker, "mousedown");
      globalEvents.off($xeIconPicker, "keydown");
      globalEvents.off($xeIconPicker, "blur");
    });
    provide("$xeIconPicker", $xeIconPicker);
    $xeIconPicker.renderVN = renderVN;
    return $xeIconPicker;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/icon-picker/index.js
var VxeIconPicker = Object.assign(icon_picker_default, {
  install: function(app) {
    app.component(icon_picker_default.name, icon_picker_default);
  }
});
dynamicApp.use(VxeIconPicker);
VxeUI.component(icon_picker_default);
var IconPicker = VxeIconPicker;
var icon_picker_default2 = VxeIconPicker;

// node_modules/vxe-pc-ui/es/image/src/image.js
var import_xe_utils125 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/image/src/preview.js
var import_xe_utils123 = __toESM(require_xe_utils());
var preview_default = defineComponent({
  name: "VxeImagePreview",
  props: {
    modelValue: Number,
    urlList: Array,
    urlField: {
      type: String,
      default: () => getConfig().imagePreview.urlField
    },
    maskClosable: {
      type: Boolean,
      default: () => getConfig().imagePreview.maskClosable
    },
    marginSize: {
      type: String,
      default: () => getConfig().imagePreview.marginSize
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imagePreview.showDownloadButton
    },
    beforeDownloadMethod: Function,
    downloadMethod: Function
  },
  emits: [
    "update:modelValue",
    "change",
    "download",
    "download-fail",
    "close"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils123.default.uniqueId();
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const reactData = reactive({
      activeIndex: props.modelValue || 0,
      offsetPct11: false,
      offsetScale: 0,
      offsetRotate: 0,
      offsetLeft: 0,
      offsetTop: 0
    });
    const computeUrlProp = computed(() => {
      return props.urlField || "url";
    });
    const computeMarginSize = computed(() => {
      return import_xe_utils123.default.toNumber(props.marginSize || 0) || 16;
    });
    const computeRotateText = computed(() => {
      const { offsetRotate } = reactData;
      if (offsetRotate) {
        return `${offsetRotate}°`;
      }
      return "0°";
    });
    const computeScaleText = computed(() => {
      const { offsetScale } = reactData;
      if (offsetScale) {
        return `${import_xe_utils123.default.ceil((1 + offsetScale) * 100)}%`;
      }
      return "100%";
    });
    const computeImgList = computed(() => {
      const { urlList } = props;
      const urlProp = computeUrlProp.value;
      if (urlList && urlList.length) {
        return urlList.map((item) => {
          if (import_xe_utils123.default.isString(item)) {
            return item;
          }
          if (item[urlProp]) {
            return item[urlProp];
          }
          return "";
        });
      }
      return [];
    });
    const computeImgTransform = computed(() => {
      let { offsetScale, offsetRotate, offsetLeft, offsetTop } = reactData;
      const stys = [];
      let targetScale = 1;
      if (offsetScale) {
        targetScale = 1 + offsetScale;
        stys.push(`scale(${targetScale})`);
      }
      if (offsetRotate) {
        stys.push(`rotate(${offsetRotate}deg)`);
      }
      if (offsetLeft || offsetTop) {
        offsetLeft /= targetScale;
        offsetTop /= targetScale;
        let targetOffsetLeft = offsetLeft;
        let targetOffsetTop = offsetTop;
        if (offsetRotate) {
          switch (offsetRotate % 360) {
            case 90:
            case -270:
              targetOffsetLeft = offsetTop;
              targetOffsetTop = -offsetLeft;
              break;
            case 180:
            case -180:
              targetOffsetLeft = -offsetLeft;
              targetOffsetTop = -offsetTop;
              break;
            case 270:
            case -90:
              targetOffsetLeft = -offsetTop;
              targetOffsetTop = offsetLeft;
              break;
          }
        }
        stys.push(`translate(${targetOffsetLeft}px, ${targetOffsetTop}px)`);
      }
      return stys.length ? stys.join(" ") : "";
    });
    const computeMaps = {
      computeImgList
    };
    const $xeImagePreview = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $imagePreview: $xeImagePreview }, params));
    };
    const imagePreviewMethods = {
      dispatchEvent: dispatchEvent2
    };
    const emitModel = (value) => {
      reactData.activeIndex = value;
      emit("update:modelValue", value);
    };
    const handleCloseEvent = (evnt) => {
      dispatchEvent2("close", {}, evnt);
    };
    const imagePreviewPrivateMethods = {};
    const resetStyle = () => {
      const elem = refElem.value;
      removeClass2(elem, "is--move");
      Object.assign(reactData, {
        offsetPct11: false,
        offsetScale: 0,
        offsetRotate: 0,
        offsetLeft: 0,
        offsetTop: 0
      });
    };
    const getOffsetZoomStep = () => {
      const { offsetScale } = reactData;
      let stepNum = 0.02;
      if (offsetScale >= -0.6) {
        stepNum = 0.04;
        if (offsetScale >= -0.4) {
          stepNum = 0.07;
          if (offsetScale >= 0) {
            stepNum = 0.1;
            if (offsetScale >= 3) {
              stepNum = 0.25;
              if (offsetScale >= 8) {
                stepNum = 0.4;
                if (offsetScale >= 16) {
                  stepNum = 0.6;
                  if (offsetScale >= 24) {
                    stepNum = 0.9;
                    if (offsetScale >= 32) {
                      stepNum = 1.3;
                      if (offsetScale >= 39) {
                        stepNum = 1.9;
                        if (offsetScale >= 45) {
                          stepNum = 2.5;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      return stepNum;
    };
    const handleZoom = (isAdd) => {
      const { offsetScale } = reactData;
      const stepNum = getOffsetZoomStep();
      if (isAdd) {
        reactData.offsetScale = Number(Math.min(49, offsetScale + stepNum).toFixed(2));
      } else {
        reactData.offsetScale = Number(Math.max(-0.9, offsetScale - stepNum).toFixed(2));
      }
    };
    const handleChange = (isNext) => {
      let activeIndex = reactData.activeIndex || 0;
      const imgList = computeImgList.value;
      if (isNext) {
        if (activeIndex >= imgList.length - 1) {
          activeIndex = 0;
        } else {
          activeIndex++;
        }
      } else {
        if (activeIndex <= 0) {
          activeIndex = imgList.length - 1;
        } else {
          activeIndex--;
        }
      }
      resetStyle();
      reactData.activeIndex = activeIndex;
      emitModel(activeIndex);
    };
    const handleRotateImg = (isRight) => {
      let offsetRotate = reactData.offsetRotate;
      if (isRight) {
        offsetRotate += 90;
      } else {
        offsetRotate -= 90;
      }
      reactData.offsetRotate = offsetRotate;
    };
    const handlePct11 = () => {
      resetStyle();
      reactData.offsetPct11 = true;
    };
    const handlePrintImg = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (VxeUI.print) {
        VxeUI.print({
          align: "center",
          pageBreaks: [
            {
              bodyHtml: `<img src="${imgUrl}" style="max-width:100%;max-height:100%;">`
            }
          ]
        });
      }
    };
    const handleDownloadEvent = (evnt, imgUrl) => {
      dispatchEvent2("download", { url: imgUrl }, evnt);
    };
    const handleDefaultDownload = (evnt, imgUrl) => {
      if (VxeUI.saveFile) {
        fetch(imgUrl).then((res) => {
          return res.blob().then((blob) => {
            VxeUI.saveFile({
              filename: imgUrl,
              content: blob
            });
            handleDownloadEvent(evnt, imgUrl);
          });
        }).catch(() => {
          if (VxeUI.modal) {
            VxeUI.modal.message({
              content: getI18n("vxe.error.downErr"),
              status: "error"
            });
          }
        });
      }
    };
    const handleDownloadImg = (evnt) => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      const beforeDownloadFn = props.beforeDownloadMethod || getConfig().imagePreview.beforeDownloadMethod;
      const downloadFn = props.downloadMethod || getConfig().imagePreview.downloadMethod;
      Promise.resolve(beforeDownloadFn ? beforeDownloadFn({
        $imagePreview: $xeImagePreview,
        url: imgUrl,
        index: activeIndex || 0
      }) : true).then((status) => {
        if (status) {
          if (downloadFn) {
            Promise.resolve(downloadFn({
              $imagePreview: $xeImagePreview,
              url: imgUrl,
              index: activeIndex || 0
            })).then(() => {
              handleDownloadEvent(evnt, imgUrl);
            }).catch((e16) => e16);
          } else {
            handleDefaultDownload(evnt, imgUrl);
          }
        }
      });
    };
    const handleOperationBtn = (evnt, code3) => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgUrl = imgList[activeIndex || 0];
      if (imgUrl) {
        switch (code3) {
          case "zoomOut":
            handleZoom(false);
            break;
          case "zoomIn":
            handleZoom(true);
            break;
          case "pctFull":
            resetStyle();
            break;
          case "pct11":
            handlePct11();
            break;
          case "rotateLeft":
            handleRotateImg(false);
            break;
          case "rotateRight":
            handleRotateImg(true);
            break;
          case "print":
            handlePrintImg();
            break;
          case "download":
            handleDownloadImg(evnt);
            break;
        }
      }
    };
    const wheelEvent = (evnt) => {
      const delta = evnt.deltaY;
      if (delta > 0) {
        handleZoom(false);
      } else if (delta < 0) {
        handleZoom(true);
      }
    };
    const moveEvent = (evnt) => {
      const { offsetTop, offsetLeft } = reactData;
      const elem = refElem.value;
      evnt.preventDefault();
      const domMousemove = document.onmousemove;
      const domMouseup = document.onmouseup;
      const startX = evnt.pageX;
      const startY = evnt.pageY;
      const marginSize = computeMarginSize.value;
      document.onmousemove = (et2) => {
        const { pageX, pageY } = et2;
        const { visibleHeight, visibleWidth } = getDomNode2();
        et2.preventDefault();
        addClass2(elem, "is--move");
        if (pageX > marginSize && pageY > marginSize && pageX < visibleWidth - marginSize && pageY < visibleHeight - marginSize) {
          reactData.offsetLeft = offsetLeft + pageX - startX;
          reactData.offsetTop = offsetTop + pageY - startY;
        }
      };
      document.onmouseup = () => {
        document.onmousemove = domMousemove;
        document.onmouseup = domMouseup;
        removeClass2(elem, "is--move");
      };
    };
    const handleGlobalKeydownEvent = (evnt) => {
      const hasCtrlKey = evnt.ctrlKey;
      const hasShiftKey = evnt.shiftKey;
      const isUpArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_UP);
      const isDownArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_DOWN);
      const isLeftArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_LEFT);
      const isRightArrow = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.ARROW_RIGHT);
      const isR = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.R);
      const isP = globalEvents.hasKey(evnt, GLOBAL_EVENT_KEYS.P);
      if (isUpArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop -= 1;
        } else {
          handleZoom(true);
        }
      } else if (isDownArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetTop += 1;
        } else {
          handleZoom(false);
        }
      } else if (isLeftArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft -= 1;
        } else {
          handleChange(false);
        }
      } else if (isRightArrow) {
        evnt.preventDefault();
        if (hasShiftKey) {
          reactData.offsetLeft += 1;
        } else {
          handleChange(true);
        }
      } else if (isR && hasCtrlKey) {
        evnt.preventDefault();
        if (hasShiftKey) {
          handleRotateImg(false);
        } else {
          handleRotateImg(true);
        }
      } else if (isP && hasCtrlKey) {
        evnt.preventDefault();
        handlePrintImg();
      }
    };
    const handleClickMaskEvent = (evnt) => {
      if (props.maskClosable) {
        if (evnt.target === evnt.currentTarget) {
          dispatchEvent2("close", {}, evnt);
        }
      }
    };
    Object.assign($xeImagePreview, imagePreviewMethods, imagePreviewPrivateMethods);
    const renderImgWrapper = () => {
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const imgTransform = computeImgTransform.value;
      return h("div", {
        class: "vxe-image-preview--img-list",
        onClick: handleClickMaskEvent
      }, imgList.map((url, index2) => {
        const isActive = activeIndex === index2;
        return h("img", {
          class: ["vxe-image-preview--img-item", {
            "is--active": isActive
          }],
          src: url,
          style: isActive ? {
            transform: imgTransform
          } : null,
          onMousedown(evnt) {
            moveEvent(evnt);
          }
        });
      }));
    };
    const renderOperationBtn = (code3, icon) => {
      return h("div", {
        class: "vxe-image-preview--operation-btn",
        title: getI18n(`vxe.imagePreview.operBtn.${code3}`),
        onClick(evnt) {
          handleOperationBtn(evnt, code3);
        }
      }, [
        h("i", {
          class: getIcon()[icon]
        })
      ]);
    };
    const renderBtnWrapper = () => {
      const { showPrintButton, showDownloadButton } = props;
      const { activeIndex } = reactData;
      const imgList = computeImgList.value;
      const rotateText = computeRotateText.value;
      const scaleText = computeScaleText.value;
      return h("div", {
        class: "vxe-image-preview--btn-wrapper"
      }, [
        h("div", {
          class: "vxe-image-preview--close-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--close-btn",
            onClick: handleCloseEvent
          }, [
            h("i", {
              class: getIcon().IMAGE_PREVIEW_CLOSE
            })
          ]),
          h("div", {
            class: "vxe-image-preview--close-bg"
          })
        ]),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--previous-btn",
          onClick() {
            handleChange(false);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_PREVIOUS
          })
        ]) : createCommentVNode(),
        imgList.length > 1 ? h("div", {
          class: "vxe-image-preview--next-btn",
          onClick() {
            handleChange(true);
          }
        }, [
          h("i", {
            class: getIcon().IMAGE_PREVIEW_NEXT
          })
        ]) : createCommentVNode(),
        h("div", {
          class: "vxe-image-preview--operation-info"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-deg"
          }, rotateText),
          h("div", {
            class: "vxe-image-preview--operation-pct"
          }, scaleText)
        ]),
        h("div", {
          class: "vxe-image-preview--operation-wrapper"
        }, [
          h("div", {
            class: "vxe-image-preview--operation-active-count"
          }, [
            h("span", {
              class: "vxe-image-preview--operation-active-current"
            }, `${(activeIndex || 0) + 1}`),
            h("span", {
              class: "vxe-image-preview--operation-active-total"
            }, `/${imgList.length}`)
          ]),
          renderOperationBtn("zoomOut", "IMAGE_PREVIEW_ZOOM_OUT"),
          renderOperationBtn("zoomIn", "IMAGE_PREVIEW_ZOOM_IN"),
          renderOperationBtn("pctFull", "IMAGE_PREVIEW_PCT_FULL"),
          renderOperationBtn("pct11", "IMAGE_PREVIEW_PCT_1_1"),
          renderOperationBtn("rotateLeft", "IMAGE_PREVIEW_ROTATE_LEFT"),
          renderOperationBtn("rotateRight", "IMAGE_PREVIEW_ROTATE_RIGHT"),
          showPrintButton ? renderOperationBtn("print", "IMAGE_PREVIEW_PRINT") : createCommentVNode(),
          showDownloadButton ? renderOperationBtn("download", "IMAGE_PREVIEW_DOWNLOAD") : createCommentVNode()
        ])
      ]);
    };
    const renderVN = () => {
      const { offsetPct11 } = reactData;
      return h("div", {
        ref: refElem,
        class: ["vxe-image-preview", {
          "is--pct11": offsetPct11
        }],
        onWheel: wheelEvent
      }, [
        renderImgWrapper(),
        renderBtnWrapper()
      ]);
    };
    watch(() => props.modelValue, (val) => {
      reactData.activeIndex = val;
      resetStyle();
    });
    onMounted(() => {
      globalEvents.on($xeImagePreview, "keydown", handleGlobalKeydownEvent);
    });
    onBeforeUnmount(() => {
      const elem = refElem.value;
      if (elem) {
        removeClass2(elem, "is--move");
      }
    });
    onUnmounted(() => {
      globalEvents.off($xeImagePreview, "keydown");
    });
    provide("$xeImagePreview", $xeImagePreview);
    $xeImagePreview.renderVN = renderVN;
    return renderVN;
  }
});

// node_modules/vxe-pc-ui/es/image/src/util.js
var import_xe_utils124 = __toESM(require_xe_utils());
var openPreviewImage = (options) => {
  if (VxeUI.modal) {
    const opts = Object.assign({
      escClosable: true
    }, options);
    const { urlList, activeIndex } = opts;
    const modalId = import_xe_utils124.default.uniqueId("image-preview");
    VxeUI.modal.open({
      id: modalId,
      title: "预览",
      width: "100%",
      height: "100%",
      showHeader: false,
      showFooter: false,
      padding: false,
      escClosable: opts.escClosable,
      className: "vxe-image-preview-popup-wrapper",
      slots: {
        default() {
          return h(preview_default, {
            modelValue: activeIndex,
            urlList,
            urlField: opts.urlField,
            marginSize: opts.marginSize,
            maskClosable: opts.maskClosable,
            showPrintButton: opts.showPrintButton,
            showDownloadButton: opts.showDownloadButton,
            beforeDownloadMethod: opts.beforeDownloadMethod,
            downloadMethod: opts.downloadMethod,
            onClose() {
              VxeUI.modal.close(modalId);
            }
          });
        }
      }
    });
  }
  return Promise.resolve();
};

// node_modules/vxe-pc-ui/es/image/src/image.js
var image_default = defineComponent({
  name: "VxeImage",
  props: {
    src: [String, Array],
    alt: [String, Number],
    loading: String,
    title: [String, Number],
    width: [String, Number],
    height: [String, Number],
    circle: Boolean,
    maskClosable: {
      type: Boolean,
      default: () => getConfig().image.maskClosable
    },
    showPreview: {
      type: Boolean,
      default: () => getConfig().image.showPreview
    },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().image.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().image.showDownloadButton
    },
    size: { type: String, default: () => getConfig().image.size || getConfig().size }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils125.default.uniqueId();
    const $xeImageGroup = inject("$xeImageGroup", null);
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeImgStyle = computed(() => {
      const { width, height } = props;
      const style = {};
      if (width && height) {
        style.maxWidth = toCssUnit(width);
        style.maxHeight = toCssUnit(height);
      } else {
        if (width) {
          style.width = toCssUnit(width);
        }
        if (height) {
          style.height = toCssUnit(height);
        }
      }
      return style;
    });
    const computeImgList = computed(() => {
      const { src } = props;
      if (src) {
        return (import_xe_utils125.default.isArray(src) ? src : [src]).map((item) => {
          if (import_xe_utils125.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgItem = computed(() => {
      const imgList = computeImgList.value;
      return imgList[0];
    });
    const computeImgUrl = computed(() => {
      const imgItem = computeImgItem.value;
      return imgItem ? `${imgItem.url || ""}` : "";
    });
    const computeMaps = {
      computeSize
    };
    const $xeImage = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const imageMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $image: $xeImage }, params));
      }
    };
    const clickEvent = (evnt) => {
      const { showPreview, showPrintButton, showDownloadButton, maskClosable } = props;
      const imgList = computeImgList.value;
      const imgUrl = computeImgUrl.value;
      if ($xeImageGroup) {
        $xeImageGroup.handleClickImgEvent(evnt, { url: imgUrl });
      } else {
        if (showPreview && imgUrl) {
          openPreviewImage({
            urlList: imgList,
            showPrintButton,
            showDownloadButton,
            maskClosable
          });
        }
        imageMethods.dispatchEvent("click", { url: imgUrl }, evnt);
      }
    };
    const imagePrivateMethods = {};
    Object.assign($xeImage, imageMethods, imagePrivateMethods);
    const renderVN = () => {
      const { alt, loading: loading2, circle } = props;
      const imgStyle = computeImgStyle.value;
      const imgUrl = computeImgUrl.value;
      const vSize = computeSize.value;
      return h("img", {
        ref: refElem,
        class: ["vxe-image", {
          [`size--${vSize}`]: vSize,
          "is--circle": circle
        }],
        src: imgUrl,
        alt,
        loading: loading2,
        style: imgStyle,
        onClick: clickEvent
      });
    };
    $xeImage.renderVN = renderVN;
    return $xeImage;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/image/index.js
var VxeImage = Object.assign({}, image_default, {
  install(app) {
    app.component(image_default.name, image_default);
  }
});
dynamicApp.use(VxeImage);
VxeUI.component(image_default);
var Image2 = VxeImage;
var image_default2 = VxeImage;

// node_modules/vxe-pc-ui/es/image/src/group.js
var import_xe_utils126 = __toESM(require_xe_utils());
var group_default4 = defineComponent({
  name: "VxeImageGroup",
  props: {
    urlList: [Array, String],
    showPreview: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPreview
    },
    imageStyle: Object,
    size: { type: String, default: () => getConfig().imageGroup.size || getConfig().size },
    showPrintButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showPrintButton
    },
    showDownloadButton: {
      type: Boolean,
      default: () => getConfig().imageGroup.showDownloadButton
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils126.default.uniqueId();
    const { computeSize } = useSize(props);
    const computeImgList = computed(() => {
      const { urlList } = props;
      if (urlList) {
        return (import_xe_utils126.default.isArray(urlList) ? urlList : [urlList]).map((item) => {
          if (import_xe_utils126.default.isString(item)) {
            return {
              url: item,
              alt: ""
            };
          }
          return {
            url: item.url,
            alt: item.alt
          };
        });
      }
      return [];
    });
    const computeImgStyleOpts = computed(() => {
      return Object.assign({}, getConfig().imageGroup.imageStyle, props.imageStyle);
    });
    const computeMaps = {
      computeSize
    };
    const $xeImageGroup = {
      xID,
      props,
      context,
      getComputeMaps: () => computeMaps
    };
    const imageGroupMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $imageGroup: $xeImageGroup }, params));
      }
    };
    const imageGroupPrivateMethods = {
      handleClickImgEvent(evnt, params) {
        const { showPreview, showPrintButton, showDownloadButton } = props;
        const { url } = params;
        const imgList = computeImgList.value;
        if (showPreview && url) {
          openPreviewImage({
            activeIndex: Math.max(0, import_xe_utils126.default.findIndexOf(imgList, (item) => item.url === url)),
            urlList: imgList,
            showPrintButton,
            showDownloadButton
          });
        }
        imageGroupMethods.dispatchEvent("click", { url, urlList: imgList }, evnt);
      }
    };
    Object.assign($xeImageGroup, imageGroupMethods, imageGroupPrivateMethods);
    const renderVN = () => {
      const imgList = computeImgList.value;
      const vSize = computeSize.value;
      const imgStyleOpts = computeImgStyleOpts.value;
      return h("div", {
        class: ["vxe-image-group", {
          [`size--${vSize}`]: vSize
        }]
      }, imgList ? imgList.map((item, index2) => {
        return h(image_default, {
          key: index2,
          src: item.url,
          alt: item.alt,
          width: imgStyleOpts.width,
          height: imgStyleOpts.height
        });
      }) : []);
    };
    $xeImageGroup.renderVN = renderVN;
    provide("$xeImageGroup", $xeImageGroup);
    return $xeImageGroup;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/image-group/index.js
var VxeImageGroup = Object.assign({}, group_default4, {
  install(app) {
    app.component(group_default4.name, group_default4);
  }
});
dynamicApp.use(VxeImageGroup);
VxeUI.component(group_default4);
var ImageGroup = VxeImageGroup;
var image_group_default = VxeImageGroup;

// node_modules/vxe-pc-ui/es/image-preview/index.js
var VxeImagePreview = Object.assign(preview_default, {
  install(app) {
    app.component(preview_default.name, preview_default);
    VxeUI.previewImage = openPreviewImage;
  }
});
dynamicApp.use(VxeImagePreview);
VxeUI.component(preview_default);
var ImagePreview = VxeImagePreview;
var image_preview_default = VxeImagePreview;

// node_modules/vxe-pc-ui/es/input/index.js
var VxeInput = Object.assign(input_default, {
  install(app) {
    app.component(input_default.name, input_default);
  }
});
dynamicApp.use(VxeInput);
VxeUI.component(input_default);
var Input = VxeInput;
var input_default2 = VxeInput;

// node_modules/vxe-pc-ui/es/layout-aside/src/layout-aside.js
var import_xe_utils127 = __toESM(require_xe_utils());
var layout_aside_default = defineComponent({
  name: "VxeLayoutAside",
  props: {
    width: [String, Number],
    collapsed: Boolean,
    collapseWidth: [String, Number],
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutAside.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils127.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeWrapperWidth = computed(() => {
      const { width, collapsed, collapseWidth } = props;
      if (collapsed) {
        if (collapseWidth) {
          return toCssUnit(collapseWidth);
        }
      } else {
        if (width) {
          return toCssUnit(width);
        }
      }
      return "";
    });
    const computeMaps = {
      computeSize
    };
    const $xeLayoutAside = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutAside: $xeLayoutAside }, params));
    };
    const layoutAsideMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutAsidePrivateMethods = {};
    Object.assign($xeLayoutAside, layoutAsideMethods, layoutAsidePrivateMethods);
    const renderVN = () => {
      const { width, collapsed, loading: loading2, padding } = props;
      const wrapperWidth = computeWrapperWidth.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("aside", {
        ref: refElem,
        class: ["vxe-layout-aside", {
          [`size--${vSize}`]: vSize,
          "is--padding": padding,
          "is--default-width": !width,
          "is--collapse": collapsed,
          "is--loading": loading2
        }],
        style: wrapperWidth ? {
          width: wrapperWidth
        } : null
      }, [
        h("div", {
          class: "vxe-layout-aside--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    provide("$xeLayoutAside", $xeLayoutAside);
    $xeLayoutAside.renderVN = renderVN;
    return $xeLayoutAside;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-aside/index.js
var VxeLayoutAside = Object.assign({}, layout_aside_default, {
  install(app) {
    app.component(layout_aside_default.name, layout_aside_default);
  }
});
dynamicApp.use(VxeLayoutAside);
VxeUI.component(layout_aside_default);
var LayoutAside = VxeLayoutAside;
var layout_aside_default2 = VxeLayoutAside;

// node_modules/vxe-pc-ui/es/layout-body/src/layout-body.js
var import_xe_utils128 = __toESM(require_xe_utils());
var layout_body_default = defineComponent({
  name: "VxeLayoutBody",
  props: {
    loading: Boolean,
    padding: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutBody.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils128.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutBody = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutBody: $xeLayoutBody }, params));
    };
    const layoutBodyMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutBodyPrivateMethods = {};
    Object.assign($xeLayoutBody, layoutBodyMethods, layoutBodyPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, padding } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-body", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2,
          "is--padding": padding
        }]
      }, [
        h("div", {
          class: "vxe-layout-body--inner"
        }, defaultSlot ? defaultSlot({}) : []),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeLayoutBody.renderVN = renderVN;
    return $xeLayoutBody;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-body/index.js
var VxeLayoutBody = Object.assign({}, layout_body_default, {
  install(app) {
    app.component(layout_body_default.name, layout_body_default);
  }
});
dynamicApp.use(VxeLayoutBody);
VxeUI.component(layout_body_default);
var LayoutBody = VxeLayoutBody;
var layout_body_default2 = VxeLayoutBody;

// node_modules/vxe-pc-ui/es/layout-container/src/layout-container.js
var import_xe_utils129 = __toESM(require_xe_utils());
var layout_container_default = defineComponent({
  name: "VxeLayoutContainer",
  props: {
    vertical: Boolean,
    size: {
      type: String,
      default: () => getConfig().layoutContainer.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils129.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeLayoutContainer = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutContainer: $xeLayoutContainer }, params));
    };
    const layoutContainerMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutContainerPrivateMethods = {};
    Object.assign($xeLayoutContainer, layoutContainerMethods, layoutContainerPrivateMethods);
    const renderVN = () => {
      const { vertical } = props;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-layout-container", {
          [`size--${vSize}`]: vSize,
          "is--vertical": vertical
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutContainer.renderVN = renderVN;
    return $xeLayoutContainer;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-container/index.js
var VxeLayoutContainer = Object.assign({}, layout_container_default, {
  install(app) {
    app.component(layout_container_default.name, layout_container_default);
  }
});
dynamicApp.use(VxeLayoutContainer);
VxeUI.component(layout_container_default);
var LayoutContainer = VxeLayoutContainer;
var layout_container_default2 = VxeLayoutContainer;

// node_modules/vxe-pc-ui/es/layout-footer/src/layout-footer.js
var import_xe_utils130 = __toESM(require_xe_utils());
var layout_footer_default = defineComponent({
  name: "VxeLayoutFooter",
  props: {
    fixed: Boolean,
    align: String
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils130.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutFooter = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutFooter: $xeLayoutFooter }, params));
    };
    const layoutFooterMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutFooterPrivateMethods = {};
    Object.assign($xeLayoutFooter, layoutFooterMethods, layoutFooterPrivateMethods);
    const renderVN = () => {
      const { fixed, align } = props;
      const defaultSlot = slots.default;
      return h("footer", {
        ref: refElem,
        class: ["vxe-layout-footer", align ? `align--${align}` : "", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutFooter.renderVN = renderVN;
    return $xeLayoutFooter;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-footer/index.js
var VxeLayoutFooter = Object.assign({}, layout_footer_default, {
  install(app) {
    app.component(layout_footer_default.name, layout_footer_default);
  }
});
dynamicApp.use(VxeLayoutFooter);
VxeUI.component(layout_footer_default);
var LayoutFooter = VxeLayoutFooter;
var layout_footer_default2 = VxeLayoutFooter;

// node_modules/vxe-pc-ui/es/layout-header/src/layout-header.js
var import_xe_utils131 = __toESM(require_xe_utils());
var layout_header_default = defineComponent({
  name: "VxeLayoutHeader",
  props: {
    fixed: Boolean
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils131.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLayoutHeader = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $layoutHeader: $xeLayoutHeader }, params));
    };
    const layoutHeaderMethods = {
      dispatchEvent: dispatchEvent2
    };
    const layoutHeaderPrivateMethods = {};
    Object.assign($xeLayoutHeader, layoutHeaderMethods, layoutHeaderPrivateMethods);
    const renderVN = () => {
      const { fixed } = props;
      const defaultSlot = slots.default;
      return h("header", {
        ref: refElem,
        class: ["vxe-layout-header", {
          "is--fixed": fixed
        }]
      }, defaultSlot ? defaultSlot({}) : []);
    };
    $xeLayoutHeader.renderVN = renderVN;
    return $xeLayoutHeader;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/layout-header/index.js
var VxeLayoutHeader = Object.assign({}, layout_header_default, {
  install(app) {
    app.component(layout_header_default.name, layout_header_default);
  }
});
dynamicApp.use(VxeLayoutHeader);
VxeUI.component(layout_header_default);
var LayoutHeader = VxeLayoutHeader;
var layout_header_default2 = VxeLayoutHeader;

// node_modules/vxe-pc-ui/es/link/src/link.js
var import_xe_utils132 = __toESM(require_xe_utils());
var link_default = defineComponent({
  name: "VxeLink",
  props: {
    href: String,
    target: String,
    status: String,
    title: [String, Number],
    icon: String,
    routerLink: Object,
    underline: {
      type: Boolean,
      default: () => getConfig().link.underline
    },
    /**
     * 权限码
     */
    permissionCode: [String, Number],
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().link.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils132.default.uniqueId();
    const { computeSize } = useSize(props);
    const { computePermissionInfo } = usePermission(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeLink = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $link: $xeLink }, params));
    };
    const linkMethods = {
      dispatchEvent: dispatchEvent2
    };
    const linkPrivateMethods = {};
    const clickEvent = (evnt) => {
      dispatchEvent2("click", {}, evnt);
    };
    Object.assign($xeLink, linkMethods, linkPrivateMethods);
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      const textContent = import_xe_utils132.default.toValueString(content);
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-link--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        defaultSlot || textContent ? h("span", {
          class: "vxe-link--content"
        }, defaultSlot ? defaultSlot({}) : textContent) : createCommentVNode()
      ];
    };
    const renderVN = () => {
      const { status, target, href, title, underline, routerLink } = props;
      const permissionInfo = computePermissionInfo.value;
      const vSize = computeSize.value;
      if (!permissionInfo.visible) {
        return createCommentVNode();
      }
      if (routerLink) {
        return h(resolveComponent("router-link"), {
          class: ["vxe-link", {
            [`size--${vSize}`]: vSize,
            [`theme--${status}`]: status,
            "is--underline": underline
          }],
          title,
          target,
          to: routerLink,
          onClick: clickEvent
        }, {
          default() {
            return renderContent();
          }
        });
      }
      return h("a", {
        ref: refElem,
        class: ["vxe-link", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--underline": underline
        }],
        href,
        target,
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeLink.renderVN = renderVN;
    return $xeLink;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/link/index.js
var VxeLink = Object.assign({}, link_default, {
  install(app) {
    app.component(link_default.name, link_default);
  }
});
dynamicApp.use(VxeLink);
VxeUI.component(link_default);
var Link = VxeLink;
var link_default2 = VxeLink;

// node_modules/vxe-pc-ui/es/list-design/src/list-design.js
var import_xe_utils135 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/list-design/render/util.js
var createListDesignActionButton = (btnObj) => {
  return Object.assign({
    name: "",
    icon: "",
    type: "",
    classify: "",
    code: "",
    status: "",
    permissionCode: ""
  }, btnObj);
};

// node_modules/vxe-pc-ui/es/list-design/src/default-setting-data.js
var getDefaultSettingFormData2 = () => {
  return {
    listView: {
      enabled: true
    },
    ganttView: {
      enabled: false
    },
    chartView: {
      enabled: false
    },
    autoFoldFilter: true,
    showCheckbox: "auto",
    showSeq: true,
    showStatistics: true,
    mobileDefaultView: "list",
    pcDefaultView: "list",
    actionButtonList: []
  };
};

// node_modules/vxe-pc-ui/es/list-design/src/layout-preview.js
var import_xe_utils133 = __toESM(require_xe_utils());
var layout_preview_default2 = defineComponent({
  name: "ListDesignLayoutView",
  props: {},
  emits: [],
  setup() {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { reactData: listDesignReactData } = $xeListDesign;
    const refGrid = ref();
    const tableData = ref([]);
    const computeFormItems = computed(() => {
      const { searchFormItems } = listDesignReactData;
      if (searchFormItems.length) {
        return searchFormItems.concat([
          {
            field: "active",
            title: "",
            folding: false,
            collapseNode: searchFormItems.some((item) => item.folding),
            itemRender: {
              name: "VxeButtonGroup",
              options: [
                { content: "查询", icon: "vxe-icon-search", status: "primary", type: "submit" },
                { content: "重置", icon: "vxe-icon-repeat", type: "reset" }
              ]
            }
          }
        ]);
      }
      return searchFormItems;
    });
    const computeTableColumn = computed(() => {
      const { formData, listTableColumns } = listDesignReactData;
      const { showSeq, actionButtonList } = formData;
      const columns = [];
      if (showSeq) {
        columns.push({
          type: "seq",
          field: "_seq",
          width: 70
        });
      }
      listTableColumns.forEach((item) => {
        columns.push({
          field: item.field,
          title: item.title,
          visible: item.visible,
          width: item.width
        });
      });
      if (actionButtonList && actionButtonList.length) {
        columns.push({
          field: "_active",
          title: getI18n("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto",
          cellRender: {
            name: "VxeButtonGroup",
            options: []
          }
        });
      }
      return columns;
    });
    const updateColumnWidthEvent = ({ column, resizeWidth }) => {
      const { listTableColumns } = listDesignReactData;
      const rest = import_xe_utils133.default.findTree(listTableColumns, (item) => item.field === column.field, { children: "children" });
      if (rest) {
        const { item } = rest;
        item.width = resizeWidth;
      }
    };
    const updateTableData = () => {
      const { listTableColumns } = listDesignReactData;
      const data = [{}, {}];
      data.forEach((row) => {
        listTableColumns.forEach((column) => {
          row[column.field] = "-";
        });
      });
      tableData.value = data;
    };
    const dataFlag = ref(0);
    watch(() => listDesignReactData.listTableColumns ? listDesignReactData.listTableColumns.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => listDesignReactData.listTableColumns, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      updateTableData();
    });
    onMounted(() => {
      updateTableData();
    });
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog2("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    return () => {
      const { searchFormData, searchFormItems } = listDesignReactData;
      const formItems = computeFormItems.value;
      const tableColumn = computeTableColumn.value;
      return h("div", {
        class: "vxe-list-design--preview"
      }, [
        h("div", {
          class: "vxe-list-design--preview-wrapper"
        }, [
          h("div", {
            class: "vxe-list-design--preview-search"
          }, [
            h("div", {
              class: "vxe-list-design--preview-title"
            }, getI18n("vxe.listDesign.searchTitle")),
            searchFormItems.length ? h(form_default, {
              data: searchFormData,
              items: formItems
            }) : h("div", {
              class: "vxe-list-design--field-configs-empty-data"
            }, [
              h("span", {}, getI18n("vxe.listDesign.search.emptyText"))
            ])
          ]),
          h("div", {
            class: "vxe-list-design--preview-table"
          }, [
            h("div", {
              class: "vxe-list-design--preview-title"
            }, getI18n("vxe.listDesign.listTitle")),
            VxeTableGridComponent ? h(VxeTableGridComponent, {
              ref: refGrid,
              columns: tableColumn,
              data: tableData.value,
              showOverflow: true,
              border: true,
              columnConfig: {
                minWidth: "auto",
                resizable: true
              },
              rowConfig: {
                isHover: true
              },
              scrollX: {
                enabled: false
              },
              scrollY: {
                enabled: false
              },
              onResizableChange: updateColumnWidthEvent
            }) : createCommentVNode()
          ])
        ])
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/list-design/src/default-setting-form.js
var import_xe_utils134 = __toESM(require_xe_utils());
var refWidgetReactConfigMaps2 = ref({});
var DefaultFieldSettingFormComponent = defineComponent({
  name: "DefaultFieldSettingForm",
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { reactData: listDesignReactData } = $xeListDesign;
    const refIsAllChecked = ref(false);
    const refIsAllIndeterminate = ref(false);
    const changeVisible = (item) => {
      item.visible = !item.visible;
      listDesignReactData.listTableColumns = listDesignReactData.listTableColumns.slice(0);
    };
    const removeSearchItem = (item) => {
      const { searchFormItems } = listDesignReactData;
      listDesignReactData.searchFormItems = searchFormItems.filter((obj) => obj.field !== item.field);
    };
    const addSearchEvent = () => {
      const { listTableColumns, searchFormItems } = listDesignReactData;
      const widgetReactConfigMaps = refWidgetReactConfigMaps2.value;
      const allFormItemList = [];
      listTableColumns.forEach((item) => {
        const { cellRender } = item;
        if (cellRender) {
          const conf = searchFormItems.find((conf2) => conf2.field === item.field);
          const name = cellRender.name || "";
          let widgetConfig = widgetReactConfigMaps[name];
          if (!widgetConfig) {
            const compConf = renderer.get(name);
            if (compConf) {
              const createWidgetFormConfig = compConf.createFormDesignWidgetConfig;
              if (createWidgetFormConfig) {
                const params = { name, $formDesign: null };
                widgetConfig = createWidgetFormConfig(params) || {};
                widgetReactConfigMaps[name] = widgetConfig;
              }
            }
          }
          if (widgetConfig.query) {
            allFormItemList.push(Object.assign(Object.assign({}, item), { checked: !!conf, isHalf: false, folding: conf ? !!conf.folding : false }));
          }
        }
      });
      refWidgetReactConfigMaps2.value = Object.assign({}, widgetReactConfigMaps);
      const refAllFormItemList = ref(allFormItemList);
      const checkOptionStatus = () => {
        const allFormItemList2 = refAllFormItemList.value;
        refIsAllChecked.value = allFormItemList2.every((item) => item.checked);
        refIsAllIndeterminate.value = !refIsAllChecked.value && allFormItemList2.some((item) => item.checked || item.isHalf);
      };
      const handleOptionCheck = (item) => {
        const allFormItemList2 = refAllFormItemList.value;
        const matchObj = import_xe_utils134.default.findTree(allFormItemList2, (obj) => obj === item);
        if (matchObj && matchObj.parent) {
          const { parent } = matchObj;
          if (parent.children && parent.children.length) {
            parent.checked = parent.children.every((obj) => obj.checked);
            parent.isHalf = !parent.checked && parent.children.some((obj) => obj.checked || obj.isHalf);
            handleOptionCheck(parent);
          }
        }
      };
      const changeCheckboxOption = (item) => {
        const isChecked = !item.checked;
        import_xe_utils134.default.eachTree([item], (obj) => {
          obj.checked = isChecked;
          obj.isHalf = false;
        });
        handleOptionCheck(item);
        checkOptionStatus();
      };
      const allOptionEvent = () => {
        const allFormItemList2 = refAllFormItemList.value;
        const isAll = !refIsAllChecked.value;
        import_xe_utils134.default.eachTree(allFormItemList2, (item) => {
          item.checked = isAll;
          item.isHalf = false;
        });
        refIsAllChecked.value = isAll;
        checkOptionStatus();
      };
      const confirmEvent = () => {
        const allFormItemList2 = refAllFormItemList.value;
        const searchItems = [];
        allFormItemList2.forEach((item) => {
          if (item.checked) {
            searchItems.push({
              field: item.field,
              title: item.title,
              folding: item.folding,
              itemRender: Object.assign({}, item.cellRender)
            });
          }
        });
        $xeListDesign.setSearchItems(searchItems);
      };
      VxeUI.modal.open({
        title: getI18n("vxe.listDesign.search.editPopupTitle"),
        width: 680,
        height: 500,
        showFooter: true,
        escClosable: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: getI18n("vxe.listDesign.searchPopup.saveBtn"),
        showZoom: true,
        resize: true,
        onConfirm: confirmEvent,
        slots: {
          default() {
            const isAllChecked = refIsAllChecked.value;
            const isAllIndeterminate = refIsAllIndeterminate.value;
            const allFormItemList2 = refAllFormItemList.value;
            return h("div", {
              class: "vxe-list-design--field-search-popup"
            }, [
              h("table", {}, [
                h("colgroup", {}, [
                  h("col", {
                    style: {
                      width: "80px"
                    }
                  }),
                  h("col")
                  // h('col', {
                  //   style: {
                  //     width: '140px'
                  //   }
                  // })
                ]),
                h("thead", {}, [
                  h("th", {}, [
                    h("div", {
                      class: ["vxe-list-design--field-search-checkbox-option", {
                        "is--checked": isAllChecked,
                        "is--indeterminate": isAllIndeterminate
                      }],
                      title: getI18n("vxe.table.allTitle"),
                      onClick: allOptionEvent
                    }, [
                      h("span", {
                        class: ["vxe-checkbox--icon", isAllIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isAllChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
                      }),
                      h("span", {
                        class: "vxe-checkbox--label"
                      }, getI18n("vxe.toolbar.customAll"))
                    ])
                  ]),
                  h("th", {}, getI18n("vxe.listDesign.searchPopup.colTitle"))
                  // h('th', {}, '展开/折叠')
                ]),
                h("tbody", {}, allFormItemList2.map((item) => {
                  const isChecked = item.checked;
                  const isIndeterminate = item.isHalf;
                  return h("tr", {}, [
                    h("td", {
                      class: "vxe-list-design--field-search-option-item col--visible"
                    }, [
                      h("div", {
                        class: ["vxe-list-design--field-search-checkbox-option", {
                          "is--checked": isChecked,
                          "is--indeterminate": isIndeterminate
                        }],
                        title: getI18n("vxe.custom.setting.colVisible"),
                        onClick: () => {
                          changeCheckboxOption(item);
                        }
                      }, [
                        h("span", {
                          class: ["vxe-checkbox--icon", isIndeterminate ? getIcon().CHECKBOX_INDETERMINATE : isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
                        })
                      ])
                    ]),
                    h("td", {
                      class: "vxe-list-design--field-search-option-item"
                    }, `${item.title || ""}`)
                    // h('td', {}, [
                    //   h(VxeRadioGroupComponent, {
                    //     modelValue: item.folding,
                    //     type: 'button',
                    //     options: foldOptions.value,
                    //     size: 'mini',
                    //     'onUpdate:modelValue' (val) {
                    //       item.folding = val
                    //     }
                    //   })
                    // ])
                  ]);
                }))
              ])
            ]);
          }
        }
      });
    };
    const renderChildOptions = (item) => {
      const { children } = item;
      if (children && children.length) {
        return h("div", {
          class: "vxe-list-design--field-option-inner"
        }, [
          h("div", {
            class: "vxe-list-design--field-sub-option",
            onClick() {
              changeVisible(item);
            }
          }, children.map((child) => {
            const { title, visible: isChecked } = child;
            return h("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": isChecked
              }],
              onClick() {
                changeVisible(child);
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, `${title}`)
            ]);
          }))
        ]);
      }
      return createCommentVNode();
    };
    const renderFieldOptions = () => {
      const { listTableColumns } = listDesignReactData;
      return listTableColumns.map((item) => {
        const { title, visible: isChecked } = item;
        return h("div", {
          class: "vxe-list-design--field-option"
        }, [
          h("div", {
            class: "vxe-list-design--field-option-inner"
          }, [
            h("div", {
              class: ["vxe-list-design--field-checkbox-option", {
                "is--checked": isChecked
              }],
              onClick() {
                changeVisible(item);
              }
            }, [
              h("span", {
                class: ["vxe-checkbox--icon", isChecked ? getIcon().CHECKBOX_CHECKED : getIcon().CHECKBOX_UNCHECKED]
              }),
              h("span", {
                class: "vxe-checkbox--label"
              }, `${title}`)
            ])
          ]),
          renderChildOptions(item)
        ]);
      });
    };
    return () => {
      return h(form_default, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: getI18n("vxe.listDesign.searchField")
            }, {
              extra() {
                return h(button_default, {
                  mode: "text",
                  status: "primary",
                  icon: getIcon().FORM_DESIGN_PROPS_EDIT,
                  content: getI18n("vxe.listDesign.search.addBtn"),
                  onClick: addSearchEvent
                });
              },
              default() {
                const { searchFormItems } = listDesignReactData;
                return [
                  searchFormItems.length ? h("div", {
                    class: "vxe-list-design--search-item-wrapper"
                  }, [
                    h("div", {
                      class: "vxe-list-design--search-item-list"
                    }, searchFormItems.map((item) => {
                      return h("div", {
                        key: item.field,
                        class: "vxe-list-design--search-item"
                      }, [
                        h("div", {
                          class: "vxe-list-design--search-item-title"
                        }, `${item.title || ""}`),
                        h("div", {
                          class: "vxe-list-design--search-item-btn"
                        }, [
                          h(button_default, {
                            icon: getIcon().LIST_DESIGN_LIST_SETTING_SEARCH_DELETE,
                            mode: "text",
                            status: "error",
                            onClick() {
                              removeSearchItem(item);
                            }
                          })
                        ])
                      ]);
                    }))
                  ]) : h("div", {
                    class: "vxe-list-design--field-configs-empty-data"
                  }, [
                    h("span", {}, getI18n("vxe.listDesign.search.emptyText"))
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: getI18n("vxe.listDesign.listField")
            }, {
              default() {
                return renderFieldOptions();
              }
            })
          ];
        }
      });
    };
  }
});
var DefaultParameterSettingFormComponent = defineComponent({
  name: "DefaultListSettingTabComponent",
  props: {},
  emits: [],
  setup() {
    const $xeListDesign = inject("$xeListDesign", null);
    if (!$xeListDesign) {
      return () => [];
    }
    const { props: listDesignProps, reactData: listDesignReactData } = $xeListDesign;
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const renderViewList = ref([
      { label: "列表视图", value: "list", isExpand: false }
    ]);
    const refSeqOpts = ref([
      { label: "显示", value: true },
      { label: "隐藏", value: false }
    ]);
    const refCheckboxOpts = ref([
      { label: "默认", value: "auto" },
      { label: "允许", value: true },
      { label: "不允许", value: false }
    ]);
    const disableView = computed(() => {
      const { formData } = listDesignReactData;
      return [formData.listView.enabled, formData.ganttView.enabled, formData.chartView.enabled].filter((enabled) => enabled).length <= 1;
    });
    const openActiveBtnPopup = (activeBtnObj) => {
      const { formData } = listDesignReactData;
      const { actionCodes } = listDesignProps;
      let btnList = formData.actionButtonList;
      if (!btnList) {
        btnList = [];
      }
      const activeBtnItem = reactive(createListDesignActionButton(activeBtnObj));
      const systemBtnList = systemConfigList.filter((item) => {
        if (actionCodes && actionCodes.length) {
          if (!actionCodes.some((conf) => import_xe_utils134.default.isString(conf) ? item.code === conf : conf.code === item.code)) {
            return false;
          }
        }
        return !btnList.some((obj) => obj.code === item.code);
      });
      const customBtnList = customConfigList.filter((item) => !btnList.some((obj) => obj.code === item.code));
      const btOptions = [];
      if (systemBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = "";
        }
        btOptions.push({ value: "", label: "系统按钮" });
      }
      if (customBtnList.length) {
        if (!activeBtnItem.type) {
          activeBtnItem.type = "custom";
        }
        btOptions.push({ value: "custom", label: "自定义按钮" });
      }
      const refSystemConfigOptions = computed(() => {
        return systemBtnList.map((item) => {
          const nameConfig = item.name;
          return {
            label: import_xe_utils134.default.toValueString(import_xe_utils134.default.isFunction(nameConfig) ? nameConfig({ name: item.code || "" }) : nameConfig),
            value: item.code
          };
        });
      });
      const refBtnTypeOptions = ref(btOptions);
      VxeUI.modal.open({
        title: "添加按钮",
        width: 600,
        height: 400,
        showFooter: true,
        showCancelButton: true,
        showConfirmButton: true,
        confirmButtonText: "保存",
        onConfirm() {
          if (activeBtnItem.type === "custom") {
            btnList.push(activeBtnItem);
          } else {
            btnList.push(activeBtnItem);
          }
          formData.actionButtonList = [...btnList];
        },
        slots: {
          default() {
            return h(form_default, {
              vertical: true,
              titleBold: true
            }, {
              default() {
                return [
                  h(form_item_default, {
                    title: "按钮类型",
                    span: 24
                  }, {
                    default() {
                      return h(select_default, {
                        modelValue: activeBtnItem.type,
                        options: refBtnTypeOptions.value,
                        "onUpdate:modelValue"(val) {
                          activeBtnItem.type = val;
                        }
                      });
                    }
                  }),
                  h(form_item_default, {
                    title: "选择系统按钮",
                    span: 24
                  }, {
                    default() {
                      return h(select_default, {
                        modelValue: activeBtnItem.code,
                        options: refSystemConfigOptions.value,
                        "onUpdate:modelValue"(val) {
                          activeBtnItem.code = val;
                        }
                      });
                    }
                  })
                  // h(VxeFormItemComponent, {
                  //   title: '按钮位置',
                  //   span: 24
                  // }, {
                  //   default () {
                  //     return h(VxeSelectComponent, {
                  //       modelValue: activeBtnItem.classify,
                  //       options: refBtnClassifyOptions.value,
                  //       'onUpdate:modelValue' (val) {
                  //         activeBtnItem.classify = val
                  //       }
                  //     })
                  //   }
                  // })
                ];
              }
            });
          }
        }
      });
    };
    const renderDefaultCellActionButton = () => {
      return h(form_item_default, {
        title: "功能按钮"
      }, {
        extra() {
          return h(button_default, {
            mode: "text",
            status: "primary",
            icon: getIcon().FORM_DESIGN_PROPS_ADD,
            content: "新增",
            onClick() {
              openActiveBtnPopup();
            }
          });
        },
        default() {
          const { formData } = listDesignReactData;
          const btnList = formData.actionButtonList;
          return btnList && btnList.length ? h("div", {
            class: "vxe-list-design--field-configs-wrapper"
          }, btnList.map((btnItem) => {
            let btnIcon = "";
            let btnName = "";
            if (btnItem.type === "custom") {
              btnIcon = btnItem.icon;
              btnName = btnItem.name;
            } else {
              const btnConfig = systemConfigList.find((item) => item.code === btnItem.code);
              if (btnConfig) {
                const nameConfig = btnConfig.name;
                btnIcon = btnConfig.icon || "";
                btnName = import_xe_utils134.default.toValueString(import_xe_utils134.default.isFunction(nameConfig) ? nameConfig({ name: btnConfig.code || "" }) : nameConfig);
              }
            }
            return h("div", {
              class: "vxe-list-design--field-configs-item"
            }, [
              btnIcon ? h("div", {
                class: "vxe-list-design--field-configs-item-icon"
              }, [
                h("i", {
                  class: btnIcon
                })
              ]) : createCommentVNode(),
              h("div", {
                class: "vxe-list-design--field-configs-item-title"
              }, `${btnName || ""}`),
              h("div", {
                class: "vxe-list-design--field-configs-item-btn"
              }, [
                h(button_default, {
                  icon: getIcon().LIST_DESIGN_LIST_SETTING_ACTIVE_DELETE,
                  mode: "text",
                  status: "error",
                  onClick() {
                    formData.actionButtonList = btnList.filter((item) => item !== btnItem);
                  }
                })
              ])
            ]);
          })) : h("div", {
            class: "vxe-list-design--field-configs-empty-data"
          }, [
            h("span", {}, "无操作按钮")
          ]);
        }
      });
    };
    return () => {
      const { showPc, showMobile } = listDesignProps;
      const { formData } = listDesignReactData;
      return h(form_default, {
        span: 24,
        vertical: true,
        titleBold: true
      }, {
        default() {
          return [
            h(form_item_default, {
              title: "视图配置"
            }, {
              default() {
                return h("div", {
                  class: "vxe-form-design--widget-form-item-render-view"
                }, renderViewList.value.map((item) => {
                  return h("div", {
                    key: item.value,
                    class: "vxe-form-design--widget-form-item-render-view-item"
                  }, [
                    h(switch_default, {
                      modelValue: formData.listView.enabled,
                      disabled: disableView.value,
                      "onUpdate:modelValue"(val) {
                        formData.listView.enabled = val;
                      }
                    }),
                    h(text_default, {
                      content: item.label,
                      icon: "vxe-icon-table"
                    })
                  ]);
                }));
              }
            }),
            h(form_item_default, {
              title: "默认视图"
            }, {
              default() {
                return [
                  h("div", {
                    class: "vxe-form-design--widget-form-item-devices"
                  }, [
                    showPc ? h("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      h("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        h(text_default, {
                          icon: getIcon().FORM_DESIGN_PROPS_PC,
                          content: getI18n("vxe.formDesign.widgetProp.displaySetting.pc")
                        })
                      ]),
                      h(select_default, {
                        modelValue: formData.pcDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: renderViewList.value,
                        "onUpdate:modelValue"(val) {
                          formData.pcDefaultView = val;
                        }
                      })
                    ]) : createCommentVNode(),
                    showMobile ? h("div", {
                      class: "vxe-form-design--widget-form-item-devices-item"
                    }, [
                      h("div", {
                        class: "vxe-form-design--widget-form-item-devices-left"
                      }, [
                        h(text_default, {
                          icon: getIcon().FORM_DESIGN_PROPS_MOBILE,
                          content: getI18n("vxe.formDesign.widgetProp.displaySetting.mobile")
                        })
                      ]),
                      h(select_default, {
                        modelValue: formData.mobileDefaultView,
                        className: "vxe-form-design--widget-form-item-devices-select",
                        options: renderViewList.value,
                        "onUpdate:modelValue"(val) {
                          formData.mobileDefaultView = val;
                        }
                      })
                    ]) : createCommentVNode()
                  ])
                ];
              }
            }),
            // h(VxeFormItemComponent, {
            //   title: '查询配置'
            // }, {
            //   default () {
            //     const { formData } = listDesignReactData
            //     return [
            //       h('div', {
            //         class: 'vxe-list-design--widget-form-item-prop-list'
            //       }, [
            //         h('span', {}, '折叠字段'),
            //         h(VxeRadioGroupComponent, {
            //           modelValue: formData.autoFoldFilter,
            //           options: refFoldOpts.value,
            //           'onUpdate:modelValue' (val) {
            //             formData.autoFoldFilter = val
            //           }
            //         })
            //       ])
            //     ]
            //   }
            // }),
            h(form_item_default, {
              title: "列配置"
            }, {
              default() {
                const { formData: formData2 } = listDesignReactData;
                return [
                  h("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, "显示序号"),
                    h(group_default3, {
                      modelValue: formData2.showSeq,
                      options: refSeqOpts.value,
                      "onUpdate:modelValue"(val) {
                        formData2.showSeq = val;
                      }
                    })
                  ]),
                  h("div", {
                    class: "vxe-list-design--widget-form-item-prop-list"
                  }, [
                    h("span", {}, "表尾统计"),
                    h(group_default3, {
                      modelValue: formData2.showStatistics,
                      options: refSeqOpts.value,
                      "onUpdate:modelValue"(val) {
                        formData2.showStatistics = val;
                      }
                    })
                  ])
                ];
              }
            }),
            h(form_item_default, {
              title: "批量操作"
            }, {
              default() {
                const { formData: formData2 } = listDesignReactData;
                return h(group_default3, {
                  modelValue: formData2.showCheckbox,
                  options: refCheckboxOpts.value,
                  "onUpdate:modelValue"(val) {
                    formData2.showCheckbox = val;
                  }
                });
              }
            }),
            systemConfigList.length || customConfigList.length ? renderDefaultCellActionButton() : createCommentVNode()
          ];
        }
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/list-design/src/layout-setting.js
var layout_setting_default2 = defineComponent({
  name: "ListDesignLayoutSetting",
  props: {},
  emits: [],
  setup() {
    const activeTab = ref(1);
    return () => {
      return h("div", {
        class: "vxe-list-design--setting"
      }, [
        h("div", {
          class: "vxe-list-design--setting-form"
        }, [
          h(tabs_default, {
            modelValue: activeTab.value,
            titleWidth: "50%",
            titleAlign: "center",
            padding: true,
            class: "vxe-list-design--setting-form-tabs",
            "onUpdate:modelValue"(val) {
              activeTab.value = val;
            }
          }, {
            default() {
              return [
                h(tab_pane_default, {
                  title: getI18n("vxe.listDesign.fieldSettingTab"),
                  icon: getIcon().LIST_DESIGN_FIELD_SETTING,
                  name: 1
                }, {
                  default() {
                    return h(DefaultFieldSettingFormComponent);
                  }
                }),
                h(tab_pane_default, {
                  title: getI18n("vxe.listDesign.listSettingTab"),
                  icon: getIcon().LIST_DESIGN_LIST_SETTING,
                  name: 2
                }, {
                  default() {
                    return h(DefaultParameterSettingFormComponent);
                  }
                })
              ];
            }
          })
        ])
      ]);
    };
  }
});

// node_modules/vxe-pc-ui/es/list-design/src/list-design.js
var list_design_default = defineComponent({
  name: "VxeListDesign",
  props: {
    size: {
      type: String,
      default: () => getConfig().listDesign.size || getConfig().size
    },
    height: {
      type: [String, Number],
      default: () => getConfig().listDesign.height
    },
    config: Object,
    showPc: {
      type: Boolean,
      default: () => getConfig().listDesign.showPc
    },
    showMobile: {
      type: Boolean,
      default: () => getConfig().listDesign.showMobile
    },
    actionCodes: Array,
    formRender: Object
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils135.default.uniqueId();
    const refElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formData: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {
      computeSize
    };
    const $xeListDesign = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const parseWidgetColumn = (widget) => {
      return {
        title: widget.title,
        field: widget.field,
        visible: !widget.hidden,
        width: "",
        cellRender: {
          name: widget.name,
          props: widget.options
        }
      };
    };
    const parseFormDesignColumns = (config3) => {
      const tableColumns = [];
      if (config3) {
        const { widgetData } = config3;
        if (widgetData) {
          widgetData.forEach((item) => {
            const { name } = item;
            if (name) {
              if (name === "row") {
                item.children.forEach((childItem) => {
                  if (childItem.name) {
                    tableColumns.push(parseWidgetColumn(childItem));
                  }
                });
              } else if (name === "subtable") {
              } else {
                tableColumns.push(parseWidgetColumn(item));
              }
            }
          });
        }
      }
      return tableColumns;
    };
    const configToSearchItems = (searchItems) => {
      if (searchItems) {
        const data = {};
        const items = searchItems.map((item) => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        return {
          items,
          data
        };
      }
      return { items: [], data: {} };
    };
    const configToListColumns = (listColumns) => {
      if (listColumns) {
        return listColumns.map((item) => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: import_xe_utils135.default.clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const loadConfig = (config3) => {
      const { formConfig, searchItems, listColumns } = config3;
      if (formConfig) {
        loadFormConfig(formConfig);
      }
      if (searchItems) {
        setSearchItems(searchItems);
      }
      if (listColumns) {
        reactData.listTableColumns = parseColumnConfigs(listColumns);
      }
      return nextTick();
    };
    const parseColumnConfigs = (listColumns) => {
      return configToListColumns(listColumns);
    };
    const loadFormConfig = (data) => {
      reactData.formData = Object.assign({}, createSettingForm(), data);
      return nextTick();
    };
    const getSearchItems = () => {
      return reactData.searchFormItems;
    };
    const setSearchItems = (searchItems) => {
      const { data, items } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      return nextTick();
    };
    const getListColumns = () => {
      return reactData.listTableColumns;
    };
    const setListColumns = (listColumns) => {
      reactData.listTableColumns = parseColumnConfigs(listColumns);
      return nextTick();
    };
    const createSettingForm = () => {
      const { actionCodes, formRender } = props;
      let conf = getDefaultSettingFormData2();
      if (actionCodes && actionCodes.length) {
        if (!conf.actionButtonList || !conf.actionButtonList.length) {
          const defActionBtnList = [];
          actionCodes.forEach((item) => {
            if (import_xe_utils135.default.isObject(item) && item.default) {
              const sysItem = systemConfigList.find((obj) => obj.code === item.code);
              if (sysItem) {
                defActionBtnList.push(createListDesignActionButton({
                  type: sysItem.type,
                  code: sysItem.code
                }));
              }
            }
          });
          conf.actionButtonList = defActionBtnList;
        }
      }
      if (formRender && formRender.name) {
        const compConf = renderer.get(formRender.name);
        const createFormConfig = compConf ? compConf.createListDesignSettingFormConfig : null;
        const params = { name: formRender.name };
        conf = (createFormConfig ? createFormConfig(params) : {}) || {};
      }
      return conf;
    };
    const initSettingForm = () => {
      reactData.formData = createSettingForm();
    };
    const clearConfig = () => {
      loadConfig({
        searchItems: [],
        listColumns: []
      });
      initSettingForm();
      return nextTick();
    };
    const listDesignMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $listDesign: $xeListDesign }, params));
      },
      loadFormDesignConfig(config3) {
        const { listTableColumns } = reactData;
        const oldMaps = {};
        import_xe_utils135.default.eachTree(listTableColumns, (item) => {
          oldMaps[item.field] = item;
        }, { children: "children" });
        const columns = parseFormDesignColumns(config3);
        import_xe_utils135.default.eachTree(columns, (item) => {
          const oldItem = oldMaps[item.field];
          if (oldItem) {
            if (oldItem.width) {
              item.width = oldItem.width;
            }
            item.visible = oldItem.visible;
          }
        }, { children: "children" });
        reactData.listTableColumns = columns;
        return nextTick();
      },
      reloadFormDesignConfig(config3) {
        reactData.listTableColumns = parseFormDesignColumns(config3);
        return nextTick();
      },
      getSearchItems,
      setSearchItems,
      getListColumns,
      setListColumns,
      getConfig() {
        return {
          formConfig: reactData.formData,
          searchItems: getSearchItems(),
          listColumns: getListColumns()
        };
      },
      loadConfig,
      reloadConfig(config3) {
        clearConfig();
        return loadConfig(config3);
      },
      clearConfig
    };
    const listDesignPrivateMethods = {};
    Object.assign($xeListDesign, listDesignMethods, listDesignPrivateMethods);
    const renderVN = () => {
      const { height } = props;
      const vSize = computeSize.value;
      const headerSlot = slots.header;
      return h("div", {
        ref: refElem,
        class: ["vxe-list-design", {
          [`size--${vSize}`]: vSize
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-list-design--header"
        }, headerSlot ? headerSlot({}) : []),
        h("div", {
          class: "vxe-list-design--body"
        }, [
          h(layout_preview_default2),
          h(layout_setting_default2)
        ])
      ]);
    };
    provide("$xeListDesign", $xeListDesign);
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    initSettingForm();
    if (props.config) {
      loadConfig(props.config);
    }
    $xeListDesign.renderVN = renderVN;
    return $xeListDesign;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/list-design/render/index.js
renderer.mixin({
  // ActionButtonUpdate: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-edit',
  //       status: 'primary'
  //     }
  //   }
  // },
  // ActionButtonDelete: {
  //   createListDesignSettingActionButtonConfig () {
  //     return {
  //       name: handleGetListDesignActionButtonName,
  //       icon: 'vxe-icon-delete',
  //       status: 'error'
  //     }
  //   }
  // }
});

// node_modules/vxe-pc-ui/es/list-design/index.js
var VxeListDesign = Object.assign({}, list_design_default, {
  install(app) {
    app.component(list_design_default.name, list_design_default);
  }
});
var listDesignHandle = {};
dynamicApp.use(VxeListDesign);
VxeUI.component(list_design_default);
VxeUI.listDesignHandle = listDesignHandle;
var ListDesign = VxeListDesign;
var list_design_default2 = VxeListDesign;

// node_modules/vxe-pc-ui/es/list-design/src/list-view.js
var import_xe_utils136 = __toESM(require_xe_utils());
var list_view_default = defineComponent({
  name: "VxeListView",
  props: {
    size: {
      type: String,
      default: () => getConfig().listView.size || getConfig().size
    },
    config: Object,
    height: {
      type: [String, Number],
      default: () => getConfig().listView.height
    },
    loading: Boolean,
    formData: Object,
    actionButtons: Array,
    gridOptions: Object,
    gridEvents: Object,
    viewRender: Object
  },
  emits: [
    "cell-action",
    "update:formData",
    "update:actionButtons"
  ],
  setup(props, context) {
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const { emit, slots } = context;
    const xID = import_xe_utils136.default.uniqueId();
    const refElem = ref();
    const refGrid = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      formConfig: {},
      searchFormData: {},
      searchFormItems: [],
      listTableColumns: [],
      tableColumns: [],
      footerData: [
        {}
        // 默认一行合计
      ]
    });
    const computeGridOptions = computed(() => {
      const { gridOptions } = props;
      const { formConfig, tableColumns, searchFormData, searchFormItems, footerData } = reactData;
      const { showStatistics } = formConfig;
      const gridOpts = gridOptions || {};
      const columnOpts = Object.assign({
        minWidth: 120
      }, gridOpts.columnConfig);
      let proxyOpts;
      if (gridOpts.proxyConfig) {
        proxyOpts = Object.assign({ autoLoad: false }, gridOpts.proxyConfig);
      }
      return Object.assign({}, gridOpts, {
        columns: tableColumns,
        columnConfig: columnOpts,
        showFooter: showStatistics,
        footerData: showStatistics ? footerData : null,
        formConfig: {
          data: searchFormData,
          items: searchFormItems
        },
        proxyConfig: proxyOpts
      });
    });
    const computeGridEvents = computed(() => {
      const { gridEvents } = props;
      const ons = {};
      import_xe_utils136.default.each(gridEvents, (fn2, key) => {
        ons[import_xe_utils136.default.camelCase(`on-${key}`)] = fn2;
      });
      return ons;
    });
    const refMaps = {
      refElem,
      refGrid
    };
    const computeMaps = {
      computeSize
    };
    const $xeListView = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const systemConfigList = [];
    const customConfigList = [];
    renderer.forEach((item, name) => {
      const { createListDesignSettingActionButtonConfig } = item;
      if (createListDesignSettingActionButtonConfig) {
        const params = { name };
        const btnConfig = Object.assign(createListDesignActionButton({ code: name }), createListDesignSettingActionButtonConfig(params));
        if (btnConfig.type === "custom") {
          customConfigList.push(btnConfig);
        } else {
          systemConfigList.push(btnConfig);
        }
      }
    });
    const configToSearchItems = (searchItems) => {
      if (searchItems && searchItems.length) {
        const data = {};
        const items = searchItems.map((item) => {
          data[item.field] = null;
          return {
            field: item.field,
            title: item.title,
            folding: item.folding,
            itemRender: item.itemRender
          };
        });
        items.push({
          field: "active",
          title: "",
          folding: false,
          collapseNode: searchItems.some((item) => item.folding),
          itemRender: {
            name: "VxeButtonGroup",
            options: [
              { content: "查询", icon: "vxe-icon-search", status: "primary", type: "submit" },
              { content: "重置", icon: "vxe-icon-repeat", type: "reset" }
            ]
          }
        });
        return {
          items,
          data
        };
      }
      return { items: [], data: {} };
    };
    const configToListColumns = (listColumns) => {
      if (listColumns) {
        return listColumns.map((item) => {
          return {
            field: item.field,
            title: item.title,
            visible: !!item.visible,
            width: item.width,
            cellRender: import_xe_utils136.default.clone(item.cellRender)
          };
        });
      }
      return [];
    };
    const clearConfig = () => {
      emit("update:formData", {});
      Object.assign(reactData, {
        formConfig: {},
        searchFormData: {},
        searchFormItems: [],
        listTableColumns: [],
        tableColumns: [],
        footerData: [
          {}
          // 默认一行合计
        ]
      });
      return nextTick();
    };
    const loadConfig = (config3) => {
      if (config3) {
        const { formConfig, searchItems, listColumns } = config3;
        reactData.formConfig = formConfig || {};
        setSearchItems(searchItems || []);
        loadListColumns(listColumns || []);
      }
      return nextTick();
    };
    const parseForm = (searchItems) => {
      return configToSearchItems(searchItems || []);
    };
    const parseTableColumn = (listColumns, formConfig) => {
      const formOpts = Object.assign({}, formConfig);
      const { showSeq, actionButtonList } = formOpts;
      const columns = [];
      const rowRecord = {};
      const cellActionSlot = slots.cellAction;
      const footerCellSlot = slots.footerCell;
      if (showSeq) {
        columns.push({
          type: "seq",
          field: "_seq",
          fixed: "left",
          width: 70
        });
      }
      configToListColumns(listColumns || []).forEach((conf) => {
        const columnConf = Object.assign({}, conf);
        if (formOpts.showStatistics && footerCellSlot) {
          columnConf.slots = {
            footer: (params) => {
              return footerCellSlot(Object.assign({}, params));
            }
          };
        }
        if (columnConf.field) {
          rowRecord[columnConf.field] = null;
        }
        columns.push(columnConf);
      });
      if (actionButtonList && actionButtonList.length) {
        const actionColumn = {
          field: "_active",
          title: getI18n("vxe.table.actionTitle"),
          fixed: "right",
          width: "auto"
        };
        const btnOptions = [];
        actionButtonList.forEach((btnItem) => {
          if (btnItem.type === "custom") {
            return {
              content: btnItem.name,
              name: btnItem.code,
              icon: btnItem.icon
            };
          }
          const btnConfig = systemConfigList.find((item) => item.code === btnItem.code);
          let btnName = btnItem.name;
          let btnIcon = btnItem.icon;
          let btnStatus = btnItem.status;
          let btnPermissionCode = btnItem.permissionCode;
          let btnClassify = btnItem.classify;
          if (btnConfig) {
            const nameConfig = btnConfig.name;
            btnIcon = btnConfig.icon || "";
            btnStatus = btnConfig.status || "";
            btnPermissionCode = btnConfig.permissionCode || "";
            btnClassify = btnConfig.classify || "";
            btnName = import_xe_utils136.default.toValueString(import_xe_utils136.default.isFunction(nameConfig) ? nameConfig({ name: btnConfig.code || "" }) : nameConfig);
          }
          if (!btnClassify || btnClassify === "cellButton") {
            btnOptions.push({
              content: btnName,
              name: btnItem.code,
              icon: btnIcon,
              status: btnStatus,
              permissionCode: btnPermissionCode
            });
          }
        });
        if (cellActionSlot) {
          actionColumn.slots = {
            default(params) {
              return cellActionSlot(Object.assign(Object.assign({}, params), { buttons: btnOptions }));
            }
          };
        } else {
          actionColumn.cellRender = {
            name: "VxeButtonGroup",
            props: {
              mode: "text"
            },
            options: btnOptions,
            events: {
              click(params, btnParams) {
                const { option: option2 } = btnParams;
                dispatchEvent2("cell-action", Object.assign(Object.assign({}, params), { button: option2 }), btnParams.$event);
              }
            }
          };
        }
        columns.push(actionColumn);
      }
      return { rowRecord, columns, actionButtons: actionButtonList };
    };
    const parseConfig = (config3) => {
      const { formConfig, searchItems, listColumns } = config3 || {};
      const { columns, rowRecord, actionButtons } = parseTableColumn(listColumns || [], formConfig || reactData.formConfig);
      const { data, items } = parseForm(searchItems || []);
      return {
        formData: data,
        formItems: items,
        tableColumns: columns,
        tableRecord: rowRecord,
        actionButtons
      };
    };
    const getTableRecord = (configOrListColumns) => {
      if (import_xe_utils136.default.isArray(configOrListColumns)) {
        const { rowRecord } = parseTableColumn(configOrListColumns, reactData.formConfig);
        return rowRecord;
      }
      if (configOrListColumns) {
        const { formConfig, listColumns } = configOrListColumns;
        const { rowRecord } = parseTableColumn(listColumns || [], formConfig || reactData.formConfig);
        return rowRecord;
      }
      return {};
    };
    const getQueryFilter = () => {
      const { searchFormData, searchFormItems } = reactData;
      const items = [];
      const rest = {
        items,
        type: "and"
      };
      const $grid = refGrid.value;
      if (!$grid) {
        return rest;
      }
      searchFormItems.forEach((item) => {
        const { field } = item;
        const itemValue = searchFormData[field];
        if (itemValue) {
          const condition = [];
          condition.push({
            field,
            value: itemValue,
            match: "exact",
            type: import_xe_utils136.default.isArray(itemValue) ? "array" : ""
          });
          items.push({
            condition,
            type: "and"
          });
        }
      });
      return rest;
    };
    const commitProxy = (code3, ...args) => {
      const $grid = refGrid.value;
      if ($grid) {
        return $grid.commitProxy(code3, ...args);
      }
      return Promise.resolve();
    };
    const loadListColumns = (listColumns) => {
      const { formConfig } = reactData;
      const listTableColumns = listColumns || [];
      const { columns, actionButtons } = parseTableColumn(listTableColumns, formConfig);
      reactData.listTableColumns = listTableColumns;
      reactData.tableColumns = columns;
      emit("update:actionButtons", actionButtons);
      nextTick(() => {
        const gridOptions = computeGridOptions.value;
        if (gridOptions.proxyConfig) {
          commitProxy("reload");
        }
      });
    };
    const setSearchItems = (searchItems) => {
      const { data, items } = configToSearchItems(searchItems);
      reactData.searchFormData = data;
      reactData.searchFormItems = items;
      emit("update:formData", data);
      return nextTick();
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $listView: $xeListView }, params));
    };
    const listViewMethods = {
      dispatchEvent: dispatchEvent2,
      clearConfig,
      loadConfig,
      parseConfig,
      getTableRecord,
      getQueryFilter,
      commitProxy
    };
    const listViewPrivateMethods = {};
    Object.assign($xeListView, listViewMethods, listViewPrivateMethods);
    const renderVN = () => {
      const { height, loading: loading2 } = props;
      const vSize = computeSize.value;
      const gridSlot = slots.grid;
      const gridOptions = computeGridOptions.value;
      const gridEvents = computeGridEvents.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list-view", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }],
        style: height ? {
          height: toCssUnit(height)
        } : null
      }, [
        h("div", {
          class: "vxe-list-view--body"
        }, [
          gridSlot ? h("div", {
            class: "vxe-list-view--grid-wrapper"
          }, getSlotVNs2(gridSlot({ $listView: $xeListView }))) : VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign({}, gridOptions, gridEvents, {
            ref: refGrid
          }), Object.assign({}, slots, {
            default: void 0
          })) : createCommentVNode()
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    watch(() => props.config, (value) => {
      loadConfig(value || {});
    });
    if (props.config) {
      loadConfig(props.config);
    }
    provide("$xeListView", $xeListView);
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog2("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    $xeListView.renderVN = renderVN;
    return $xeListView;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/list-view/index.js
var VxeListView = Object.assign(list_view_default, {
  install: function(app) {
    app.component(list_view_default.name, list_view_default);
  }
});
dynamicApp.use(VxeListView);
VxeUI.component(list_view_default);
var ListView = VxeListView;
var list_view_default2 = VxeListView;

// node_modules/vxe-pc-ui/es/list/src/list.js
var import_xe_utils137 = __toESM(require_xe_utils());
var list_default = defineComponent({
  name: "VxeList",
  props: {
    data: Array,
    height: [Number, String],
    maxHeight: [Number, String],
    loading: Boolean,
    className: [String, Function],
    size: { type: String, default: () => getConfig().list.size || getConfig().size },
    autoResize: { type: Boolean, default: () => getConfig().list.autoResize },
    syncResize: [Boolean, String, Number],
    scrollY: Object
  },
  emits: [
    "scroll"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils137.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      scrollYLoad: false,
      bodyHeight: 0,
      topSpaceHeight: 0,
      items: []
    });
    const internalData = {
      resizeObserver: void 0,
      fullData: [],
      lastScrollLeft: 0,
      lastScrollTop: 0,
      scrollYStore: {
        startIndex: 0,
        endIndex: 0,
        visibleSize: 0,
        offsetSize: 0,
        rowHeight: 0
      }
    };
    const refElem = ref();
    const refVirtualWrapper = ref();
    const refVirtualBody = ref();
    const refMaps = {
      refElem
    };
    const $xeList = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    const computeSYOpts = computed(() => {
      return Object.assign({}, getConfig().list.scrollY, props.scrollY);
    });
    const computeStyles = computed(() => {
      const { height, maxHeight } = props;
      const style = {};
      if (height) {
        style.height = `${isNaN(height) ? height : `${height}px`}`;
      } else if (maxHeight) {
        style.height = "auto";
        style.maxHeight = `${isNaN(maxHeight) ? maxHeight : `${maxHeight}px`}`;
      }
      return style;
    });
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $list: $xeList }, params));
    };
    const updateYSpace = () => {
      const { scrollYLoad } = reactData;
      const { scrollYStore, fullData } = internalData;
      reactData.bodyHeight = scrollYLoad ? fullData.length * scrollYStore.rowHeight : 0;
      reactData.topSpaceHeight = scrollYLoad ? Math.max(scrollYStore.startIndex * scrollYStore.rowHeight, 0) : 0;
    };
    const handleData = () => {
      const { scrollYLoad } = reactData;
      const { fullData, scrollYStore } = internalData;
      reactData.items = scrollYLoad ? fullData.slice(scrollYStore.startIndex, scrollYStore.endIndex) : fullData.slice(0);
      return nextTick();
    };
    const updateYData = () => {
      handleData();
      updateYSpace();
    };
    const computeScrollLoad = () => {
      return nextTick().then(() => {
        const { scrollYLoad } = reactData;
        const { scrollYStore } = internalData;
        const virtualBodyElem = refVirtualBody.value;
        const sYOpts = computeSYOpts.value;
        let rowHeight = 0;
        let firstItemElem;
        if (virtualBodyElem) {
          if (sYOpts.sItem) {
            firstItemElem = virtualBodyElem.querySelector(sYOpts.sItem);
          }
          if (!firstItemElem) {
            firstItemElem = virtualBodyElem.children[0];
          }
        }
        if (firstItemElem) {
          rowHeight = firstItemElem.offsetHeight;
        }
        rowHeight = Math.max(20, rowHeight);
        scrollYStore.rowHeight = rowHeight;
        if (scrollYLoad) {
          const scrollBodyElem = refVirtualWrapper.value;
          const visibleYSize = Math.max(8, Math.ceil(scrollBodyElem.clientHeight / rowHeight));
          const offsetYSize = sYOpts.oSize ? import_xe_utils137.default.toNumber(sYOpts.oSize) : browse3.edge ? 10 : 0;
          scrollYStore.offsetSize = offsetYSize;
          scrollYStore.visibleSize = visibleYSize;
          scrollYStore.endIndex = Math.max(scrollYStore.startIndex, visibleYSize + offsetYSize, scrollYStore.endIndex);
          updateYData();
        } else {
          updateYSpace();
        }
      });
    };
    const clearScroll = () => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (scrollBodyElem) {
        scrollBodyElem.scrollTop = 0;
      }
      return nextTick();
    };
    const scrollTo = (scrollLeft, scrollTop) => {
      const scrollBodyElem = refVirtualWrapper.value;
      if (import_xe_utils137.default.isNumber(scrollLeft)) {
        scrollBodyElem.scrollLeft = scrollLeft;
      }
      if (import_xe_utils137.default.isNumber(scrollTop)) {
        scrollBodyElem.scrollTop = scrollTop;
      }
      if (reactData.scrollYLoad) {
        return new Promise((resolve) => {
          setTimeout(() => {
            nextTick(() => {
              resolve();
            });
          }, 50);
        });
      }
      return nextTick();
    };
    const refreshScroll = () => {
      const { lastScrollLeft, lastScrollTop } = internalData;
      return clearScroll().then(() => {
        if (lastScrollLeft || lastScrollTop) {
          internalData.lastScrollLeft = 0;
          internalData.lastScrollTop = 0;
          return scrollTo(lastScrollLeft, lastScrollTop);
        }
      });
    };
    const recalculate = () => {
      const el2 = refElem.value;
      if (el2.clientWidth && el2.clientHeight) {
        return computeScrollLoad();
      }
      return Promise.resolve();
    };
    const loadYData = (evnt) => {
      const { scrollYStore } = internalData;
      const { startIndex, endIndex, visibleSize, offsetSize, rowHeight } = scrollYStore;
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const toVisibleIndex = Math.floor(scrollTop / rowHeight);
      const offsetStartIndex = Math.max(0, toVisibleIndex - 1 - offsetSize);
      const offsetEndIndex = toVisibleIndex + visibleSize + offsetSize;
      if (toVisibleIndex <= startIndex || toVisibleIndex >= endIndex - visibleSize - 1) {
        if (startIndex !== offsetStartIndex || endIndex !== offsetEndIndex) {
          scrollYStore.startIndex = offsetStartIndex;
          scrollYStore.endIndex = offsetEndIndex;
          updateYData();
        }
      }
    };
    const scrollEvent = (evnt) => {
      const scrollBodyElem = evnt.target;
      const scrollTop = scrollBodyElem.scrollTop;
      const scrollLeft = scrollBodyElem.scrollLeft;
      const isX = scrollLeft !== internalData.lastScrollLeft;
      const isY = scrollTop !== internalData.lastScrollTop;
      internalData.lastScrollTop = scrollTop;
      internalData.lastScrollLeft = scrollLeft;
      if (reactData.scrollYLoad) {
        loadYData(evnt);
      }
      dispatchEvent2("scroll", { scrollLeft, scrollTop, isX, isY }, evnt);
    };
    const loadData = (datas) => {
      const { scrollYStore } = internalData;
      const sYOpts = computeSYOpts.value;
      const fullData = datas || [];
      Object.assign(scrollYStore, {
        startIndex: 0,
        endIndex: 1,
        visibleSize: 0
      });
      internalData.fullData = fullData;
      reactData.scrollYLoad = !!sYOpts.enabled && sYOpts.gt > -1 && (sYOpts.gt === 0 || sYOpts.gt <= fullData.length);
      handleData();
      return computeScrollLoad().then(() => {
        refreshScroll();
      });
    };
    const listMethods = {
      dispatchEvent: dispatchEvent2,
      loadData,
      /**
       * 重新加载数据
       * @param {Array} datas 数据
       */
      reloadData(datas) {
        clearScroll();
        return loadData(datas);
      },
      recalculate,
      scrollTo,
      refreshScroll,
      clearScroll
    };
    Object.assign($xeList, listMethods);
    const dataFlag = ref(0);
    watch(() => props.data ? props.data.length : -1, () => {
      dataFlag.value++;
    });
    watch(() => props.data, () => {
      dataFlag.value++;
    });
    watch(dataFlag, () => {
      loadData(props.data || []);
    });
    watch(() => props.syncResize, (value) => {
      if (value) {
        recalculate();
        nextTick(() => setTimeout(() => recalculate()));
      }
    });
    onActivated(() => {
      recalculate().then(() => refreshScroll());
    });
    nextTick(() => {
      globalEvents.on($xeList, "resize", () => {
        recalculate();
      });
      if (props.autoResize) {
        const el2 = refElem.value;
        const resizeObserver = globalResize.create(() => recalculate());
        resizeObserver.observe(el2);
        internalData.resizeObserver = resizeObserver;
      }
      loadData(props.data || []);
    });
    onUnmounted(() => {
      const { resizeObserver } = internalData;
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
      globalEvents.off($xeList, "resize");
    });
    const renderVN = () => {
      const { className, loading: loading2 } = props;
      const { bodyHeight, topSpaceHeight, items } = reactData;
      const defaultSlot = slots.default;
      const vSize = computeSize.value;
      const styles = computeStyles.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-list", className ? import_xe_utils137.default.isFunction(className) ? className({ $list: $xeList }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          ref: refVirtualWrapper,
          class: "vxe-list--virtual-wrapper",
          style: styles,
          onScroll: scrollEvent
        }, [
          h("div", {
            class: "vxe-list--y-space",
            style: {
              height: bodyHeight ? `${bodyHeight}px` : ""
            }
          }),
          h("div", {
            ref: refVirtualBody,
            class: "vxe-list--body",
            style: {
              marginTop: topSpaceHeight ? `${topSpaceHeight}px` : ""
            }
          }, defaultSlot ? defaultSlot({ items, $list: $xeList }) : [])
        ]),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list--loading",
          modelValue: loading2
        })
      ]);
    };
    $xeList.renderVN = renderVN;
    return $xeList;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/list/index.js
var VxeList = Object.assign(list_default, {
  install(app) {
    app.component(list_default.name, list_default);
  }
});
dynamicApp.use(VxeList);
VxeUI.component(list_default);
var List = VxeList;
var list_default2 = VxeList;

// node_modules/vxe-pc-ui/es/menu/src/menu.js
var import_xe_utils138 = __toESM(require_xe_utils());
var menu_default = defineComponent({
  name: "VxeMenu",
  props: {
    modelValue: [String, Number],
    expandAll: Boolean,
    collapsed: {
      type: Boolean,
      default: null
    },
    collapseFixed: Boolean,
    loading: Boolean,
    options: {
      type: Array,
      default: () => []
    },
    size: {
      type: String,
      default: () => getConfig().image.size || getConfig().size
    }
  },
  emits: [
    "update:modelValue",
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils138.default.uniqueId();
    const $xeLayoutAside = inject("$xeLayoutAside", null);
    const refElem = ref();
    const refCollapseElem = ref();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: !!props.collapsed,
      isEnterCollapse: false,
      collapseStyle: {},
      collapseZindex: 0,
      activeName: props.modelValue,
      menuList: [],
      itemHeight: 1
    });
    const refMaps = {
      refElem
    };
    const computeIsCollapsed = computed(() => {
      const { collapsed } = props;
      if (import_xe_utils138.default.isBoolean(collapsed)) {
        return collapsed;
      }
      if ($xeLayoutAside) {
        return $xeLayoutAside.props.collapsed;
      }
      return false;
    });
    const computeCollapseWidth = computed(() => {
      let collapseWidth = "";
      if ($xeLayoutAside) {
        collapseWidth = $xeLayoutAside.props.collapseWidth || "";
      }
      return collapseWidth;
    });
    const computeCollapseEnterWidth = computed(() => {
      let width = "";
      if ($xeLayoutAside) {
        width = $xeLayoutAside.props.width || "";
      }
      return width;
    });
    const computeMaps = {
      computeSize
    };
    const $xeMenu = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const getMenuTitle = (item) => {
      return `${item.title || item.name}`;
    };
    const updateZindex = () => {
      if (reactData.collapseZindex < getLastZIndex2()) {
        reactData.collapseZindex = nextZIndex2();
      }
    };
    const updateActiveMenu = (isDefExpand) => {
      const { activeName } = reactData;
      import_xe_utils138.default.eachTree(reactData.menuList, (item, index2, items, path, parent, nodes) => {
        if (item.itemKey === activeName) {
          nodes.forEach((obj) => {
            obj.isActive = true;
            if (isDefExpand) {
              obj.isExpand = true;
            }
          });
          item.isExactActive = true;
        } else {
          item.isExactActive = false;
          item.isActive = false;
        }
      }, { children: "childList" });
    };
    const updateMenuConfig = () => {
      const { options, expandAll } = props;
      reactData.menuList = import_xe_utils138.default.mapTree(options, (item, index2, items, path, parent) => {
        const objItem = Object.assign(Object.assign({}, item), { parentKey: parent ? parent.name || path.slice(0, path.length - 1).join(",") : "", level: path.length, itemKey: item.name || path.join(","), isExactActive: false, isActive: false, isExpand: import_xe_utils138.default.isBoolean(item.expanded) ? item.expanded : !!expandAll, hasChild: item.children && item.children.length > 0 });
        return objItem;
      }, { children: "children", mapChildren: "childList" });
    };
    const updateCollapseStyle = () => {
      const { collapseFixed } = props;
      if (collapseFixed) {
        nextTick(() => {
          const { isEnterCollapse } = reactData;
          const isCollapsed = computeIsCollapsed.value;
          const collapseEnterWidth = computeCollapseEnterWidth.value;
          const collapseWidth = computeCollapseWidth.value;
          const el2 = refElem.value;
          if (el2) {
            const clientRect = el2.getBoundingClientRect();
            const parentNode = el2.parentNode;
            reactData.collapseStyle = isCollapsed ? {
              top: toCssUnit(clientRect.top),
              left: toCssUnit(clientRect.left),
              height: toCssUnit(parentNode.clientHeight),
              width: isEnterCollapse ? collapseEnterWidth ? toCssUnit(collapseEnterWidth) : "" : collapseWidth ? toCssUnit(collapseWidth) : "",
              zIndex: reactData.collapseZindex
            } : {};
          }
        });
      }
    };
    const handleCollapseMenu = () => {
      const { collapseFixed } = props;
      if (collapseFixed) {
        const { initialized } = reactData;
        const isCollapsed = computeIsCollapsed.value;
        if (isCollapsed) {
          if (!initialized) {
            reactData.initialized = true;
            nextTick(() => {
              const collapseEl = refCollapseElem.value;
              if (collapseEl) {
                document.body.appendChild(collapseEl);
              }
            });
          }
        }
        reactData.isEnterCollapse = false;
        updateZindex();
        updateCollapseStyle();
      }
    };
    const handleClickIconCollapse = (evnt, item) => {
      const { hasChild, isExpand } = item;
      if (hasChild) {
        evnt.stopPropagation();
        evnt.preventDefault();
        item.isExpand = !isExpand;
      }
    };
    const emitModel = (value) => {
      reactData.activeName = value;
      emit("update:modelValue", value);
    };
    const handleClickMenu = (evnt, item) => {
      const { itemKey, routerLink, hasChild } = item;
      if (routerLink) {
        emitModel(itemKey);
        handleMenuMouseleave();
      } else {
        if (hasChild) {
          handleClickIconCollapse(evnt, item);
        } else {
          emitModel(itemKey);
          handleMenuMouseleave();
        }
      }
      dispatchEvent2("click", { menu: item }, evnt);
    };
    const handleMenuMouseenter = () => {
      const { collapseStyle } = reactData;
      const collapseEnterWidth = computeCollapseEnterWidth.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: collapseEnterWidth ? toCssUnit(collapseEnterWidth) : ""
      });
      reactData.isEnterCollapse = true;
    };
    const handleMenuMouseleave = () => {
      const { collapseStyle } = reactData;
      const el2 = refElem.value;
      reactData.collapseStyle = Object.assign({}, collapseStyle, {
        width: el2 ? toCssUnit(el2.offsetWidth) : ""
      });
      reactData.isEnterCollapse = false;
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $menu: $xeMenu }, params));
    };
    const menuMethods = {
      dispatchEvent: dispatchEvent2
    };
    const menuPrivateMethods = {};
    Object.assign($xeMenu, menuMethods, menuPrivateMethods);
    const renderMenuTitle = (item) => {
      const { icon, isExpand, hasChild } = item;
      const title = getMenuTitle(item);
      return [
        h("span", {
          class: "vxe-menu--item-link-icon"
        }, icon ? [
          h("i", {
            class: icon
          })
        ] : []),
        h("span", {
          class: "vxe-menu--item-link-title",
          title
        }, title),
        hasChild ? h("span", {
          class: "vxe-menu--item-link-collapse",
          onClick(evnt) {
            handleClickIconCollapse(evnt, item);
          }
        }, [
          h("i", {
            class: isExpand ? getIcon().MENU_ITEM_EXPAND_OPEN : getIcon().MENU_ITEM_EXPAND_CLOSE
          })
        ]) : createCommentVNode()
      ];
    };
    const renderDefaultChildren = (item) => {
      const { itemKey, level, hasChild, isActive, isExactActive, isExpand, routerLink, childList } = item;
      const { isEnterCollapse } = reactData;
      const isCollapsed = computeIsCollapsed.value;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return createCommentVNode();
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive,
          "is--expand": (!isCollapsed || isEnterCollapse) && isExpand
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, {
          default: () => renderMenuTitle(item)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, renderMenuTitle(item)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group"
        }, childList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
      ]);
    };
    const renderCollapseChildren = (item) => {
      const { itemKey, level, hasChild, isActive, isExactActive, routerLink, childList } = item;
      if (item.permissionCode) {
        if (!permission.checkVisible(item.permissionCode)) {
          return createCommentVNode();
        }
      }
      return h("div", {
        key: itemKey,
        class: ["vxe-menu--item-wrapper", `vxe-menu--item-level${level}`, {
          "is--exact-active": isExactActive,
          "is--active": isActive
        }]
      }, [
        routerLink ? h(resolveComponent("router-link"), {
          class: "vxe-menu--item-link",
          to: routerLink,
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, {
          default: () => renderMenuTitle(item)
        }) : h("div", {
          class: "vxe-menu--item-link",
          onClick(evnt) {
            handleClickMenu(evnt, item);
          }
        }, renderMenuTitle(item)),
        hasChild ? h("div", {
          class: "vxe-menu--item-group"
        }, childList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
      ]);
    };
    const renderVN = () => {
      const { loading: loading2 } = props;
      const { initialized, menuList, collapseStyle, isEnterCollapse } = reactData;
      const vSize = computeSize.value;
      const isCollapsed = computeIsCollapsed.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-menu", {
          [`size--${vSize}`]: vSize,
          "is--collapsed": isCollapsed,
          "is--loading": loading2
        }]
      }, [
        h("div", {
          class: "vxe-menu--item-list"
        }, menuList.map((child) => isCollapsed ? renderCollapseChildren(child) : renderDefaultChildren(child))),
        initialized ? h("div", {
          ref: refCollapseElem,
          class: ["vxe-menu--collapse-wrapper", {
            [`size--${vSize}`]: vSize,
            "is--collapsed": isCollapsed,
            "is--enter": isEnterCollapse,
            "is--loading": loading2
          }],
          style: collapseStyle,
          onMouseenter: handleMenuMouseenter,
          onMouseleave: handleMenuMouseleave
        }, [
          isCollapsed ? h("div", {
            class: "vxe-menu--item-list"
          }, menuList.map((child) => renderDefaultChildren(child))) : createCommentVNode()
        ]) : createCommentVNode(),
        /**
         * 加载中
         */
        h(loading_default, {
          class: "vxe-list-view--loading",
          modelValue: loading2
        })
      ]);
    };
    const optFlag = ref(0);
    watch(() => props.options ? props.options.length : -1, () => {
      optFlag.value++;
    });
    watch(() => props.options, () => {
      optFlag.value++;
    });
    watch(optFlag, () => {
      updateMenuConfig();
      updateActiveMenu(true);
    });
    watch(() => props.modelValue, (val) => {
      reactData.activeName = val;
    });
    watch(() => reactData.activeName, () => {
      updateActiveMenu(true);
    });
    watch(computeIsCollapsed, () => {
      handleCollapseMenu();
    });
    onMounted(() => {
      globalEvents.on($xeMenu, "resize", updateCollapseStyle);
      updateCollapseStyle();
    });
    onBeforeUnmount(() => {
      globalEvents.off($xeMenu, "resize");
      const collapseEl = refCollapseElem.value;
      if (collapseEl) {
        const parentNode = collapseEl.parentNode;
        if (parentNode) {
          parentNode.removeChild(collapseEl);
        }
      }
    });
    updateMenuConfig();
    updateActiveMenu(true);
    $xeMenu.renderVN = renderVN;
    return $xeMenu;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/menu/index.js
var VxeMenu = Object.assign({}, menu_default, {
  install(app) {
    app.component(menu_default.name, menu_default);
  }
});
dynamicApp.use(VxeMenu);
VxeUI.component(menu_default);
var Menu = VxeMenu;
var menu_default2 = VxeMenu;

// node_modules/vxe-pc-ui/es/modal/index.js
var import_xe_utils139 = __toESM(require_xe_utils());
function handleModal(options) {
  checkDynamic();
  return new Promise((resolve) => {
    const opts = Object.assign({}, options);
    if (opts.id && allActiveModals.some((comp) => comp.props.id === opts.id)) {
      resolve("exist");
    } else {
      const _onHide = opts.onHide;
      const modalOpts = Object.assign(opts, {
        key: import_xe_utils139.default.uniqueId(),
        modelValue: true,
        onHide(params) {
          const modalList = dynamicStore.modals;
          if (_onHide) {
            _onHide(params);
          }
          dynamicStore.modals = modalList.filter((item) => item.key !== modalOpts.key);
          resolve(params.type);
        }
      });
      dynamicStore.modals.push(modalOpts);
    }
  });
}
function getModal(id2) {
  return import_xe_utils139.default.find(allActiveModals, ($modal) => $modal.props.id === id2);
}
function closeModal(id2) {
  const modals = id2 ? [getModal(id2)] : allActiveModals;
  const restPromises = [];
  modals.forEach(($modal) => {
    if ($modal) {
      restPromises.push($modal.close());
    }
  });
  return Promise.all(restPromises);
}
function handleOpen(defOpts, content, title, options) {
  let opts;
  if (import_xe_utils139.default.isObject(content)) {
    opts = content;
  } else {
    opts = { content: import_xe_utils139.default.toValueString(content), title };
  }
  return handleModal(Object.assign(Object.assign(Object.assign({}, defOpts), options), opts));
}
function openModal(options) {
  return handleOpen({
    type: "modal"
  }, options);
}
function openAlert(content, title, options) {
  return handleOpen({
    type: "alert",
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openConfirm(content, title, options) {
  return handleOpen({
    type: "confirm",
    status: "question",
    lockScroll: true,
    showHeader: true,
    showFooter: true
  }, content, title, options);
}
function openMessage(content, options) {
  return handleOpen({
    type: "message",
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: false
  }, content, "", options);
}
function openNotification(content, title, options) {
  return handleOpen({
    type: "notification",
    mask: false,
    lockView: false,
    lockScroll: false,
    showHeader: true,
    draggable: false,
    position: "top-right",
    width: 320
  }, content, title, options);
}
var ModalController = {
  get: getModal,
  close: closeModal,
  open: openModal,
  alert: openAlert,
  confirm: openConfirm,
  message: openMessage,
  notification: openNotification
};
var VxeModal = Object.assign(modal_default, {
  install: function(app) {
    app.component(modal_default.name, modal_default);
  }
});
VxeUI.modal = ModalController;
dynamicApp.use(VxeModal);
VxeUI.component(modal_default);
var Modal = VxeModal;
var modal_default2 = VxeModal;

// node_modules/vxe-pc-ui/es/notice-bar/src/notice-bar.js
var import_xe_utils140 = __toESM(require_xe_utils());
var notice_bar_default = defineComponent({
  name: "VxeNoticeBar",
  props: {
    duration: [String, Number],
    direction: {
      type: String,
      default: () => getConfig().noticeBar.direction
    },
    speed: {
      type: String,
      default: () => getConfig().noticeBar.speed
    },
    content: String,
    vertical: Boolean,
    loop: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => getConfig().noticeBar.size || getConfig().size
    }
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils140.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refContentElem = ref();
    const reactData = reactive({
      animationDuration: 0
    });
    const refMaps = {
      refElem
    };
    const computeNoticeText = computed(() => {
      const { content } = props;
      return `${content || ""}`;
    });
    const computeMaps = {};
    const $xeNoticeBar = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $noticeBar: $xeNoticeBar }, params));
    };
    const noticeBarMethods = {
      dispatchEvent: dispatchEvent2
    };
    const noticeBarPrivateMethods = {};
    const updateAnimationStyle = () => {
      const { speed } = props;
      const contEl = refContentElem.value;
      if (contEl) {
        let sRate = 46;
        if (speed === "fast") {
          sRate = 118;
        } else if (speed === "slow") {
          sRate = 18;
        }
        reactData.animationDuration = Math.ceil(contEl.scrollWidth / sRate);
      }
    };
    Object.assign($xeNoticeBar, noticeBarMethods, noticeBarPrivateMethods);
    const renderVN = () => {
      const { vertical, duration, direction } = props;
      const { animationDuration } = reactData;
      const vSize = computeSize.value;
      const noticeText = computeNoticeText.value;
      const defaultSlot = slots.default;
      const prefixSlot = slots.prefix;
      const suffixSlot = slots.suffix;
      return h("div", {
        ref: refElem,
        class: ["vxe-notice-bar", `is--${vertical ? "vertical" : "horizontal"}`, `dir--${direction || "left"}`, {
          [`size--${vSize}`]: vSize
        }]
      }, [
        prefixSlot ? h("div", {
          class: "vxe-notice-bar--prefix"
        }, prefixSlot({})) : renderEmptyElement($xeNoticeBar),
        h("div", {
          class: "vxe-notice-bar--content"
        }, [
          h("div", {
            ref: refContentElem,
            class: "vxe-notice-bar--inner"
          }, [
            h("div", {
              class: "vxe-notice-bar--wrapper",
              style: {
                animationDuration: `${duration ? toCssUnit(duration, "s") : animationDuration}s`
              }
            }, defaultSlot ? defaultSlot({}) : noticeText)
          ])
        ]),
        suffixSlot ? h("div", {
          class: "vxe-notice-bar--suffix"
        }, suffixSlot({})) : renderEmptyElement($xeNoticeBar)
      ]);
    };
    $xeNoticeBar.renderVN = renderVN;
    onMounted(() => {
      globalEvents.on($xeNoticeBar, "resize", updateAnimationStyle);
      updateAnimationStyle();
    });
    onBeforeUnmount(() => {
      globalEvents.off($xeNoticeBar, "resize");
    });
    return $xeNoticeBar;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/notice-bar/index.js
var VxeNoticeBar = Object.assign({}, notice_bar_default, {
  install(app) {
    app.component(notice_bar_default.name, notice_bar_default);
  }
});
dynamicApp.use(VxeNoticeBar);
VxeUI.component(notice_bar_default);
var NoticeBar = VxeNoticeBar;
var notice_bar_default2 = VxeNoticeBar;

// node_modules/vxe-pc-ui/es/number-input/index.js
var VxeNumberInput = Object.assign({}, number_input_default, {
  install(app) {
    app.component(number_input_default.name, number_input_default);
  }
});
dynamicApp.use(VxeNumberInput);
VxeUI.component(number_input_default);
var NumberInput = VxeNumberInput;
var number_input_default2 = VxeNumberInput;

// node_modules/vxe-pc-ui/es/select/src/util.js
var import_xe_utils142 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/select/src/option-info.js
var import_xe_utils141 = __toESM(require_xe_utils());
var OptionInfo = class {
  constructor($xeselect, _vm) {
    Object.assign(this, {
      id: import_xe_utils141.default.uniqueId("option_"),
      value: _vm.value,
      label: _vm.label,
      visible: _vm.visible,
      className: _vm.className,
      disabled: _vm.disabled
    });
  }
  update(name, value) {
    this[name] = value;
  }
};

// node_modules/vxe-pc-ui/es/select/src/util.js
function isOption(option2) {
  return option2 instanceof OptionInfo;
}
function createOption($xeSelect, _vm) {
  return isOption(_vm) ? _vm : new OptionInfo($xeSelect, _vm);
}
function watchOption(props, option2) {
  Object.keys(props).forEach((name) => {
    watch(() => props[name], (value) => {
      option2.update(name, value);
    });
  });
}
function assembleOption($xeSelect, el2, option2, $xeOptgroup) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const parentElem = el2.parentNode;
  const parentOption = $xeOptgroup ? $xeOptgroup.optionConfig : null;
  const parentCols = parentOption ? parentOption.options : staticOptions;
  if (parentElem && parentCols) {
    parentCols.splice(import_xe_utils142.default.arrayIndexOf(parentElem.children, el2), 0, option2);
    reactData.staticOptions = staticOptions.slice(0);
  }
}
function destroyOption($xeSelect, option2) {
  const { reactData } = $xeSelect;
  const { staticOptions } = reactData;
  const matchObj = import_xe_utils142.default.findTree(staticOptions, (item) => item.id === option2.id, { children: "options" });
  if (matchObj) {
    matchObj.items.splice(matchObj.index, 1);
  }
  reactData.staticOptions = staticOptions.slice(0);
}

// node_modules/vxe-pc-ui/es/select/src/optgroup.js
var optgroup_default = defineComponent({
  name: "VxeOptgroup",
  props: {
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const optionConfig = createOption($xeSelect, props);
    const $xeOptgroup = { optionConfig };
    optionConfig.options = [];
    provide("$xeOptgroup", $xeOptgroup);
    watchOption(props, optionConfig);
    onMounted(() => {
      const el2 = elem.value;
      assembleOption($xeSelect, el2, optionConfig);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      const defaultSlot = slots.default;
      return h("div", {
        ref: elem
      }, defaultSlot ? defaultSlot({}) : []);
    };
  }
});

// node_modules/vxe-pc-ui/es/optgroup/index.js
var VxeOptgroup = Object.assign(optgroup_default, {
  install: function(app) {
    app.component(optgroup_default.name, optgroup_default);
  }
});
dynamicApp.use(VxeOptgroup);
VxeUI.component(optgroup_default);
var Optgroup = VxeOptgroup;
var optgroup_default2 = VxeOptgroup;

// node_modules/vxe-pc-ui/es/select/src/option.js
var option_default = defineComponent({
  name: "VxeOption",
  props: {
    value: [String, Number, Boolean],
    label: {
      type: [String, Number, Boolean],
      default: ""
    },
    visible: {
      type: Boolean,
      default: null
    },
    className: [String, Function],
    disabled: Boolean
  },
  emits: [],
  setup(props, { slots }) {
    const elem = ref();
    const $xeSelect = inject("$xeSelect", {});
    const $xeOptgroup = inject("$xeOptgroup", null);
    const optionConfig = createOption($xeSelect, props);
    optionConfig.slots = slots;
    watchOption(props, optionConfig);
    onMounted(() => {
      const el2 = elem.value;
      assembleOption($xeSelect, el2, optionConfig, $xeOptgroup);
    });
    onUnmounted(() => {
      destroyOption($xeSelect, optionConfig);
    });
    return () => {
      return h("div", {
        ref: elem
      });
    };
  }
});

// node_modules/vxe-pc-ui/es/option/index.js
var VxeOption = Object.assign(option_default, {
  install: function(app) {
    app.component(option_default.name, option_default);
  }
});
dynamicApp.use(VxeOption);
VxeUI.component(option_default);
var Option2 = VxeOption;
var option_default2 = VxeOption;

// node_modules/vxe-pc-ui/es/pager/src/pager.js
var import_xe_utils143 = __toESM(require_xe_utils());
var pager_default = defineComponent({
  name: "VxePager",
  props: {
    size: {
      type: String,
      default: () => getConfig().pager.size || getConfig().size
    },
    // 自定义布局
    layouts: {
      type: Array,
      default: () => getConfig().pager.layouts || ["PrevJump", "PrevPage", "Jump", "PageCount", "NextPage", "NextJump", "Sizes", "Total"]
    },
    // 当前页
    currentPage: {
      type: Number,
      default: 1
    },
    // 加载中
    loading: Boolean,
    // 每页大小
    pageSize: {
      type: Number,
      default: () => getConfig().pager.pageSize || 10
    },
    // 总条数
    total: { type: Number, default: 0 },
    // 显示页码按钮的数量
    pagerCount: {
      type: Number,
      default: () => getConfig().pager.pagerCount || 7
    },
    // 每页大小选项列表
    pageSizes: {
      type: Array,
      default: () => getConfig().pager.pageSizes || [10, 15, 20, 50, 100]
    },
    // 列对其方式
    align: {
      type: String,
      default: () => getConfig().pager.align
    },
    // 带边框
    border: {
      type: Boolean,
      default: () => getConfig().pager.border
    },
    // 带背景颜色
    background: {
      type: Boolean,
      default: () => getConfig().pager.background
    },
    // 配套的样式
    perfect: {
      type: Boolean,
      default: () => getConfig().pager.perfect
    },
    // 当只有一页时隐藏
    autoHidden: {
      type: Boolean,
      default: () => getConfig().pager.autoHidden
    },
    transfer: {
      type: Boolean,
      default: () => getConfig().pager.transfer
    },
    className: [String, Function],
    pageSizePlacement: {
      type: String,
      default: () => getConfig().pager.pageSizePlacement
    },
    // 自定义图标
    iconPrevPage: String,
    iconJumpPrev: String,
    iconJumpNext: String,
    iconNextPage: String,
    iconJumpMore: String,
    iconHomePage: String,
    iconEndPage: String
  },
  emits: [
    "update:pageSize",
    "update:currentPage",
    "page-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils143.default.uniqueId();
    const { computeSize } = useSize(props);
    const $xeGrid = inject("$xeGrid", null);
    const reactData = reactive({
      inpCurrPage: props.currentPage
    });
    const refElem = ref();
    const refMaps = {
      refElem
    };
    const computePageCount = computed(() => {
      return getPageCount(props.total, props.pageSize);
    });
    const computeNumList = computed(() => {
      const { pagerCount } = props;
      const pageCount = computePageCount.value;
      const len = pageCount > pagerCount ? pagerCount - 2 : pagerCount;
      const rest = [];
      for (let index2 = 0; index2 < len; index2++) {
        rest.push(index2);
      }
      return rest;
    });
    const computeOffsetNumber = computed(() => {
      return Math.floor((props.pagerCount - 2) / 2);
    });
    const computeSizeList = computed(() => {
      return props.pageSizes.map((item) => {
        if (import_xe_utils143.default.isNumber(item)) {
          return {
            value: item,
            label: `${getI18n("vxe.pager.pagesize", [item])}`
          };
        }
        return Object.assign({ value: "", label: "" }, item);
      });
    });
    const $xePager = {
      xID,
      props,
      context,
      getRefMaps: () => refMaps
    };
    let pagerMethods = {};
    let pagerPrivateMethods = {};
    const getPageCount = (total, size) => {
      return Math.max(Math.ceil(total / size), 1);
    };
    const jumpPageEvent = (evnt, currentPage) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const changeCurrentPage = (currentPage, evnt) => {
      emit("update:currentPage", currentPage);
      if (evnt && currentPage !== props.currentPage) {
        pagerMethods.dispatchEvent("page-change", { type: "current", pageSize: props.pageSize, currentPage }, evnt);
      }
    };
    const triggerJumpEvent = (params) => {
      const { $event } = params;
      const inputElem = $event.target;
      const inpValue = import_xe_utils143.default.toInteger(inputElem.value);
      const pageCount = computePageCount.value;
      const current = inpValue <= 0 ? 1 : inpValue >= pageCount ? pageCount : inpValue;
      const currPage = import_xe_utils143.default.toValueString(current);
      inputElem.value = currPage;
      reactData.inpCurrPage = currPage;
      changeCurrentPage(current, $event);
    };
    const handleHomePage = (evnt) => {
      const { currentPage } = props;
      if (currentPage > 1) {
        changeCurrentPage(1, evnt);
      }
    };
    const handleEndPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(pageCount, evnt);
      }
    };
    const handlePrevPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage > 1) {
        changeCurrentPage(Math.min(pageCount, Math.max(currentPage - 1, 1)), evnt);
      }
    };
    const handleNextPage = (evnt) => {
      const { currentPage } = props;
      const pageCount = computePageCount.value;
      if (currentPage < pageCount) {
        changeCurrentPage(Math.min(pageCount, currentPage + 1), evnt);
      }
    };
    const handlePrevJump = (evnt) => {
      const numList = computeNumList.value;
      changeCurrentPage(Math.max(props.currentPage - numList.length, 1), evnt);
    };
    const handleNextJump = (evnt) => {
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      changeCurrentPage(Math.min(props.currentPage + numList.length, pageCount), evnt);
    };
    const pageSizeEvent = (params) => {
      const { value } = params;
      const pageSize = import_xe_utils143.default.toNumber(value);
      const pageCount = getPageCount(props.total, pageSize);
      let currentPage = props.currentPage;
      if (currentPage > pageCount) {
        currentPage = pageCount;
        emit("update:currentPage", pageCount);
      }
      emit("update:pageSize", pageSize);
      pagerMethods.dispatchEvent("page-change", { type: "size", pageSize, currentPage }, params.$event);
    };
    const jumpKeydownEvent = (params) => {
      const { $event } = params;
      if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ENTER)) {
        triggerJumpEvent(params);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_UP)) {
        $event.preventDefault();
        handleNextPage($event);
      } else if (globalEvents.hasKey($event, GLOBAL_EVENT_KEYS.ARROW_DOWN)) {
        $event.preventDefault();
        handlePrevPage($event);
      }
    };
    const renderHomePage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.homePageTitle"),
        onClick: handleHomePage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconHomePage || getIcon().PAGER_HOME]
        })
      ]);
    };
    const renderPrevPage = () => {
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.prevPageTitle"),
        onClick: handlePrevPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconPrevPage || getIcon().PAGER_PREV_PAGE]
        })
      ]);
    };
    const renderPrevJump = (tagName) => {
      return h(tagName || "button", {
        class: ["vxe-pager--jump-prev", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage <= 1
        }],
        type: "button",
        title: getI18n("vxe.pager.prevJumpTitle"),
        onClick: handlePrevJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpPrev || getIcon().PAGER_JUMP_PREV]
        })
      ]);
    };
    const renderNextJump = (tagName) => {
      const pageCount = computePageCount.value;
      return h(tagName || "button", {
        class: ["vxe-pager--jump-next", {
          "is--fixed": !tagName,
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.nextJumpTitle"),
        onClick: handleNextJump
      }, [
        tagName ? h("i", {
          class: ["vxe-pager--jump-more-icon", props.iconJumpMore || getIcon().PAGER_JUMP_MORE]
        }) : null,
        h("i", {
          class: ["vxe-pager--jump-icon", props.iconJumpNext || getIcon().PAGER_JUMP_NEXT]
        })
      ]);
    };
    const renderNextPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--next-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.nextPageTitle"),
        onClick: handleNextPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconNextPage || getIcon().PAGER_NEXT_PAGE]
        })
      ]);
    };
    const renderEndPage = () => {
      const pageCount = computePageCount.value;
      return h("button", {
        class: ["vxe-pager--prev-btn", {
          "is--disabled": props.currentPage >= pageCount
        }],
        type: "button",
        title: getI18n("vxe.pager.endPageTitle"),
        onClick: handleEndPage
      }, [
        h("i", {
          class: ["vxe-pager--btn-icon", props.iconEndPage || getIcon().PAGER_END]
        })
      ]);
    };
    const renderNumber = (showJump) => {
      const { currentPage, pagerCount } = props;
      const nums = [];
      const pageCount = computePageCount.value;
      const numList = computeNumList.value;
      const offsetNumber = computeOffsetNumber.value;
      const isOv = pageCount > pagerCount;
      const isLt = isOv && currentPage > offsetNumber + 1;
      const isGt = isOv && currentPage < pageCount - offsetNumber;
      let startNumber = 1;
      if (isOv) {
        if (currentPage >= pageCount - offsetNumber) {
          startNumber = Math.max(pageCount - numList.length + 1, 1);
        } else {
          startNumber = Math.max(currentPage - offsetNumber, 1);
        }
      }
      if (showJump && isLt) {
        nums.push(h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, 1)
        }, "1"), renderPrevJump("span"));
      }
      numList.forEach((item, index2) => {
        const number2 = startNumber + index2;
        if (number2 <= pageCount) {
          nums.push(h("button", {
            key: number2,
            class: ["vxe-pager--num-btn", {
              "is--active": currentPage === number2
            }],
            type: "button",
            onClick: (evnt) => jumpPageEvent(evnt, number2)
          }, `${number2}`));
        }
      });
      if (showJump && isGt) {
        nums.push(renderNextJump("button"), h("button", {
          class: "vxe-pager--num-btn",
          type: "button",
          onClick: (evnt) => jumpPageEvent(evnt, pageCount)
        }, pageCount));
      }
      return h("span", {
        class: "vxe-pager--btn-wrapper"
      }, nums);
    };
    const renderJumpNumber = () => {
      return renderNumber(true);
    };
    const renderSizes = () => {
      const sizeList = computeSizeList.value;
      return h(select_default, {
        class: "vxe-pager--sizes",
        modelValue: props.pageSize,
        placement: props.pageSizePlacement,
        transfer: props.transfer,
        options: sizeList,
        onChange: pageSizeEvent
      });
    };
    const renderJump = (isFull) => {
      const pageCount = computePageCount.value;
      return h("span", {
        class: "vxe-pager--jump"
      }, [
        isFull ? h("span", {
          class: "vxe-pager--goto-text"
        }, getI18n("vxe.pager.goto")) : null,
        h(input_default, {
          class: "vxe-pager--goto",
          modelValue: reactData.inpCurrPage,
          placeholder: getI18n("vxe.pager.gotoTitle"),
          align: "center",
          type: "integer",
          max: pageCount,
          min: 1,
          controls: false,
          onKeydown: jumpKeydownEvent,
          onBlur: triggerJumpEvent,
          "onUpdate:modelValue"(val) {
            reactData.inpCurrPage = val;
          }
        }),
        isFull ? h("span", {
          class: "vxe-pager--classifier-text"
        }, getI18n("vxe.pager.pageClassifier")) : null
      ]);
    };
    const renderFullJump = () => {
      return renderJump(true);
    };
    const renderPageCount = () => {
      const pageCount = computePageCount.value;
      return h("span", {
        class: "vxe-pager--count"
      }, [
        h("span", {
          class: "vxe-pager--separator"
        }),
        h("span", pageCount)
      ]);
    };
    const renderTotal = () => {
      return h("span", {
        class: "vxe-pager--total"
      }, getI18n("vxe.pager.total", [props.total]));
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $pager: $xePager }, params));
    };
    pagerMethods = {
      dispatchEvent: dispatchEvent2,
      homePage() {
        handleHomePage();
        return nextTick();
      },
      endPage() {
        handleEndPage();
        return nextTick();
      },
      prevPage() {
        handlePrevPage();
        return nextTick();
      },
      nextPage() {
        handleNextPage();
        return nextTick();
      },
      prevJump() {
        handlePrevJump();
        return nextTick();
      },
      nextJump() {
        handleNextJump();
        return nextTick();
      }
    };
    pagerPrivateMethods = {
      handlePrevPage,
      handleNextPage,
      handlePrevJump,
      handleNextJump
    };
    Object.assign($xePager, pagerMethods, pagerPrivateMethods);
    watch(() => props.currentPage, (value) => {
      reactData.inpCurrPage = value;
    });
    const renderVN = () => {
      const { align, layouts, className } = props;
      const childNodes = [];
      const vSize = computeSize.value;
      const pageCount = computePageCount.value;
      if (slots.left) {
        childNodes.push(h("span", {
          class: "vxe-pager--left-wrapper"
        }, slots.left({ $grid: $xeGrid })));
      }
      layouts.forEach((name) => {
        let renderFn;
        switch (name) {
          case "Home":
            renderFn = renderHomePage;
            break;
          case "PrevJump":
            renderFn = renderPrevJump;
            break;
          case "PrevPage":
            renderFn = renderPrevPage;
            break;
          case "Number":
            renderFn = renderNumber;
            break;
          case "JumpNumber":
            renderFn = renderJumpNumber;
            break;
          case "NextPage":
            renderFn = renderNextPage;
            break;
          case "NextJump":
            renderFn = renderNextJump;
            break;
          case "End":
            renderFn = renderEndPage;
            break;
          case "Sizes":
            renderFn = renderSizes;
            break;
          case "FullJump":
            renderFn = renderFullJump;
            break;
          case "Jump":
            renderFn = renderJump;
            break;
          case "PageCount":
            renderFn = renderPageCount;
            break;
          case "Total":
            renderFn = renderTotal;
            break;
        }
        if (renderFn) {
          childNodes.push(renderFn());
        } else {
          if (true) {
            errLog2("vxe.error.notProp", [`layouts -> ${name}`]);
          }
        }
      });
      if (slots.right) {
        childNodes.push(h("span", {
          class: "vxe-pager--right-wrapper"
        }, slots.right({ $grid: $xeGrid })));
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-pager", className ? import_xe_utils143.default.isFunction(className) ? className({ $pager: $xePager }) : className : "", {
          [`size--${vSize}`]: vSize,
          [`align--${align}`]: align,
          "is--border": props.border,
          "is--background": props.background,
          "is--perfect": props.perfect,
          "is--hidden": props.autoHidden && pageCount === 1,
          "is--loading": props.loading
        }]
      }, [
        h("div", {
          class: "vxe-pager--wrapper"
        }, childNodes)
      ]);
    };
    $xePager.renderVN = renderVN;
    return $xePager;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/pager/index.js
var VxePager = Object.assign(pager_default, {
  install: function(app) {
    app.component(pager_default.name, pager_default);
  }
});
dynamicApp.use(VxePager);
VxeUI.component(pager_default);
var Pager = VxePager;
var pager_default2 = VxePager;

// node_modules/vxe-pc-ui/es/password-input/src/password-input.js
var import_xe_utils144 = __toESM(require_xe_utils());
var password_input_default = defineComponent({
  name: "VxePasswordInput",
  props: {
    modelValue: String,
    immediate: {
      type: Boolean,
      default: true
    },
    name: String,
    clearable: {
      type: Boolean,
      default: () => getConfig().passwordInput.clearable
    },
    readonly: Boolean,
    disabled: Boolean,
    maxLength: [String, Number],
    placeholder: String,
    autoComplete: {
      type: String,
      default: "off"
    },
    className: String,
    size: {
      type: String,
      default: () => getConfig().passwordInput.size || getConfig().size
    },
    prefixIcon: String,
    suffixIcon: String,
    controls: {
      type: Boolean,
      default: () => getConfig().passwordInput.controls
    },
    // 已废弃
    autocomplete: String
  },
  emits: [
    "update:modelValue",
    "input",
    "change",
    "click",
    "focus",
    "blur",
    "clear",
    "toggle-visible",
    "prefix-click",
    "suffix-click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils144.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      showPwd: false,
      isActivated: false,
      inputValue: props.modelValue
    });
    const refElem = ref();
    const refInputTarget = ref();
    const refMaps = {
      refElem,
      refInput: refInputTarget
    };
    const $xePasswordInput = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps
    };
    let passwordInputMethods = {};
    const computeIsClearable = computed(() => {
      return props.clearable;
    });
    const computeInpReadonly = computed(() => {
      const { readonly } = props;
      return readonly;
    });
    const computeInpPlaceholder = computed(() => {
      const { placeholder } = props;
      if (placeholder) {
        return getFuncText2(placeholder);
      }
      const globalPlaceholder = getConfig().passwordInput.placeholder;
      if (globalPlaceholder) {
        return getFuncText2(globalPlaceholder);
      }
      return getI18n("vxe.base.pleaseInput");
    });
    const computeInputType = computed(() => {
      const { showPwd } = reactData;
      if (showPwd) {
        return "text";
      }
      return "password";
    });
    const computeInpImmediate = computed(() => {
      const { immediate } = props;
      return immediate;
    });
    const triggerEvent3 = (evnt) => {
      const { inputValue } = reactData;
      passwordInputMethods.dispatchEvent(evnt.type, { value: inputValue }, evnt);
    };
    const emitInputEvent = (value, evnt) => {
      const inpImmediate = computeInpImmediate.value;
      reactData.inputValue = value;
      if (inpImmediate) {
        handleChange(value, evnt);
      } else {
        passwordInputMethods.dispatchEvent("input", { value }, evnt);
      }
    };
    const inputEvent = (evnt) => {
      const inputElem = evnt.target;
      const value = inputElem.value;
      emitInputEvent(value, evnt);
    };
    const handleChange = (value, evnt) => {
      reactData.inputValue = value;
      emit("update:modelValue", value);
      passwordInputMethods.dispatchEvent("input", { value }, evnt);
      if (import_xe_utils144.default.toValueString(props.modelValue) !== value) {
        passwordInputMethods.dispatchEvent("change", { value }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
        }
      }
    };
    const changeEvent = (evnt) => {
      triggerEvent3(evnt);
      const { inputValue } = reactData;
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, inputValue);
      }
    };
    const focusEvent = (evnt) => {
      reactData.isActivated = true;
      triggerEvent3(evnt);
    };
    const blurEvent = (evnt) => {
      const { inputValue } = reactData;
      const value = inputValue;
      passwordInputMethods.dispatchEvent("blur", { value }, evnt);
      if ($xeForm && formItemInfo) {
        $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, value);
      }
    };
    const passwordToggleEvent = (evnt) => {
      const { readonly, disabled } = props;
      const { showPwd } = reactData;
      if (!disabled && !readonly) {
        reactData.showPwd = !showPwd;
      }
      passwordInputMethods.dispatchEvent("toggle-visible", { visible: reactData.showPwd }, evnt);
    };
    const clickEvent = (evnt) => {
      triggerEvent3(evnt);
    };
    const clearValueEvent = (evnt, value) => {
      focus();
      handleChange("", evnt);
      passwordInputMethods.dispatchEvent("clear", { value }, evnt);
    };
    const clickSuffixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        passwordInputMethods.dispatchEvent("suffix-click", { value: inputValue }, evnt);
      }
    };
    const clickPrefixEvent = (evnt) => {
      const { disabled } = props;
      if (!disabled) {
        const { inputValue } = reactData;
        passwordInputMethods.dispatchEvent("prefix-click", { value: inputValue }, evnt);
      }
    };
    const renderPasswordIcon = () => {
      const { showPwd } = reactData;
      return h("div", {
        class: "vxe-password-input--control-icon",
        onClick: passwordToggleEvent
      }, [
        h("i", {
          class: ["vxe-password-input--password-icon", showPwd ? getIcon().PASSWORD_INPUT_SHOW_PWD : getIcon().PASSWORD_INPUT_HIDE_PWD]
        })
      ]);
    };
    const renderPrefixIcon2 = () => {
      const { prefixIcon } = props;
      const prefixSlot = slots.prefix;
      return prefixSlot || prefixIcon ? h("div", {
        class: "vxe-password-input--prefix",
        onClick: clickPrefixEvent
      }, [
        h("div", {
          class: "vxe-password-input--prefix-icon"
        }, prefixSlot ? getSlotVNs2(prefixSlot({})) : [
          h("i", {
            class: prefixIcon
          })
        ])
      ]) : null;
    };
    const renderSuffixIcon2 = () => {
      const { disabled, suffixIcon, controls } = props;
      const { inputValue } = reactData;
      const suffixSlot = slots.suffix;
      const isClearable = computeIsClearable.value;
      return isClearable || controls || suffixSlot || suffixIcon ? h("div", {
        class: ["vxe-password-input--suffix", {
          "is--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils144.default.eqNull(inputValue))
        }]
      }, [
        isClearable ? h("div", {
          class: "vxe-password-input--clear-icon",
          onClick: clearValueEvent
        }, [
          h("i", {
            class: getIcon().INPUT_CLEAR
          })
        ]) : createCommentVNode(),
        controls ? renderPasswordIcon() : createCommentVNode(),
        suffixSlot || suffixIcon ? h("div", {
          class: "vxe-password-input--suffix-icon",
          onClick: clickSuffixEvent
        }, suffixSlot ? getSlotVNs2(suffixSlot({})) : [
          h("i", {
            class: suffixIcon
          })
        ]) : createCommentVNode()
      ]) : null;
    };
    passwordInputMethods = {
      dispatchEvent(type, params, evnt) {
        emit(type, createEvent(evnt, { $passwordInput: $xePasswordInput }, params));
      },
      focus() {
        const inputElem = refInputTarget.value;
        reactData.isActivated = true;
        inputElem.focus();
        return nextTick();
      },
      blur() {
        const inputElem = refInputTarget.value;
        inputElem.blur();
        reactData.isActivated = false;
        return nextTick();
      },
      select() {
        const inputElem = refInputTarget.value;
        inputElem.select();
        reactData.isActivated = false;
        return nextTick();
      }
    };
    Object.assign($xePasswordInput, passwordInputMethods);
    watch(() => props.modelValue, (val) => {
      reactData.inputValue = val;
    });
    const renderVN = () => {
      const { className, name, disabled, readonly, autocomplete, autoComplete, maxLength } = props;
      const { inputValue, isActivated } = reactData;
      const vSize = computeSize.value;
      const inpReadonly = computeInpReadonly.value;
      const inputType = computeInputType.value;
      const inpPlaceholder = computeInpPlaceholder.value;
      const isClearable = computeIsClearable.value;
      const prefix = renderPrefixIcon2();
      const suffix = renderSuffixIcon2();
      return h("div", {
        ref: refElem,
        class: ["vxe-password-input", className, {
          [`size--${vSize}`]: vSize,
          "is--prefix": !!prefix,
          "is--suffix": !!suffix,
          "is--readonly": readonly,
          "is--disabled": disabled,
          "is--active": isActivated,
          "show--clear": isClearable && !disabled && !(inputValue === "" || import_xe_utils144.default.eqNull(inputValue))
        }],
        spellcheck: false
      }, [
        prefix || createCommentVNode(),
        h("div", {
          class: "vxe-password-input--wrapper"
        }, [
          h("input", {
            ref: refInputTarget,
            class: "vxe-password-input--inner",
            value: inputValue,
            name,
            type: inputType,
            placeholder: inpPlaceholder,
            readonly: inpReadonly,
            disabled,
            autocomplete: autocomplete || autoComplete,
            maxlength: maxLength,
            onClick: clickEvent,
            onInput: inputEvent,
            onChange: changeEvent,
            onFocus: focusEvent,
            onBlur: blurEvent
          })
        ]),
        suffix || createCommentVNode()
      ]);
    };
    $xePasswordInput.renderVN = renderVN;
    return $xePasswordInput;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/password-input/index.js
var VxePasswordInput = Object.assign({}, password_input_default, {
  install(app) {
    app.component(password_input_default.name, password_input_default);
  }
});
dynamicApp.use(VxePasswordInput);
VxeUI.component(password_input_default);
var PasswordInput = VxePasswordInput;
var password_input_default2 = VxePasswordInput;

// node_modules/vxe-pc-ui/es/print/src/page-break.js
var import_xe_utils146 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/print/src/util.js
var import_xe_utils145 = __toESM(require_xe_utils());
var printFrame;
var defaultHtmlStyle2 = 'body{margin:0;padding:0;color:#000000;font-size:14px;font-family:"Microsoft YaHei",微软雅黑,"MicrosoftJhengHei",华文细黑,STHeiti,MingLiu}body *{-webkit-box-sizing:border-box;box-sizing:border-box}.vxe-table{border-collapse:collapse;text-align:left;border-spacing:0}.vxe-table:not(.is--print){table-layout:fixed}.vxe-table,.vxe-table th,.vxe-table td,.vxe-table td{border-color:#D0D0D0;border-style:solid;border-width:0}.vxe-table.is--print{width:100%}.border--default,.border--full,.border--outer{border-top-width:1px}.border--default,.border--full,.border--outer{border-left-width:1px}.border--outer,.border--default th,.border--default td,.border--full th,.border--full td,.border--outer th,.border--inner th,.border--inner td{border-bottom-width:1px}.border--default,.border--outer,.border--full th,.border--full td{border-right-width:1px}.border--default th,.border--full th,.border--outer th{background-color:#f8f8f9}.vxe-table td>div,.vxe-table th>div{padding:.5em .4em}.col--center{text-align:center}.col--right{text-align:right}.vxe-table:not(.is--print) .col--ellipsis>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;word-break:break-all}.vxe-table--tree-node{text-align:left}.vxe-table--tree-node-wrapper{position:relative}.vxe-table--tree-icon-wrapper{position:absolute;top:50%;width:1em;height:1em;text-align:center;-webkit-transform:translateY(-50%);transform:translateY(-50%);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer}.vxe-table--tree-unfold-icon,.vxe-table--tree-fold-icon{position:absolute;width:0;height:0;border-style:solid;border-width:.5em;border-right-color:transparent;border-bottom-color:transparent}.vxe-table--tree-unfold-icon{left:.3em;top:0;border-left-color:#939599;border-top-color:transparent}.vxe-table--tree-fold-icon{left:0;top:.3em;border-left-color:transparent;border-top-color:#939599}.vxe-table--tree-cell{display:block;padding-left:1.5em}.vxe-table input[type="checkbox"]{margin:0}.vxe-table input[type="checkbox"],.vxe-table input[type="radio"],.vxe-table input[type="checkbox"]+span,.vxe-table input[type="radio"]+span{vertical-align:middle;padding-left:0.4em}';
function createPrintFrame() {
  const frame = document.createElement("iframe");
  frame.className = "vxe-table--print-frame";
  return frame;
}
function appendPrintFrame() {
  if (!printFrame.parentNode) {
    document.body.appendChild(printFrame);
  }
}
function afterPrintEvent() {
  requestAnimationFrame(removeFrame);
}
function removeFrame() {
  if (printFrame) {
    if (printFrame.parentNode) {
      try {
        printFrame.contentDocument.write("");
      } catch (e16) {
      }
      printFrame.parentNode.removeChild(printFrame);
    }
    printFrame = null;
  }
}
function getExportBlobByString(str, type) {
  return new Blob([str], { type: `text/${type};charset=utf-8;` });
}
var printMargin = 80;
function createHtmlPage2(opts, printHtml2) {
  const { customStyle } = opts;
  return [
    "<!DOCTYPE html><html>",
    "<head>",
    '<meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,minimal-ui">',
    `<title>${opts.title}</title>`,
    opts._pageBreaks || opts.pageBreaks && opts.pageBreaks.length ? '<style media="print">@page {size: auto;margin: 0mm;}</style>' : "",
    `<style>.vxe-print-slots{display: none;}.vxe-print-page-break.align--center{text-align:center;}.vxe-print-page-break.align--left{text-align:left;}.vxe-print-page-break.align--right{text-align:right;}.vxe-print-page-break--header-title{font-size:1.8em;text-align:center;line-height:${printMargin}px;}.vxe-print-page-break{page-break-before:always;display:flex;flex-direction:column;height:100vh;overflow:hidden;}.vxe-print-page-break--body{display:flex;flex-direction:row;flex-grow:1;overflow: hidden;}.vxe-print-page-break--left,.vxe-print-page-break--right{flex-shrink:0;width:${printMargin}px;height:100%;}.vxe-print-page-break--header,.vxe-print-page-break--footer{flex-shrink:0;height:${printMargin}px;width:100%;}.vxe-print-page-break--content{flex-grow: 1;overflow: hidden;}.vxe-print-page-break--footer-page-number{line-height:${printMargin}px;text-align:center;}</style>`,
    "<style>.vxe-table{white-space:pre;}</style>",
    `<style>${defaultHtmlStyle2}</style>`,
    customStyle ? `<style>${customStyle}</style>` : "",
    "</head>",
    "<body>",
    `${printHtml2}`,
    "</body>",
    "</html>"
  ].join("");
}
function handlePrint(opts, printHtml2 = "") {
  const { beforeMethod } = opts;
  if (beforeMethod) {
    printHtml2 = beforeMethod({ content: printHtml2, html: printHtml2, options: opts }) || "";
  }
  printHtml2 = createHtmlPage2(opts, printHtml2);
  const blob = getExportBlobByString(printHtml2, "html");
  return new Promise((resolve) => {
    if (import_xe_utils145.default.browse().msie) {
      removeFrame();
      printFrame = createPrintFrame();
      appendPrintFrame();
      printFrame.contentDocument.write(printHtml2);
      printFrame.contentDocument.execCommand("print");
      setTimeout(() => {
        resolve({
          status: true
        });
      }, 300);
    } else {
      if (!printFrame) {
        printFrame = createPrintFrame();
        printFrame.onload = (evnt) => {
          if (evnt.target.src) {
            evnt.target.contentWindow.onafterprint = afterPrintEvent;
            evnt.target.contentWindow.print();
          }
          resolve({
            status: true
          });
        };
        printFrame.onerror = () => {
          resolve({
            status: false
          });
        };
      }
      appendPrintFrame();
      printFrame.src = URL.createObjectURL(blob);
    }
  });
}
function createPageBreak(opts) {
  const { title, showPageNumber, align, headerAlign, footerAlign, showAllPageTitle } = opts;
  const pageBreaks = opts.pageBreaks || [];
  const pageCount = pageBreaks.length;
  return pageBreaks.map((item, index2) => {
    const bodyHtml = item.bodyHtml;
    const headerHtml = item.headerHtml || opts.headerHtml;
    const footerHtml = item.footerHtml || opts.footerHtml;
    const leftHtml = item.leftHtml || opts.leftHtml;
    const rightHtml = item.rightHtml || opts.rightHtml;
    const currentPage = index2 + 1;
    const params = {
      currentPage,
      pageCount
    };
    return [
      `<div class="${["vxe-print-page-break", align ? `align--${align}` : ""].join(" ")}">`,
      `<div class="${["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""].join(" ")}">`,
      headerHtml ? `${import_xe_utils145.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : title && (showAllPageTitle || !index2) ? `<div class="vxe-print-page-break--header-title">${title || ""}</div>` : "",
      "</div>",
      '<div class="vxe-print-page-break--body">',
      `<div class="vxe-print-page-break--left">${import_xe_utils145.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}</div>`,
      `<div class="vxe-print-page-break--content">${import_xe_utils145.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}</div>`,
      `<div class="vxe-print-page-break--right">${import_xe_utils145.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}</div>`,
      "</div>",
      `<div class="${["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""].join(" ")}">`,
      footerHtml ? `${import_xe_utils145.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : showPageNumber ? `<div class="vxe-print-page-break--footer-page-number">${currentPage}/${pageCount}</div>` : "",
      "</div>",
      "</div>"
    ].join("");
  }).join("");
}
var printHtml = (options) => {
  const opts = Object.assign({ _pageBreaks: false, customLayout: true }, options);
  if (opts.sheetName) {
    opts.title = opts.title || opts.sheetName;
  }
  if (opts.style) {
    opts.customStyle = opts.customStyle || opts.style;
  }
  if (opts.beforePrintMethod) {
    opts.beforeMethod = opts.beforeMethod || opts.beforePrintMethod;
  }
  if (opts.pageBreaks && opts.pageBreaks.length) {
    return handlePrint(opts, createPageBreak(opts));
  }
  const printHtml2 = opts.html || opts.content;
  return handlePrint(opts, printHtml2);
};
function assemblePageBreak($xePageBreak, elem, pageBreakConfig) {
  const staticPageBreaks = $xePageBreak.reactData.staticPageBreaks;
  const parentElem = elem.parentNode;
  if (parentElem && staticPageBreaks) {
    staticPageBreaks.splice(import_xe_utils145.default.arrayIndexOf(parentElem.children, elem), 0, pageBreakConfig);
    $xePageBreak.reactData.staticPageBreaks = staticPageBreaks.slice(0);
  }
}
function destroyPageBreak($xePageBreak, pageBreakConfig) {
  $xePageBreak.reactData.staticPageBreaks = $xePageBreak.reactData.staticPageBreaks.filter((item) => item.id !== pageBreakConfig.id);
}

// node_modules/vxe-pc-ui/es/print/src/page-break.js
var page_break_default = defineComponent({
  name: "VxePrintPageBreak",
  props: {},
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils146.default.uniqueId();
    const $xePrint = inject("$xePrint", null);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const pageBreakConfig = reactive({
      id: xID,
      slots
    });
    const $xePrintPageBreak = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $print: $xePrint }, params));
    };
    const printPageBreakMethods = {
      dispatchEvent: dispatchEvent2
    };
    const printPageBreakPrivateMethods = {};
    Object.assign($xePrintPageBreak, printPageBreakMethods, printPageBreakPrivateMethods);
    if (!$xePrint) {
      $xePrintPageBreak.renderVN = () => {
        return createCommentVNode();
      };
      return $xePrintPageBreak;
    }
    const renderVN = () => {
      return h("div", {
        ref: refElem
      });
    };
    onMounted(() => {
      const elem = refElem.value;
      if ($xePrint && elem) {
        assemblePageBreak($xePrint, elem, pageBreakConfig);
      }
    });
    onUnmounted(() => {
      if ($xePrint) {
        destroyPageBreak($xePrint, pageBreakConfig);
      }
    });
    $xePrintPageBreak.renderVN = renderVN;
    return $xePrintPageBreak;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/print-page-break/index.js
var VxePrintPageBreak = Object.assign({}, page_break_default, {
  install(app) {
    app.component(page_break_default.name, page_break_default);
  }
});
dynamicApp.use(VxePrintPageBreak);
VxeUI.component(page_break_default);
var PrintPageBreak = VxePrintPageBreak;
var print_page_break_default = VxePrintPageBreak;

// node_modules/vxe-pc-ui/es/print/src/print.js
var import_xe_utils147 = __toESM(require_xe_utils());
var print_default = defineComponent({
  name: "VxePrint",
  props: {
    align: {
      type: String,
      default: () => getConfig().print.align
    },
    title: String,
    headerAlign: {
      type: String,
      default: () => getConfig().print.headerAlign
    },
    footerAlign: {
      type: String,
      default: () => getConfig().print.footerAlign
    },
    showPageNumber: {
      type: Boolean,
      default: () => getConfig().print.showPageNumber
    },
    customLayout: Boolean,
    pageBreaks: Array,
    content: String,
    html: String,
    headerHtml: String,
    footerHtml: String,
    leftHtml: String,
    rightHtml: String,
    showAllPageTitle: {
      type: Boolean,
      default: () => getConfig().print.showAllPageTitle
    },
    customStyle: {
      type: String,
      default: () => getConfig().print.customStyle
    },
    beforeMethod: Function
  },
  emits: [],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils147.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      staticPageBreaks: []
    });
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xePrint = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $print: $xePrint }, params));
    };
    const printMethods = {
      dispatchEvent: dispatchEvent2,
      print() {
        const elem = refElem.value;
        return printHtml(Object.assign({}, props, {
          _pageBreaks: !!reactData.staticPageBreaks.length,
          html: (elem ? elem.outerHTML : "") || props.html || props.content || ""
        }));
      }
    };
    const printPrivateMethods = {};
    Object.assign($xePrint, printMethods, printPrivateMethods);
    const renderPageConfigLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const pageBreaks = props.pageBreaks || [];
      const pageCount = pageBreaks.length;
      return pageBreaks.map((item, index2) => {
        const bodyHtml = item.bodyHtml;
        const headerHtml = item.headerHtml || props.headerHtml;
        const footerHtml = item.footerHtml || props.footerHtml;
        const leftHtml = item.leftHtml || props.leftHtml;
        const rightHtml = item.rightHtml || props.rightHtml;
        const currentPage = index2 + 1;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerHtml ? `${import_xe_utils147.default.isFunction(headerHtml) ? headerHtml(params) : headerHtml || ""}` : [
            title && (showAllPageTitle || !index2) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, `${import_xe_utils147.default.isFunction(leftHtml) ? leftHtml(params) : leftHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--content"
            }, `${import_xe_utils147.default.isFunction(bodyHtml) ? bodyHtml(params) : bodyHtml || ""}`),
            h("div", {
              class: "vxe-print-page-break--right"
            }, `${import_xe_utils147.default.isFunction(rightHtml) ? rightHtml(params) : rightHtml || ""}`)
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerHtml ? `${import_xe_utils147.default.isFunction(footerHtml) ? footerHtml(params) : footerHtml || ""}` : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderPageStaticLayouts = () => {
      const { title, showPageNumber, showAllPageTitle, align, headerAlign, footerAlign } = props;
      const { staticPageBreaks } = reactData;
      const pageCount = staticPageBreaks.length;
      return staticPageBreaks.map((item, index2) => {
        const itemSlots = item.slots || {};
        const currentPage = index2 + 1;
        const defaultSlot = itemSlots.default;
        const headerSlot = itemSlots.header || slots.header;
        const footerSlot = itemSlots.footer || slots.footer;
        const leftSlot = itemSlots.left || slots.left;
        const rightSlot = itemSlots.right || slots.right;
        const params = {
          currentPage,
          pageCount
        };
        return h("div", {
          class: ["vxe-print-page-break", align ? `align--${align}` : ""]
        }, [
          h("div", {
            class: ["vxe-print-page-break--header", headerAlign ? `align--${headerAlign}` : ""]
          }, headerSlot ? getSlotVNs2(headerSlot(params)) : [
            title && (showAllPageTitle || !index2) ? h("div", {
              class: "vxe-print-page-break--header-title"
            }, `${title || ""}`) : createCommentVNode()
          ]),
          h("div", {
            class: "vxe-print-page-break--body"
          }, [
            h("div", {
              class: "vxe-print-page-break--left"
            }, leftSlot ? getSlotVNs2(leftSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--content"
            }, defaultSlot ? getSlotVNs2(defaultSlot(params)) : []),
            h("div", {
              class: "vxe-print-page-break--right"
            }, rightSlot ? getSlotVNs2(rightSlot(params)) : [])
          ]),
          h("div", {
            class: ["vxe-print-page-break--footer", footerAlign ? `align--${footerAlign}` : ""]
          }, footerSlot ? getSlotVNs2(footerSlot(params)) : [
            showPageNumber ? h("div", {
              class: "vxe-print-page-break--footer-page-number"
            }, `${currentPage}/${pageCount}`) : createCommentVNode()
          ])
        ]);
      });
    };
    const renderVN = () => {
      const { customLayout } = props;
      const { staticPageBreaks } = reactData;
      const defaultSlot = slots.default;
      return h("div", {
        ref: refElem,
        class: ["vxe-print"]
      }, customLayout ? defaultSlot ? getSlotVNs2(defaultSlot({})) : [] : [
        h("div", {
          key: "slot",
          class: "vxe-print-slots"
        }, defaultSlot ? getSlotVNs2(defaultSlot({})) : [])
      ].concat(staticPageBreaks.length ? renderPageStaticLayouts() : renderPageConfigLayouts()));
    };
    $xePrint.renderVN = renderVN;
    provide("$xePrint", $xePrint);
    return $xePrint;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/print/index.js
var VxePrint = Object.assign({}, print_default, {
  install(app) {
    app.component(print_default.name, print_default);
  }
});
dynamicApp.use(VxePrint);
VxeUI.component(print_default);
VxeUI.print = printHtml;
var Print = VxePrint;
var print_default2 = VxePrint;

// node_modules/vxe-pc-ui/es/pulldown/src/pulldown.js
var import_xe_utils148 = __toESM(require_xe_utils());
var pulldown_default = defineComponent({
  name: "VxePulldown",
  props: {
    modelValue: Boolean,
    disabled: Boolean,
    placement: String,
    trigger: {
      type: String,
      default: getConfig().pulldown.trigger
    },
    size: { type: String, default: () => getConfig().size },
    options: Array,
    className: {
      type: [String, Function],
      default: getConfig().pulldown.className
    },
    popupClassName: [String, Function],
    showPopupShadow: Boolean,
    destroyOnClose: {
      type: Boolean,
      default: getConfig().pulldown.destroyOnClose
    },
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "click",
    "option-click",
    "show-panel",
    "hide-panel",
    "visible-change"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const xID = import_xe_utils148.default.uniqueId();
    const { computeSize } = useSize(props);
    const reactData = reactive({
      initialized: false,
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      hpTimeout: void 0
    };
    const refElem = ref();
    const refPulldownContent = ref();
    const refPulldownPanel = ref();
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().pulldown.transfer;
        if (import_xe_utils148.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const refMaps = {
      refElem
    };
    const $xePulldown = {
      xID,
      props,
      context,
      reactData,
      internalData,
      getRefMaps: () => refMaps
    };
    let pulldownMethods = {};
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const isPanelVisible = () => {
      return reactData.visiblePanel;
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex, visiblePanel } = reactData;
        const btnTransfer = computeBtnTransfer.value;
        if (visiblePanel) {
          const targetElem = refPulldownContent.value;
          const panelElem = refPulldownPanel.value;
          if (panelElem && targetElem) {
            const targetHeight = targetElem.offsetHeight;
            const targetWidth = targetElem.offsetWidth;
            const panelHeight = panelElem.offsetHeight;
            const panelWidth = panelElem.offsetWidth;
            const marginSize = 5;
            const panelStyle = {
              zIndex: panelIndex
            };
            const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(targetElem);
            let panelPlacement = "bottom";
            if (btnTransfer) {
              let left = boundingLeft;
              let top = boundingTop + targetHeight;
              if (placement === "top") {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              } else if (!placement) {
                if (top + panelHeight + marginSize > visibleHeight) {
                  panelPlacement = "top";
                  top = boundingTop - panelHeight;
                }
                if (top < marginSize) {
                  panelPlacement = "bottom";
                  top = boundingTop + targetHeight;
                }
              }
              if (left + panelWidth + marginSize > visibleWidth) {
                left -= left + panelWidth + marginSize - visibleWidth;
              }
              if (left < marginSize) {
                left = marginSize;
              }
              Object.assign(panelStyle, {
                left: `${left}px`,
                top: `${top}px`,
                minWidth: `${targetWidth}px`
              });
            } else {
              if (placement === "top") {
                panelPlacement = "top";
                panelStyle.bottom = `${targetHeight}px`;
              } else if (!placement) {
                if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                  if (boundingTop - targetHeight - panelHeight > marginSize) {
                    panelPlacement = "top";
                    panelStyle.bottom = `${targetHeight}px`;
                  }
                }
              }
            }
            reactData.panelStyle = panelStyle;
            reactData.panelPlacement = panelPlacement;
          }
        }
        return nextTick();
      });
    };
    const showPanel = () => {
      if (!reactData.initialized) {
        reactData.initialized = true;
      }
      return new Promise((resolve) => {
        if (!props.disabled) {
          if (internalData.hpTimeout) {
            clearTimeout(internalData.hpTimeout);
          }
          reactData.isActivated = true;
          reactData.isAniVisible = true;
          setTimeout(() => {
            reactData.visiblePanel = true;
            emit("update:modelValue", true);
            updatePlacement();
            setTimeout(() => {
              resolve(updatePlacement());
            }, 40);
          }, 10);
          updateZindex();
          dispatchEvent2("visible-change", { visible: true }, null);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const hidePanel = () => {
      reactData.visiblePanel = false;
      dispatchEvent2("visible-change", { visible: false }, null);
      emit("update:modelValue", false);
      return new Promise((resolve) => {
        if (reactData.isAniVisible) {
          internalData.hpTimeout = window.setTimeout(() => {
            reactData.isAniVisible = false;
            nextTick(() => {
              resolve();
            });
          }, 350);
        } else {
          nextTick(() => {
            resolve();
          });
        }
      });
    };
    const togglePanel = () => {
      if (reactData.visiblePanel) {
        return hidePanel();
      }
      return showPanel();
    };
    const handleOptionEvent = (evnt, option2) => {
      if (!option2.disabled) {
        if (reactData.visiblePanel) {
          hidePanel();
          dispatchEvent2("hide-panel", {}, evnt);
        }
        dispatchEvent2("option-click", { option: option2 }, evnt);
      }
    };
    const clickTargetEvent = (evnt) => {
      const { trigger } = props;
      if (trigger === "click") {
        if (reactData.visiblePanel) {
          hidePanel();
          dispatchEvent2("hide-panel", {}, evnt);
        } else {
          showPanel();
          dispatchEvent2("show-panel", {}, evnt);
        }
      }
      dispatchEvent2("click", { $pulldown: $xePulldown }, evnt);
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        if (visiblePanel) {
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hidePanel();
            dispatchEvent2("hide-panel", {}, evnt);
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { disabled } = props;
      const { visiblePanel } = reactData;
      const el2 = refElem.value;
      const panelElem = refPulldownPanel.value;
      if (!disabled) {
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hidePanel();
          dispatchEvent2("hide-panel", {}, evnt);
        }
      }
    };
    const handleGlobalBlurEvent = (evnt) => {
      if (reactData.visiblePanel) {
        reactData.isActivated = false;
        hidePanel();
        dispatchEvent2("hide-panel", {}, evnt);
      }
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $pulldown: $xePulldown }, params));
    };
    pulldownMethods = {
      dispatchEvent: dispatchEvent2,
      isPanelVisible,
      togglePanel,
      showPanel,
      hidePanel
    };
    Object.assign($xePulldown, pulldownMethods);
    watch(() => props.modelValue, (value) => {
      reactData.isActivated = !!value;
      if (value) {
        showPanel();
      } else {
        hidePanel();
      }
    });
    nextTick(() => {
      if (props.modelValue) {
        showPanel();
      }
      globalEvents.on($xePulldown, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xePulldown, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xePulldown, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xePulldown, "mousewheel");
      globalEvents.off($xePulldown, "mousedown");
      globalEvents.off($xePulldown, "blur");
    });
    const renderDefaultPanel = (options) => {
      const optionSlot = slots.option;
      return h("div", {
        class: "vxe-pulldown--panel-list"
      }, options ? options.map((item) => {
        return h("div", {
          class: "vxe-pulldown--panel-item",
          onClick(evnt) {
            handleOptionEvent(evnt, item);
          }
        }, optionSlot ? optionSlot({ $pulldown: $xePulldown, option: item }) : `${item.label || ""}`);
      }) : []);
    };
    const renderVN = () => {
      const { className, options, popupClassName, showPopupShadow, destroyOnClose, disabled } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, panelStyle, panelPlacement } = reactData;
      const btnTransfer = computeBtnTransfer.value;
      const vSize = computeSize.value;
      const defaultSlot = slots.default;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const dropdownSlot = slots.dropdown;
      return h("div", {
        ref: refElem,
        class: ["vxe-pulldown", className ? import_xe_utils148.default.isFunction(className) ? className({ $pulldown: $xePulldown }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": disabled,
          "is--active": isActivated
        }]
      }, [
        h("div", {
          ref: refPulldownContent,
          class: "vxe-pulldown--content",
          onClick: clickTargetEvent
        }, defaultSlot ? defaultSlot({ $pulldown: $xePulldown }) : []),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refPulldownPanel,
            class: ["vxe-table--ignore-clear vxe-pulldown--panel", popupClassName ? import_xe_utils148.default.isFunction(popupClassName) ? popupClassName({ $pulldown: $xePulldown }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--shadow": showPopupShadow,
              "is--transfer": btnTransfer,
              "ani--leave": isAniVisible,
              "ani--enter": visiblePanel
            }],
            placement: panelPlacement,
            style: panelStyle
          }, [
            h("div", {
              class: "vxe-pulldown--panel-wrapper"
            }, initialized && (destroyOnClose ? visiblePanel || isAniVisible : true) ? [
              headerSlot ? h("div", {
                class: "vxe-pulldown--panel-header"
              }, headerSlot({ $pulldown: $xePulldown })) : createCommentVNode(),
              h("div", {
                class: "vxe-pulldown--panel-body"
              }, dropdownSlot ? dropdownSlot({ $pulldown: $xePulldown }) : [
                renderDefaultPanel(options)
              ]),
              footerSlot ? h("div", {
                class: "vxe-pulldown--panel-footer"
              }, footerSlot({ $pulldown: $xePulldown })) : createCommentVNode()
            ] : [])
          ])
        ])
      ]);
    };
    $xePulldown.renderVN = renderVN;
    return $xePulldown;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/pulldown/index.js
var VxePulldown = Object.assign(pulldown_default, {
  install: function(app) {
    app.component(pulldown_default.name, pulldown_default);
  }
});
dynamicApp.use(VxePulldown);
VxeUI.component(pulldown_default);
var Pulldown = VxePulldown;
var pulldown_default2 = VxePulldown;

// node_modules/vxe-pc-ui/es/radio/index.js
var VxeRadio = Object.assign(radio_default, {
  install: function(app) {
    app.component(radio_default.name, radio_default);
  }
});
dynamicApp.use(VxeRadio);
VxeUI.component(radio_default);
var Radio = VxeRadio;
var radio_default2 = VxeRadio;

// node_modules/vxe-pc-ui/es/radio-button/index.js
var VxeRadioButton = Object.assign(button_default3, {
  install: function(app) {
    app.component(button_default3.name, button_default3);
  }
});
dynamicApp.use(VxeRadioButton);
VxeUI.component(button_default3);
var RadioButton = VxeRadioButton;
var radio_button_default = VxeRadioButton;

// node_modules/vxe-pc-ui/es/radio-group/index.js
var VxeRadioGroup = Object.assign(group_default3, {
  install: function(app) {
    app.component(group_default3.name, group_default3);
  }
});
dynamicApp.use(VxeRadioGroup);
VxeUI.component(group_default3);
var RadioGroup = VxeRadioGroup;
var radio_group_default = VxeRadioGroup;

// node_modules/vxe-pc-ui/es/rate/index.js
var VxeRate = Object.assign({}, rate_default, {
  install(app) {
    app.component(rate_default.name, rate_default);
  }
});
dynamicApp.use(VxeRate);
VxeUI.component(rate_default);
var Rate = VxeRate;
var rate_default2 = VxeRate;

// node_modules/vxe-pc-ui/es/result/src/result.js
var import_xe_utils149 = __toESM(require_xe_utils());
var result_default = defineComponent({
  name: "VxeResult",
  props: {
    imageUrl: String,
    imageStyle: Object,
    icon: String,
    type: [String, Number],
    status: [String, Number],
    title: [String, Number],
    content: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit, slots } = context;
    const xID = import_xe_utils149.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeResult = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $result: $xeResult }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeResult, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const { imageUrl, imageStyle, icon, title, type, content } = props;
      const status = props.status || type;
      const slotExtra = slots.extra;
      return h("div", {
        ref: "refElem",
        class: ["vxe-result", {
          [`theme--${status}`]: status
        }]
      }, [
        h("div", {
          class: "vxe-result--inner"
        }, [
          imageUrl ? h("div", {
            class: "vxe-result--img-wrapper"
          }, [
            h("img", {
              src: imageUrl,
              style: imageStyle
            })
          ]) : h("div", {
            class: "vxe-result--icon-wrapper"
          }, [
            h("i", {
              class: [icon, type ? getIcon()[`RESULT_${type}`.toLocaleUpperCase()] : ""]
            })
          ]),
          h("div", {
            class: "vxe-result--title-wrapper"
          }, `${title || ""}`),
          h("div", {
            class: "vxe-result--content-wrapper"
          }, `${content || ""}`),
          slotExtra ? h("div", {
            class: "vxe-result--extra-wrapper"
          }, slotExtra({})) : renderEmptyElement($xeResult)
        ])
      ]);
    };
    $xeResult.renderVN = renderVN;
    return $xeResult;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/result/index.js
var VxeResult = Object.assign({}, result_default, {
  install(app) {
    app.component(result_default.name, result_default);
  }
});
dynamicApp.use(VxeResult);
VxeUI.component(result_default);
var Result = VxeResult;
var result_default2 = VxeResult;

// node_modules/vxe-pc-ui/es/row/index.js
var VxeRow = Object.assign({}, row_default, {
  install(app) {
    app.component(row_default.name, row_default);
  }
});
dynamicApp.use(VxeRow);
VxeUI.component(row_default);
var Row = VxeRow;
var row_default2 = VxeRow;

// node_modules/vxe-pc-ui/es/select/index.js
var VxeSelect = Object.assign(select_default, {
  install: function(app) {
    app.component(select_default.name, select_default);
  }
});
dynamicApp.use(VxeSelect);
VxeUI.component(select_default);
var Select = VxeSelect;
var select_default2 = VxeSelect;

// node_modules/vxe-pc-ui/es/slider/index.js
var VxeSlider = Object.assign({}, slider_default, {
  install(app) {
    app.component(slider_default.name, slider_default);
  }
});
dynamicApp.use(VxeSlider);
VxeUI.component(slider_default);
var Slider = VxeSlider;
var slider_default2 = VxeSlider;

// node_modules/vxe-pc-ui/es/steps/src/steps.js
var import_xe_utils150 = __toESM(require_xe_utils());
var steps_default = defineComponent({
  name: "VxeSteps",
  props: {},
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils150.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeSteps = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $steps: $xeSteps }, params));
    };
    const stepsMethods = {
      dispatchEvent: dispatchEvent2
    };
    const stepsPrivateMethods = {};
    Object.assign($xeSteps, stepsMethods, stepsPrivateMethods);
    const renderVN = () => {
      return h("div", {
        ref: refElem,
        class: "vxe-steps"
      }, []);
    };
    $xeSteps.renderVN = renderVN;
    return $xeSteps;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/steps/index.js
var VxeSteps = Object.assign({}, steps_default, {
  install(app) {
    app.component(steps_default.name, steps_default);
  }
});
dynamicApp.use(VxeSteps);
VxeUI.component(steps_default);
var Steps = VxeSteps;
var steps_default2 = VxeSteps;

// node_modules/vxe-pc-ui/es/switch/index.js
var VxeSwitch = Object.assign(switch_default, {
  install: function(app) {
    app.component(switch_default.name, switch_default);
  }
});
dynamicApp.use(VxeSwitch);
VxeUI.component(switch_default);
var Switch = VxeSwitch;
var switch_default2 = VxeSwitch;

// node_modules/vxe-pc-ui/es/tab-pane/index.js
var VxeTabPane = Object.assign({}, tab_pane_default, {
  install(app) {
    app.component(tab_pane_default.name, tab_pane_default);
  }
});
dynamicApp.use(VxeTabPane);
VxeUI.component(tab_pane_default);
var TabPane = VxeTabPane;
var tab_pane_default2 = VxeTabPane;

// node_modules/vxe-pc-ui/es/table-select/src/table-select.js
var import_xe_utils151 = __toESM(require_xe_utils());
function getRowUniqueId2() {
  return import_xe_utils151.default.uniqueId("row_");
}
var table_select_default = defineComponent({
  name: "VxeTableSelect",
  props: {
    modelValue: [String, Number, Array],
    clearable: Boolean,
    placeholder: {
      type: String,
      default: () => import_xe_utils151.default.eqNull(getConfig().tableSelect.placeholder) ? getI18n("vxe.base.pleaseSelect") : getConfig().tableSelect.placeholder
    },
    readonly: {
      type: Boolean,
      default: null
    },
    loading: Boolean,
    disabled: {
      type: Boolean,
      default: null
    },
    multiple: Boolean,
    className: [String, Function],
    prefixIcon: String,
    placement: String,
    columns: Array,
    options: Array,
    optionProps: Object,
    size: {
      type: String,
      default: () => getConfig().select.size || getConfig().size
    },
    popupConfig: Object,
    gridConfig: Object,
    transfer: {
      type: Boolean,
      default: null
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "clear",
    "blur",
    "focus",
    "click"
  ],
  setup(props, context) {
    const { emit, slots } = context;
    const VxeTableGridComponent = VxeUI.getComponent("VxeGrid");
    const $xeModal = inject("$xeModal", null);
    const $xeDrawer = inject("$xeDrawer", null);
    const $xeTable = inject("$xeTable", null);
    const $xeForm = inject("$xeForm", null);
    const formItemInfo = inject("xeFormItemInfo", null);
    const xID = import_xe_utils151.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const refInput = ref();
    const refGridWrapper = ref();
    const refOptionPanel = ref();
    const refGrid = ref();
    const reactData = reactive({
      initialized: false,
      tableColumns: [],
      fullOptionList: [],
      fullRowMaps: {},
      panelIndex: 0,
      panelStyle: {},
      panelPlacement: null,
      triggerFocusPanel: false,
      visiblePanel: false,
      isAniVisible: false,
      isActivated: false
    });
    const internalData = {
      // hpTimeout: undefined,
      // vpTimeout: undefined
    };
    const refMaps = {
      refElem
    };
    const computeFormReadonly = computed(() => {
      const { readonly } = props;
      if (readonly === null) {
        if ($xeForm) {
          return $xeForm.props.readonly;
        }
        return false;
      }
      return readonly;
    });
    const computeIsDisabled = computed(() => {
      const { disabled } = props;
      if (disabled === null) {
        if ($xeForm) {
          return $xeForm.props.disabled;
        }
        return false;
      }
      return disabled;
    });
    const computeBtnTransfer = computed(() => {
      const { transfer } = props;
      if (transfer === null) {
        const globalTransfer = getConfig().select.transfer;
        if (import_xe_utils151.default.isBoolean(globalTransfer)) {
          return globalTransfer;
        }
        if ($xeTable || $xeModal || $xeDrawer || $xeForm) {
          return true;
        }
      }
      return transfer;
    });
    const computePropsOpts = computed(() => {
      return props.optionProps || {};
    });
    const computeRowOpts = computed(() => {
      const gridOpts = computeGridOpts.value;
      return Object.assign({}, gridOpts.rowConfig, {
        isCurrent: true
      });
    });
    const computeRowKeyField = computed(() => {
      const rowOpts = computeRowOpts.value;
      return rowOpts.keyField || "_X_ROW_KEY";
    });
    const computeLabelField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.label || "label";
    });
    const computeValueField = computed(() => {
      const propsOpts = computePropsOpts.value;
      return propsOpts.value || "value";
    });
    const computePopupOpts = computed(() => {
      return Object.assign({}, getConfig().tableSelect.popupConfig, props.popupConfig);
    });
    const computeGridOpts = computed(() => {
      return Object.assign({}, getConfig().tableSelect.gridConfig, props.gridConfig, { data: void 0, columns: void 0 });
    });
    const computeSelectLabel = computed(() => {
      const { modelValue } = props;
      const { fullRowMaps } = reactData;
      const labelField = computeLabelField.value;
      return (import_xe_utils151.default.isArray(modelValue) ? modelValue : [modelValue]).map((val) => {
        const cacheItem = fullRowMaps[val];
        return cacheItem ? cacheItem.item[labelField] : val;
      }).join(", ");
    });
    const computePopupWrapperStyle = computed(() => {
      const popupOpts = computePopupOpts.value;
      const { height, width } = popupOpts;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      return stys;
    });
    const computeMaps = {};
    const $xeTableSelect = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tableSelect: $xeTableSelect }, params));
    };
    const emitModel = (value) => {
      emit("update:modelValue", value);
    };
    const tableSelectMethods = {
      dispatchEvent: dispatchEvent2
    };
    const tableSelectPrivateMethods = {};
    const getRowid2 = (option2) => {
      const nodeKeyField = computeRowKeyField.value;
      const rowid = option2[nodeKeyField];
      return rowid ? encodeURIComponent(rowid) : "";
    };
    const getRowsByValue = (modelValue) => {
      const { fullRowMaps } = reactData;
      const rows = [];
      const vals = import_xe_utils151.default.eqNull(modelValue) ? [] : import_xe_utils151.default.isArray(modelValue) ? modelValue : [modelValue];
      vals.forEach((val) => {
        const cacheItem = fullRowMaps[val];
        if (cacheItem) {
          rows.push(cacheItem.item);
        }
      });
      return rows;
    };
    const updateModel = (modelValue) => {
      const { multiple } = props;
      nextTick(() => {
        const $grid = refGrid.value;
        if ($grid) {
          const selectList = getRowsByValue(modelValue);
          if (selectList.length) {
            if (multiple) {
              $grid.setCheckboxRow(selectList, true);
            } else {
              $grid.setRadioRow(selectList[0]);
            }
          }
        }
      });
    };
    const loadTableColumn = (columns) => {
      const { multiple } = props;
      const tableCols = [];
      if (multiple) {
        tableCols.push({
          type: "checkbox",
          width: 70
        });
      } else {
        tableCols.push({
          type: "radio",
          width: 70
        });
      }
      reactData.tableColumns = tableCols.concat(columns || []);
    };
    const cacheDataMap = () => {
      const { options } = props;
      const rowKeyField = computeRowKeyField.value;
      const valueField = computeValueField.value;
      const gridOpts = computeGridOpts.value;
      const { treeConfig } = gridOpts;
      const rowMaps = {};
      const keyMaps = {};
      if (treeConfig) {
      } else {
        import_xe_utils151.default.arrayEach(options || [], (item, index2, items) => {
          let rowid = getRowid2(item);
          if (!rowid) {
            rowid = getRowUniqueId2();
          }
          if (keyMaps[rowid]) {
            errLog2("vxe.error.repeatKey", [rowKeyField, rowid]);
          }
          keyMaps[rowid] = true;
          const value = item[valueField];
          if (rowMaps[value]) {
            errLog2("vxe.error.repeatKey", [valueField, value]);
          }
          rowMaps[value] = { item, index: index2, items, parent: null, nodes: [] };
        });
      }
      reactData.fullOptionList = options || [];
      reactData.fullRowMaps = rowMaps;
      updateModel(props.modelValue);
    };
    const updateZindex = () => {
      if (reactData.panelIndex < getLastZIndex2()) {
        reactData.panelIndex = nextZIndex2();
      }
    };
    const updatePlacement = () => {
      return nextTick().then(() => {
        const { placement } = props;
        const { panelIndex } = reactData;
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        const btnTransfer = computeBtnTransfer.value;
        if (panelElem && el2) {
          const targetHeight = el2.offsetHeight;
          const targetWidth = el2.offsetWidth;
          const panelHeight = panelElem.offsetHeight;
          const panelWidth = panelElem.offsetWidth;
          const marginSize = 5;
          const panelStyle = {
            zIndex: panelIndex
          };
          const { boundingTop, boundingLeft, visibleHeight, visibleWidth } = getAbsolutePos2(el2);
          let panelPlacement = "bottom";
          if (btnTransfer) {
            let left = boundingLeft;
            let top = boundingTop + targetHeight;
            if (placement === "top") {
              panelPlacement = "top";
              top = boundingTop - panelHeight;
            } else if (!placement) {
              if (top + panelHeight + marginSize > visibleHeight) {
                panelPlacement = "top";
                top = boundingTop - panelHeight;
              }
              if (top < marginSize) {
                panelPlacement = "bottom";
                top = boundingTop + targetHeight;
              }
            }
            if (left + panelWidth + marginSize > visibleWidth) {
              left -= left + panelWidth + marginSize - visibleWidth;
            }
            if (left < marginSize) {
              left = marginSize;
            }
            Object.assign(panelStyle, {
              left: `${left}px`,
              top: `${top}px`,
              minWidth: `${targetWidth}px`
            });
          } else {
            if (placement === "top") {
              panelPlacement = "top";
              panelStyle.bottom = `${targetHeight}px`;
            } else if (!placement) {
              if (boundingTop + targetHeight + panelHeight > visibleHeight) {
                if (boundingTop - targetHeight - panelHeight > marginSize) {
                  panelPlacement = "top";
                  panelStyle.bottom = `${targetHeight}px`;
                }
              }
            }
          }
          reactData.panelStyle = panelStyle;
          reactData.panelPlacement = panelPlacement;
          return nextTick();
        }
      });
    };
    const showOptionPanel = () => {
      const { loading: loading2 } = props;
      const isDisabled = computeIsDisabled.value;
      if (!loading2 && !isDisabled) {
        if (internalData.vpTimeout) {
          clearTimeout(internalData.vpTimeout);
        }
        if (internalData.hpTimeout) {
          clearTimeout(internalData.hpTimeout);
        }
        if (!reactData.initialized) {
          reactData.initialized = true;
        }
        reactData.isActivated = true;
        reactData.isAniVisible = true;
        internalData.vpTimeout = setTimeout(() => {
          reactData.visiblePanel = true;
          updateModel(props.modelValue);
          internalData.vpTimeout = void 0;
        }, 10);
        updateZindex();
        updatePlacement();
      }
    };
    const hideOptionPanel = () => {
      reactData.visiblePanel = false;
      if (internalData.vpTimeout) {
        clearTimeout(internalData.vpTimeout);
      }
      if (internalData.hpTimeout) {
        clearTimeout(internalData.hpTimeout);
      }
      internalData.hpTimeout = window.setTimeout(() => {
        reactData.isAniVisible = false;
        internalData.hpTimeout = void 0;
      }, 350);
    };
    const changeEvent = (evnt, selectValue) => {
      const { fullRowMaps } = reactData;
      emitModel(selectValue);
      if (selectValue !== props.modelValue) {
        const cacheItem = fullRowMaps[selectValue];
        dispatchEvent2("change", { value: selectValue, row: cacheItem ? cacheItem.item : null }, evnt);
        if ($xeForm && formItemInfo) {
          $xeForm.triggerItemEvent(evnt, formItemInfo.itemConfig.field, selectValue);
        }
      }
    };
    const clearValueEvent = (evnt, selectValue) => {
      changeEvent(evnt, selectValue);
      dispatchEvent2("clear", { value: selectValue }, evnt);
    };
    const clearEvent = (params, evnt) => {
      clearValueEvent(evnt, null);
      hideOptionPanel();
    };
    const handleGlobalMousewheelEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (visiblePanel) {
          const panelElem = refOptionPanel.value;
          if (getEventTargetNode2(evnt, panelElem).flag) {
            updatePlacement();
          } else {
            hideOptionPanel();
          }
        }
      }
    };
    const handleGlobalMousedownEvent = (evnt) => {
      const { visiblePanel } = reactData;
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        const el2 = refElem.value;
        const panelElem = refOptionPanel.value;
        reactData.isActivated = getEventTargetNode2(evnt, el2).flag || getEventTargetNode2(evnt, panelElem).flag;
        if (visiblePanel && !reactData.isActivated) {
          hideOptionPanel();
        }
      }
    };
    const handleGlobalBlurEvent = () => {
      hideOptionPanel();
    };
    const focusEvent = (evnt) => {
      const isDisabled = computeIsDisabled.value;
      if (!isDisabled) {
        if (!reactData.visiblePanel) {
          reactData.triggerFocusPanel = true;
          showOptionPanel();
          setTimeout(() => {
            reactData.triggerFocusPanel = false;
          }, 150);
        }
      }
      dispatchEvent2("focus", {}, evnt);
    };
    const clickEvent = (evnt) => {
      togglePanelEvent(evnt);
      dispatchEvent2("click", {}, evnt);
    };
    const blurEvent = (evnt) => {
      reactData.isActivated = false;
      dispatchEvent2("blur", {}, evnt);
    };
    const togglePanelEvent = (params) => {
      const { $event } = params;
      $event.preventDefault();
      if (reactData.triggerFocusPanel) {
        reactData.triggerFocusPanel = false;
      } else {
        if (reactData.visiblePanel) {
          hideOptionPanel();
        } else {
          showOptionPanel();
        }
      }
    };
    const radioChangeEvent = (params) => {
      const { $event, row } = params;
      const valueField = computeValueField.value;
      const value = row[valueField];
      changeEvent($event, value);
      hideOptionPanel();
    };
    const checkboxChangeEvent = (params) => {
      const { $grid, $event } = params;
      const valueField = computeValueField.value;
      const checkboxRecords = $grid.getCheckboxRecords();
      const value = checkboxRecords.map((row) => {
        return row[valueField];
      });
      changeEvent($event, value);
    };
    const checkboxAllEvent = (params) => {
      checkboxChangeEvent(params);
    };
    Object.assign($xeTableSelect, tableSelectMethods, tableSelectPrivateMethods);
    const renderVN = () => {
      const { className, options, loading: loading2 } = props;
      const { initialized, isActivated, isAniVisible, visiblePanel, tableColumns } = reactData;
      const vSize = computeSize.value;
      const isDisabled = computeIsDisabled.value;
      const selectLabel = computeSelectLabel.value;
      const btnTransfer = computeBtnTransfer.value;
      const formReadonly = computeFormReadonly.value;
      const popupOpts = computePopupOpts.value;
      const { className: popupClassName } = popupOpts;
      const gridOpts = computeGridOpts.value;
      const rowOpts = computeRowOpts.value;
      const popupWrapperStyle = computePopupWrapperStyle.value;
      const headerSlot = slots.header;
      const footerSlot = slots.footer;
      const prefixSlot = slots.prefix;
      if (formReadonly) {
        return h("div", {
          ref: refElem,
          class: ["vxe-table-select--readonly", className]
        }, [
          h("span", {
            class: "vxe-table-select-label"
          }, selectLabel)
        ]);
      }
      return h("div", {
        ref: refElem,
        class: ["vxe-table-select", className ? import_xe_utils151.default.isFunction(className) ? className({ $tableSelect: $xeTableSelect }) : className : "", {
          [`size--${vSize}`]: vSize,
          "is--visible": visiblePanel,
          "is--disabled": isDisabled,
          "is--loading": loading2,
          "is--active": isActivated
        }]
      }, [
        h(input_default, {
          ref: refInput,
          clearable: props.clearable,
          placeholder: loading2 ? getI18n("vxe.select.loadingText") : props.placeholder,
          readonly: true,
          disabled: isDisabled,
          type: "text",
          prefixIcon: props.prefixIcon,
          suffixIcon: loading2 ? getIcon().TABLE_SELECT_LOADED : visiblePanel ? getIcon().TABLE_SELECT_OPEN : getIcon().TABLE_SELECT_CLOSE,
          modelValue: loading2 ? "" : selectLabel,
          onClear: clearEvent,
          onClick: clickEvent,
          onFocus: focusEvent,
          onBlur: blurEvent,
          onSuffixClick: togglePanelEvent
        }, prefixSlot ? {
          prefix: () => prefixSlot({})
        } : {}),
        h(Teleport, {
          to: "body",
          disabled: btnTransfer ? !initialized : true
        }, [
          h("div", {
            ref: refOptionPanel,
            class: ["vxe-table--ignore-clear vxe-table-select--panel", popupClassName ? import_xe_utils151.default.isFunction(popupClassName) ? popupClassName({ $tableSelect: $xeTableSelect }) : popupClassName : "", {
              [`size--${vSize}`]: vSize,
              "is--transfer": btnTransfer,
              "ani--leave": !loading2 && isAniVisible,
              "ani--enter": !loading2 && visiblePanel
            }],
            placement: reactData.panelPlacement,
            style: reactData.panelStyle
          }, initialized ? [
            h("div", {
              class: "vxe-table-select--panel-wrapper"
            }, [
              headerSlot ? h("div", {
                class: "vxe-table-select--panel-header"
              }, headerSlot({})) : renderEmptyElement($xeTableSelect),
              h("div", {
                class: "vxe-table-select--panel-body"
              }, [
                h("div", {
                  ref: refGridWrapper,
                  class: "vxe-table-select-grid--wrapper",
                  style: popupWrapperStyle
                }, [
                  VxeTableGridComponent ? h(VxeTableGridComponent, Object.assign(Object.assign({}, gridOpts), { class: "vxe-table-select--grid", ref: refGrid, rowConfig: rowOpts, data: options, columns: tableColumns, height: "100%", autoResize: true, onRadioChange: radioChangeEvent, onCheckboxChange: checkboxChangeEvent, onCheckboxAll: checkboxAllEvent }), Object.assign({}, slots, {
                    header: void 0,
                    footer: void 0,
                    prefixSlot: void 0
                  })) : renderEmptyElement($xeTableSelect)
                ])
              ]),
              footerSlot ? h("div", {
                class: "vxe-table-select--panel-footer"
              }, footerSlot({})) : renderEmptyElement($xeTableSelect)
            ])
          ] : [])
        ])
      ]);
    };
    watch(() => props.options, () => {
      cacheDataMap();
    });
    watch(() => props.columns, (val) => {
      loadTableColumn(val || []);
    });
    watch(() => props.modelValue, (val) => {
      updateModel(val);
    });
    loadTableColumn(props.columns || []);
    cacheDataMap();
    onMounted(() => {
      globalEvents.on($xeTableSelect, "mousewheel", handleGlobalMousewheelEvent);
      globalEvents.on($xeTableSelect, "mousedown", handleGlobalMousedownEvent);
      globalEvents.on($xeTableSelect, "blur", handleGlobalBlurEvent);
    });
    onUnmounted(() => {
      globalEvents.off($xeTableSelect, "mousewheel");
      globalEvents.off($xeTableSelect, "mousedown");
      globalEvents.off($xeTableSelect, "blur");
    });
    if (true) {
      nextTick(() => {
        if (!VxeTableGridComponent) {
          errLog2("vxe.error.reqComp", ["vxe-grid"]);
        }
      });
    }
    provide("$xeTableSelect", $xeTableSelect);
    $xeTableSelect.renderVN = renderVN;
    return $xeTableSelect;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/table-select/index.js
var VxeTableSelect = Object.assign({}, table_select_default, {
  install(app) {
    app.component(table_select_default.name, table_select_default);
  }
});
dynamicApp.use(VxeTableSelect);
VxeUI.component(table_select_default);
var TableSelect = VxeTableSelect;
var table_select_default2 = VxeTableSelect;

// node_modules/vxe-pc-ui/es/tabs/index.js
var VxeTabs = Object.assign({}, tabs_default, {
  install(app) {
    app.component(tabs_default.name, tabs_default);
  }
});
dynamicApp.use(VxeTabs);
VxeUI.component(tabs_default);
var Tabs = VxeTabs;
var tabs_default2 = VxeTabs;

// node_modules/vxe-pc-ui/es/tag/src/tag.js
var import_xe_utils152 = __toESM(require_xe_utils());
var tag_default = defineComponent({
  name: "VxeTag",
  props: {
    status: String,
    title: [String, Number],
    icon: String,
    content: [String, Number],
    size: {
      type: String,
      default: () => getConfig().tag.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { slots, emit } = context;
    const xID = import_xe_utils152.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const reactData = reactive({});
    const refMaps = {
      refElem
    };
    const computeMaps = {};
    const $xeTag = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $tag: $xeTag }, params));
    };
    const tagMethods = {
      dispatchEvent: dispatchEvent2
    };
    const tagPrivateMethods = {};
    const clickEvent = (evnt) => {
      dispatchEvent2("click", {}, evnt);
    };
    Object.assign($xeTag, tagMethods, tagPrivateMethods);
    const renderContent = () => {
      const { icon, content } = props;
      const defaultSlot = slots.default;
      const iconSlot = slots.icon;
      return [
        iconSlot || icon ? h("span", {
          class: "vxe-tag--icon"
        }, iconSlot ? getSlotVNs2(iconSlot({})) : [
          h("i", {
            class: icon
          })
        ]) : createCommentVNode(),
        h("span", {
          class: "vxe-tag--content"
        }, defaultSlot ? defaultSlot({}) : import_xe_utils152.default.toValueString(content))
      ];
    };
    const renderVN = () => {
      const { status, title } = props;
      const vSize = computeSize.value;
      return h("span", {
        ref: refElem,
        class: ["vxe-tag", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status
        }],
        title,
        onClick: clickEvent
      }, renderContent());
    };
    $xeTag.renderVN = renderVN;
    return $xeTag;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/tag/index.js
var VxeTag = Object.assign({}, tag_default, {
  install(app) {
    app.component(tag_default.name, tag_default);
  }
});
dynamicApp.use(VxeTag);
VxeUI.component(tag_default);
var Tag = VxeTag;
var tag_default2 = VxeTag;

// node_modules/vxe-pc-ui/es/text-ellipsis/src/text-ellipsis.js
var import_xe_utils153 = __toESM(require_xe_utils());
var text_ellipsis_default = defineComponent({
  name: "VxeTextEllipsis",
  props: {
    content: [String, Number],
    lineClamp: [String, Number],
    status: String,
    title: [String, Number],
    loading: Boolean,
    offsetLength: [String, Number],
    size: {
      type: String,
      default: () => getConfig().textEllipsis.size || getConfig().size
    }
  },
  emits: [
    "click"
  ],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils153.default.uniqueId();
    const { computeSize } = useSize(props);
    const refElem = ref();
    const realityElem = ref();
    const reactData = reactive({
      resizeObserver: null,
      visibleLen: 0
    });
    const refMaps = {
      refElem
    };
    const computeTextLineClamp = computed(() => {
      return import_xe_utils153.default.toNumber(props.lineClamp);
    });
    const computeTextContent = computed(() => {
      return import_xe_utils153.default.toValueString(props.content);
    });
    const computeTextOffsetLength = computed(() => {
      return props.offsetLength ? import_xe_utils153.default.toNumber(props.offsetLength) : 0;
    });
    const computeVisibleContent = computed(() => {
      const { visibleLen } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      const textContent = computeTextContent.value;
      const textOffsetLength = computeTextOffsetLength.value;
      if (textLineClamp > 1) {
        if (textContent.length > visibleLen) {
          return `${textContent.slice(0, Math.max(1, visibleLen - 3 + textOffsetLength))}...`;
        }
        return textContent;
      }
      return textContent;
    });
    const computeMaps = {};
    const $xeTextEllipsis = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $textEllipsis: $xeTextEllipsis }, params));
    };
    const calculateFont = (targetWidth) => {
      const el2 = refElem.value;
      const ryEl = realityElem.value;
      if (el2 && ryEl) {
        let fontSize = 12;
        try {
          fontSize = Math.max(10, import_xe_utils153.default.toNumber(getComputedStyle(ryEl).fontSize));
        } catch (e16) {
        }
        const textContent = computeTextContent.value;
        let currIndex = Math.floor(targetWidth / fontSize);
        let currStr = textContent.slice(0, currIndex);
        ryEl.textContent = currStr;
        reactData.visibleLen = currStr.length;
        let maxCount = 0;
        while (targetWidth > ryEl.clientWidth && maxCount < 30) {
          maxCount++;
          const offsetIndex = Math.floor((targetWidth - ryEl.clientWidth) / fontSize);
          if (offsetIndex) {
            currIndex += offsetIndex;
            currStr = textContent.slice(0, currIndex);
            ryEl.textContent = currStr;
            reactData.visibleLen = currStr.length;
          } else {
            break;
          }
        }
        ryEl.textContent = "";
        ryEl.style.display = "";
        ryEl.style.position = "";
        ryEl.style.top = "";
        ryEl.style.left = "";
      }
    };
    const updateStyle = () => {
      const el2 = refElem.value;
      const ryEl = realityElem.value;
      const textContent = computeTextContent.value;
      const textLineClamp = computeTextLineClamp.value;
      if (el2 && ryEl) {
        const cWidth = el2.clientWidth;
        ryEl.style.display = "block";
        ryEl.style.position = "absolute";
        ryEl.style.top = "-3000px";
        ryEl.style.left = "-3000px";
        ryEl.textContent = textContent;
        const sWidth = ryEl.offsetWidth;
        const targetWidth = Math.floor(cWidth * textLineClamp);
        if (targetWidth > sWidth) {
          reactData.visibleLen = textContent.length;
        } else {
          calculateFont(targetWidth);
        }
      } else {
        reactData.visibleLen = textContent.length;
      }
    };
    const textEllipsisMethods = {
      dispatchEvent: dispatchEvent2
    };
    const clickEvent = () => {
      emit("click", {});
    };
    const initObserver = () => {
      const { resizeObserver } = reactData;
      const textLineClamp = computeTextLineClamp.value;
      if (!resizeObserver) {
        const el2 = refElem.value;
        if (el2 && textLineClamp > 1) {
          if (window.ResizeObserver) {
            const observerObj = new window.ResizeObserver(import_xe_utils153.default.throttle(() => {
              updateStyle();
            }, 300, { leading: true, trailing: true }));
            observerObj.observe(el2);
            reactData.resizeObserver = observerObj;
          }
        }
      }
    };
    const textEllipsisPrivateMethods = {};
    Object.assign($xeTextEllipsis, textEllipsisMethods, textEllipsisPrivateMethods);
    const renderVN = () => {
      const { loading: loading2, status, title } = props;
      const vSize = computeSize.value;
      const visibleContent = computeVisibleContent.value;
      const textLineClamp = computeTextLineClamp.value;
      return h("div", {
        ref: refElem,
        class: ["vxe-text-ellipsis", textLineClamp > 1 ? "is--multi" : "is--single", {
          [`size--${vSize}`]: vSize,
          [`theme--${status}`]: status,
          "is--loading": loading2
        }],
        title,
        onClick: clickEvent
      }, [
        h("span", {
          ref: realityElem,
          class: "vxe-text-ellipsis-reality"
        }),
        h("span", {
          class: "vxe-text-ellipsis-content"
        }, visibleContent)
      ]);
    };
    watch(() => props.content, () => {
      updateStyle();
    });
    watch(() => props.lineClamp, () => {
      initObserver();
      updateStyle();
    });
    onMounted(() => {
      initObserver();
      updateStyle();
    });
    onBeforeUnmount(() => {
      const { resizeObserver } = reactData;
      const el2 = refElem.value;
      const ryEl = realityElem.value;
      if (ryEl) {
        ryEl.textContent = "";
      }
      if (resizeObserver) {
        if (el2) {
          resizeObserver.unobserve(el2);
        }
        resizeObserver.disconnect();
        reactData.resizeObserver = null;
      }
    });
    $xeTextEllipsis.renderVN = renderVN;
    return $xeTextEllipsis;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/text-ellipsis/index.js
var VxeTextEllipsis = Object.assign({}, text_ellipsis_default, {
  install(app) {
    app.component(text_ellipsis_default.name, text_ellipsis_default);
  }
});
dynamicApp.use(VxeTextEllipsis);
VxeUI.component(text_ellipsis_default);
var TextEllipsis = VxeTextEllipsis;
var text_ellipsis_default2 = VxeTextEllipsis;

// node_modules/vxe-pc-ui/es/text/index.js
var VxeText = Object.assign({}, text_default, {
  install(app) {
    app.component(text_default.name, text_default);
  }
});
dynamicApp.use(VxeText);
VxeUI.component(text_default);
var Text2 = VxeText;
var text_default2 = VxeText;

// node_modules/vxe-pc-ui/es/textarea/index.js
var VxeTextarea = Object.assign(textarea_default, {
  install: function(app) {
    app.component(textarea_default.name, textarea_default);
  }
});
dynamicApp.use(VxeTextarea);
VxeUI.component(textarea_default);
var Textarea = VxeTextarea;
var textarea_default2 = VxeTextarea;

// node_modules/vxe-pc-ui/es/tip/index.js
var VxeTip = Object.assign({}, tip_default, {
  install(app) {
    app.component(tip_default.name, tip_default);
    app.component("VxeTipsComponent", tip_default);
  }
});
dynamicApp.use(VxeTip);
VxeUI.component(tip_default);
var Tips = VxeTip;
var Tip = VxeTip;
var tip_default2 = VxeTip;

// node_modules/vxe-pc-ui/es/tooltip/index.js
var VxeTooltip = Object.assign({}, tooltip_default, {
  install(app) {
    app.component(tooltip_default.name, tooltip_default);
  }
});
dynamicApp.use(VxeTooltip);
VxeUI.component(tooltip_default);
var Tooltip = VxeTooltip;
var tooltip_default2 = VxeTooltip;

// node_modules/vxe-pc-ui/es/tree/index.js
var VxeTree = Object.assign({}, tree_default, {
  install(app) {
    app.component(tree_default.name, tree_default);
  }
});
dynamicApp.use(VxeTree);
VxeUI.component(tree_default);
var Tree = VxeTree;
var tree_default2 = VxeTree;

// node_modules/vxe-pc-ui/es/tree-select/index.js
var VxeTreeSelect = Object.assign({}, tree_select_default, {
  install(app) {
    app.component(tree_select_default.name, tree_select_default);
  }
});
dynamicApp.use(VxeTreeSelect);
VxeUI.component(tree_select_default);
var TreeSelect = VxeTreeSelect;
var tree_select_default2 = VxeTreeSelect;

// node_modules/vxe-pc-ui/es/upload/index.js
var VxeUpload = Object.assign({}, upload_default, {
  install(app) {
    app.component(upload_default.name, upload_default);
  }
});
dynamicApp.use(VxeUpload);
VxeUI.component(upload_default);
VxeUI.saveFile = saveLocalFile;
VxeUI.readFile = readLocalFile;
var Upload = VxeUpload;
var upload_default2 = VxeUpload;

// node_modules/vxe-pc-ui/es/watermark/src/watermark.js
var import_xe_utils155 = __toESM(require_xe_utils());

// node_modules/vxe-pc-ui/es/watermark/src/util.js
var import_xe_utils154 = __toESM(require_xe_utils());
var canvasEl = null;
var fontEl = null;
var fontCacheMaps = {};
function getMarkCanvas() {
  if (!canvasEl) {
    canvasEl = document.createElement("canvas");
    canvasEl.style.position = "absolute";
    canvasEl.style.top = "0";
    canvasEl.style.left = "0";
  }
  return canvasEl;
}
function removeMarkElement(elem) {
  if (elem) {
    const parentEl2 = elem.parentNode;
    if (parentEl2) {
      parentEl2.removeChild(elem);
    }
  }
}
function calcFontWH(text, fontSize) {
  const fKey = `${fontSize}_${text}`;
  if (!fontCacheMaps[fKey]) {
    if (!fontEl) {
      fontEl = document.createElement("span");
    }
    if (!fontEl.parentNode) {
      document.body.append(fontEl);
    }
    fontEl.textContent = text;
    fontEl.style.fontSize = toCssUnit(fontSize);
    const width = fontEl.offsetWidth;
    const height = fontEl.offsetHeight;
    fontCacheMaps[fKey] = {
      width,
      height
    };
  }
  return fontCacheMaps[fKey];
}
function calcContentWH(contList) {
  let contentWidth = 0;
  let contentHeight = 0;
  contList.forEach((item) => {
    contentWidth = Math.max(item.width, contentWidth);
    contentHeight = Math.max(item.height, contentHeight);
  });
  return {
    contentWidth,
    contentHeight
  };
}
function calcCanvasWH(contentWidth, opts) {
  const { gap } = opts;
  const [gapX = 0, gapY = 0] = gap ? import_xe_utils154.default.isArray(gap) ? gap : [gap, gap] : [];
  const canvasWidth = contentWidth + import_xe_utils154.default.toNumber(gapX);
  const canvasHeight = contentWidth + import_xe_utils154.default.toNumber(gapY);
  return {
    canvasWidth,
    canvasHeight
  };
}
function getFontConf(item, key, opts) {
  return (item.font ? item.font[key] : "") || (opts.font ? opts.font[key] : "");
}
function createMarkFont(contConf, defaultFontSize, opts) {
  const { offset } = opts;
  const text = import_xe_utils154.default.toValueString(contConf.textContent);
  const fontSize = import_xe_utils154.default.toNumber(getFontConf(contConf, "fontSize", opts) || defaultFontSize) || 14;
  const [offsetX = 0, offsetY = 0] = offset ? import_xe_utils154.default.isArray(offset) ? offset : [offset, offset] : [];
  const { width, height } = calcFontWH(text, fontSize);
  return {
    text,
    fontSize,
    font: contConf.font,
    width: width + import_xe_utils154.default.toNumber(offsetX),
    height: height + import_xe_utils154.default.toNumber(offsetY)
  };
}
function drayFont(ctx, item, opts) {
  const fontWeight = getFontConf(item, "fontWeight", opts);
  ctx.fillStyle = `${getFontConf(item, "color", opts) || "rgba(0, 0, 0, 0.15)"}`;
  ctx.font = [
    getFontConf(item, "fontStyle", opts) || "normal",
    fontWeight === "bold" || fontWeight === "bolder" ? "bold" : "",
    toCssUnit(item.fontSize),
    getFontConf(item, "fontFamily", opts) || "sans-serif"
  ].join(" ");
}
function getContentUrl(content, defaultFontSize, options) {
  const opts = Object.assign({}, options);
  const { rotate } = opts;
  const deg = import_xe_utils154.default.toNumber(rotate);
  const contList = (import_xe_utils154.default.isArray(content) ? content : [content]).map((item) => {
    if (item) {
      if (item.textContent) {
        return createMarkFont(item, defaultFontSize, opts);
      }
      return createMarkFont({
        textContent: `${item}`
      }, defaultFontSize, opts);
    }
    return createMarkFont({
      textContent: ""
    }, defaultFontSize, opts);
  });
  removeMarkElement(fontEl);
  return new Promise((resolve) => {
    const canvasEl2 = getMarkCanvas();
    if (!canvasEl2.parentNode) {
      document.body.append(canvasEl2);
    }
    const ctx = canvasEl2.getContext("2d");
    if (ctx && contList.length) {
      const { contentWidth, contentHeight } = calcContentWH(contList);
      const { canvasWidth, canvasHeight } = calcCanvasWH(contentWidth, opts);
      canvasEl2.width = canvasWidth;
      canvasEl2.height = canvasHeight;
      const x = (canvasWidth - contentWidth) / 2;
      const y = (canvasHeight - contentHeight) / 2;
      const drayX = x + contentWidth / 2;
      const drayY = y + contentHeight / 2;
      ctx.save();
      ctx.translate(drayX, drayY);
      ctx.rotate(deg * Math.PI / 180);
      ctx.translate(-drayX, -drayY);
      let offsetHeight = 0;
      contList.forEach((item) => {
        const align = getFontConf(item, "align", opts);
        drayFont(ctx, item, opts);
        ctx.fillText(item.text, x + (align === "center" ? (contentWidth - item.width) / 2 : 0), y + (contentHeight + contentHeight) / 2 + offsetHeight, contentWidth);
        offsetHeight += item.height;
      });
      ctx.restore();
      resolve(canvasEl2.toDataURL());
      removeMarkElement(canvasEl2);
    } else {
      resolve("");
      removeMarkElement(canvasEl2);
    }
  });
}

// node_modules/vxe-pc-ui/es/watermark/src/watermark.js
var watermark_default = defineComponent({
  name: "VxeWatermark",
  props: {
    width: String,
    height: String,
    imageUrl: String,
    rotate: {
      type: [Number, String],
      default: () => getConfig().watermark.rotate
    },
    gap: {
      type: [Array, Number, String],
      default: () => import_xe_utils155.default.clone(getConfig().watermark.gap, true)
    },
    content: [String, Array],
    font: Object,
    offset: Object,
    zIndex: [String, Number]
  },
  emits: [],
  setup(props, context) {
    const { emit } = context;
    const xID = import_xe_utils155.default.uniqueId();
    const refElem = ref();
    const reactData = reactive({
      markUrl: ""
    });
    const refMaps = {
      refElem
    };
    const computeFontOpts = computed(() => {
      return import_xe_utils155.default.assign({}, import_xe_utils155.default.clone(getConfig().watermark.font, true), props.font);
    });
    const computeWrapperStyle = computed(() => {
      const { width, height, zIndex } = props;
      const { markUrl } = reactData;
      const stys = {};
      if (width) {
        stys.width = toCssUnit(width);
      }
      if (height) {
        stys.height = toCssUnit(height);
      }
      if (markUrl) {
        stys.backgroundImage = `url(${markUrl})`;
      }
      if (zIndex) {
        stys.zIndex = zIndex;
      }
      return stys;
    });
    const computeMaps = {};
    const $xeWatermark = {
      xID,
      props,
      context,
      reactData,
      getRefMaps: () => refMaps,
      getComputeMaps: () => computeMaps
    };
    const dispatchEvent2 = (type, params, evnt) => {
      emit(type, createEvent(evnt, { $watermark: $xeWatermark }, params));
    };
    const collapsePaneMethods = {
      dispatchEvent: dispatchEvent2
    };
    const updateMarkStyle = () => {
      const { content, gap, rotate, offset } = props;
      const el2 = refElem.value;
      const fontOpts = computeFontOpts.value;
      if (el2) {
        if (content) {
          getContentUrl(content, getComputedStyle(el2).fontSize, {
            font: fontOpts,
            rotate,
            gap,
            offset
          }).then((url) => {
            reactData.markUrl = url;
          });
        }
      }
    };
    const collapsePanePrivateMethods = {};
    Object.assign($xeWatermark, collapsePaneMethods, collapsePanePrivateMethods);
    const renderVN = () => {
      const wrapperStyle = computeWrapperStyle.value;
      return h("div", {
        ref: refElem,
        class: "vxe-watermark",
        style: wrapperStyle
      });
    };
    watch(() => props.imageUrl, () => {
      updateMarkStyle();
    });
    watch(() => props.content, () => {
      updateMarkStyle();
    });
    watch(() => props.gap, () => {
      updateMarkStyle();
    });
    watch(() => props.rotate, () => {
      updateMarkStyle();
    });
    watch(() => props.width, () => {
      updateMarkStyle();
    });
    watch(() => props.height, () => {
      updateMarkStyle();
    });
    watch(() => props.font, () => {
      updateMarkStyle();
    });
    onMounted(() => {
      updateMarkStyle();
      globalEvents.on($xeWatermark, "resize", import_xe_utils155.default.throttle(() => {
        updateMarkStyle();
      }, 300, { trailing: true, leading: true }));
    });
    onUnmounted(() => {
      globalEvents.off($xeWatermark, "resize");
    });
    $xeWatermark.renderVN = renderVN;
    return $xeWatermark;
  },
  render() {
    return this.renderVN();
  }
});

// node_modules/vxe-pc-ui/es/watermark/index.js
var VxeWatermark = Object.assign({}, watermark_default, {
  install(app) {
    app.component(watermark_default.name, watermark_default);
  }
});
dynamicApp.use(VxeWatermark);
VxeUI.component(watermark_default);
var WatermarkController = {
  load(options) {
    checkDynamic();
    dynamicStore.globalWatermark = Object.assign({}, options);
    return Promise.resolve();
  },
  clear() {
    dynamicStore.globalWatermark = null;
    return Promise.resolve();
  }
};
VxeUI.watermark = WatermarkController;
var Watermark = VxeWatermark;
var watermark_default2 = VxeWatermark;

// node_modules/vxe-pc-ui/es/components.js
var components3 = [
  alert_default2,
  anchor_default2,
  anchor_link_default2,
  avatar_default2,
  badge_default2,
  breadcrumb_default2,
  breadcrumb_item_default2,
  button_default2,
  button_group_default2,
  calendar_default2,
  card_default2,
  carousel_default2,
  carousel_item_default2,
  checkbox_default2,
  checkbox_group_default,
  col_default2,
  collapse_default2,
  collapse_pane_default2,
  color_picker_default2,
  countdown_default2,
  date_picker_default2,
  drawer_default2,
  empty_default2,
  form_default2,
  form_design_default2,
  form_gather_default,
  form_group_default2,
  form_item_default2,
  form_view_default2,
  icon_default2,
  icon_picker_default2,
  image_default2,
  image_group_default,
  image_preview_default,
  input_default2,
  layout_aside_default2,
  layout_body_default2,
  layout_container_default2,
  layout_footer_default2,
  layout_header_default2,
  link_default2,
  list_design_default2,
  list_view_default2,
  list_default2,
  loading_default2,
  menu_default2,
  modal_default2,
  notice_bar_default2,
  number_input_default2,
  optgroup_default2,
  option_default2,
  pager_default2,
  password_input_default2,
  print_page_break_default,
  print_default2,
  pulldown_default2,
  radio_default2,
  radio_button_default,
  radio_group_default,
  rate_default2,
  result_default2,
  row_default2,
  select_default2,
  slider_default2,
  steps_default2,
  switch_default2,
  tab_pane_default2,
  table_select_default2,
  tabs_default2,
  tag_default2,
  text_ellipsis_default2,
  text_default2,
  textarea_default2,
  tip_default2,
  tooltip_default2,
  tree_default2,
  tree_select_default2,
  upload_default2,
  watermark_default2
];
function install2(app, options) {
  setConfig(options);
  components3.forEach((component2) => app.use(component2));
}
var defaultLanguage = "zh-CN";
setI18n(defaultLanguage, zh_CN_default2);
setLanguage(defaultLanguage);
setTheme("light");
var loading = LoadingController;
var modal2 = ModalController;
var drawer = DrawerController;
var watermark = WatermarkController;
var print2 = printHtml;
var saveFile2 = saveLocalFile;
var readFile2 = readLocalFile;

// node_modules/vxe-pc-ui/es/index.esm.js
var index_esm_default3 = components_exports2;

// node_modules/@intlify/shared/dist/shared.mjs
var inBrowser = typeof window !== "undefined";
var mark;
var measure;
if (true) {
  const perf2 = inBrowser && window.performance;
  if (perf2 && perf2.mark && perf2.measure && perf2.clearMarks && // @ts-ignore browser compat
  perf2.clearMeasures) {
    mark = (tag) => {
      perf2.mark(tag);
    };
    measure = (name, startTag, endTag) => {
      perf2.measure(name, startTag, endTag);
      perf2.clearMarks(startTag);
      perf2.clearMarks(endTag);
    };
  }
}
var RE_ARGS = /\{([0-9a-zA-Z]+)\}/g;
function format(message, ...args) {
  if (args.length === 1 && isObject(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
var makeSymbol = (name, shareable = false) => !shareable ? Symbol(name) : Symbol.for(name);
var generateFormatCacheKey = (locale, key, source) => friendlyJSONstringify({ l: locale, k: key, s: source });
var friendlyJSONstringify = (json) => JSON.stringify(json).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029").replace(/\u0027/g, "\\u0027");
var isNumber = (val) => typeof val === "number" && isFinite(val);
var isDate = (val) => toTypeString(val) === "[object Date]";
var isRegExp = (val) => toTypeString(val) === "[object RegExp]";
var isEmptyObject = (val) => isPlainObject(val) && Object.keys(val).length === 0;
var assign = Object.assign;
var _create = Object.create;
var create = (obj = null) => _create(obj);
var _globalThis;
var getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : create());
};
function escapeHtml(rawText) {
  return rawText.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}
var isArray = Array.isArray;
var isFunction = (val) => typeof val === "function";
var isString = (val) => typeof val === "string";
var isBoolean = (val) => typeof val === "boolean";
var isObject = (val) => val !== null && typeof val === "object";
var isPromise = (val) => {
  return isObject(val) && isFunction(val.then) && isFunction(val.catch);
};
var objectToString = Object.prototype.toString;
var toTypeString = (value) => objectToString.call(value);
var isPlainObject = (val) => {
  if (!isObject(val))
    return false;
  const proto = Object.getPrototypeOf(val);
  return proto === null || proto.constructor === Object;
};
var toDisplayString2 = (val) => {
  return val == null ? "" : isArray(val) || isPlainObject(val) && val.toString === objectToString ? JSON.stringify(val, null, 2) : String(val);
};
function join(items, separator = "") {
  return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
var RANGE = 2;
function generateCodeFrame(source, start = 0, end = source.length) {
  const lines = source.split(/\r?\n/);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length + 1;
    if (count >= start) {
      for (let j = i - RANGE; j <= i + RANGE || end > count; j++) {
        if (j < 0 || j >= lines.length)
          continue;
        const line = j + 1;
        res.push(`${line}${" ".repeat(3 - String(line).length)}|  ${lines[j]}`);
        const lineLength = lines[j].length;
        if (j === i) {
          const pad = start - (count - lineLength) + 1;
          const length = Math.max(1, end > count ? lineLength - pad : end - start);
          res.push(`   |  ` + " ".repeat(pad) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
  }
  return res.join("\n");
}
function incrementer(code3) {
  let current = code3;
  return () => ++current;
}
function warn(msg, err) {
  if (typeof console !== "undefined") {
    console.warn(`[intlify] ` + msg);
    if (err) {
      console.warn(err.stack);
    }
  }
}
var hasWarned = {};
function warnOnce(msg) {
  if (!hasWarned[msg]) {
    hasWarned[msg] = true;
    warn(msg);
  }
}
function createEmitter() {
  const events = /* @__PURE__ */ new Map();
  const emitter = {
    events,
    on(event, handler) {
      const handlers = events.get(event);
      const added = handlers && handlers.push(handler);
      if (!added) {
        events.set(event, [handler]);
      }
    },
    off(event, handler) {
      const handlers = events.get(event);
      if (handlers) {
        handlers.splice(handlers.indexOf(handler) >>> 0, 1);
      }
    },
    emit(event, payload) {
      (events.get(event) || []).slice().map((handler) => handler(payload));
      (events.get("*") || []).slice().map((handler) => handler(event, payload));
    }
  };
  return emitter;
}
var isNotObjectOrIsArray = (val) => !isObject(val) || isArray(val);
function deepCopy(src, des) {
  if (isNotObjectOrIsArray(src) || isNotObjectOrIsArray(des)) {
    throw new Error("Invalid value");
  }
  const stack = [{ src, des }];
  while (stack.length) {
    const { src: src2, des: des2 } = stack.pop();
    Object.keys(src2).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isObject(src2[key]) && !isObject(des2[key])) {
        des2[key] = Array.isArray(src2[key]) ? [] : create();
      }
      if (isNotObjectOrIsArray(des2[key]) || isNotObjectOrIsArray(src2[key])) {
        des2[key] = src2[key];
      } else {
        stack.push({ src: src2[key], des: des2[key] });
      }
    });
  }
}

// node_modules/@intlify/message-compiler/dist/message-compiler.esm-browser.js
function createPosition(line, column, offset) {
  return { line, column, offset };
}
function createLocation(start, end, source) {
  const loc = { start, end };
  if (source != null) {
    loc.source = source;
  }
  return loc;
}
var RE_ARGS2 = /\{([0-9a-zA-Z]+)\}/g;
function format2(message, ...args) {
  if (args.length === 1 && isObject2(args[0])) {
    args = args[0];
  }
  if (!args || !args.hasOwnProperty) {
    args = {};
  }
  return message.replace(RE_ARGS2, (match, identifier) => {
    return args.hasOwnProperty(identifier) ? args[identifier] : "";
  });
}
var assign2 = Object.assign;
var isString2 = (val) => typeof val === "string";
var isObject2 = (val) => val !== null && typeof val === "object";
function join2(items, separator = "") {
  return items.reduce((str, item, index2) => index2 === 0 ? str + item : str + separator + item, "");
}
var CompileWarnCodes = {
  USE_MODULO_SYNTAX: 1,
  __EXTEND_POINT__: 2
};
var warnMessages = {
  [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`
};
function createCompileWarn(code3, loc, ...args) {
  const msg = format2(warnMessages[code3] || "", ...args || []);
  const message = { message: String(msg), code: code3 };
  if (loc) {
    message.location = loc;
  }
  return message;
}
var CompileErrorCodes = {
  // tokenizer error codes
  EXPECTED_TOKEN: 1,
  INVALID_TOKEN_IN_PLACEHOLDER: 2,
  UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,
  UNKNOWN_ESCAPE_SEQUENCE: 4,
  INVALID_UNICODE_ESCAPE_SEQUENCE: 5,
  UNBALANCED_CLOSING_BRACE: 6,
  UNTERMINATED_CLOSING_BRACE: 7,
  EMPTY_PLACEHOLDER: 8,
  NOT_ALLOW_NEST_PLACEHOLDER: 9,
  INVALID_LINKED_FORMAT: 10,
  // parser error codes
  MUST_HAVE_MESSAGES_IN_PLURAL: 11,
  UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,
  UNEXPECTED_EMPTY_LINKED_KEY: 13,
  UNEXPECTED_LEXICAL_ANALYSIS: 14,
  // generator error codes
  UNHANDLED_CODEGEN_NODE_TYPE: 15,
  // minifier error codes
  UNHANDLED_MINIFIER_NODE_TYPE: 16,
  // Special value for higher-order compilers to pick up the last code
  // to avoid collision of error codes. This should always be kept as the last
  // item.
  __EXTEND_POINT__: 17
};
var errorMessages = {
  // tokenizer error messages
  [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,
  [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,
  [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,
  [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\{0}`,
  [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,
  [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,
  [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,
  [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,
  [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,
  [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,
  // parser error messages
  [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,
  [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,
  [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,
  // generator error messages
  [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,
  // minimizer error messages
  [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`
};
function createCompileError(code3, loc, options = {}) {
  const { domain, messages, args } = options;
  const msg = format2((messages || errorMessages)[code3] || "", ...args || []);
  const error = new SyntaxError(String(msg));
  error.code = code3;
  if (loc) {
    error.location = loc;
  }
  error.domain = domain;
  return error;
}
function defaultOnError(error) {
  throw error;
}
var RE_HTML_TAG = /<\/?[\w\s="/.':;#-\/]+>/;
var detectHtmlTag = (source) => RE_HTML_TAG.test(source);
var CHAR_SP = " ";
var CHAR_CR = "\r";
var CHAR_LF = "\n";
var CHAR_LS = String.fromCharCode(8232);
var CHAR_PS = String.fromCharCode(8233);
function createScanner(str) {
  const _buf = str;
  let _index = 0;
  let _line = 1;
  let _column = 1;
  let _peekOffset = 0;
  const isCRLF = (index3) => _buf[index3] === CHAR_CR && _buf[index3 + 1] === CHAR_LF;
  const isLF = (index3) => _buf[index3] === CHAR_LF;
  const isPS = (index3) => _buf[index3] === CHAR_PS;
  const isLS = (index3) => _buf[index3] === CHAR_LS;
  const isLineEnd = (index3) => isCRLF(index3) || isLF(index3) || isPS(index3) || isLS(index3);
  const index2 = () => _index;
  const line = () => _line;
  const column = () => _column;
  const peekOffset = () => _peekOffset;
  const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];
  const currentChar = () => charAt(_index);
  const currentPeek = () => charAt(_index + _peekOffset);
  function next() {
    _peekOffset = 0;
    if (isLineEnd(_index)) {
      _line++;
      _column = 0;
    }
    if (isCRLF(_index)) {
      _index++;
    }
    _index++;
    _column++;
    return _buf[_index];
  }
  function peek() {
    if (isCRLF(_index + _peekOffset)) {
      _peekOffset++;
    }
    _peekOffset++;
    return _buf[_index + _peekOffset];
  }
  function reset() {
    _index = 0;
    _line = 1;
    _column = 1;
    _peekOffset = 0;
  }
  function resetPeek(offset = 0) {
    _peekOffset = offset;
  }
  function skipToPeek() {
    const target = _index + _peekOffset;
    while (target !== _index) {
      next();
    }
    _peekOffset = 0;
  }
  return {
    index: index2,
    line,
    column,
    peekOffset,
    charAt,
    currentChar,
    currentPeek,
    next,
    peek,
    reset,
    resetPeek,
    skipToPeek
  };
}
var EOF = void 0;
var DOT = ".";
var LITERAL_DELIMITER = "'";
var ERROR_DOMAIN$3 = "tokenizer";
function createTokenizer(source, options = {}) {
  const location2 = options.location !== false;
  const _scnr = createScanner(source);
  const currentOffset = () => _scnr.index();
  const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());
  const _initLoc = currentPosition();
  const _initOffset = currentOffset();
  const _context = {
    currentType: 14,
    offset: _initOffset,
    startLoc: _initLoc,
    endLoc: _initLoc,
    lastType: 14,
    lastOffset: _initOffset,
    lastStartLoc: _initLoc,
    lastEndLoc: _initLoc,
    braceNest: 0,
    inLinked: false,
    text: ""
  };
  const context = () => _context;
  const { onError } = options;
  function emitError(code3, pos, offset, ...args) {
    const ctx = context();
    pos.column += offset;
    pos.offset += offset;
    if (onError) {
      const loc = location2 ? createLocation(ctx.startLoc, pos) : null;
      const err = createCompileError(code3, loc, {
        domain: ERROR_DOMAIN$3,
        args
      });
      onError(err);
    }
  }
  function getToken(context2, type, value) {
    context2.endLoc = currentPosition();
    context2.currentType = type;
    const token = { type };
    if (location2) {
      token.loc = createLocation(context2.startLoc, context2.endLoc);
    }
    if (value != null) {
      token.value = value;
    }
    return token;
  }
  const getEndToken = (context2) => getToken(
    context2,
    14
    /* TokenTypes.EOF */
  );
  function eat(scnr, ch2) {
    if (scnr.currentChar() === ch2) {
      scnr.next();
      return ch2;
    } else {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch2);
      return "";
    }
  }
  function peekSpaces(scnr) {
    let buf = "";
    while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {
      buf += scnr.currentPeek();
      scnr.peek();
    }
    return buf;
  }
  function skipSpaces(scnr) {
    const buf = peekSpaces(scnr);
    scnr.skipToPeek();
    return buf;
  }
  function isIdentifierStart(ch2) {
    if (ch2 === EOF) {
      return false;
    }
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 97 && cc2 <= 122 || // a-z
    cc2 >= 65 && cc2 <= 90 || // A-Z
    cc2 === 95;
  }
  function isNumberStart(ch2) {
    if (ch2 === EOF) {
      return false;
    }
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 48 && cc2 <= 57;
  }
  function isNamedIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isListIdentifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ch2 = scnr.currentPeek() === "-" ? scnr.peek() : scnr.currentPeek();
    const ret = isNumberStart(ch2);
    scnr.resetPeek();
    return ret;
  }
  function isLiteralStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 2) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === LITERAL_DELIMITER;
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDotStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 8) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ".";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedModifierStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 9) {
      return false;
    }
    peekSpaces(scnr);
    const ret = isIdentifierStart(scnr.currentPeek());
    scnr.resetPeek();
    return ret;
  }
  function isLinkedDelimiterStart(scnr, context2) {
    const { currentType } = context2;
    if (!(currentType === 8 || currentType === 12)) {
      return false;
    }
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === ":";
    scnr.resetPeek();
    return ret;
  }
  function isLinkedReferStart(scnr, context2) {
    const { currentType } = context2;
    if (currentType !== 10) {
      return false;
    }
    const fn2 = () => {
      const ch2 = scnr.currentPeek();
      if (ch2 === "{") {
        return isIdentifierStart(scnr.peek());
      } else if (ch2 === "@" || ch2 === "%" || ch2 === "|" || ch2 === ":" || ch2 === "." || ch2 === CHAR_SP || !ch2) {
        return false;
      } else if (ch2 === CHAR_LF) {
        scnr.peek();
        return fn2();
      } else {
        return isTextStart(scnr, false);
      }
    };
    const ret = fn2();
    scnr.resetPeek();
    return ret;
  }
  function isPluralStart(scnr) {
    peekSpaces(scnr);
    const ret = scnr.currentPeek() === "|";
    scnr.resetPeek();
    return ret;
  }
  function detectModuloStart(scnr) {
    const spaces = peekSpaces(scnr);
    const ret = scnr.currentPeek() === "%" && scnr.peek() === "{";
    scnr.resetPeek();
    return {
      isModulo: ret,
      hasSpace: spaces.length > 0
    };
  }
  function isTextStart(scnr, reset = true) {
    const fn2 = (hasSpace = false, prev = "", detectModulo = false) => {
      const ch2 = scnr.currentPeek();
      if (ch2 === "{") {
        return prev === "%" ? false : hasSpace;
      } else if (ch2 === "@" || !ch2) {
        return prev === "%" ? true : hasSpace;
      } else if (ch2 === "%") {
        scnr.peek();
        return fn2(hasSpace, "%", true);
      } else if (ch2 === "|") {
        return prev === "%" || detectModulo ? true : !(prev === CHAR_SP || prev === CHAR_LF);
      } else if (ch2 === CHAR_SP) {
        scnr.peek();
        return fn2(true, CHAR_SP, detectModulo);
      } else if (ch2 === CHAR_LF) {
        scnr.peek();
        return fn2(true, CHAR_LF, detectModulo);
      } else {
        return true;
      }
    };
    const ret = fn2();
    reset && scnr.resetPeek();
    return ret;
  }
  function takeChar(scnr, fn2) {
    const ch2 = scnr.currentChar();
    if (ch2 === EOF) {
      return EOF;
    }
    if (fn2(ch2)) {
      scnr.next();
      return ch2;
    }
    return null;
  }
  function isIdentifier(ch2) {
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 97 && cc2 <= 122 || // a-z
    cc2 >= 65 && cc2 <= 90 || // A-Z
    cc2 >= 48 && cc2 <= 57 || // 0-9
    cc2 === 95 || // _
    cc2 === 36;
  }
  function takeIdentifierChar(scnr) {
    return takeChar(scnr, isIdentifier);
  }
  function isNamedIdentifier(ch2) {
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 97 && cc2 <= 122 || // a-z
    cc2 >= 65 && cc2 <= 90 || // A-Z
    cc2 >= 48 && cc2 <= 57 || // 0-9
    cc2 === 95 || // _
    cc2 === 36 || // $
    cc2 === 45;
  }
  function takeNamedIdentifierChar(scnr) {
    return takeChar(scnr, isNamedIdentifier);
  }
  function isDigit(ch2) {
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 48 && cc2 <= 57;
  }
  function takeDigit(scnr) {
    return takeChar(scnr, isDigit);
  }
  function isHexDigit(ch2) {
    const cc2 = ch2.charCodeAt(0);
    return cc2 >= 48 && cc2 <= 57 || // 0-9
    cc2 >= 65 && cc2 <= 70 || // A-F
    cc2 >= 97 && cc2 <= 102;
  }
  function takeHexDigit(scnr) {
    return takeChar(scnr, isHexDigit);
  }
  function getDigits(scnr) {
    let ch2 = "";
    let num = "";
    while (ch2 = takeDigit(scnr)) {
      num += ch2;
    }
    return num;
  }
  function readModulo(scnr) {
    skipSpaces(scnr);
    const ch2 = scnr.currentChar();
    if (ch2 !== "%") {
      emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch2);
    }
    scnr.next();
    return "%";
  }
  function readText(scnr) {
    let buf = "";
    while (true) {
      const ch2 = scnr.currentChar();
      if (ch2 === "{" || ch2 === "}" || ch2 === "@" || ch2 === "|" || !ch2) {
        break;
      } else if (ch2 === "%") {
        if (isTextStart(scnr)) {
          buf += ch2;
          scnr.next();
        } else {
          break;
        }
      } else if (ch2 === CHAR_SP || ch2 === CHAR_LF) {
        if (isTextStart(scnr)) {
          buf += ch2;
          scnr.next();
        } else if (isPluralStart(scnr)) {
          break;
        } else {
          buf += ch2;
          scnr.next();
        }
      } else {
        buf += ch2;
        scnr.next();
      }
    }
    return buf;
  }
  function readNamedIdentifier(scnr) {
    skipSpaces(scnr);
    let ch2 = "";
    let name = "";
    while (ch2 = takeNamedIdentifierChar(scnr)) {
      name += ch2;
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return name;
  }
  function readListIdentifier(scnr) {
    skipSpaces(scnr);
    let value = "";
    if (scnr.currentChar() === "-") {
      scnr.next();
      value += `-${getDigits(scnr)}`;
    } else {
      value += getDigits(scnr);
    }
    if (scnr.currentChar() === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
    }
    return value;
  }
  function isLiteral2(ch2) {
    return ch2 !== LITERAL_DELIMITER && ch2 !== CHAR_LF;
  }
  function readLiteral(scnr) {
    skipSpaces(scnr);
    eat(scnr, `'`);
    let ch2 = "";
    let literal = "";
    while (ch2 = takeChar(scnr, isLiteral2)) {
      if (ch2 === "\\") {
        literal += readEscapeSequence(scnr);
      } else {
        literal += ch2;
      }
    }
    const current = scnr.currentChar();
    if (current === CHAR_LF || current === EOF) {
      emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);
      if (current === CHAR_LF) {
        scnr.next();
        eat(scnr, `'`);
      }
      return literal;
    }
    eat(scnr, `'`);
    return literal;
  }
  function readEscapeSequence(scnr) {
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "\\":
      case `'`:
        scnr.next();
        return `\\${ch2}`;
      case "u":
        return readUnicodeEscapeSequence(scnr, ch2, 4);
      case "U":
        return readUnicodeEscapeSequence(scnr, ch2, 6);
      default:
        emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch2);
        return "";
    }
  }
  function readUnicodeEscapeSequence(scnr, unicode, digits) {
    eat(scnr, unicode);
    let sequence = "";
    for (let i = 0; i < digits; i++) {
      const ch2 = takeHexDigit(scnr);
      if (!ch2) {
        emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\${unicode}${sequence}${scnr.currentChar()}`);
        break;
      }
      sequence += ch2;
    }
    return `\\${unicode}${sequence}`;
  }
  function isInvalidIdentifier(ch2) {
    return ch2 !== "{" && ch2 !== "}" && ch2 !== CHAR_SP && ch2 !== CHAR_LF;
  }
  function readInvalidIdentifier(scnr) {
    skipSpaces(scnr);
    let ch2 = "";
    let identifiers = "";
    while (ch2 = takeChar(scnr, isInvalidIdentifier)) {
      identifiers += ch2;
    }
    return identifiers;
  }
  function readLinkedModifier(scnr) {
    let ch2 = "";
    let name = "";
    while (ch2 = takeIdentifierChar(scnr)) {
      name += ch2;
    }
    return name;
  }
  function readLinkedRefer(scnr) {
    const fn2 = (buf) => {
      const ch2 = scnr.currentChar();
      if (ch2 === "{" || ch2 === "%" || ch2 === "@" || ch2 === "|" || ch2 === "(" || ch2 === ")" || !ch2) {
        return buf;
      } else if (ch2 === CHAR_SP) {
        return buf;
      } else if (ch2 === CHAR_LF || ch2 === DOT) {
        buf += ch2;
        scnr.next();
        return fn2(buf);
      } else {
        buf += ch2;
        scnr.next();
        return fn2(buf);
      }
    };
    return fn2("");
  }
  function readPlural(scnr) {
    skipSpaces(scnr);
    const plural = eat(
      scnr,
      "|"
      /* TokenChars.Pipe */
    );
    skipSpaces(scnr);
    return plural;
  }
  function readTokenInPlaceholder(scnr, context2) {
    let token = null;
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "{":
        if (context2.braceNest >= 1) {
          emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          2,
          "{"
          /* TokenChars.BraceLeft */
        );
        skipSpaces(scnr);
        context2.braceNest++;
        return token;
      case "}":
        if (context2.braceNest > 0 && context2.currentType === 2) {
          emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);
        }
        scnr.next();
        token = getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
        context2.braceNest--;
        context2.braceNest > 0 && skipSpaces(scnr);
        if (context2.inLinked && context2.braceNest === 0) {
          context2.inLinked = false;
        }
        return token;
      case "@":
        if (context2.braceNest > 0) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
        }
        token = readTokenInLinked(scnr, context2) || getEndToken(context2);
        context2.braceNest = 0;
        return token;
      default: {
        let validNamedIdentifier = true;
        let validListIdentifier = true;
        let validLiteral = true;
        if (isPluralStart(scnr)) {
          if (context2.braceNest > 0) {
            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          }
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (context2.braceNest > 0 && (context2.currentType === 5 || context2.currentType === 6 || context2.currentType === 7)) {
          emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);
          context2.braceNest = 0;
          return readToken(scnr, context2);
        }
        if (validNamedIdentifier = isNamedIdentifierStart(scnr, context2)) {
          token = getToken(context2, 5, readNamedIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validListIdentifier = isListIdentifierStart(scnr, context2)) {
          token = getToken(context2, 6, readListIdentifier(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (validLiteral = isLiteralStart(scnr, context2)) {
          token = getToken(context2, 7, readLiteral(scnr));
          skipSpaces(scnr);
          return token;
        }
        if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {
          token = getToken(context2, 13, readInvalidIdentifier(scnr));
          emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);
          skipSpaces(scnr);
          return token;
        }
        break;
      }
    }
    return token;
  }
  function readTokenInLinked(scnr, context2) {
    const { currentType } = context2;
    let token = null;
    const ch2 = scnr.currentChar();
    if ((currentType === 8 || currentType === 9 || currentType === 12 || currentType === 10) && (ch2 === CHAR_LF || ch2 === CHAR_SP)) {
      emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
    }
    switch (ch2) {
      case "@":
        scnr.next();
        token = getToken(
          context2,
          8,
          "@"
          /* TokenChars.LinkedAlias */
        );
        context2.inLinked = true;
        return token;
      case ".":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          9,
          "."
          /* TokenChars.LinkedDot */
        );
      case ":":
        skipSpaces(scnr);
        scnr.next();
        return getToken(
          context2,
          10,
          ":"
          /* TokenChars.LinkedDelimiter */
        );
      default:
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        if (isLinkedDotStart(scnr, context2) || isLinkedDelimiterStart(scnr, context2)) {
          skipSpaces(scnr);
          return readTokenInLinked(scnr, context2);
        }
        if (isLinkedModifierStart(scnr, context2)) {
          skipSpaces(scnr);
          return getToken(context2, 12, readLinkedModifier(scnr));
        }
        if (isLinkedReferStart(scnr, context2)) {
          skipSpaces(scnr);
          if (ch2 === "{") {
            return readTokenInPlaceholder(scnr, context2) || token;
          } else {
            return getToken(context2, 11, readLinkedRefer(scnr));
          }
        }
        if (currentType === 8) {
          emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);
        }
        context2.braceNest = 0;
        context2.inLinked = false;
        return readToken(scnr, context2);
    }
  }
  function readToken(scnr, context2) {
    let token = {
      type: 14
      /* TokenTypes.EOF */
    };
    if (context2.braceNest > 0) {
      return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
    }
    if (context2.inLinked) {
      return readTokenInLinked(scnr, context2) || getEndToken(context2);
    }
    const ch2 = scnr.currentChar();
    switch (ch2) {
      case "{":
        return readTokenInPlaceholder(scnr, context2) || getEndToken(context2);
      case "}":
        emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);
        scnr.next();
        return getToken(
          context2,
          3,
          "}"
          /* TokenChars.BraceRight */
        );
      case "@":
        return readTokenInLinked(scnr, context2) || getEndToken(context2);
      default: {
        if (isPluralStart(scnr)) {
          token = getToken(context2, 1, readPlural(scnr));
          context2.braceNest = 0;
          context2.inLinked = false;
          return token;
        }
        const { isModulo, hasSpace } = detectModuloStart(scnr);
        if (isModulo) {
          return hasSpace ? getToken(context2, 0, readText(scnr)) : getToken(context2, 4, readModulo(scnr));
        }
        if (isTextStart(scnr)) {
          return getToken(context2, 0, readText(scnr));
        }
        break;
      }
    }
    return token;
  }
  function nextToken() {
    const { currentType, offset, startLoc, endLoc } = _context;
    _context.lastType = currentType;
    _context.lastOffset = offset;
    _context.lastStartLoc = startLoc;
    _context.lastEndLoc = endLoc;
    _context.offset = currentOffset();
    _context.startLoc = currentPosition();
    if (_scnr.currentChar() === EOF) {
      return getToken(
        _context,
        14
        /* TokenTypes.EOF */
      );
    }
    return readToken(_scnr, _context);
  }
  return {
    nextToken,
    currentOffset,
    currentPosition,
    context
  };
}
var ERROR_DOMAIN$2 = "parser";
var KNOWN_ESCAPES = /(?:\\\\|\\'|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{6}))/g;
function fromEscapeSequence(match, codePoint4, codePoint6) {
  switch (match) {
    case `\\\\`:
      return `\\`;
    case `\\'`:
      return `'`;
    default: {
      const codePoint = parseInt(codePoint4 || codePoint6, 16);
      if (codePoint <= 55295 || codePoint >= 57344) {
        return String.fromCodePoint(codePoint);
      }
      return "�";
    }
  }
}
function createParser(options = {}) {
  const location2 = options.location !== false;
  const { onError, onWarn } = options;
  function emitError(tokenzer, code3, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onError) {
      const loc = location2 ? createLocation(start, end) : null;
      const err = createCompileError(code3, loc, {
        domain: ERROR_DOMAIN$2,
        args
      });
      onError(err);
    }
  }
  function emitWarn(tokenzer, code3, start, offset, ...args) {
    const end = tokenzer.currentPosition();
    end.offset += offset;
    end.column += offset;
    if (onWarn) {
      const loc = location2 ? createLocation(start, end) : null;
      onWarn(createCompileWarn(code3, loc, args));
    }
  }
  function startNode(type, offset, loc) {
    const node = { type };
    if (location2) {
      node.start = offset;
      node.end = offset;
      node.loc = { start: loc, end: loc };
    }
    return node;
  }
  function endNode(node, offset, pos, type) {
    if (type) {
      node.type = type;
    }
    if (location2) {
      node.end = offset;
      if (node.loc) {
        node.loc.end = pos;
      }
    }
  }
  function parseText(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(3, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseList(tokenizer, index2) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(5, offset, loc);
    node.index = parseInt(index2, 10);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseNamed(tokenizer, key, modulo) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(4, offset, loc);
    node.key = key;
    if (modulo === true) {
      node.modulo = true;
    }
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLiteral(tokenizer, value) {
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(9, offset, loc);
    node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);
    tokenizer.nextToken();
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinkedModifier(tokenizer) {
    const token = tokenizer.nextToken();
    const context = tokenizer.context();
    const { lastOffset: offset, lastStartLoc: loc } = context;
    const node = startNode(8, offset, loc);
    if (token.type !== 12) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);
      node.value = "";
      endNode(node, offset, loc);
      return {
        nextConsumeToken: token,
        node
      };
    }
    if (token.value == null) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    node.value = token.value || "";
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node
    };
  }
  function parseLinkedKey(tokenizer, value) {
    const context = tokenizer.context();
    const node = startNode(7, context.offset, context.startLoc);
    node.value = value;
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseLinked(tokenizer) {
    const context = tokenizer.context();
    const linkedNode = startNode(6, context.offset, context.startLoc);
    let token = tokenizer.nextToken();
    if (token.type === 9) {
      const parsed = parseLinkedModifier(tokenizer);
      linkedNode.modifier = parsed.node;
      token = parsed.nextConsumeToken || tokenizer.nextToken();
    }
    if (token.type !== 10) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
    }
    token = tokenizer.nextToken();
    if (token.type === 2) {
      token = tokenizer.nextToken();
    }
    switch (token.type) {
      case 11:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLinkedKey(tokenizer, token.value || "");
        break;
      case 5:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseNamed(tokenizer, token.value || "");
        break;
      case 6:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseList(tokenizer, token.value || "");
        break;
      case 7:
        if (token.value == null) {
          emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
        }
        linkedNode.key = parseLiteral(tokenizer, token.value || "");
        break;
      default: {
        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);
        const nextContext = tokenizer.context();
        const emptyLinkedKeyNode = startNode(7, nextContext.offset, nextContext.startLoc);
        emptyLinkedKeyNode.value = "";
        endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);
        linkedNode.key = emptyLinkedKeyNode;
        endNode(linkedNode, nextContext.offset, nextContext.startLoc);
        return {
          nextConsumeToken: token,
          node: linkedNode
        };
      }
    }
    endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());
    return {
      node: linkedNode
    };
  }
  function parseMessage(tokenizer) {
    const context = tokenizer.context();
    const startOffset = context.currentType === 1 ? tokenizer.currentOffset() : context.offset;
    const startLoc = context.currentType === 1 ? context.endLoc : context.startLoc;
    const node = startNode(2, startOffset, startLoc);
    node.items = [];
    let nextToken = null;
    let modulo = null;
    do {
      const token = nextToken || tokenizer.nextToken();
      nextToken = null;
      switch (token.type) {
        case 0:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseText(tokenizer, token.value || ""));
          break;
        case 6:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseList(tokenizer, token.value || ""));
          break;
        case 4:
          modulo = true;
          break;
        case 5:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseNamed(tokenizer, token.value || "", !!modulo));
          if (modulo) {
            emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));
            modulo = null;
          }
          break;
        case 7:
          if (token.value == null) {
            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));
          }
          node.items.push(parseLiteral(tokenizer, token.value || ""));
          break;
        case 8: {
          const parsed = parseLinked(tokenizer);
          node.items.push(parsed.node);
          nextToken = parsed.nextConsumeToken || null;
          break;
        }
      }
    } while (context.currentType !== 14 && context.currentType !== 1);
    const endOffset = context.currentType === 1 ? context.lastOffset : tokenizer.currentOffset();
    const endLoc = context.currentType === 1 ? context.lastEndLoc : tokenizer.currentPosition();
    endNode(node, endOffset, endLoc);
    return node;
  }
  function parsePlural(tokenizer, offset, loc, msgNode) {
    const context = tokenizer.context();
    let hasEmptyMessage = msgNode.items.length === 0;
    const node = startNode(1, offset, loc);
    node.cases = [];
    node.cases.push(msgNode);
    do {
      const msg = parseMessage(tokenizer);
      if (!hasEmptyMessage) {
        hasEmptyMessage = msg.items.length === 0;
      }
      node.cases.push(msg);
    } while (context.currentType !== 14);
    if (hasEmptyMessage) {
      emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  function parseResource(tokenizer) {
    const context = tokenizer.context();
    const { offset, startLoc } = context;
    const msgNode = parseMessage(tokenizer);
    if (context.currentType === 14) {
      return msgNode;
    } else {
      return parsePlural(tokenizer, offset, startLoc, msgNode);
    }
  }
  function parse2(source) {
    const tokenizer = createTokenizer(source, assign2({}, options));
    const context = tokenizer.context();
    const node = startNode(0, context.offset, context.startLoc);
    if (location2 && node.loc) {
      node.loc.source = source;
    }
    node.body = parseResource(tokenizer);
    if (options.onCacheKey) {
      node.cacheKey = options.onCacheKey(source);
    }
    if (context.currentType !== 14) {
      emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || "");
    }
    endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());
    return node;
  }
  return { parse: parse2 };
}
function getTokenCaption(token) {
  if (token.type === 14) {
    return "EOF";
  }
  const name = (token.value || "").replace(/\r?\n/gu, "\\n");
  return name.length > 10 ? name.slice(0, 9) + "…" : name;
}
function createTransformer(ast, options = {}) {
  const _context = {
    ast,
    helpers: /* @__PURE__ */ new Set()
  };
  const context = () => _context;
  const helper = (name) => {
    _context.helpers.add(name);
    return name;
  };
  return { context, helper };
}
function traverseNodes(nodes, transformer) {
  for (let i = 0; i < nodes.length; i++) {
    traverseNode(nodes[i], transformer);
  }
}
function traverseNode(node, transformer) {
  switch (node.type) {
    case 1:
      traverseNodes(node.cases, transformer);
      transformer.helper(
        "plural"
        /* HelperNameMap.PLURAL */
      );
      break;
    case 2:
      traverseNodes(node.items, transformer);
      break;
    case 6: {
      const linked = node;
      traverseNode(linked.key, transformer);
      transformer.helper(
        "linked"
        /* HelperNameMap.LINKED */
      );
      transformer.helper(
        "type"
        /* HelperNameMap.TYPE */
      );
      break;
    }
    case 5:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "list"
        /* HelperNameMap.LIST */
      );
      break;
    case 4:
      transformer.helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      );
      transformer.helper(
        "named"
        /* HelperNameMap.NAMED */
      );
      break;
  }
}
function transform(ast, options = {}) {
  const transformer = createTransformer(ast);
  transformer.helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  );
  ast.body && traverseNode(ast.body, transformer);
  const context = transformer.context();
  ast.helpers = Array.from(context.helpers);
}
function optimize(ast) {
  const body = ast.body;
  if (body.type === 2) {
    optimizeMessageNode(body);
  } else {
    body.cases.forEach((c) => optimizeMessageNode(c));
  }
  return ast;
}
function optimizeMessageNode(message) {
  if (message.items.length === 1) {
    const item = message.items[0];
    if (item.type === 3 || item.type === 9) {
      message.static = item.value;
      delete item.value;
    }
  } else {
    const values = [];
    for (let i = 0; i < message.items.length; i++) {
      const item = message.items[i];
      if (!(item.type === 3 || item.type === 9)) {
        break;
      }
      if (item.value == null) {
        break;
      }
      values.push(item.value);
    }
    if (values.length === message.items.length) {
      message.static = join2(values);
      for (let i = 0; i < message.items.length; i++) {
        const item = message.items[i];
        if (item.type === 3 || item.type === 9) {
          delete item.value;
        }
      }
    }
  }
}
var ERROR_DOMAIN$1 = "minifier";
function minify(node) {
  node.t = node.type;
  switch (node.type) {
    case 0: {
      const resource = node;
      minify(resource.body);
      resource.b = resource.body;
      delete resource.body;
      break;
    }
    case 1: {
      const plural = node;
      const cases = plural.cases;
      for (let i = 0; i < cases.length; i++) {
        minify(cases[i]);
      }
      plural.c = cases;
      delete plural.cases;
      break;
    }
    case 2: {
      const message = node;
      const items = message.items;
      for (let i = 0; i < items.length; i++) {
        minify(items[i]);
      }
      message.i = items;
      delete message.items;
      if (message.static) {
        message.s = message.static;
        delete message.static;
      }
      break;
    }
    case 3:
    case 9:
    case 8:
    case 7: {
      const valueNode = node;
      if (valueNode.value) {
        valueNode.v = valueNode.value;
        delete valueNode.value;
      }
      break;
    }
    case 6: {
      const linked = node;
      minify(linked.key);
      linked.k = linked.key;
      delete linked.key;
      if (linked.modifier) {
        minify(linked.modifier);
        linked.m = linked.modifier;
        delete linked.modifier;
      }
      break;
    }
    case 5: {
      const list = node;
      list.i = list.index;
      delete list.index;
      break;
    }
    case 4: {
      const named = node;
      named.k = named.key;
      delete named.key;
      break;
    }
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {
        domain: ERROR_DOMAIN$1,
        args: [node.type]
      });
    }
  }
  delete node.type;
}
var ERROR_DOMAIN = "parser";
function createCodeGenerator(ast, options) {
  const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;
  const location2 = options.location !== false;
  const _context = {
    filename,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    map: void 0,
    breakLineCode,
    needIndent: _needIndent,
    indentLevel: 0
  };
  if (location2 && ast.loc) {
    _context.source = ast.loc.source;
  }
  const context = () => _context;
  function push(code3, node) {
    _context.code += code3;
  }
  function _newline(n, withBreakLine = true) {
    const _breakLineCode = withBreakLine ? breakLineCode : "";
    push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);
  }
  function indent(withNewLine = true) {
    const level = ++_context.indentLevel;
    withNewLine && _newline(level);
  }
  function deindent(withNewLine = true) {
    const level = --_context.indentLevel;
    withNewLine && _newline(level);
  }
  function newline() {
    _newline(_context.indentLevel);
  }
  const helper = (key) => `_${key}`;
  const needIndent = () => _context.needIndent;
  return {
    context,
    push,
    indent,
    deindent,
    newline,
    helper,
    needIndent
  };
}
function generateLinkedNode(generator, node) {
  const { helper } = generator;
  generator.push(`${helper(
    "linked"
    /* HelperNameMap.LINKED */
  )}(`);
  generateNode(generator, node.key);
  if (node.modifier) {
    generator.push(`, `);
    generateNode(generator, node.modifier);
    generator.push(`, _type`);
  } else {
    generator.push(`, undefined, _type`);
  }
  generator.push(`)`);
}
function generateMessageNode(generator, node) {
  const { helper, needIndent } = generator;
  generator.push(`${helper(
    "normalize"
    /* HelperNameMap.NORMALIZE */
  )}([`);
  generator.indent(needIndent());
  const length = node.items.length;
  for (let i = 0; i < length; i++) {
    generateNode(generator, node.items[i]);
    if (i === length - 1) {
      break;
    }
    generator.push(", ");
  }
  generator.deindent(needIndent());
  generator.push("])");
}
function generatePluralNode(generator, node) {
  const { helper, needIndent } = generator;
  if (node.cases.length > 1) {
    generator.push(`${helper(
      "plural"
      /* HelperNameMap.PLURAL */
    )}([`);
    generator.indent(needIndent());
    const length = node.cases.length;
    for (let i = 0; i < length; i++) {
      generateNode(generator, node.cases[i]);
      if (i === length - 1) {
        break;
      }
      generator.push(", ");
    }
    generator.deindent(needIndent());
    generator.push(`])`);
  }
}
function generateResource(generator, node) {
  if (node.body) {
    generateNode(generator, node.body);
  } else {
    generator.push("null");
  }
}
function generateNode(generator, node) {
  const { helper } = generator;
  switch (node.type) {
    case 0:
      generateResource(generator, node);
      break;
    case 1:
      generatePluralNode(generator, node);
      break;
    case 2:
      generateMessageNode(generator, node);
      break;
    case 6:
      generateLinkedNode(generator, node);
      break;
    case 8:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 7:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 5:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "list"
        /* HelperNameMap.LIST */
      )}(${node.index}))`, node);
      break;
    case 4:
      generator.push(`${helper(
        "interpolate"
        /* HelperNameMap.INTERPOLATE */
      )}(${helper(
        "named"
        /* HelperNameMap.NAMED */
      )}(${JSON.stringify(node.key)}))`, node);
      break;
    case 9:
      generator.push(JSON.stringify(node.value), node);
      break;
    case 3:
      generator.push(JSON.stringify(node.value), node);
      break;
    default: {
      throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {
        domain: ERROR_DOMAIN,
        args: [node.type]
      });
    }
  }
}
var generate = (ast, options = {}) => {
  const mode = isString2(options.mode) ? options.mode : "normal";
  const filename = isString2(options.filename) ? options.filename : "message.intl";
  const sourceMap = !!options.sourceMap;
  const breakLineCode = options.breakLineCode != null ? options.breakLineCode : mode === "arrow" ? ";" : "\n";
  const needIndent = options.needIndent ? options.needIndent : mode !== "arrow";
  const helpers = ast.helpers || [];
  const generator = createCodeGenerator(ast, {
    mode,
    filename,
    sourceMap,
    breakLineCode,
    needIndent
  });
  generator.push(mode === "normal" ? `function __msg__ (ctx) {` : `(ctx) => {`);
  generator.indent(needIndent);
  if (helpers.length > 0) {
    generator.push(`const { ${join2(helpers.map((s) => `${s}: _${s}`), ", ")} } = ctx`);
    generator.newline();
  }
  generator.push(`return `);
  generateNode(generator, ast);
  generator.deindent(needIndent);
  generator.push(`}`);
  delete ast.helpers;
  const { code: code3, map } = generator.context();
  return {
    ast,
    code: code3,
    map: map ? map.toJSON() : void 0
    // eslint-disable-line @typescript-eslint/no-explicit-any
  };
};
function baseCompile(source, options = {}) {
  const assignedOptions = assign2({}, options);
  const jit = !!assignedOptions.jit;
  const enalbeMinify = !!assignedOptions.minify;
  const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;
  const parser = createParser(assignedOptions);
  const ast = parser.parse(source);
  if (!jit) {
    transform(ast, assignedOptions);
    return generate(ast, assignedOptions);
  } else {
    enambeOptimize && optimize(ast);
    enalbeMinify && minify(ast);
    return { ast, code: "" };
  }
}

// node_modules/@intlify/core-base/dist/core-base.mjs
function initFeatureFlags() {
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
}
var pathStateMachine = [];
pathStateMachine[
  0
  /* States.BEFORE_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    0
    /* States.BEFORE_PATH */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  1
  /* States.IN_PATH */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1
    /* States.IN_PATH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4
    /* States.IN_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7
    /* States.AFTER_PATH */
  ]
};
pathStateMachine[
  2
  /* States.BEFORE_IDENT */
] = {
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    2
    /* States.BEFORE_IDENT */
  ],
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  3
  /* States.IN_IDENT */
] = {
  [
    "i"
    /* PathCharTypes.IDENT */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "0"
    /* PathCharTypes.ZERO */
  ]: [
    3,
    0
    /* Actions.APPEND */
  ],
  [
    "w"
    /* PathCharTypes.WORKSPACE */
  ]: [
    1,
    1
    /* Actions.PUSH */
  ],
  [
    "."
    /* PathCharTypes.DOT */
  ]: [
    2,
    1
    /* Actions.PUSH */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    1
    /* Actions.PUSH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: [
    7,
    1
    /* Actions.PUSH */
  ]
};
pathStateMachine[
  4
  /* States.IN_SUB_PATH */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ],
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ],
  [
    "["
    /* PathCharTypes.LEFT_BRACKET */
  ]: [
    4,
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ],
  [
    "]"
    /* PathCharTypes.RIGHT_BRACKET */
  ]: [
    1,
    3
    /* Actions.PUSH_SUB_PATH */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  5
  /* States.IN_SINGLE_QUOTE */
] = {
  [
    "'"
    /* PathCharTypes.SINGLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    5,
    0
    /* Actions.APPEND */
  ]
};
pathStateMachine[
  6
  /* States.IN_DOUBLE_QUOTE */
] = {
  [
    '"'
    /* PathCharTypes.DOUBLE_QUOTE */
  ]: [
    4,
    0
    /* Actions.APPEND */
  ],
  [
    "o"
    /* PathCharTypes.END_OF_FAIL */
  ]: 8,
  [
    "l"
    /* PathCharTypes.ELSE */
  ]: [
    6,
    0
    /* Actions.APPEND */
  ]
};
var literalValueRE = /^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;
function isLiteral(exp) {
  return literalValueRE.test(exp);
}
function stripQuotes(str) {
  const a = str.charCodeAt(0);
  const b = str.charCodeAt(str.length - 1);
  return a === b && (a === 34 || a === 39) ? str.slice(1, -1) : str;
}
function getPathCharType(ch2) {
  if (ch2 === void 0 || ch2 === null) {
    return "o";
  }
  const code3 = ch2.charCodeAt(0);
  switch (code3) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
      return ch2;
    case 95:
    case 36:
    case 45:
      return "i";
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "w";
  }
  return "i";
}
function formatSubPath(path) {
  const trimmed = path.trim();
  if (path.charAt(0) === "0" && isNaN(parseInt(path))) {
    return false;
  }
  return isLiteral(trimmed) ? stripQuotes(trimmed) : "*" + trimmed;
}
function parse(path) {
  const keys = [];
  let index2 = -1;
  let mode = 0;
  let subPathDepth = 0;
  let c;
  let key;
  let newChar;
  let type;
  let transition;
  let action;
  let typeMap;
  const actions = [];
  actions[
    0
    /* Actions.APPEND */
  ] = () => {
    if (key === void 0) {
      key = newChar;
    } else {
      key += newChar;
    }
  };
  actions[
    1
    /* Actions.PUSH */
  ] = () => {
    if (key !== void 0) {
      keys.push(key);
      key = void 0;
    }
  };
  actions[
    2
    /* Actions.INC_SUB_PATH_DEPTH */
  ] = () => {
    actions[
      0
      /* Actions.APPEND */
    ]();
    subPathDepth++;
  };
  actions[
    3
    /* Actions.PUSH_SUB_PATH */
  ] = () => {
    if (subPathDepth > 0) {
      subPathDepth--;
      mode = 4;
      actions[
        0
        /* Actions.APPEND */
      ]();
    } else {
      subPathDepth = 0;
      if (key === void 0) {
        return false;
      }
      key = formatSubPath(key);
      if (key === false) {
        return false;
      } else {
        actions[
          1
          /* Actions.PUSH */
        ]();
      }
    }
  };
  function maybeUnescapeQuote() {
    const nextChar = path[index2 + 1];
    if (mode === 5 && nextChar === "'" || mode === 6 && nextChar === '"') {
      index2++;
      newChar = "\\" + nextChar;
      actions[
        0
        /* Actions.APPEND */
      ]();
      return true;
    }
  }
  while (mode !== null) {
    index2++;
    c = path[index2];
    if (c === "\\" && maybeUnescapeQuote()) {
      continue;
    }
    type = getPathCharType(c);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap[
      "l"
      /* PathCharTypes.ELSE */
    ] || 8;
    if (transition === 8) {
      return;
    }
    mode = transition[0];
    if (transition[1] !== void 0) {
      action = actions[transition[1]];
      if (action) {
        newChar = c;
        if (action() === false) {
          return;
        }
      }
    }
    if (mode === 7) {
      return keys;
    }
  }
}
var cache = /* @__PURE__ */ new Map();
function resolveWithKeyValue(obj, path) {
  return isObject(obj) ? obj[path] : null;
}
function resolveValue$1(obj, path) {
  if (!isObject(obj)) {
    return null;
  }
  let hit = cache.get(path);
  if (!hit) {
    hit = parse(path);
    if (hit) {
      cache.set(path, hit);
    }
  }
  if (!hit) {
    return null;
  }
  const len = hit.length;
  let last = obj;
  let i = 0;
  while (i < len) {
    const val = last[hit[i]];
    if (val === void 0) {
      return null;
    }
    if (isFunction(last)) {
      return null;
    }
    last = val;
    i++;
  }
  return last;
}
var DEFAULT_MODIFIER = (str) => str;
var DEFAULT_MESSAGE = (ctx) => "";
var DEFAULT_MESSAGE_DATA_TYPE = "text";
var DEFAULT_NORMALIZE = (values) => values.length === 0 ? "" : join(values);
var DEFAULT_INTERPOLATE = toDisplayString2;
function pluralDefault(choice, choicesLength) {
  choice = Math.abs(choice);
  if (choicesLength === 2) {
    return choice ? choice > 1 ? 1 : 0 : 1;
  }
  return choice ? Math.min(choice, 2) : 0;
}
function getPluralIndex(options) {
  const index2 = isNumber(options.pluralIndex) ? options.pluralIndex : -1;
  return options.named && (isNumber(options.named.count) || isNumber(options.named.n)) ? isNumber(options.named.count) ? options.named.count : isNumber(options.named.n) ? options.named.n : index2 : index2;
}
function normalizeNamed(pluralIndex, props) {
  if (!props.count) {
    props.count = pluralIndex;
  }
  if (!props.n) {
    props.n = pluralIndex;
  }
}
function createMessageContext(options = {}) {
  const locale = options.locale;
  const pluralIndex = getPluralIndex(options);
  const pluralRule = isObject(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? options.pluralRules[locale] : pluralDefault;
  const orgPluralRule = isObject(options.pluralRules) && isString(locale) && isFunction(options.pluralRules[locale]) ? pluralDefault : void 0;
  const plural = (messages) => {
    return messages[pluralRule(pluralIndex, messages.length, orgPluralRule)];
  };
  const _list = options.list || [];
  const list = (index2) => _list[index2];
  const _named = options.named || create();
  isNumber(options.pluralIndex) && normalizeNamed(pluralIndex, _named);
  const named = (key) => _named[key];
  function message(key) {
    const msg = isFunction(options.messages) ? options.messages(key) : isObject(options.messages) ? options.messages[key] : false;
    return !msg ? options.parent ? options.parent.message(key) : DEFAULT_MESSAGE : msg;
  }
  const _modifier = (name) => options.modifiers ? options.modifiers[name] : DEFAULT_MODIFIER;
  const normalize = isPlainObject(options.processor) && isFunction(options.processor.normalize) ? options.processor.normalize : DEFAULT_NORMALIZE;
  const interpolate = isPlainObject(options.processor) && isFunction(options.processor.interpolate) ? options.processor.interpolate : DEFAULT_INTERPOLATE;
  const type = isPlainObject(options.processor) && isString(options.processor.type) ? options.processor.type : DEFAULT_MESSAGE_DATA_TYPE;
  const linked = (key, ...args) => {
    const [arg1, arg2] = args;
    let type2 = "text";
    let modifier = "";
    if (args.length === 1) {
      if (isObject(arg1)) {
        modifier = arg1.modifier || modifier;
        type2 = arg1.type || type2;
      } else if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
    } else if (args.length === 2) {
      if (isString(arg1)) {
        modifier = arg1 || modifier;
      }
      if (isString(arg2)) {
        type2 = arg2 || type2;
      }
    }
    const ret = message(key)(ctx);
    const msg = (
      // The message in vnode resolved with linked are returned as an array by processor.nomalize
      type2 === "vnode" && isArray(ret) && modifier ? ret[0] : ret
    );
    return modifier ? _modifier(modifier)(msg, type2) : msg;
  };
  const ctx = {
    [
      "list"
      /* HelperNameMap.LIST */
    ]: list,
    [
      "named"
      /* HelperNameMap.NAMED */
    ]: named,
    [
      "plural"
      /* HelperNameMap.PLURAL */
    ]: plural,
    [
      "linked"
      /* HelperNameMap.LINKED */
    ]: linked,
    [
      "message"
      /* HelperNameMap.MESSAGE */
    ]: message,
    [
      "type"
      /* HelperNameMap.TYPE */
    ]: type,
    [
      "interpolate"
      /* HelperNameMap.INTERPOLATE */
    ]: interpolate,
    [
      "normalize"
      /* HelperNameMap.NORMALIZE */
    ]: normalize,
    [
      "values"
      /* HelperNameMap.VALUES */
    ]: assign(create(), _list, _named)
  };
  return ctx;
}
var devtools = null;
function setDevToolsHook(hook) {
  devtools = hook;
}
function initI18nDevTools(i18n, version7, meta) {
  devtools && devtools.emit("i18n:init", {
    timestamp: Date.now(),
    i18n,
    version: version7,
    meta
  });
}
var translateDevTools = createDevToolsHook(
  "function:translate"
  /* IntlifyDevToolsHooks.FunctionTranslate */
);
function createDevToolsHook(hook) {
  return (payloads) => devtools && devtools.emit(hook, payloads);
}
var code$1 = CompileWarnCodes.__EXTEND_POINT__;
var inc$1 = incrementer(code$1);
var CoreWarnCodes = {
  NOT_FOUND_KEY: code$1,
  // 2
  FALLBACK_TO_TRANSLATE: inc$1(),
  // 3
  CANNOT_FORMAT_NUMBER: inc$1(),
  // 4
  FALLBACK_TO_NUMBER_FORMAT: inc$1(),
  // 5
  CANNOT_FORMAT_DATE: inc$1(),
  // 6
  FALLBACK_TO_DATE_FORMAT: inc$1(),
  // 7
  EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER: inc$1(),
  // 8
  __EXTEND_POINT__: inc$1()
  // 9
};
var warnMessages2 = {
  [CoreWarnCodes.NOT_FOUND_KEY]: `Not found '{key}' key in '{locale}' locale messages.`,
  [CoreWarnCodes.FALLBACK_TO_TRANSLATE]: `Fall back to translate '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_NUMBER]: `Cannot format a number value due to not supported Intl.NumberFormat.`,
  [CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT]: `Fall back to number format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.CANNOT_FORMAT_DATE]: `Cannot format a date value due to not supported Intl.DateTimeFormat.`,
  [CoreWarnCodes.FALLBACK_TO_DATE_FORMAT]: `Fall back to datetime format '{key}' key with '{target}' locale.`,
  [CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER]: `This project is using Custom Message Compiler, which is an experimental feature. It may receive breaking changes or be removed in the future.`
};
function getWarnMessage(code3, ...args) {
  return format(warnMessages2[code3], ...args);
}
var code = CompileErrorCodes.__EXTEND_POINT__;
var inc = incrementer(code);
var CoreErrorCodes = {
  INVALID_ARGUMENT: code,
  // 17
  INVALID_DATE_ARGUMENT: inc(),
  // 18
  INVALID_ISO_DATE_ARGUMENT: inc(),
  // 19
  NOT_SUPPORT_NON_STRING_MESSAGE: inc(),
  // 20
  NOT_SUPPORT_LOCALE_PROMISE_VALUE: inc(),
  // 21
  NOT_SUPPORT_LOCALE_ASYNC_FUNCTION: inc(),
  // 22
  NOT_SUPPORT_LOCALE_TYPE: inc(),
  // 23
  __EXTEND_POINT__: inc()
  // 24
};
function createCoreError(code3) {
  return createCompileError(code3, null, true ? { messages: errorMessages2 } : void 0);
}
var errorMessages2 = {
  [CoreErrorCodes.INVALID_ARGUMENT]: "Invalid arguments",
  [CoreErrorCodes.INVALID_DATE_ARGUMENT]: "The date provided is an invalid Date object.Make sure your Date represents a valid date.",
  [CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT]: "The argument provided is not a valid ISO date string",
  [CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE]: "Not support non-string message",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE]: "cannot support promise value",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION]: "cannot support async function",
  [CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE]: "cannot support locale type"
};
function getLocale(context, options) {
  return options.locale != null ? resolveLocale(options.locale) : resolveLocale(context.locale);
}
var _resolveLocale;
function resolveLocale(locale) {
  if (isString(locale)) {
    return locale;
  } else {
    if (isFunction(locale)) {
      if (locale.resolvedOnce && _resolveLocale != null) {
        return _resolveLocale;
      } else if (locale.constructor.name === "Function") {
        const resolve = locale();
        if (isPromise(resolve)) {
          throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_PROMISE_VALUE);
        }
        return _resolveLocale = resolve;
      } else {
        throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_ASYNC_FUNCTION);
      }
    } else {
      throw createCoreError(CoreErrorCodes.NOT_SUPPORT_LOCALE_TYPE);
    }
  }
}
function fallbackWithSimple(ctx, fallback, start) {
  return [.../* @__PURE__ */ new Set([
    start,
    ...isArray(fallback) ? fallback : isObject(fallback) ? Object.keys(fallback) : isString(fallback) ? [fallback] : [start]
  ])];
}
function fallbackWithLocaleChain(ctx, fallback, start) {
  const startLocale = isString(start) ? start : DEFAULT_LOCALE;
  const context = ctx;
  if (!context.__localeChainCache) {
    context.__localeChainCache = /* @__PURE__ */ new Map();
  }
  let chain = context.__localeChainCache.get(startLocale);
  if (!chain) {
    chain = [];
    let block = [start];
    while (isArray(block)) {
      block = appendBlockToChain(chain, block, fallback);
    }
    const defaults2 = isArray(fallback) || !isPlainObject(fallback) ? fallback : fallback["default"] ? fallback["default"] : null;
    block = isString(defaults2) ? [defaults2] : defaults2;
    if (isArray(block)) {
      appendBlockToChain(chain, block, false);
    }
    context.__localeChainCache.set(startLocale, chain);
  }
  return chain;
}
function appendBlockToChain(chain, block, blocks) {
  let follow = true;
  for (let i = 0; i < block.length && isBoolean(follow); i++) {
    const locale = block[i];
    if (isString(locale)) {
      follow = appendLocaleToChain(chain, block[i], blocks);
    }
  }
  return follow;
}
function appendLocaleToChain(chain, locale, blocks) {
  let follow;
  const tokens = locale.split("-");
  do {
    const target = tokens.join("-");
    follow = appendItemToChain(chain, target, blocks);
    tokens.splice(-1, 1);
  } while (tokens.length && follow === true);
  return follow;
}
function appendItemToChain(chain, target, blocks) {
  let follow = false;
  if (!chain.includes(target)) {
    follow = true;
    if (target) {
      follow = target[target.length - 1] !== "!";
      const locale = target.replace(/!/g, "");
      chain.push(locale);
      if ((isArray(blocks) || isPlainObject(blocks)) && blocks[locale]) {
        follow = blocks[locale];
      }
    }
  }
  return follow;
}
var VERSION = "9.14.2";
var NOT_REOSLVED = -1;
var DEFAULT_LOCALE = "en-US";
var MISSING_RESOLVE_VALUE = "";
var capitalize = (str) => `${str.charAt(0).toLocaleUpperCase()}${str.substr(1)}`;
function getDefaultLinkedModifiers() {
  return {
    upper: (val, type) => {
      return type === "text" && isString(val) ? val.toUpperCase() : type === "vnode" && isObject(val) && "__v_isVNode" in val ? val.children.toUpperCase() : val;
    },
    lower: (val, type) => {
      return type === "text" && isString(val) ? val.toLowerCase() : type === "vnode" && isObject(val) && "__v_isVNode" in val ? val.children.toLowerCase() : val;
    },
    capitalize: (val, type) => {
      return type === "text" && isString(val) ? capitalize(val) : type === "vnode" && isObject(val) && "__v_isVNode" in val ? capitalize(val.children) : val;
    }
  };
}
var _compiler;
function registerMessageCompiler(compiler) {
  _compiler = compiler;
}
var _resolver;
function registerMessageResolver(resolver) {
  _resolver = resolver;
}
var _fallbacker;
function registerLocaleFallbacker(fallbacker) {
  _fallbacker = fallbacker;
}
var _additionalMeta = null;
var setAdditionalMeta = (meta) => {
  _additionalMeta = meta;
};
var getAdditionalMeta = () => _additionalMeta;
var _fallbackContext = null;
var setFallbackContext = (context) => {
  _fallbackContext = context;
};
var getFallbackContext = () => _fallbackContext;
var _cid = 0;
function createCoreContext(options = {}) {
  const onWarn = isFunction(options.onWarn) ? options.onWarn : warn;
  const version7 = isString(options.version) ? options.version : VERSION;
  const locale = isString(options.locale) || isFunction(options.locale) ? options.locale : DEFAULT_LOCALE;
  const _locale = isFunction(locale) ? DEFAULT_LOCALE : locale;
  const fallbackLocale = isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || isString(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale;
  const messages = isPlainObject(options.messages) ? options.messages : createResources(_locale);
  const datetimeFormats = isPlainObject(options.datetimeFormats) ? options.datetimeFormats : createResources(_locale);
  const numberFormats = isPlainObject(options.numberFormats) ? options.numberFormats : createResources(_locale);
  const modifiers = assign(create(), options.modifiers, getDefaultLinkedModifiers());
  const pluralRules = options.pluralRules || create();
  const missing = isFunction(options.missing) ? options.missing : null;
  const missingWarn = isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const fallbackWarn = isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const fallbackFormat = !!options.fallbackFormat;
  const unresolving = !!options.unresolving;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const processor = isPlainObject(options.processor) ? options.processor : null;
  const warnHtmlMessage = isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const escapeParameter = !!options.escapeParameter;
  const messageCompiler = isFunction(options.messageCompiler) ? options.messageCompiler : _compiler;
  if (isFunction(options.messageCompiler)) {
    warnOnce(getWarnMessage(CoreWarnCodes.EXPERIMENTAL_CUSTOM_MESSAGE_COMPILER));
  }
  const messageResolver = isFunction(options.messageResolver) ? options.messageResolver : _resolver || resolveWithKeyValue;
  const localeFallbacker = isFunction(options.localeFallbacker) ? options.localeFallbacker : _fallbacker || fallbackWithSimple;
  const fallbackContext = isObject(options.fallbackContext) ? options.fallbackContext : void 0;
  const internalOptions = options;
  const __datetimeFormatters = isObject(internalOptions.__datetimeFormatters) ? internalOptions.__datetimeFormatters : /* @__PURE__ */ new Map();
  const __numberFormatters = isObject(internalOptions.__numberFormatters) ? internalOptions.__numberFormatters : /* @__PURE__ */ new Map();
  const __meta = isObject(internalOptions.__meta) ? internalOptions.__meta : {};
  _cid++;
  const context = {
    version: version7,
    cid: _cid,
    locale,
    fallbackLocale,
    messages,
    modifiers,
    pluralRules,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackFormat,
    unresolving,
    postTranslation,
    processor,
    warnHtmlMessage,
    escapeParameter,
    messageCompiler,
    messageResolver,
    localeFallbacker,
    fallbackContext,
    onWarn,
    __meta
  };
  {
    context.datetimeFormats = datetimeFormats;
    context.numberFormats = numberFormats;
    context.__datetimeFormatters = __datetimeFormatters;
    context.__numberFormatters = __numberFormatters;
  }
  if (true) {
    context.__v_emitter = internalOptions.__v_emitter != null ? internalOptions.__v_emitter : void 0;
  }
  if (true) {
    initI18nDevTools(context, version7, __meta);
  }
  return context;
}
var createResources = (locale) => ({ [locale]: create() });
function isTranslateFallbackWarn(fallback, key) {
  return fallback instanceof RegExp ? fallback.test(key) : fallback;
}
function isTranslateMissingWarn(missing, key) {
  return missing instanceof RegExp ? missing.test(key) : missing;
}
function handleMissing(context, key, locale, missingWarn, type) {
  const { missing, onWarn } = context;
  if (true) {
    const emitter = context.__v_emitter;
    if (emitter) {
      emitter.emit("missing", {
        locale,
        key,
        type,
        groupId: `${type}:${key}`
      });
    }
  }
  if (missing !== null) {
    const ret = missing(context, locale, key, type);
    return isString(ret) ? ret : key;
  } else {
    if (isTranslateMissingWarn(missingWarn, key)) {
      onWarn(getWarnMessage(CoreWarnCodes.NOT_FOUND_KEY, { key, locale }));
    }
    return key;
  }
}
function updateFallbackLocale(ctx, locale, fallback) {
  const context = ctx;
  context.__localeChainCache = /* @__PURE__ */ new Map();
  ctx.localeFallbacker(ctx, fallback, locale);
}
function isAlmostSameLocale(locale, compareLocale) {
  if (locale === compareLocale)
    return false;
  return locale.split("-")[0] === compareLocale.split("-")[0];
}
function isImplicitFallback(targetLocale, locales) {
  const index2 = locales.indexOf(targetLocale);
  if (index2 === -1) {
    return false;
  }
  for (let i = index2 + 1; i < locales.length; i++) {
    if (isAlmostSameLocale(targetLocale, locales[i])) {
      return true;
    }
  }
  return false;
}
function format3(ast) {
  const msg = (ctx) => formatParts(ctx, ast);
  return msg;
}
function formatParts(ctx, ast) {
  const body = resolveBody(ast);
  if (body == null) {
    throw createUnhandleNodeError(
      0
      /* NodeTypes.Resource */
    );
  }
  const type = resolveType(body);
  if (type === 1) {
    const plural = body;
    const cases = resolveCases(plural);
    return ctx.plural(cases.reduce((messages, c) => [
      ...messages,
      formatMessageParts(ctx, c)
    ], []));
  } else {
    return formatMessageParts(ctx, body);
  }
}
var PROPS_BODY = ["b", "body"];
function resolveBody(node) {
  return resolveProps(node, PROPS_BODY);
}
var PROPS_CASES = ["c", "cases"];
function resolveCases(node) {
  return resolveProps(node, PROPS_CASES, []);
}
function formatMessageParts(ctx, node) {
  const static_ = resolveStatic(node);
  if (static_ != null) {
    return ctx.type === "text" ? static_ : ctx.normalize([static_]);
  } else {
    const messages = resolveItems(node).reduce((acm, c) => [...acm, formatMessagePart(ctx, c)], []);
    return ctx.normalize(messages);
  }
}
var PROPS_STATIC = ["s", "static"];
function resolveStatic(node) {
  return resolveProps(node, PROPS_STATIC);
}
var PROPS_ITEMS = ["i", "items"];
function resolveItems(node) {
  return resolveProps(node, PROPS_ITEMS, []);
}
function formatMessagePart(ctx, node) {
  const type = resolveType(node);
  switch (type) {
    case 3: {
      return resolveValue(node, type);
    }
    case 9: {
      return resolveValue(node, type);
    }
    case 4: {
      const named = node;
      if (hasOwn(named, "k") && named.k) {
        return ctx.interpolate(ctx.named(named.k));
      }
      if (hasOwn(named, "key") && named.key) {
        return ctx.interpolate(ctx.named(named.key));
      }
      throw createUnhandleNodeError(type);
    }
    case 5: {
      const list = node;
      if (hasOwn(list, "i") && isNumber(list.i)) {
        return ctx.interpolate(ctx.list(list.i));
      }
      if (hasOwn(list, "index") && isNumber(list.index)) {
        return ctx.interpolate(ctx.list(list.index));
      }
      throw createUnhandleNodeError(type);
    }
    case 6: {
      const linked = node;
      const modifier = resolveLinkedModifier(linked);
      const key = resolveLinkedKey(linked);
      return ctx.linked(formatMessagePart(ctx, key), modifier ? formatMessagePart(ctx, modifier) : void 0, ctx.type);
    }
    case 7: {
      return resolveValue(node, type);
    }
    case 8: {
      return resolveValue(node, type);
    }
    default:
      throw new Error(`unhandled node on format message part: ${type}`);
  }
}
var PROPS_TYPE = ["t", "type"];
function resolveType(node) {
  return resolveProps(node, PROPS_TYPE);
}
var PROPS_VALUE = ["v", "value"];
function resolveValue(node, type) {
  const resolved = resolveProps(node, PROPS_VALUE);
  if (resolved) {
    return resolved;
  } else {
    throw createUnhandleNodeError(type);
  }
}
var PROPS_MODIFIER = ["m", "modifier"];
function resolveLinkedModifier(node) {
  return resolveProps(node, PROPS_MODIFIER);
}
var PROPS_KEY = ["k", "key"];
function resolveLinkedKey(node) {
  const resolved = resolveProps(node, PROPS_KEY);
  if (resolved) {
    return resolved;
  } else {
    throw createUnhandleNodeError(
      6
      /* NodeTypes.Linked */
    );
  }
}
function resolveProps(node, props, defaultValue) {
  for (let i = 0; i < props.length; i++) {
    const prop = props[i];
    if (hasOwn(node, prop) && node[prop] != null) {
      return node[prop];
    }
  }
  return defaultValue;
}
function createUnhandleNodeError(type) {
  return new Error(`unhandled node type: ${type}`);
}
var WARN_MESSAGE = `Detected HTML in '{source}' message. Recommend not using HTML messages to avoid XSS.`;
function checkHtmlMessage(source, warnHtmlMessage) {
  if (warnHtmlMessage && detectHtmlTag(source)) {
    warn(format(WARN_MESSAGE, { source }));
  }
}
var defaultOnCacheKey = (message) => message;
var compileCache = create();
function onCompileWarn(_warn) {
  if (_warn.code === CompileWarnCodes.USE_MODULO_SYNTAX) {
    warn(`The use of named interpolation with modulo syntax is deprecated. It will be removed in v10.
reference: https://vue-i18n.intlify.dev/guide/essentials/syntax#rails-i18n-format 
(message compiler warning message: ${_warn.message})`);
  }
}
function isMessageAST(val) {
  return isObject(val) && resolveType(val) === 0 && (hasOwn(val, "b") || hasOwn(val, "body"));
}
function baseCompile2(message, options = {}) {
  let detectError = false;
  const onError = options.onError || defaultOnError;
  options.onError = (err) => {
    detectError = true;
    onError(err);
  };
  return { ...baseCompile(message, options), detectError };
}
var compileToFunction = (message, context) => {
  if (!isString(message)) {
    throw createCoreError(CoreErrorCodes.NOT_SUPPORT_NON_STRING_MESSAGE);
  }
  if (true) {
    context.onWarn = onCompileWarn;
  }
  {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    checkHtmlMessage(message, warnHtmlMessage);
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { code: code3, detectError } = baseCompile2(message, context);
    const msg = new Function(`return ${code3}`)();
    return !detectError ? compileCache[cacheKey] = msg : msg;
  }
};
function compile(message, context) {
  if (true) {
    context.onWarn = onCompileWarn;
  }
  if (__INTLIFY_JIT_COMPILATION__ && !__INTLIFY_DROP_MESSAGE_COMPILER__ && isString(message)) {
    const warnHtmlMessage = isBoolean(context.warnHtmlMessage) ? context.warnHtmlMessage : true;
    checkHtmlMessage(message, warnHtmlMessage);
    const onCacheKey = context.onCacheKey || defaultOnCacheKey;
    const cacheKey = onCacheKey(message);
    const cached = compileCache[cacheKey];
    if (cached) {
      return cached;
    }
    const { ast, detectError } = baseCompile2(message, {
      ...context,
      location: true,
      jit: true
    });
    const msg = format3(ast);
    return !detectError ? compileCache[cacheKey] = msg : msg;
  } else {
    if (!isMessageAST(message)) {
      warn(`the message that is resolve with key '${context.key}' is not supported for jit compilation`);
      return () => message;
    }
    const cacheKey = message.cacheKey;
    if (cacheKey) {
      const cached = compileCache[cacheKey];
      if (cached) {
        return cached;
      }
      return compileCache[cacheKey] = format3(message);
    } else {
      return format3(message);
    }
  }
}
var NOOP_MESSAGE_FUNCTION = () => "";
var isMessageFunction = (val) => isFunction(val);
function translate(context, ...args) {
  const { fallbackFormat, postTranslation, unresolving, messageCompiler, fallbackLocale, messages } = context;
  const [key, options] = parseTranslateArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const escapeParameter = isBoolean(options.escapeParameter) ? options.escapeParameter : context.escapeParameter;
  const resolvedMessage = !!options.resolvedMessage;
  const defaultMsgOrKey = isString(options.default) || isBoolean(options.default) ? !isBoolean(options.default) ? options.default : !messageCompiler ? () => key : key : fallbackFormat ? !messageCompiler ? () => key : key : "";
  const enableDefaultMsg = fallbackFormat || defaultMsgOrKey !== "";
  const locale = getLocale(context, options);
  escapeParameter && escapeParams(options);
  let [formatScope, targetLocale, message] = !resolvedMessage ? resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) : [
    key,
    locale,
    messages[locale] || create()
  ];
  let format4 = formatScope;
  let cacheBaseKey = key;
  if (!resolvedMessage && !(isString(format4) || isMessageAST(format4) || isMessageFunction(format4))) {
    if (enableDefaultMsg) {
      format4 = defaultMsgOrKey;
      cacheBaseKey = format4;
    }
  }
  if (!resolvedMessage && (!(isString(format4) || isMessageAST(format4) || isMessageFunction(format4)) || !isString(targetLocale))) {
    return unresolving ? NOT_REOSLVED : key;
  }
  if (isString(format4) && context.messageCompiler == null) {
    warn(`The message format compilation is not supported in this build. Because message compiler isn't included. You need to pre-compilation all message format. So translate function return '${key}'.`);
    return key;
  }
  let occurred = false;
  const onError = () => {
    occurred = true;
  };
  const msg = !isMessageFunction(format4) ? compileMessageFormat(context, key, targetLocale, format4, cacheBaseKey, onError) : format4;
  if (occurred) {
    return format4;
  }
  const ctxOptions = getMessageContextOptions(context, targetLocale, message, options);
  const msgContext = createMessageContext(ctxOptions);
  const messaged = evaluateMessage(context, msg, msgContext);
  const ret = postTranslation ? postTranslation(messaged, key) : messaged;
  if (true) {
    const payloads = {
      timestamp: Date.now(),
      key: isString(key) ? key : isMessageFunction(format4) ? format4.key : "",
      locale: targetLocale || (isMessageFunction(format4) ? format4.locale : ""),
      format: isString(format4) ? format4 : isMessageFunction(format4) ? format4.source : "",
      message: ret
    };
    payloads.meta = assign({}, context.__meta, getAdditionalMeta() || {});
    translateDevTools(payloads);
  }
  return ret;
}
function escapeParams(options) {
  if (isArray(options.list)) {
    options.list = options.list.map((item) => isString(item) ? escapeHtml(item) : item);
  } else if (isObject(options.named)) {
    Object.keys(options.named).forEach((key) => {
      if (isString(options.named[key])) {
        options.named[key] = escapeHtml(options.named[key]);
      }
    });
  }
}
function resolveMessageFormat(context, key, locale, fallbackLocale, fallbackWarn, missingWarn) {
  const { messages, onWarn, messageResolver: resolveValue2, localeFallbacker } = context;
  const locales = localeFallbacker(context, fallbackLocale, locale);
  let message = create();
  let targetLocale;
  let format4 = null;
  let from = locale;
  let to2 = null;
  const type = "translate";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = to2 = locales[i];
    if (locale !== targetLocale && !isAlmostSameLocale(locale, targetLocale) && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_TRANSLATE, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to: to2,
          groupId: `${type}:${key}`
        });
      }
    }
    message = messages[targetLocale] || create();
    let start = null;
    let startTag;
    let endTag;
    if (inBrowser) {
      start = window.performance.now();
      startTag = "intlify-message-resolve-start";
      endTag = "intlify-message-resolve-end";
      mark && mark(startTag);
    }
    if ((format4 = resolveValue2(message, key)) === null) {
      format4 = message[key];
    }
    if (inBrowser) {
      const end = window.performance.now();
      const emitter = context.__v_emitter;
      if (emitter && start && format4) {
        emitter.emit("message-resolve", {
          type: "message-resolve",
          key,
          message: format4,
          time: end - start,
          groupId: `${type}:${key}`
        });
      }
      if (startTag && endTag && mark && measure) {
        mark(endTag);
        measure("intlify message resolve", startTag, endTag);
      }
    }
    if (isString(format4) || isMessageAST(format4) || isMessageFunction(format4)) {
      break;
    }
    if (!isImplicitFallback(targetLocale, locales)) {
      const missingRet = handleMissing(
        context,
        // eslint-disable-line @typescript-eslint/no-explicit-any
        key,
        targetLocale,
        missingWarn,
        type
      );
      if (missingRet !== key) {
        format4 = missingRet;
      }
    }
    from = to2;
  }
  return [format4, targetLocale, message];
}
function compileMessageFormat(context, key, targetLocale, format4, cacheBaseKey, onError) {
  const { messageCompiler, warnHtmlMessage } = context;
  if (isMessageFunction(format4)) {
    const msg2 = format4;
    msg2.locale = msg2.locale || targetLocale;
    msg2.key = msg2.key || key;
    return msg2;
  }
  if (messageCompiler == null) {
    const msg2 = () => format4;
    msg2.locale = targetLocale;
    msg2.key = key;
    return msg2;
  }
  let start = null;
  let startTag;
  let endTag;
  if (inBrowser) {
    start = window.performance.now();
    startTag = "intlify-message-compilation-start";
    endTag = "intlify-message-compilation-end";
    mark && mark(startTag);
  }
  const msg = messageCompiler(format4, getCompileContext(context, targetLocale, cacheBaseKey, format4, warnHtmlMessage, onError));
  if (inBrowser) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start) {
      emitter.emit("message-compilation", {
        type: "message-compilation",
        message: format4,
        time: end - start,
        groupId: `${"translate"}:${key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message compilation", startTag, endTag);
    }
  }
  msg.locale = targetLocale;
  msg.key = key;
  msg.source = format4;
  return msg;
}
function evaluateMessage(context, msg, msgCtx) {
  let start = null;
  let startTag;
  let endTag;
  if (inBrowser) {
    start = window.performance.now();
    startTag = "intlify-message-evaluation-start";
    endTag = "intlify-message-evaluation-end";
    mark && mark(startTag);
  }
  const messaged = msg(msgCtx);
  if (inBrowser) {
    const end = window.performance.now();
    const emitter = context.__v_emitter;
    if (emitter && start) {
      emitter.emit("message-evaluation", {
        type: "message-evaluation",
        value: messaged,
        time: end - start,
        groupId: `${"translate"}:${msg.key}`
      });
    }
    if (startTag && endTag && mark && measure) {
      mark(endTag);
      measure("intlify message evaluation", startTag, endTag);
    }
  }
  return messaged;
}
function parseTranslateArgs(...args) {
  const [arg1, arg2, arg3] = args;
  const options = create();
  if (!isString(arg1) && !isNumber(arg1) && !isMessageFunction(arg1) && !isMessageAST(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const key = isNumber(arg1) ? String(arg1) : isMessageFunction(arg1) ? arg1 : arg1;
  if (isNumber(arg2)) {
    options.plural = arg2;
  } else if (isString(arg2)) {
    options.default = arg2;
  } else if (isPlainObject(arg2) && !isEmptyObject(arg2)) {
    options.named = arg2;
  } else if (isArray(arg2)) {
    options.list = arg2;
  }
  if (isNumber(arg3)) {
    options.plural = arg3;
  } else if (isString(arg3)) {
    options.default = arg3;
  } else if (isPlainObject(arg3)) {
    assign(options, arg3);
  }
  return [key, options];
}
function getCompileContext(context, locale, key, source, warnHtmlMessage, onError) {
  return {
    locale,
    key,
    warnHtmlMessage,
    onError: (err) => {
      onError && onError(err);
      if (true) {
        const _source = getSourceForCodeFrame(source);
        const message = `Message compilation error: ${err.message}`;
        const codeFrame = err.location && _source && generateCodeFrame(_source, err.location.start.offset, err.location.end.offset);
        const emitter = context.__v_emitter;
        if (emitter && _source) {
          emitter.emit("compile-error", {
            message: _source,
            error: err.message,
            start: err.location && err.location.start.offset,
            end: err.location && err.location.end.offset,
            groupId: `${"translate"}:${key}`
          });
        }
        console.error(codeFrame ? `${message}
${codeFrame}` : message);
      } else {
        throw err;
      }
    },
    onCacheKey: (source2) => generateFormatCacheKey(locale, key, source2)
  };
}
function getSourceForCodeFrame(source) {
  if (isString(source)) {
    return source;
  } else {
    if (source.loc && source.loc.source) {
      return source.loc.source;
    }
  }
}
function getMessageContextOptions(context, locale, message, options) {
  const { modifiers, pluralRules, messageResolver: resolveValue2, fallbackLocale, fallbackWarn, missingWarn, fallbackContext } = context;
  const resolveMessage = (key) => {
    let val = resolveValue2(message, key);
    if (val == null && fallbackContext) {
      const [, , message2] = resolveMessageFormat(fallbackContext, key, locale, fallbackLocale, fallbackWarn, missingWarn);
      val = resolveValue2(message2, key);
    }
    if (isString(val) || isMessageAST(val)) {
      let occurred = false;
      const onError = () => {
        occurred = true;
      };
      const msg = compileMessageFormat(context, key, locale, val, key, onError);
      return !occurred ? msg : NOOP_MESSAGE_FUNCTION;
    } else if (isMessageFunction(val)) {
      return val;
    } else {
      return NOOP_MESSAGE_FUNCTION;
    }
  };
  const ctxOptions = {
    locale,
    modifiers,
    pluralRules,
    messages: resolveMessage
  };
  if (context.processor) {
    ctxOptions.processor = context.processor;
  }
  if (options.list) {
    ctxOptions.list = options.list;
  }
  if (options.named) {
    ctxOptions.named = options.named;
  }
  if (isNumber(options.plural)) {
    ctxOptions.pluralIndex = options.plural;
  }
  return ctxOptions;
}
var intlDefined = typeof Intl !== "undefined";
var Availabilities = {
  dateTimeFormat: intlDefined && typeof Intl.DateTimeFormat !== "undefined",
  numberFormat: intlDefined && typeof Intl.NumberFormat !== "undefined"
};
function datetime(context, ...args) {
  const { datetimeFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __datetimeFormatters } = context;
  if (!Availabilities.dateTimeFormat) {
    onWarn(getWarnMessage(CoreWarnCodes.CANNOT_FORMAT_DATE));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value, options, overrides] = parseDateTimeArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString(key) || key === "") {
    return new Intl.DateTimeFormat(locale, overrides).format(value);
  }
  let datetimeFormat = {};
  let targetLocale;
  let format4 = null;
  let from = locale;
  let to2 = null;
  const type = "datetime format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = to2 = locales[i];
    if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_DATE_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to: to2,
          groupId: `${type}:${key}`
        });
      }
    }
    datetimeFormat = datetimeFormats[targetLocale] || {};
    format4 = datetimeFormat[key];
    if (isPlainObject(format4))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to2;
  }
  if (!isPlainObject(format4) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __datetimeFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat(targetLocale, assign({}, format4, overrides));
    __datetimeFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
var DATETIME_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "weekday",
  "era",
  "year",
  "month",
  "day",
  "hour",
  "minute",
  "second",
  "timeZoneName",
  "formatMatcher",
  "hour12",
  "timeZone",
  "dateStyle",
  "timeStyle",
  "calendar",
  "dayPeriod",
  "numberingSystem",
  "hourCycle",
  "fractionalSecondDigits"
];
function parseDateTimeArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  let value;
  if (isString(arg1)) {
    const matches2 = arg1.match(/(\d{4}-\d{2}-\d{2})(T|\s)?(.*)/);
    if (!matches2) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
    const dateTime = matches2[3] ? matches2[3].trim().startsWith("T") ? `${matches2[1].trim()}${matches2[3].trim()}` : `${matches2[1].trim()}T${matches2[3].trim()}` : matches2[1].trim();
    value = new Date(dateTime);
    try {
      value.toISOString();
    } catch (e16) {
      throw createCoreError(CoreErrorCodes.INVALID_ISO_DATE_ARGUMENT);
    }
  } else if (isDate(arg1)) {
    if (isNaN(arg1.getTime())) {
      throw createCoreError(CoreErrorCodes.INVALID_DATE_ARGUMENT);
    }
    value = arg1;
  } else if (isNumber(arg1)) {
    value = arg1;
  } else {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (DATETIME_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearDateTimeFormat(ctx, locale, format4) {
  const context = ctx;
  for (const key in format4) {
    const id2 = `${locale}__${key}`;
    if (!context.__datetimeFormatters.has(id2)) {
      continue;
    }
    context.__datetimeFormatters.delete(id2);
  }
}
function number(context, ...args) {
  const { numberFormats, unresolving, fallbackLocale, onWarn, localeFallbacker } = context;
  const { __numberFormatters } = context;
  if (!Availabilities.numberFormat) {
    onWarn(getWarnMessage(CoreWarnCodes.CANNOT_FORMAT_NUMBER));
    return MISSING_RESOLVE_VALUE;
  }
  const [key, value, options, overrides] = parseNumberArgs(...args);
  const missingWarn = isBoolean(options.missingWarn) ? options.missingWarn : context.missingWarn;
  const fallbackWarn = isBoolean(options.fallbackWarn) ? options.fallbackWarn : context.fallbackWarn;
  const part = !!options.part;
  const locale = getLocale(context, options);
  const locales = localeFallbacker(
    context,
    // eslint-disable-line @typescript-eslint/no-explicit-any
    fallbackLocale,
    locale
  );
  if (!isString(key) || key === "") {
    return new Intl.NumberFormat(locale, overrides).format(value);
  }
  let numberFormat = {};
  let targetLocale;
  let format4 = null;
  let from = locale;
  let to2 = null;
  const type = "number format";
  for (let i = 0; i < locales.length; i++) {
    targetLocale = to2 = locales[i];
    if (locale !== targetLocale && isTranslateFallbackWarn(fallbackWarn, key)) {
      onWarn(getWarnMessage(CoreWarnCodes.FALLBACK_TO_NUMBER_FORMAT, {
        key,
        target: targetLocale
      }));
    }
    if (locale !== targetLocale) {
      const emitter = context.__v_emitter;
      if (emitter) {
        emitter.emit("fallback", {
          type,
          key,
          from,
          to: to2,
          groupId: `${type}:${key}`
        });
      }
    }
    numberFormat = numberFormats[targetLocale] || {};
    format4 = numberFormat[key];
    if (isPlainObject(format4))
      break;
    handleMissing(context, key, targetLocale, missingWarn, type);
    from = to2;
  }
  if (!isPlainObject(format4) || !isString(targetLocale)) {
    return unresolving ? NOT_REOSLVED : key;
  }
  let id2 = `${targetLocale}__${key}`;
  if (!isEmptyObject(overrides)) {
    id2 = `${id2}__${JSON.stringify(overrides)}`;
  }
  let formatter = __numberFormatters.get(id2);
  if (!formatter) {
    formatter = new Intl.NumberFormat(targetLocale, assign({}, format4, overrides));
    __numberFormatters.set(id2, formatter);
  }
  return !part ? formatter.format(value) : formatter.formatToParts(value);
}
var NUMBER_FORMAT_OPTIONS_KEYS = [
  "localeMatcher",
  "style",
  "currency",
  "currencyDisplay",
  "currencySign",
  "useGrouping",
  "minimumIntegerDigits",
  "minimumFractionDigits",
  "maximumFractionDigits",
  "minimumSignificantDigits",
  "maximumSignificantDigits",
  "compactDisplay",
  "notation",
  "signDisplay",
  "unit",
  "unitDisplay",
  "roundingMode",
  "roundingPriority",
  "roundingIncrement",
  "trailingZeroDisplay"
];
function parseNumberArgs(...args) {
  const [arg1, arg2, arg3, arg4] = args;
  const options = create();
  let overrides = create();
  if (!isNumber(arg1)) {
    throw createCoreError(CoreErrorCodes.INVALID_ARGUMENT);
  }
  const value = arg1;
  if (isString(arg2)) {
    options.key = arg2;
  } else if (isPlainObject(arg2)) {
    Object.keys(arg2).forEach((key) => {
      if (NUMBER_FORMAT_OPTIONS_KEYS.includes(key)) {
        overrides[key] = arg2[key];
      } else {
        options[key] = arg2[key];
      }
    });
  }
  if (isString(arg3)) {
    options.locale = arg3;
  } else if (isPlainObject(arg3)) {
    overrides = arg3;
  }
  if (isPlainObject(arg4)) {
    overrides = arg4;
  }
  return [options.key || "", value, options, overrides];
}
function clearNumberFormat(ctx, locale, format4) {
  const context = ctx;
  for (const key in format4) {
    const id2 = `${locale}__${key}`;
    if (!context.__numberFormatters.has(id2)) {
      continue;
    }
    context.__numberFormatters.delete(id2);
  }
}
{
  initFeatureFlags();
}

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/env.js
function getDevtoolsGlobalHook() {
  return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
  return typeof navigator !== "undefined" && typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : {};
}
var isProxyAvailable = typeof Proxy === "function";

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/const.js
var HOOK_SETUP = "devtools-plugin:setup";
var HOOK_PLUGIN_SETTINGS_SET = "plugin:settings:set";

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/time.js
var supported;
var perf;
function isPerformanceSupported() {
  var _a2;
  if (supported !== void 0) {
    return supported;
  }
  if (typeof window !== "undefined" && window.performance) {
    supported = true;
    perf = window.performance;
  } else if (typeof globalThis !== "undefined" && ((_a2 = globalThis.perf_hooks) === null || _a2 === void 0 ? void 0 : _a2.performance)) {
    supported = true;
    perf = globalThis.perf_hooks.performance;
  } else {
    supported = false;
  }
  return supported;
}
function now() {
  return isPerformanceSupported() ? perf.now() : Date.now();
}

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/proxy.js
var ApiProxy = class {
  constructor(plugin, hook) {
    this.target = null;
    this.targetQueue = [];
    this.onQueue = [];
    this.plugin = plugin;
    this.hook = hook;
    const defaultSettings = {};
    if (plugin.settings) {
      for (const id2 in plugin.settings) {
        const item = plugin.settings[id2];
        defaultSettings[id2] = item.defaultValue;
      }
    }
    const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
    let currentSettings = Object.assign({}, defaultSettings);
    try {
      const raw = localStorage.getItem(localSettingsSaveId);
      const data = JSON.parse(raw);
      Object.assign(currentSettings, data);
    } catch (e16) {
    }
    this.fallbacks = {
      getSettings() {
        return currentSettings;
      },
      setSettings(value) {
        try {
          localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
        } catch (e16) {
        }
        currentSettings = value;
      },
      now() {
        return now();
      }
    };
    if (hook) {
      hook.on(HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
        if (pluginId === this.plugin.id) {
          this.fallbacks.setSettings(value);
        }
      });
    }
    this.proxiedOn = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target.on[prop];
        } else {
          return (...args) => {
            this.onQueue.push({
              method: prop,
              args
            });
          };
        }
      }
    });
    this.proxiedTarget = new Proxy({}, {
      get: (_target, prop) => {
        if (this.target) {
          return this.target[prop];
        } else if (prop === "on") {
          return this.proxiedOn;
        } else if (Object.keys(this.fallbacks).includes(prop)) {
          return (...args) => {
            this.targetQueue.push({
              method: prop,
              args,
              resolve: () => {
              }
            });
            return this.fallbacks[prop](...args);
          };
        } else {
          return (...args) => {
            return new Promise((resolve) => {
              this.targetQueue.push({
                method: prop,
                args,
                resolve
              });
            });
          };
        }
      }
    });
  }
  async setRealTarget(target) {
    this.target = target;
    for (const item of this.onQueue) {
      this.target.on[item.method](...item.args);
    }
    for (const item of this.targetQueue) {
      item.resolve(await this.target[item.method](...item.args));
    }
  }
};

// node_modules/vue-i18n/node_modules/@vue/devtools-api/lib/esm/index.js
function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
  const descriptor = pluginDescriptor;
  const target = getTarget();
  const hook = getDevtoolsGlobalHook();
  const enableProxy = isProxyAvailable && descriptor.enableEarlyProxy;
  if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
    hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
  } else {
    const proxy = enableProxy ? new ApiProxy(descriptor, hook) : null;
    const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
    list.push({
      pluginDescriptor: descriptor,
      setupFn,
      proxy
    });
    if (proxy) {
      setupFn(proxy.proxiedTarget);
    }
  }
}

// node_modules/vue-i18n/dist/vue-i18n.mjs
var VERSION2 = "9.14.2";
function initFeatureFlags2() {
  if (typeof __VUE_I18N_FULL_INSTALL__ !== "boolean") {
    getGlobalThis().__VUE_I18N_FULL_INSTALL__ = true;
  }
  if (typeof __VUE_I18N_LEGACY_API__ !== "boolean") {
    getGlobalThis().__VUE_I18N_LEGACY_API__ = true;
  }
  if (typeof __INTLIFY_JIT_COMPILATION__ !== "boolean") {
    getGlobalThis().__INTLIFY_JIT_COMPILATION__ = false;
  }
  if (typeof __INTLIFY_DROP_MESSAGE_COMPILER__ !== "boolean") {
    getGlobalThis().__INTLIFY_DROP_MESSAGE_COMPILER__ = false;
  }
  if (typeof __INTLIFY_PROD_DEVTOOLS__ !== "boolean") {
    getGlobalThis().__INTLIFY_PROD_DEVTOOLS__ = false;
  }
}
var code$12 = CoreWarnCodes.__EXTEND_POINT__;
var inc$12 = incrementer(code$12);
var I18nWarnCodes = {
  FALLBACK_TO_ROOT: code$12,
  // 9
  NOT_SUPPORTED_PRESERVE: inc$12(),
  // 10
  NOT_SUPPORTED_FORMATTER: inc$12(),
  // 11
  NOT_SUPPORTED_PRESERVE_DIRECTIVE: inc$12(),
  // 12
  NOT_SUPPORTED_GET_CHOICE_INDEX: inc$12(),
  // 13
  COMPONENT_NAME_LEGACY_COMPATIBLE: inc$12(),
  // 14
  NOT_FOUND_PARENT_SCOPE: inc$12(),
  // 15
  IGNORE_OBJ_FLATTEN: inc$12(),
  // 16
  NOTICE_DROP_ALLOW_COMPOSITION: inc$12(),
  // 17
  NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG: inc$12()
  // 18
};
var warnMessages3 = {
  [I18nWarnCodes.FALLBACK_TO_ROOT]: `Fall back to {type} '{key}' with root locale.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE]: `Not supported 'preserve'.`,
  [I18nWarnCodes.NOT_SUPPORTED_FORMATTER]: `Not supported 'formatter'.`,
  [I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE]: `Not supported 'preserveDirectiveContent'.`,
  [I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX]: `Not supported 'getChoiceIndex'.`,
  [I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE]: `Component name legacy compatible: '{name}' -> 'i18n'`,
  [I18nWarnCodes.NOT_FOUND_PARENT_SCOPE]: `Not found parent scope. use the global scope.`,
  [I18nWarnCodes.IGNORE_OBJ_FLATTEN]: `Ignore object flatten: '{key}' key has an string value`,
  [I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION]: `'allowComposition' option will be dropped in the next major version. For more information, please see 👉 https://tinyurl.com/2p97mcze`,
  [I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG]: `'translateExistCompatible' option will be dropped in the next major version.`
};
function getWarnMessage2(code3, ...args) {
  return format(warnMessages3[code3], ...args);
}
var code2 = CoreErrorCodes.__EXTEND_POINT__;
var inc2 = incrementer(code2);
var I18nErrorCodes = {
  // composer module errors
  UNEXPECTED_RETURN_TYPE: code2,
  // 24
  // legacy module errors
  INVALID_ARGUMENT: inc2(),
  // 25
  // i18n module errors
  MUST_BE_CALL_SETUP_TOP: inc2(),
  // 26
  NOT_INSTALLED: inc2(),
  // 27
  NOT_AVAILABLE_IN_LEGACY_MODE: inc2(),
  // 28
  // directive module errors
  REQUIRED_VALUE: inc2(),
  // 29
  INVALID_VALUE: inc2(),
  // 30
  // vue-devtools errors
  CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN: inc2(),
  // 31
  NOT_INSTALLED_WITH_PROVIDE: inc2(),
  // 32
  // unexpected error
  UNEXPECTED_ERROR: inc2(),
  // 33
  // not compatible legacy vue-i18n constructor
  NOT_COMPATIBLE_LEGACY_VUE_I18N: inc2(),
  // 34
  // bridge support vue 2.x only
  BRIDGE_SUPPORT_VUE_2_ONLY: inc2(),
  // 35
  // need to define `i18n` option in `allowComposition: true` and `useScope: 'local' at `useI18n``
  MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION: inc2(),
  // 36
  // Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly
  NOT_AVAILABLE_COMPOSITION_IN_LEGACY: inc2(),
  // 37
  // for enhancement
  __EXTEND_POINT__: inc2()
  // 38
};
function createI18nError(code3, ...args) {
  return createCompileError(code3, null, true ? { messages: errorMessages3, args } : void 0);
}
var errorMessages3 = {
  [I18nErrorCodes.UNEXPECTED_RETURN_TYPE]: "Unexpected return type in composer",
  [I18nErrorCodes.INVALID_ARGUMENT]: "Invalid argument",
  [I18nErrorCodes.MUST_BE_CALL_SETUP_TOP]: "Must be called at the top of a `setup` function",
  [I18nErrorCodes.NOT_INSTALLED]: "Need to install with `app.use` function",
  [I18nErrorCodes.UNEXPECTED_ERROR]: "Unexpected error",
  [I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE]: "Not available in legacy mode",
  [I18nErrorCodes.REQUIRED_VALUE]: `Required in value: {0}`,
  [I18nErrorCodes.INVALID_VALUE]: `Invalid value`,
  [I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN]: `Cannot setup vue-devtools plugin`,
  [I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE]: "Need to install with `provide` function",
  [I18nErrorCodes.NOT_COMPATIBLE_LEGACY_VUE_I18N]: "Not compatible legacy VueI18n.",
  [I18nErrorCodes.BRIDGE_SUPPORT_VUE_2_ONLY]: "vue-i18n-bridge support Vue 2.x only",
  [I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION]: "Must define ‘i18n’ option or custom block in Composition API with using local scope in Legacy API mode",
  [I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY]: "Not available Compostion API in Legacy API mode. Please make sure that the legacy API mode is working properly"
};
var TranslateVNodeSymbol = makeSymbol("__translateVNode");
var DatetimePartsSymbol = makeSymbol("__datetimeParts");
var NumberPartsSymbol = makeSymbol("__numberParts");
var EnableEmitter = makeSymbol("__enableEmitter");
var DisableEmitter = makeSymbol("__disableEmitter");
var SetPluralRulesSymbol = makeSymbol("__setPluralRules");
makeSymbol("__intlifyMeta");
var InejctWithOptionSymbol = makeSymbol("__injectWithOption");
var DisposeSymbol = makeSymbol("__dispose");
function handleFlatJson(obj) {
  if (!isObject(obj)) {
    return obj;
  }
  for (const key in obj) {
    if (!hasOwn(obj, key)) {
      continue;
    }
    if (!key.includes(".")) {
      if (isObject(obj[key])) {
        handleFlatJson(obj[key]);
      }
    } else {
      const subKeys = key.split(".");
      const lastIndex = subKeys.length - 1;
      let currentObj = obj;
      let hasStringValue = false;
      for (let i = 0; i < lastIndex; i++) {
        if (!(subKeys[i] in currentObj)) {
          currentObj[subKeys[i]] = create();
        }
        if (!isObject(currentObj[subKeys[i]])) {
          warn(getWarnMessage2(I18nWarnCodes.IGNORE_OBJ_FLATTEN, {
            key: subKeys[i]
          }));
          hasStringValue = true;
          break;
        }
        currentObj = currentObj[subKeys[i]];
      }
      if (!hasStringValue) {
        currentObj[subKeys[lastIndex]] = obj[key];
        delete obj[key];
      }
      if (isObject(currentObj[subKeys[lastIndex]])) {
        handleFlatJson(currentObj[subKeys[lastIndex]]);
      }
    }
  }
  return obj;
}
function getLocaleMessages(locale, options) {
  const { messages, __i18n, messageResolver, flatJson } = options;
  const ret = isPlainObject(messages) ? messages : isArray(__i18n) ? create() : { [locale]: create() };
  if (isArray(__i18n)) {
    __i18n.forEach((custom) => {
      if ("locale" in custom && "resource" in custom) {
        const { locale: locale2, resource } = custom;
        if (locale2) {
          ret[locale2] = ret[locale2] || create();
          deepCopy(resource, ret[locale2]);
        } else {
          deepCopy(resource, ret);
        }
      } else {
        isString(custom) && deepCopy(JSON.parse(custom), ret);
      }
    });
  }
  if (messageResolver == null && flatJson) {
    for (const key in ret) {
      if (hasOwn(ret, key)) {
        handleFlatJson(ret[key]);
      }
    }
  }
  return ret;
}
function getComponentOptions(instance) {
  return instance.type;
}
function adjustI18nResources(gl, options, componentOptions) {
  let messages = isObject(options.messages) ? options.messages : create();
  if ("__i18nGlobal" in componentOptions) {
    messages = getLocaleMessages(gl.locale.value, {
      messages,
      __i18n: componentOptions.__i18nGlobal
    });
  }
  const locales = Object.keys(messages);
  if (locales.length) {
    locales.forEach((locale) => {
      gl.mergeLocaleMessage(locale, messages[locale]);
    });
  }
  {
    if (isObject(options.datetimeFormats)) {
      const locales2 = Object.keys(options.datetimeFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeDateTimeFormat(locale, options.datetimeFormats[locale]);
        });
      }
    }
    if (isObject(options.numberFormats)) {
      const locales2 = Object.keys(options.numberFormats);
      if (locales2.length) {
        locales2.forEach((locale) => {
          gl.mergeNumberFormat(locale, options.numberFormats[locale]);
        });
      }
    }
  }
}
function createTextNode(key) {
  return createVNode(Text, null, key, 0);
}
var DEVTOOLS_META = "__INTLIFY_META__";
var NOOP_RETURN_ARRAY = () => [];
var NOOP_RETURN_FALSE = () => false;
var composerID = 0;
function defineCoreMissingHandler(missing) {
  return (ctx, locale, key, type) => {
    return missing(locale, key, getCurrentInstance() || void 0, type);
  };
}
var getMetaInfo = () => {
  const instance = getCurrentInstance();
  let meta = null;
  return instance && (meta = getComponentOptions(instance)[DEVTOOLS_META]) ? { [DEVTOOLS_META]: meta } : null;
};
function createComposer(options = {}, VueI18nLegacy) {
  const { __root, __injectWithOption } = options;
  const _isGlobal = __root === void 0;
  const flatJson = options.flatJson;
  const _ref = inBrowser ? ref : shallowRef;
  const translateExistCompatible = !!options.translateExistCompatible;
  if (true) {
    if (translateExistCompatible && true) {
      warnOnce(getWarnMessage2(I18nWarnCodes.NOTICE_DROP_TRANSLATE_EXIST_COMPATIBLE_FLAG));
    }
  }
  let _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : true;
  const _locale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = _ref(
    // prettier-ignore
    __root && _inheritLocale ? __root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = _ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = _ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = _ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  let _missingWarn = __root ? __root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  let _fallbackWarn = __root ? __root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  let _fallbackRoot = __root ? __root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  let _fallbackFormat = !!options.fallbackFormat;
  let _missing = isFunction(options.missing) ? options.missing : null;
  let _runtimeMissing = isFunction(options.missing) ? defineCoreMissingHandler(options.missing) : null;
  let _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  let _warnHtmlMessage = __root ? __root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  let _escapeParameter = !!options.escapeParameter;
  const _modifiers = __root ? __root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  let _pluralRules = options.pluralRules || __root && __root.pluralRules;
  let _context;
  const getCoreContext = () => {
    _isGlobal && setFallbackContext(null);
    const ctxOptions = {
      version: VERSION2,
      locale: _locale.value,
      fallbackLocale: _fallbackLocale.value,
      messages: _messages.value,
      modifiers: _modifiers,
      pluralRules: _pluralRules,
      missing: _runtimeMissing === null ? void 0 : _runtimeMissing,
      missingWarn: _missingWarn,
      fallbackWarn: _fallbackWarn,
      fallbackFormat: _fallbackFormat,
      unresolving: true,
      postTranslation: _postTranslation === null ? void 0 : _postTranslation,
      warnHtmlMessage: _warnHtmlMessage,
      escapeParameter: _escapeParameter,
      messageResolver: options.messageResolver,
      messageCompiler: options.messageCompiler,
      __meta: { framework: "vue" }
    };
    {
      ctxOptions.datetimeFormats = _datetimeFormats.value;
      ctxOptions.numberFormats = _numberFormats.value;
      ctxOptions.__datetimeFormatters = isPlainObject(_context) ? _context.__datetimeFormatters : void 0;
      ctxOptions.__numberFormatters = isPlainObject(_context) ? _context.__numberFormatters : void 0;
    }
    if (true) {
      ctxOptions.__v_emitter = isPlainObject(_context) ? _context.__v_emitter : void 0;
    }
    const ctx = createCoreContext(ctxOptions);
    _isGlobal && setFallbackContext(ctx);
    return ctx;
  };
  _context = getCoreContext();
  updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => _locale.value,
    set: (val) => {
      _locale.value = val;
      _context.locale = _locale.value;
    }
  });
  const fallbackLocale = computed({
    get: () => _fallbackLocale.value,
    set: (val) => {
      _fallbackLocale.value = val;
      _context.fallbackLocale = _fallbackLocale.value;
      updateFallbackLocale(_context, _locale.value, val);
    }
  });
  const messages = computed(() => _messages.value);
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return isFunction(_postTranslation) ? _postTranslation : null;
  }
  function setPostTranslationHandler(handler) {
    _postTranslation = handler;
    _context.postTranslation = handler;
  }
  function getMissingHandler() {
    return _missing;
  }
  function setMissingHandler(handler) {
    if (handler !== null) {
      _runtimeMissing = defineCoreMissingHandler(handler);
    }
    _missing = handler;
    _context.missing = _runtimeMissing;
  }
  function isResolvedTranslateMessage(type, arg) {
    return type !== "translate" || !arg.resolvedMessage;
  }
  const wrapWithDeps = (fn2, argumentParser, warnType, fallbackSuccess, fallbackFail, successCondition) => {
    trackReactivityValues();
    let ret;
    try {
      if (true) {
        setAdditionalMeta(getMetaInfo());
      }
      if (!_isGlobal) {
        _context.fallbackContext = __root ? getFallbackContext() : void 0;
      }
      ret = fn2(_context);
    } finally {
      if (true) {
        setAdditionalMeta(null);
      }
      if (!_isGlobal) {
        _context.fallbackContext = void 0;
      }
    }
    if (warnType !== "translate exists" && // for not `te` (e.g `t`)
    isNumber(ret) && ret === NOT_REOSLVED || warnType === "translate exists" && !ret) {
      const [key, arg2] = argumentParser();
      if (__root && isString(key) && isResolvedTranslateMessage(warnType, arg2)) {
        if (_fallbackRoot && (isTranslateFallbackWarn(_fallbackWarn, key) || isTranslateMissingWarn(_missingWarn, key))) {
          warn(getWarnMessage2(I18nWarnCodes.FALLBACK_TO_ROOT, {
            key,
            type: warnType
          }));
        }
        if (true) {
          const { __v_emitter: emitter } = _context;
          if (emitter && _fallbackRoot) {
            emitter.emit("fallback", {
              type: warnType,
              key,
              to: "global",
              groupId: `${warnType}:${key}`
            });
          }
        }
      }
      return __root && _fallbackRoot ? fallbackSuccess(__root) : fallbackFail(key);
    } else if (successCondition(ret)) {
      return ret;
    } else {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_RETURN_TYPE);
    }
  };
  function t10(...args) {
    return wrapWithDeps((context) => Reflect.apply(translate, null, [context, ...args]), () => parseTranslateArgs(...args), "translate", (root) => Reflect.apply(root.t, root, [...args]), (key) => key, (val) => isString(val));
  }
  function rt(...args) {
    const [arg1, arg2, arg3] = args;
    if (arg3 && !isObject(arg3)) {
      throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
    }
    return t10(...[arg1, arg2, assign({ resolvedMessage: true }, arg3 || {})]);
  }
  function d(...args) {
    return wrapWithDeps((context) => Reflect.apply(datetime, null, [context, ...args]), () => parseDateTimeArgs(...args), "datetime format", (root) => Reflect.apply(root.d, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
  }
  function n(...args) {
    return wrapWithDeps((context) => Reflect.apply(number, null, [context, ...args]), () => parseNumberArgs(...args), "number format", (root) => Reflect.apply(root.n, root, [...args]), () => MISSING_RESOLVE_VALUE, (val) => isString(val));
  }
  function normalize(values) {
    return values.map((val) => isString(val) || isNumber(val) || isBoolean(val) ? createTextNode(String(val)) : val);
  }
  const interpolate = (val) => val;
  const processor = {
    normalize,
    interpolate,
    type: "vnode"
  };
  function translateVNode(...args) {
    return wrapWithDeps(
      (context) => {
        let ret;
        const _context2 = context;
        try {
          _context2.processor = processor;
          ret = Reflect.apply(translate, null, [_context2, ...args]);
        } finally {
          _context2.processor = null;
        }
        return ret;
      },
      () => parseTranslateArgs(...args),
      "translate",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[TranslateVNodeSymbol](...args),
      (key) => [createTextNode(key)],
      (val) => isArray(val)
    );
  }
  function numberParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(number, null, [context, ...args]),
      () => parseNumberArgs(...args),
      "number format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[NumberPartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString(val) || isArray(val)
    );
  }
  function datetimeParts(...args) {
    return wrapWithDeps(
      (context) => Reflect.apply(datetime, null, [context, ...args]),
      () => parseDateTimeArgs(...args),
      "datetime format",
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (root) => root[DatetimePartsSymbol](...args),
      NOOP_RETURN_ARRAY,
      (val) => isString(val) || isArray(val)
    );
  }
  function setPluralRules(rules) {
    _pluralRules = rules;
    _context.pluralRules = _pluralRules;
  }
  function te(key, locale2) {
    return wrapWithDeps(() => {
      if (!key) {
        return false;
      }
      const targetLocale = isString(locale2) ? locale2 : _locale.value;
      const message = getLocaleMessage(targetLocale);
      const resolved = _context.messageResolver(message, key);
      return !translateExistCompatible ? isMessageAST(resolved) || isMessageFunction(resolved) || isString(resolved) : resolved != null;
    }, () => [key], "translate exists", (root) => {
      return Reflect.apply(root.te, root, [key, locale2]);
    }, NOOP_RETURN_FALSE, (val) => isBoolean(val));
  }
  function resolveMessages(key) {
    let messages2 = null;
    const locales = fallbackWithLocaleChain(_context, _fallbackLocale.value, _locale.value);
    for (let i = 0; i < locales.length; i++) {
      const targetLocaleMessages = _messages.value[locales[i]] || {};
      const messageValue = _context.messageResolver(targetLocaleMessages, key);
      if (messageValue != null) {
        messages2 = messageValue;
        break;
      }
    }
    return messages2;
  }
  function tm2(key) {
    const messages2 = resolveMessages(key);
    return messages2 != null ? messages2 : __root ? __root.tm(key) || {} : {};
  }
  function getLocaleMessage(locale2) {
    return _messages.value[locale2] || {};
  }
  function setLocaleMessage(locale2, message) {
    if (flatJson) {
      const _message = { [locale2]: message };
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
      message = _message[locale2];
    }
    _messages.value[locale2] = message;
    _context.messages = _messages.value;
  }
  function mergeLocaleMessage(locale2, message) {
    _messages.value[locale2] = _messages.value[locale2] || {};
    const _message = { [locale2]: message };
    if (flatJson) {
      for (const key in _message) {
        if (hasOwn(_message, key)) {
          handleFlatJson(_message[key]);
        }
      }
    }
    message = _message[locale2];
    deepCopy(message, _messages.value[locale2]);
    _context.messages = _messages.value;
  }
  function getDateTimeFormat(locale2) {
    return _datetimeFormats.value[locale2] || {};
  }
  function setDateTimeFormat(locale2, format4) {
    _datetimeFormats.value[locale2] = format4;
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format4);
  }
  function mergeDateTimeFormat(locale2, format4) {
    _datetimeFormats.value[locale2] = assign(_datetimeFormats.value[locale2] || {}, format4);
    _context.datetimeFormats = _datetimeFormats.value;
    clearDateTimeFormat(_context, locale2, format4);
  }
  function getNumberFormat(locale2) {
    return _numberFormats.value[locale2] || {};
  }
  function setNumberFormat(locale2, format4) {
    _numberFormats.value[locale2] = format4;
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format4);
  }
  function mergeNumberFormat(locale2, format4) {
    _numberFormats.value[locale2] = assign(_numberFormats.value[locale2] || {}, format4);
    _context.numberFormats = _numberFormats.value;
    clearNumberFormat(_context, locale2, format4);
  }
  composerID++;
  if (__root && inBrowser) {
    watch(__root.locale, (val) => {
      if (_inheritLocale) {
        _locale.value = val;
        _context.locale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
    watch(__root.fallbackLocale, (val) => {
      if (_inheritLocale) {
        _fallbackLocale.value = val;
        _context.fallbackLocale = val;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    });
  }
  const composer = {
    id: composerID,
    locale,
    fallbackLocale,
    get inheritLocale() {
      return _inheritLocale;
    },
    set inheritLocale(val) {
      _inheritLocale = val;
      if (val && __root) {
        _locale.value = __root.locale.value;
        _fallbackLocale.value = __root.fallbackLocale.value;
        updateFallbackLocale(_context, _locale.value, _fallbackLocale.value);
      }
    },
    get availableLocales() {
      return Object.keys(_messages.value).sort();
    },
    messages,
    get modifiers() {
      return _modifiers;
    },
    get pluralRules() {
      return _pluralRules || {};
    },
    get isGlobal() {
      return _isGlobal;
    },
    get missingWarn() {
      return _missingWarn;
    },
    set missingWarn(val) {
      _missingWarn = val;
      _context.missingWarn = _missingWarn;
    },
    get fallbackWarn() {
      return _fallbackWarn;
    },
    set fallbackWarn(val) {
      _fallbackWarn = val;
      _context.fallbackWarn = _fallbackWarn;
    },
    get fallbackRoot() {
      return _fallbackRoot;
    },
    set fallbackRoot(val) {
      _fallbackRoot = val;
    },
    get fallbackFormat() {
      return _fallbackFormat;
    },
    set fallbackFormat(val) {
      _fallbackFormat = val;
      _context.fallbackFormat = _fallbackFormat;
    },
    get warnHtmlMessage() {
      return _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      _warnHtmlMessage = val;
      _context.warnHtmlMessage = val;
    },
    get escapeParameter() {
      return _escapeParameter;
    },
    set escapeParameter(val) {
      _escapeParameter = val;
      _context.escapeParameter = val;
    },
    t: t10,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    [SetPluralRulesSymbol]: setPluralRules
  };
  {
    composer.datetimeFormats = datetimeFormats;
    composer.numberFormats = numberFormats;
    composer.rt = rt;
    composer.te = te;
    composer.tm = tm2;
    composer.d = d;
    composer.n = n;
    composer.getDateTimeFormat = getDateTimeFormat;
    composer.setDateTimeFormat = setDateTimeFormat;
    composer.mergeDateTimeFormat = mergeDateTimeFormat;
    composer.getNumberFormat = getNumberFormat;
    composer.setNumberFormat = setNumberFormat;
    composer.mergeNumberFormat = mergeNumberFormat;
    composer[InejctWithOptionSymbol] = __injectWithOption;
    composer[TranslateVNodeSymbol] = translateVNode;
    composer[DatetimePartsSymbol] = datetimeParts;
    composer[NumberPartsSymbol] = numberParts;
  }
  if (true) {
    composer[EnableEmitter] = (emitter) => {
      _context.__v_emitter = emitter;
    };
    composer[DisableEmitter] = () => {
      _context.__v_emitter = void 0;
    };
  }
  return composer;
}
function convertComposerOptions(options) {
  const locale = isString(options.locale) ? options.locale : DEFAULT_LOCALE;
  const fallbackLocale = isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : locale;
  const missing = isFunction(options.missing) ? options.missing : void 0;
  const missingWarn = isBoolean(options.silentTranslationWarn) || isRegExp(options.silentTranslationWarn) ? !options.silentTranslationWarn : true;
  const fallbackWarn = isBoolean(options.silentFallbackWarn) || isRegExp(options.silentFallbackWarn) ? !options.silentFallbackWarn : true;
  const fallbackRoot = isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const fallbackFormat = !!options.formatFallbackMessages;
  const modifiers = isPlainObject(options.modifiers) ? options.modifiers : {};
  const pluralizationRules = options.pluralizationRules;
  const postTranslation = isFunction(options.postTranslation) ? options.postTranslation : void 0;
  const warnHtmlMessage = isString(options.warnHtmlInMessage) ? options.warnHtmlInMessage !== "off" : true;
  const escapeParameter = !!options.escapeParameterHtml;
  const inheritLocale = isBoolean(options.sync) ? options.sync : true;
  if (options.formatter) {
    warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
  }
  if (options.preserveDirectiveContent) {
    warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
  }
  let messages = options.messages;
  if (isPlainObject(options.sharedMessages)) {
    const sharedMessages = options.sharedMessages;
    const locales = Object.keys(sharedMessages);
    messages = locales.reduce((messages2, locale2) => {
      const message = messages2[locale2] || (messages2[locale2] = {});
      assign(message, sharedMessages[locale2]);
      return messages2;
    }, messages || {});
  }
  const { __i18n, __root, __injectWithOption } = options;
  const datetimeFormats = options.datetimeFormats;
  const numberFormats = options.numberFormats;
  const flatJson = options.flatJson;
  const translateExistCompatible = options.translateExistCompatible;
  return {
    locale,
    fallbackLocale,
    messages,
    flatJson,
    datetimeFormats,
    numberFormats,
    missing,
    missingWarn,
    fallbackWarn,
    fallbackRoot,
    fallbackFormat,
    modifiers,
    pluralRules: pluralizationRules,
    postTranslation,
    warnHtmlMessage,
    escapeParameter,
    messageResolver: options.messageResolver,
    inheritLocale,
    translateExistCompatible,
    __i18n,
    __root,
    __injectWithOption
  };
}
function createVueI18n(options = {}, VueI18nLegacy) {
  {
    const composer = createComposer(convertComposerOptions(options));
    const { __extender } = options;
    const vueI18n = {
      // id
      id: composer.id,
      // locale
      get locale() {
        return composer.locale.value;
      },
      set locale(val) {
        composer.locale.value = val;
      },
      // fallbackLocale
      get fallbackLocale() {
        return composer.fallbackLocale.value;
      },
      set fallbackLocale(val) {
        composer.fallbackLocale.value = val;
      },
      // messages
      get messages() {
        return composer.messages.value;
      },
      // datetimeFormats
      get datetimeFormats() {
        return composer.datetimeFormats.value;
      },
      // numberFormats
      get numberFormats() {
        return composer.numberFormats.value;
      },
      // availableLocales
      get availableLocales() {
        return composer.availableLocales;
      },
      // formatter
      get formatter() {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
        return {
          interpolate() {
            return [];
          }
        };
      },
      set formatter(val) {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_FORMATTER));
      },
      // missing
      get missing() {
        return composer.getMissingHandler();
      },
      set missing(handler) {
        composer.setMissingHandler(handler);
      },
      // silentTranslationWarn
      get silentTranslationWarn() {
        return isBoolean(composer.missingWarn) ? !composer.missingWarn : composer.missingWarn;
      },
      set silentTranslationWarn(val) {
        composer.missingWarn = isBoolean(val) ? !val : val;
      },
      // silentFallbackWarn
      get silentFallbackWarn() {
        return isBoolean(composer.fallbackWarn) ? !composer.fallbackWarn : composer.fallbackWarn;
      },
      set silentFallbackWarn(val) {
        composer.fallbackWarn = isBoolean(val) ? !val : val;
      },
      // modifiers
      get modifiers() {
        return composer.modifiers;
      },
      // formatFallbackMessages
      get formatFallbackMessages() {
        return composer.fallbackFormat;
      },
      set formatFallbackMessages(val) {
        composer.fallbackFormat = val;
      },
      // postTranslation
      get postTranslation() {
        return composer.getPostTranslationHandler();
      },
      set postTranslation(handler) {
        composer.setPostTranslationHandler(handler);
      },
      // sync
      get sync() {
        return composer.inheritLocale;
      },
      set sync(val) {
        composer.inheritLocale = val;
      },
      // warnInHtmlMessage
      get warnHtmlInMessage() {
        return composer.warnHtmlMessage ? "warn" : "off";
      },
      set warnHtmlInMessage(val) {
        composer.warnHtmlMessage = val !== "off";
      },
      // escapeParameterHtml
      get escapeParameterHtml() {
        return composer.escapeParameter;
      },
      set escapeParameterHtml(val) {
        composer.escapeParameter = val;
      },
      // preserveDirectiveContent
      get preserveDirectiveContent() {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
        return true;
      },
      set preserveDirectiveContent(val) {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_PRESERVE_DIRECTIVE));
      },
      // pluralizationRules
      get pluralizationRules() {
        return composer.pluralRules || {};
      },
      // for internal
      __composer: composer,
      // t
      t(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = {};
        let list = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      rt(...args) {
        return Reflect.apply(composer.rt, composer, [...args]);
      },
      // tc
      tc(...args) {
        const [arg1, arg2, arg3] = args;
        const options2 = { plural: 1 };
        let list = null;
        let named = null;
        if (!isString(arg1)) {
          throw createI18nError(I18nErrorCodes.INVALID_ARGUMENT);
        }
        const key = arg1;
        if (isString(arg2)) {
          options2.locale = arg2;
        } else if (isNumber(arg2)) {
          options2.plural = arg2;
        } else if (isArray(arg2)) {
          list = arg2;
        } else if (isPlainObject(arg2)) {
          named = arg2;
        }
        if (isString(arg3)) {
          options2.locale = arg3;
        } else if (isArray(arg3)) {
          list = arg3;
        } else if (isPlainObject(arg3)) {
          named = arg3;
        }
        return Reflect.apply(composer.t, composer, [
          key,
          list || named || {},
          options2
        ]);
      },
      // te
      te(key, locale) {
        return composer.te(key, locale);
      },
      // tm
      tm(key) {
        return composer.tm(key);
      },
      // getLocaleMessage
      getLocaleMessage(locale) {
        return composer.getLocaleMessage(locale);
      },
      // setLocaleMessage
      setLocaleMessage(locale, message) {
        composer.setLocaleMessage(locale, message);
      },
      // mergeLocaleMessage
      mergeLocaleMessage(locale, message) {
        composer.mergeLocaleMessage(locale, message);
      },
      // d
      d(...args) {
        return Reflect.apply(composer.d, composer, [...args]);
      },
      // getDateTimeFormat
      getDateTimeFormat(locale) {
        return composer.getDateTimeFormat(locale);
      },
      // setDateTimeFormat
      setDateTimeFormat(locale, format4) {
        composer.setDateTimeFormat(locale, format4);
      },
      // mergeDateTimeFormat
      mergeDateTimeFormat(locale, format4) {
        composer.mergeDateTimeFormat(locale, format4);
      },
      // n
      n(...args) {
        return Reflect.apply(composer.n, composer, [...args]);
      },
      // getNumberFormat
      getNumberFormat(locale) {
        return composer.getNumberFormat(locale);
      },
      // setNumberFormat
      setNumberFormat(locale, format4) {
        composer.setNumberFormat(locale, format4);
      },
      // mergeNumberFormat
      mergeNumberFormat(locale, format4) {
        composer.mergeNumberFormat(locale, format4);
      },
      // getChoiceIndex
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getChoiceIndex(choice, choicesLength) {
        warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_GET_CHOICE_INDEX));
        return -1;
      }
    };
    vueI18n.__extender = __extender;
    if (true) {
      vueI18n.__enableEmitter = (emitter) => {
        const __composer = composer;
        __composer[EnableEmitter] && __composer[EnableEmitter](emitter);
      };
      vueI18n.__disableEmitter = () => {
        const __composer = composer;
        __composer[DisableEmitter] && __composer[DisableEmitter]();
      };
    }
    return vueI18n;
  }
}
var baseFormatProps = {
  tag: {
    type: [String, Object]
  },
  locale: {
    type: String
  },
  scope: {
    type: String,
    // NOTE: avoid https://github.com/microsoft/rushstack/issues/1050
    validator: (val) => val === "parent" || val === "global",
    default: "parent"
    /* ComponentI18nScope */
  },
  i18n: {
    type: Object
  }
};
function getInterpolateArg({ slots }, keys) {
  if (keys.length === 1 && keys[0] === "default") {
    const ret = slots.default ? slots.default() : [];
    return ret.reduce((slot, current) => {
      return [
        ...slot,
        // prettier-ignore
        ...current.type === Fragment ? current.children : [current]
      ];
    }, []);
  } else {
    return keys.reduce((arg, key) => {
      const slot = slots[key];
      if (slot) {
        arg[key] = slot();
      }
      return arg;
    }, create());
  }
}
function getFragmentableTag(tag) {
  return Fragment;
}
var TranslationImpl = defineComponent({
  /* eslint-disable */
  name: "i18n-t",
  props: assign({
    keypath: {
      type: String,
      required: true
    },
    plural: {
      type: [Number, String],
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      validator: (val) => isNumber(val) || !isNaN(val)
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const { slots, attrs } = context;
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return () => {
      const keys = Object.keys(slots).filter((key) => key !== "_");
      const options = create();
      if (props.locale) {
        options.locale = props.locale;
      }
      if (props.plural !== void 0) {
        options.plural = isString(props.plural) ? +props.plural : props.plural;
      }
      const arg = getInterpolateArg(context, keys);
      const children = i18n[TranslateVNodeSymbol](props.keypath, arg, options);
      const assignedAttrs = assign(create(), attrs);
      const tag = isString(props.tag) || isObject(props.tag) ? props.tag : getFragmentableTag();
      return h(tag, assignedAttrs, children);
    };
  }
});
var Translation = TranslationImpl;
function isVNode2(target) {
  return isArray(target) && !isString(target[0]);
}
function renderFormatter(props, context, slotKeys, partFormatter) {
  const { slots, attrs } = context;
  return () => {
    const options = { part: true };
    let overrides = create();
    if (props.locale) {
      options.locale = props.locale;
    }
    if (isString(props.format)) {
      options.key = props.format;
    } else if (isObject(props.format)) {
      if (isString(props.format.key)) {
        options.key = props.format.key;
      }
      overrides = Object.keys(props.format).reduce((options2, prop) => {
        return slotKeys.includes(prop) ? assign(create(), options2, { [prop]: props.format[prop] }) : options2;
      }, create());
    }
    const parts = partFormatter(...[props.value, options, overrides]);
    let children = [options.key];
    if (isArray(parts)) {
      children = parts.map((part, index2) => {
        const slot = slots[part.type];
        const node = slot ? slot({ [part.type]: part.value, index: index2, parts }) : [part.value];
        if (isVNode2(node)) {
          node[0].key = `${part.type}-${index2}`;
        }
        return node;
      });
    } else if (isString(parts)) {
      children = [parts];
    }
    const assignedAttrs = assign(create(), attrs);
    const tag = isString(props.tag) || isObject(props.tag) ? props.tag : getFragmentableTag();
    return h(tag, assignedAttrs, children);
  };
}
var NumberFormatImpl = defineComponent({
  /* eslint-disable */
  name: "i18n-n",
  props: assign({
    value: {
      type: Number,
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, NUMBER_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[NumberPartsSymbol](...args)
    ));
  }
});
var NumberFormat = NumberFormatImpl;
var DatetimeFormatImpl = defineComponent({
  /* eslint-disable */
  name: "i18n-d",
  props: assign({
    value: {
      type: [Number, Date],
      required: true
    },
    format: {
      type: [String, Object]
    }
  }, baseFormatProps),
  /* eslint-enable */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  setup(props, context) {
    const i18n = props.i18n || useI18n({
      useScope: props.scope,
      __useComponent: true
    });
    return renderFormatter(props, context, DATETIME_FORMAT_OPTIONS_KEYS, (...args) => (
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      i18n[DatetimePartsSymbol](...args)
    ));
  }
});
var DatetimeFormat = DatetimeFormatImpl;
function getComposer$2(i18n, instance) {
  const i18nInternal = i18n;
  if (i18n.mode === "composition") {
    return i18nInternal.__getInstance(instance) || i18n.global;
  } else {
    const vueI18n = i18nInternal.__getInstance(instance);
    return vueI18n != null ? vueI18n.__composer : i18n.global.__composer;
  }
}
function vTDirective(i18n) {
  const _process = (binding) => {
    const { instance, modifiers, value } = binding;
    if (!instance || !instance.$) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const composer = getComposer$2(i18n, instance.$);
    if (modifiers.preserve) {
      warn(getWarnMessage2(I18nWarnCodes.NOT_SUPPORTED_PRESERVE));
    }
    const parsedValue = parseValue(value);
    return [
      Reflect.apply(composer.t, composer, [...makeParams(parsedValue)]),
      composer
    ];
  };
  const register = (el2, binding) => {
    const [textContent, composer] = _process(binding);
    if (inBrowser && i18n.global === composer) {
      el2.__i18nWatcher = watch(composer.locale, () => {
        binding.instance && binding.instance.$forceUpdate();
      });
    }
    el2.__composer = composer;
    el2.textContent = textContent;
  };
  const unregister = (el2) => {
    if (inBrowser && el2.__i18nWatcher) {
      el2.__i18nWatcher();
      el2.__i18nWatcher = void 0;
      delete el2.__i18nWatcher;
    }
    if (el2.__composer) {
      el2.__composer = void 0;
      delete el2.__composer;
    }
  };
  const update = (el2, { value }) => {
    if (el2.__composer) {
      const composer = el2.__composer;
      const parsedValue = parseValue(value);
      el2.textContent = Reflect.apply(composer.t, composer, [
        ...makeParams(parsedValue)
      ]);
    }
  };
  const getSSRProps = (binding) => {
    const [textContent] = _process(binding);
    return { textContent };
  };
  return {
    created: register,
    unmounted: unregister,
    beforeUpdate: update,
    getSSRProps
  };
}
function parseValue(value) {
  if (isString(value)) {
    return { path: value };
  } else if (isPlainObject(value)) {
    if (!("path" in value)) {
      throw createI18nError(I18nErrorCodes.REQUIRED_VALUE, "path");
    }
    return value;
  } else {
    throw createI18nError(I18nErrorCodes.INVALID_VALUE);
  }
}
function makeParams(value) {
  const { path, locale, args, choice, plural } = value;
  const options = {};
  const named = args || {};
  if (isString(locale)) {
    options.locale = locale;
  }
  if (isNumber(choice)) {
    options.plural = choice;
  }
  if (isNumber(plural)) {
    options.plural = plural;
  }
  return [path, named, options];
}
function apply(app, i18n, ...options) {
  const pluginOptions = isPlainObject(options[0]) ? options[0] : {};
  const useI18nComponentName = !!pluginOptions.useI18nComponentName;
  const globalInstall = isBoolean(pluginOptions.globalInstall) ? pluginOptions.globalInstall : true;
  if (globalInstall && useI18nComponentName) {
    warn(getWarnMessage2(I18nWarnCodes.COMPONENT_NAME_LEGACY_COMPATIBLE, {
      name: Translation.name
    }));
  }
  if (globalInstall) {
    [!useI18nComponentName ? Translation.name : "i18n", "I18nT"].forEach((name) => app.component(name, Translation));
    [NumberFormat.name, "I18nN"].forEach((name) => app.component(name, NumberFormat));
    [DatetimeFormat.name, "I18nD"].forEach((name) => app.component(name, DatetimeFormat));
  }
  {
    app.directive("t", vTDirective(i18n));
  }
}
var VueDevToolsLabels = {
  [
    "vue-devtools-plugin-vue-i18n"
    /* VueDevToolsIDs.PLUGIN */
  ]: "Vue I18n devtools",
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "I18n Resources",
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: "Vue I18n"
};
var VueDevToolsPlaceholders = {
  [
    "vue-i18n-resource-inspector"
    /* VueDevToolsIDs.CUSTOM_INSPECTOR */
  ]: "Search for scopes ..."
};
var VueDevToolsTimelineColors = {
  [
    "vue-i18n-timeline"
    /* VueDevToolsIDs.TIMELINE */
  ]: 16764185
};
var VUE_I18N_COMPONENT_TYPES = "vue-i18n: composer properties";
var devtoolsApi;
async function enableDevTools(app, i18n) {
  return new Promise((resolve, reject) => {
    try {
      setupDevtoolsPlugin({
        id: "vue-devtools-plugin-vue-i18n",
        label: VueDevToolsLabels[
          "vue-devtools-plugin-vue-i18n"
          /* VueDevToolsIDs.PLUGIN */
        ],
        packageName: "vue-i18n",
        homepage: "https://vue-i18n.intlify.dev",
        logo: "https://vue-i18n.intlify.dev/vue-i18n-devtools-logo.png",
        componentStateTypes: [VUE_I18N_COMPONENT_TYPES],
        app
        // eslint-disable-line @typescript-eslint/no-explicit-any
      }, (api) => {
        devtoolsApi = api;
        api.on.visitComponentTree(({ componentInstance, treeNode }) => {
          updateComponentTreeTags(componentInstance, treeNode, i18n);
        });
        api.on.inspectComponent(({ componentInstance, instanceData }) => {
          if (componentInstance.vnode.el && componentInstance.vnode.el.__VUE_I18N__ && instanceData) {
            if (i18n.mode === "legacy") {
              if (componentInstance.vnode.el.__VUE_I18N__ !== i18n.global.__composer) {
                inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
              }
            } else {
              inspectComposer(instanceData, componentInstance.vnode.el.__VUE_I18N__);
            }
          }
        });
        api.addInspector({
          id: "vue-i18n-resource-inspector",
          label: VueDevToolsLabels[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ],
          icon: "language",
          treeFilterPlaceholder: VueDevToolsPlaceholders[
            "vue-i18n-resource-inspector"
            /* VueDevToolsIDs.CUSTOM_INSPECTOR */
          ]
        });
        api.on.getInspectorTree((payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            registerScope(payload, i18n);
          }
        });
        const roots = /* @__PURE__ */ new Map();
        api.on.getInspectorState(async (payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            api.unhighlightElement();
            inspectScope(payload, i18n);
            if (payload.nodeId === "global") {
              if (!roots.has(payload.app)) {
                const [root] = await api.getComponentInstances(payload.app);
                roots.set(payload.app, root);
              }
              api.highlightElement(roots.get(payload.app));
            } else {
              const instance = getComponentInstance(payload.nodeId, i18n);
              instance && api.highlightElement(instance);
            }
          }
        });
        api.on.editInspectorState((payload) => {
          if (payload.app === app && payload.inspectorId === "vue-i18n-resource-inspector") {
            editScope(payload, i18n);
          }
        });
        api.addTimelineLayer({
          id: "vue-i18n-timeline",
          label: VueDevToolsLabels[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ],
          color: VueDevToolsTimelineColors[
            "vue-i18n-timeline"
            /* VueDevToolsIDs.TIMELINE */
          ]
        });
        resolve(true);
      });
    } catch (e16) {
      console.error(e16);
      reject(false);
    }
  });
}
function getI18nScopeLable(instance) {
  return instance.type.name || instance.type.displayName || instance.type.__file || "Anonymous";
}
function updateComponentTreeTags(instance, treeNode, i18n) {
  const global2 = i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  if (instance && instance.vnode.el && instance.vnode.el.__VUE_I18N__) {
    if (instance.vnode.el.__VUE_I18N__ !== global2) {
      const tag = {
        label: `i18n (${getI18nScopeLable(instance)} Scope)`,
        textColor: 0,
        backgroundColor: 16764185
      };
      treeNode.tags.push(tag);
    }
  }
}
function inspectComposer(instanceData, composer) {
  const type = VUE_I18N_COMPONENT_TYPES;
  instanceData.state.push({
    type,
    key: "locale",
    editable: true,
    value: composer.locale.value
  });
  instanceData.state.push({
    type,
    key: "availableLocales",
    editable: false,
    value: composer.availableLocales
  });
  instanceData.state.push({
    type,
    key: "fallbackLocale",
    editable: true,
    value: composer.fallbackLocale.value
  });
  instanceData.state.push({
    type,
    key: "inheritLocale",
    editable: true,
    value: composer.inheritLocale
  });
  instanceData.state.push({
    type,
    key: "messages",
    editable: false,
    value: getLocaleMessageValue(composer.messages.value)
  });
  {
    instanceData.state.push({
      type,
      key: "datetimeFormats",
      editable: false,
      value: composer.datetimeFormats.value
    });
    instanceData.state.push({
      type,
      key: "numberFormats",
      editable: false,
      value: composer.numberFormats.value
    });
  }
}
function getLocaleMessageValue(messages) {
  const value = {};
  Object.keys(messages).forEach((key) => {
    const v = messages[key];
    if (isFunction(v) && "source" in v) {
      value[key] = getMessageFunctionDetails(v);
    } else if (isMessageAST(v) && v.loc && v.loc.source) {
      value[key] = v.loc.source;
    } else if (isObject(v)) {
      value[key] = getLocaleMessageValue(v);
    } else {
      value[key] = v;
    }
  });
  return value;
}
var ESC = {
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "&": "&amp;"
};
function escape(s) {
  return s.replace(/[<>"&]/g, escapeChar);
}
function escapeChar(a) {
  return ESC[a] || a;
}
function getMessageFunctionDetails(func) {
  const argString = func.source ? `("${escape(func.source)}")` : `(?)`;
  return {
    _custom: {
      type: "function",
      display: `<span>ƒ</span> ${argString}`
    }
  };
}
function registerScope(payload, i18n) {
  payload.rootNodes.push({
    id: "global",
    label: "Global Scope"
  });
  const global2 = i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  for (const [keyInstance, instance] of i18n.__instances) {
    const composer = i18n.mode === "composition" ? instance : instance.__composer;
    if (global2 === composer) {
      continue;
    }
    payload.rootNodes.push({
      id: composer.id.toString(),
      label: `${getI18nScopeLable(keyInstance)} Scope`
    });
  }
}
function getComponentInstance(nodeId, i18n) {
  let instance = null;
  if (nodeId !== "global") {
    for (const [component2, composer] of i18n.__instances.entries()) {
      if (composer.id.toString() === nodeId) {
        instance = component2;
        break;
      }
    }
  }
  return instance;
}
function getComposer$1(nodeId, i18n) {
  if (nodeId === "global") {
    return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
  } else {
    const instance = Array.from(i18n.__instances.values()).find((item) => item.id.toString() === nodeId);
    if (instance) {
      return i18n.mode === "composition" ? instance : instance.__composer;
    } else {
      return null;
    }
  }
}
function inspectScope(payload, i18n) {
  const composer = getComposer$1(payload.nodeId, i18n);
  if (composer) {
    payload.state = makeScopeInspectState(composer);
  }
  return null;
}
function makeScopeInspectState(composer) {
  const state = {};
  const localeType = "Locale related info";
  const localeStates = [
    {
      type: localeType,
      key: "locale",
      editable: true,
      value: composer.locale.value
    },
    {
      type: localeType,
      key: "fallbackLocale",
      editable: true,
      value: composer.fallbackLocale.value
    },
    {
      type: localeType,
      key: "availableLocales",
      editable: false,
      value: composer.availableLocales
    },
    {
      type: localeType,
      key: "inheritLocale",
      editable: true,
      value: composer.inheritLocale
    }
  ];
  state[localeType] = localeStates;
  const localeMessagesType = "Locale messages info";
  const localeMessagesStates = [
    {
      type: localeMessagesType,
      key: "messages",
      editable: false,
      value: getLocaleMessageValue(composer.messages.value)
    }
  ];
  state[localeMessagesType] = localeMessagesStates;
  {
    const datetimeFormatsType = "Datetime formats info";
    const datetimeFormatsStates = [
      {
        type: datetimeFormatsType,
        key: "datetimeFormats",
        editable: false,
        value: composer.datetimeFormats.value
      }
    ];
    state[datetimeFormatsType] = datetimeFormatsStates;
    const numberFormatsType = "Datetime formats info";
    const numberFormatsStates = [
      {
        type: numberFormatsType,
        key: "numberFormats",
        editable: false,
        value: composer.numberFormats.value
      }
    ];
    state[numberFormatsType] = numberFormatsStates;
  }
  return state;
}
function addTimelineEvent(event, payload) {
  if (devtoolsApi) {
    let groupId;
    if (payload && "groupId" in payload) {
      groupId = payload.groupId;
      delete payload.groupId;
    }
    devtoolsApi.addTimelineEvent({
      layerId: "vue-i18n-timeline",
      event: {
        title: event,
        groupId,
        time: Date.now(),
        meta: {},
        data: payload || {},
        logType: event === "compile-error" ? "error" : event === "fallback" || event === "missing" ? "warning" : "default"
      }
    });
  }
}
function editScope(payload, i18n) {
  const composer = getComposer$1(payload.nodeId, i18n);
  if (composer) {
    const [field] = payload.path;
    if (field === "locale" && isString(payload.state.value)) {
      composer.locale.value = payload.state.value;
    } else if (field === "fallbackLocale" && (isString(payload.state.value) || isArray(payload.state.value) || isObject(payload.state.value))) {
      composer.fallbackLocale.value = payload.state.value;
    } else if (field === "inheritLocale" && isBoolean(payload.state.value)) {
      composer.inheritLocale = payload.state.value;
    }
  }
}
function defineMixin(vuei18n, composer, i18n) {
  return {
    beforeCreate() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const options = this.$options;
      if (options.i18n) {
        const optionsI18n = options.i18n;
        if (options.__i18n) {
          optionsI18n.__i18n = options.__i18n;
        }
        optionsI18n.__root = composer;
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, optionsI18n);
        } else {
          optionsI18n.__injectWithOption = true;
          optionsI18n.__extender = i18n.__vueI18nExtend;
          this.$i18n = createVueI18n(optionsI18n);
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else if (options.__i18n) {
        if (this === this.$root) {
          this.$i18n = mergeToGlobal(vuei18n, options);
        } else {
          this.$i18n = createVueI18n({
            __i18n: options.__i18n,
            __injectWithOption: true,
            __extender: i18n.__vueI18nExtend,
            __root: composer
          });
          const _vueI18n = this.$i18n;
          if (_vueI18n.__extender) {
            _vueI18n.__disposer = _vueI18n.__extender(this.$i18n);
          }
        }
      } else {
        this.$i18n = vuei18n;
      }
      if (options.__i18nGlobal) {
        adjustI18nResources(composer, options, options);
      }
      this.$t = (...args) => this.$i18n.t(...args);
      this.$rt = (...args) => this.$i18n.rt(...args);
      this.$tc = (...args) => this.$i18n.tc(...args);
      this.$te = (key, locale) => this.$i18n.te(key, locale);
      this.$d = (...args) => this.$i18n.d(...args);
      this.$n = (...args) => this.$i18n.n(...args);
      this.$tm = (key) => this.$i18n.tm(key);
      i18n.__setInstance(instance, this.$i18n);
    },
    mounted() {
      if (this.$el && this.$i18n) {
        const _vueI18n = this.$i18n;
        this.$el.__VUE_I18N__ = _vueI18n.__composer;
        const emitter = this.__v_emitter = createEmitter();
        _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
        emitter.on("*", addTimelineEvent);
      }
    },
    unmounted() {
      const instance = getCurrentInstance();
      if (!instance) {
        throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
      }
      const _vueI18n = this.$i18n;
      if (this.$el && this.$el.__VUE_I18N__) {
        if (this.__v_emitter) {
          this.__v_emitter.off("*", addTimelineEvent);
          delete this.__v_emitter;
        }
        if (this.$i18n) {
          _vueI18n.__disableEmitter && _vueI18n.__disableEmitter();
          delete this.$el.__VUE_I18N__;
        }
      }
      delete this.$t;
      delete this.$rt;
      delete this.$tc;
      delete this.$te;
      delete this.$d;
      delete this.$n;
      delete this.$tm;
      if (_vueI18n.__disposer) {
        _vueI18n.__disposer();
        delete _vueI18n.__disposer;
        delete _vueI18n.__extender;
      }
      i18n.__deleteInstance(instance);
      delete this.$i18n;
    }
  };
}
function mergeToGlobal(g, options) {
  g.locale = options.locale || g.locale;
  g.fallbackLocale = options.fallbackLocale || g.fallbackLocale;
  g.missing = options.missing || g.missing;
  g.silentTranslationWarn = options.silentTranslationWarn || g.silentFallbackWarn;
  g.silentFallbackWarn = options.silentFallbackWarn || g.silentFallbackWarn;
  g.formatFallbackMessages = options.formatFallbackMessages || g.formatFallbackMessages;
  g.postTranslation = options.postTranslation || g.postTranslation;
  g.warnHtmlInMessage = options.warnHtmlInMessage || g.warnHtmlInMessage;
  g.escapeParameterHtml = options.escapeParameterHtml || g.escapeParameterHtml;
  g.sync = options.sync || g.sync;
  g.__composer[SetPluralRulesSymbol](options.pluralizationRules || g.pluralizationRules);
  const messages = getLocaleMessages(g.locale, {
    messages: options.messages,
    __i18n: options.__i18n
  });
  Object.keys(messages).forEach((locale) => g.mergeLocaleMessage(locale, messages[locale]));
  if (options.datetimeFormats) {
    Object.keys(options.datetimeFormats).forEach((locale) => g.mergeDateTimeFormat(locale, options.datetimeFormats[locale]));
  }
  if (options.numberFormats) {
    Object.keys(options.numberFormats).forEach((locale) => g.mergeNumberFormat(locale, options.numberFormats[locale]));
  }
  return g;
}
var I18nInjectionKey = makeSymbol("global-vue-i18n");
function createI18n(options = {}, VueI18nLegacy) {
  const __legacyMode = __VUE_I18N_LEGACY_API__ && isBoolean(options.legacy) ? options.legacy : __VUE_I18N_LEGACY_API__;
  const __globalInjection = isBoolean(options.globalInjection) ? options.globalInjection : true;
  const __allowComposition = __VUE_I18N_LEGACY_API__ && __legacyMode ? !!options.allowComposition : true;
  const __instances = /* @__PURE__ */ new Map();
  const [globalScope, __global] = createGlobal(options, __legacyMode);
  const symbol = makeSymbol(true ? "vue-i18n" : "");
  if (true) {
    if (__legacyMode && __allowComposition && true) {
      warn(getWarnMessage2(I18nWarnCodes.NOTICE_DROP_ALLOW_COMPOSITION));
    }
  }
  function __getInstance(component2) {
    return __instances.get(component2) || null;
  }
  function __setInstance(component2, instance) {
    __instances.set(component2, instance);
  }
  function __deleteInstance(component2) {
    __instances.delete(component2);
  }
  {
    const i18n = {
      // mode
      get mode() {
        return __VUE_I18N_LEGACY_API__ && __legacyMode ? "legacy" : "composition";
      },
      // allowComposition
      get allowComposition() {
        return __allowComposition;
      },
      // install plugin
      async install(app, ...options2) {
        if (true) {
          app.__VUE_I18N__ = i18n;
        }
        app.__VUE_I18N_SYMBOL__ = symbol;
        app.provide(app.__VUE_I18N_SYMBOL__, i18n);
        if (isPlainObject(options2[0])) {
          const opts = options2[0];
          i18n.__composerExtend = opts.__composerExtend;
          i18n.__vueI18nExtend = opts.__vueI18nExtend;
        }
        let globalReleaseHandler = null;
        if (!__legacyMode && __globalInjection) {
          globalReleaseHandler = injectGlobalFields(app, i18n.global);
        }
        if (__VUE_I18N_FULL_INSTALL__) {
          apply(app, i18n, ...options2);
        }
        if (__VUE_I18N_LEGACY_API__ && __legacyMode) {
          app.mixin(defineMixin(__global, __global.__composer, i18n));
        }
        const unmountApp = app.unmount;
        app.unmount = () => {
          globalReleaseHandler && globalReleaseHandler();
          i18n.dispose();
          unmountApp();
        };
        if (true) {
          const ret = await enableDevTools(app, i18n);
          if (!ret) {
            throw createI18nError(I18nErrorCodes.CANNOT_SETUP_VUE_DEVTOOLS_PLUGIN);
          }
          const emitter = createEmitter();
          if (__legacyMode) {
            const _vueI18n = __global;
            _vueI18n.__enableEmitter && _vueI18n.__enableEmitter(emitter);
          } else {
            const _composer = __global;
            _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
          }
          emitter.on("*", addTimelineEvent);
        }
      },
      // global accessor
      get global() {
        return __global;
      },
      dispose() {
        globalScope.stop();
      },
      // @internal
      __instances,
      // @internal
      __getInstance,
      // @internal
      __setInstance,
      // @internal
      __deleteInstance
    };
    return i18n;
  }
}
function useI18n(options = {}) {
  const instance = getCurrentInstance();
  if (instance == null) {
    throw createI18nError(I18nErrorCodes.MUST_BE_CALL_SETUP_TOP);
  }
  if (!instance.isCE && instance.appContext.app != null && !instance.appContext.app.__VUE_I18N_SYMBOL__) {
    throw createI18nError(I18nErrorCodes.NOT_INSTALLED);
  }
  const i18n = getI18nInstance(instance);
  const gl = getGlobalComposer(i18n);
  const componentOptions = getComponentOptions(instance);
  const scope = getScope(options, componentOptions);
  if (__VUE_I18N_LEGACY_API__) {
    if (i18n.mode === "legacy" && !options.__useComponent) {
      if (!i18n.allowComposition) {
        throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_IN_LEGACY_MODE);
      }
      return useI18nForLegacy(instance, scope, gl, options);
    }
  }
  if (scope === "global") {
    adjustI18nResources(gl, options, componentOptions);
    return gl;
  }
  if (scope === "parent") {
    let composer2 = getComposer(i18n, instance, options.__useComponent);
    if (composer2 == null) {
      if (true) {
        warn(getWarnMessage2(I18nWarnCodes.NOT_FOUND_PARENT_SCOPE));
      }
      composer2 = gl;
    }
    return composer2;
  }
  const i18nInternal = i18n;
  let composer = i18nInternal.__getInstance(instance);
  if (composer == null) {
    const composerOptions = assign({}, options);
    if ("__i18n" in componentOptions) {
      composerOptions.__i18n = componentOptions.__i18n;
    }
    if (gl) {
      composerOptions.__root = gl;
    }
    composer = createComposer(composerOptions);
    if (i18nInternal.__composerExtend) {
      composer[DisposeSymbol] = i18nInternal.__composerExtend(composer);
    }
    setupLifeCycle(i18nInternal, instance, composer);
    i18nInternal.__setInstance(instance, composer);
  }
  return composer;
}
function createGlobal(options, legacyMode, VueI18nLegacy) {
  const scope = effectScope();
  {
    const obj = __VUE_I18N_LEGACY_API__ && legacyMode ? scope.run(() => createVueI18n(options)) : scope.run(() => createComposer(options));
    if (obj == null) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    return [scope, obj];
  }
}
function getI18nInstance(instance) {
  {
    const i18n = inject(!instance.isCE ? instance.appContext.app.__VUE_I18N_SYMBOL__ : I18nInjectionKey);
    if (!i18n) {
      throw createI18nError(!instance.isCE ? I18nErrorCodes.UNEXPECTED_ERROR : I18nErrorCodes.NOT_INSTALLED_WITH_PROVIDE);
    }
    return i18n;
  }
}
function getScope(options, componentOptions) {
  return isEmptyObject(options) ? "__i18n" in componentOptions ? "local" : "global" : !options.useScope ? "local" : options.useScope;
}
function getGlobalComposer(i18n) {
  return i18n.mode === "composition" ? i18n.global : i18n.global.__composer;
}
function getComposer(i18n, target, useComponent = false) {
  let composer = null;
  const root = target.root;
  let current = getParentComponentInstance(target, useComponent);
  while (current != null) {
    const i18nInternal = i18n;
    if (i18n.mode === "composition") {
      composer = i18nInternal.__getInstance(current);
    } else {
      if (__VUE_I18N_LEGACY_API__) {
        const vueI18n = i18nInternal.__getInstance(current);
        if (vueI18n != null) {
          composer = vueI18n.__composer;
          if (useComponent && composer && !composer[InejctWithOptionSymbol]) {
            composer = null;
          }
        }
      }
    }
    if (composer != null) {
      break;
    }
    if (root === current) {
      break;
    }
    current = current.parent;
  }
  return composer;
}
function getParentComponentInstance(target, useComponent = false) {
  if (target == null) {
    return null;
  }
  {
    return !useComponent ? target.parent : target.vnode.ctx || target.parent;
  }
}
function setupLifeCycle(i18n, target, composer) {
  let emitter = null;
  {
    onMounted(() => {
      if (target.vnode.el) {
        target.vnode.el.__VUE_I18N__ = composer;
        emitter = createEmitter();
        const _composer = composer;
        _composer[EnableEmitter] && _composer[EnableEmitter](emitter);
        emitter.on("*", addTimelineEvent);
      }
    }, target);
    onUnmounted(() => {
      const _composer = composer;
      if (target.vnode.el && target.vnode.el.__VUE_I18N__) {
        emitter && emitter.off("*", addTimelineEvent);
        _composer[DisableEmitter] && _composer[DisableEmitter]();
        delete target.vnode.el.__VUE_I18N__;
      }
      i18n.__deleteInstance(target);
      const dispose = _composer[DisposeSymbol];
      if (dispose) {
        dispose();
        delete _composer[DisposeSymbol];
      }
    }, target);
  }
}
function useI18nForLegacy(instance, scope, root, options = {}) {
  const isLocalScope = scope === "local";
  const _composer = shallowRef(null);
  if (isLocalScope && instance.proxy && !(instance.proxy.$options.i18n || instance.proxy.$options.__i18n)) {
    throw createI18nError(I18nErrorCodes.MUST_DEFINE_I18N_OPTION_IN_ALLOW_COMPOSITION);
  }
  const _inheritLocale = isBoolean(options.inheritLocale) ? options.inheritLocale : !isString(options.locale);
  const _locale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.locale.value : isString(options.locale) ? options.locale : DEFAULT_LOCALE
  );
  const _fallbackLocale = ref(
    // prettier-ignore
    !isLocalScope || _inheritLocale ? root.fallbackLocale.value : isString(options.fallbackLocale) || isArray(options.fallbackLocale) || isPlainObject(options.fallbackLocale) || options.fallbackLocale === false ? options.fallbackLocale : _locale.value
  );
  const _messages = ref(getLocaleMessages(_locale.value, options));
  const _datetimeFormats = ref(isPlainObject(options.datetimeFormats) ? options.datetimeFormats : { [_locale.value]: {} });
  const _numberFormats = ref(isPlainObject(options.numberFormats) ? options.numberFormats : { [_locale.value]: {} });
  const _missingWarn = isLocalScope ? root.missingWarn : isBoolean(options.missingWarn) || isRegExp(options.missingWarn) ? options.missingWarn : true;
  const _fallbackWarn = isLocalScope ? root.fallbackWarn : isBoolean(options.fallbackWarn) || isRegExp(options.fallbackWarn) ? options.fallbackWarn : true;
  const _fallbackRoot = isLocalScope ? root.fallbackRoot : isBoolean(options.fallbackRoot) ? options.fallbackRoot : true;
  const _fallbackFormat = !!options.fallbackFormat;
  const _missing = isFunction(options.missing) ? options.missing : null;
  const _postTranslation = isFunction(options.postTranslation) ? options.postTranslation : null;
  const _warnHtmlMessage = isLocalScope ? root.warnHtmlMessage : isBoolean(options.warnHtmlMessage) ? options.warnHtmlMessage : true;
  const _escapeParameter = !!options.escapeParameter;
  const _modifiers = isLocalScope ? root.modifiers : isPlainObject(options.modifiers) ? options.modifiers : {};
  const _pluralRules = options.pluralRules || isLocalScope && root.pluralRules;
  function trackReactivityValues() {
    return [
      _locale.value,
      _fallbackLocale.value,
      _messages.value,
      _datetimeFormats.value,
      _numberFormats.value
    ];
  }
  const locale = computed({
    get: () => {
      return _composer.value ? _composer.value.locale.value : _locale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.locale.value = val;
      }
      _locale.value = val;
    }
  });
  const fallbackLocale = computed({
    get: () => {
      return _composer.value ? _composer.value.fallbackLocale.value : _fallbackLocale.value;
    },
    set: (val) => {
      if (_composer.value) {
        _composer.value.fallbackLocale.value = val;
      }
      _fallbackLocale.value = val;
    }
  });
  const messages = computed(() => {
    if (_composer.value) {
      return _composer.value.messages.value;
    } else {
      return _messages.value;
    }
  });
  const datetimeFormats = computed(() => _datetimeFormats.value);
  const numberFormats = computed(() => _numberFormats.value);
  function getPostTranslationHandler() {
    return _composer.value ? _composer.value.getPostTranslationHandler() : _postTranslation;
  }
  function setPostTranslationHandler(handler) {
    if (_composer.value) {
      _composer.value.setPostTranslationHandler(handler);
    }
  }
  function getMissingHandler() {
    return _composer.value ? _composer.value.getMissingHandler() : _missing;
  }
  function setMissingHandler(handler) {
    if (_composer.value) {
      _composer.value.setMissingHandler(handler);
    }
  }
  function warpWithDeps(fn2) {
    trackReactivityValues();
    return fn2();
  }
  function t10(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.t, null, [...args])) : warpWithDeps(() => "");
  }
  function rt(...args) {
    return _composer.value ? Reflect.apply(_composer.value.rt, null, [...args]) : "";
  }
  function d(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.d, null, [...args])) : warpWithDeps(() => "");
  }
  function n(...args) {
    return _composer.value ? warpWithDeps(() => Reflect.apply(_composer.value.n, null, [...args])) : warpWithDeps(() => "");
  }
  function tm2(key) {
    return _composer.value ? _composer.value.tm(key) : {};
  }
  function te(key, locale2) {
    return _composer.value ? _composer.value.te(key, locale2) : false;
  }
  function getLocaleMessage(locale2) {
    return _composer.value ? _composer.value.getLocaleMessage(locale2) : {};
  }
  function setLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.setLocaleMessage(locale2, message);
      _messages.value[locale2] = message;
    }
  }
  function mergeLocaleMessage(locale2, message) {
    if (_composer.value) {
      _composer.value.mergeLocaleMessage(locale2, message);
    }
  }
  function getDateTimeFormat(locale2) {
    return _composer.value ? _composer.value.getDateTimeFormat(locale2) : {};
  }
  function setDateTimeFormat(locale2, format4) {
    if (_composer.value) {
      _composer.value.setDateTimeFormat(locale2, format4);
      _datetimeFormats.value[locale2] = format4;
    }
  }
  function mergeDateTimeFormat(locale2, format4) {
    if (_composer.value) {
      _composer.value.mergeDateTimeFormat(locale2, format4);
    }
  }
  function getNumberFormat(locale2) {
    return _composer.value ? _composer.value.getNumberFormat(locale2) : {};
  }
  function setNumberFormat(locale2, format4) {
    if (_composer.value) {
      _composer.value.setNumberFormat(locale2, format4);
      _numberFormats.value[locale2] = format4;
    }
  }
  function mergeNumberFormat(locale2, format4) {
    if (_composer.value) {
      _composer.value.mergeNumberFormat(locale2, format4);
    }
  }
  const wrapper = {
    get id() {
      return _composer.value ? _composer.value.id : -1;
    },
    locale,
    fallbackLocale,
    messages,
    datetimeFormats,
    numberFormats,
    get inheritLocale() {
      return _composer.value ? _composer.value.inheritLocale : _inheritLocale;
    },
    set inheritLocale(val) {
      if (_composer.value) {
        _composer.value.inheritLocale = val;
      }
    },
    get availableLocales() {
      return _composer.value ? _composer.value.availableLocales : Object.keys(_messages.value);
    },
    get modifiers() {
      return _composer.value ? _composer.value.modifiers : _modifiers;
    },
    get pluralRules() {
      return _composer.value ? _composer.value.pluralRules : _pluralRules;
    },
    get isGlobal() {
      return _composer.value ? _composer.value.isGlobal : false;
    },
    get missingWarn() {
      return _composer.value ? _composer.value.missingWarn : _missingWarn;
    },
    set missingWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackWarn() {
      return _composer.value ? _composer.value.fallbackWarn : _fallbackWarn;
    },
    set fallbackWarn(val) {
      if (_composer.value) {
        _composer.value.missingWarn = val;
      }
    },
    get fallbackRoot() {
      return _composer.value ? _composer.value.fallbackRoot : _fallbackRoot;
    },
    set fallbackRoot(val) {
      if (_composer.value) {
        _composer.value.fallbackRoot = val;
      }
    },
    get fallbackFormat() {
      return _composer.value ? _composer.value.fallbackFormat : _fallbackFormat;
    },
    set fallbackFormat(val) {
      if (_composer.value) {
        _composer.value.fallbackFormat = val;
      }
    },
    get warnHtmlMessage() {
      return _composer.value ? _composer.value.warnHtmlMessage : _warnHtmlMessage;
    },
    set warnHtmlMessage(val) {
      if (_composer.value) {
        _composer.value.warnHtmlMessage = val;
      }
    },
    get escapeParameter() {
      return _composer.value ? _composer.value.escapeParameter : _escapeParameter;
    },
    set escapeParameter(val) {
      if (_composer.value) {
        _composer.value.escapeParameter = val;
      }
    },
    t: t10,
    getPostTranslationHandler,
    setPostTranslationHandler,
    getMissingHandler,
    setMissingHandler,
    rt,
    d,
    n,
    tm: tm2,
    te,
    getLocaleMessage,
    setLocaleMessage,
    mergeLocaleMessage,
    getDateTimeFormat,
    setDateTimeFormat,
    mergeDateTimeFormat,
    getNumberFormat,
    setNumberFormat,
    mergeNumberFormat
  };
  function sync(composer) {
    composer.locale.value = _locale.value;
    composer.fallbackLocale.value = _fallbackLocale.value;
    Object.keys(_messages.value).forEach((locale2) => {
      composer.mergeLocaleMessage(locale2, _messages.value[locale2]);
    });
    Object.keys(_datetimeFormats.value).forEach((locale2) => {
      composer.mergeDateTimeFormat(locale2, _datetimeFormats.value[locale2]);
    });
    Object.keys(_numberFormats.value).forEach((locale2) => {
      composer.mergeNumberFormat(locale2, _numberFormats.value[locale2]);
    });
    composer.escapeParameter = _escapeParameter;
    composer.fallbackFormat = _fallbackFormat;
    composer.fallbackRoot = _fallbackRoot;
    composer.fallbackWarn = _fallbackWarn;
    composer.missingWarn = _missingWarn;
    composer.warnHtmlMessage = _warnHtmlMessage;
  }
  onBeforeMount(() => {
    if (instance.proxy == null || instance.proxy.$i18n == null) {
      throw createI18nError(I18nErrorCodes.NOT_AVAILABLE_COMPOSITION_IN_LEGACY);
    }
    const composer = _composer.value = instance.proxy.$i18n.__composer;
    if (scope === "global") {
      _locale.value = composer.locale.value;
      _fallbackLocale.value = composer.fallbackLocale.value;
      _messages.value = composer.messages.value;
      _datetimeFormats.value = composer.datetimeFormats.value;
      _numberFormats.value = composer.numberFormats.value;
    } else if (isLocalScope) {
      sync(composer);
    }
  });
  return wrapper;
}
var globalExportProps = [
  "locale",
  "fallbackLocale",
  "availableLocales"
];
var globalExportMethods = ["t", "rt", "d", "n", "tm", "te"];
function injectGlobalFields(app, composer) {
  const i18n = /* @__PURE__ */ Object.create(null);
  globalExportProps.forEach((prop) => {
    const desc = Object.getOwnPropertyDescriptor(composer, prop);
    if (!desc) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    const wrap = isRef(desc.value) ? {
      get() {
        return desc.value.value;
      },
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set(val) {
        desc.value.value = val;
      }
    } : {
      get() {
        return desc.get && desc.get();
      }
    };
    Object.defineProperty(i18n, prop, wrap);
  });
  app.config.globalProperties.$i18n = i18n;
  globalExportMethods.forEach((method) => {
    const desc = Object.getOwnPropertyDescriptor(composer, method);
    if (!desc || !desc.value) {
      throw createI18nError(I18nErrorCodes.UNEXPECTED_ERROR);
    }
    Object.defineProperty(app.config.globalProperties, `$${method}`, desc);
  });
  const dispose = () => {
    delete app.config.globalProperties.$i18n;
    globalExportMethods.forEach((method) => {
      delete app.config.globalProperties[`$${method}`];
    });
  };
  return dispose;
}
{
  initFeatureFlags2();
}
if (__INTLIFY_JIT_COMPILATION__) {
  registerMessageCompiler(compile);
} else {
  registerMessageCompiler(compileToFunction);
}
registerMessageResolver(resolveValue$1);
registerLocaleFallbacker(fallbackWithLocaleChain);
if (true) {
  const target = getGlobalThis();
  target.__INTLIFY__ = true;
  setDevToolsHook(target.__INTLIFY_DEVTOOLS_GLOBAL_HOOK__);
}
if (true) ;

// node_modules/@ksware/ksw-ux/kingsware-ui/index.js
var pm = Object.defineProperty;
var hm = (e16, t10, n) => t10 in e16 ? pm(e16, t10, { enumerable: true, configurable: true, writable: true, value: n }) : e16[t10] = n;
var mr = (e16, t10, n) => hm(e16, typeof t10 != "symbol" ? t10 + "" : t10, n);
var fo = { size: "1em", color: "currentColor", spin: false, prefix: "ksw" };
function Ye(e16, t10, n) {
  return { name: "Icon" + e16, props: { size: { type: [String, Number], default: fo.size }, color: { type: String, default: fo.color }, rotate: { type: Number }, spin: { type: Boolean, default: t10 || fo.spin }, grayscale: { type: Boolean, default: false } }, setup(o) {
    return () => {
      const { spin: r, grayscale: a } = o, i = [`${fo.prefix}-icon`, `${fo.prefix}-icon-${e16}`];
      return r && i.push(`${fo.prefix}-icon-spin`), a && i.push(`${fo.prefix}-icon-grayscale`), createVNode("span", { class: i.join(" ") }, [n(o)]);
    };
  } };
}
var _p = Ye("Add", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M11.25 4.5q0-.074.014-.146.015-.073.043-.141t.07-.13q.04-.061.093-.113.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043T12 3.75t.146.014.141.043.13.07.113.093q.053.052.094.113.04.062.069.13.028.068.043.14t.014.147v6.75h6.75q.074 0 .146.014.073.015.141.043t.13.07q.061.04.113.093.053.052.094.113.04.062.069.13.028.068.043.14t.014.147-.014.146-.043.141-.07.13-.093.113q-.052.053-.113.094-.062.04-.13.069-.068.028-.14.043t-.147.014h-6.75v6.75q0 .074-.014.146-.015.073-.043.141t-.07.13q-.04.061-.093.113-.052.053-.113.094-.062.04-.13.069-.068.028-.14.043T12 20.25t-.146-.014-.141-.043-.13-.07-.113-.093q-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14t-.014-.147v-6.75H4.5q-.074 0-.146-.014-.073-.015-.141-.043t-.13-.07q-.061-.04-.113-.093-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14T3.75 12t.014-.146.043-.141.07-.13.093-.113q.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043t.147-.014h6.75z" }, null)]);
});
var wp = Ye("ArrowLeft", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "m7.477 12 6.363-6.976a.6.6 0 0 0 .16-.409.624.624 0 0 0-.632-.615.64.64 0 0 0-.472.207L6.16 11.59a.604.604 0 0 0 0 .818l6.736 7.384a.64.64 0 0 0 .472.207.624.624 0 0 0 .632-.615.6.6 0 0 0-.16-.41z" }, null)]);
});
var vl = Ye("ArrowRight", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "m16.523 12-6.363 6.976a.6.6 0 0 0-.16.409c0 .34.283.615.632.615.18 0 .352-.075.472-.207l6.736-7.384a.604.604 0 0 0 0-.818l-6.736-7.384A.64.64 0 0 0 10.632 4a.624.624 0 0 0-.632.615c0 .151.057.297.16.41z" }, null)]);
});
var Tp = Ye("Check", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M20 6.075 8.657 19 4 14.283l1.173-1.145 3.413 3.457L18.76 5z" }, null)]);
});
var Cp = Ye("Clear", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M2 12C2 6.5 6.5 2 12 2s10 4.5 10 10-4.5 10-10 10S2 17.5 2 12m14.535-3.536q0 .2-.076.383-.076.184-.216.325L13.414 12l2.829 2.828q.07.07.124.152.055.082.092.173.038.09.057.187t.02.196-.02.195q-.019.096-.057.187-.037.091-.092.173t-.124.152q-.07.07-.152.124-.082.055-.173.092-.09.038-.187.057t-.195.02q-.099 0-.196-.02-.096-.019-.187-.057-.091-.037-.173-.092t-.152-.124L12 13.414l-2.829 2.829q-.14.14-.324.216t-.383.076-.382-.076-.325-.216q-.07-.07-.124-.152-.055-.082-.093-.173-.037-.09-.056-.187t-.02-.195q0-.099.02-.196.019-.096.056-.187t.093-.173.124-.152L10.586 12 7.757 9.172q-.07-.07-.124-.152-.055-.082-.092-.173-.038-.09-.057-.187t-.02-.196.02-.195q.019-.096.057-.187.037-.091.092-.173t.124-.152q.07-.07.152-.124.082-.055.173-.092.09-.038.187-.057t.195-.02q.099 0 .196.02.096.019.187.057.091.037.173.092t.152.124L12 10.586l2.828-2.829q.141-.14.325-.216.183-.077.382-.077.2 0 .383.077.184.076.325.216.14.141.216.325t.076.382" }, null)]);
});
var h0 = Ye("ClearDate", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "m13.163 12.346 6.393-7.922a.75.75 0 1 0-1.167-.941l-6.393 7.921a.75.75 0 1 0 1.167.942" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M2.292 21.375q0-4.604 2.251-7.528 2.48-3.222 6.832-3.222 1.001 0 1.709.708t.708 1.709l-.004.071q-.045.476-.207.925l-.023.056q-.755 1.667-.663 3.494t1.01 3.41a.75.75 0 0 1-.648 1.127H3.042a.75.75 0 0 1-.75-.75m9.76-.75H3.809q.164-3.578 1.923-5.863 2.03-2.637 5.643-2.637.38 0 .648.268.257.257.268.615-.029.254-.113.496-.89 1.985-.781 4.16.078 1.554.655 2.961M21.375 13.833h-4.167a.75.75 0 1 0 0 1.5h4.167a.75.75 0 0 0 0-1.5M21.375 17.167h-5a.75.75 0 1 0 0 1.5h5a.75.75 0 0 0 0-1.5M21.375 20.5h-3.333a.75.75 0 1 0 0 1.5h3.333a.75.75 0 1 0 0-1.5" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M12.307 14.782h-.017q-.055.001-.123.01-1.172.023-1.94-.87-.774-.9-.565-2.07a1 1 0 0 0 .012-.131v-.013a.75.75 0 0 0-.75-.737H8.92a.75.75 0 0 0-.734.618q-.335 1.87.904 3.311 1.237 1.44 3.133 1.392.064-.002.14-.012a.75.75 0 0 0 .695-.748v-.019a.75.75 0 0 0-.75-.731zM7.285 18.683q-.252 1.31-.162 2.641l.002.05a.75.75 0 0 1-.75.751.75.75 0 0 1-.748-.7q-.103-1.524.185-3.025a.75.75 0 0 1 1.473.283M10.223 18.661q-.267 1.65.153 2.312a.75.75 0 0 1 .117.374v.028a.75.75 0 0 1-.731.75h-.019a.75.75 0 0 1-.633-.348q-.726-1.143-.368-3.355a.75.75 0 0 1 .724-.63h.016a.75.75 0 0 1 .75.733v.017a1 1 0 0 1-.01.12" }, null)]);
});
var yl = Ye("Close", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M20 5.468 5.468 20 4 18.532 18.532 4z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M5.468 4 20 18.532 18.532 20 4 5.468z" }, null)]);
});
var kp = Ye("Delete", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { fill: "none", stroke: e16.color, "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "1.5", d: "m14.413 9.99-.27 7M9.856 16.99l-.269-7" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m5.52 5.733 1.068 13.882q.045.586.476.986.432.399 1.02.399h7.832q.588 0 1.02-.4.431-.399.476-.984L18.48 5.733q.006-.07.024-.137.018-.068.049-.131.03-.064.072-.12.042-.057.093-.104.052-.048.111-.085t.125-.063.135-.039.139-.013q.074 0 .146.014.073.015.141.043t.13.07q.061.04.113.093.053.052.094.113.04.062.069.13.028.068.043.14t.014.147l-.002.058-1.068 13.881q-.09 1.173-.953 1.971-.863.799-2.039.799H8.084q-1.176 0-2.039-.799-.863-.798-.953-1.97L4.024 5.847l-.002-.058q0-.074.014-.146.015-.073.043-.141t.07-.13q.04-.061.093-.113.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043t.147-.014q.07 0 .14.013.068.013.134.039.065.025.125.063.06.037.11.085.052.047.094.104t.072.12q.03.063.05.13.017.068.023.138" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M7.5 4.477v.916q0 .074.014.146.015.073.043.141t.07.13q.04.061.093.113.052.053.113.094.062.04.13.069.068.028.14.043t.147.014.146-.014.141-.043.13-.07.113-.093q.053-.052.094-.113.04-.062.069-.13.028-.068.043-.14T9 5.392v-.916q0-.591.399-1.015.394-.418.965-.436 1.636-.052 3.272 0 .571.018.966.436.398.423.398 1.015v.916q0 .074.014.146.015.073.043.141t.07.13q.04.061.093.113.052.053.113.094.062.04.13.069.068.028.14.043t.147.014.146-.014.141-.043.13-.07.113-.093q.053-.052.094-.113.04-.062.069-.13.028-.068.043-.14t.014-.147v-.916q0-1.187-.807-2.043-.819-.87-2.01-.908-1.683-.053-3.367 0-1.19.038-2.01.908-.806.857-.806 2.043" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M12 5.998q4.103 0 8.122.697.063.011.128.011.074 0 .146-.014.073-.015.141-.043t.13-.07q.061-.04.113-.093.053-.052.094-.113.04-.062.069-.13.028-.068.043-.14T21 5.955q0-.066-.011-.13-.012-.065-.034-.127t-.056-.119-.075-.107-.093-.092q-.05-.043-.107-.075-.057-.033-.12-.055-.061-.023-.126-.034-4.145-.72-8.378-.72-4.227.001-8.377.719-.066.011-.128.034-.061.022-.118.055-.057.032-.108.074-.05.043-.093.093t-.075.107-.056.119q-.022.062-.034.126Q3 5.89 3 5.955q0 .074.014.146.015.073.043.141t.07.13q.04.061.093.113.052.053.113.094.062.04.13.069.068.028.14.043t.147.014q.064 0 .128-.011Q7.9 5.998 12 5.998" }, null)]);
});
var bl = Ye("Drag", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { d: "M6 5q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T8 3t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178q.037.09.066.184.028.094.048.19.019.097.028.195T10 5t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117-.168.1q-.087.047-.178.085-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T8 7t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.094-.048-.19-.019-.097-.028-.195T6 5m0 7q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T8 10t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178q.037.09.066.184.028.094.048.19.019.097.028.195T10 12t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117q-.082.054-.168.1t-.178.085q-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T8 14t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.094-.048-.19-.019-.097-.028-.195T6 12m0 7q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T8 17t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178.066.184q.028.095.048.19.019.097.028.195T10 19t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117-.168.1q-.087.047-.178.085-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T8 21t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.095-.048-.19-.019-.097-.028-.195T6 19m7-14q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T15 3t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178q.037.09.066.184.028.094.048.19.019.097.028.195T17 5t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117-.168.1q-.087.047-.178.085-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T15 7t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.094-.048-.19-.019-.097-.028-.195T13 5m0 7q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T15 10t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178q.037.09.066.184.028.094.048.19.019.097.028.195T17 12t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117q-.082.054-.168.1t-.178.085q-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T15 14t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.094-.048-.19-.019-.097-.028-.195T13 12m0 7q0-.098.01-.196t.028-.194.048-.19.066-.185.084-.178.101-.168.117-.158.132-.145.145-.132.158-.117.168-.1.178-.085.184-.066.19-.048.195-.028T15 17t.196.01.194.028.19.048.185.066.178.084.168.101.158.117.145.132.132.145.117.158.1.168.085.178.066.184q.028.095.048.19.019.097.028.195T17 19t-.01.196-.028.194-.048.19q-.029.095-.066.185-.038.091-.084.178-.046.086-.101.168t-.117.158-.132.145-.145.132-.158.117-.168.1q-.087.047-.178.085-.09.037-.184.066-.094.028-.19.048-.097.019-.195.028T15 21t-.196-.01-.194-.028-.19-.048q-.095-.029-.185-.066-.091-.038-.178-.084-.086-.046-.168-.101t-.158-.117-.145-.132-.132-.145-.117-.158-.1-.168q-.047-.087-.085-.178-.037-.09-.066-.184-.028-.095-.048-.19-.019-.097-.028-.195T13 19" }, null)]);
});
var Sp = Ye("Edit", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { d: "M20.25 19.5H3.75a.75.75 0 1 0 0 1.5h16.5a.75.75 0 1 0 0-1.5" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M5.487 17.961a.7.7 0 0 1-.237.04.75.75 0 0 1-.705-.982l1.5-4.5a.75.75 0 0 1 .18-.3l9-8.999a.75.75 0 0 1 1.062 0l3 3a.75.75 0 0 1 0 1.062l-9 9a.75.75 0 0 1-.3.18zm.959-1.9 2.91-.97 8.34-8.34-1.94-1.94-8.34 8.34zm1.022-3.068.008-.023zm2.025 2.052.02-.007zm-4.48 1.493L5 16.543z" }, null)]);
});
var Np = Ye("EmptyBox", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M8.667 11.375h-5a.625.625 0 1 0 0 1.25h4.375V14.5c0 .345.28.625.625.625h6.666c.345 0 .625-.28.625-.625v-1.875h4.375a.625.625 0 0 0 0-1.25h-5a.625.625 0 0 0-.625.625v1.875H9.292V12a.625.625 0 0 0-.625-.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M20.919 11.78q.04.106.04.22v5q0 .95-.672 1.62-.671.672-1.62.672H5.333q-.949 0-1.62-.672-.671-.67-.671-1.62v-5q0-.114.04-.22l2.094-5.585q.251-.67.84-1.079.59-.408 1.306-.408h9.356q.717 0 1.306.408.589.409.84 1.08zm-3.265-5.146 2.054 5.48V17q0 .431-.305.737-.305.305-.736.305H5.333q-.431 0-.736-.305-.305-.306-.305-.737v-4.887l2.054-5.479q.254-.676.976-.676h9.356q.722 0 .976.676" }, null)]);
});
var Mp = Ye("File", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M16.375 15.75h-8.75a.625.625 0 1 0 0 1.25h8.75a.625.625 0 1 0 0-1.25M16.375 12h-8.75a.625.625 0 1 0 0 1.25h8.75a.625.625 0 1 0 0-1.25M10.125 8.25h-2.5a.625.625 0 1 0 0 1.25h2.5a.625.625 0 1 0 0-1.25" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M20.567 8.433a.63.63 0 0 1 .183.442v12.5c0 .345-.28.625-.625.625H3.875a.625.625 0 0 1-.625-.625V2.625c0-.345.28-.625.625-.625h10c.166 0 .325.066.442.183zm-6.95-5.183L19.5 9.134V20.75h-15V3.25z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M20.125 9.5h-6.25a.625.625 0 0 1-.625-.625v-6.25a.625.625 0 1 1 1.25 0V8.25h5.625a.625.625 0 1 1 0 1.25" }, null)]);
});
var Ir = Ye("FilterFill", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { d: "M4 4h16l-5.818 9.273v4.636L9.818 21v-7.727z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M8.818 13.56V21q0 .155.047.303t.137.275q.057.08.129.148.071.068.154.12.084.053.176.088t.189.052q.097.016.195.014.099-.003.195-.025t.186-.062.17-.097l4.364-3.09q.098-.07.176-.16.079-.091.134-.198.055-.106.083-.223.029-.116.029-.236V13.56l5.665-9.029Q21 4.288 21 4q0-.098-.02-.195-.018-.097-.056-.188-.038-.09-.093-.173-.054-.081-.124-.151t-.151-.124q-.082-.055-.173-.093t-.188-.057T20 3H4q-.288 0-.531.153-.084.052-.156.12-.071.068-.128.148t-.098.17-.062.186T3 3.97t.014.196.052.189.087.175zm2-.287q0-.288-.153-.532L5.808 5h12.384l-4.857 7.741q-.153.244-.153.532v4.119l-2.364 1.674z" }, null)]);
});
var La = Ye("Filter", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M9.068 21v-7.511l-5.703-9.09A.75.75 0 0 1 4 3.25h16a.75.75 0 0 1 .635 1.149l-5.703 9.09v4.42a.75.75 0 0 1-.317.612l-4.363 3.091A.75.75 0 0 1 9.068 21m1.385-8.126a.75.75 0 0 1 .115.399v6.277l2.864-2.029v-4.248c0-.141.04-.28.114-.399l5.098-8.124H5.356z" }, null)]);
});
var $p = Ye("Fold", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M13.628 13.1h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625h-7.714a.634.634 0 0 0-.643.625c0 .345.288.625.643.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m17.94 9.167-3.403 3.308 3.402 3.308a.617.617 0 0 1 0 .884.65.65 0 0 1-.423.182l-.03.001a.65.65 0 0 1-.455-.183l-3.858-3.75a.616.616 0 0 1 0-.884l3.858-3.75a.65.65 0 0 1 .909 0 .616.616 0 0 1 0 .884M10.342 11.85H2.628a.634.634 0 0 0-.643.625c0 .345.288.625.643.625h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m6.03 15.783 3.403-3.308-3.402-3.308a.617.617 0 0 1 0-.884.65.65 0 0 1 .423-.182l.031-.001c.17 0 .334.066.455.183l3.857 3.75a.616.616 0 0 1 0 .884l-3.857 3.75a.65.65 0 0 1-.91 0 .616.616 0 0 1 0-.884" }, null)]);
});
var xp = Ye("Hide", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M12.016 19.508q-3.089 0-6.019-2.305-1.892-1.488-3.449-3.693-.448-.64-.448-1.419 0-.778.446-1.415 1.56-2.208 3.451-3.696 2.93-2.305 6.02-2.305 3.088 0 6.018 2.305 1.893 1.488 3.45 3.693.448.64.448 1.418t-.446 1.416q-1.56 2.208-3.452 3.696-2.93 2.305-6.019 2.305m0-1.5q2.57 0 5.092-1.984 1.72-1.353 3.15-3.377.388-.556.002-1.109-1.432-2.026-3.152-3.38-2.522-1.983-5.092-1.983T6.925 8.159q-1.72 1.353-3.15 3.376-.389.556-.002 1.11 1.431 2.026 3.152 3.38 2.522 1.983 5.091 1.983" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M14.904 14.979Q16.1 13.783 16.1 12.09t-1.196-2.887-2.888-1.196T9.13 9.204t-1.196 2.887 1.196 2.888 2.887 1.196 2.888-1.196m-1.061-4.714q.757.756.757 1.826t-.757 1.827-1.827.757-1.826-.757-.757-1.827.757-1.826q.756-.757 1.826-.757t1.827.757" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M19.73 3.14 3.065 19.805a.75.75 0 1 0 1.06 1.06L20.793 4.2a.75.75 0 0 0-1.061-1.06" }, null)]);
});
var Ip = Ye("LeftMenuDisplay", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { d: "M3 4.25v-.5A.75.75 0 0 1 3.75 3h16.5a.75.75 0 0 1 .75.75v.5a.75.75 0 0 1-.75.75H3.75A.75.75 0 0 1 3 4.25M3 20.25v-.5a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 .75.75v.5a.75.75 0 0 1-.75.75H3.75a.75.75 0 0 1-.75-.75M11 9.5V9a.75.75 0 0 1 .75-.75h8.5A.75.75 0 0 1 21 9v.5a.75.75 0 0 1-.75.75h-8.5A.75.75 0 0 1 11 9.5M11 15v-.5a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 .75.75v.5a.75.75 0 0 1-.75.75h-8.5A.75.75 0 0 1 11 15M3 15.138a.5.5 0 0 0 .748.435l5.492-3.139a.5.5 0 0 0 0-.868L3.748 8.427A.5.5 0 0 0 3 8.862z" }, null)]);
});
var Dp = Ye("Loading", true, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M21.298 15.68Q22 13.908 22 12t-.702-3.68q-.762-1.927-2.227-3.391-1.464-1.465-3.39-2.227Q13.907 2 12 2t-3.68.702q-1.927.762-3.391 2.227-1.465 1.464-2.227 3.39Q2 10.093 2 12t.702 3.68q.762 1.927 2.227 3.391t3.39 2.227Q10.093 22 12 22t3.68-.702q1.927-.762 3.391-2.227t2.227-3.39m-1.86-6.625Q20 10.475 20 12q0 1.526-.562 2.945-.61 1.54-1.781 2.712-1.172 1.171-2.712 1.781Q13.525 20 12 20q-1.526 0-2.945-.562-1.54-.61-2.712-1.781-1.171-1.172-1.781-2.712Q4 13.525 4 12q0-1.526.562-2.945.61-1.54 1.781-2.712 1.172-1.171 2.712-1.781Q10.475 4 12 4q1.526 0 2.945.562 1.54.61 2.712 1.781 1.171 1.172 1.781 2.712", style: "opacity:.4000000059604645" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M12 4h-1V2h1q2.034 0 3.893.786 1.795.76 3.178 2.143t2.143 3.178Q22 9.967 22 12v1h-2v-1q0-3.314-2.343-5.657T12 4" }, null)]);
});
var oi = Ye("More", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("rect", { width: "4", height: "4", x: "3", y: "10", rx: "2" }, null), createVNode("rect", { width: "4", height: "4", x: "10", y: "10", rx: "2" }, null), createVNode("rect", { width: "4", height: "4", x: "17", y: "10", rx: "2" }, null)]);
});
var g0 = Ye("Refresh", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M18.592 7.487q-1.715-2.693-4.797-3.49-3.137-.81-5.963.833-1.665.968-2.714 2.57-1.006 1.534-1.276 3.376-.27 1.843.25 3.612.545 1.847 1.86 3.273 1.312 1.421 3.11 2.086 1.72.636 3.57.471 1.85-.164 3.434-1.094 1.655-.972 2.702-2.605v-.001a.75.75 0 0 1 1.264.809q-1.24 1.937-3.207 3.09-1.874 1.102-4.061 1.296t-4.223-.56q-2.135-.789-3.69-2.475-1.554-1.683-2.197-3.866-.615-2.085-.296-4.254.318-2.17 1.505-3.98Q5.107 4.68 7.078 3.532q3.358-1.953 7.093-.988 1.74.45 3.202 1.504 1.493 1.077 2.484 2.632a.75.75 0 1 1-1.265.806" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M15 7.25h4.25V2.5h1.5v6.25H15z" }, null)]);
});
var Dr = Ye("Search", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M15.426 15.401a.745.745 0 0 1 1.058 0l4.794 4.817a.755.755 0 0 1 0 1.064.745.745 0 0 1-1.056 0l-4.795-4.817a.755.755 0 0 1 0-1.064" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M18.17 13.537q.58-1.463.58-3.037t-.58-3.037q-.628-1.588-1.836-2.797-1.209-1.208-2.797-1.837-1.463-.579-3.037-.579t-3.037.58q-1.588.628-2.797 1.836Q3.458 5.875 2.83 7.463 2.25 8.926 2.25 10.5t.58 3.037q.628 1.588 1.836 2.797 1.209 1.208 2.797 1.837 1.463.579 3.037.579t3.037-.58q1.588-.628 2.797-1.836 1.208-1.209 1.837-2.797m-2.897-7.81Q17.25 7.704 17.25 10.5t-1.977 4.773T10.5 17.25t-4.773-1.977T3.75 10.5t1.977-4.773T10.5 3.75t4.773 1.977" }, null)]);
});
function Dn(e16) {
  if (e16 === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e16;
}
function v0(e16, t10) {
  e16.prototype = Object.create(t10.prototype), e16.prototype.constructor = e16, e16.__proto__ = t10;
}
var Qt = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } };
var ra = { duration: 0.5, overwrite: false, delay: 0 };
var _l;
var Kt;
var dt;
var an = 1e8;
var at = 1 / an;
var Ns = Math.PI * 2;
var Ap = Ns / 4;
var Ep = 0;
var y0 = Math.sqrt;
var Kp = Math.cos;
var zp = Math.sin;
var It = function(e16) {
  return typeof e16 == "string";
};
var yt = function(e16) {
  return typeof e16 == "function";
};
var Pn = function(e16) {
  return typeof e16 == "number";
};
var wl = function(e16) {
  return typeof e16 > "u";
};
var $n = function(e16) {
  return typeof e16 == "object";
};
var jt = function(e16) {
  return e16 !== false;
};
var Tl = function() {
  return typeof window < "u";
};
var pr = function(e16) {
  return yt(e16) || It(e16);
};
var b0 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {
};
var zt = Array.isArray;
var Ms = /(?:-?\.?\d|\.)+/gi;
var _0 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
var Ho = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
var Li = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
var w0 = /[+-]=-?[.\d]+/;
var T0 = /[^,'"\[\]\s]+/gi;
var Pp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
var mt;
var yn;
var $s;
var Cl;
var en = {};
var Ar = {};
var C0;
var k0 = function(e16) {
  return (Ar = Mo(e16, en)) && Wt;
};
var kl = function(e16, t10) {
  return console.warn("Invalid property", e16, "set to", t10, "Missing plugin? gsap.registerPlugin()");
};
var Fa = function(e16, t10) {
  return !t10 && console.warn(e16);
};
var S0 = function(e16, t10) {
  return e16 && (en[e16] = t10) && Ar && (Ar[e16] = t10) || en;
};
var ja = function() {
  return 0;
};
var Rp = { suppressEvents: true, isStart: true, kill: false };
var wr = { suppressEvents: true, kill: false };
var Lp = { suppressEvents: true };
var Sl = {};
var Gn = [];
var xs = {};
var N0;
var Ht = {};
var Fi = {};
var Tc = 30;
var Tr = [];
var Nl = "";
var Ml = function(e16) {
  var t10 = e16[0], n, o;
  if ($n(t10) || yt(t10) || (e16 = [e16]), !(n = (t10._gsap || {}).harness)) {
    for (o = Tr.length; o-- && !Tr[o].targetTest(t10); ) ;
    n = Tr[o];
  }
  for (o = e16.length; o--; ) e16[o] && (e16[o]._gsap || (e16[o]._gsap = new X0(e16[o], n))) || e16.splice(o, 1);
  return e16;
};
var _o = function(e16) {
  return e16._gsap || Ml(rn(e16))[0]._gsap;
};
var M0 = function(e16, t10, n) {
  return (n = e16[t10]) && yt(n) ? e16[t10]() : wl(n) && e16.getAttribute && e16.getAttribute(t10) || n;
};
var Ot = function(e16, t10) {
  return (e16 = e16.split(",")).forEach(t10) || e16;
};
var _t2 = function(e16) {
  return Math.round(e16 * 1e5) / 1e5 || 0;
};
var $t = function(e16) {
  return Math.round(e16 * 1e7) / 1e7 || 0;
};
var Qo = function(e16, t10) {
  var n = t10.charAt(0), o = parseFloat(t10.substr(2));
  return e16 = parseFloat(e16), n === "+" ? e16 + o : n === "-" ? e16 - o : n === "*" ? e16 * o : e16 / o;
};
var Fp = function(e16, t10) {
  for (var n = t10.length, o = 0; e16.indexOf(t10[o]) < 0 && ++o < n; ) ;
  return o < n;
};
var Er = function() {
  var e16 = Gn.length, t10 = Gn.slice(0), n, o;
  for (xs = {}, Gn.length = 0, n = 0; n < e16; n++) o = t10[n], o && o._lazy && (o.render(o._lazy[0], o._lazy[1], true)._lazy = 0);
};
var $0 = function(e16, t10, n, o) {
  Gn.length && !Kt && Er(), e16.render(t10, n, Kt && t10 < 0 && (e16._initted || e16._startAt)), Gn.length && !Kt && Er();
};
var x0 = function(e16) {
  var t10 = parseFloat(e16);
  return (t10 || t10 === 0) && (e16 + "").match(T0).length < 2 ? t10 : It(e16) ? e16.trim() : e16;
};
var I0 = function(e16) {
  return e16;
};
var sn = function(e16, t10) {
  for (var n in t10) n in e16 || (e16[n] = t10[n]);
  return e16;
};
var jp = function(e16) {
  return function(t10, n) {
    for (var o in n) o in t10 || o === "duration" && e16 || o === "ease" || (t10[o] = n[o]);
  };
};
var Mo = function(e16, t10) {
  for (var n in t10) e16[n] = t10[n];
  return e16;
};
var Cc = function e(t10, n) {
  for (var o in n) o !== "__proto__" && o !== "constructor" && o !== "prototype" && (t10[o] = $n(n[o]) ? e(t10[o] || (t10[o] = {}), n[o]) : n[o]);
  return t10;
};
var Kr = function(e16, t10) {
  var n = {}, o;
  for (o in e16) o in t10 || (n[o] = e16[o]);
  return n;
};
var Ea = function(e16) {
  var t10 = e16.parent || mt, n = e16.keyframes ? jp(zt(e16.keyframes)) : sn;
  if (jt(e16.inherit)) for (; t10; ) n(e16, t10.vars.defaults), t10 = t10.parent || t10._dp;
  return e16;
};
var Op = function(e16, t10) {
  for (var n = e16.length, o = n === t10.length; o && n-- && e16[n] === t10[n]; ) ;
  return n < 0;
};
var D0 = function(e16, t10, n, o, r) {
  var a = e16[o], i;
  if (r) for (i = t10[r]; a && a[r] > i; ) a = a._prev;
  return a ? (t10._next = a._next, a._next = t10) : (t10._next = e16[n], e16[n] = t10), t10._next ? t10._next._prev = t10 : e16[o] = t10, t10._prev = a, t10.parent = t10._dp = e16, t10;
};
var ai = function(e16, t10, n, o) {
  n === void 0 && (n = "_first"), o === void 0 && (o = "_last");
  var r = t10._prev, a = t10._next;
  r ? r._next = a : e16[n] === t10 && (e16[n] = a), a ? a._prev = r : e16[o] === t10 && (e16[o] = r), t10._next = t10._prev = t10.parent = null;
};
var Jn = function(e16, t10) {
  e16.parent && (!t10 || e16.parent.autoRemoveChildren) && e16.parent.remove && e16.parent.remove(e16), e16._act = 0;
};
var wo = function(e16, t10) {
  if (e16 && (!t10 || t10._end > e16._dur || t10._start < 0)) for (var n = e16; n; ) n._dirty = 1, n = n.parent;
  return e16;
};
var Bp = function(e16) {
  for (var t10 = e16.parent; t10 && t10.parent; ) t10._dirty = 1, t10.totalDuration(), t10 = t10.parent;
  return e16;
};
var Is = function(e16, t10, n, o) {
  return e16._startAt && (Kt ? e16._startAt.revert(wr) : e16.vars.immediateRender && !e16.vars.autoRevert || e16._startAt.render(t10, true, o));
};
var Zp = function e2(t10) {
  return !t10 || t10._ts && e2(t10.parent);
};
var kc = function(e16) {
  return e16._repeat ? ia(e16._tTime, e16 = e16.duration() + e16._rDelay) * e16 : 0;
};
var ia = function(e16, t10) {
  var n = Math.floor(e16 /= t10);
  return e16 && n === e16 ? n - 1 : n;
};
var zr = function(e16, t10) {
  return (e16 - t10._start) * t10._ts + (t10._ts >= 0 ? 0 : t10._dirty ? t10.totalDuration() : t10._tDur);
};
var ri = function(e16) {
  return e16._end = $t(e16._start + (e16._tDur / Math.abs(e16._ts || e16._rts || at) || 0));
};
var ii = function(e16, t10) {
  var n = e16._dp;
  return n && n.smoothChildTiming && e16._ts && (e16._start = $t(n._time - (e16._ts > 0 ? t10 / e16._ts : ((e16._dirty ? e16.totalDuration() : e16._tDur) - t10) / -e16._ts)), ri(e16), n._dirty || wo(n, e16)), e16;
};
var A0 = function(e16, t10) {
  var n;
  if ((t10._time || !t10._dur && t10._initted || t10._start < e16._time && (t10._dur || !t10.add)) && (n = zr(e16.rawTime(), t10), (!t10._dur || er(0, t10.totalDuration(), n) - t10._tTime > at) && t10.render(n, true)), wo(e16, t10)._dp && e16._initted && e16._time >= e16._dur && e16._ts) {
    if (e16._dur < e16.duration()) for (n = e16; n._dp; ) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
    e16._zTime = -at;
  }
};
var _n = function(e16, t10, n, o) {
  return t10.parent && Jn(t10), t10._start = $t((Pn(n) ? n : n || e16 !== mt ? on2(e16, n, t10) : e16._time) + t10._delay), t10._end = $t(t10._start + (t10.totalDuration() / Math.abs(t10.timeScale()) || 0)), D0(e16, t10, "_first", "_last", e16._sort ? "_start" : 0), Ds(t10) || (e16._recent = t10), o || A0(e16, t10), e16._ts < 0 && ii(e16, e16._tTime), e16;
};
var E0 = function(e16, t10) {
  return (en.ScrollTrigger || kl("scrollTrigger", t10)) && en.ScrollTrigger.create(t10, e16);
};
var K0 = function(e16, t10, n, o, r) {
  if (xl(e16, t10, r), !e16._initted) return 1;
  if (!n && e16._pt && !Kt && (e16._dur && e16.vars.lazy !== false || !e16._dur && e16.vars.lazy) && N0 !== Ut.frame) return Gn.push(e16), e16._lazy = [r, o], 1;
};
var Wp = function e3(t10) {
  var n = t10.parent;
  return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e3(n));
};
var Ds = function(e16) {
  var t10 = e16.data;
  return t10 === "isFromStart" || t10 === "isStart";
};
var qp = function(e16, t10, n, o) {
  var r = e16.ratio, a = t10 < 0 || !t10 && (!e16._start && Wp(e16) && !(!e16._initted && Ds(e16)) || (e16._ts < 0 || e16._dp._ts < 0) && !Ds(e16)) ? 0 : 1, i = e16._rDelay, s = 0, l, c, u;
  if (i && e16._repeat && (s = er(0, e16._tDur, t10), c = ia(s, i), e16._yoyo && c & 1 && (a = 1 - a), c !== ia(e16._tTime, i) && (r = 1 - a, e16.vars.repeatRefresh && e16._initted && e16.invalidate())), a !== r || Kt || o || e16._zTime === at || !t10 && e16._zTime) {
    if (!e16._initted && K0(e16, t10, o, n, s)) return;
    for (u = e16._zTime, e16._zTime = t10 || (n ? at : 0), n || (n = t10 && !u), e16.ratio = a, e16._from && (a = 1 - a), e16._time = 0, e16._tTime = s, l = e16._pt; l; ) l.r(a, l.d), l = l._next;
    t10 < 0 && Is(e16, t10, n, true), e16._onUpdate && !n && Yt(e16, "onUpdate"), s && e16._repeat && !n && e16.parent && Yt(e16, "onRepeat"), (t10 >= e16._tDur || t10 < 0) && e16.ratio === a && (a && Jn(e16, 1), !n && !Kt && (Yt(e16, a ? "onComplete" : "onReverseComplete", true), e16._prom && e16._prom()));
  } else e16._zTime || (e16._zTime = t10);
};
var Vp = function(e16, t10, n) {
  var o;
  if (n > t10) for (o = e16._first; o && o._start <= n; ) {
    if (o.data === "isPause" && o._start > t10) return o;
    o = o._next;
  }
  else for (o = e16._last; o && o._start >= n; ) {
    if (o.data === "isPause" && o._start < t10) return o;
    o = o._prev;
  }
};
var sa = function(e16, t10, n, o) {
  var r = e16._repeat, a = $t(t10) || 0, i = e16._tTime / e16._tDur;
  return i && !o && (e16._time *= a / e16._dur), e16._dur = a, e16._tDur = r ? r < 0 ? 1e10 : $t(a * (r + 1) + e16._rDelay * r) : a, i > 0 && !o && ii(e16, e16._tTime = e16._tDur * i), e16.parent && ri(e16), n || wo(e16.parent, e16), e16;
};
var Sc = function(e16) {
  return e16 instanceof Pt ? wo(e16) : sa(e16, e16._dur);
};
var Hp = { _start: 0, endTime: ja, totalDuration: ja };
var on2 = function e4(t10, n, o) {
  var r = t10.labels, a = t10._recent || Hp, i = t10.duration() >= an ? a.endTime(false) : t10._dur, s, l, c;
  return It(n) && (isNaN(n) || n in r) ? (l = n.charAt(0), c = n.substr(-1) === "%", s = n.indexOf("="), l === "<" || l === ">" ? (s >= 0 && (n = n.replace(/=/, "")), (l === "<" ? a._start : a.endTime(a._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (c ? (s < 0 ? a : o).totalDuration() / 100 : 1)) : s < 0 ? (n in r || (r[n] = i), r[n]) : (l = parseFloat(n.charAt(s - 1) + n.substr(s + 1)), c && o && (l = l / 100 * (zt(o) ? o[0] : o).totalDuration()), s > 1 ? e4(t10, n.substr(0, s - 1), o) + l : i + l)) : n == null ? i : +n;
};
var Ka = function(e16, t10, n) {
  var o = Pn(t10[1]), r = (o ? 2 : 1) + (e16 < 2 ? 0 : 1), a = t10[r], i, s;
  if (o && (a.duration = t10[1]), a.parent = n, e16) {
    for (i = a, s = n; s && !("immediateRender" in i); ) i = s.vars.defaults || {}, s = jt(s.vars.inherit) && s.parent;
    a.immediateRender = jt(i.immediateRender), e16 < 2 ? a.runBackwards = 1 : a.startAt = t10[r - 1];
  }
  return new Tt(t10[0], a, t10[r + 1]);
};
var io = function(e16, t10) {
  return e16 || e16 === 0 ? t10(e16) : t10;
};
var er = function(e16, t10, n) {
  return n < e16 ? e16 : n > t10 ? t10 : n;
};
var Et = function(e16, t10) {
  return !It(e16) || !(t10 = Pp.exec(e16)) ? "" : t10[1];
};
var Up = function(e16, t10, n) {
  return io(n, function(o) {
    return er(e16, t10, o);
  });
};
var As = [].slice;
var z0 = function(e16, t10) {
  return e16 && $n(e16) && "length" in e16 && (!t10 && !e16.length || e16.length - 1 in e16 && $n(e16[0])) && !e16.nodeType && e16 !== yn;
};
var Gp = function(e16, t10, n) {
  return n === void 0 && (n = []), e16.forEach(function(o) {
    var r;
    return It(o) && !t10 || z0(o, 1) ? (r = n).push.apply(r, rn(o)) : n.push(o);
  }) || n;
};
var rn = function(e16, t10, n) {
  return dt && !t10 && dt.selector ? dt.selector(e16) : It(e16) && !n && ($s || !la()) ? As.call((t10 || Cl).querySelectorAll(e16), 0) : zt(e16) ? Gp(e16, n) : z0(e16) ? As.call(e16, 0) : e16 ? [e16] : [];
};
var Es = function(e16) {
  return e16 = rn(e16)[0] || Fa("Invalid scope") || {}, function(t10) {
    var n = e16.current || e16.nativeElement || e16;
    return rn(t10, n.querySelectorAll ? n : n === e16 ? Fa("Invalid scope") || Cl.createElement("div") : e16);
  };
};
var P0 = function(e16) {
  return e16.sort(function() {
    return 0.5 - Math.random();
  });
};
var R0 = function(e16) {
  if (yt(e16)) return e16;
  var t10 = $n(e16) ? e16 : { each: e16 }, n = To(t10.ease), o = t10.from || 0, r = parseFloat(t10.base) || 0, a = {}, i = o > 0 && o < 1, s = isNaN(o) || i, l = t10.axis, c = o, u = o;
  return It(o) ? c = u = { center: 0.5, edges: 0.5, end: 1 }[o] || 0 : !i && s && (c = o[0], u = o[1]), function(d, m, p) {
    var f = (p || t10).length, h10 = a[f], g, v, y, k, T, w, _, M, x;
    if (!h10) {
      if (x = t10.grid === "auto" ? 0 : (t10.grid || [1, an])[1], !x) {
        for (_ = -an; _ < (_ = p[x++].getBoundingClientRect().left) && x < f; ) ;
        x < f && x--;
      }
      for (h10 = a[f] = [], g = s ? Math.min(x, f) * c - 0.5 : o % x, v = x === an ? 0 : s ? f * u / x - 0.5 : o / x | 0, _ = 0, M = an, w = 0; w < f; w++) y = w % x - g, k = v - (w / x | 0), h10[w] = T = l ? Math.abs(l === "y" ? k : y) : y0(y * y + k * k), T > _ && (_ = T), T < M && (M = T);
      o === "random" && P0(h10), h10.max = _ - M, h10.min = M, h10.v = f = (parseFloat(t10.amount) || parseFloat(t10.each) * (x > f ? f - 1 : l ? l === "y" ? f / x : x : Math.max(x, f / x)) || 0) * (o === "edges" ? -1 : 1), h10.b = f < 0 ? r - f : r, h10.u = Et(t10.amount || t10.each) || 0, n = n && f < 0 ? H0(n) : n;
    }
    return f = (h10[d] - h10.min) / h10.max || 0, $t(h10.b + (n ? n(f) : f) * h10.v) + h10.u;
  };
};
var Ks = function(e16) {
  var t10 = Math.pow(10, ((e16 + "").split(".")[1] || "").length);
  return function(n) {
    var o = $t(Math.round(parseFloat(n) / e16) * e16 * t10);
    return (o - o % 1) / t10 + (Pn(n) ? 0 : Et(n));
  };
};
var L0 = function(e16, t10) {
  var n = zt(e16), o, r;
  return !n && $n(e16) && (o = n = e16.radius || an, e16.values ? (e16 = rn(e16.values), (r = !Pn(e16[0])) && (o *= o)) : e16 = Ks(e16.increment)), io(t10, n ? yt(e16) ? function(a) {
    return r = e16(a), Math.abs(r - a) <= o ? r : a;
  } : function(a) {
    for (var i = parseFloat(r ? a.x : a), s = parseFloat(r ? a.y : 0), l = an, c = 0, u = e16.length, d, m; u--; ) r ? (d = e16[u].x - i, m = e16[u].y - s, d = d * d + m * m) : d = Math.abs(e16[u] - i), d < l && (l = d, c = u);
    return c = !o || l <= o ? e16[c] : a, r || c === a || Pn(a) ? c : c + Et(a);
  } : Ks(e16));
};
var F0 = function(e16, t10, n, o) {
  return io(zt(e16) ? !t10 : n === true ? !!(n = 0) : !o, function() {
    return zt(e16) ? e16[~~(Math.random() * e16.length)] : (n = n || 1e-5) && (o = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e16 - n / 2 + Math.random() * (t10 - e16 + n * 0.99)) / n) * n * o) / o;
  });
};
var Xp = function() {
  for (var e16 = arguments.length, t10 = new Array(e16), n = 0; n < e16; n++) t10[n] = arguments[n];
  return function(o) {
    return t10.reduce(function(r, a) {
      return a(r);
    }, o);
  };
};
var Yp = function(e16, t10) {
  return function(n) {
    return e16(parseFloat(n)) + (t10 || Et(n));
  };
};
var Qp = function(e16, t10, n) {
  return O0(e16, t10, 0, 1, n);
};
var j0 = function(e16, t10, n) {
  return io(n, function(o) {
    return e16[~~t10(o)];
  });
};
var Jp = function e5(t10, n, o) {
  var r = n - t10;
  return zt(t10) ? j0(t10, e5(0, t10.length), n) : io(o, function(a) {
    return (r + (a - t10) % r) % r + t10;
  });
};
var eh = function e6(t10, n, o) {
  var r = n - t10, a = r * 2;
  return zt(t10) ? j0(t10, e6(0, t10.length - 1), n) : io(o, function(i) {
    return i = (a + (i - t10) % a) % a || 0, t10 + (i > r ? a - i : i);
  });
};
var Oa = function(e16) {
  for (var t10 = 0, n = "", o, r, a, i; ~(o = e16.indexOf("random(", t10)); ) a = e16.indexOf(")", o), i = e16.charAt(o + 7) === "[", r = e16.substr(o + 7, a - o - 7).match(i ? T0 : Ms), n += e16.substr(t10, o - t10) + F0(i ? r : +r[0], i ? 0 : +r[1], +r[2] || 1e-5), t10 = a + 1;
  return n + e16.substr(t10, e16.length - t10);
};
var O0 = function(e16, t10, n, o, r) {
  var a = t10 - e16, i = o - n;
  return io(r, function(s) {
    return n + ((s - e16) / a * i || 0);
  });
};
var th = function e7(t10, n, o, r) {
  var a = isNaN(t10 + n) ? 0 : function(p) {
    return (1 - p) * t10 + p * n;
  };
  if (!a) {
    var i = It(t10), s = {}, l, c, u, d, m;
    if (o === true && (r = 1) && (o = null), i) t10 = { p: t10 }, n = { p: n };
    else if (zt(t10) && !zt(n)) {
      for (u = [], d = t10.length, m = d - 2, c = 1; c < d; c++) u.push(e7(t10[c - 1], t10[c]));
      d--, a = function(p) {
        p *= d;
        var f = Math.min(m, ~~p);
        return u[f](p - f);
      }, o = n;
    } else r || (t10 = Mo(zt(t10) ? [] : {}, t10));
    if (!u) {
      for (l in n) $l.call(s, t10, l, "get", n[l]);
      a = function(p) {
        return Al(p, s) || (i ? t10.p : t10);
      };
    }
  }
  return io(o, a);
};
var Nc = function(e16, t10, n) {
  var o = e16.labels, r = an, a, i, s;
  for (a in o) i = o[a] - t10, i < 0 == !!n && i && r > (i = Math.abs(i)) && (s = a, r = i);
  return s;
};
var Yt = function(e16, t10, n) {
  var o = e16.vars, r = o[t10], a = dt, i = e16._ctx, s, l, c;
  if (r) return s = o[t10 + "Params"], l = o.callbackScope || e16, n && Gn.length && Er(), i && (dt = i), c = s ? r.apply(l, s) : r.call(l), dt = a, c;
};
var Da = function(e16) {
  return Jn(e16), e16.scrollTrigger && e16.scrollTrigger.kill(!!Kt), e16.progress() < 1 && Yt(e16, "onInterrupt"), e16;
};
var Uo;
var B0 = [];
var Z0 = function(e16) {
  if (e16) if (e16 = !e16.name && e16.default || e16, Tl() || e16.headless) {
    var t10 = e16.name, n = yt(e16), o = t10 && !n && e16.init ? function() {
      this._props = [];
    } : e16, r = { init: ja, render: Al, add: $l, kill: vh, modifier: gh, rawVars: 0 }, a = { targetTest: 0, get: 0, getSetter: Dl, aliases: {}, register: 0 };
    if (la(), e16 !== o) {
      if (Ht[t10]) return;
      sn(o, sn(Kr(e16, r), a)), Mo(o.prototype, Mo(r, Kr(e16, a))), Ht[o.prop = t10] = o, e16.targetTest && (Tr.push(o), Sl[t10] = 1), t10 = (t10 === "css" ? "CSS" : t10.charAt(0).toUpperCase() + t10.substr(1)) + "Plugin";
    }
    S0(t10, o), e16.register && e16.register(Wt, o, Bt);
  } else B0.push(e16);
};
var nt = 255;
var Aa = { aqua: [0, nt, nt], lime: [0, nt, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, nt], navy: [0, 0, 128], white: [nt, nt, nt], olive: [128, 128, 0], yellow: [nt, nt, 0], orange: [nt, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [nt, 0, 0], pink: [nt, 192, 203], cyan: [0, nt, nt], transparent: [nt, nt, nt, 0] };
var ji = function(e16, t10, n) {
  return e16 += e16 < 0 ? 1 : e16 > 1 ? -1 : 0, (e16 * 6 < 1 ? t10 + (n - t10) * e16 * 6 : e16 < 0.5 ? n : e16 * 3 < 2 ? t10 + (n - t10) * (2 / 3 - e16) * 6 : t10) * nt + 0.5 | 0;
};
var W0 = function(e16, t10, n) {
  var o = e16 ? Pn(e16) ? [e16 >> 16, e16 >> 8 & nt, e16 & nt] : 0 : Aa.black, r, a, i, s, l, c, u, d, m, p;
  if (!o) {
    if (e16.substr(-1) === "," && (e16 = e16.substr(0, e16.length - 1)), Aa[e16]) o = Aa[e16];
    else if (e16.charAt(0) === "#") {
      if (e16.length < 6 && (r = e16.charAt(1), a = e16.charAt(2), i = e16.charAt(3), e16 = "#" + r + r + a + a + i + i + (e16.length === 5 ? e16.charAt(4) + e16.charAt(4) : "")), e16.length === 9) return o = parseInt(e16.substr(1, 6), 16), [o >> 16, o >> 8 & nt, o & nt, parseInt(e16.substr(7), 16) / 255];
      e16 = parseInt(e16.substr(1), 16), o = [e16 >> 16, e16 >> 8 & nt, e16 & nt];
    } else if (e16.substr(0, 3) === "hsl") {
      if (o = p = e16.match(Ms), !t10) s = +o[0] % 360 / 360, l = +o[1] / 100, c = +o[2] / 100, a = c <= 0.5 ? c * (l + 1) : c + l - c * l, r = c * 2 - a, o.length > 3 && (o[3] *= 1), o[0] = ji(s + 1 / 3, r, a), o[1] = ji(s, r, a), o[2] = ji(s - 1 / 3, r, a);
      else if (~e16.indexOf("=")) return o = e16.match(_0), n && o.length < 4 && (o[3] = 1), o;
    } else o = e16.match(Ms) || Aa.transparent;
    o = o.map(Number);
  }
  return t10 && !p && (r = o[0] / nt, a = o[1] / nt, i = o[2] / nt, u = Math.max(r, a, i), d = Math.min(r, a, i), c = (u + d) / 2, u === d ? s = l = 0 : (m = u - d, l = c > 0.5 ? m / (2 - u - d) : m / (u + d), s = u === r ? (a - i) / m + (a < i ? 6 : 0) : u === a ? (i - r) / m + 2 : (r - a) / m + 4, s *= 60), o[0] = ~~(s + 0.5), o[1] = ~~(l * 100 + 0.5), o[2] = ~~(c * 100 + 0.5)), n && o.length < 4 && (o[3] = 1), o;
};
var q0 = function(e16) {
  var t10 = [], n = [], o = -1;
  return e16.split(Xn).forEach(function(r) {
    var a = r.match(Ho) || [];
    t10.push.apply(t10, a), n.push(o += a.length + 1);
  }), t10.c = n, t10;
};
var Mc = function(e16, t10, n) {
  var o = "", r = (e16 + o).match(Xn), a = t10 ? "hsla(" : "rgba(", i = 0, s, l, c, u;
  if (!r) return e16;
  if (r = r.map(function(d) {
    return (d = W0(d, t10, 1)) && a + (t10 ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")";
  }), n && (c = q0(e16), s = n.c, s.join(o) !== c.c.join(o))) for (l = e16.replace(Xn, "1").split(Ho), u = l.length - 1; i < u; i++) o += l[i] + (~s.indexOf(i) ? r.shift() || a + "0,0,0,0)" : (c.length ? c : r.length ? r : n).shift());
  if (!l) for (l = e16.split(Xn), u = l.length - 1; i < u; i++) o += l[i] + r[i];
  return o + l[u];
};
var Xn = function() {
  var e16 = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", t10;
  for (t10 in Aa) e16 += "|" + t10 + "\\b";
  return new RegExp(e16 + ")", "gi");
}();
var nh = /hsl[a]?\(/;
var V0 = function(e16) {
  var t10 = e16.join(" "), n;
  if (Xn.lastIndex = 0, Xn.test(t10)) return n = nh.test(t10), e16[1] = Mc(e16[1], n), e16[0] = Mc(e16[0], n, q0(e16[1])), true;
};
var Ba;
var Ut = function() {
  var e16 = Date.now, t10 = 500, n = 33, o = e16(), r = o, a = 1e3 / 240, i = a, s = [], l, c, u, d, m, p, f = function h10(g) {
    var v = e16() - r, y = g === true, k, T, w, _;
    if ((v > t10 || v < 0) && (o += v - n), r += v, w = r - o, k = w - i, (k > 0 || y) && (_ = ++d.frame, m = w - d.time * 1e3, d.time = w = w / 1e3, i += k + (k >= a ? 4 : a - k), T = 1), y || (l = c(h10)), T) for (p = 0; p < s.length; p++) s[p](w, m, _, g);
  };
  return d = { time: 0, frame: 0, tick: function() {
    f(true);
  }, deltaRatio: function(h10) {
    return m / (1e3 / (h10 || 60));
  }, wake: function() {
    C0 && (!$s && Tl() && (yn = $s = window, Cl = yn.document || {}, en.gsap = Wt, (yn.gsapVersions || (yn.gsapVersions = [])).push(Wt.version), k0(Ar || yn.GreenSockGlobals || !yn.gsap && yn || {}), B0.forEach(Z0)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && d.sleep(), c = u || function(h10) {
      return setTimeout(h10, i - d.time * 1e3 + 1 | 0);
    }, Ba = 1, f(2));
  }, sleep: function() {
    (u ? cancelAnimationFrame : clearTimeout)(l), Ba = 0, c = ja;
  }, lagSmoothing: function(h10, g) {
    t10 = h10 || 1 / 0, n = Math.min(g || 33, t10);
  }, fps: function(h10) {
    a = 1e3 / (h10 || 240), i = d.time * 1e3 + a;
  }, add: function(h10, g, v) {
    var y = g ? function(k, T, w, _) {
      h10(k, T, w, _), d.remove(y);
    } : h10;
    return d.remove(h10), s[v ? "unshift" : "push"](y), la(), y;
  }, remove: function(h10, g) {
    ~(g = s.indexOf(h10)) && s.splice(g, 1) && p >= g && p--;
  }, _listeners: s }, d;
}();
var la = function() {
  return !Ba && Ut.wake();
};
var Oe = {};
var oh = /^[\d.\-M][\d.\-,\s]/;
var ah = /["']/g;
var rh = function(e16) {
  for (var t10 = {}, n = e16.substr(1, e16.length - 3).split(":"), o = n[0], r = 1, a = n.length, i, s, l; r < a; r++) s = n[r], i = r !== a - 1 ? s.lastIndexOf(",") : s.length, l = s.substr(0, i), t10[o] = isNaN(l) ? l.replace(ah, "").trim() : +l, o = s.substr(i + 1).trim();
  return t10;
};
var ih = function(e16) {
  var t10 = e16.indexOf("(") + 1, n = e16.indexOf(")"), o = e16.indexOf("(", t10);
  return e16.substring(t10, ~o && o < n ? e16.indexOf(")", n + 1) : n);
};
var sh = function(e16) {
  var t10 = (e16 + "").split("("), n = Oe[t10[0]];
  return n && t10.length > 1 && n.config ? n.config.apply(null, ~e16.indexOf("{") ? [rh(t10[1])] : ih(e16).split(",").map(x0)) : Oe._CE && oh.test(e16) ? Oe._CE("", e16) : n;
};
var H0 = function(e16) {
  return function(t10) {
    return 1 - e16(1 - t10);
  };
};
var U0 = function e8(t10, n) {
  for (var o = t10._first, r; o; ) o instanceof Pt ? e8(o, n) : o.vars.yoyoEase && (!o._yoyo || !o._repeat) && o._yoyo !== n && (o.timeline ? e8(o.timeline, n) : (r = o._ease, o._ease = o._yEase, o._yEase = r, o._yoyo = n)), o = o._next;
};
var To = function(e16, t10) {
  return e16 && (yt(e16) ? e16 : Oe[e16] || sh(e16)) || t10;
};
var Eo = function(e16, t10, n, o) {
  n === void 0 && (n = function(i) {
    return 1 - t10(1 - i);
  }), o === void 0 && (o = function(i) {
    return i < 0.5 ? t10(i * 2) / 2 : 1 - t10((1 - i) * 2) / 2;
  });
  var r = { easeIn: t10, easeOut: n, easeInOut: o }, a;
  return Ot(e16, function(i) {
    Oe[i] = en[i] = r, Oe[a = i.toLowerCase()] = n;
    for (var s in r) Oe[a + (s === "easeIn" ? ".in" : s === "easeOut" ? ".out" : ".inOut")] = Oe[i + "." + s] = r[s];
  }), r;
};
var G0 = function(e16) {
  return function(t10) {
    return t10 < 0.5 ? (1 - e16(1 - t10 * 2)) / 2 : 0.5 + e16((t10 - 0.5) * 2) / 2;
  };
};
var Oi = function e9(t10, n, o) {
  var r = n >= 1 ? n : 1, a = (o || (t10 ? 0.3 : 0.45)) / (n < 1 ? n : 1), i = a / Ns * (Math.asin(1 / r) || 0), s = function(c) {
    return c === 1 ? 1 : r * Math.pow(2, -10 * c) * zp((c - i) * a) + 1;
  }, l = t10 === "out" ? s : t10 === "in" ? function(c) {
    return 1 - s(1 - c);
  } : G0(s);
  return a = Ns / a, l.config = function(c, u) {
    return e9(t10, c, u);
  }, l;
};
var Bi = function e10(t10, n) {
  n === void 0 && (n = 1.70158);
  var o = function(a) {
    return a ? --a * a * ((n + 1) * a + n) + 1 : 0;
  }, r = t10 === "out" ? o : t10 === "in" ? function(a) {
    return 1 - o(1 - a);
  } : G0(o);
  return r.config = function(a) {
    return e10(t10, a);
  }, r;
};
Ot("Linear,Quad,Cubic,Quart,Quint,Strong", function(e16, t10) {
  var n = t10 < 5 ? t10 + 1 : t10;
  Eo(e16 + ",Power" + (n - 1), t10 ? function(o) {
    return Math.pow(o, n);
  } : function(o) {
    return o;
  }, function(o) {
    return 1 - Math.pow(1 - o, n);
  }, function(o) {
    return o < 0.5 ? Math.pow(o * 2, n) / 2 : 1 - Math.pow((1 - o) * 2, n) / 2;
  });
});
Oe.Linear.easeNone = Oe.none = Oe.Linear.easeIn;
Eo("Elastic", Oi("in"), Oi("out"), Oi());
(function(e16, t10) {
  var n = 1 / t10, o = 2 * n, r = 2.5 * n, a = function(i) {
    return i < n ? e16 * i * i : i < o ? e16 * Math.pow(i - 1.5 / t10, 2) + 0.75 : i < r ? e16 * (i -= 2.25 / t10) * i + 0.9375 : e16 * Math.pow(i - 2.625 / t10, 2) + 0.984375;
  };
  Eo("Bounce", function(i) {
    return 1 - a(1 - i);
  }, a);
})(7.5625, 2.75);
Eo("Expo", function(e16) {
  return e16 ? Math.pow(2, 10 * (e16 - 1)) : 0;
});
Eo("Circ", function(e16) {
  return -(y0(1 - e16 * e16) - 1);
});
Eo("Sine", function(e16) {
  return e16 === 1 ? 1 : -Kp(e16 * Ap) + 1;
});
Eo("Back", Bi("in"), Bi("out"), Bi());
Oe.SteppedEase = Oe.steps = en.SteppedEase = { config: function(e16, t10) {
  e16 === void 0 && (e16 = 1);
  var n = 1 / e16, o = e16 + (t10 ? 0 : 1), r = t10 ? 1 : 0, a = 1 - at;
  return function(i) {
    return ((o * er(0, a, i) | 0) + r) * n;
  };
} };
ra.ease = Oe["quad.out"];
Ot("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(e16) {
  return Nl += e16 + "," + e16 + "Params,";
});
var X0 = function(e16, t10) {
  this.id = Ep++, e16._gsap = this, this.target = e16, this.harness = t10, this.get = t10 ? t10.get : M0, this.set = t10 ? t10.getSetter : Dl;
};
var Za = function() {
  function e16(n) {
    this.vars = n, this._delay = +n.delay || 0, (this._repeat = n.repeat === 1 / 0 ? -2 : n.repeat || 0) && (this._rDelay = n.repeatDelay || 0, this._yoyo = !!n.yoyo || !!n.yoyoEase), this._ts = 1, sa(this, +n.duration, 1, 1), this.data = n.data, dt && (this._ctx = dt, dt.data.push(this)), Ba || Ut.wake();
  }
  var t10 = e16.prototype;
  return t10.delay = function(n) {
    return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay;
  }, t10.duration = function(n) {
    return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur;
  }, t10.totalDuration = function(n) {
    return arguments.length ? (this._dirty = 0, sa(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur;
  }, t10.totalTime = function(n, o) {
    if (la(), !arguments.length) return this._tTime;
    var r = this._dp;
    if (r && r.smoothChildTiming && this._ts) {
      for (ii(this, n), !r._dp || r.parent || A0(r, this); r && r.parent; ) r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, true), r = r.parent;
      !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && _n(this._dp, this, this._start - this._delay);
    }
    return (this._tTime !== n || !this._dur && !o || this._initted && Math.abs(this._zTime) === at || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), $0(this, n, o)), this;
  }, t10.time = function(n, o) {
    return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + kc(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), o) : this._time;
  }, t10.totalProgress = function(n, o) {
    return arguments.length ? this.totalTime(this.totalDuration() * n, o) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0;
  }, t10.progress = function(n, o) {
    return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + kc(this), o) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
  }, t10.iteration = function(n, o) {
    var r = this.duration() + this._rDelay;
    return arguments.length ? this.totalTime(this._time + (n - 1) * r, o) : this._repeat ? ia(this._tTime, r) + 1 : 1;
  }, t10.timeScale = function(n, o) {
    if (!arguments.length) return this._rts === -at ? 0 : this._rts;
    if (this._rts === n) return this;
    var r = this.parent && this._ts ? zr(this.parent._time, this) : this._tTime;
    return this._rts = +n || 0, this._ts = this._ps || n === -at ? 0 : this._rts, this.totalTime(er(-Math.abs(this._delay), this._tDur, r), o !== false), ri(this), Bp(this);
  }, t10.paused = function(n) {
    return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (la(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== at && (this._tTime -= at)))), this) : this._ps;
  }, t10.startTime = function(n) {
    if (arguments.length) {
      this._start = n;
      var o = this.parent || this._dp;
      return o && (o._sort || !this.parent) && _n(o, this, n - this._delay), this;
    }
    return this._start;
  }, t10.endTime = function(n) {
    return this._start + (jt(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
  }, t10.rawTime = function(n) {
    var o = this.parent || this._dp;
    return o ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? zr(o.rawTime(n), this) : this._tTime : this._tTime;
  }, t10.revert = function(n) {
    n === void 0 && (n = Lp);
    var o = Kt;
    return Kt = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-0.01, n.suppressEvents)), this.data !== "nested" && n.kill !== false && this.kill(), Kt = o, this;
  }, t10.globalTime = function(n) {
    for (var o = this, r = arguments.length ? n : o.rawTime(); o; ) r = o._start + r / (Math.abs(o._ts) || 1), o = o._dp;
    return !this.parent && this._sat ? this._sat.globalTime(n) : r;
  }, t10.repeat = function(n) {
    return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, Sc(this)) : this._repeat === -2 ? 1 / 0 : this._repeat;
  }, t10.repeatDelay = function(n) {
    if (arguments.length) {
      var o = this._time;
      return this._rDelay = n, Sc(this), o ? this.time(o) : this;
    }
    return this._rDelay;
  }, t10.yoyo = function(n) {
    return arguments.length ? (this._yoyo = n, this) : this._yoyo;
  }, t10.seek = function(n, o) {
    return this.totalTime(on2(this, n), jt(o));
  }, t10.restart = function(n, o) {
    return this.play().totalTime(n ? -this._delay : 0, jt(o));
  }, t10.play = function(n, o) {
    return n != null && this.seek(n, o), this.reversed(false).paused(false);
  }, t10.reverse = function(n, o) {
    return n != null && this.seek(n || this.totalDuration(), o), this.reversed(true).paused(false);
  }, t10.pause = function(n, o) {
    return n != null && this.seek(n, o), this.paused(true);
  }, t10.resume = function() {
    return this.paused(false);
  }, t10.reversed = function(n) {
    return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -at : 0)), this) : this._rts < 0;
  }, t10.invalidate = function() {
    return this._initted = this._act = 0, this._zTime = -at, this;
  }, t10.isActive = function() {
    var n = this.parent || this._dp, o = this._start, r;
    return !!(!n || this._ts && this._initted && n.isActive() && (r = n.rawTime(true)) >= o && r < this.endTime(true) - at);
  }, t10.eventCallback = function(n, o, r) {
    var a = this.vars;
    return arguments.length > 1 ? (o ? (a[n] = o, r && (a[n + "Params"] = r), n === "onUpdate" && (this._onUpdate = o)) : delete a[n], this) : a[n];
  }, t10.then = function(n) {
    var o = this;
    return new Promise(function(r) {
      var a = yt(n) ? n : I0, i = function() {
        var s = o.then;
        o.then = null, yt(a) && (a = a(o)) && (a.then || a === o) && (o.then = s), r(a), o.then = s;
      };
      o._initted && o.totalProgress() === 1 && o._ts >= 0 || !o._tTime && o._ts < 0 ? i() : o._prom = i;
    });
  }, t10.kill = function() {
    Da(this);
  }, e16;
}();
sn(Za.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: false, parent: null, _initted: false, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -at, _prom: 0, _ps: false, _rts: 1 });
var Pt = function(e16) {
  v0(t10, e16);
  function t10(o, r) {
    var a;
    return o === void 0 && (o = {}), a = e16.call(this, o) || this, a.labels = {}, a.smoothChildTiming = !!o.smoothChildTiming, a.autoRemoveChildren = !!o.autoRemoveChildren, a._sort = jt(o.sortChildren), mt && _n(o.parent || mt, Dn(a), r), o.reversed && a.reverse(), o.paused && a.paused(true), o.scrollTrigger && E0(Dn(a), o.scrollTrigger), a;
  }
  var n = t10.prototype;
  return n.to = function(o, r, a) {
    return Ka(0, arguments, this), this;
  }, n.from = function(o, r, a) {
    return Ka(1, arguments, this), this;
  }, n.fromTo = function(o, r, a, i) {
    return Ka(2, arguments, this), this;
  }, n.set = function(o, r, a) {
    return r.duration = 0, r.parent = this, Ea(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new Tt(o, r, on2(this, a), 1), this;
  }, n.call = function(o, r, a) {
    return _n(this, Tt.delayedCall(0, o, r), a);
  }, n.staggerTo = function(o, r, a, i, s, l, c) {
    return a.duration = r, a.stagger = a.stagger || i, a.onComplete = l, a.onCompleteParams = c, a.parent = this, new Tt(o, a, on2(this, s)), this;
  }, n.staggerFrom = function(o, r, a, i, s, l, c) {
    return a.runBackwards = 1, Ea(a).immediateRender = jt(a.immediateRender), this.staggerTo(o, r, a, i, s, l, c);
  }, n.staggerFromTo = function(o, r, a, i, s, l, c, u) {
    return i.startAt = a, Ea(i).immediateRender = jt(i.immediateRender), this.staggerTo(o, r, i, s, l, c, u);
  }, n.render = function(o, r, a) {
    var i = this._time, s = this._dirty ? this.totalDuration() : this._tDur, l = this._dur, c = o <= 0 ? 0 : $t(o), u = this._zTime < 0 != o < 0 && (this._initted || !l), d, m, p, f, h10, g, v, y, k, T, w, _;
    if (this !== mt && c > s && o >= 0 && (c = s), c !== this._tTime || a || u) {
      if (i !== this._time && l && (c += this._time - i, o += this._time - i), d = c, k = this._start, y = this._ts, g = !y, u && (l || (i = this._zTime), (o || !r) && (this._zTime = o)), this._repeat) {
        if (w = this._yoyo, h10 = l + this._rDelay, this._repeat < -1 && o < 0) return this.totalTime(h10 * 100 + o, r, a);
        if (d = $t(c % h10), c === s ? (f = this._repeat, d = l) : (f = ~~(c / h10), f && f === c / h10 && (d = l, f--), d > l && (d = l)), T = ia(this._tTime, h10), !i && this._tTime && T !== f && this._tTime - T * h10 - this._dur <= 0 && (T = f), w && f & 1 && (d = l - d, _ = 1), f !== T && !this._lock) {
          var M = w && T & 1, x = M === (w && f & 1);
          if (f < T && (M = !M), i = M ? 0 : c % l ? l : c, this._lock = 1, this.render(i || (_ ? 0 : $t(f * h10)), r, !l)._lock = 0, this._tTime = c, !r && this.parent && Yt(this, "onRepeat"), this.vars.repeatRefresh && !_ && (this.invalidate()._lock = 1), i && i !== this._time || g !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
          if (l = this._dur, s = this._tDur, x && (this._lock = 2, i = M ? l : -1e-4, this.render(i, true), this.vars.repeatRefresh && !_ && this.invalidate()), this._lock = 0, !this._ts && !g) return this;
          U0(this, _);
        }
      }
      if (this._hasPause && !this._forcing && this._lock < 2 && (v = Vp(this, $t(i), $t(d)), v && (c -= d - (d = v._start))), this._tTime = c, this._time = d, this._act = !y, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = o, i = 0), !i && d && !r && !f && (Yt(this, "onStart"), this._tTime !== c)) return this;
      if (d >= i && o >= 0) for (m = this._first; m; ) {
        if (p = m._next, (m._act || d >= m._start) && m._ts && v !== m) {
          if (m.parent !== this) return this.render(o, r, a);
          if (m.render(m._ts > 0 ? (d - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (d - m._start) * m._ts, r, a), d !== this._time || !this._ts && !g) {
            v = 0, p && (c += this._zTime = -at);
            break;
          }
        }
        m = p;
      }
      else {
        m = this._last;
        for (var R = o < 0 ? o : d; m; ) {
          if (p = m._prev, (m._act || R <= m._end) && m._ts && v !== m) {
            if (m.parent !== this) return this.render(o, r, a);
            if (m.render(m._ts > 0 ? (R - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (R - m._start) * m._ts, r, a || Kt && (m._initted || m._startAt)), d !== this._time || !this._ts && !g) {
              v = 0, p && (c += this._zTime = R ? -at : at);
              break;
            }
          }
          m = p;
        }
      }
      if (v && !r && (this.pause(), v.render(d >= i ? 0 : -at)._zTime = d >= i ? 1 : -1, this._ts)) return this._start = k, ri(this), this.render(o, r, a);
      this._onUpdate && !r && Yt(this, "onUpdate", true), (c === s && this._tTime >= this.totalDuration() || !c && i) && (k === this._start || Math.abs(y) !== Math.abs(this._ts)) && (this._lock || ((o || !l) && (c === s && this._ts > 0 || !c && this._ts < 0) && Jn(this, 1), !r && !(o < 0 && !i) && (c || i || !s) && (Yt(this, c === s && o >= 0 ? "onComplete" : "onReverseComplete", true), this._prom && !(c < s && this.timeScale() > 0) && this._prom())));
    }
    return this;
  }, n.add = function(o, r) {
    var a = this;
    if (Pn(r) || (r = on2(this, r, o)), !(o instanceof Za)) {
      if (zt(o)) return o.forEach(function(i) {
        return a.add(i, r);
      }), this;
      if (It(o)) return this.addLabel(o, r);
      if (yt(o)) o = Tt.delayedCall(0, o);
      else return this;
    }
    return this !== o ? _n(this, o, r) : this;
  }, n.getChildren = function(o, r, a, i) {
    o === void 0 && (o = true), r === void 0 && (r = true), a === void 0 && (a = true), i === void 0 && (i = -an);
    for (var s = [], l = this._first; l; ) l._start >= i && (l instanceof Tt ? r && s.push(l) : (a && s.push(l), o && s.push.apply(s, l.getChildren(true, r, a)))), l = l._next;
    return s;
  }, n.getById = function(o) {
    for (var r = this.getChildren(1, 1, 1), a = r.length; a--; ) if (r[a].vars.id === o) return r[a];
  }, n.remove = function(o) {
    return It(o) ? this.removeLabel(o) : yt(o) ? this.killTweensOf(o) : (ai(this, o), o === this._recent && (this._recent = this._last), wo(this));
  }, n.totalTime = function(o, r) {
    return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = $t(Ut.time - (this._ts > 0 ? o / this._ts : (this.totalDuration() - o) / -this._ts))), e16.prototype.totalTime.call(this, o, r), this._forcing = 0, this) : this._tTime;
  }, n.addLabel = function(o, r) {
    return this.labels[o] = on2(this, r), this;
  }, n.removeLabel = function(o) {
    return delete this.labels[o], this;
  }, n.addPause = function(o, r, a) {
    var i = Tt.delayedCall(0, r || ja, a);
    return i.data = "isPause", this._hasPause = 1, _n(this, i, on2(this, o));
  }, n.removePause = function(o) {
    var r = this._first;
    for (o = on2(this, o); r; ) r._start === o && r.data === "isPause" && Jn(r), r = r._next;
  }, n.killTweensOf = function(o, r, a) {
    for (var i = this.getTweensOf(o, a), s = i.length; s--; ) Vn !== i[s] && i[s].kill(o, r);
    return this;
  }, n.getTweensOf = function(o, r) {
    for (var a = [], i = rn(o), s = this._first, l = Pn(r), c; s; ) s instanceof Tt ? Fp(s._targets, i) && (l ? (!Vn || s._initted && s._ts) && s.globalTime(0) <= r && s.globalTime(s.totalDuration()) > r : !r || s.isActive()) && a.push(s) : (c = s.getTweensOf(i, r)).length && a.push.apply(a, c), s = s._next;
    return a;
  }, n.tweenTo = function(o, r) {
    r = r || {};
    var a = this, i = on2(a, o), s = r, l = s.startAt, c = s.onStart, u = s.onStartParams, d = s.immediateRender, m, p = Tt.to(a, sn({ ease: r.ease || "none", lazy: false, immediateRender: false, time: i, overwrite: "auto", duration: r.duration || Math.abs((i - (l && "time" in l ? l.time : a._time)) / a.timeScale()) || at, onStart: function() {
      if (a.pause(), !m) {
        var f = r.duration || Math.abs((i - (l && "time" in l ? l.time : a._time)) / a.timeScale());
        p._dur !== f && sa(p, f, 0, 1).render(p._time, true, true), m = 1;
      }
      c && c.apply(p, u || []);
    } }, r));
    return d ? p.render(0) : p;
  }, n.tweenFromTo = function(o, r, a) {
    return this.tweenTo(r, sn({ startAt: { time: on2(this, o) } }, a));
  }, n.recent = function() {
    return this._recent;
  }, n.nextLabel = function(o) {
    return o === void 0 && (o = this._time), Nc(this, on2(this, o));
  }, n.previousLabel = function(o) {
    return o === void 0 && (o = this._time), Nc(this, on2(this, o), 1);
  }, n.currentLabel = function(o) {
    return arguments.length ? this.seek(o, true) : this.previousLabel(this._time + at);
  }, n.shiftChildren = function(o, r, a) {
    a === void 0 && (a = 0);
    for (var i = this._first, s = this.labels, l; i; ) i._start >= a && (i._start += o, i._end += o), i = i._next;
    if (r) for (l in s) s[l] >= a && (s[l] += o);
    return wo(this);
  }, n.invalidate = function(o) {
    var r = this._first;
    for (this._lock = 0; r; ) r.invalidate(o), r = r._next;
    return e16.prototype.invalidate.call(this, o);
  }, n.clear = function(o) {
    o === void 0 && (o = true);
    for (var r = this._first, a; r; ) a = r._next, this.remove(r), r = a;
    return this._dp && (this._time = this._tTime = this._pTime = 0), o && (this.labels = {}), wo(this);
  }, n.totalDuration = function(o) {
    var r = 0, a = this, i = a._last, s = an, l, c, u;
    if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -o : o));
    if (a._dirty) {
      for (u = a.parent; i; ) l = i._prev, i._dirty && i.totalDuration(), c = i._start, c > s && a._sort && i._ts && !a._lock ? (a._lock = 1, _n(a, i, c - i._delay, 1)._lock = 0) : s = c, c < 0 && i._ts && (r -= c, (!u && !a._dp || u && u.smoothChildTiming) && (a._start += c / a._ts, a._time -= c, a._tTime -= c), a.shiftChildren(-c, false, -1 / 0), s = 0), i._end > r && i._ts && (r = i._end), i = l;
      sa(a, a === mt && a._time > r ? a._time : r, 1, 1), a._dirty = 0;
    }
    return a._tDur;
  }, t10.updateRoot = function(o) {
    if (mt._ts && ($0(mt, zr(o, mt)), N0 = Ut.frame), Ut.frame >= Tc) {
      Tc += Qt.autoSleep || 120;
      var r = mt._first;
      if ((!r || !r._ts) && Qt.autoSleep && Ut._listeners.length < 2) {
        for (; r && !r._ts; ) r = r._next;
        r || Ut.sleep();
      }
    }
  }, t10;
}(Za);
sn(Pt.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var lh = function(e16, t10, n, o, r, a, i) {
  var s = new Bt(this._pt, e16, t10, 0, 1, nd, null, r), l = 0, c = 0, u, d, m, p, f, h10, g, v;
  for (s.b = n, s.e = o, n += "", o += "", (g = ~o.indexOf("random(")) && (o = Oa(o)), a && (v = [n, o], a(v, e16, t10), n = v[0], o = v[1]), d = n.match(Li) || []; u = Li.exec(o); ) p = u[0], f = o.substring(l, u.index), m ? m = (m + 1) % 5 : f.substr(-5) === "rgba(" && (m = 1), p !== d[c++] && (h10 = parseFloat(d[c - 1]) || 0, s._pt = { _next: s._pt, p: f || c === 1 ? f : ",", s: h10, c: p.charAt(1) === "=" ? Qo(h10, p) - h10 : parseFloat(p) - h10, m: m && m < 4 ? Math.round : 0 }, l = Li.lastIndex);
  return s.c = l < o.length ? o.substring(l, o.length) : "", s.fp = i, (w0.test(o) || g) && (s.e = 0), this._pt = s, s;
};
var $l = function(e16, t10, n, o, r, a, i, s, l, c) {
  yt(o) && (o = o(r || 0, e16, a));
  var u = e16[t10], d = n !== "get" ? n : yt(u) ? l ? e16[t10.indexOf("set") || !yt(e16["get" + t10.substr(3)]) ? t10 : "get" + t10.substr(3)](l) : e16[t10]() : u, m = yt(u) ? l ? mh : ed : Il, p;
  if (It(o) && (~o.indexOf("random(") && (o = Oa(o)), o.charAt(1) === "=" && (p = Qo(d, o) + (Et(d) || 0), (p || p === 0) && (o = p))), !c || d !== o || zs) return !isNaN(d * o) && o !== "" ? (p = new Bt(this._pt, e16, t10, +d || 0, o - (d || 0), typeof u == "boolean" ? hh : td, 0, m), l && (p.fp = l), i && p.modifier(i, this, e16), this._pt = p) : (!u && !(t10 in e16) && kl(t10, o), lh.call(this, e16, t10, d, o, m, s || Qt.stringFilter, l));
};
var ch = function(e16, t10, n, o, r) {
  if (yt(e16) && (e16 = za(e16, r, t10, n, o)), !$n(e16) || e16.style && e16.nodeType || zt(e16) || b0(e16)) return It(e16) ? za(e16, r, t10, n, o) : e16;
  var a = {}, i;
  for (i in e16) a[i] = za(e16[i], r, t10, n, o);
  return a;
};
var Y0 = function(e16, t10, n, o, r, a) {
  var i, s, l, c;
  if (Ht[e16] && (i = new Ht[e16]()).init(r, i.rawVars ? t10[e16] : ch(t10[e16], o, r, a, n), n, o, a) !== false && (n._pt = s = new Bt(n._pt, r, e16, 0, 1, i.render, i, 0, i.priority), n !== Uo)) for (l = n._ptLookup[n._targets.indexOf(r)], c = i._props.length; c--; ) l[i._props[c]] = s;
  return i;
};
var Vn;
var zs;
var xl = function e11(t10, n, o) {
  var r = t10.vars, a = r.ease, i = r.startAt, s = r.immediateRender, l = r.lazy, c = r.onUpdate, u = r.runBackwards, d = r.yoyoEase, m = r.keyframes, p = r.autoRevert, f = t10._dur, h10 = t10._startAt, g = t10._targets, v = t10.parent, y = v && v.data === "nested" ? v.vars.targets : g, k = t10._overwrite === "auto" && !_l, T = t10.timeline, w, _, M, x, R, I, P, F, N, j, z, A, B;
  if (T && (!m || !a) && (a = "none"), t10._ease = To(a, ra.ease), t10._yEase = d ? H0(To(d === true ? a : d, ra.ease)) : 0, d && t10._yoyo && !t10._repeat && (d = t10._yEase, t10._yEase = t10._ease, t10._ease = d), t10._from = !T && !!r.runBackwards, !T || m && !r.stagger) {
    if (F = g[0] ? _o(g[0]).harness : 0, A = F && r[F.prop], w = Kr(r, Sl), h10 && (h10._zTime < 0 && h10.progress(1), n < 0 && u && s && !p ? h10.render(-1, true) : h10.revert(u && f ? wr : Rp), h10._lazy = 0), i) {
      if (Jn(t10._startAt = Tt.set(g, sn({ data: "isStart", overwrite: false, parent: v, immediateRender: true, lazy: !h10 && jt(l), startAt: null, delay: 0, onUpdate: c && function() {
        return Yt(t10, "onUpdate");
      }, stagger: 0 }, i))), t10._startAt._dp = 0, t10._startAt._sat = t10, n < 0 && (Kt || !s && !p) && t10._startAt.revert(wr), s && f && n <= 0 && o <= 0) {
        n && (t10._zTime = n);
        return;
      }
    } else if (u && f && !h10) {
      if (n && (s = false), M = sn({ overwrite: false, data: "isFromStart", lazy: s && !h10 && jt(l), immediateRender: s, stagger: 0, parent: v }, w), A && (M[F.prop] = A), Jn(t10._startAt = Tt.set(g, M)), t10._startAt._dp = 0, t10._startAt._sat = t10, n < 0 && (Kt ? t10._startAt.revert(wr) : t10._startAt.render(-1, true)), t10._zTime = n, !s) e11(t10._startAt, at, at);
      else if (!n) return;
    }
    for (t10._pt = t10._ptCache = 0, l = f && jt(l) || l && !f, _ = 0; _ < g.length; _++) {
      if (R = g[_], P = R._gsap || Ml(g)[_]._gsap, t10._ptLookup[_] = j = {}, xs[P.id] && Gn.length && Er(), z = y === g ? _ : y.indexOf(R), F && (N = new F()).init(R, A || w, t10, z, y) !== false && (t10._pt = x = new Bt(t10._pt, R, N.name, 0, 1, N.render, N, 0, N.priority), N._props.forEach(function(D) {
        j[D] = x;
      }), N.priority && (I = 1)), !F || A) for (M in w) Ht[M] && (N = Y0(M, w, t10, z, R, y)) ? N.priority && (I = 1) : j[M] = x = $l.call(t10, R, M, "get", w[M], z, y, 0, r.stringFilter);
      t10._op && t10._op[_] && t10.kill(R, t10._op[_]), k && t10._pt && (Vn = t10, mt.killTweensOf(R, j, t10.globalTime(n)), B = !t10.parent, Vn = 0), t10._pt && l && (xs[P.id] = 1);
    }
    I && od(t10), t10._onInit && t10._onInit(t10);
  }
  t10._onUpdate = c, t10._initted = (!t10._op || t10._pt) && !B, m && n <= 0 && T.render(an, true, true);
};
var uh = function(e16, t10, n, o, r, a, i, s) {
  var l = (e16._pt && e16._ptCache || (e16._ptCache = {}))[t10], c, u, d, m;
  if (!l) for (l = e16._ptCache[t10] = [], d = e16._ptLookup, m = e16._targets.length; m--; ) {
    if (c = d[m][t10], c && c.d && c.d._pt) for (c = c.d._pt; c && c.p !== t10 && c.fp !== t10; ) c = c._next;
    if (!c) return zs = 1, e16.vars[t10] = "+=0", xl(e16, i), zs = 0, s ? Fa(t10 + " not eligible for reset") : 1;
    l.push(c);
  }
  for (m = l.length; m--; ) u = l[m], c = u._pt || u, c.s = (o || o === 0) && !r ? o : c.s + (o || 0) + a * c.c, c.c = n - c.s, u.e && (u.e = _t2(n) + Et(u.e)), u.b && (u.b = c.s + Et(u.b));
};
var dh = function(e16, t10) {
  var n = e16[0] ? _o(e16[0]).harness : 0, o = n && n.aliases, r, a, i, s;
  if (!o) return t10;
  r = Mo({}, t10);
  for (a in o) if (a in r) for (s = o[a].split(","), i = s.length; i--; ) r[s[i]] = r[a];
  return r;
};
var fh = function(e16, t10, n, o) {
  var r = t10.ease || o || "power1.inOut", a, i;
  if (zt(t10)) i = n[e16] || (n[e16] = []), t10.forEach(function(s, l) {
    return i.push({ t: l / (t10.length - 1) * 100, v: s, e: r });
  });
  else for (a in t10) i = n[a] || (n[a] = []), a === "ease" || i.push({ t: parseFloat(e16), v: t10[a], e: r });
};
var za = function(e16, t10, n, o, r) {
  return yt(e16) ? e16.call(t10, n, o, r) : It(e16) && ~e16.indexOf("random(") ? Oa(e16) : e16;
};
var Q0 = Nl + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
var J0 = {};
Ot(Q0 + ",id,stagger,delay,duration,paused,scrollTrigger", function(e16) {
  return J0[e16] = 1;
});
var Tt = function(e16) {
  v0(t10, e16);
  function t10(o, r, a, i) {
    var s;
    typeof r == "number" && (a.duration = r, r = a, a = null), s = e16.call(this, i ? r : Ea(r)) || this;
    var l = s.vars, c = l.duration, u = l.delay, d = l.immediateRender, m = l.stagger, p = l.overwrite, f = l.keyframes, h10 = l.defaults, g = l.scrollTrigger, v = l.yoyoEase, y = r.parent || mt, k = (zt(o) || b0(o) ? Pn(o[0]) : "length" in r) ? [o] : rn(o), T, w, _, M, x, R, I, P;
    if (s._targets = k.length ? Ml(k) : Fa("GSAP target " + o + " not found. https://gsap.com", !Qt.nullTargetWarn) || [], s._ptLookup = [], s._overwrite = p, f || m || pr(c) || pr(u)) {
      if (r = s.vars, T = s.timeline = new Pt({ data: "nested", defaults: h10 || {}, targets: y && y.data === "nested" ? y.vars.targets : k }), T.kill(), T.parent = T._dp = Dn(s), T._start = 0, m || pr(c) || pr(u)) {
        if (M = k.length, I = m && R0(m), $n(m)) for (x in m) ~Q0.indexOf(x) && (P || (P = {}), P[x] = m[x]);
        for (w = 0; w < M; w++) _ = Kr(r, J0), _.stagger = 0, v && (_.yoyoEase = v), P && Mo(_, P), R = k[w], _.duration = +za(c, Dn(s), w, R, k), _.delay = (+za(u, Dn(s), w, R, k) || 0) - s._delay, !m && M === 1 && _.delay && (s._delay = u = _.delay, s._start += u, _.delay = 0), T.to(R, _, I ? I(w, R, k) : 0), T._ease = Oe.none;
        T.duration() ? c = u = 0 : s.timeline = 0;
      } else if (f) {
        Ea(sn(T.vars.defaults, { ease: "none" })), T._ease = To(f.ease || r.ease || "none");
        var F = 0, N, j, z;
        if (zt(f)) f.forEach(function(A) {
          return T.to(k, A, ">");
        }), T.duration();
        else {
          _ = {};
          for (x in f) x === "ease" || x === "easeEach" || fh(x, f[x], _, f.easeEach);
          for (x in _) for (N = _[x].sort(function(A, B) {
            return A.t - B.t;
          }), F = 0, w = 0; w < N.length; w++) j = N[w], z = { ease: j.e, duration: (j.t - (w ? N[w - 1].t : 0)) / 100 * c }, z[x] = j.v, T.to(k, z, F), F += z.duration;
          T.duration() < c && T.to({}, { duration: c - T.duration() });
        }
      }
      c || s.duration(c = T.duration());
    } else s.timeline = 0;
    return p === true && !_l && (Vn = Dn(s), mt.killTweensOf(k), Vn = 0), _n(y, Dn(s), a), r.reversed && s.reverse(), r.paused && s.paused(true), (d || !c && !f && s._start === $t(y._time) && jt(d) && Zp(Dn(s)) && y.data !== "nested") && (s._tTime = -at, s.render(Math.max(0, -u) || 0)), g && E0(Dn(s), g), s;
  }
  var n = t10.prototype;
  return n.render = function(o, r, a) {
    var i = this._time, s = this._tDur, l = this._dur, c = o < 0, u = o > s - at && !c ? s : o < at ? 0 : o, d, m, p, f, h10, g, v, y, k;
    if (!l) qp(this, o, r, a);
    else if (u !== this._tTime || !o || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== c) {
      if (d = u, y = this.timeline, this._repeat) {
        if (f = l + this._rDelay, this._repeat < -1 && c) return this.totalTime(f * 100 + o, r, a);
        if (d = $t(u % f), u === s ? (p = this._repeat, d = l) : (p = ~~(u / f), p && p === $t(u / f) && (d = l, p--), d > l && (d = l)), g = this._yoyo && p & 1, g && (k = this._yEase, d = l - d), h10 = ia(this._tTime, f), d === i && !a && this._initted && p === h10) return this._tTime = u, this;
        p !== h10 && (y && this._yEase && U0(y, g), this.vars.repeatRefresh && !g && !this._lock && this._time !== f && this._initted && (this._lock = a = 1, this.render($t(f * p), true).invalidate()._lock = 0));
      }
      if (!this._initted) {
        if (K0(this, c ? o : d, a, r, u)) return this._tTime = 0, this;
        if (i !== this._time && !(a && this.vars.repeatRefresh && p !== h10)) return this;
        if (l !== this._dur) return this.render(o, r, a);
      }
      if (this._tTime = u, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = v = (k || this._ease)(d / l), this._from && (this.ratio = v = 1 - v), d && !i && !r && !p && (Yt(this, "onStart"), this._tTime !== u)) return this;
      for (m = this._pt; m; ) m.r(v, m.d), m = m._next;
      y && y.render(o < 0 ? o : y._dur * y._ease(d / this._dur), r, a) || this._startAt && (this._zTime = o), this._onUpdate && !r && (c && Is(this, o, r, a), Yt(this, "onUpdate")), this._repeat && p !== h10 && this.vars.onRepeat && !r && this.parent && Yt(this, "onRepeat"), (u === this._tDur || !u) && this._tTime === u && (c && !this._onUpdate && Is(this, o, true, true), (o || !l) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && Jn(this, 1), !r && !(c && !i) && (u || i || g) && (Yt(this, u === s ? "onComplete" : "onReverseComplete", true), this._prom && !(u < s && this.timeScale() > 0) && this._prom()));
    }
    return this;
  }, n.targets = function() {
    return this._targets;
  }, n.invalidate = function(o) {
    return (!o || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(o), e16.prototype.invalidate.call(this, o);
  }, n.resetTo = function(o, r, a, i, s) {
    Ba || Ut.wake(), this._ts || this.play();
    var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts), c;
    return this._initted || xl(this, l), c = this._ease(l / this._dur), uh(this, o, r, a, i, c, l, s) ? this.resetTo(o, r, a, i, 1) : (ii(this, 0), this.parent || D0(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0));
  }, n.kill = function(o, r) {
    if (r === void 0 && (r = "all"), !o && (!r || r === "all")) return this._lazy = this._pt = 0, this.parent ? Da(this) : this;
    if (this.timeline) {
      var a = this.timeline.totalDuration();
      return this.timeline.killTweensOf(o, r, Vn && Vn.vars.overwrite !== true)._first || Da(this), this.parent && a !== this.timeline.totalDuration() && sa(this, this._dur * this.timeline._tDur / a, 0, 1), this;
    }
    var i = this._targets, s = o ? rn(o) : i, l = this._ptLookup, c = this._pt, u, d, m, p, f, h10, g;
    if ((!r || r === "all") && Op(i, s)) return r === "all" && (this._pt = 0), Da(this);
    for (u = this._op = this._op || [], r !== "all" && (It(r) && (f = {}, Ot(r, function(v) {
      return f[v] = 1;
    }), r = f), r = dh(i, r)), g = i.length; g--; ) if (~s.indexOf(i[g])) {
      d = l[g], r === "all" ? (u[g] = r, p = d, m = {}) : (m = u[g] = u[g] || {}, p = r);
      for (f in p) h10 = d && d[f], h10 && ((!("kill" in h10.d) || h10.d.kill(f) === true) && ai(this, h10, "_pt"), delete d[f]), m !== "all" && (m[f] = 1);
    }
    return this._initted && !this._pt && c && Da(this), this;
  }, t10.to = function(o, r) {
    return new t10(o, r, arguments[2]);
  }, t10.from = function(o, r) {
    return Ka(1, arguments);
  }, t10.delayedCall = function(o, r, a, i) {
    return new t10(r, 0, { immediateRender: false, lazy: false, overwrite: false, delay: o, onComplete: r, onReverseComplete: r, onCompleteParams: a, onReverseCompleteParams: a, callbackScope: i });
  }, t10.fromTo = function(o, r, a) {
    return Ka(2, arguments);
  }, t10.set = function(o, r) {
    return r.duration = 0, r.repeatDelay || (r.repeat = 0), new t10(o, r);
  }, t10.killTweensOf = function(o, r, a) {
    return mt.killTweensOf(o, r, a);
  }, t10;
}(Za);
sn(Tt.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
Ot("staggerTo,staggerFrom,staggerFromTo", function(e16) {
  Tt[e16] = function() {
    var t10 = new Pt(), n = As.call(arguments, 0);
    return n.splice(e16 === "staggerFromTo" ? 5 : 4, 0, 0), t10[e16].apply(t10, n);
  };
});
var Il = function(e16, t10, n) {
  return e16[t10] = n;
};
var ed = function(e16, t10, n) {
  return e16[t10](n);
};
var mh = function(e16, t10, n, o) {
  return e16[t10](o.fp, n);
};
var ph = function(e16, t10, n) {
  return e16.setAttribute(t10, n);
};
var Dl = function(e16, t10) {
  return yt(e16[t10]) ? ed : wl(e16[t10]) && e16.setAttribute ? ph : Il;
};
var td = function(e16, t10) {
  return t10.set(t10.t, t10.p, Math.round((t10.s + t10.c * e16) * 1e6) / 1e6, t10);
};
var hh = function(e16, t10) {
  return t10.set(t10.t, t10.p, !!(t10.s + t10.c * e16), t10);
};
var nd = function(e16, t10) {
  var n = t10._pt, o = "";
  if (!e16 && t10.b) o = t10.b;
  else if (e16 === 1 && t10.e) o = t10.e;
  else {
    for (; n; ) o = n.p + (n.m ? n.m(n.s + n.c * e16) : Math.round((n.s + n.c * e16) * 1e4) / 1e4) + o, n = n._next;
    o += t10.c;
  }
  t10.set(t10.t, t10.p, o, t10);
};
var Al = function(e16, t10) {
  for (var n = t10._pt; n; ) n.r(e16, n.d), n = n._next;
};
var gh = function(e16, t10, n, o) {
  for (var r = this._pt, a; r; ) a = r._next, r.p === o && r.modifier(e16, t10, n), r = a;
};
var vh = function(e16) {
  for (var t10 = this._pt, n, o; t10; ) o = t10._next, t10.p === e16 && !t10.op || t10.op === e16 ? ai(this, t10, "_pt") : t10.dep || (n = 1), t10 = o;
  return !n;
};
var yh = function(e16, t10, n, o) {
  o.mSet(e16, t10, o.m.call(o.tween, n, o.mt), o);
};
var od = function(e16) {
  for (var t10 = e16._pt, n, o, r, a; t10; ) {
    for (n = t10._next, o = r; o && o.pr > t10.pr; ) o = o._next;
    (t10._prev = o ? o._prev : a) ? t10._prev._next = t10 : r = t10, (t10._next = o) ? o._prev = t10 : a = t10, t10 = n;
  }
  e16._pt = r;
};
var Bt = function() {
  function e16(n, o, r, a, i, s, l, c, u) {
    this.t = o, this.s = a, this.c = i, this.p = r, this.r = s || td, this.d = l || this, this.set = c || Il, this.pr = u || 0, this._next = n, n && (n._prev = this);
  }
  var t10 = e16.prototype;
  return t10.modifier = function(n, o, r) {
    this.mSet = this.mSet || this.set, this.set = yh, this.m = n, this.mt = r, this.tween = o;
  }, e16;
}();
Ot(Nl + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(e16) {
  return Sl[e16] = 1;
});
en.TweenMax = en.TweenLite = Tt;
en.TimelineLite = en.TimelineMax = Pt;
mt = new Pt({ sortChildren: false, defaults: ra, autoRemoveChildren: true, id: "root", smoothChildTiming: true });
Qt.stringFilter = V0;
var Co = [];
var Cr = {};
var bh = [];
var $c = 0;
var _h = 0;
var Zi = function(e16) {
  return (Cr[e16] || bh).map(function(t10) {
    return t10();
  });
};
var Ps = function() {
  var e16 = Date.now(), t10 = [];
  e16 - $c > 2 && (Zi("matchMediaInit"), Co.forEach(function(n) {
    var o = n.queries, r = n.conditions, a, i, s, l;
    for (i in o) a = yn.matchMedia(o[i]).matches, a && (s = 1), a !== r[i] && (r[i] = a, l = 1);
    l && (n.revert(), s && t10.push(n));
  }), Zi("matchMediaRevert"), t10.forEach(function(n) {
    return n.onMatch(n, function(o) {
      return n.add(null, o);
    });
  }), $c = e16, Zi("matchMedia"));
};
var ad = function() {
  function e16(n, o) {
    this.selector = o && Es(o), this.data = [], this._r = [], this.isReverted = false, this.id = _h++, n && this.add(n);
  }
  var t10 = e16.prototype;
  return t10.add = function(n, o, r) {
    yt(n) && (r = o, o = n, n = yt);
    var a = this, i = function() {
      var s = dt, l = a.selector, c;
      return s && s !== a && s.data.push(a), r && (a.selector = Es(r)), dt = a, c = o.apply(a, arguments), yt(c) && a._r.push(c), dt = s, a.selector = l, a.isReverted = false, c;
    };
    return a.last = i, n === yt ? i(a, function(s) {
      return a.add(null, s);
    }) : n ? a[n] = i : i;
  }, t10.ignore = function(n) {
    var o = dt;
    dt = null, n(this), dt = o;
  }, t10.getTweens = function() {
    var n = [];
    return this.data.forEach(function(o) {
      return o instanceof e16 ? n.push.apply(n, o.getTweens()) : o instanceof Tt && !(o.parent && o.parent.data === "nested") && n.push(o);
    }), n;
  }, t10.clear = function() {
    this._r.length = this.data.length = 0;
  }, t10.kill = function(n, o) {
    var r = this;
    if (n ? function() {
      for (var i = r.getTweens(), s = r.data.length, l; s--; ) l = r.data[s], l.data === "isFlip" && (l.revert(), l.getChildren(true, true, false).forEach(function(c) {
        return i.splice(i.indexOf(c), 1);
      }));
      for (i.map(function(c) {
        return { g: c._dur || c._delay || c._sat && !c._sat.vars.immediateRender ? c.globalTime(0) : -1 / 0, t: c };
      }).sort(function(c, u) {
        return u.g - c.g || -1 / 0;
      }).forEach(function(c) {
        return c.t.revert(n);
      }), s = r.data.length; s--; ) l = r.data[s], l instanceof Pt ? l.data !== "nested" && (l.scrollTrigger && l.scrollTrigger.revert(), l.kill()) : !(l instanceof Tt) && l.revert && l.revert(n);
      r._r.forEach(function(c) {
        return c(n, r);
      }), r.isReverted = true;
    }() : this.data.forEach(function(i) {
      return i.kill && i.kill();
    }), this.clear(), o) for (var a = Co.length; a--; ) Co[a].id === this.id && Co.splice(a, 1);
  }, t10.revert = function(n) {
    this.kill(n || {});
  }, e16;
}();
var wh = function() {
  function e16(n) {
    this.contexts = [], this.scope = n, dt && dt.data.push(this);
  }
  var t10 = e16.prototype;
  return t10.add = function(n, o, r) {
    $n(n) || (n = { matches: n });
    var a = new ad(0, r || this.scope), i = a.conditions = {}, s, l, c;
    dt && !a.selector && (a.selector = dt.selector), this.contexts.push(a), o = a.add("onMatch", o), a.queries = n;
    for (l in n) l === "all" ? c = 1 : (s = yn.matchMedia(n[l]), s && (Co.indexOf(a) < 0 && Co.push(a), (i[l] = s.matches) && (c = 1), s.addListener ? s.addListener(Ps) : s.addEventListener("change", Ps)));
    return c && o(a, function(u) {
      return a.add(null, u);
    }), this;
  }, t10.revert = function(n) {
    this.kill(n || {});
  }, t10.kill = function(n) {
    this.contexts.forEach(function(o) {
      return o.kill(n, true);
    });
  }, e16;
}();
var Pr = { registerPlugin: function() {
  for (var e16 = arguments.length, t10 = new Array(e16), n = 0; n < e16; n++) t10[n] = arguments[n];
  t10.forEach(function(o) {
    return Z0(o);
  });
}, timeline: function(e16) {
  return new Pt(e16);
}, getTweensOf: function(e16, t10) {
  return mt.getTweensOf(e16, t10);
}, getProperty: function(e16, t10, n, o) {
  It(e16) && (e16 = rn(e16)[0]);
  var r = _o(e16 || {}).get, a = n ? I0 : x0;
  return n === "native" && (n = ""), e16 && (t10 ? a((Ht[t10] && Ht[t10].get || r)(e16, t10, n, o)) : function(i, s, l) {
    return a((Ht[i] && Ht[i].get || r)(e16, i, s, l));
  });
}, quickSetter: function(e16, t10, n) {
  if (e16 = rn(e16), e16.length > 1) {
    var o = e16.map(function(c) {
      return Wt.quickSetter(c, t10, n);
    }), r = o.length;
    return function(c) {
      for (var u = r; u--; ) o[u](c);
    };
  }
  e16 = e16[0] || {};
  var a = Ht[t10], i = _o(e16), s = i.harness && (i.harness.aliases || {})[t10] || t10, l = a ? function(c) {
    var u = new a();
    Uo._pt = 0, u.init(e16, n ? c + n : c, Uo, 0, [e16]), u.render(1, u), Uo._pt && Al(1, Uo);
  } : i.set(e16, s);
  return a ? l : function(c) {
    return l(e16, s, n ? c + n : c, i, 1);
  };
}, quickTo: function(e16, t10, n) {
  var o, r = Wt.to(e16, Mo((o = {}, o[t10] = "+=0.1", o.paused = true, o), n || {})), a = function(i, s, l) {
    return r.resetTo(t10, i, s, l);
  };
  return a.tween = r, a;
}, isTweening: function(e16) {
  return mt.getTweensOf(e16, true).length > 0;
}, defaults: function(e16) {
  return e16 && e16.ease && (e16.ease = To(e16.ease, ra.ease)), Cc(ra, e16 || {});
}, config: function(e16) {
  return Cc(Qt, e16 || {});
}, registerEffect: function(e16) {
  var t10 = e16.name, n = e16.effect, o = e16.plugins, r = e16.defaults, a = e16.extendTimeline;
  (o || "").split(",").forEach(function(i) {
    return i && !Ht[i] && !en[i] && Fa(t10 + " effect requires " + i + " plugin.");
  }), Fi[t10] = function(i, s, l) {
    return n(rn(i), sn(s || {}, r), l);
  }, a && (Pt.prototype[t10] = function(i, s, l) {
    return this.add(Fi[t10](i, $n(s) ? s : (l = s) && {}, this), l);
  });
}, registerEase: function(e16, t10) {
  Oe[e16] = To(t10);
}, parseEase: function(e16, t10) {
  return arguments.length ? To(e16, t10) : Oe;
}, getById: function(e16) {
  return mt.getById(e16);
}, exportRoot: function(e16, t10) {
  e16 === void 0 && (e16 = {});
  var n = new Pt(e16), o, r;
  for (n.smoothChildTiming = jt(e16.smoothChildTiming), mt.remove(n), n._dp = 0, n._time = n._tTime = mt._time, o = mt._first; o; ) r = o._next, (t10 || !(!o._dur && o instanceof Tt && o.vars.onComplete === o._targets[0])) && _n(n, o, o._start - o._delay), o = r;
  return _n(mt, n, 0), n;
}, context: function(e16, t10) {
  return e16 ? new ad(e16, t10) : dt;
}, matchMedia: function(e16) {
  return new wh(e16);
}, matchMediaRefresh: function() {
  return Co.forEach(function(e16) {
    var t10 = e16.conditions, n, o;
    for (o in t10) t10[o] && (t10[o] = false, n = 1);
    n && e16.revert();
  }) || Ps();
}, addEventListener: function(e16, t10) {
  var n = Cr[e16] || (Cr[e16] = []);
  ~n.indexOf(t10) || n.push(t10);
}, removeEventListener: function(e16, t10) {
  var n = Cr[e16], o = n && n.indexOf(t10);
  o >= 0 && n.splice(o, 1);
}, utils: { wrap: Jp, wrapYoyo: eh, distribute: R0, random: F0, snap: L0, normalize: Qp, getUnit: Et, clamp: Up, splitColor: W0, toArray: rn, selector: Es, mapRange: O0, pipe: Xp, unitize: Yp, interpolate: th, shuffle: P0 }, install: k0, effects: Fi, ticker: Ut, updateRoot: Pt.updateRoot, plugins: Ht, globalTimeline: mt, core: { PropTween: Bt, globals: S0, Tween: Tt, Timeline: Pt, Animation: Za, getCache: _o, _removeLinkedListItem: ai, reverting: function() {
  return Kt;
}, context: function(e16) {
  return e16 && dt && (dt.data.push(e16), e16._ctx = dt), dt;
}, suppressOverwrites: function(e16) {
  return _l = e16;
} } };
Ot("to,from,fromTo,delayedCall,set,killTweensOf", function(e16) {
  return Pr[e16] = Tt[e16];
});
Ut.add(Pt.updateRoot);
Uo = Pr.to({}, { duration: 0 });
var Th = function(e16, t10) {
  for (var n = e16._pt; n && n.p !== t10 && n.op !== t10 && n.fp !== t10; ) n = n._next;
  return n;
};
var Ch = function(e16, t10) {
  var n = e16._targets, o, r, a;
  for (o in t10) for (r = n.length; r--; ) a = e16._ptLookup[r][o], a && (a = a.d) && (a._pt && (a = Th(a, o)), a && a.modifier && a.modifier(t10[o], e16, n[r], o));
};
var Wi = function(e16, t10) {
  return { name: e16, rawVars: 1, init: function(n, o, r) {
    r._onInit = function(a) {
      var i, s;
      if (It(o) && (i = {}, Ot(o, function(l) {
        return i[l] = 1;
      }), o = i), t10) {
        i = {};
        for (s in o) i[s] = t10(o[s]);
        o = i;
      }
      Ch(a, o);
    };
  } };
};
var Wt = Pr.registerPlugin({ name: "attr", init: function(e16, t10, n, o, r) {
  var a, i, s;
  this.tween = n;
  for (a in t10) s = e16.getAttribute(a) || "", i = this.add(e16, "setAttribute", (s || 0) + "", t10[a], o, r, 0, 0, a), i.op = a, i.b = s, this._props.push(a);
}, render: function(e16, t10) {
  for (var n = t10._pt; n; ) Kt ? n.set(n.t, n.p, n.b, n) : n.r(e16, n.d), n = n._next;
} }, { name: "endArray", init: function(e16, t10) {
  for (var n = t10.length; n--; ) this.add(e16, n, e16[n] || 0, t10[n], 0, 0, 0, 0, 0, 1);
} }, Wi("roundProps", Ks), Wi("modifiers"), Wi("snap", L0)) || Pr;
Tt.version = Pt.version = Wt.version = "3.12.5";
C0 = 1;
Tl() && la();
Oe.Power0;
Oe.Power1;
Oe.Power2;
Oe.Power3;
Oe.Power4;
Oe.Linear;
Oe.Quad;
Oe.Cubic;
Oe.Quart;
Oe.Quint;
Oe.Strong;
Oe.Elastic;
Oe.Back;
Oe.SteppedEase;
Oe.Bounce;
Oe.Sine;
Oe.Expo;
Oe.Circ;
var xc;
var Hn;
var Jo;
var El;
var yo;
var Ic;
var Kl;
var kh = function() {
  return typeof window < "u";
};
var Rn = {};
var go = 180 / Math.PI;
var ea = Math.PI / 180;
var qo = Math.atan2;
var Dc = 1e8;
var zl = /([A-Z])/g;
var Sh = /(left|right|width|margin|padding|x)/i;
var Nh = /[\s,\(]\S/;
var Tn = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" };
var Rs = function(e16, t10) {
  return t10.set(t10.t, t10.p, Math.round((t10.s + t10.c * e16) * 1e4) / 1e4 + t10.u, t10);
};
var Mh = function(e16, t10) {
  return t10.set(t10.t, t10.p, e16 === 1 ? t10.e : Math.round((t10.s + t10.c * e16) * 1e4) / 1e4 + t10.u, t10);
};
var $h = function(e16, t10) {
  return t10.set(t10.t, t10.p, e16 ? Math.round((t10.s + t10.c * e16) * 1e4) / 1e4 + t10.u : t10.b, t10);
};
var xh = function(e16, t10) {
  var n = t10.s + t10.c * e16;
  t10.set(t10.t, t10.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t10.u, t10);
};
var rd = function(e16, t10) {
  return t10.set(t10.t, t10.p, e16 ? t10.e : t10.b, t10);
};
var id = function(e16, t10) {
  return t10.set(t10.t, t10.p, e16 !== 1 ? t10.b : t10.e, t10);
};
var Ih = function(e16, t10, n) {
  return e16.style[t10] = n;
};
var Dh = function(e16, t10, n) {
  return e16.style.setProperty(t10, n);
};
var Ah = function(e16, t10, n) {
  return e16._gsap[t10] = n;
};
var Eh = function(e16, t10, n) {
  return e16._gsap.scaleX = e16._gsap.scaleY = n;
};
var Kh = function(e16, t10, n, o, r) {
  var a = e16._gsap;
  a.scaleX = a.scaleY = n, a.renderTransform(r, a);
};
var zh = function(e16, t10, n, o, r) {
  var a = e16._gsap;
  a[t10] = n, a.renderTransform(r, a);
};
var pt = "transform";
var Zt = pt + "Origin";
var Ph = function e12(t10, n) {
  var o = this, r = this.target, a = r.style, i = r._gsap;
  if (t10 in Rn && a) {
    if (this.tfm = this.tfm || {}, t10 !== "transform") t10 = Tn[t10] || t10, ~t10.indexOf(",") ? t10.split(",").forEach(function(s) {
      return o.tfm[s] = Kn(r, s);
    }) : this.tfm[t10] = i.x ? i[t10] : Kn(r, t10), t10 === Zt && (this.tfm.zOrigin = i.zOrigin);
    else return Tn.transform.split(",").forEach(function(s) {
      return e12.call(o, s, n);
    });
    if (this.props.indexOf(pt) >= 0) return;
    i.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(Zt, n, "")), t10 = pt;
  }
  (a || n) && this.props.push(t10, n, a[t10]);
};
var sd = function(e16) {
  e16.translate && (e16.removeProperty("translate"), e16.removeProperty("scale"), e16.removeProperty("rotate"));
};
var Rh = function() {
  var e16 = this.props, t10 = this.target, n = t10.style, o = t10._gsap, r, a;
  for (r = 0; r < e16.length; r += 3) e16[r + 1] ? t10[e16[r]] = e16[r + 2] : e16[r + 2] ? n[e16[r]] = e16[r + 2] : n.removeProperty(e16[r].substr(0, 2) === "--" ? e16[r] : e16[r].replace(zl, "-$1").toLowerCase());
  if (this.tfm) {
    for (a in this.tfm) o[a] = this.tfm[a];
    o.svg && (o.renderTransform(), t10.setAttribute("data-svg-origin", this.svgo || "")), r = Kl(), (!r || !r.isStart) && !n[pt] && (sd(n), o.zOrigin && n[Zt] && (n[Zt] += " " + o.zOrigin + "px", o.zOrigin = 0, o.renderTransform()), o.uncache = 1);
  }
};
var ld = function(e16, t10) {
  var n = { target: e16, props: [], revert: Rh, save: Ph };
  return e16._gsap || Wt.core.getCache(e16), t10 && t10.split(",").forEach(function(o) {
    return n.save(o);
  }), n;
};
var cd;
var Ls = function(e16, t10) {
  var n = Hn.createElementNS ? Hn.createElementNS((t10 || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e16) : Hn.createElement(e16);
  return n && n.style ? n : Hn.createElement(e16);
};
var Sn = function e13(t10, n, o) {
  var r = getComputedStyle(t10);
  return r[n] || r.getPropertyValue(n.replace(zl, "-$1").toLowerCase()) || r.getPropertyValue(n) || !o && e13(t10, ca(n) || n, 1) || "";
};
var Ac = "O,Moz,ms,Ms,Webkit".split(",");
var ca = function(e16, t10, n) {
  var o = t10 || yo, r = o.style, a = 5;
  if (e16 in r && !n) return e16;
  for (e16 = e16.charAt(0).toUpperCase() + e16.substr(1); a-- && !(Ac[a] + e16 in r); ) ;
  return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? Ac[a] : "") + e16;
};
var Fs = function() {
  kh() && window.document && (xc = window, Hn = xc.document, Jo = Hn.documentElement, yo = Ls("div") || { style: {} }, Ls("div"), pt = ca(pt), Zt = pt + "Origin", yo.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", cd = !!ca("perspective"), Kl = Wt.core.reverting, El = 1);
};
var qi = function e14(t10) {
  var n = Ls("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), o = this.parentNode, r = this.nextSibling, a = this.style.cssText, i;
  if (Jo.appendChild(n), n.appendChild(this), this.style.display = "block", t10) try {
    i = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = e14;
  } catch {
  }
  else this._gsapBBox && (i = this._gsapBBox());
  return o && (r ? o.insertBefore(this, r) : o.appendChild(this)), Jo.removeChild(n), this.style.cssText = a, i;
};
var Ec = function(e16, t10) {
  for (var n = t10.length; n--; ) if (e16.hasAttribute(t10[n])) return e16.getAttribute(t10[n]);
};
var ud = function(e16) {
  var t10;
  try {
    t10 = e16.getBBox();
  } catch {
    t10 = qi.call(e16, true);
  }
  return t10 && (t10.width || t10.height) || e16.getBBox === qi || (t10 = qi.call(e16, true)), t10 && !t10.width && !t10.x && !t10.y ? { x: +Ec(e16, ["x", "cx", "x1"]) || 0, y: +Ec(e16, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : t10;
};
var dd = function(e16) {
  return !!(e16.getCTM && (!e16.parentNode || e16.ownerSVGElement) && ud(e16));
};
var $o = function(e16, t10) {
  if (t10) {
    var n = e16.style, o;
    t10 in Rn && t10 !== Zt && (t10 = pt), n.removeProperty ? (o = t10.substr(0, 2), (o === "ms" || t10.substr(0, 6) === "webkit") && (t10 = "-" + t10), n.removeProperty(o === "--" ? t10 : t10.replace(zl, "-$1").toLowerCase())) : n.removeAttribute(t10);
  }
};
var Un = function(e16, t10, n, o, r, a) {
  var i = new Bt(e16._pt, t10, n, 0, 1, a ? id : rd);
  return e16._pt = i, i.b = o, i.e = r, e16._props.push(n), i;
};
var Kc = { deg: 1, rad: 1, turn: 1 };
var Lh = { grid: 1, flex: 1 };
var eo = function e15(t10, n, o, r) {
  var a = parseFloat(o) || 0, i = (o + "").trim().substr((a + "").length) || "px", s = yo.style, l = Sh.test(n), c = t10.tagName.toLowerCase() === "svg", u = (c ? "client" : "offset") + (l ? "Width" : "Height"), d = 100, m = r === "px", p = r === "%", f, h10, g, v;
  if (r === i || !a || Kc[r] || Kc[i]) return a;
  if (i !== "px" && !m && (a = e15(t10, n, o, "px")), v = t10.getCTM && dd(t10), (p || i === "%") && (Rn[n] || ~n.indexOf("adius"))) return f = v ? t10.getBBox()[l ? "width" : "height"] : t10[u], _t2(p ? a / f * d : a / 100 * f);
  if (s[l ? "width" : "height"] = d + (m ? i : r), h10 = ~n.indexOf("adius") || r === "em" && t10.appendChild && !c ? t10 : t10.parentNode, v && (h10 = (t10.ownerSVGElement || {}).parentNode), (!h10 || h10 === Hn || !h10.appendChild) && (h10 = Hn.body), g = h10._gsap, g && p && g.width && l && g.time === Ut.time && !g.uncache) return _t2(a / g.width * d);
  if (p && (n === "height" || n === "width")) {
    var y = t10.style[n];
    t10.style[n] = d + r, f = t10[u], y ? t10.style[n] = y : $o(t10, n);
  } else (p || i === "%") && !Lh[Sn(h10, "display")] && (s.position = Sn(t10, "position")), h10 === t10 && (s.position = "static"), h10.appendChild(yo), f = yo[u], h10.removeChild(yo), s.position = "absolute";
  return l && p && (g = _o(h10), g.time = Ut.time, g.width = h10[u]), _t2(m ? f * a / d : f && a ? d / f * a : 0);
};
var Kn = function(e16, t10, n, o) {
  var r;
  return El || Fs(), t10 in Tn && t10 !== "transform" && (t10 = Tn[t10], ~t10.indexOf(",") && (t10 = t10.split(",")[0])), Rn[t10] && t10 !== "transform" ? (r = qa(e16, o), r = t10 !== "transformOrigin" ? r[t10] : r.svg ? r.origin : Lr(Sn(e16, Zt)) + " " + r.zOrigin + "px") : (r = e16.style[t10], (!r || r === "auto" || o || ~(r + "").indexOf("calc(")) && (r = Rr[t10] && Rr[t10](e16, t10, n) || Sn(e16, t10) || M0(e16, t10) || (t10 === "opacity" ? 1 : 0))), n && !~(r + "").trim().indexOf(" ") ? eo(e16, t10, r, n) + n : r;
};
var Fh = function(e16, t10, n, o) {
  if (!n || n === "none") {
    var r = ca(t10, e16, 1), a = r && Sn(e16, r, 1);
    a && a !== n ? (t10 = r, n = a) : t10 === "borderColor" && (n = Sn(e16, "borderTopColor"));
  }
  var i = new Bt(this._pt, e16.style, t10, 0, 1, nd), s = 0, l = 0, c, u, d, m, p, f, h10, g, v, y, k, T;
  if (i.b = n, i.e = o, n += "", o += "", o === "auto" && (f = e16.style[t10], e16.style[t10] = o, o = Sn(e16, t10) || o, f ? e16.style[t10] = f : $o(e16, t10)), c = [n, o], V0(c), n = c[0], o = c[1], d = n.match(Ho) || [], T = o.match(Ho) || [], T.length) {
    for (; u = Ho.exec(o); ) h10 = u[0], v = o.substring(s, u.index), p ? p = (p + 1) % 5 : (v.substr(-5) === "rgba(" || v.substr(-5) === "hsla(") && (p = 1), h10 !== (f = d[l++] || "") && (m = parseFloat(f) || 0, k = f.substr((m + "").length), h10.charAt(1) === "=" && (h10 = Qo(m, h10) + k), g = parseFloat(h10), y = h10.substr((g + "").length), s = Ho.lastIndex - y.length, y || (y = y || Qt.units[t10] || k, s === o.length && (o += y, i.e += y)), k !== y && (m = eo(e16, t10, f, y) || 0), i._pt = { _next: i._pt, p: v || l === 1 ? v : ",", s: m, c: g - m, m: p && p < 4 || t10 === "zIndex" ? Math.round : 0 });
    i.c = s < o.length ? o.substring(s, o.length) : "";
  } else i.r = t10 === "display" && o === "none" ? id : rd;
  return w0.test(o) && (i.e = 0), this._pt = i, i;
};
var zc = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" };
var jh = function(e16) {
  var t10 = e16.split(" "), n = t10[0], o = t10[1] || "50%";
  return (n === "top" || n === "bottom" || o === "left" || o === "right") && (e16 = n, n = o, o = e16), t10[0] = zc[n] || n, t10[1] = zc[o] || o, t10.join(" ");
};
var Oh = function(e16, t10) {
  if (t10.tween && t10.tween._time === t10.tween._dur) {
    var n = t10.t, o = n.style, r = t10.u, a = n._gsap, i, s, l;
    if (r === "all" || r === true) o.cssText = "", s = 1;
    else for (r = r.split(","), l = r.length; --l > -1; ) i = r[l], Rn[i] && (s = 1, i = i === "transformOrigin" ? Zt : pt), $o(n, i);
    s && ($o(n, pt), a && (a.svg && n.removeAttribute("transform"), qa(n, 1), a.uncache = 1, sd(o)));
  }
};
var Rr = { clearProps: function(e16, t10, n, o, r) {
  if (r.data !== "isFromStart") {
    var a = e16._pt = new Bt(e16._pt, t10, n, 0, 0, Oh);
    return a.u = o, a.pr = -10, a.tween = r, e16._props.push(n), 1;
  }
} };
var Wa = [1, 0, 0, 1, 0, 0];
var fd = {};
var md = function(e16) {
  return e16 === "matrix(1, 0, 0, 1, 0, 0)" || e16 === "none" || !e16;
};
var Pc = function(e16) {
  var t10 = Sn(e16, pt);
  return md(t10) ? Wa : t10.substr(7).match(_0).map(_t2);
};
var Pl = function(e16, t10) {
  var n = e16._gsap || _o(e16), o = e16.style, r = Pc(e16), a, i, s, l;
  return n.svg && e16.getAttribute("transform") ? (s = e16.transform.baseVal.consolidate().matrix, r = [s.a, s.b, s.c, s.d, s.e, s.f], r.join(",") === "1,0,0,1,0,0" ? Wa : r) : (r === Wa && !e16.offsetParent && e16 !== Jo && !n.svg && (s = o.display, o.display = "block", a = e16.parentNode, (!a || !e16.offsetParent) && (l = 1, i = e16.nextElementSibling, Jo.appendChild(e16)), r = Pc(e16), s ? o.display = s : $o(e16, "display"), l && (i ? a.insertBefore(e16, i) : a ? a.appendChild(e16) : Jo.removeChild(e16))), t10 && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r);
};
var js = function(e16, t10, n, o, r, a) {
  var i = e16._gsap, s = r || Pl(e16, true), l = i.xOrigin || 0, c = i.yOrigin || 0, u = i.xOffset || 0, d = i.yOffset || 0, m = s[0], p = s[1], f = s[2], h10 = s[3], g = s[4], v = s[5], y = t10.split(" "), k = parseFloat(y[0]) || 0, T = parseFloat(y[1]) || 0, w, _, M, x;
  n ? s !== Wa && (_ = m * h10 - p * f) && (M = k * (h10 / _) + T * (-f / _) + (f * v - h10 * g) / _, x = k * (-p / _) + T * (m / _) - (m * v - p * g) / _, k = M, T = x) : (w = ud(e16), k = w.x + (~y[0].indexOf("%") ? k / 100 * w.width : k), T = w.y + (~(y[1] || y[0]).indexOf("%") ? T / 100 * w.height : T)), o || o !== false && i.smooth ? (g = k - l, v = T - c, i.xOffset = u + (g * m + v * f) - g, i.yOffset = d + (g * p + v * h10) - v) : i.xOffset = i.yOffset = 0, i.xOrigin = k, i.yOrigin = T, i.smooth = !!o, i.origin = t10, i.originIsAbsolute = !!n, e16.style[Zt] = "0px 0px", a && (Un(a, i, "xOrigin", l, k), Un(a, i, "yOrigin", c, T), Un(a, i, "xOffset", u, i.xOffset), Un(a, i, "yOffset", d, i.yOffset)), e16.setAttribute("data-svg-origin", k + " " + T);
};
var qa = function(e16, t10) {
  var n = e16._gsap || new X0(e16);
  if ("x" in n && !t10 && !n.uncache) return n;
  var o = e16.style, r = n.scaleX < 0, a = "px", i = "deg", s = getComputedStyle(e16), l = Sn(e16, Zt) || "0", c, u, d, m, p, f, h10, g, v, y, k, T, w, _, M, x, R, I, P, F, N, j, z, A, B, D, te, ie, U, oe, se, E;
  return c = u = d = f = h10 = g = v = y = k = 0, m = p = 1, n.svg = !!(e16.getCTM && dd(e16)), s.translate && ((s.translate !== "none" || s.scale !== "none" || s.rotate !== "none") && (o[pt] = (s.translate !== "none" ? "translate3d(" + (s.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (s.rotate !== "none" ? "rotate(" + s.rotate + ") " : "") + (s.scale !== "none" ? "scale(" + s.scale.split(" ").join(",") + ") " : "") + (s[pt] !== "none" ? s[pt] : "")), o.scale = o.rotate = o.translate = "none"), _ = Pl(e16, n.svg), n.svg && (n.uncache ? (B = e16.getBBox(), l = n.xOrigin - B.x + "px " + (n.yOrigin - B.y) + "px", A = "") : A = !t10 && e16.getAttribute("data-svg-origin"), js(e16, A || l, !!A || n.originIsAbsolute, n.smooth !== false, _)), T = n.xOrigin || 0, w = n.yOrigin || 0, _ !== Wa && (I = _[0], P = _[1], F = _[2], N = _[3], c = j = _[4], u = z = _[5], _.length === 6 ? (m = Math.sqrt(I * I + P * P), p = Math.sqrt(N * N + F * F), f = I || P ? qo(P, I) * go : 0, v = F || N ? qo(F, N) * go + f : 0, v && (p *= Math.abs(Math.cos(v * ea))), n.svg && (c -= T - (T * I + w * F), u -= w - (T * P + w * N))) : (E = _[6], oe = _[7], te = _[8], ie = _[9], U = _[10], se = _[11], c = _[12], u = _[13], d = _[14], M = qo(E, U), h10 = M * go, M && (x = Math.cos(-M), R = Math.sin(-M), A = j * x + te * R, B = z * x + ie * R, D = E * x + U * R, te = j * -R + te * x, ie = z * -R + ie * x, U = E * -R + U * x, se = oe * -R + se * x, j = A, z = B, E = D), M = qo(-F, U), g = M * go, M && (x = Math.cos(-M), R = Math.sin(-M), A = I * x - te * R, B = P * x - ie * R, D = F * x - U * R, se = N * R + se * x, I = A, P = B, F = D), M = qo(P, I), f = M * go, M && (x = Math.cos(M), R = Math.sin(M), A = I * x + P * R, B = j * x + z * R, P = P * x - I * R, z = z * x - j * R, I = A, j = B), h10 && Math.abs(h10) + Math.abs(f) > 359.9 && (h10 = f = 0, g = 180 - g), m = _t2(Math.sqrt(I * I + P * P + F * F)), p = _t2(Math.sqrt(z * z + E * E)), M = qo(j, z), v = Math.abs(M) > 2e-4 ? M * go : 0, k = se ? 1 / (se < 0 ? -se : se) : 0), n.svg && (A = e16.getAttribute("transform"), n.forceCSS = e16.setAttribute("transform", "") || !md(Sn(e16, pt)), A && e16.setAttribute("transform", A))), Math.abs(v) > 90 && Math.abs(v) < 270 && (r ? (m *= -1, v += f <= 0 ? 180 : -180, f += f <= 0 ? 180 : -180) : (p *= -1, v += v <= 0 ? 180 : -180)), t10 = t10 || n.uncache, n.x = c - ((n.xPercent = c && (!t10 && n.xPercent || (Math.round(e16.offsetWidth / 2) === Math.round(-c) ? -50 : 0))) ? e16.offsetWidth * n.xPercent / 100 : 0) + a, n.y = u - ((n.yPercent = u && (!t10 && n.yPercent || (Math.round(e16.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? e16.offsetHeight * n.yPercent / 100 : 0) + a, n.z = d + a, n.scaleX = _t2(m), n.scaleY = _t2(p), n.rotation = _t2(f) + i, n.rotationX = _t2(h10) + i, n.rotationY = _t2(g) + i, n.skewX = v + i, n.skewY = y + i, n.transformPerspective = k + a, (n.zOrigin = parseFloat(l.split(" ")[2]) || !t10 && n.zOrigin || 0) && (o[Zt] = Lr(l)), n.xOffset = n.yOffset = 0, n.force3D = Qt.force3D, n.renderTransform = n.svg ? Zh : cd ? pd : Bh, n.uncache = 0, n;
};
var Lr = function(e16) {
  return (e16 = e16.split(" "))[0] + " " + e16[1];
};
var Vi = function(e16, t10, n) {
  var o = Et(t10);
  return _t2(parseFloat(t10) + parseFloat(eo(e16, "x", n + "px", o))) + o;
};
var Bh = function(e16, t10) {
  t10.z = "0px", t10.rotationY = t10.rotationX = "0deg", t10.force3D = 0, pd(e16, t10);
};
var mo = "0deg";
var Na = "0px";
var po = ") ";
var pd = function(e16, t10) {
  var n = t10 || this, o = n.xPercent, r = n.yPercent, a = n.x, i = n.y, s = n.z, l = n.rotation, c = n.rotationY, u = n.rotationX, d = n.skewX, m = n.skewY, p = n.scaleX, f = n.scaleY, h10 = n.transformPerspective, g = n.force3D, v = n.target, y = n.zOrigin, k = "", T = g === "auto" && e16 && e16 !== 1 || g === true;
  if (y && (u !== mo || c !== mo)) {
    var w = parseFloat(c) * ea, _ = Math.sin(w), M = Math.cos(w), x;
    w = parseFloat(u) * ea, x = Math.cos(w), a = Vi(v, a, _ * x * -y), i = Vi(v, i, -Math.sin(w) * -y), s = Vi(v, s, M * x * -y + y);
  }
  h10 !== Na && (k += "perspective(" + h10 + po), (o || r) && (k += "translate(" + o + "%, " + r + "%) "), (T || a !== Na || i !== Na || s !== Na) && (k += s !== Na || T ? "translate3d(" + a + ", " + i + ", " + s + ") " : "translate(" + a + ", " + i + po), l !== mo && (k += "rotate(" + l + po), c !== mo && (k += "rotateY(" + c + po), u !== mo && (k += "rotateX(" + u + po), (d !== mo || m !== mo) && (k += "skew(" + d + ", " + m + po), (p !== 1 || f !== 1) && (k += "scale(" + p + ", " + f + po), v.style[pt] = k || "translate(0, 0)";
};
var Zh = function(e16, t10) {
  var n = t10 || this, o = n.xPercent, r = n.yPercent, a = n.x, i = n.y, s = n.rotation, l = n.skewX, c = n.skewY, u = n.scaleX, d = n.scaleY, m = n.target, p = n.xOrigin, f = n.yOrigin, h10 = n.xOffset, g = n.yOffset, v = n.forceCSS, y = parseFloat(a), k = parseFloat(i), T, w, _, M, x;
  s = parseFloat(s), l = parseFloat(l), c = parseFloat(c), c && (c = parseFloat(c), l += c, s += c), s || l ? (s *= ea, l *= ea, T = Math.cos(s) * u, w = Math.sin(s) * u, _ = Math.sin(s - l) * -d, M = Math.cos(s - l) * d, l && (c *= ea, x = Math.tan(l - c), x = Math.sqrt(1 + x * x), _ *= x, M *= x, c && (x = Math.tan(c), x = Math.sqrt(1 + x * x), T *= x, w *= x)), T = _t2(T), w = _t2(w), _ = _t2(_), M = _t2(M)) : (T = u, M = d, w = _ = 0), (y && !~(a + "").indexOf("px") || k && !~(i + "").indexOf("px")) && (y = eo(m, "x", a, "px"), k = eo(m, "y", i, "px")), (p || f || h10 || g) && (y = _t2(y + p - (p * T + f * _) + h10), k = _t2(k + f - (p * w + f * M) + g)), (o || r) && (x = m.getBBox(), y = _t2(y + o / 100 * x.width), k = _t2(k + r / 100 * x.height)), x = "matrix(" + T + "," + w + "," + _ + "," + M + "," + y + "," + k + ")", m.setAttribute("transform", x), v && (m.style[pt] = x);
};
var Wh = function(e16, t10, n, o, r) {
  var a = 360, i = It(r), s = parseFloat(r) * (i && ~r.indexOf("rad") ? go : 1), l = s - o, c = o + l + "deg", u, d;
  return i && (u = r.split("_")[1], u === "short" && (l %= a, l !== l % (a / 2) && (l += l < 0 ? a : -a)), u === "cw" && l < 0 ? l = (l + a * Dc) % a - ~~(l / a) * a : u === "ccw" && l > 0 && (l = (l - a * Dc) % a - ~~(l / a) * a)), e16._pt = d = new Bt(e16._pt, t10, n, o, l, Mh), d.e = c, d.u = "deg", e16._props.push(n), d;
};
var Rc = function(e16, t10) {
  for (var n in t10) e16[n] = t10[n];
  return e16;
};
var qh = function(e16, t10, n) {
  var o = Rc({}, n._gsap), r = "perspective,force3D,transformOrigin,svgOrigin", a = n.style, i, s, l, c, u, d, m, p;
  o.svg ? (l = n.getAttribute("transform"), n.setAttribute("transform", ""), a[pt] = t10, i = qa(n, 1), $o(n, pt), n.setAttribute("transform", l)) : (l = getComputedStyle(n)[pt], a[pt] = t10, i = qa(n, 1), a[pt] = l);
  for (s in Rn) l = o[s], c = i[s], l !== c && r.indexOf(s) < 0 && (m = Et(l), p = Et(c), u = m !== p ? eo(n, s, l, p) : parseFloat(l), d = parseFloat(c), e16._pt = new Bt(e16._pt, i, s, u, d - u, Rs), e16._pt.u = p || 0, e16._props.push(s));
  Rc(i, o);
};
Ot("padding,margin,Width,Radius", function(e16, t10) {
  var n = "Top", o = "Right", r = "Bottom", a = "Left", i = (t10 < 3 ? [n, o, r, a] : [n + a, n + o, r + o, r + a]).map(function(s) {
    return t10 < 2 ? e16 + s : "border" + s + e16;
  });
  Rr[t10 > 1 ? "border" + e16 : e16] = function(s, l, c, u, d) {
    var m, p;
    if (arguments.length < 4) return m = i.map(function(f) {
      return Kn(s, f, c);
    }), p = m.join(" "), p.split(m[0]).length === 5 ? m[0] : p;
    m = (u + "").split(" "), p = {}, i.forEach(function(f, h10) {
      return p[f] = m[h10] = m[h10] || m[(h10 - 1) / 2 | 0];
    }), s.init(l, p, d);
  };
});
var hd = { name: "css", register: Fs, targetTest: function(e16) {
  return e16.style && e16.nodeType;
}, init: function(e16, t10, n, o, r) {
  var a = this._props, i = e16.style, s = n.vars.startAt, l, c, u, d, m, p, f, h10, g, v, y, k, T, w, _, M;
  El || Fs(), this.styles = this.styles || ld(e16), M = this.styles.props, this.tween = n;
  for (f in t10) if (f !== "autoRound" && (c = t10[f], !(Ht[f] && Y0(f, t10, n, o, e16, r)))) {
    if (m = typeof c, p = Rr[f], m === "function" && (c = c.call(n, o, e16, r), m = typeof c), m === "string" && ~c.indexOf("random(") && (c = Oa(c)), p) p(this, e16, f, c, n) && (_ = 1);
    else if (f.substr(0, 2) === "--") l = (getComputedStyle(e16).getPropertyValue(f) + "").trim(), c += "", Xn.lastIndex = 0, Xn.test(l) || (h10 = Et(l), g = Et(c)), g ? h10 !== g && (l = eo(e16, f, l, g) + g) : h10 && (c += h10), this.add(i, "setProperty", l, c, o, r, 0, 0, f), a.push(f), M.push(f, 0, i[f]);
    else if (m !== "undefined") {
      if (s && f in s ? (l = typeof s[f] == "function" ? s[f].call(n, o, e16, r) : s[f], It(l) && ~l.indexOf("random(") && (l = Oa(l)), Et(l + "") || l === "auto" || (l += Qt.units[f] || Et(Kn(e16, f)) || ""), (l + "").charAt(1) === "=" && (l = Kn(e16, f))) : l = Kn(e16, f), d = parseFloat(l), v = m === "string" && c.charAt(1) === "=" && c.substr(0, 2), v && (c = c.substr(2)), u = parseFloat(c), f in Tn && (f === "autoAlpha" && (d === 1 && Kn(e16, "visibility") === "hidden" && u && (d = 0), M.push("visibility", 0, i.visibility), Un(this, i, "visibility", d ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), f !== "scale" && f !== "transform" && (f = Tn[f], ~f.indexOf(",") && (f = f.split(",")[0]))), y = f in Rn, y) {
        if (this.styles.save(f), k || (T = e16._gsap, T.renderTransform && !t10.parseTransform || qa(e16, t10.parseTransform), w = t10.smoothOrigin !== false && T.smooth, k = this._pt = new Bt(this._pt, i, pt, 0, 1, T.renderTransform, T, 0, -1), k.dep = 1), f === "scale") this._pt = new Bt(this._pt, T, "scaleY", T.scaleY, (v ? Qo(T.scaleY, v + u) : u) - T.scaleY || 0, Rs), this._pt.u = 0, a.push("scaleY", f), f += "X";
        else if (f === "transformOrigin") {
          M.push(Zt, 0, i[Zt]), c = jh(c), T.svg ? js(e16, c, 0, w, 0, this) : (g = parseFloat(c.split(" ")[2]) || 0, g !== T.zOrigin && Un(this, T, "zOrigin", T.zOrigin, g), Un(this, i, f, Lr(l), Lr(c)));
          continue;
        } else if (f === "svgOrigin") {
          js(e16, c, 1, w, 0, this);
          continue;
        } else if (f in fd) {
          Wh(this, T, f, d, v ? Qo(d, v + c) : c);
          continue;
        } else if (f === "smoothOrigin") {
          Un(this, T, "smooth", T.smooth, c);
          continue;
        } else if (f === "force3D") {
          T[f] = c;
          continue;
        } else if (f === "transform") {
          qh(this, c, e16);
          continue;
        }
      } else f in i || (f = ca(f) || f);
      if (y || (u || u === 0) && (d || d === 0) && !Nh.test(c) && f in i) h10 = (l + "").substr((d + "").length), u || (u = 0), g = Et(c) || (f in Qt.units ? Qt.units[f] : h10), h10 !== g && (d = eo(e16, f, l, g)), this._pt = new Bt(this._pt, y ? T : i, f, d, (v ? Qo(d, v + u) : u) - d, !y && (g === "px" || f === "zIndex") && t10.autoRound !== false ? xh : Rs), this._pt.u = g || 0, h10 !== g && g !== "%" && (this._pt.b = l, this._pt.r = $h);
      else if (f in i) Fh.call(this, e16, f, l, v ? v + c : c);
      else if (f in e16) this.add(e16, f, l || e16[f], v ? v + c : c, o, r);
      else if (f !== "parseTransform") {
        kl(f, c);
        continue;
      }
      y || (f in i ? M.push(f, 0, i[f]) : M.push(f, 1, l || e16[f])), a.push(f);
    }
  }
  _ && od(this);
}, render: function(e16, t10) {
  if (t10.tween._time || !Kl()) for (var n = t10._pt; n; ) n.r(e16, n.d), n = n._next;
  else t10.styles.revert();
}, get: Kn, aliases: Tn, getSetter: function(e16, t10, n) {
  var o = Tn[t10];
  return o && o.indexOf(",") < 0 && (t10 = o), t10 in Rn && t10 !== Zt && (e16._gsap.x || Kn(e16, "x")) ? n && Ic === n ? t10 === "scale" ? Eh : Ah : (Ic = n || {}) && (t10 === "scale" ? Kh : zh) : e16.style && !wl(e16.style[t10]) ? Ih : ~t10.indexOf("-") ? Dh : Dl(e16, t10);
}, core: { _removeProperty: $o, _getMatrix: Pl } };
Wt.utils.checkPrefix = ca;
Wt.core.getStyleSaver = ld;
(function(e16, t10, n, o) {
  var r = Ot(e16 + "," + t10 + "," + n, function(a) {
    Rn[a] = 1;
  });
  Ot(t10, function(a) {
    Qt.units[a] = "deg", fd[a] = 1;
  }), Tn[r[13]] = e16 + "," + t10, Ot(o, function(a) {
    var i = a.split(":");
    Tn[i[1]] = r[i[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Ot("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(e16) {
  Qt.units[e16] = "px";
});
Wt.registerPlugin(hd);
var Vh = Wt.registerPlugin(hd) || Wt;
Vh.core.Tween;
var Hh = Ye("Setting", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M8.854 3.816 8.64 5.097v.001q-.034.207-.274.34-.159.09-.237.138-.229.137-.426.064l-1.215-.456q-1.489-.56-2.284.818L2.907 8.25q-.792 1.375.433 2.383l1.004.826q.162.134.157.4-.002.142 0 .283.005.265-.157.398l-1.003.827q-1.227 1.009-.434 2.385l1.298 2.247q.795 1.375 2.281.817l1.216-.455q.198-.074.426.063.122.073.244.141.234.13.268.337l.213 1.282q.263 1.566 1.85 1.566h2.594q1.59 0 1.85-1.567l.213-1.28q.035-.208.268-.337.124-.07.242-.141.23-.138.427-.065l1.217.456q1.487.558 2.281-.818l1.299-2.247q.791-1.373-.433-2.384l-1.005-.827q-.162-.134-.156-.4.002-.14 0-.283-.006-.263.157-.397l1.002-.827q1.227-1.009.434-2.385l-1.297-2.247q-.795-1.377-2.282-.817l-1.217.456q-.197.073-.425-.064-.145-.088-.243-.141-.234-.13-.27-.337l-.212-1.28q-.26-1.568-1.85-1.568h-2.593q-1.59 0-1.85 1.566m1.266 1.529v-.001l.214-1.28q.052-.314.37-.314h2.593q.318 0 .37.313l.213 1.281q.156.923 1.021 1.403.082.044.197.113.85.513 1.725.184l1.217-.456q.299-.112.458.163l1.295 2.247q.16.275-.086.477l-1.004.827q-.724.596-.703 1.587.002.112 0 .227-.02.986.704 1.582l1.003.827q.245.202.087.476l-1.297 2.247q-.16.275-.457.164l-1.217-.456q-.875-.328-1.725.183-.1.06-.198.115-.864.478-1.02 1.4l-.213 1.283q-.052.313-.37.313h-2.594q-.318 0-.37-.314l-.213-1.28q-.153-.922-1.02-1.403-.1-.055-.196-.113-.85-.512-1.726-.185l-1.218.457q-.298.111-.457-.163l-1.296-2.247q-.159-.275.086-.477l1.005-.827q.721-.593.703-1.584-.002-.114 0-.227.018-.99-.703-1.584l-1.004-.828q-.245-.202-.087-.477l1.297-2.246q.159-.276.456-.164l1.217.456q.877.328 1.726-.184.066-.04.203-.118.86-.474 1.014-1.397" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M14.652 9.348Q13.553 8.25 12 8.25T9.348 9.348Q8.25 10.447 8.25 12t1.098 2.652T12 15.75t2.652-1.098Q15.75 13.553 15.75 12t-1.098-2.652m-4.243 1.061Q11.068 9.75 12 9.75t1.591.659T14.25 12t-.659 1.591T12 14.25t-1.591-.659T9.75 12t.659-1.591" }, null)]);
});
var Uh = Ye("SizeControls", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("rect", { width: "16", height: "1.5", x: "4", y: "2.5", rx: ".75" }, null), createVNode("rect", { width: "16", height: "1.5", x: "4", y: "20", rx: ".75" }, null), createVNode("path", { d: "M9 8h6l-3-3zM9 16h6l-3 3z" }, null), createVNode("rect", { width: "1.5", height: "8", x: "11.25", y: "8", rx: "0" }, null)]);
});
var Gh = Ye("TableSortDownColor", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, fill: "none", "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0 }, [createVNode("path", { fill: "#2882FF", d: "M6.375 13.25h11.25L12 19.5z" }, null), createVNode("path", { fill: "#CDCACF", d: "m12 4.5 5.625 6.25H6.375z" }, null)]);
});
var Xh = Ye("TableSortNormalColor", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, fill: "none", "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0 }, [createVNode("path", { fill: "#CDCACF", d: "m12 4.5 5.625 6.25H6.375zm-5.625 8.75h11.25L12 19.5z" }, null)]);
});
var Yh = Ye("TableSortUpColor", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, fill: "none", "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0 }, [createVNode("path", { fill: "#CDCACF", d: "M6.375 13.25h11.25L12 19.5z" }, null), createVNode("path", { fill: "#2882FF", d: "m12 4.5 5.625 6.25H6.375z" }, null)]);
});
var gd = Ye("Tips", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M2.095 16.185Q2.911 18.114 4.4 19.6q1.487 1.488 3.416 2.304 1.998.845 4.185.845t4.185-.845q1.929-.816 3.416-2.304 1.488-1.487 2.304-3.416.845-1.998.845-4.185t-.845-4.185Q21.089 5.886 19.6 4.4q-1.487-1.488-3.416-2.304Q14.187 1.25 12 1.25t-4.185.845Q5.886 2.911 4.4 4.4 2.91 5.886 2.095 7.815 1.25 9.813 1.25 12t.845 4.185M8.4 20.523q-1.66-.702-2.94-1.982T3.476 15.6Q2.75 13.881 2.75 12t.727-3.6q.702-1.66 1.982-2.94T8.4 3.476Q10.119 2.75 12 2.75t3.6.727q1.66.702 2.94 1.982t1.983 2.94q.727 1.719.727 3.601t-.727 3.6q-.702 1.66-1.982 2.94t-2.94 1.983q-1.719.727-3.601.727t-3.6-.727" }, null), createVNode("path", { d: "M13.25 6.75q0 .061-.006.123-.006.06-.018.12-.012.061-.03.12t-.041.115-.053.111-.063.105-.073.099-.082.09-.091.083q-.047.04-.099.073-.05.034-.105.063-.054.03-.11.053-.057.023-.116.041t-.12.03-.12.018Q12.06 8 12 8t-.123-.006q-.06-.006-.12-.018-.061-.012-.12-.03t-.115-.041-.111-.053-.105-.063-.099-.073-.09-.082-.083-.091q-.04-.047-.073-.099-.034-.05-.063-.105-.03-.054-.053-.11-.023-.057-.041-.116t-.03-.12-.018-.12q-.006-.062-.006-.123t.006-.123q.006-.06.018-.12.012-.061.03-.12t.041-.115.053-.111.063-.105.073-.099.082-.09.091-.083q.047-.04.099-.073.05-.034.105-.063.054-.03.11-.053.057-.023.116-.041t.12-.03.12-.018Q11.94 5.5 12 5.5t.123.006q.06.006.12.018.061.012.12.03t.115.041.111.053.105.063.099.073.09.082.083.091q.04.047.073.099.034.05.063.105.03.054.053.11.023.057.041.116t.03.12.018.12q.006.062.006.123" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M11.5 10.75h-.25q-.074 0-.146-.014-.073-.015-.141-.043t-.13-.07q-.061-.04-.113-.093-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14T10.5 10t.014-.146.043-.141.07-.13.093-.113q.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043t.147-.014h1q.074 0 .146.014.073.015.141.043t.13.07q.061.04.113.093.053.052.094.113.04.062.069.13.028.068.043.14T13 10v7q0 .074-.014.146-.015.073-.043.141t-.07.13q-.04.061-.093.113-.052.053-.113.094-.062.04-.13.069-.068.028-.14.043t-.147.014-.146-.014-.141-.043-.13-.07-.113-.093q-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14T11.5 17z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M10.5 16.25H14q.074 0 .146.014.073.015.141.043t.13.07q.061.04.113.093.053.052.094.113.04.062.069.13.028.068.043.14t.014.147-.014.146-.043.141-.07.13-.093.113q-.052.053-.113.094-.062.04-.13.069-.068.028-.14.043T14 17.75h-3.5q-.074 0-.146-.014-.073-.015-.141-.043t-.13-.07q-.061-.04-.113-.093-.053-.052-.094-.113-.04-.062-.069-.13-.028-.068-.043-.14T9.75 17t.014-.146.043-.141.07-.13.093-.113q.052-.053.113-.094.062-.04.13-.069.068-.028.14-.043t.147-.014" }, null)]);
});
var Qh = Ye("Unfold", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M2.643 13h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625H2.643a.634.634 0 0 0-.643.625c0 .345.288.625.643.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m6.955 9.067-3.403 3.308 3.402 3.308a.617.617 0 0 1 0 .884.65.65 0 0 1-.423.182l-.031.001a.65.65 0 0 1-.455-.183l-3.857-3.75a.616.616 0 0 1 0-.884l3.857-3.75a.65.65 0 0 1 .91 0 .616.616 0 0 1 0 .884M21.357 11.8h-7.714a.634.634 0 0 0-.643.625c0 .345.288.625.643.625h7.714c.355 0 .643-.28.643-.625a.634.634 0 0 0-.643-.625" }, null), createVNode("path", { "fill-rule": "evenodd", d: "m17.045 15.733 3.403-3.308-3.402-3.308a.617.617 0 0 1 0-.884.65.65 0 0 1 .423-.182l.031-.001c.17 0 .334.066.455.183l3.857 3.75a.616.616 0 0 1 0 .884l-3.857 3.75a.65.65 0 0 1-.91 0 .616.616 0 0 1 0-.884" }, null)]);
});
var Rl = Ye("Warning", false, function(e16) {
  return createVNode("svg", { xmlns: "http://www.w3.org/2000/svg", width: e16.size, height: e16.size, "aria-hidden": true, viewBox: "0 0 24 24", transform: e16.rotate ? `rotate(${e16.rotate})` : void 0, fill: e16.color }, [createVNode("path", { "fill-rule": "evenodd", d: "M4.58 21.083h-.003q-1.402.005-2.13-1.194-.729-1.201-.075-2.444L9.797 3.408q.324-.612.918-.97.594-.357 1.287-.357t1.286.357.918.97l7.424 14.036q.656 1.245-.075 2.447-.73 1.201-2.136 1.192zm-.003-1.5h14.851q.557.004.846-.472.289-.475.03-.966L12.88 4.11q-.28-.53-.878-.53-.6 0-.88.53L3.7 18.143q-.26.492.03.968.287.475.843.472z" }, null), createVNode("path", { "fill-rule": "evenodd", d: "M13.167 8.667v5a1 1 0 0 1-2 0v-5a1 1 0 0 1 2 0" }, null), createVNode("circle", { cx: "12", cy: "16.583", r: "1.25" }, null)]);
});
function Dt(e16) {
  let t10 = "";
  const n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", o = n.length;
  for (let r = 0; r < e16; r++)
    t10 += n.charAt(Math.floor(Math.random() * o));
  return t10;
}
function vd(e16) {
  return e16 != null && e16 !== "";
}
function Jh(e16) {
  if (!e16)
    return false;
  const t10 = new Option().style;
  return t10.color = e16, !!t10.color;
}
function yd(e16, t10, n = "id") {
  const o = new Map(e16.map((c, u) => [c[n], u])), r = new Map(e16.map((c) => [c[n], c])), a = [], i = [];
  for (const c of t10) {
    const u = o.get(c) ?? -1;
    u >= 0 && (a.push(u), i.push(c));
  }
  a.sort((c, u) => c - u);
  for (const c in a)
    o.set(i[c], a[c]);
  const s = [];
  for (const [c, u] of o)
    s[u] = c;
  const l = [];
  for (const c of s)
    l.push(r.get(c));
  return l;
}
function Fr(e16, t10) {
  if (!Array.isArray(e16) || e16.length === 0)
    return [];
  let n = [];
  for (const o of e16)
    o[t10] ? n = n.concat(Fr(o[t10], t10)) : n.push(o);
  return n;
}
function bd(e16, t10) {
  if (!Array.isArray(e16) || e16.length === 0)
    return [];
  let n = [];
  for (const o of e16)
    n.push(o), Array.isArray(o[t10]) && (n = n.concat(bd(o[t10], t10)));
  return n;
}
function _d(e16, t10, n) {
  if (!Array.isArray(e16) || e16.length === 0)
    return [];
  for (let o = 0; o < e16.length; o++) {
    const r = e16[o];
    if (!n(r)) {
      e16.splice(o, 1), o--;
      continue;
    }
    Array.isArray(r[t10]) && _d(r[t10], t10, n);
  }
  return e16;
}
function wd(e16, t10, n, o) {
  const r = new Map(n.map((a) => [a[o], a]));
  for (let a = 0; a < e16.length; a++) {
    const i = e16[a];
    if (r.has(i[o])) {
      e16[a] = r.get(i[o]);
      continue;
    }
    Array.isArray(i[t10]) && wd(i[t10], t10, n, o);
  }
  return e16;
}
function Ae(e16, t10) {
  return new Proxy(e16, {
    get(o, r) {
      var a;
      return Object.hasOwnProperty.call(o, r) ? o[r] : (a = t10.value) == null ? void 0 : a[r];
    },
    has(o, r) {
      const a = isRef(t10) ? t10.value : t10;
      return Reflect.has(e16, r) || Reflect.has(a, r);
    }
  });
}
function eg(e16, t10) {
  return e16.sort((n, o) => {
    for (let r = 0; r < t10.length; r++) {
      const { field: a, order: i } = t10[r];
      let s = 0;
      if (typeof n[a] == "string" ? s = n[a].localeCompare(o[a]) : s = n[a] - o[a], i === "desc" && (s = -s), s !== 0)
        return s;
    }
    return 0;
  });
}
function hr(e16, t10) {
  if (typeof t10 != "string")
    return e16;
  const n = Array.isArray(e16) ? e16 : [e16], o = [];
  for (const r of n) {
    if (!(r instanceof Date)) {
      o.push(r);
      continue;
    }
    const a = r.getFullYear(), i = r.getMonth() + 1, s = r.getDate(), l = r.getHours(), c = r.getMinutes(), u = r.getSeconds(), d = t10.replace("YYYY", Vo(a, 4)).replace("MM", Vo(i, 2)).replace("DD", Vo(s, 2)).replace("HH", Vo(l, 2)).replace("mm", Vo(c, 2)).replace("ss", Vo(u, 2));
    o.push(d);
  }
  return o.length === 1 ? o[0] : o;
}
function Vo(e16, t10) {
  let n = `${e16}`;
  for (; n.length < t10; )
    n = `0${n}`;
  return n;
}
var tg = class {
  constructor() {
    mr(this, "events");
    this.events = /* @__PURE__ */ new Map();
  }
  on(t10, n, o) {
    const r = this.events.get(n);
    if (!r) {
      this.events.set(n, { [t10]: o });
      return;
    }
    r[t10] || (r[t10] = o);
  }
  emit(t10, n, ...o) {
    var a;
    const r = (a = this.events.get(n)) == null ? void 0 : a[t10];
    typeof r == "function" && r.call(null, ...o);
  }
  remove(t10, n) {
    const o = this.events.get(n);
    o && (o[t10] && delete o[t10], Object.keys(o).length === 0 && this.events.delete(n));
  }
};
var Hi = "data-observer-key";
var ng = class {
  constructor() {
    mr(this, "resizeObserver");
    mr(this, "actions");
    this.actions = {}, typeof ResizeObserver < "u" ? this.resizeObserver = new ResizeObserver((t10) => {
      t10.forEach((n) => {
        const r = n.target.getAttribute(Hi);
        r && this.actions[r] && this.actions[r](n);
      });
    }) : this.resizeObserver = null;
  }
  observe(t10, n) {
    var r;
    if (!(t10 instanceof HTMLElement) && !(t10 instanceof Element))
      return;
    const o = t10.getAttribute(Hi) ?? "";
    this.actions[o] = n, (r = this.resizeObserver) == null || r.observe(t10);
  }
  unobserve(t10) {
    var o;
    if (!(t10 instanceof HTMLElement) && !(t10 instanceof Element))
      return;
    const n = t10.getAttribute(Hi) ?? "";
    delete this.actions[n], (o = this.resizeObserver) == null || o.unobserve(t10);
  }
};
var og = (e16) => {
  const t10 = /* @__PURE__ */ Object.create(null);
  return (n) => {
    const o = t10[n];
    return o || (t10[n] = e16(n), t10[n]);
  };
};
var ag = /-(\w)/g;
var Td = og((e16) => e16.replace(ag, (t10, n) => n ? n.toUpperCase() : ""));
var rg = Symbol("skipFlatten");
var jr = (e16 = [], t10 = true) => {
  const n = Array.isArray(e16) ? e16 : [e16], o = [];
  return n.forEach((r) => {
    Array.isArray(r) ? o.push(...jr(r, t10)) : r && r.type === Fragment ? r.key === rg ? o.push(r) : o.push(...jr(r.children, t10)) : r && isVNode(r) ? t10 && !ig(r) ? o.push(r) : t10 || o.push(r) : vd(r) && o.push(r);
  }), o;
};
function ig(e16) {
  return e16 && (e16.type === Comment || e16.type === Fragment && e16.children.length === 0 || e16.type === Text && e16.children.trim() === "");
}
function Cd(e16) {
  return Array.isArray(e16) && e16.length === 1 && (e16 = e16[0]), e16 && e16.__v_isVNode && typeof e16.type != "symbol";
}
var kd = (e16, t10) => {
  if (typeof e16 == "number") {
    if (t10 === 3)
      return {
        mode: "rgb",
        r: (e16 >> 8 & 15 | e16 >> 4 & 240) / 255,
        g: (e16 >> 4 & 15 | e16 & 240) / 255,
        b: (e16 & 15 | e16 << 4 & 240) / 255
      };
    if (t10 === 4)
      return {
        mode: "rgb",
        r: (e16 >> 12 & 15 | e16 >> 8 & 240) / 255,
        g: (e16 >> 8 & 15 | e16 >> 4 & 240) / 255,
        b: (e16 >> 4 & 15 | e16 & 240) / 255,
        alpha: (e16 & 15 | e16 << 4 & 240) / 255
      };
    if (t10 === 6)
      return {
        mode: "rgb",
        r: (e16 >> 16 & 255) / 255,
        g: (e16 >> 8 & 255) / 255,
        b: (e16 & 255) / 255
      };
    if (t10 === 8)
      return {
        mode: "rgb",
        r: (e16 >> 24 & 255) / 255,
        g: (e16 >> 16 & 255) / 255,
        b: (e16 >> 8 & 255) / 255,
        alpha: (e16 & 255) / 255
      };
  }
};
var sg = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  // Added in CSS Colors Level 4:
  // https://drafts.csswg.org/css-color/#changes-from-3
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
var lg = (e16) => kd(sg[e16.toLowerCase()], 6);
var cg = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
var ug = (e16) => {
  let t10;
  return (t10 = e16.match(cg)) ? kd(parseInt(t10[1], 16), t10[1].length) : void 0;
};
var Yn = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)";
var Pa = `${Yn}%`;
var Ll = `(?:${Yn}%|${Yn})`;
var dg = `(?:${Yn}(deg|grad|rad|turn)|${Yn})`;
var ua = "\\s*,\\s*";
var fg = new RegExp(
  `^rgba?\\(\\s*${Yn}${ua}${Yn}${ua}${Yn}\\s*(?:,\\s*${Ll}\\s*)?\\)$`
);
var mg = new RegExp(
  `^rgba?\\(\\s*${Pa}${ua}${Pa}${ua}${Pa}\\s*(?:,\\s*${Ll}\\s*)?\\)$`
);
var pg = (e16) => {
  let t10 = { mode: "rgb" }, n;
  if (n = e16.match(fg))
    n[1] !== void 0 && (t10.r = n[1] / 255), n[2] !== void 0 && (t10.g = n[2] / 255), n[3] !== void 0 && (t10.b = n[3] / 255);
  else if (n = e16.match(mg))
    n[1] !== void 0 && (t10.r = n[1] / 100), n[2] !== void 0 && (t10.g = n[2] / 100), n[3] !== void 0 && (t10.b = n[3] / 100);
  else
    return;
  return n[4] !== void 0 ? t10.alpha = Math.max(0, Math.min(1, n[4] / 100)) : n[5] !== void 0 && (t10.alpha = Math.max(0, Math.min(1, +n[5]))), t10;
};
var hg = (e16, t10) => e16 === void 0 ? void 0 : typeof e16 != "object" ? $d(e16) : e16.mode !== void 0 ? e16 : t10 ? { ...e16, mode: t10 } : void 0;
var Os = (e16 = "rgb") => (t10) => (t10 = hg(t10, e16)) !== void 0 ? (
  // if the color's mode corresponds to our target mode
  t10.mode === e16 ? (
    // then just return the color
    t10
  ) : (
    // otherwise check to see if we have a dedicated
    // converter for the target mode
    wn[t10.mode][e16] ? (
      // and return its result...
      wn[t10.mode][e16](t10)
    ) : (
      // ...otherwise pass through RGB as an intermediary step.
      // if the target mode is RGB...
      e16 === "rgb" ? (
        // just return the RGB
        wn[t10.mode].rgb(t10)
      ) : (
        // otherwise convert color.mode -> RGB -> target_mode
        wn.rgb[e16](wn[t10.mode].rgb(t10))
      )
    )
  )
) : void 0;
var wn = {};
var Sd = {};
var Or = [];
var Nd = {};
var gg = (e16) => e16;
var Ge = (e16) => (wn[e16.mode] = {
  ...wn[e16.mode],
  ...e16.toMode
}, Object.keys(e16.fromMode || {}).forEach((t10) => {
  wn[t10] || (wn[t10] = {}), wn[t10][e16.mode] = e16.fromMode[t10];
}), e16.ranges || (e16.ranges = {}), e16.difference || (e16.difference = {}), e16.channels.forEach((t10) => {
  if (e16.ranges[t10] === void 0 && (e16.ranges[t10] = [0, 1]), !e16.interpolate[t10])
    throw new Error(`Missing interpolator for: ${t10}`);
  typeof e16.interpolate[t10] == "function" && (e16.interpolate[t10] = {
    use: e16.interpolate[t10]
  }), e16.interpolate[t10].fixup || (e16.interpolate[t10].fixup = gg);
}), Sd[e16.mode] = e16, (e16.parse || []).forEach((t10) => {
  yg(t10, e16.mode);
}), Os(e16.mode));
var vg = (e16) => Sd[e16];
var yg = (e16, t10) => {
  if (typeof e16 == "string") {
    if (!t10)
      throw new Error("'mode' required when 'parser' is a string");
    Nd[e16] = t10;
  } else typeof e16 == "function" && Or.indexOf(e16) < 0 && Or.push(e16);
};
var Bs = /[^\x00-\x7F]|[a-zA-Z_]/;
var bg = /[^\x00-\x7F]|[-\w]/;
var ce = {
  Function: "function",
  Ident: "ident",
  Number: "number",
  Percentage: "percentage",
  ParenClose: ")",
  None: "none",
  Hue: "hue",
  Alpha: "alpha"
};
var Se = 0;
function gr(e16) {
  let t10 = e16[Se], n = e16[Se + 1];
  return t10 === "-" || t10 === "+" ? /\d/.test(n) || n === "." && /\d/.test(e16[Se + 2]) : t10 === "." ? /\d/.test(n) : /\d/.test(t10);
}
function Zs(e16) {
  if (Se >= e16.length)
    return false;
  let t10 = e16[Se];
  if (Bs.test(t10))
    return true;
  if (t10 === "-") {
    if (e16.length - Se < 2)
      return false;
    let n = e16[Se + 1];
    return !!(n === "-" || Bs.test(n));
  }
  return false;
}
var _g = {
  deg: 1,
  rad: 180 / Math.PI,
  grad: 9 / 10,
  turn: 360
};
function Ma(e16) {
  let t10 = "";
  if ((e16[Se] === "-" || e16[Se] === "+") && (t10 += e16[Se++]), t10 += vr(e16), e16[Se] === "." && /\d/.test(e16[Se + 1]) && (t10 += e16[Se++] + vr(e16)), (e16[Se] === "e" || e16[Se] === "E") && ((e16[Se + 1] === "-" || e16[Se + 1] === "+") && /\d/.test(e16[Se + 2]) ? t10 += e16[Se++] + e16[Se++] + vr(e16) : /\d/.test(e16[Se + 1]) && (t10 += e16[Se++] + vr(e16))), Zs(e16)) {
    let n = Br(e16);
    return n === "deg" || n === "rad" || n === "turn" || n === "grad" ? { type: ce.Hue, value: t10 * _g[n] } : void 0;
  }
  return e16[Se] === "%" ? (Se++, { type: ce.Percentage, value: +t10 }) : { type: ce.Number, value: +t10 };
}
function vr(e16) {
  let t10 = "";
  for (; /\d/.test(e16[Se]); )
    t10 += e16[Se++];
  return t10;
}
function Br(e16) {
  let t10 = "";
  for (; Se < e16.length && bg.test(e16[Se]); )
    t10 += e16[Se++];
  return t10;
}
function wg(e16) {
  let t10 = Br(e16);
  return e16[Se] === "(" ? (Se++, { type: ce.Function, value: t10 }) : t10 === "none" ? { type: ce.None, value: void 0 } : { type: ce.Ident, value: t10 };
}
function Tg(e16 = "") {
  let t10 = e16.trim(), n = [], o;
  for (Se = 0; Se < t10.length; ) {
    if (o = t10[Se++], o === `
` || o === "	" || o === " ") {
      for (; Se < t10.length && (t10[Se] === `
` || t10[Se] === "	" || t10[Se] === " "); )
        Se++;
      continue;
    }
    if (o === ",")
      return;
    if (o === ")") {
      n.push({ type: ce.ParenClose });
      continue;
    }
    if (o === "+") {
      if (Se--, gr(t10)) {
        n.push(Ma(t10));
        continue;
      }
      return;
    }
    if (o === "-") {
      if (Se--, gr(t10)) {
        n.push(Ma(t10));
        continue;
      }
      if (Zs(t10)) {
        n.push({ type: ce.Ident, value: Br(t10) });
        continue;
      }
      return;
    }
    if (o === ".") {
      if (Se--, gr(t10)) {
        n.push(Ma(t10));
        continue;
      }
      return;
    }
    if (o === "/") {
      for (; Se < t10.length && (t10[Se] === `
` || t10[Se] === "	" || t10[Se] === " "); )
        Se++;
      let r;
      if (gr(t10) && (r = Ma(t10), r.type !== ce.Hue)) {
        n.push({ type: ce.Alpha, value: r });
        continue;
      }
      if (Zs(t10) && Br(t10) === "none") {
        n.push({
          type: ce.Alpha,
          value: { type: ce.None, value: void 0 }
        });
        continue;
      }
      return;
    }
    if (/\d/.test(o)) {
      Se--, n.push(Ma(t10));
      continue;
    }
    if (Bs.test(o)) {
      Se--, n.push(wg(t10));
      continue;
    }
    return;
  }
  return n;
}
function Cg(e16) {
  e16._i = 0;
  let t10 = e16[e16._i++];
  if (!t10 || t10.type !== ce.Function || t10.value !== "color" || (t10 = e16[e16._i++], t10.type !== ce.Ident))
    return;
  const n = Nd[t10.value];
  if (!n)
    return;
  const o = { mode: n }, r = Md(e16, false);
  if (!r)
    return;
  const a = vg(n).channels;
  for (let i = 0, s, l; i < a.length; i++)
    s = r[i], l = a[i], s.type !== ce.None && (o[l] = s.type === ce.Number ? s.value : s.value / 100, l === "alpha" && (o[l] = Math.max(0, Math.min(1, o[l]))));
  return o;
}
function Md(e16, t10) {
  const n = [];
  let o;
  for (; e16._i < e16.length; ) {
    if (o = e16[e16._i++], o.type === ce.None || o.type === ce.Number || o.type === ce.Alpha || o.type === ce.Percentage || t10 && o.type === ce.Hue) {
      n.push(o);
      continue;
    }
    if (o.type === ce.ParenClose) {
      if (e16._i < e16.length)
        return;
      continue;
    }
    return;
  }
  if (!(n.length < 3 || n.length > 4)) {
    if (n.length === 4) {
      if (n[3].type !== ce.Alpha)
        return;
      n[3] = n[3].value;
    }
    return n.length === 3 && n.push({ type: ce.None, value: void 0 }), n.every((r) => r.type !== ce.Alpha) ? n : void 0;
  }
}
function kg(e16, t10) {
  e16._i = 0;
  let n = e16[e16._i++];
  if (!n || n.type !== ce.Function)
    return;
  let o = Md(e16, t10);
  if (o)
    return o.unshift(n.value), o;
}
var $d = (e16) => {
  if (typeof e16 != "string")
    return;
  const t10 = Tg(e16), n = t10 ? kg(t10, true) : void 0;
  let o, r = 0, a = Or.length;
  for (; r < a; )
    if ((o = Or[r++](e16, n)) !== void 0)
      return o;
  return t10 ? Cg(t10) : void 0;
};
function Sg(e16, t10) {
  if (!t10 || t10[0] !== "rgb" && t10[0] !== "rgba")
    return;
  const n = { mode: "rgb" }, [, o, r, a, i] = t10;
  if (!(o.type === ce.Hue || r.type === ce.Hue || a.type === ce.Hue))
    return o.type !== ce.None && (n.r = o.type === ce.Number ? o.value / 255 : o.value / 100), r.type !== ce.None && (n.g = r.type === ce.Number ? r.value / 255 : r.value / 100), a.type !== ce.None && (n.b = a.type === ce.Number ? a.value / 255 : a.value / 100), i.type !== ce.None && (n.alpha = Math.min(
      1,
      Math.max(
        0,
        i.type === ce.Number ? i.value : i.value / 100
      )
    )), n;
}
var Ng = (e16) => e16 === "transparent" ? { mode: "rgb", r: 0, g: 0, b: 0, alpha: 0 } : void 0;
var Mg = (e16, t10, n) => e16 + n * (t10 - e16);
var $g = (e16) => {
  let t10 = [];
  for (let n = 0; n < e16.length - 1; n++) {
    let o = e16[n], r = e16[n + 1];
    o === void 0 && r === void 0 ? t10.push(void 0) : o !== void 0 && r !== void 0 ? t10.push([o, r]) : t10.push(o !== void 0 ? [o, o] : [r, r]);
  }
  return t10;
};
var xg = (e16) => (t10) => {
  let n = $g(t10);
  return (o) => {
    let r = o * n.length, a = o >= 1 ? n.length - 1 : Math.max(Math.floor(r), 0), i = n[a];
    return i === void 0 ? void 0 : e16(i[0], i[1], r - a);
  };
};
var ve = xg(Mg);
var Mt = (e16) => {
  let t10 = false, n = e16.map((o) => o !== void 0 ? (t10 = true, o) : 1);
  return t10 ? n : e16;
};
var ga = {
  mode: "rgb",
  channels: ["r", "g", "b", "alpha"],
  parse: [
    Sg,
    ug,
    pg,
    lg,
    Ng,
    "srgb"
  ],
  serialize: "srgb",
  interpolate: {
    r: ve,
    g: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  },
  gamut: true,
  white: { r: 1, g: 1, b: 1 },
  black: { r: 0, g: 0, b: 0 }
};
var Ui = (e16 = 0) => Math.pow(Math.abs(e16), 563 / 256) * Math.sign(e16);
var Lc = (e16) => {
  let t10 = Ui(e16.r), n = Ui(e16.g), o = Ui(e16.b), r = {
    mode: "xyz65",
    x: 0.5766690429101305 * t10 + 0.1855582379065463 * n + 0.1882286462349947 * o,
    y: 0.297344975250536 * t10 + 0.6273635662554661 * n + 0.0752914584939979 * o,
    z: 0.0270313613864123 * t10 + 0.0706888525358272 * n + 0.9913375368376386 * o
  };
  return e16.alpha !== void 0 && (r.alpha = e16.alpha), r;
};
var Gi = (e16) => Math.pow(Math.abs(e16), 256 / 563) * Math.sign(e16);
var Fc = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = {
    mode: "a98",
    r: Gi(
      e16 * 2.0415879038107465 - t10 * 0.5650069742788597 - 0.3447313507783297 * n
    ),
    g: Gi(
      e16 * -0.9692436362808798 + t10 * 1.8759675015077206 + 0.0415550574071756 * n
    ),
    b: Gi(
      e16 * 0.0134442806320312 - t10 * 0.1183623922310184 + 1.0151749943912058 * n
    )
  };
  return o !== void 0 && (r.alpha = o), r;
};
var Xi = (e16 = 0) => {
  const t10 = Math.abs(e16);
  return t10 <= 0.04045 ? e16 / 12.92 : (Math.sign(e16) || 1) * Math.pow((t10 + 0.055) / 1.055, 2.4);
};
var va = ({ r: e16, g: t10, b: n, alpha: o }) => {
  let r = {
    mode: "lrgb",
    r: Xi(e16),
    g: Xi(t10),
    b: Xi(n)
  };
  return o !== void 0 && (r.alpha = o), r;
};
var Ko = (e16) => {
  let { r: t10, g: n, b: o, alpha: r } = va(e16), a = {
    mode: "xyz65",
    x: 0.4123907992659593 * t10 + 0.357584339383878 * n + 0.1804807884018343 * o,
    y: 0.2126390058715102 * t10 + 0.715168678767756 * n + 0.0721923153607337 * o,
    z: 0.0193308187155918 * t10 + 0.119194779794626 * n + 0.9505321522496607 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var Yi = (e16 = 0) => {
  const t10 = Math.abs(e16);
  return t10 > 31308e-7 ? (Math.sign(e16) || 1) * (1.055 * Math.pow(t10, 1 / 2.4) - 0.055) : e16 * 12.92;
};
var ya = ({ r: e16, g: t10, b: n, alpha: o }, r = "rgb") => {
  let a = {
    mode: r,
    r: Yi(e16),
    g: Yi(t10),
    b: Yi(n)
  };
  return o !== void 0 && (a.alpha = o), a;
};
var zo = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = ya({
    r: e16 * 3.2409699419045226 - t10 * 1.537383177570094 - 0.4986107602930034 * n,
    g: e16 * -0.9692436362808796 + t10 * 1.8759675015077204 + 0.0415550574071756 * n,
    b: e16 * 0.0556300796969936 - t10 * 0.2039769588889765 + 1.0569715142428784 * n
  });
  return o !== void 0 && (r.alpha = o), r;
};
var Ig = {
  ...ga,
  mode: "a98",
  parse: ["a98-rgb"],
  serialize: "a98-rgb",
  fromMode: {
    rgb: (e16) => Fc(Ko(e16)),
    xyz65: Fc
  },
  toMode: {
    rgb: (e16) => zo(Lc(e16)),
    xyz65: Lc
  }
};
var At = (e16) => (e16 = e16 % 360) < 0 ? e16 + 360 : e16;
var Dg = (e16, t10) => e16.map((n, o, r) => {
  if (n === void 0)
    return n;
  let a = At(n);
  return o === 0 || e16[o - 1] === void 0 ? a : t10(a - At(r[o - 1]));
}).reduce((n, o) => !n.length || o === void 0 || n[n.length - 1] === void 0 ? (n.push(o), n) : (n.push(o + n[n.length - 1]), n), []);
var Fn = (e16) => Dg(e16, (t10) => Math.abs(t10) <= 180 ? t10 : t10 - 360 * Math.sign(t10));
var xt = [-0.14861, 1.78277, -0.29227, -0.90649, 1.97294, 0];
var Ag = Math.PI / 180;
var Eg = 180 / Math.PI;
var jc = xt[3] * xt[4];
var Oc = xt[1] * xt[4];
var Bc = xt[1] * xt[2] - xt[0] * xt[3];
var Kg = ({ r: e16, g: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = (Bc * n + e16 * jc - t10 * Oc) / (Bc + jc - Oc), a = n - r, i = (xt[4] * (t10 - r) - xt[2] * a) / xt[3], s = {
    mode: "cubehelix",
    l: r,
    s: r === 0 || r === 1 ? void 0 : Math.sqrt(a * a + i * i) / (xt[4] * r * (1 - r))
  };
  return s.s && (s.h = Math.atan2(i, a) * Eg - 120), o !== void 0 && (s.alpha = o), s;
};
var zg = ({ h: e16, s: t10, l: n, alpha: o }) => {
  let r = { mode: "rgb" };
  e16 = (e16 === void 0 ? 0 : e16 + 120) * Ag, n === void 0 && (n = 0);
  let a = t10 === void 0 ? 0 : t10 * n * (1 - n), i = Math.cos(e16), s = Math.sin(e16);
  return r.r = n + a * (xt[0] * i + xt[1] * s), r.g = n + a * (xt[2] * i + xt[3] * s), r.b = n + a * (xt[4] * i + xt[5] * s), o !== void 0 && (r.alpha = o), r;
};
var si = (e16, t10) => {
  if (e16.h === void 0 || t10.h === void 0 || !e16.s || !t10.s)
    return 0;
  let n = At(e16.h), o = At(t10.h), r = Math.sin((o - n + 360) / 2 * Math.PI / 180);
  return 2 * Math.sqrt(e16.s * t10.s) * r;
};
var Pg = (e16, t10) => {
  if (e16.h === void 0 || t10.h === void 0)
    return 0;
  let n = At(e16.h), o = At(t10.h);
  return Math.abs(o - n) > 180 ? n - (o - 360 * Math.sign(o - n)) : o - n;
};
var li = (e16, t10) => {
  if (e16.h === void 0 || t10.h === void 0 || !e16.c || !t10.c)
    return 0;
  let n = At(e16.h), o = At(t10.h), r = Math.sin((o - n + 360) / 2 * Math.PI / 180);
  return 2 * Math.sqrt(e16.c * t10.c) * r;
};
var jn = (e16) => {
  let t10 = e16.reduce(
    (o, r) => {
      if (r !== void 0) {
        let a = r * Math.PI / 180;
        o.sin += Math.sin(a), o.cos += Math.cos(a);
      }
      return o;
    },
    { sin: 0, cos: 0 }
  ), n = Math.atan2(t10.sin, t10.cos) * 180 / Math.PI;
  return n < 0 ? 360 + n : n;
};
var Rg = {
  mode: "cubehelix",
  channels: ["h", "s", "l", "alpha"],
  parse: ["--cubehelix"],
  serialize: "--cubehelix",
  ranges: {
    h: [0, 360],
    s: [0, 4.614],
    l: [0, 1]
  },
  fromMode: {
    rgb: Kg
  },
  toMode: {
    rgb: zg
  },
  interpolate: {
    h: {
      use: ve,
      fixup: Fn
    },
    s: ve,
    l: ve,
    alpha: {
      use: ve,
      fixup: Mt
    }
  },
  difference: {
    h: si
  },
  average: {
    h: jn
  }
};
var to = ({ l: e16, a: t10, b: n, alpha: o }, r = "lch") => {
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let a = Math.sqrt(t10 * t10 + n * n), i = { mode: r, l: e16, c: a };
  return a && (i.h = At(Math.atan2(n, t10) * 180 / Math.PI)), o !== void 0 && (i.alpha = o), i;
};
var no = ({ l: e16, c: t10, h: n, alpha: o }, r = "lab") => {
  n === void 0 && (n = 0);
  let a = {
    mode: r,
    l: e16,
    a: t10 ? t10 * Math.cos(n / 180 * Math.PI) : 0,
    b: t10 ? t10 * Math.sin(n / 180 * Math.PI) : 0
  };
  return o !== void 0 && (a.alpha = o), a;
};
var xd = Math.pow(29, 3) / Math.pow(3, 3);
var Id = Math.pow(6, 3) / Math.pow(29, 3);
var Ct = {
  X: 0.3457 / 0.3585,
  Y: 1,
  Z: (1 - 0.3457 - 0.3585) / 0.3585
};
var ta = {
  X: 0.3127 / 0.329,
  Y: 1,
  Z: (1 - 0.3127 - 0.329) / 0.329
};
var Qi = (e16) => Math.pow(e16, 3) > Id ? Math.pow(e16, 3) : (116 * e16 - 16) / xd;
var Dd = ({ l: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = (e16 + 16) / 116, a = t10 / 500 + r, i = r - n / 200, s = {
    mode: "xyz65",
    x: Qi(a) * ta.X,
    y: Qi(r) * ta.Y,
    z: Qi(i) * ta.Z
  };
  return o !== void 0 && (s.alpha = o), s;
};
var ci = (e16) => zo(Dd(e16));
var Ji = (e16) => e16 > Id ? Math.cbrt(e16) : (xd * e16 + 16) / 116;
var Ad = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Ji(e16 / ta.X), a = Ji(t10 / ta.Y), i = Ji(n / ta.Z), s = {
    mode: "lab65",
    l: 116 * a - 16,
    a: 500 * (r - a),
    b: 200 * (a - i)
  };
  return o !== void 0 && (s.alpha = o), s;
};
var ui = (e16) => {
  let t10 = Ad(Ko(e16));
  return e16.r === e16.b && e16.b === e16.g && (t10.a = t10.b = 0), t10;
};
var Zr = 1;
var Ed = 1;
var Va = 26 / 180 * Math.PI;
var Wr = Math.cos(Va);
var qr = Math.sin(Va);
var Kd = 100 / Math.log(139 / 100);
var Ws = ({ l: e16, c: t10, h: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = {
    mode: "lab65",
    l: (Math.exp(e16 * Zr / Kd) - 1) / 39e-4
  }, a = (Math.exp(0.0435 * t10 * Ed * Zr) - 1) / 0.075, i = a * Math.cos(n / 180 * Math.PI - Va), s = a * Math.sin(n / 180 * Math.PI - Va);
  return r.a = i * Wr - s / 0.83 * qr, r.b = i * qr + s / 0.83 * Wr, o !== void 0 && (r.alpha = o), r;
};
var qs = ({ l: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = t10 * Wr + n * qr, a = 0.83 * (n * Wr - t10 * qr), i = Math.sqrt(r * r + a * a), s = {
    mode: "dlch",
    l: Kd / Zr * Math.log(1 + 39e-4 * e16),
    c: Math.log(1 + 0.075 * i) / (0.0435 * Ed * Zr)
  };
  return s.c && (s.h = At((Math.atan2(a, r) + Va) / Math.PI * 180)), o !== void 0 && (s.alpha = o), s;
};
var Zc = (e16) => Ws(to(e16, "dlch"));
var Wc = (e16) => no(qs(e16), "dlab");
var Lg = {
  mode: "dlab",
  parse: ["--din99o-lab"],
  serialize: "--din99o-lab",
  toMode: {
    lab65: Zc,
    rgb: (e16) => ci(Zc(e16))
  },
  fromMode: {
    lab65: Wc,
    rgb: (e16) => Wc(ui(e16))
  },
  channels: ["l", "a", "b", "alpha"],
  ranges: {
    l: [0, 100],
    a: [-40.09, 45.501],
    b: [-40.469, 44.344]
  },
  interpolate: {
    l: ve,
    a: ve,
    b: ve,
    alpha: {
      use: ve,
      fixup: Mt
    }
  }
};
var Fg = {
  mode: "dlch",
  parse: ["--din99o-lch"],
  serialize: "--din99o-lch",
  toMode: {
    lab65: Ws,
    dlab: (e16) => no(e16, "dlab"),
    rgb: (e16) => ci(Ws(e16))
  },
  fromMode: {
    lab65: qs,
    dlab: (e16) => to(e16, "dlch"),
    rgb: (e16) => qs(ui(e16))
  },
  channels: ["l", "c", "h", "alpha"],
  ranges: {
    l: [0, 100],
    c: [0, 51.484],
    h: [0, 360]
  },
  interpolate: {
    l: ve,
    c: ve,
    h: {
      use: ve,
      fixup: Fn
    },
    alpha: {
      use: ve,
      fixup: Mt
    }
  },
  difference: {
    h: li
  },
  average: {
    h: jn
  }
};
function jg({ h: e16, s: t10, i: n, alpha: o }) {
  e16 = At(e16 !== void 0 ? e16 : 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.abs(e16 / 60 % 2 - 1), a;
  switch (Math.floor(e16 / 60)) {
    case 0:
      a = {
        r: n * (1 + t10 * (3 / (2 - r) - 1)),
        g: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1)),
        b: n * (1 - t10)
      };
      break;
    case 1:
      a = {
        r: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1)),
        g: n * (1 + t10 * (3 / (2 - r) - 1)),
        b: n * (1 - t10)
      };
      break;
    case 2:
      a = {
        r: n * (1 - t10),
        g: n * (1 + t10 * (3 / (2 - r) - 1)),
        b: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1))
      };
      break;
    case 3:
      a = {
        r: n * (1 - t10),
        g: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1)),
        b: n * (1 + t10 * (3 / (2 - r) - 1))
      };
      break;
    case 4:
      a = {
        r: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1)),
        g: n * (1 - t10),
        b: n * (1 + t10 * (3 / (2 - r) - 1))
      };
      break;
    case 5:
      a = {
        r: n * (1 + t10 * (3 / (2 - r) - 1)),
        g: n * (1 - t10),
        b: n * (1 + t10 * (3 * (1 - r) / (2 - r) - 1))
      };
      break;
    default:
      a = { r: n * (1 - t10), g: n * (1 - t10), b: n * (1 - t10) };
  }
  return a.mode = "rgb", o !== void 0 && (a.alpha = o), a;
}
function Og({ r: e16, g: t10, b: n, alpha: o }) {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.max(e16, t10, n), a = Math.min(e16, t10, n), i = {
    mode: "hsi",
    s: e16 + t10 + n === 0 ? 0 : 1 - 3 * a / (e16 + t10 + n),
    i: (e16 + t10 + n) / 3
  };
  return r - a !== 0 && (i.h = (r === e16 ? (t10 - n) / (r - a) + (t10 < n) * 6 : r === t10 ? (n - e16) / (r - a) + 2 : (e16 - t10) / (r - a) + 4) * 60), o !== void 0 && (i.alpha = o), i;
}
var Bg = {
  mode: "hsi",
  toMode: {
    rgb: jg
  },
  parse: ["--hsi"],
  serialize: "--hsi",
  fromMode: {
    rgb: Og
  },
  channels: ["h", "s", "i", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  interpolate: {
    h: { use: ve, fixup: Fn },
    s: ve,
    i: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: si
  },
  average: {
    h: jn
  }
};
function Zg({ h: e16, s: t10, l: n, alpha: o }) {
  e16 = At(e16 !== void 0 ? e16 : 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = n + t10 * (n < 0.5 ? n : 1 - n), a = r - (r - n) * 2 * Math.abs(e16 / 60 % 2 - 1), i;
  switch (Math.floor(e16 / 60)) {
    case 0:
      i = { r, g: a, b: 2 * n - r };
      break;
    case 1:
      i = { r: a, g: r, b: 2 * n - r };
      break;
    case 2:
      i = { r: 2 * n - r, g: r, b: a };
      break;
    case 3:
      i = { r: 2 * n - r, g: a, b: r };
      break;
    case 4:
      i = { r: a, g: 2 * n - r, b: r };
      break;
    case 5:
      i = { r, g: 2 * n - r, b: a };
      break;
    default:
      i = { r: 2 * n - r, g: 2 * n - r, b: 2 * n - r };
  }
  return i.mode = "rgb", o !== void 0 && (i.alpha = o), i;
}
function Wg({ r: e16, g: t10, b: n, alpha: o }) {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.max(e16, t10, n), a = Math.min(e16, t10, n), i = {
    mode: "hsl",
    s: r === a ? 0 : (r - a) / (1 - Math.abs(r + a - 1)),
    l: 0.5 * (r + a)
  };
  return r - a !== 0 && (i.h = (r === e16 ? (t10 - n) / (r - a) + (t10 < n) * 6 : r === t10 ? (n - e16) / (r - a) + 2 : (e16 - t10) / (r - a) + 4) * 60), o !== void 0 && (i.alpha = o), i;
}
var qg = (e16, t10) => {
  switch (t10) {
    case "deg":
      return +e16;
    case "rad":
      return e16 / Math.PI * 180;
    case "grad":
      return e16 / 10 * 9;
    case "turn":
      return e16 * 360;
  }
};
var Vg = new RegExp(
  `^hsla?\\(\\s*${dg}${ua}${Pa}${ua}${Pa}\\s*(?:,\\s*${Ll}\\s*)?\\)$`
);
var Hg = (e16) => {
  let t10 = e16.match(Vg);
  if (!t10) return;
  let n = { mode: "hsl" };
  return t10[3] !== void 0 ? n.h = +t10[3] : t10[1] !== void 0 && t10[2] !== void 0 && (n.h = qg(t10[1], t10[2])), t10[4] !== void 0 && (n.s = Math.min(Math.max(0, t10[4] / 100), 1)), t10[5] !== void 0 && (n.l = Math.min(Math.max(0, t10[5] / 100), 1)), t10[6] !== void 0 ? n.alpha = Math.max(0, Math.min(1, t10[6] / 100)) : t10[7] !== void 0 && (n.alpha = Math.max(0, Math.min(1, +t10[7]))), n;
};
function Ug(e16, t10) {
  if (!t10 || t10[0] !== "hsl" && t10[0] !== "hsla")
    return;
  const n = { mode: "hsl" }, [, o, r, a, i] = t10;
  if (o.type !== ce.None) {
    if (o.type === ce.Percentage)
      return;
    n.h = o.value;
  }
  if (r.type !== ce.None) {
    if (r.type === ce.Hue)
      return;
    n.s = r.value / 100;
  }
  if (a.type !== ce.None) {
    if (a.type === ce.Hue)
      return;
    n.l = a.value / 100;
  }
  return i.type !== ce.None && (n.alpha = Math.min(
    1,
    Math.max(
      0,
      i.type === ce.Number ? i.value : i.value / 100
    )
  )), n;
}
var zd = {
  mode: "hsl",
  toMode: {
    rgb: Zg
  },
  fromMode: {
    rgb: Wg
  },
  channels: ["h", "s", "l", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  parse: [Ug, Hg],
  serialize: (e16) => `hsl(${e16.h !== void 0 ? e16.h : "none"} ${e16.s !== void 0 ? e16.s * 100 + "%" : "none"} ${e16.l !== void 0 ? e16.l * 100 + "%" : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  interpolate: {
    h: { use: ve, fixup: Fn },
    s: ve,
    l: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: si
  },
  average: {
    h: jn
  }
};
function Pd({ h: e16, s: t10, v: n, alpha: o }) {
  e16 = At(e16 !== void 0 ? e16 : 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.abs(e16 / 60 % 2 - 1), a;
  switch (Math.floor(e16 / 60)) {
    case 0:
      a = { r: n, g: n * (1 - t10 * r), b: n * (1 - t10) };
      break;
    case 1:
      a = { r: n * (1 - t10 * r), g: n, b: n * (1 - t10) };
      break;
    case 2:
      a = { r: n * (1 - t10), g: n, b: n * (1 - t10 * r) };
      break;
    case 3:
      a = { r: n * (1 - t10), g: n * (1 - t10 * r), b: n };
      break;
    case 4:
      a = { r: n * (1 - t10 * r), g: n * (1 - t10), b: n };
      break;
    case 5:
      a = { r: n, g: n * (1 - t10), b: n * (1 - t10 * r) };
      break;
    default:
      a = { r: n * (1 - t10), g: n * (1 - t10), b: n * (1 - t10) };
  }
  return a.mode = "rgb", o !== void 0 && (a.alpha = o), a;
}
function Rd({ r: e16, g: t10, b: n, alpha: o }) {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.max(e16, t10, n), a = Math.min(e16, t10, n), i = {
    mode: "hsv",
    s: r === 0 ? 0 : 1 - a / r,
    v: r
  };
  return r - a !== 0 && (i.h = (r === e16 ? (t10 - n) / (r - a) + (t10 < n) * 6 : r === t10 ? (n - e16) / (r - a) + 2 : (e16 - t10) / (r - a) + 4) * 60), o !== void 0 && (i.alpha = o), i;
}
var Ld = {
  mode: "hsv",
  toMode: {
    rgb: Pd
  },
  parse: ["--hsv"],
  serialize: "--hsv",
  fromMode: {
    rgb: Rd
  },
  channels: ["h", "s", "v", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  interpolate: {
    h: { use: ve, fixup: Fn },
    s: ve,
    v: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: si
  },
  average: {
    h: jn
  }
};
function Gg({ h: e16, w: t10, b: n, alpha: o }) {
  if (t10 === void 0 && (t10 = 0), n === void 0 && (n = 0), t10 + n > 1) {
    let r = t10 + n;
    t10 /= r, n /= r;
  }
  return Pd({
    h: e16,
    s: n === 1 ? 1 : 1 - t10 / (1 - n),
    v: 1 - n,
    alpha: o
  });
}
function Xg(e16) {
  let t10 = Rd(e16);
  if (t10 === void 0) return;
  let n = t10.s !== void 0 ? t10.s : 0, o = t10.v !== void 0 ? t10.v : 0, r = {
    mode: "hwb",
    w: (1 - n) * o,
    b: 1 - o
  };
  return t10.h !== void 0 && (r.h = t10.h), t10.alpha !== void 0 && (r.alpha = t10.alpha), r;
}
function Yg(e16, t10) {
  if (!t10 || t10[0] !== "hwb")
    return;
  const n = { mode: "hwb" }, [, o, r, a, i] = t10;
  if (o.type !== ce.None) {
    if (o.type === ce.Percentage)
      return;
    n.h = o.value;
  }
  if (r.type !== ce.None) {
    if (r.type === ce.Hue)
      return;
    n.w = r.value / 100;
  }
  if (a.type !== ce.None) {
    if (a.type === ce.Hue)
      return;
    n.b = a.value / 100;
  }
  return i.type !== ce.None && (n.alpha = Math.min(
    1,
    Math.max(
      0,
      i.type === ce.Number ? i.value : i.value / 100
    )
  )), n;
}
var Qg = {
  mode: "hwb",
  toMode: {
    rgb: Gg
  },
  fromMode: {
    rgb: Xg
  },
  channels: ["h", "w", "b", "alpha"],
  ranges: {
    h: [0, 360]
  },
  gamut: "rgb",
  parse: [Yg],
  serialize: (e16) => `hwb(${e16.h !== void 0 ? e16.h : "none"} ${e16.w !== void 0 ? e16.w * 100 + "%" : "none"} ${e16.b !== void 0 ? e16.b * 100 + "%" : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  interpolate: {
    h: { use: ve, fixup: Fn },
    w: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: Pg
  },
  average: {
    h: jn
  }
};
var Fd = 203;
var di = 0.1593017578125;
var jd = 78.84375;
var fi = 0.8359375;
var mi = 18.8515625;
var pi = 18.6875;
function es(e16) {
  if (e16 < 0) return 0;
  const t10 = Math.pow(e16, 1 / jd);
  return 1e4 * Math.pow(Math.max(0, t10 - fi) / (mi - pi * t10), 1 / di);
}
function ts(e16) {
  if (e16 < 0) return 0;
  const t10 = Math.pow(e16 / 1e4, di);
  return Math.pow((fi + mi * t10) / (1 + pi * t10), jd);
}
var ns = (e16) => Math.max(e16 / Fd, 0);
var qc = ({ i: e16, t: t10, p: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  const r = es(
    e16 + 0.008609037037932761 * t10 + 0.11102962500302593 * n
  ), a = es(
    e16 - 0.00860903703793275 * t10 - 0.11102962500302599 * n
  ), i = es(
    e16 + 0.5600313357106791 * t10 - 0.32062717498731885 * n
  ), s = {
    mode: "xyz65",
    x: ns(
      2.070152218389422 * r - 1.3263473389671556 * a + 0.2066510476294051 * i
    ),
    y: ns(
      0.3647385209748074 * r + 0.680566024947227 * a - 0.0453045459220346 * i
    ),
    z: ns(
      -0.049747207535812 * r - 0.0492609666966138 * a + 1.1880659249923042 * i
    )
  };
  return o !== void 0 && (s.alpha = o), s;
};
var os = (e16 = 0) => Math.max(e16 * Fd, 0);
var Vc = ({ x: e16, y: t10, z: n, alpha: o }) => {
  const r = os(e16), a = os(t10), i = os(n), s = ts(
    0.3592832590121217 * r + 0.6976051147779502 * a - 0.0358915932320289 * i
  ), l = ts(
    -0.1920808463704995 * r + 1.1004767970374323 * a + 0.0753748658519118 * i
  ), c = ts(
    0.0070797844607477 * r + 0.0748396662186366 * a + 0.8433265453898765 * i
  ), u = 0.5 * s + 0.5 * l, d = 1.61376953125 * s - 3.323486328125 * l + 1.709716796875 * c, m = 4.378173828125 * s - 4.24560546875 * l - 0.132568359375 * c, p = { mode: "itp", i: u, t: d, p: m };
  return o !== void 0 && (p.alpha = o), p;
};
var Jg = {
  mode: "itp",
  channels: ["i", "t", "p", "alpha"],
  parse: ["--ictcp"],
  serialize: "--ictcp",
  toMode: {
    xyz65: qc,
    rgb: (e16) => zo(qc(e16))
  },
  fromMode: {
    xyz65: Vc,
    rgb: (e16) => Vc(Ko(e16))
  },
  ranges: {
    i: [0, 0.581],
    t: [-0.369, 0.272],
    p: [-0.164, 0.331]
  },
  interpolate: {
    i: ve,
    t: ve,
    p: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var e22 = 134.03437499999998;
var t2 = 16295499532821565e-27;
var as = (e16) => {
  if (e16 < 0) return 0;
  let t10 = Math.pow(e16 / 1e4, di);
  return Math.pow((fi + mi * t10) / (1 + pi * t10), e22);
};
var rs = (e16 = 0) => Math.max(e16 * 203, 0);
var Od = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 = rs(e16), t10 = rs(t10), n = rs(n);
  let r = 1.15 * e16 - 0.15 * n, a = 0.66 * t10 + 0.34 * e16, i = as(0.41478972 * r + 0.579999 * a + 0.014648 * n), s = as(-0.20151 * r + 1.120649 * a + 0.0531008 * n), l = as(-0.0166008 * r + 0.2648 * a + 0.6684799 * n), c = (i + s) / 2, u = {
    mode: "jab",
    j: 0.44 * c / (1 - 0.56 * c) - t2,
    a: 3.524 * i - 4.066708 * s + 0.542708 * l,
    b: 0.199076 * i + 1.096799 * s - 1.295875 * l
  };
  return o !== void 0 && (u.alpha = o), u;
};
var n2 = 134.03437499999998;
var Hc = 16295499532821565e-27;
var is2 = (e16) => {
  if (e16 < 0) return 0;
  let t10 = Math.pow(e16, 1 / n2);
  return 1e4 * Math.pow((fi - t10) / (pi * t10 - mi), 1 / di);
};
var ss = (e16) => e16 / 203;
var Bd = ({ j: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = (e16 + Hc) / (0.44 + 0.56 * (e16 + Hc)), a = is2(r + 0.13860504 * t10 + 0.058047316 * n), i = is2(r - 0.13860504 * t10 - 0.058047316 * n), s = is2(r - 0.096019242 * t10 - 0.8118919 * n), l = {
    mode: "xyz65",
    x: ss(
      1.661373024652174 * a - 0.914523081304348 * i + 0.23136208173913045 * s
    ),
    y: ss(
      -0.3250758611844533 * a + 1.571847026732543 * i - 0.21825383453227928 * s
    ),
    z: ss(-0.090982811 * a - 0.31272829 * i + 1.5227666 * s)
  };
  return o !== void 0 && (l.alpha = o), l;
};
var Zd = (e16) => {
  let t10 = Od(Ko(e16));
  return e16.r === e16.b && e16.b === e16.g && (t10.a = t10.b = 0), t10;
};
var Wd = (e16) => zo(Bd(e16));
var o2 = {
  mode: "jab",
  channels: ["j", "a", "b", "alpha"],
  parse: ["--jzazbz"],
  serialize: "--jzazbz",
  fromMode: {
    rgb: Zd,
    xyz65: Od
  },
  toMode: {
    rgb: Wd,
    xyz65: Bd
  },
  ranges: {
    j: [0, 0.222],
    a: [-0.109, 0.129],
    b: [-0.185, 0.134]
  },
  interpolate: {
    j: ve,
    a: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var Uc = ({ j: e16, a: t10, b: n, alpha: o }) => {
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.sqrt(t10 * t10 + n * n), a = {
    mode: "jch",
    j: e16,
    c: r
  };
  return r && (a.h = At(Math.atan2(n, t10) * 180 / Math.PI)), o !== void 0 && (a.alpha = o), a;
};
var Gc = ({ j: e16, c: t10, h: n, alpha: o }) => {
  n === void 0 && (n = 0);
  let r = {
    mode: "jab",
    j: e16,
    a: t10 ? t10 * Math.cos(n / 180 * Math.PI) : 0,
    b: t10 ? t10 * Math.sin(n / 180 * Math.PI) : 0
  };
  return o !== void 0 && (r.alpha = o), r;
};
var a2 = {
  mode: "jch",
  parse: ["--jzczhz"],
  serialize: "--jzczhz",
  toMode: {
    jab: Gc,
    rgb: (e16) => Wd(Gc(e16))
  },
  fromMode: {
    rgb: (e16) => Uc(Zd(e16)),
    jab: Uc
  },
  channels: ["j", "c", "h", "alpha"],
  ranges: {
    j: [0, 0.221],
    c: [0, 0.19],
    h: [0, 360]
  },
  interpolate: {
    h: { use: ve, fixup: Fn },
    c: ve,
    j: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: li
  },
  average: {
    h: jn
  }
};
var hi = Math.pow(29, 3) / Math.pow(3, 3);
var Fl = Math.pow(6, 3) / Math.pow(29, 3);
var ls = (e16) => Math.pow(e16, 3) > Fl ? Math.pow(e16, 3) : (116 * e16 - 16) / hi;
var jl = ({ l: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = (e16 + 16) / 116, a = t10 / 500 + r, i = r - n / 200, s = {
    mode: "xyz50",
    x: ls(a) * Ct.X,
    y: ls(r) * Ct.Y,
    z: ls(i) * Ct.Z
  };
  return o !== void 0 && (s.alpha = o), s;
};
var tr = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = ya({
    r: e16 * 3.1341359569958707 - t10 * 1.6173863321612538 - 0.4906619460083532 * n,
    g: e16 * -0.978795502912089 + t10 * 1.916254567259524 + 0.03344273116131949 * n,
    b: e16 * 0.07195537988411677 - t10 * 0.2289768264158322 + 1.405386058324125 * n
  });
  return o !== void 0 && (r.alpha = o), r;
};
var qd = (e16) => tr(jl(e16));
var nr = (e16) => {
  let { r: t10, g: n, b: o, alpha: r } = va(e16), a = {
    mode: "xyz50",
    x: 0.436065742824811 * t10 + 0.3851514688337912 * n + 0.14307845442264197 * o,
    y: 0.22249319175623702 * t10 + 0.7168870538238823 * n + 0.06061979053616537 * o,
    z: 0.013923904500943465 * t10 + 0.09708128566574634 * n + 0.7140993584005155 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var cs = (e16) => e16 > Fl ? Math.cbrt(e16) : (hi * e16 + 16) / 116;
var Ol = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = cs(e16 / Ct.X), a = cs(t10 / Ct.Y), i = cs(n / Ct.Z), s = {
    mode: "lab",
    l: 116 * a - 16,
    a: 500 * (r - a),
    b: 200 * (a - i)
  };
  return o !== void 0 && (s.alpha = o), s;
};
var Vd = (e16) => {
  let t10 = Ol(nr(e16));
  return e16.r === e16.b && e16.b === e16.g && (t10.a = t10.b = 0), t10;
};
function r2(e16, t10) {
  if (!t10 || t10[0] !== "lab")
    return;
  const n = { mode: "lab" }, [, o, r, a, i] = t10;
  if (!(o.type === ce.Hue || r.type === ce.Hue || a.type === ce.Hue))
    return o.type !== ce.None && (n.l = Math.min(Math.max(0, o.value), 100)), r.type !== ce.None && (n.a = r.type === ce.Number ? r.value : r.value * 125 / 100), a.type !== ce.None && (n.b = a.type === ce.Number ? a.value : a.value * 125 / 100), i.type !== ce.None && (n.alpha = Math.min(
      1,
      Math.max(
        0,
        i.type === ce.Number ? i.value : i.value / 100
      )
    )), n;
}
var Bl = {
  mode: "lab",
  toMode: {
    xyz50: jl,
    rgb: qd
  },
  fromMode: {
    xyz50: Ol,
    rgb: Vd
  },
  channels: ["l", "a", "b", "alpha"],
  ranges: {
    l: [0, 100],
    a: [-100, 100],
    b: [-100, 100]
  },
  parse: [r2],
  serialize: (e16) => `lab(${e16.l !== void 0 ? e16.l : "none"} ${e16.a !== void 0 ? e16.a : "none"} ${e16.b !== void 0 ? e16.b : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  interpolate: {
    l: ve,
    a: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var i2 = {
  ...Bl,
  mode: "lab65",
  parse: ["--lab-d65"],
  serialize: "--lab-d65",
  toMode: {
    xyz65: Dd,
    rgb: ci
  },
  fromMode: {
    xyz65: Ad,
    rgb: ui
  },
  ranges: {
    l: [0, 100],
    a: [-86.182, 98.234],
    b: [-107.86, 94.477]
  }
};
function s2(e16, t10) {
  if (!t10 || t10[0] !== "lch")
    return;
  const n = { mode: "lch" }, [, o, r, a, i] = t10;
  if (o.type !== ce.None) {
    if (o.type === ce.Hue)
      return;
    n.l = Math.min(Math.max(0, o.value), 100);
  }
  if (r.type !== ce.None && (n.c = Math.max(
    0,
    r.type === ce.Number ? r.value : r.value * 150 / 100
  )), a.type !== ce.None) {
    if (a.type === ce.Percentage)
      return;
    n.h = a.value;
  }
  return i.type !== ce.None && (n.alpha = Math.min(
    1,
    Math.max(
      0,
      i.type === ce.Number ? i.value : i.value / 100
    )
  )), n;
}
var Zl = {
  mode: "lch",
  toMode: {
    lab: no,
    rgb: (e16) => qd(no(e16))
  },
  fromMode: {
    rgb: (e16) => to(Vd(e16)),
    lab: to
  },
  channels: ["l", "c", "h", "alpha"],
  ranges: {
    l: [0, 100],
    c: [0, 150],
    h: [0, 360]
  },
  parse: [s2],
  serialize: (e16) => `lch(${e16.l !== void 0 ? e16.l : "none"} ${e16.c !== void 0 ? e16.c : "none"} ${e16.h !== void 0 ? e16.h : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  interpolate: {
    h: { use: ve, fixup: Fn },
    c: ve,
    l: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: li
  },
  average: {
    h: jn
  }
};
var l2 = {
  ...Zl,
  mode: "lch65",
  parse: ["--lch-d65"],
  serialize: "--lch-d65",
  toMode: {
    lab65: (e16) => no(e16, "lab65"),
    rgb: (e16) => ci(no(e16, "lab65"))
  },
  fromMode: {
    rgb: (e16) => to(ui(e16), "lch65"),
    lab65: (e16) => to(e16, "lch65")
  },
  ranges: {
    l: [0, 100],
    c: [0, 133.807],
    h: [0, 360]
  }
};
var Hd = ({ l: e16, u: t10, v: n, alpha: o }) => {
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.sqrt(t10 * t10 + n * n), a = {
    mode: "lchuv",
    l: e16,
    c: r
  };
  return r && (a.h = At(Math.atan2(n, t10) * 180 / Math.PI)), o !== void 0 && (a.alpha = o), a;
};
var Ud = ({ l: e16, c: t10, h: n, alpha: o }) => {
  n === void 0 && (n = 0);
  let r = {
    mode: "luv",
    l: e16,
    u: t10 ? t10 * Math.cos(n / 180 * Math.PI) : 0,
    v: t10 ? t10 * Math.sin(n / 180 * Math.PI) : 0
  };
  return o !== void 0 && (r.alpha = o), r;
};
var Gd = (e16, t10, n) => 4 * e16 / (e16 + 15 * t10 + 3 * n);
var Xd = (e16, t10, n) => 9 * t10 / (e16 + 15 * t10 + 3 * n);
var c2 = Gd(Ct.X, Ct.Y, Ct.Z);
var u2 = Xd(Ct.X, Ct.Y, Ct.Z);
var d2 = (e16) => e16 <= Fl ? hi * e16 : 116 * Math.cbrt(e16) - 16;
var Vs = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = d2(t10 / Ct.Y), a = Gd(e16, t10, n), i = Xd(e16, t10, n);
  !isFinite(a) || !isFinite(i) ? r = a = i = 0 : (a = 13 * r * (a - c2), i = 13 * r * (i - u2));
  let s = {
    mode: "luv",
    l: r,
    u: a,
    v: i
  };
  return o !== void 0 && (s.alpha = o), s;
};
var f2 = (e16, t10, n) => 4 * e16 / (e16 + 15 * t10 + 3 * n);
var m2 = (e16, t10, n) => 9 * t10 / (e16 + 15 * t10 + 3 * n);
var p2 = f2(Ct.X, Ct.Y, Ct.Z);
var h2 = m2(Ct.X, Ct.Y, Ct.Z);
var Hs = ({ l: e16, u: t10, v: n, alpha: o }) => {
  if (e16 === void 0 && (e16 = 0), e16 === 0)
    return { mode: "xyz50", x: 0, y: 0, z: 0 };
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = t10 / (13 * e16) + p2, a = n / (13 * e16) + h2, i = Ct.Y * (e16 <= 8 ? e16 / hi : Math.pow((e16 + 16) / 116, 3)), s = i * (9 * r) / (4 * a), l = i * (12 - 3 * r - 20 * a) / (4 * a), c = { mode: "xyz50", x: s, y: i, z: l };
  return o !== void 0 && (c.alpha = o), c;
};
var g2 = (e16) => Hd(Vs(nr(e16)));
var v2 = (e16) => tr(Hs(Ud(e16)));
var y2 = {
  mode: "lchuv",
  toMode: {
    luv: Ud,
    rgb: v2
  },
  fromMode: {
    rgb: g2,
    luv: Hd
  },
  channels: ["l", "c", "h", "alpha"],
  parse: ["--lchuv"],
  serialize: "--lchuv",
  ranges: {
    l: [0, 100],
    c: [0, 176.956],
    h: [0, 360]
  },
  interpolate: {
    h: { use: ve, fixup: Fn },
    c: ve,
    l: ve,
    alpha: { use: ve, fixup: Mt }
  },
  difference: {
    h: li
  },
  average: {
    h: jn
  }
};
var b2 = {
  ...ga,
  mode: "lrgb",
  toMode: {
    rgb: ya
  },
  fromMode: {
    rgb: va
  },
  parse: ["srgb-linear"],
  serialize: "srgb-linear"
};
var _2 = {
  mode: "luv",
  toMode: {
    xyz50: Hs,
    rgb: (e16) => tr(Hs(e16))
  },
  fromMode: {
    xyz50: Vs,
    rgb: (e16) => Vs(nr(e16))
  },
  channels: ["l", "u", "v", "alpha"],
  parse: ["--luv"],
  serialize: "--luv",
  ranges: {
    l: [0, 100],
    u: [-84.936, 175.042],
    v: [-125.882, 87.243]
  },
  interpolate: {
    l: ve,
    u: ve,
    v: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var Yd = ({ r: e16, g: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.cbrt(
    0.41222147079999993 * e16 + 0.5363325363 * t10 + 0.0514459929 * n
  ), a = Math.cbrt(
    0.2119034981999999 * e16 + 0.6806995450999999 * t10 + 0.1073969566 * n
  ), i = Math.cbrt(
    0.08830246189999998 * e16 + 0.2817188376 * t10 + 0.6299787005000002 * n
  ), s = {
    mode: "oklab",
    l: 0.2104542553 * r + 0.793617785 * a - 0.0040720468 * i,
    a: 1.9779984951 * r - 2.428592205 * a + 0.4505937099 * i,
    b: 0.0259040371 * r + 0.7827717662 * a - 0.808675766 * i
  };
  return o !== void 0 && (s.alpha = o), s;
};
var gi = (e16) => {
  let t10 = Yd(va(e16));
  return e16.r === e16.b && e16.b === e16.g && (t10.a = t10.b = 0), t10;
};
var or = ({ l: e16, a: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = Math.pow(
    e16 * 0.9999999984505198 + 0.39633779217376786 * t10 + 0.2158037580607588 * n,
    3
  ), a = Math.pow(
    e16 * 1.0000000088817609 - 0.10556134232365635 * t10 - 0.06385417477170591 * n,
    3
  ), i = Math.pow(
    e16 * 1.0000000546724108 - 0.08948418209496575 * t10 - 1.2914855378640917 * n,
    3
  ), s = {
    mode: "lrgb",
    r: 4.076741661347994 * r - 3.307711590408193 * a + 0.230969928729428 * i,
    g: -1.2684380040921763 * r + 2.6097574006633715 * a - 0.3413193963102197 * i,
    b: -0.004196086541837188 * r - 0.7034186144594493 * a + 1.7076147009309444 * i
  };
  return o !== void 0 && (s.alpha = o), s;
};
var vi = (e16) => ya(or(e16));
function Us(e16) {
  const o = 1.170873786407767;
  return 0.5 * (o * e16 - 0.206 + Math.sqrt((o * e16 - 0.206) * (o * e16 - 0.206) + 4 * 0.03 * o * e16));
}
function Vr(e16) {
  return (e16 * e16 + 0.206 * e16) / (1.170873786407767 * (e16 + 0.03));
}
function w2(e16, t10) {
  let n, o, r, a, i, s, l, c;
  -1.88170328 * e16 - 0.80936493 * t10 > 1 ? (n = 1.19086277, o = 1.76576728, r = 0.59662641, a = 0.75515197, i = 0.56771245, s = 4.0767416621, l = -3.3077115913, c = 0.2309699292) : 1.81444104 * e16 - 1.19445276 * t10 > 1 ? (n = 0.73956515, o = -0.45954404, r = 0.08285427, a = 0.1254107, i = 0.14503204, s = -1.2684380046, l = 2.6097574011, c = -0.3413193965) : (n = 1.35733652, o = -915799e-8, r = -1.1513021, a = -0.50559606, i = 692167e-8, s = -0.0041960863, l = -0.7034186147, c = 1.707614701);
  let u = n + o * e16 + r * t10 + a * e16 * e16 + i * e16 * t10, d = 0.3963377774 * e16 + 0.2158037573 * t10, m = -0.1055613458 * e16 - 0.0638541728 * t10, p = -0.0894841775 * e16 - 1.291485548 * t10;
  {
    let f = 1 + u * d, h10 = 1 + u * m, g = 1 + u * p, v = f * f * f, y = h10 * h10 * h10, k = g * g * g, T = 3 * d * f * f, w = 3 * m * h10 * h10, _ = 3 * p * g * g, M = 6 * d * d * f, x = 6 * m * m * h10, R = 6 * p * p * g, I = s * v + l * y + c * k, P = s * T + l * w + c * _, F = s * M + l * x + c * R;
    u = u - I * P / (P * P - 0.5 * I * F);
  }
  return u;
}
function Wl(e16, t10) {
  let n = w2(e16, t10), o = or({ l: 1, a: n * e16, b: n * t10 }), r = Math.cbrt(1 / Math.max(o.r, o.g, o.b)), a = r * n;
  return [r, a];
}
function T2(e16, t10, n, o, r, a = null) {
  a || (a = Wl(e16, t10));
  let i;
  if ((n - r) * a[1] - (a[0] - r) * o <= 0)
    i = a[1] * r / (o * a[0] + a[1] * (r - n));
  else {
    i = a[1] * (r - 1) / (o * (a[0] - 1) + a[1] * (r - n));
    {
      let s = n - r, l = o, c = 0.3963377774 * e16 + 0.2158037573 * t10, u = -0.1055613458 * e16 - 0.0638541728 * t10, d = -0.0894841775 * e16 - 1.291485548 * t10, m = s + l * c, p = s + l * u, f = s + l * d;
      {
        let h10 = r * (1 - i) + i * n, g = i * o, v = h10 + g * c, y = h10 + g * u, k = h10 + g * d, T = v * v * v, w = y * y * y, _ = k * k * k, M = 3 * m * v * v, x = 3 * p * y * y, R = 3 * f * k * k, I = 6 * m * m * v, P = 6 * p * p * y, F = 6 * f * f * k, N = 4.0767416621 * T - 3.3077115913 * w + 0.2309699292 * _ - 1, j = 4.0767416621 * M - 3.3077115913 * x + 0.2309699292 * R, z = 4.0767416621 * I - 3.3077115913 * P + 0.2309699292 * F, A = j / (j * j - 0.5 * N * z), B = -N * A, D = -1.2684380046 * T + 2.6097574011 * w - 0.3413193965 * _ - 1, te = -1.2684380046 * M + 2.6097574011 * x - 0.3413193965 * R, ie = -1.2684380046 * I + 2.6097574011 * P - 0.3413193965 * F, U = te / (te * te - 0.5 * D * ie), oe = -D * U, se = -0.0041960863 * T - 0.7034186147 * w + 1.707614701 * _ - 1, E = -0.0041960863 * M - 0.7034186147 * x + 1.707614701 * R, K = -0.0041960863 * I - 0.7034186147 * P + 1.707614701 * F, ee = E / (E * E - 0.5 * se * K), V = -se * ee;
        B = A >= 0 ? B : 1e6, oe = U >= 0 ? oe : 1e6, V = ee >= 0 ? V : 1e6, i += Math.min(B, Math.min(oe, V));
      }
    }
  }
  return i;
}
function ql(e16, t10, n = null) {
  n || (n = Wl(e16, t10));
  let o = n[0], r = n[1];
  return [r / o, r / (1 - o)];
}
function Qd(e16, t10, n) {
  let o = Wl(t10, n), r = T2(t10, n, e16, 1, e16, o), a = ql(t10, n, o), i = 0.11516993 + 1 / (7.4477897 + 4.1590124 * n + t10 * (-2.19557347 + 1.75198401 * n + t10 * (-2.13704948 - 10.02301043 * n + t10 * (-4.24894561 + 5.38770819 * n + 4.69891013 * t10)))), s = 0.11239642 + 1 / (1.6132032 - 0.68124379 * n + t10 * (0.40370612 + 0.90148123 * n + t10 * (-0.27087943 + 0.6122399 * n + t10 * (299215e-8 - 0.45399568 * n - 0.14661872 * t10)))), l = r / Math.min(e16 * a[0], (1 - e16) * a[1]), c = e16 * i, u = (1 - e16) * s, d = 0.9 * l * Math.sqrt(
    Math.sqrt(
      1 / (1 / (c * c * c * c) + 1 / (u * u * u * u))
    )
  );
  return c = e16 * 0.4, u = (1 - e16) * 0.8, [Math.sqrt(1 / (1 / (c * c) + 1 / (u * u))), d, r];
}
function Xc(e16) {
  const t10 = e16.l !== void 0 ? e16.l : 0, n = e16.a !== void 0 ? e16.a : 0, o = e16.b !== void 0 ? e16.b : 0, r = { mode: "okhsl", l: Us(t10) };
  e16.alpha !== void 0 && (r.alpha = e16.alpha);
  let a = Math.sqrt(n * n + o * o);
  if (!a)
    return r.s = 0, r;
  let [i, s, l] = Qd(t10, n / a, o / a), c;
  if (a < s) {
    let u = 0, d = 0.8 * i, m = 1 - d / s;
    c = (a - u) / (d + m * (a - u)) * 0.8;
  } else {
    let u = s, d = 0.2 * s * s * 1.25 * 1.25 / i, m = 1 - d / (l - s);
    c = 0.8 + 0.2 * ((a - u) / (d + m * (a - u)));
  }
  return c && (r.s = c, r.h = At(Math.atan2(o, n) * 180 / Math.PI)), r;
}
function Yc(e16) {
  let t10 = e16.h !== void 0 ? e16.h : 0, n = e16.s !== void 0 ? e16.s : 0, o = e16.l !== void 0 ? e16.l : 0;
  const r = { mode: "oklab", l: Vr(o) };
  if (e16.alpha !== void 0 && (r.alpha = e16.alpha), !n || o === 1)
    return r.a = r.b = 0, r;
  let a = Math.cos(t10 / 180 * Math.PI), i = Math.sin(t10 / 180 * Math.PI), [s, l, c] = Qd(r.l, a, i), u, d, m, p;
  n < 0.8 ? (u = 1.25 * n, d = 0, m = 0.8 * s, p = 1 - m / l) : (u = 5 * (n - 0.8), d = l, m = 0.2 * l * l * 1.25 * 1.25 / s, p = 1 - m / (c - l));
  let f = d + u * m / (1 - p * u);
  return r.a = f * a, r.b = f * i, r;
}
var C2 = {
  ...zd,
  mode: "okhsl",
  channels: ["h", "s", "l", "alpha"],
  parse: ["--okhsl"],
  serialize: "--okhsl",
  fromMode: {
    oklab: Xc,
    rgb: (e16) => Xc(gi(e16))
  },
  toMode: {
    oklab: Yc,
    rgb: (e16) => vi(Yc(e16))
  }
};
function Qc(e16) {
  let t10 = e16.l !== void 0 ? e16.l : 0, n = e16.a !== void 0 ? e16.a : 0, o = e16.b !== void 0 ? e16.b : 0, r = Math.sqrt(n * n + o * o), a = r ? n / r : 1, i = r ? o / r : 1, [s, l] = ql(a, i), c = 0.5, u = 1 - c / s, d = l / (r + t10 * l), m = d * t10, p = d * r, f = Vr(m), h10 = p * f / m, g = or({ l: f, a: a * h10, b: i * h10 }), v = Math.cbrt(
    1 / Math.max(g.r, g.g, g.b, 0)
  );
  t10 = t10 / v, r = r / v * Us(t10) / t10, t10 = Us(t10);
  const y = {
    mode: "okhsv",
    s: r ? (c + l) * p / (l * c + l * u * p) : 0,
    v: t10 ? t10 / m : 0
  };
  return y.s && (y.h = At(Math.atan2(o, n) * 180 / Math.PI)), e16.alpha !== void 0 && (y.alpha = e16.alpha), y;
}
function Jc(e16) {
  const t10 = { mode: "oklab" };
  e16.alpha !== void 0 && (t10.alpha = e16.alpha);
  const n = e16.h !== void 0 ? e16.h : 0, o = e16.s !== void 0 ? e16.s : 0, r = e16.v !== void 0 ? e16.v : 0, a = Math.cos(n / 180 * Math.PI), i = Math.sin(n / 180 * Math.PI), [s, l] = ql(a, i), c = 0.5, u = 1 - c / s, d = 1 - o * c / (c + l - l * u * o), m = o * l * c / (c + l - l * u * o), p = Vr(d), f = m * p / d, h10 = or({
    l: p,
    a: a * f,
    b: i * f
  }), g = Math.cbrt(
    1 / Math.max(h10.r, h10.g, h10.b, 0)
  ), v = Vr(r * d), y = m * v / d;
  return t10.l = v * g, t10.a = y * a * g, t10.b = y * i * g, t10;
}
var k2 = {
  ...Ld,
  mode: "okhsv",
  channels: ["h", "s", "v", "alpha"],
  parse: ["--okhsv"],
  serialize: "--okhsv",
  fromMode: {
    oklab: Qc,
    rgb: (e16) => Qc(gi(e16))
  },
  toMode: {
    oklab: Jc,
    rgb: (e16) => vi(Jc(e16))
  }
};
function S2(e16, t10) {
  if (!t10 || t10[0] !== "oklab")
    return;
  const n = { mode: "oklab" }, [, o, r, a, i] = t10;
  if (!(o.type === ce.Hue || r.type === ce.Hue || a.type === ce.Hue))
    return o.type !== ce.None && (n.l = Math.min(
      Math.max(0, o.type === ce.Number ? o.value : o.value / 100),
      1
    )), r.type !== ce.None && (n.a = r.type === ce.Number ? r.value : r.value * 0.4 / 100), a.type !== ce.None && (n.b = a.type === ce.Number ? a.value : a.value * 0.4 / 100), i.type !== ce.None && (n.alpha = Math.min(
      1,
      Math.max(
        0,
        i.type === ce.Number ? i.value : i.value / 100
      )
    )), n;
}
var N2 = {
  ...Bl,
  mode: "oklab",
  toMode: {
    lrgb: or,
    rgb: vi
  },
  fromMode: {
    lrgb: Yd,
    rgb: gi
  },
  ranges: {
    l: [0, 1],
    a: [-0.4, 0.4],
    b: [-0.4, 0.4]
  },
  parse: [S2],
  serialize: (e16) => `oklab(${e16.l !== void 0 ? e16.l : "none"} ${e16.a !== void 0 ? e16.a : "none"} ${e16.b !== void 0 ? e16.b : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`
};
function M2(e16, t10) {
  if (!t10 || t10[0] !== "oklch")
    return;
  const n = { mode: "oklch" }, [, o, r, a, i] = t10;
  if (o.type !== ce.None) {
    if (o.type === ce.Hue)
      return;
    n.l = Math.min(
      Math.max(0, o.type === ce.Number ? o.value : o.value / 100),
      1
    );
  }
  if (r.type !== ce.None && (n.c = Math.max(
    0,
    r.type === ce.Number ? r.value : r.value * 0.4 / 100
  )), a.type !== ce.None) {
    if (a.type === ce.Percentage)
      return;
    n.h = a.value;
  }
  return i.type !== ce.None && (n.alpha = Math.min(
    1,
    Math.max(
      0,
      i.type === ce.Number ? i.value : i.value / 100
    )
  )), n;
}
var $2 = {
  ...Zl,
  mode: "oklch",
  toMode: {
    oklab: (e16) => no(e16, "oklab"),
    rgb: (e16) => vi(no(e16, "oklab"))
  },
  fromMode: {
    rgb: (e16) => to(gi(e16), "oklch"),
    oklab: (e16) => to(e16, "oklch")
  },
  parse: [M2],
  serialize: (e16) => `oklch(${e16.l !== void 0 ? e16.l : "none"} ${e16.c !== void 0 ? e16.c : "none"} ${e16.h !== void 0 ? e16.h : "none"}${e16.alpha < 1 ? ` / ${e16.alpha}` : ""})`,
  ranges: {
    l: [0, 1],
    c: [0, 0.4],
    h: [0, 360]
  }
};
var eu = (e16) => {
  let { r: t10, g: n, b: o, alpha: r } = va(e16), a = {
    mode: "xyz65",
    x: 0.486570948648216 * t10 + 0.265667693169093 * n + 0.1982172852343625 * o,
    y: 0.2289745640697487 * t10 + 0.6917385218365062 * n + 0.079286914093745 * o,
    z: 0 * t10 + 0.0451133818589026 * n + 1.043944368900976 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var tu = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = ya(
    {
      r: e16 * 2.4934969119414263 - t10 * 0.9313836179191242 - 0.402710784450717 * n,
      g: e16 * -0.8294889695615749 + t10 * 1.7626640603183465 + 0.0236246858419436 * n,
      b: e16 * 0.0358458302437845 - t10 * 0.0761723892680418 + 0.9568845240076871 * n
    },
    "p3"
  );
  return o !== void 0 && (r.alpha = o), r;
};
var x2 = {
  ...ga,
  mode: "p3",
  parse: ["display-p3"],
  serialize: "display-p3",
  fromMode: {
    rgb: (e16) => tu(Ko(e16)),
    xyz65: tu
  },
  toMode: {
    rgb: (e16) => zo(eu(e16)),
    xyz65: eu
  }
};
var us = (e16) => {
  let t10 = Math.abs(e16);
  return t10 >= 1 / 512 ? Math.sign(e16) * Math.pow(t10, 1 / 1.8) : 16 * e16;
};
var nu = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = {
    mode: "prophoto",
    r: us(
      e16 * 1.3457868816471585 - t10 * 0.2555720873797946 - 0.0511018649755453 * n
    ),
    g: us(
      e16 * -0.5446307051249019 + t10 * 1.5082477428451466 + 0.0205274474364214 * n
    ),
    b: us(e16 * 0 + t10 * 0 + 1.2119675456389452 * n)
  };
  return o !== void 0 && (r.alpha = o), r;
};
var ds = (e16 = 0) => {
  let t10 = Math.abs(e16);
  return t10 >= 16 / 512 ? Math.sign(e16) * Math.pow(t10, 1.8) : e16 / 16;
};
var ou = (e16) => {
  let t10 = ds(e16.r), n = ds(e16.g), o = ds(e16.b), r = {
    mode: "xyz50",
    x: 0.7977666449006423 * t10 + 0.1351812974005331 * n + 0.0313477341283922 * o,
    y: 0.2880748288194013 * t10 + 0.7118352342418731 * n + 899369387256e-16 * o,
    z: 0 * t10 + 0 * n + 0.8251046025104602 * o
  };
  return e16.alpha !== void 0 && (r.alpha = e16.alpha), r;
};
var I2 = {
  ...ga,
  mode: "prophoto",
  parse: ["prophoto-rgb"],
  serialize: "prophoto-rgb",
  fromMode: {
    xyz50: nu,
    rgb: (e16) => nu(nr(e16))
  },
  toMode: {
    xyz50: ou,
    rgb: (e16) => tr(ou(e16))
  }
};
var au = 1.09929682680944;
var D2 = 0.018053968510807;
var fs = (e16) => {
  const t10 = Math.abs(e16);
  return t10 > D2 ? (Math.sign(e16) || 1) * (au * Math.pow(t10, 0.45) - (au - 1)) : 4.5 * e16;
};
var ru = ({ x: e16, y: t10, z: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  let r = {
    mode: "rec2020",
    r: fs(
      e16 * 1.7166511879712683 - t10 * 0.3556707837763925 - 0.2533662813736599 * n
    ),
    g: fs(
      e16 * -0.6666843518324893 + t10 * 1.6164812366349395 + 0.0157685458139111 * n
    ),
    b: fs(
      e16 * 0.0176398574453108 - t10 * 0.0427706132578085 + 0.9421031212354739 * n
    )
  };
  return o !== void 0 && (r.alpha = o), r;
};
var iu = 1.09929682680944;
var A2 = 0.018053968510807;
var ms = (e16 = 0) => {
  let t10 = Math.abs(e16);
  return t10 < A2 * 4.5 ? e16 / 4.5 : (Math.sign(e16) || 1) * Math.pow((t10 + iu - 1) / iu, 1 / 0.45);
};
var su = (e16) => {
  let t10 = ms(e16.r), n = ms(e16.g), o = ms(e16.b), r = {
    mode: "xyz65",
    x: 0.6369580483012911 * t10 + 0.1446169035862083 * n + 0.1688809751641721 * o,
    y: 0.262700212011267 * t10 + 0.6779980715188708 * n + 0.059301716469862 * o,
    z: 0 * t10 + 0.0280726930490874 * n + 1.0609850577107909 * o
  };
  return e16.alpha !== void 0 && (r.alpha = e16.alpha), r;
};
var E2 = {
  ...ga,
  mode: "rec2020",
  fromMode: {
    xyz65: ru,
    rgb: (e16) => ru(Ko(e16))
  },
  toMode: {
    xyz65: su,
    rgb: (e16) => zo(su(e16))
  },
  parse: ["rec2020"],
  serialize: "rec2020"
};
var ko = 0.0037930732552754493;
var Jd = Math.cbrt(ko);
var ps = (e16) => Math.cbrt(e16) - Jd;
var K2 = (e16) => {
  const { r: t10, g: n, b: o, alpha: r } = va(e16), a = ps(0.3 * t10 + 0.622 * n + 0.078 * o + ko), i = ps(0.23 * t10 + 0.692 * n + 0.078 * o + ko), s = ps(
    0.2434226892454782 * t10 + 0.2047674442449682 * n + 0.5518098665095535 * o + ko
  ), l = {
    mode: "xyb",
    x: (a - i) / 2,
    y: (a + i) / 2,
    /* Apply default chroma from luma (subtract Y from B) */
    b: s - (a + i) / 2
  };
  return r !== void 0 && (l.alpha = r), l;
};
var hs = (e16) => Math.pow(e16 + Jd, 3);
var z2 = ({ x: e16, y: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  const r = hs(e16 + t10) - ko, a = hs(t10 - e16) - ko, i = hs(n + t10) - ko, s = ya({
    r: 11.031566904639861 * r - 9.866943908131562 * a - 0.16462299650829934 * i,
    g: -3.2541473810744237 * r + 4.418770377582723 * a - 0.16462299650829934 * i,
    b: -3.6588512867136815 * r + 2.7129230459360922 * a + 1.9459282407775895 * i
  });
  return o !== void 0 && (s.alpha = o), s;
};
var P2 = {
  mode: "xyb",
  channels: ["x", "y", "b", "alpha"],
  parse: ["--xyb"],
  serialize: "--xyb",
  toMode: {
    rgb: z2
  },
  fromMode: {
    rgb: K2
  },
  ranges: {
    x: [-0.0154, 0.0281],
    y: [0, 0.8453],
    b: [-0.2778, 0.388]
  },
  interpolate: {
    x: ve,
    y: ve,
    b: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var R2 = {
  mode: "xyz50",
  parse: ["xyz-d50"],
  serialize: "xyz-d50",
  toMode: {
    rgb: tr,
    lab: Ol
  },
  fromMode: {
    rgb: nr,
    lab: jl
  },
  channels: ["x", "y", "z", "alpha"],
  ranges: {
    x: [0, 0.964],
    y: [0, 0.999],
    z: [0, 0.825]
  },
  interpolate: {
    x: ve,
    y: ve,
    z: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var L2 = (e16) => {
  let { x: t10, y: n, z: o, alpha: r } = e16;
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0), o === void 0 && (o = 0);
  let a = {
    mode: "xyz50",
    x: 1.0479298208405488 * t10 + 0.0229467933410191 * n - 0.0501922295431356 * o,
    y: 0.0296278156881593 * t10 + 0.990434484573249 * n - 0.0170738250293851 * o,
    z: -0.0092430581525912 * t10 + 0.0150551448965779 * n + 0.7518742899580008 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var F2 = (e16) => {
  let { x: t10, y: n, z: o, alpha: r } = e16;
  t10 === void 0 && (t10 = 0), n === void 0 && (n = 0), o === void 0 && (o = 0);
  let a = {
    mode: "xyz65",
    x: 0.9554734527042182 * t10 - 0.0230985368742614 * n + 0.0632593086610217 * o,
    y: -0.0283697069632081 * t10 + 1.0099954580058226 * n + 0.021041398966943 * o,
    z: 0.0123140016883199 * t10 - 0.0205076964334779 * n + 1.3303659366080753 * o
  };
  return r !== void 0 && (a.alpha = r), a;
};
var j2 = {
  mode: "xyz65",
  toMode: {
    rgb: zo,
    xyz50: L2
  },
  fromMode: {
    rgb: Ko,
    xyz50: F2
  },
  ranges: {
    x: [0, 0.95],
    y: [0, 1],
    z: [0, 1.088]
  },
  channels: ["x", "y", "z", "alpha"],
  parse: ["xyz", "xyz-d65"],
  serialize: "xyz-d65",
  interpolate: {
    x: ve,
    y: ve,
    z: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
var O2 = ({ r: e16, g: t10, b: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  const r = {
    mode: "yiq",
    y: 0.29889531 * e16 + 0.58662247 * t10 + 0.11448223 * n,
    i: 0.59597799 * e16 - 0.2741761 * t10 - 0.32180189 * n,
    q: 0.21147017 * e16 - 0.52261711 * t10 + 0.31114694 * n
  };
  return o !== void 0 && (r.alpha = o), r;
};
var B2 = ({ y: e16, i: t10, q: n, alpha: o }) => {
  e16 === void 0 && (e16 = 0), t10 === void 0 && (t10 = 0), n === void 0 && (n = 0);
  const r = {
    mode: "rgb",
    r: e16 + 0.95608445 * t10 + 0.6208885 * n,
    g: e16 - 0.27137664 * t10 - 0.6486059 * n,
    b: e16 - 1.10561724 * t10 + 1.70250126 * n
  };
  return o !== void 0 && (r.alpha = o), r;
};
var Z2 = {
  mode: "yiq",
  toMode: {
    rgb: B2
  },
  fromMode: {
    rgb: O2
  },
  channels: ["y", "i", "q", "alpha"],
  parse: ["--yiq"],
  serialize: "--yiq",
  ranges: {
    i: [-0.595, 0.595],
    q: [-0.522, 0.522]
  },
  interpolate: {
    y: ve,
    i: ve,
    q: ve,
    alpha: { use: ve, fixup: Mt }
  }
};
Ge(Ig);
Ge(Rg);
Ge(Lg);
Ge(Fg);
Ge(Bg);
Ge(zd);
Ge(Ld);
Ge(Qg);
Ge(Jg);
Ge(o2);
Ge(a2);
Ge(Bl);
Ge(i2);
Ge(Zl);
Ge(l2);
Ge(y2);
Ge(b2);
Ge(_2);
Ge(C2);
Ge(k2);
Ge(N2);
Ge($2);
Ge(x2);
Ge(I2);
Ge(E2);
Ge(ga);
Ge(P2);
Ge(R2);
Ge(j2);
Ge(Z2);
var W2 = {
  primary: "#3b82f6",
  success: "#22c55e",
  warning: "#f97316",
  danger: "#ef4444",
  error: "#ef4444",
  info: "#64748b"
};
var $a = [
  97.78,
  93.56,
  88.11,
  82.67,
  74.22,
  64.78,
  57.33,
  46.89,
  39.44,
  32,
  23.78
];
var gs = [
  0.0108,
  0.0321,
  0.0609,
  0.0908,
  0.1398,
  0.1472,
  0.1299,
  0.1067,
  0.0898,
  0.0726,
  0.054
];
var q2 = [
  "--k-oklch-50",
  "--k-oklch-100",
  "--k-oklch-200",
  "--k-oklch-300",
  "--k-oklch-400",
  "--k-oklch-500",
  "--k-oklch-600",
  "--k-oklch-700",
  "--k-oklch-800",
  "--k-oklch-900",
  "--k-oklch-950"
];
function Nn(e16) {
  const t10 = $a.map((s) => s - $a[5]), n = gs.map((s) => s - gs[5]), o = W2[e16] ?? e16, r = Os("oklch"), a = Os("rgb"), i = {};
  if ($d(o)) {
    const { l: s, c: l, h: c } = r(o) ?? {};
    if (!s || !l || !c)
      return;
    for (let u = 0; u < 11; u++) {
      const d = s + t10[u] / 100, m = $a[$a.length - 1] / 100, p = $a[0] / 100, f = xa(d, m, p), h10 = l + n[u], g = gs[0], y = xa(h10, g, l), T = a({ l: f, c: y, h: c, mode: "oklch" }), w = {
        mode: "rgb",
        r: (xa(T.r, 0, 1) * 255).toFixed(2),
        g: (xa(T.g, 0, 1) * 255).toFixed(2),
        b: (xa(T.b, 0, 1) * 255).toFixed(2)
      };
      i[q2[u]] = `rgb(${w.r}, ${w.g}, ${w.b})`;
    }
  }
  return {
    colorLevel: i
  };
}
function xa(e16, t10 = 0, n = 255) {
  return Math.max(t10, Math.min(n, e16));
}
var fn = Symbol("__size__");
Object.freeze({});
Object.freeze([]);
var V2 = () => {
};
var $e = (e16, t10) => {
  if (e16.install = (n) => {
    for (const o of [e16, ...Object.values(t10 ?? {})])
      n.component(o.name, o);
  }, t10)
    for (const [n, o] of Object.entries(t10))
      e16[n] = o;
  return e16;
};
var H2 = (e16, t10) => (e16.install = (n) => {
  e16._context = n._context, n.config.globalProperties[t10] = e16;
}, e16);
var tn = (e16) => (e16.install = V2, e16);
var U2 = [
  // bg
  {
    name: "bg-color-main",
    value: "500"
  },
  {
    name: "bg-color-main--hover",
    value: "400"
  },
  {
    name: "bg-color-main--active",
    value: "600"
  },
  {
    name: "bg-color-main--loading",
    value: "300"
  },
  // border
  {
    name: "border-color-main",
    value: "500"
  },
  {
    name: "border-color-main--hover",
    value: "400"
  },
  {
    name: "border-color-main--active",
    value: "600"
  },
  {
    name: "border-color-main--loading",
    value: "300"
  }
];
var G2 = [
  // bg
  {
    name: "bg-color-secondary--hover",
    value: "50"
  },
  {
    name: "bg-color-secondary--active",
    value: "50"
  },
  // content
  {
    name: "content-color-secondary",
    value: "500"
  },
  {
    name: "content-color-secondary--hover",
    value: "400"
  },
  {
    name: "content-color-secondary--active",
    value: "600"
  },
  {
    name: "content-color-secondary--loading",
    value: "300"
  },
  // border
  {
    name: "border-color-secondary",
    value: "500"
  },
  {
    name: "border-color-secondary--hover",
    value: "400"
  },
  {
    name: "border-color-secondary--active",
    value: "600"
  },
  {
    name: "border-color-secondary--loading",
    value: "300"
  }
];
var X2 = [
  // content
  {
    name: "content-color-text",
    value: "500"
  },
  {
    name: "content-color-text--hover",
    value: "400"
  },
  {
    name: "content-color-text--active",
    value: "600"
  },
  {
    name: "content-color-text--loading",
    value: "300"
  }
];
var Y2 = [
  { type: "main", vars: U2 },
  { type: "secondary", vars: G2 },
  { type: "text", vars: X2 }
];
var ef = typeof global == "object" && global && global.Object === Object && global;
var Q2 = typeof self == "object" && self && self.Object === Object && self;
var mn = ef || Q2 || Function("return this")();
var oo = mn.Symbol;
var tf = Object.prototype;
var J2 = tf.hasOwnProperty;
var ev = tf.toString;
var Ia = oo ? oo.toStringTag : void 0;
function tv(e16) {
  var t10 = J2.call(e16, Ia), n = e16[Ia];
  try {
    e16[Ia] = void 0;
    var o = true;
  } catch {
  }
  var r = ev.call(e16);
  return o && (t10 ? e16[Ia] = n : delete e16[Ia]), r;
}
var nv = Object.prototype;
var ov = nv.toString;
function av(e16) {
  return ov.call(e16);
}
var rv = "[object Null]";
var iv = "[object Undefined]";
var lu = oo ? oo.toStringTag : void 0;
function Po(e16) {
  return e16 == null ? e16 === void 0 ? iv : rv : lu && lu in Object(e16) ? tv(e16) : av(e16);
}
function Ro(e16) {
  return e16 != null && typeof e16 == "object";
}
var sv = "[object Symbol]";
function nf(e16) {
  return typeof e16 == "symbol" || Ro(e16) && Po(e16) == sv;
}
function lv(e16, t10) {
  for (var n = -1, o = e16 == null ? 0 : e16.length, r = Array(o); ++n < o; )
    r[n] = t10(e16[n], n, e16);
  return r;
}
var yi = Array.isArray;
var cv = 1 / 0;
var cu = oo ? oo.prototype : void 0;
var uu = cu ? cu.toString : void 0;
function of(e16) {
  if (typeof e16 == "string")
    return e16;
  if (yi(e16))
    return lv(e16, of) + "";
  if (nf(e16))
    return uu ? uu.call(e16) : "";
  var t10 = e16 + "";
  return t10 == "0" && 1 / e16 == -cv ? "-0" : t10;
}
var uv = /\s/;
function dv(e16) {
  for (var t10 = e16.length; t10-- && uv.test(e16.charAt(t10)); )
    ;
  return t10;
}
var fv = /^\s+/;
function mv(e16) {
  return e16 && e16.slice(0, dv(e16) + 1).replace(fv, "");
}
function ao(e16) {
  var t10 = typeof e16;
  return e16 != null && (t10 == "object" || t10 == "function");
}
var du = NaN;
var pv = /^[-+]0x[0-9a-f]+$/i;
var hv = /^0b[01]+$/i;
var gv = /^0o[0-7]+$/i;
var vv = parseInt;
function fu(e16) {
  if (typeof e16 == "number")
    return e16;
  if (nf(e16))
    return du;
  if (ao(e16)) {
    var t10 = typeof e16.valueOf == "function" ? e16.valueOf() : e16;
    e16 = ao(t10) ? t10 + "" : t10;
  }
  if (typeof e16 != "string")
    return e16 === 0 ? e16 : +e16;
  e16 = mv(e16);
  var n = hv.test(e16);
  return n || gv.test(e16) ? vv(e16.slice(2), n ? 2 : 8) : pv.test(e16) ? du : +e16;
}
var yv = "[object AsyncFunction]";
var bv = "[object Function]";
var _v = "[object GeneratorFunction]";
var wv = "[object Proxy]";
function af(e16) {
  if (!ao(e16))
    return false;
  var t10 = Po(e16);
  return t10 == bv || t10 == _v || t10 == yv || t10 == wv;
}
var vs = mn["__core-js_shared__"];
var mu = function() {
  var e16 = /[^.]+$/.exec(vs && vs.keys && vs.keys.IE_PROTO || "");
  return e16 ? "Symbol(src)_1." + e16 : "";
}();
function Tv(e16) {
  return !!mu && mu in e16;
}
var Cv = Function.prototype;
var kv = Cv.toString;
function Lo(e16) {
  if (e16 != null) {
    try {
      return kv.call(e16);
    } catch {
    }
    try {
      return e16 + "";
    } catch {
    }
  }
  return "";
}
var Sv = /[\\^$.*+?()[\]{}|]/g;
var Nv = /^\[object .+?Constructor\]$/;
var Mv = Function.prototype;
var $v = Object.prototype;
var xv = Mv.toString;
var Iv = $v.hasOwnProperty;
var Dv = RegExp(
  "^" + xv.call(Iv).replace(Sv, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Av(e16) {
  if (!ao(e16) || Tv(e16))
    return false;
  var t10 = af(e16) ? Dv : Nv;
  return t10.test(Lo(e16));
}
function Ev(e16, t10) {
  return e16 == null ? void 0 : e16[t10];
}
function Fo(e16, t10) {
  var n = Ev(e16, t10);
  return Av(n) ? n : void 0;
}
var Gs = Fo(mn, "WeakMap");
var pu = Object.create;
var Kv = /* @__PURE__ */ function() {
  function e16() {
  }
  return function(t10) {
    if (!ao(t10))
      return {};
    if (pu)
      return pu(t10);
    e16.prototype = t10;
    var n = new e16();
    return e16.prototype = void 0, n;
  };
}();
function zv(e16, t10) {
  var n = -1, o = e16.length;
  for (t10 || (t10 = Array(o)); ++n < o; )
    t10[n] = e16[n];
  return t10;
}
var hu = function() {
  try {
    var e16 = Fo(Object, "defineProperty");
    return e16({}, "", {}), e16;
  } catch {
  }
}();
function Pv(e16, t10) {
  for (var n = -1, o = e16 == null ? 0 : e16.length; ++n < o && t10(e16[n], n, e16) !== false; )
    ;
  return e16;
}
var Rv = 9007199254740991;
var Lv = /^(?:0|[1-9]\d*)$/;
function Fv(e16, t10) {
  var n = typeof e16;
  return t10 = t10 ?? Rv, !!t10 && (n == "number" || n != "symbol" && Lv.test(e16)) && e16 > -1 && e16 % 1 == 0 && e16 < t10;
}
function rf(e16, t10, n) {
  t10 == "__proto__" && hu ? hu(e16, t10, {
    configurable: true,
    enumerable: true,
    value: n,
    writable: true
  }) : e16[t10] = n;
}
function sf(e16, t10) {
  return e16 === t10 || e16 !== e16 && t10 !== t10;
}
var jv = Object.prototype;
var Ov = jv.hasOwnProperty;
function lf(e16, t10, n) {
  var o = e16[t10];
  (!(Ov.call(e16, t10) && sf(o, n)) || n === void 0 && !(t10 in e16)) && rf(e16, t10, n);
}
function bi(e16, t10, n, o) {
  var r = !n;
  n || (n = {});
  for (var a = -1, i = t10.length; ++a < i; ) {
    var s = t10[a], l = void 0;
    l === void 0 && (l = e16[s]), r ? rf(n, s, l) : lf(n, s, l);
  }
  return n;
}
var Bv = 9007199254740991;
function cf(e16) {
  return typeof e16 == "number" && e16 > -1 && e16 % 1 == 0 && e16 <= Bv;
}
function uf(e16) {
  return e16 != null && cf(e16.length) && !af(e16);
}
var Zv = Object.prototype;
function Vl(e16) {
  var t10 = e16 && e16.constructor, n = typeof t10 == "function" && t10.prototype || Zv;
  return e16 === n;
}
function Wv(e16, t10) {
  for (var n = -1, o = Array(e16); ++n < e16; )
    o[n] = t10(n);
  return o;
}
var qv = "[object Arguments]";
function gu(e16) {
  return Ro(e16) && Po(e16) == qv;
}
var df = Object.prototype;
var Vv = df.hasOwnProperty;
var Hv = df.propertyIsEnumerable;
var Uv = gu(/* @__PURE__ */ function() {
  return arguments;
}()) ? gu : function(e16) {
  return Ro(e16) && Vv.call(e16, "callee") && !Hv.call(e16, "callee");
};
function Gv() {
  return false;
}
var ff = typeof exports == "object" && exports && !exports.nodeType && exports;
var vu = ff && typeof module == "object" && module && !module.nodeType && module;
var Xv = vu && vu.exports === ff;
var yu = Xv ? mn.Buffer : void 0;
var Yv = yu ? yu.isBuffer : void 0;
var mf = Yv || Gv;
var Qv = "[object Arguments]";
var Jv = "[object Array]";
var e42 = "[object Boolean]";
var t4 = "[object Date]";
var n4 = "[object Error]";
var o4 = "[object Function]";
var a4 = "[object Map]";
var r4 = "[object Number]";
var i4 = "[object Object]";
var s4 = "[object RegExp]";
var l4 = "[object Set]";
var c4 = "[object String]";
var u4 = "[object WeakMap]";
var d4 = "[object ArrayBuffer]";
var f4 = "[object DataView]";
var m4 = "[object Float32Array]";
var p4 = "[object Float64Array]";
var h4 = "[object Int8Array]";
var g4 = "[object Int16Array]";
var v4 = "[object Int32Array]";
var y4 = "[object Uint8Array]";
var b4 = "[object Uint8ClampedArray]";
var _4 = "[object Uint16Array]";
var w4 = "[object Uint32Array]";
var st = {};
st[m4] = st[p4] = st[h4] = st[g4] = st[v4] = st[y4] = st[b4] = st[_4] = st[w4] = true;
st[Qv] = st[Jv] = st[d4] = st[e42] = st[f4] = st[t4] = st[n4] = st[o4] = st[a4] = st[r4] = st[i4] = st[s4] = st[l4] = st[c4] = st[u4] = false;
function T4(e16) {
  return Ro(e16) && cf(e16.length) && !!st[Po(e16)];
}
function Hl(e16) {
  return function(t10) {
    return e16(t10);
  };
}
var pf = typeof exports == "object" && exports && !exports.nodeType && exports;
var Ra = pf && typeof module == "object" && module && !module.nodeType && module;
var C4 = Ra && Ra.exports === pf;
var ys = C4 && ef.process;
var da = function() {
  try {
    var e16 = Ra && Ra.require && Ra.require("util").types;
    return e16 || ys && ys.binding && ys.binding("util");
  } catch {
  }
}();
var bu = da && da.isTypedArray;
var k4 = bu ? Hl(bu) : T4;
var S4 = Object.prototype;
var N4 = S4.hasOwnProperty;
function hf(e16, t10) {
  var n = yi(e16), o = !n && Uv(e16), r = !n && !o && mf(e16), a = !n && !o && !r && k4(e16), i = n || o || r || a, s = i ? Wv(e16.length, String) : [], l = s.length;
  for (var c in e16)
    (t10 || N4.call(e16, c)) && !(i && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    a && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    Fv(c, l))) && s.push(c);
  return s;
}
function gf(e16, t10) {
  return function(n) {
    return e16(t10(n));
  };
}
var M4 = gf(Object.keys, Object);
var $4 = Object.prototype;
var x4 = $4.hasOwnProperty;
function I4(e16) {
  if (!Vl(e16))
    return M4(e16);
  var t10 = [];
  for (var n in Object(e16))
    x4.call(e16, n) && n != "constructor" && t10.push(n);
  return t10;
}
function Ul(e16) {
  return uf(e16) ? hf(e16) : I4(e16);
}
function D4(e16) {
  var t10 = [];
  if (e16 != null)
    for (var n in Object(e16))
      t10.push(n);
  return t10;
}
var A4 = Object.prototype;
var E4 = A4.hasOwnProperty;
function K4(e16) {
  if (!ao(e16))
    return D4(e16);
  var t10 = Vl(e16), n = [];
  for (var o in e16)
    o == "constructor" && (t10 || !E4.call(e16, o)) || n.push(o);
  return n;
}
function Gl(e16) {
  return uf(e16) ? hf(e16, true) : K4(e16);
}
var Ha = Fo(Object, "create");
function z4() {
  this.__data__ = Ha ? Ha(null) : {}, this.size = 0;
}
function P4(e16) {
  var t10 = this.has(e16) && delete this.__data__[e16];
  return this.size -= t10 ? 1 : 0, t10;
}
var R4 = "__lodash_hash_undefined__";
var L4 = Object.prototype;
var F4 = L4.hasOwnProperty;
function j4(e16) {
  var t10 = this.__data__;
  if (Ha) {
    var n = t10[e16];
    return n === R4 ? void 0 : n;
  }
  return F4.call(t10, e16) ? t10[e16] : void 0;
}
var O4 = Object.prototype;
var B4 = O4.hasOwnProperty;
function Z4(e16) {
  var t10 = this.__data__;
  return Ha ? t10[e16] !== void 0 : B4.call(t10, e16);
}
var W4 = "__lodash_hash_undefined__";
function q4(e16, t10) {
  var n = this.__data__;
  return this.size += this.has(e16) ? 0 : 1, n[e16] = Ha && t10 === void 0 ? W4 : t10, this;
}
function xo(e16) {
  var t10 = -1, n = e16 == null ? 0 : e16.length;
  for (this.clear(); ++t10 < n; ) {
    var o = e16[t10];
    this.set(o[0], o[1]);
  }
}
xo.prototype.clear = z4;
xo.prototype.delete = P4;
xo.prototype.get = j4;
xo.prototype.has = Z4;
xo.prototype.set = q4;
function V4() {
  this.__data__ = [], this.size = 0;
}
function _i(e16, t10) {
  for (var n = e16.length; n--; )
    if (sf(e16[n][0], t10))
      return n;
  return -1;
}
var H4 = Array.prototype;
var U4 = H4.splice;
function G4(e16) {
  var t10 = this.__data__, n = _i(t10, e16);
  if (n < 0)
    return false;
  var o = t10.length - 1;
  return n == o ? t10.pop() : U4.call(t10, n, 1), --this.size, true;
}
function X4(e16) {
  var t10 = this.__data__, n = _i(t10, e16);
  return n < 0 ? void 0 : t10[n][1];
}
function Y4(e16) {
  return _i(this.__data__, e16) > -1;
}
function Q4(e16, t10) {
  var n = this.__data__, o = _i(n, e16);
  return o < 0 ? (++this.size, n.push([e16, t10])) : n[o][1] = t10, this;
}
function On(e16) {
  var t10 = -1, n = e16 == null ? 0 : e16.length;
  for (this.clear(); ++t10 < n; ) {
    var o = e16[t10];
    this.set(o[0], o[1]);
  }
}
On.prototype.clear = V4;
On.prototype.delete = G4;
On.prototype.get = X4;
On.prototype.has = Y4;
On.prototype.set = Q4;
var Ua = Fo(mn, "Map");
function J4() {
  this.size = 0, this.__data__ = {
    hash: new xo(),
    map: new (Ua || On)(),
    string: new xo()
  };
}
function e52(e16) {
  var t10 = typeof e16;
  return t10 == "string" || t10 == "number" || t10 == "symbol" || t10 == "boolean" ? e16 !== "__proto__" : e16 === null;
}
function wi(e16, t10) {
  var n = e16.__data__;
  return e52(t10) ? n[typeof t10 == "string" ? "string" : "hash"] : n.map;
}
function t5(e16) {
  var t10 = wi(this, e16).delete(e16);
  return this.size -= t10 ? 1 : 0, t10;
}
function n5(e16) {
  return wi(this, e16).get(e16);
}
function o5(e16) {
  return wi(this, e16).has(e16);
}
function a5(e16, t10) {
  var n = wi(this, e16), o = n.size;
  return n.set(e16, t10), this.size += n.size == o ? 0 : 1, this;
}
function ba(e16) {
  var t10 = -1, n = e16 == null ? 0 : e16.length;
  for (this.clear(); ++t10 < n; ) {
    var o = e16[t10];
    this.set(o[0], o[1]);
  }
}
ba.prototype.clear = J4;
ba.prototype.delete = t5;
ba.prototype.get = n5;
ba.prototype.has = o5;
ba.prototype.set = a5;
function _u(e16) {
  return e16 == null ? "" : of(e16);
}
function vf(e16, t10) {
  for (var n = -1, o = t10.length, r = e16.length; ++n < o; )
    e16[r + n] = t10[n];
  return e16;
}
var yf = gf(Object.getPrototypeOf, Object);
function r5() {
  this.__data__ = new On(), this.size = 0;
}
function i5(e16) {
  var t10 = this.__data__, n = t10.delete(e16);
  return this.size = t10.size, n;
}
function s5(e16) {
  return this.__data__.get(e16);
}
function l5(e16) {
  return this.__data__.has(e16);
}
var c5 = 200;
function u5(e16, t10) {
  var n = this.__data__;
  if (n instanceof On) {
    var o = n.__data__;
    if (!Ua || o.length < c5 - 1)
      return o.push([e16, t10]), this.size = ++n.size, this;
    n = this.__data__ = new ba(o);
  }
  return n.set(e16, t10), this.size = n.size, this;
}
function _a(e16) {
  var t10 = this.__data__ = new On(e16);
  this.size = t10.size;
}
_a.prototype.clear = r5;
_a.prototype.delete = i5;
_a.prototype.get = s5;
_a.prototype.has = l5;
_a.prototype.set = u5;
function d5(e16, t10) {
  return e16 && bi(t10, Ul(t10), e16);
}
function f5(e16, t10) {
  return e16 && bi(t10, Gl(t10), e16);
}
var bf = typeof exports == "object" && exports && !exports.nodeType && exports;
var wu = bf && typeof module == "object" && module && !module.nodeType && module;
var m5 = wu && wu.exports === bf;
var Tu = m5 ? mn.Buffer : void 0;
var Cu = Tu ? Tu.allocUnsafe : void 0;
function p5(e16, t10) {
  if (t10)
    return e16.slice();
  var n = e16.length, o = Cu ? Cu(n) : new e16.constructor(n);
  return e16.copy(o), o;
}
function h5(e16, t10) {
  for (var n = -1, o = e16 == null ? 0 : e16.length, r = 0, a = []; ++n < o; ) {
    var i = e16[n];
    t10(i, n, e16) && (a[r++] = i);
  }
  return a;
}
function _f() {
  return [];
}
var g5 = Object.prototype;
var v5 = g5.propertyIsEnumerable;
var ku = Object.getOwnPropertySymbols;
var Xl = ku ? function(e16) {
  return e16 == null ? [] : (e16 = Object(e16), h5(ku(e16), function(t10) {
    return v5.call(e16, t10);
  }));
} : _f;
function y5(e16, t10) {
  return bi(e16, Xl(e16), t10);
}
var b5 = Object.getOwnPropertySymbols;
var wf = b5 ? function(e16) {
  for (var t10 = []; e16; )
    vf(t10, Xl(e16)), e16 = yf(e16);
  return t10;
} : _f;
function _5(e16, t10) {
  return bi(e16, wf(e16), t10);
}
function Tf(e16, t10, n) {
  var o = t10(e16);
  return yi(e16) ? o : vf(o, n(e16));
}
function w5(e16) {
  return Tf(e16, Ul, Xl);
}
function T5(e16) {
  return Tf(e16, Gl, wf);
}
var Xs = Fo(mn, "DataView");
var Ys = Fo(mn, "Promise");
var Qs = Fo(mn, "Set");
var Su = "[object Map]";
var C5 = "[object Object]";
var Nu = "[object Promise]";
var Mu = "[object Set]";
var $u = "[object WeakMap]";
var xu = "[object DataView]";
var k5 = Lo(Xs);
var S5 = Lo(Ua);
var N5 = Lo(Ys);
var M5 = Lo(Qs);
var $5 = Lo(Gs);
var zn = Po;
(Xs && zn(new Xs(new ArrayBuffer(1))) != xu || Ua && zn(new Ua()) != Su || Ys && zn(Ys.resolve()) != Nu || Qs && zn(new Qs()) != Mu || Gs && zn(new Gs()) != $u) && (zn = function(e16) {
  var t10 = Po(e16), n = t10 == C5 ? e16.constructor : void 0, o = n ? Lo(n) : "";
  if (o)
    switch (o) {
      case k5:
        return xu;
      case S5:
        return Su;
      case N5:
        return Nu;
      case M5:
        return Mu;
      case $5:
        return $u;
    }
  return t10;
});
var x5 = Object.prototype;
var I5 = x5.hasOwnProperty;
function D5(e16) {
  var t10 = e16.length, n = new e16.constructor(t10);
  return t10 && typeof e16[0] == "string" && I5.call(e16, "index") && (n.index = e16.index, n.input = e16.input), n;
}
var Iu = mn.Uint8Array;
function Yl(e16) {
  var t10 = new e16.constructor(e16.byteLength);
  return new Iu(t10).set(new Iu(e16)), t10;
}
function A5(e16, t10) {
  var n = t10 ? Yl(e16.buffer) : e16.buffer;
  return new e16.constructor(n, e16.byteOffset, e16.byteLength);
}
var E5 = /\w*$/;
function K5(e16) {
  var t10 = new e16.constructor(e16.source, E5.exec(e16));
  return t10.lastIndex = e16.lastIndex, t10;
}
var Du = oo ? oo.prototype : void 0;
var Au = Du ? Du.valueOf : void 0;
function z5(e16) {
  return Au ? Object(Au.call(e16)) : {};
}
function P5(e16, t10) {
  var n = t10 ? Yl(e16.buffer) : e16.buffer;
  return new e16.constructor(n, e16.byteOffset, e16.length);
}
var R5 = "[object Boolean]";
var L5 = "[object Date]";
var F5 = "[object Map]";
var j5 = "[object Number]";
var O5 = "[object RegExp]";
var B5 = "[object Set]";
var Z5 = "[object String]";
var W5 = "[object Symbol]";
var q5 = "[object ArrayBuffer]";
var V5 = "[object DataView]";
var H5 = "[object Float32Array]";
var U5 = "[object Float64Array]";
var G5 = "[object Int8Array]";
var X5 = "[object Int16Array]";
var Y5 = "[object Int32Array]";
var Q5 = "[object Uint8Array]";
var J5 = "[object Uint8ClampedArray]";
var e62 = "[object Uint16Array]";
var t6 = "[object Uint32Array]";
function n6(e16, t10, n) {
  var o = e16.constructor;
  switch (t10) {
    case q5:
      return Yl(e16);
    case R5:
    case L5:
      return new o(+e16);
    case V5:
      return A5(e16, n);
    case H5:
    case U5:
    case G5:
    case X5:
    case Y5:
    case Q5:
    case J5:
    case e62:
    case t6:
      return P5(e16, n);
    case F5:
      return new o();
    case j5:
    case Z5:
      return new o(e16);
    case O5:
      return K5(e16);
    case B5:
      return new o();
    case W5:
      return z5(e16);
  }
}
function o6(e16) {
  return typeof e16.constructor == "function" && !Vl(e16) ? Kv(yf(e16)) : {};
}
var a6 = "[object Map]";
function r6(e16) {
  return Ro(e16) && zn(e16) == a6;
}
var Eu = da && da.isMap;
var i6 = Eu ? Hl(Eu) : r6;
var s6 = "[object Set]";
function l6(e16) {
  return Ro(e16) && zn(e16) == s6;
}
var Ku = da && da.isSet;
var c6 = Ku ? Hl(Ku) : l6;
var u6 = 1;
var d6 = 2;
var f6 = 4;
var Cf = "[object Arguments]";
var m6 = "[object Array]";
var p6 = "[object Boolean]";
var h6 = "[object Date]";
var g6 = "[object Error]";
var kf = "[object Function]";
var v6 = "[object GeneratorFunction]";
var y6 = "[object Map]";
var b6 = "[object Number]";
var Sf = "[object Object]";
var _6 = "[object RegExp]";
var w6 = "[object Set]";
var T6 = "[object String]";
var C6 = "[object Symbol]";
var k6 = "[object WeakMap]";
var S6 = "[object ArrayBuffer]";
var N6 = "[object DataView]";
var M6 = "[object Float32Array]";
var $6 = "[object Float64Array]";
var x6 = "[object Int8Array]";
var I6 = "[object Int16Array]";
var D6 = "[object Int32Array]";
var A6 = "[object Uint8Array]";
var E6 = "[object Uint8ClampedArray]";
var K6 = "[object Uint16Array]";
var z6 = "[object Uint32Array]";
var ot = {};
ot[Cf] = ot[m6] = ot[S6] = ot[N6] = ot[p6] = ot[h6] = ot[M6] = ot[$6] = ot[x6] = ot[I6] = ot[D6] = ot[y6] = ot[b6] = ot[Sf] = ot[_6] = ot[w6] = ot[T6] = ot[C6] = ot[A6] = ot[E6] = ot[K6] = ot[z6] = true;
ot[g6] = ot[kf] = ot[k6] = false;
function kr(e16, t10, n, o, r, a) {
  var i, s = t10 & u6, l = t10 & d6, c = t10 & f6;
  if (i !== void 0)
    return i;
  if (!ao(e16))
    return e16;
  var u = yi(e16);
  if (u) {
    if (i = D5(e16), !s)
      return zv(e16, i);
  } else {
    var d = zn(e16), m = d == kf || d == v6;
    if (mf(e16))
      return p5(e16, s);
    if (d == Sf || d == Cf || m && !r) {
      if (i = l || m ? {} : o6(e16), !s)
        return l ? _5(e16, f5(i, e16)) : y5(e16, d5(i, e16));
    } else {
      if (!ot[d])
        return r ? e16 : {};
      i = n6(e16, d, s);
    }
  }
  a || (a = new _a());
  var p = a.get(e16);
  if (p)
    return p;
  a.set(e16, i), c6(e16) ? e16.forEach(function(g) {
    i.add(kr(g, t10, n, g, e16, a));
  }) : i6(e16) && e16.forEach(function(g, v) {
    i.set(v, kr(g, t10, n, v, e16, a));
  });
  var f = c ? l ? T5 : w5 : l ? Gl : Ul, h10 = u ? void 0 : f(e16);
  return Pv(h10 || e16, function(g, v) {
    h10 && (v = g, g = e16[v]), lf(i, v, kr(g, t10, n, v, e16, a));
  }), i;
}
var P6 = 1;
var R6 = 4;
function Sr(e16) {
  return kr(e16, P6 | R6);
}
var bs = function() {
  return mn.Date.now();
};
var L6 = "Expected a function";
var F6 = Math.max;
var j6 = Math.min;
function O6(e16, t10, n) {
  var o, r, a, i, s, l, c = 0, u = false, d = false, m = true;
  if (typeof e16 != "function")
    throw new TypeError(L6);
  t10 = fu(t10) || 0, ao(n) && (u = !!n.leading, d = "maxWait" in n, a = d ? F6(fu(n.maxWait) || 0, t10) : a, m = "trailing" in n ? !!n.trailing : m);
  function p(_) {
    var M = o, x = r;
    return o = r = void 0, c = _, i = e16.apply(x, M), i;
  }
  function f(_) {
    return c = _, s = setTimeout(v, t10), u ? p(_) : i;
  }
  function h10(_) {
    var M = _ - l, x = _ - c, R = t10 - M;
    return d ? j6(R, a - x) : R;
  }
  function g(_) {
    var M = _ - l, x = _ - c;
    return l === void 0 || M >= t10 || M < 0 || d && x >= a;
  }
  function v() {
    var _ = bs();
    if (g(_))
      return y(_);
    s = setTimeout(v, h10(_));
  }
  function y(_) {
    return s = void 0, m && o ? p(_) : (o = r = void 0, i);
  }
  function k() {
    s !== void 0 && clearTimeout(s), c = 0, o = l = r = s = void 0;
  }
  function T() {
    return s === void 0 ? i : y(bs());
  }
  function w() {
    var _ = bs(), M = g(_);
    if (o = arguments, r = this, l = _, M) {
      if (s === void 0)
        return f(l);
      if (d)
        return clearTimeout(s), s = setTimeout(v, t10), p(l);
    }
    return s === void 0 && (s = setTimeout(v, t10)), i;
  }
  return w.cancel = k, w.flush = T, w;
}
var B6 = "[object Number]";
function Z6(e16) {
  return typeof e16 == "number" || Ro(e16) && Po(e16) == B6;
}
var W6 = /* @__PURE__ */ new Map([
  ["default", "base"],
  ["small", "sm"],
  ["large", "lg"],
  ["base", "base"],
  ["sm", "sm"],
  ["lg", "lg"]
]);
var q6 = /* @__PURE__ */ new Map([
  ["base", "default"],
  ["sm", "small"],
  ["lg", "large"],
  ["default", "default"],
  ["small", "small"],
  ["large", "large"]
]);
function kt(e16) {
  const t10 = inject(fn, "base");
  return computed(() => {
    const n = e16.size || unref(t10);
    let o, r;
    if (typeof n == "object") {
      const { ownSize: a, elSize: i } = n;
      o = a, r = i;
    } else
      o = n, r = n;
    return {
      ownSize: W6.get(_u(o)) ?? "base",
      elSize: q6.get(_u(r)) ?? "default"
    };
  });
}
var V6 = { key: 0 };
var H6 = { key: 1 };
var U6 = defineComponent({
  name: "KButton",
  __name: "button",
  props: {
    type: { default: "" },
    main: { type: Boolean, default: false },
    secondary: { type: Boolean, default: false },
    text: { type: Boolean, default: false },
    icon: { type: Boolean, default: false },
    size: {},
    iconLeft: { default: "" },
    iconRight: { default: "" },
    value: { default: "" },
    disabled: { type: Boolean, default: false },
    loading: { type: Boolean, default: false },
    loadingIcon: { default: Dp },
    color: { default: "" }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = Dt(8), i = ref(), s = ref(n.color);
    watch(
      () => n.color,
      (m) => {
        var f;
        if (!m)
          return;
        s.value = m;
        const p = (f = Nn(m)) == null ? void 0 : f.colorLevel;
        m && nextTick(() => {
          var h10, g, v, y, k, T;
          if ((g = (h10 = i == null ? void 0 : i.value) == null ? void 0 : h10.$el) != null && g.style) {
            const w = (v = i.value.$el) == null ? void 0 : v.classList, _ = (k = (y = p == null ? void 0 : p["--k-oklch-500"]) == null ? void 0 : y.match(/\(([^)]+)\)/)) == null ? void 0 : k[1];
            for (const M of Y2) {
              const x = `el-button--${M.type}`;
              w != null && w.contains(x) && M.vars.forEach((R) => {
                var I;
                (I = i.value.$el) == null || I.style.setProperty(
                  `--k-button-${R.name}`,
                  p == null ? void 0 : p[`--k-oklch-${R.value}`]
                );
              });
            }
            (T = i.value.$el) == null || T.style.setProperty("--k-button-focus", `rgba(${_}, 0.2)`);
          }
        });
      },
      { immediate: true }
    );
    const l = computed(() => {
      const m = ["primary", "success", "info", "warning", "danger"];
      return n.type && m.includes(n.type) ? `el-button--${n.type}` : "";
    }), c = computed(() => {
      const { ownSize: m } = o.value;
      return m ? `el-button--${m}` : "";
    }), u = computed(() => {
      const m = ["main", "secondary", "text", "icon"];
      if (["primary", "success", "info", "warning", "danger"].includes(n.type))
        return "";
      for (let f = 0; f < m.length; f++)
        if (n[m[f]])
          return "";
      return "k-button--base";
    });
    return t10(Ae({}, i)), (m, p) => (openBlock(), createBlock(unref(ElButton), mergeProps({
      id: unref(a),
      ref_key: "buttonRef",
      ref: i,
      class: ["k-button", [
        "el-button",
        {
          "el-button--main": m.main,
          "el-button--secondary": m.secondary,
          "el-button--text": m.text,
          "el-button--icon": m.icon,
          "is-loading": m.loading,
          "is-disabled": m.disabled,
          "button-loading": m.loading
        },
        l.value,
        c.value,
        u.value,
        unref(r)
      ]],
      loading: m.loading,
      "loading-icon": m.loadingIcon,
      disabled: m.disabled
    }, m.$attrs), {
      default: withCtx(() => [
        renderSlot(m.$slots, "iconLeft", { class: "icon-left" }, () => [
          n.iconLeft ? (openBlock(), createBlock(resolveDynamicComponent(n.iconLeft), { key: 0 })) : createCommentVNode("", true)
        ]),
        n.value && n.icon === false ? (openBlock(), createElementBlock("label", V6, toDisplayString(n.value), 1)) : m.$slots.default ? (openBlock(), createElementBlock("label", H6, [
          renderSlot(m.$slots, "default", { class: "slot-content" })
        ])) : createCommentVNode("", true),
        renderSlot(m.$slots, "iconRight", { class: "icon-right" }, () => [
          n.iconRight ? (openBlock(), createBlock(resolveDynamicComponent(n.iconRight), { key: 0 })) : createCommentVNode("", true)
        ]),
        n.loading ? (openBlock(), createBlock(resolveDynamicComponent(n.loadingIcon), {
          key: 2,
          class: "loading-icon"
        })) : createCommentVNode("", true)
      ]),
      _: 3
    }, 16, ["id", "class", "loading", "loading-icon", "disabled"]));
  }
});
var Lt = $e(U6);
var G6 = defineComponent({
  name: "KInput",
  __name: "input",
  props: {
    size: {},
    iconLeft: { default: void 0 },
    iconRight: { default: void 0 },
    prefixIcon: { default: void 0 },
    suffixIcon: { default: void 0 }
  },
  setup(e16, { expose: t10 }) {
    var p, f, h10, g;
    const o = kt(e16), r = inject("_styleModule", ""), a = useSlots(), i = (p = a.prepend) == null ? void 0 : p.call(a), s = (f = i == null ? void 0 : i[0]) == null ? void 0 : f.type, l = (h10 = a.append) == null ? void 0 : h10.call(a), c = (g = l == null ? void 0 : l[0]) == null ? void 0 : g.type, u = computed(() => (v) => {
      switch (typeof v) {
        case "string":
          return "k-input-slot--htmlTag";
        case "object":
          return "k-input-slot--component";
        case "symbol":
          return "k-input-slot--string";
        default:
          return "";
      }
    });
    provide(fn, o);
    const d = ref();
    return t10(Ae({}, d)), (v, y) => (openBlock(), createBlock(unref(ElInput), mergeProps({
      ref_key: "inputRef",
      ref: d,
      class: [
        "k-input",
        {
          "k-input-has-prepend": a.prepend,
          "k-input-has-append": a.append
        },
        unref(r)
      ]
    }, v.$attrs, {
      "prefix-icon": v.iconLeft ?? v.prefixIcon,
      "suffix-icon": v.iconRight ?? v.suffixIcon,
      size: unref(o).elSize
    }), createSlots({
      prefix: withCtx(() => [
        renderSlot(v.$slots, "prefix")
      ]),
      suffix: withCtx(() => [
        renderSlot(v.$slots, "suffix")
      ]),
      _: 2
    }, [
      a.prepend ? {
        name: "prepend",
        fn: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(u.value(unref(s)))
          }, [
            renderSlot(v.$slots, "prepend")
          ], 2)
        ]),
        key: "0"
      } : void 0,
      a.append ? {
        name: "append",
        fn: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass(u.value(unref(c)))
          }, [
            renderSlot(v.$slots, "append")
          ], 2)
        ]),
        key: "1"
      } : void 0
    ]), 1040, ["class", "prefix-icon", "suffix-icon", "size"]));
  }
});
var ro = $e(G6);
var X6 = defineComponent({
  name: "KInputNumber",
  __name: "input_number",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", ""), a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElInputNumber), mergeProps({
      ref_key: "inputNumberRef",
      ref: a,
      class: ["k-input-number", unref(r)]
    }, s.$attrs, {
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var Y6 = $e(X6);
var Q6 = [
  {
    name: "-text-color--hover",
    value: "400"
  },
  {
    name: "-text-color--checked",
    value: "500"
  },
  {
    name: "__inner__border-color--hover",
    value: "400"
  },
  {
    name: "__inner__border-color--checked",
    value: "500"
  },
  {
    name: "__inner__ball-color--normal",
    value: "500"
  },
  {
    name: "__inner__ball-color--hover",
    value: "500"
  },
  {
    name: "__inner__ball-color--checked",
    value: "500"
  },
  {
    name: "__button__border-color--hover",
    value: "400"
  },
  {
    name: "__button__text-color--hover",
    value: "400"
  },
  {
    name: "__button__bg-color--checked",
    value: "500"
  },
  {
    name: "__button__border-color--checked",
    value: "500"
  }
];
var J6 = defineComponent({
  name: "KRadio",
  __name: "radio",
  props: {
    size: {},
    color: { default: "" },
    button: { type: Boolean, default: false }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = ref(n.color), i = ref();
    watch(
      () => n.color,
      (c) => {
        var d;
        if (!c)
          return;
        a.value = c;
        const u = (d = Nn == null ? void 0 : Nn(c)) == null ? void 0 : d.colorLevel;
        nextTick(() => {
          var m, p, f, h10;
          if ((m = i.value.$el) != null && m.style) {
            const g = (f = (p = u == null ? void 0 : u["--k-oklch-500"]) == null ? void 0 : p.match(/\(([^)]+)\)/)) == null ? void 0 : f[1];
            (h10 = i.value.$el) == null || h10.style.setProperty("--radio-color--focus", `rgba(${g}, 0.2)`), Q6.forEach((v) => {
              var y;
              (y = i.value.$el) == null || y.style.setProperty(
                `--radio${v.name}`,
                u == null ? void 0 : u[`--k-oklch-${v.value}`]
              );
            });
          }
        });
      },
      { immediate: true }
    );
    const s = computed(() => {
      const { ownSize: c } = o.value;
      return c ? `k-radio--${c}` : "";
    });
    return t10(Ae({}, i)), (c, u) => (openBlock(), createBlock(unref(ElRadio), mergeProps(c.$attrs, {
      ref_key: "kRadioRef",
      ref: i,
      class: ["k-radio", [s.value, { "is-button": n.button === true }, unref(r)]]
    }), createSlots({ _: 2 }, [
      renderList(c.$slots, (d, m) => ({
        name: m,
        fn: withCtx((p) => [
          renderSlot(c.$slots, m, normalizeProps(guardReactiveProps(p)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Nf = defineComponent({
  name: "KRadioGroup",
  __name: "radio_group",
  props: {
    size: {},
    direction: {},
    button: { type: Boolean, default: false },
    color: {},
    column: { type: Boolean, default: false },
    row: { type: Boolean, default: true }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = ref(null), i = ref(n.color), s = computed(() => o.value.ownSize ? `k-radio-group--${o.value.ownSize}` : "");
    return watch(
      () => n.color,
      (c) => {
        i.value = c;
      }
    ), provide("_fillColor", i), provide(fn, o), t10(Ae({}, a)), (c, u) => (openBlock(), createBlock(unref(ElRadioGroup), mergeProps({
      ref_key: "KRadioGroupRef",
      ref: a,
      class: ["k-radio-group", [
        {
          "k-radio-group--button": n.button === true,
          "k-radio-group--row": n.row === true,
          "k-radio-group--column": n.column === true
        },
        s.value,
        unref(r)
      ]]
    }, c.$attrs), createSlots({ _: 2 }, [
      renderList(c.$slots, (d, m) => ({
        name: m,
        fn: withCtx((p) => [
          renderSlot(c.$slots, m, normalizeProps(guardReactiveProps(p)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Mf = $e(J6, { RadioGroup: Nf });
var $f = tn(Nf);
var ey = [
  {
    name: "-text-color--hover",
    value: "400"
  },
  {
    name: "-text-color--checked",
    value: "500"
  },
  {
    name: "__inner__border-color--hover",
    value: "400"
  },
  {
    name: "__inner__border-color--checked",
    value: "500"
  },
  {
    name: "__inner__bg-color--hover",
    value: "400"
  },
  {
    name: "__inner__bg-color--checked",
    value: "500"
  }
];
var ty = { class: "checkbox__label" };
var ny = defineComponent({
  name: "KCheckbox",
  __name: "checkbox",
  props: {
    size: {},
    label: {},
    color: { default: "" },
    strict: { type: Boolean, default: false }
  },
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = e16, r = ref(), a = Dt(8), i = kt(o), s = ref(o.color), l = ref(), c = ref();
    typeof window < "u" && nextTick(() => {
      l.value = document == null ? void 0 : document.getElementById(a);
    }), watch(
      () => o.color,
      (p) => {
        var h10;
        if (!p)
          return;
        s.value = p;
        const f = (h10 = Nn == null ? void 0 : Nn(p)) == null ? void 0 : h10.colorLevel;
        nextTick(() => {
          var g, v, y, k, T;
          if ((g = l.value) != null && g.style) {
            c.value = (y = (v = l.value) == null ? void 0 : v.parentNode) == null ? void 0 : y.parentNode;
            const w = (k = f == null ? void 0 : f["--k-oklch-500"].match(/\(([^)]+)\)/)) == null ? void 0 : k[1];
            (T = c.value) == null || T.style.setProperty("--checkbox-color--focus", `rgba(${w}, 0.2)`), ey.forEach((_) => {
              var M;
              (M = c.value) == null || M.style.setProperty(
                `--checkbox${_.name}`,
                f == null ? void 0 : f[`--k-oklch-${_.value}`]
              );
            });
          }
        });
      },
      { immediate: true }
    );
    function u(p) {
      var h10;
      if (!o.strict || !p.target || !(p.target instanceof Element))
        return;
      ((h10 = p.target) == null ? void 0 : h10.classList.contains("el-checkbox__inner")) || p.preventDefault();
    }
    const d = computed(() => {
      const { ownSize: p } = i.value;
      return p ? `k-checkbox--${p}` : "";
    });
    return t10(Ae({}, r)), (p, f) => (openBlock(), createBlock(unref(ElCheckbox), mergeProps({
      id: unref(a),
      ref_key: "kCheckboxRef",
      ref: r,
      class: ["k-checkbox", [d.value, unref(n)]]
    }, p.$attrs, {
      label: p.label,
      onClick: u
    }), {
      default: withCtx(() => [
        renderSlot(p.$slots, "default", {}, () => [
          createBaseVNode("span", ty, toDisplayString(o.label), 1)
        ])
      ]),
      _: 3
    }, 16, ["id", "class", "label"]));
  }
});
var xf = defineComponent({
  name: "KCheckboxGroup",
  __name: "checkbox_group",
  props: {
    size: {},
    color: { default: "#409eff" }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = ref(n.color), i = ref(null);
    return watch(
      () => n.color,
      (l) => {
        a.value = l;
      }
    ), provide("useCheckboxGroup", true), provide("_fillColor", a), provide(fn, o), t10(Ae({}, i)), (l, c) => (openBlock(), createBlock(unref(ElCheckboxGroup), mergeProps({
      ref_key: "kCheckboxGroupRef",
      ref: i,
      class: ["k-checkbox-group", unref(r)]
    }, l.$attrs), {
      default: withCtx(() => [
        renderSlot(l.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var fa = $e(ny, { CheckboxGroup: xf });
var If = tn(xf);
var oy = defineComponent({
  name: "KSwitch",
  __name: "switch",
  props: {
    switchOnColor: { default: "" },
    switchOffColor: { default: "" },
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = kt(n), a = ref();
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElSwitch), mergeProps({
      ref_key: "kSwitchRef",
      ref: a,
      class: ["k-switch", unref(o)]
    }, s.$attrs, {
      size: unref(r).elSize,
      style: {
        "--el-switch-on-color": n.switchOnColor,
        "--el-switch-off-color": n.switchOffColor
      }
    }), null, 16, ["class", "size", "style"]));
  }
});
var ay = $e(oy);
var ry = { class: "k-dropdown-link" };
var iy = defineComponent({
  name: "KDropdown",
  __name: "dropdown",
  props: {
    title: {},
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = e16, r = kt(o), a = ref();
    return provide(fn, r), t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElDropdown), mergeProps({
      ref_key: "kDropDownRef",
      ref: a,
      class: ["k-dropdown", unref(n)]
    }, s.$attrs, {
      size: unref(r).elSize
    }), {
      dropdown: withCtx(() => [
        createVNode(unref(ElDropdownMenu), null, {
          default: withCtx(() => [
            renderSlot(s.$slots, "default")
          ]),
          _: 3
        })
      ]),
      default: withCtx(() => [
        renderSlot(s.$slots, "title", {}, () => [
          createBaseVNode("span", ry, toDisplayString(o.title), 1)
        ])
      ]),
      _: 3
    }, 16, ["class", "size"]));
  }
});
var Df = defineComponent({
  name: "KDropdownItem",
  __name: "dropdown_item",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElDropdownItem), mergeProps({
      ref_key: "kDropDownItemRef",
      ref: o,
      class: [unref(n)]
    }, a.$attrs), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
});
var ar = $e(iy, { DropdownItem: Df });
var rr = tn(Df);
var sy = defineComponent({
  name: "TabLabel",
  props: {
    tabIndexList: {
      type: Array,
      default: () => []
    },
    tabSlots: {
      type: Object,
      default: () => null
    }
  },
  emits: ["command"],
  setup(e16, {
    slots: t10,
    emit: n
  }) {
    return () => {
      var s, l;
      const a = new Map(e16.tabIndexList.map((c, u) => [c, u])), i = r(jr((l = (s = e16.tabSlots) == null ? void 0 : s.default) == null ? void 0 : l.call(s))).filter((c, u) => a.has(u));
      return createVNode(Fragment, null, [createVNode(ar, {
        trigger: "click",
        disabled: e16.tabIndexList.length === 0,
        maxHeight: "300px",
        onCommand: o
      }, {
        default: () => [i.map((c) => createVNode(rr, {
          key: c.name,
          command: c,
          disabled: c.disabled
        }, {
          default: () => [typeof (c == null ? void 0 : c.label) == "function" ? c.label() : c.label]
        }))],
        ...t10
      })]);
    };
    function o(a) {
      n("command", a);
    }
    function r(a) {
      return a.map((i) => {
        var s;
        if (Cd(i)) {
          const l = {
            ...i.props || {}
          };
          for (const [p, f] of Object.entries(l))
            delete l[p], l[Td(p)] = f;
          const c = i.children || {}, u = ((s = i.props) == null ? void 0 : s.name) !== void 0 ? i.props.name : void 0, {
            label: d = c.label,
            disabled: m
          } = l;
          return {
            name: u,
            label: d,
            disabled: m === "" || m
          };
        }
        return null;
      }).filter((i) => i);
    }
  }
});
var ly = defineComponent({
  name: "KTabs",
  __name: "tabs",
  props: {
    modelValue: { default: void 0 },
    tabPosition: { default: "top" },
    editable: { type: Boolean, default: false },
    addable: { type: Boolean, default: false },
    maxWidth: { default: void 0 },
    type: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(void 0);
    let a = null, i, s = [], l = null;
    const c = ref(), u = ref([]);
    let d = 0;
    onMounted(() => {
      window.addEventListener("resize", f);
    }), onUnmounted(() => {
      window.removeEventListener("resize", f);
    }), nextTick(() => {
      var g;
      a = (g = c == null ? void 0 : c.value) == null ? void 0 : g.$el, i = (a == null ? void 0 : a.querySelector(".el-tabs__nav")) ?? void 0, l = a == null ? void 0 : a.querySelector(".el-tabs__new-tab"), s = (a == null ? void 0 : a.querySelectorAll(".el-tabs__item")) ?? [], f();
    }), watch(
      () => n.maxWidth,
      (g) => {
        g && nextTick(() => {
          a && (a == null || a.style.setProperty("--plane-max-width", g));
        });
      },
      { immediate: true }
    );
    function m(g, v = 0) {
      if (!a)
        return;
      const y = g.getBoundingClientRect(), k = a.getBoundingClientRect(), T = v - d, { width: w, height: _ } = (l == null ? void 0 : l.getBoundingClientRect()) ?? {};
      return n.tabPosition === "top" || n.tabPosition === "bottom" ? y.left + T >= k.left && y.right + T <= k.right - (w ?? 0) : y.top + T >= k.top && y.bottom + T <= k.bottom - (_ ?? 0);
    }
    function p(g) {
      const v = g.name ?? "";
      r.value = v, f();
    }
    function f() {
      setTimeout(() => {
        var T;
        const g = /\(([^)]+)\)/g, v = (T = i == null ? void 0 : i.style.transform) == null ? void 0 : T.match(g);
        if (!v)
          return;
        const [y] = v.map((w) => parseFloat(w.slice(1, -1))), k = [];
        s == null || s.forEach((w, _) => {
          m(w, y) || k.push(_);
        }), d = y, u.value = k;
      });
    }
    return watch(
      () => n.modelValue,
      () => {
        r.value = n.modelValue;
      },
      { immediate: true }
    ), t10(Ae({}, c)), (g, v) => (openBlock(), createBlock(unref(ElTabs), mergeProps({
      ref_key: "KTabsRef",
      ref: c,
      modelValue: r.value,
      "onUpdate:modelValue": v[0] || (v[0] = (y) => r.value = y),
      class: ["k-tabs", unref(o)]
    }, g.$attrs, {
      "tab-position": g.tabPosition,
      editable: g.editable,
      addable: g.addable,
      onTabClick: f
    }), createSlots({
      default: withCtx(() => [
        u.value.length ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["k-tabs-more", `tab-${g.tabPosition}-layout`]),
          style: normalizeStyle({
            right: (g.editable || g.addable) && (g.tabPosition === "top" || g.tabPosition === "bottom") ? "2rem" : 0
          })
        }, [
          createVNode(unref(sy), {
            "tab-index-list": u.value,
            "tab-slots": g.$slots,
            onCommand: p
          }, {
            title: withCtx(() => [
              createVNode(unref(oi))
            ]),
            _: 1
          }, 8, ["tab-index-list", "tab-slots"])
        ], 6)) : createCommentVNode("", true),
        renderSlot(g.$slots, "default")
      ]),
      _: 2
    }, [
      g.$slots.addIcon ? {
        name: "add-icon",
        fn: withCtx(() => [
          renderSlot(g.$slots, "add-icon")
        ]),
        key: "0"
      } : void 0
    ]), 1040, ["modelValue", "class", "tab-position", "editable", "addable"]));
  }
});
var cy = { class: "k-tooltip-icon" };
var uy = defineComponent({
  name: "KTooltip",
  __name: "tooltip",
  props: {
    type: { default: void 0 },
    color: { default: "" },
    textColor: { default: "#FFF" },
    popperStyle: {}
  },
  setup(e16, { expose: t10 }) {
    const n = {
      normal: "#000",
      danger: "#ef4444",
      warning: "#f97316",
      primary: "#2882ff"
    }, o = e16, r = ref(), a = ref(void 0), i = computed(() => {
      const l = o.popperStyle || {};
      return {
        color: o.textColor,
        backgroundColor: a.value,
        borderColor: a.value,
        ...l
      };
    });
    return watch(
      () => [o.type, o.color],
      () => {
        o.color && Jh(o.color) ? a.value = o.color : !o.color && o.type && n[o.type] ? a.value = n[o.type] : a.value = void 0;
      },
      { immediate: true }
    ), t10(Ae({}, r)), (l, c) => (openBlock(), createBlock(unref(ElTooltip), mergeProps({
      ref_key: "tooltipRef",
      ref: r,
      class: "k-tooltip"
    }, l.$attrs, { "popper-style": i.value }), createSlots({
      default: withCtx(() => [
        renderSlot(l.$slots, "default", {}, () => [
          createBaseVNode("i", cy, [
            createVNode(unref(gd), {
              style: normalizeStyle({
                color: a.value,
                width: "15px",
                height: "15px"
              })
            }, null, 8, ["style"])
          ])
        ])
      ]),
      _: 2
    }, [
      l.$slots.content ? {
        name: "content",
        fn: withCtx(() => [
          renderSlot(l.$slots, "content")
        ]),
        key: "0"
      } : void 0
    ]), 1040, ["popper-style"]));
  }
});
var wa = $e(uy);
var Af = defineComponent({
  name: "KTabPane",
  __name: "tab_pane",
  props: {
    closable: {
      type: Boolean,
      default: false
    },
    label: {
      type: String,
      default: ""
    }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(null), a = useSlots(), i = ref(false), s = computed(() => {
      var m, p, f;
      if (a.label) {
        const h10 = ((f = (p = (m = a.label) == null ? void 0 : m.call(a)) == null ? void 0 : p[0]) == null ? void 0 : f.children) ?? "";
        return typeof h10 == "string" ? h10 : null;
      }
      return n.label;
    });
    let l = null;
    function c(m) {
      const p = m.target;
      if (p.clientWidth < p.scrollWidth) {
        l = setTimeout(() => {
          i.value = true;
        }, 500);
        return;
      }
      u();
    }
    function u() {
      l && clearTimeout(l), i.value = false;
    }
    return t10(Ae({}, r)), (m, p) => (openBlock(), createBlock(unref(ElTabPane), mergeProps({
      ref_key: "KTabPaneRef",
      ref: r,
      class: ["k-tab-item", unref(o)]
    }, m.$attrs, {
      closable: n.closable
    }), {
      label: withCtx(() => [
        createVNode(unref(wa), {
          content: s.value,
          visible: i.value && !!s.value
        }, {
          default: withCtx(() => [
            createBaseVNode("span", {
              class: normalizeClass(n.closable ? "k-tab-item-closeable" : ""),
              onMouseenter: c,
              onMouseleave: u
            }, [
              renderSlot(m.$slots, "label", {}, () => [
                createTextVNode(toDisplayString(n.label), 1)
              ])
            ], 34)
          ]),
          _: 3
        }, 8, ["content", "visible"])
      ]),
      default: withCtx(() => [
        renderSlot(m.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "closable"]));
  }
});
var Ef = $e(ly, { TabPane: Af });
var Kf = tn(Af);
var dy = defineComponent({
  name: "KPagination",
  __name: "pagination",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", ""), a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElPagination), mergeProps({
      ref_key: "KPaginationRef",
      ref: a,
      class: ["k-pagination", unref(r)]
    }, s.$attrs, {
      size: unref(o).elSize
    }), null, 16, ["class", "size"]));
  }
});
var zf = $e(dy);
var fy = defineComponent({
  name: "KSelect",
  __name: "select",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", ""), a = ref();
    return provide(fn, o), t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElSelect), mergeProps({
      ref_key: "inputRef",
      ref: a,
      class: ["k-select", [unref(r)]]
    }, s.$attrs, {
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var Pf = defineComponent({
  name: "KOption",
  __name: "option",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElOption), mergeProps({
      ref_key: "KOptionRef",
      ref: o,
      value: "",
      class: ["k-option", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Rf = defineComponent({
  name: "KOptionGroup",
  __name: "option_group",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElOptionGroup), mergeProps({
      ref_key: "KOptionGroupRef",
      ref: o,
      class: ["k-option-group", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Go = $e(fy, { Option: Pf, OptionGroup: Rf });
var vo = tn(Pf);
var my = tn(Rf);
var py = defineComponent({
  name: "KCascader",
  __name: "cascader",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", "");
    provide(fn, o);
    const a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElCascader), mergeProps({
      ref_key: "cascaderRef",
      ref: a,
      class: ["k-cascader", unref(r)]
    }, s.$attrs, {
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var Lf = $e(py);
var hy = defineComponent({
  name: "KDatePicker",
  __name: "date_picker",
  props: {
    size: {},
    shortcuts: {},
    showDefaultShortcuts: { type: Boolean, default: true },
    type: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = kt(n), r = inject("_styleModule", ""), a = inject("$t"), i = ref(null), s = [
      {
        text: a == null ? void 0 : a("within7days"),
        value: () => c(-7)
      },
      {
        text: a == null ? void 0 : a("within15days"),
        value: () => c(-15)
      },
      {
        text: a == null ? void 0 : a("curMonth"),
        value: u()
      },
      {
        text: a == null ? void 0 : a("curQuarter"),
        value: m()
      },
      {
        text: a == null ? void 0 : a("curYear"),
        value: p()
      }
    ], l = computed(() => (n.type === "daterange" || n.type === "datetimerange") && n.showDefaultShortcuts ? [...s, ...n.shortcuts || []] : n.shortcuts);
    function c(h10) {
      const g = /* @__PURE__ */ new Date(), v = /* @__PURE__ */ new Date();
      return v.setDate(v.getDate() + h10), h10 > 0 ? [g, v] : [v, g];
    }
    function u() {
      const h10 = /* @__PURE__ */ new Date();
      h10.setDate(1), h10.setHours(0, 0, 0, 0);
      const g = d(), v = /* @__PURE__ */ new Date();
      return v.setDate(g), v.setHours(23, 59, 59, 59), [h10, v];
    }
    function d() {
      const h10 = (/* @__PURE__ */ new Date()).getMonth() + 1, g = [1, 3, 5, 7, 8, 10, 12], v = [4, 6, 9, 11];
      if (g.includes(h10))
        return 31;
      if (v.includes(h10))
        return 30;
      const y = (/* @__PURE__ */ new Date()).getFullYear();
      return y % 4 === 0 && y % 100 !== 0 || y % 400 === 0 ? 29 : 28;
    }
    function m() {
      const h10 = /* @__PURE__ */ new Date(), g = /* @__PURE__ */ new Date(), v = h10.getMonth(), y = Math.floor(v / 3);
      return h10.setMonth(y * 3), h10.setDate(1), h10.setHours(0, 0, 0, 0), g.setMonth(y * 3 + 2), g.setHours(23, 59, 59, 59), y === 0 || y === 3 ? g.setDate(31) : g.setDate(30), [h10, g];
    }
    function p() {
      const h10 = /* @__PURE__ */ new Date(), g = /* @__PURE__ */ new Date();
      return h10.setMonth(0), h10.setDate(1), h10.setHours(0, 0, 0, 0), g.setMonth(11), g.setDate(31), g.setHours(23, 59, 59, 59), [h10, g];
    }
    return provide(fn, o), t10(Ae({}, i)), (h10, g) => (openBlock(), createBlock(unref(ElDatePicker), mergeProps({
      ref_key: "datePickerRef",
      ref: i,
      class: ["k-date-picker", unref(r)]
    }, h10.$attrs, {
      type: h10.type,
      shortcuts: l.value,
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(h10.$slots, (v, y) => ({
        name: y,
        fn: withCtx((k) => [
          renderSlot(h10.$slots, y, normalizeProps(guardReactiveProps(k)))
        ])
      }))
    ]), 1040, ["class", "type", "shortcuts", "size"]));
  }
});
var Ff = $e(hy);
var gy = {
  key: 0,
  class: "default-sign"
};
var vy = { class: "file-list" };
var yy = ["onClick"];
var by = { class: "header-icon" };
var _y = ["title"];
var wy = { class: "status-icon-box" };
var Ty = { class: "status-icon" };
var Cy = { class: "remove-file" };
var ky = { class: "el-upload__tip" };
var Sy = defineComponent({
  name: "KUpload",
  __name: "upload",
  props: {
    drag: { type: Boolean },
    autoUpload: { type: Boolean },
    disabled: { type: Boolean },
    removeIcon: {},
    successIcon: {},
    failIcon: {},
    onPreview: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(), a = computed(() => (d) => {
      if (d === "success" && n.successIcon)
        return n.successIcon;
      if (d === "success")
        return Tp;
      if (d === "fail" && n.failIcon)
        return n.failIcon;
      if (d === "fail")
        return Rl;
    });
    function i(d) {
      var m;
      d && d.stopPropagation(), d && d.preventDefault(), (m = r.value) == null || m.submit();
    }
    function s(d, m) {
      var p;
      (p = r.value) == null || p.handleRemove(d, m);
    }
    function l(d) {
      var m;
      (m = n.onPreview) == null || m.call(n, d);
    }
    function c() {
      r.value.$el.querySelector("input").click();
    }
    return t10(Ae({ submit: i, selectFile: c, handleRemove: s }, r)), (d, m) => {
      const p = resolveComponent("k-button");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(["k-upload", unref(o), { "k-dragger": n.drag }])
      }, [
        createVNode(unref(ElUpload), mergeProps({
          ref_key: "KUploadRef",
          ref: r
        }, d.$attrs, {
          "on-preview": l,
          "auto-upload": d.autoUpload,
          disabled: d.disabled,
          drag: d.drag
        }), {
          trigger: withCtx(() => [
            renderSlot(d.$slots, "trigger", {}, () => [
              n.drag ? (openBlock(), createElementBlock("div", gy, [
                createVNode(unref(Np), { color: "#2882ff" }),
                createTextVNode(" " + toDisplayString(d.$t("uploadDragSign")), 1)
              ])) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: "default-upload-btn",
                onClick: m[0] || (m[0] = withModifiers(() => {
                }, ["stop"]))
              }, [
                createVNode(p, {
                  secondary: "",
                  "icon-left": d.autoUpload ? "IconUpload" : "",
                  onClick: c
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(n.autoUpload ? d.$t("uploadFile") : d.$t("selectFile")), 1)
                  ]),
                  _: 1
                }, 8, ["icon-left"]),
                n.autoUpload ? createCommentVNode("", true) : (openBlock(), createBlock(p, {
                  key: 0,
                  main: "",
                  class: "main-btn",
                  disabled: n.disabled,
                  "icon-left": "IconUpload",
                  onClick: i
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(d.$t("uploadFile")), 1)
                  ]),
                  _: 1
                }, 8, ["disabled"]))
              ]))
            ])
          ]),
          file: withCtx(({ file: f }) => [
            renderSlot(d.$slots, "file", {}, () => [
              createBaseVNode("div", vy, [
                createBaseVNode("div", null, [
                  createBaseVNode("a", {
                    onClick: (h10) => l(f)
                  }, [
                    createBaseVNode("span", by, [
                      createVNode(unref(Mp))
                    ]),
                    createBaseVNode("span", {
                      title: f.name
                    }, toDisplayString(f.name), 9, _y)
                  ], 8, yy),
                  f.status === "uploading" ? (openBlock(), createBlock(unref(ElProgress), {
                    key: 0,
                    type: "line",
                    "stroke-width": 2,
                    percentage: Number(f.percentage),
                    style: "margin-top: 0.5rem"
                  }, null, 8, ["percentage"])) : createCommentVNode("", true)
                ]),
                createBaseVNode("div", wy, [
                  createBaseVNode("span", Ty, [
                    (openBlock(), createBlock(resolveDynamicComponent(a.value(f.status)), {
                      color: f.status === "success" ? "#22c55e" : "#ef4444"
                    }, null, 8, ["color"]))
                  ]),
                  createBaseVNode("span", Cy, [
                    (openBlock(), createBlock(resolveDynamicComponent(n.removeIcon ?? unref(kp)), {
                      color: "#f97316",
                      onClick: (h10) => s(f)
                    }, null, 8, ["onClick"]))
                  ])
                ])
              ])
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", ky, [
              renderSlot(d.$slots, "tip")
            ])
          ]),
          _: 3
        }, 16, ["auto-upload", "disabled", "drag"])
      ], 2);
    };
  }
});
var Ny = $e(Sy);
var My = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_450_84265'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_3105_3983'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_450_84265)'%3e%3cg%20clip-path='url(%23master_svg1_3105_3983)'%3e%3c/g%3e%3cg%20transform='matrix(0,1,-1,0,24,-16)'%3e%3cg%3e%3cg%3e%3cpath%20d='M28,18.5234L21.02422,12.159531C20.911577,12.0567654,20.766101,12,20.615385,12C20.275517,12,20,12.282768,20,12.631579C20,12.811982,20.0751679,12.983774,20.206545,13.10363L27.591160000000002,19.84047C27.82432,20.053179999999998,28.17568,20.053179999999998,28.408839999999998,19.84047L35.7929,13.10416L35.7929,13.10416C35.9248,12.983774,36,12.811982,36,12.631579C36,12.282768,35.7245,12,35.3846,12C35.2339,12,35.0884,12.0567654,34.9758,12.159531L34.9758,12.159531L28,18.5234Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3cg%3e%3cpath%20d='M28,10.523399999999999L21.02422,4.159531C20.911577,4.0567654,20.766101,4,20.615385,4C20.275517,4,20,4.282768,20,4.631579C20,4.811982,20.0751679,4.983774,20.206545,5.10363L27.591160000000002,11.84047C27.82432,12.05318,28.17568,12.05318,28.408839999999998,11.84047L35.7929,5.10416L35.7929,5.10416C35.9248,4.983774,36,4.811982,36,4.631579C36,4.282768,35.7245,4,35.3846,4C35.2339,4,35.0884,4.0567654,34.9758,4.159531L34.9758,4.159531L28,10.523399999999999Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
var $y = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_3069_6476'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_3105_3984'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_3069_6476)'%3e%3cg%20clip-path='url(%23master_svg1_3105_3984)'%3e%3c/g%3e%3cg%20transform='matrix(0,-1,1,0,-16,24)'%3e%3cg%3e%3cg%3e%3cpath%20d='M12,34.39683575515747L5.02422,27.48749075515747C4.911577,27.37591675515747,4.766101,27.31428575515747,4.615385,27.31428575515747C4.275517,27.31428575515747,4,27.62129075515747,4,27.99999975515747C4,28.19586575515747,4.0751679,28.382385755157472,4.206545,28.51250575515747L11.59116,35.82679575515747C11.82432,36.057735755157466,12.17568,36.057735755157466,12.40884,35.82679575515747L19.7929,28.51308575515747L19.7929,28.51308575515747C19.924799999999998,28.382385755157472,20,28.19586575515747,20,27.99999975515747C20,27.62129075515747,19.7245,27.31428575515747,19.3846,27.31428575515747C19.2339,27.31428575515747,19.0884,27.37591675515747,18.9758,27.48749075515747L18.9758,27.48749075515747L12,34.39683575515747Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3cg%3e%3cpath%20d='M12,27.08255L5.02422,20.173205C4.911577,20.061631,4.766101,20,4.615385,20C4.275517,20,4,20.307005,4,20.685714C4,20.88158,4.0751679,21.0681,4.206545,21.19822L11.59116,28.51251C11.82432,28.74345,12.17568,28.74345,12.40884,28.51251L19.7929,21.1988L19.7929,21.1988C19.924799999999998,21.0681,20,20.88158,20,20.685714C20,20.307005,19.7245,20,19.3846,20C19.2339,20,19.0884,20.061631,18.9758,20.173205L18.9758,20.173205L12,27.08255Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
var xy = ["id"];
var Iy = { class: "k-transfer_searcher" };
var Dy = { class: "k-transfer-item" };
var Ay = { class: "k-transfer-label" };
var Ey = {
  id: "draggable",
  class: "k-transfer-sort"
};
var Ky = defineComponent({
  name: "KTransfer",
  __name: "transfer",
  props: {
    modelValue: {},
    data: {},
    filterablePlaceholder: {},
    props: {},
    matchKey: { default: "label" },
    defaultKeys: {},
    filterable: { type: Boolean, default: true }
  },
  emits: [
    "update:modelValue",
    "change",
    "left-check-change",
    "right-check-change",
    "input",
    "reset",
    "sort"
  ],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = n, a = inject("_styleModule", ""), i = inject("$t"), s = ref([]), l = ref(""), c = ref([]);
    let u = null, d, m = [];
    const p = Dt(8);
    onMounted(() => {
      k(), M();
    }), onUnmounted(() => {
      _ == null || _.destroy();
    });
    const f = computed(() => ({
      label: "label",
      key: "key",
      disabled: "disabled",
      ...o.props
    })), h10 = computed(() => o.filterablePlaceholder ?? (i == null ? void 0 : i("searchHeaderName")));
    watch(() => [o.modelValue, o.matchKey], () => {
      s.value = [], Array.isArray(o.modelValue) && o.modelValue.forEach((P) => {
        const F = o.data.find((N) => N[o.matchKey] === P[o.matchKey]);
        if (F) {
          const { key: N } = f.value;
          s.value.push(F[N]);
        }
      });
    }, { immediate: true }), watch(() => o.data, (P) => {
      if (P) {
        Array.isArray(P) || (c.value = [], m.length = 0), c.value = P, m = c.value.map((F) => F[f.value.key]);
        return;
      }
      c.value = [], m.length = 0;
    }, { immediate: true }), watch(() => l.value, (P) => {
      var F;
      if (!(!d || !d.length))
        for (let N = 0; N < d.length; N++) {
          if ((F = d[N]) != null && F.value)
            continue;
          d[N].value = P;
          const j = new Event("input", { bubbles: true });
          d[N].dispatchEvent(j);
        }
    }, { immediate: true });
    function g(P, F, N) {
      const j = w(P);
      r("update:modelValue", j), r("change", P, F, N);
    }
    function v(P, F) {
      r("left-check-change", P, F);
    }
    function y(P, F) {
      r("right-check-change", P, F);
    }
    function k() {
      if (u = document.getElementById(p), u === null)
        return;
      d = u.querySelectorAll(".el-transfer-panel__filter input");
      const P = u.querySelectorAll(".el-transfer-panel__header")[1], F = document.createElement("label");
      F.innerHTML = i == null ? void 0 : i("restoreDefault"), F.classList.add("transfer-restore__text"), F.addEventListener("click", () => {
        T();
      }), P.appendChild(F);
      const N = u.querySelectorAll(".el-transfer__button");
      N[0].innerHTML = `<img class="k-transfer__left-arrow" src="${My}" />`, N[1].innerHTML = `<img class="k-transfer__right-arrow" src="${$y}" />`;
    }
    function T() {
      if (!Array.isArray(o.defaultKeys))
        return;
      const { key: P } = f.value, F = o.data.filter((N) => {
        var j;
        return (j = o.defaultKeys) == null ? void 0 : j.includes(N[P]);
      });
      c.value.sort((N, j) => m.indexOf(N[P]) - m.indexOf(j[P])), r("update:modelValue", F), r("reset", [...o.defaultKeys]), r("sort", c.value);
    }
    function w(P) {
      const F = [], { key: N } = f.value;
      for (const j of P) {
        const z = c.value.find((A) => A[N] === j);
        z && F.push(z);
      }
      return F;
    }
    let _ = null;
    function M() {
      var F, N;
      const P = (N = (F = document.getElementById(p)) == null ? void 0 : F.querySelectorAll(".el-transfer-panel__list")) == null ? void 0 : N[1];
      P && (_ = new sortable_esm_default(P, {
        handle: ".k-transfer-sort",
        animation: 150,
        onEnd: (j) => {
          var D;
          const { newIndex: z, oldIndex: A } = j;
          if (z === A || z === void 0 || A === void 0)
            return;
          s.value.splice(z, 0, s.value.splice(A, 1)[0]), c.value = yd(c.value, s.value, ((D = o.props) == null ? void 0 : D.key) ?? "key");
          const B = w(s.value);
          r("update:modelValue", B), r("sort", c.value);
        }
      }));
    }
    function x() {
      return {
        sourceData: c.value,
        selectData: w(s.value)
      };
    }
    const R = ref(null);
    return t10(Ae({ getTransferData: x }, R)), (P, F) => (openBlock(), createElementBlock("div", {
      id: unref(p),
      class: normalizeClass(["k-transfer", unref(a)])
    }, [
      createBaseVNode("div", Iy, [
        P.filterable ? (openBlock(), createBlock(unref(ro), {
          key: 0,
          modelValue: l.value,
          "onUpdate:modelValue": F[0] || (F[0] = (N) => l.value = N),
          placeholder: h10.value,
          "prefix-icon": unref(Dr)
        }, null, 8, ["modelValue", "placeholder", "prefix-icon"])) : createCommentVNode("", true)
      ]),
      createVNode(unref(ElTransfer), mergeProps({
        ref_key: "kTransferRef",
        ref: R,
        modelValue: s.value,
        "onUpdate:modelValue": F[1] || (F[1] = (N) => s.value = N)
      }, P.$attrs, {
        data: c.value,
        props: o.props,
        format: {
          noChecked: " ",
          hasChecked: " "
        },
        filterable: "",
        onChange: g,
        onLeftCheckChange: v,
        onRightCheckChange: y
      }), {
        default: withCtx(({ option: N }) => [
          createBaseVNode("div", Dy, [
            createBaseVNode("span", Ay, toDisplayString(N[f.value.label]), 1),
            createBaseVNode("span", Ey, [
              s.value.includes(N[f.value.key]) ? (openBlock(), createBlock(unref(bl), { key: 0 })) : createCommentVNode("", true)
            ])
          ])
        ]),
        _: 1
      }, 16, ["modelValue", "data", "props"])
    ], 10, xy));
  }
});
var jf = $e(Ky);
var zy = { class: "k-operate__header" };
var Py = { class: "k-operate__content" };
var Ry = { class: "k-operate__list" };
var Ly = { class: "list-header" };
var Fy = ["onClick"];
var jy = { class: "k-operate-list__label" };
var Oy = {
  key: 0,
  class: "k-operate-rest"
};
var By = { class: "el-dropdown-link" };
var Zy = { class: "k-operate__close" };
var Wy = defineComponent({
  name: "KOperate",
  __name: "operate",
  props: {
    data: { default: () => [] },
    max: { default: 5 },
    total: { default: 0 },
    hideOnClick: { type: Boolean, default: true }
  },
  emits: ["close"],
  setup(e16, { emit: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref([]), a = ref([]);
    watch(() => [n.data, n.max], () => {
      var u;
      if (!Array.isArray(n.data)) {
        a.value = [], r.value = [];
        return;
      }
      const { max: c } = n;
      ((u = n.data) == null ? void 0 : u.length) > c ? (a.value = n.data.slice(0, c), r.value = n.data.slice(c)) : (a.value = n.data, r.value = []);
    }, { immediate: true, deep: true });
    const i = t10;
    function s(c) {
      const { disabled: u, handler: d } = c;
      u || typeof d == "function" && d();
    }
    function l() {
      i("close");
    }
    return (c, u) => Number.isInteger(c.total) && c.total > 0 ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(["k-operate", unref(o)])
    }, [
      createBaseVNode("span", zy, toDisplayString(c.total || "-"), 1),
      createBaseVNode("div", Py, [
        createBaseVNode("ul", Ry, [
          createBaseVNode("li", Ly, toDisplayString(c.$t("batchOperation")) + ":", 1),
          (openBlock(true), createElementBlock(Fragment, null, renderList(a.value, (d, m) => (openBlock(), createElementBlock("li", {
            key: m,
            class: normalizeClass(["k-operate-list__item", { "k-operate-list__item--disabled": d.disabled }]),
            onClick: (p) => s(d)
          }, [
            createBaseVNode("span", jy, toDisplayString(d.label), 1)
          ], 10, Fy))), 128)),
          r.value.length ? (openBlock(), createElementBlock("li", Oy, [
            createVNode(unref(ar), {
              trigger: "click",
              "hide-on-click": c.hideOnClick
            }, {
              title: withCtx(() => [
                createBaseVNode("span", By, [
                  createVNode(unref(oi), { color: "#2882FF" })
                ])
              ]),
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(r.value, (d, m) => (openBlock(), createBlock(unref(rr), {
                  key: m,
                  disabled: d.disabled,
                  class: "k-dropdown-item__content",
                  onClick: (p) => s(d)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(d.label), 1)
                  ]),
                  _: 2
                }, 1032, ["disabled", "onClick"]))), 128))
              ]),
              _: 1
            }, 8, ["hide-on-click"])
          ])) : createCommentVNode("", true)
        ]),
        createBaseVNode("div", Zy, [
          createVNode(unref(yl), { onClick: l })
        ])
      ])
    ], 2)) : createCommentVNode("", true);
  }
});
var Of = $e(Wy);
var qy = [
  // block colors
  {
    name: "__block__bg-color--normal",
    value: "500"
  },
  {
    name: "__block__bg-color--hover",
    value: "400"
  },
  // point colors
  {
    name: "__point-color--normal",
    value: "500"
  },
  {
    name: "__point-color--hover",
    value: "400"
  },
  {
    name: "__point-color--active",
    value: "300"
  },
  // border colors
  {
    name: "__border__border-color--normal",
    value: "500"
  },
  {
    name: "__border__border-color--hover",
    value: "400"
  },
  {
    name: "__border__bg-color--normal",
    value: "50"
  },
  {
    name: "__border__bg-color--hover",
    value: "50"
  },
  {
    name: "__border__text-color--normal",
    value: "500"
  },
  {
    name: "__border__text-color--hover",
    value: "400"
  }
];
var Vy = defineComponent({
  name: "KTag",
  __name: "tag",
  props: {
    type: { default: void 0 },
    color: {},
    size: {},
    point: { type: Boolean, default: false },
    text: { default: void 0 },
    border: { type: Boolean }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = kt(n), a = ref(), i = ref(n.color);
    return watch(
      () => n.color,
      (l) => {
        var u;
        if (!l)
          return;
        i.value = l;
        const c = (u = Nn == null ? void 0 : Nn(l)) == null ? void 0 : u.colorLevel;
        nextTick(() => {
          var d, m, p, f, h10;
          if ((m = (d = a.value) == null ? void 0 : d.$el) != null && m.style) {
            const g = (f = (p = c == null ? void 0 : c["--k-oklch-500"]) == null ? void 0 : p.match(/\(([^)]+)\)/)) == null ? void 0 : f[1];
            (h10 = a.value.$el) == null || h10.style.setProperty("--tag-color--focus", `rgba(${g}, 0.2)`), qy.forEach((v) => {
              var y;
              (y = a.value.$el) == null || y.style.setProperty(
                `--tag${v.name}`,
                c == null ? void 0 : c[`--k-oklch-${v.value}`]
              );
            });
          }
        });
      },
      { immediate: true }
    ), t10(Ae({}, a)), (l, c) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["k-tag", unref(o)])
    }, [
      createVNode(unref(ElTag), mergeProps({
        ref_key: "KTagRef",
        ref: a,
        class: [
          { "is-border": l.border },
          { "is-point": l.point },
          { [`k-tag__${l.type}`]: l.type },
          { "is-custom": i.value }
        ]
      }, l.$attrs, {
        size: unref(r).elSize
      }), {
        default: withCtx(() => [
          createBaseVNode("span", null, [
            renderSlot(l.$slots, "default", {}, () => [
              createTextVNode(toDisplayString(n.text), 1)
            ])
          ])
        ]),
        _: 3
      }, 16, ["class", "size"])
    ], 2));
  }
});
var Hy = $e(Vy);
var Uy = defineComponent({
  name: "KPopover",
  __name: "popover",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElPopover), mergeProps({
      ref_key: "KPopoverRef",
      ref: o,
      class: ["k-popover", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Io = $e(Uy);
var Gy = defineComponent({
  name: "KPopconfirm",
  __name: "popconfirm",
  props: {
    icon: { default: Cp }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(null);
    return t10(Ae({}, r)), (i, s) => (openBlock(), createBlock(unref(ElPopconfirm), mergeProps({
      ref_key: "KPopconfirmRef",
      ref: r,
      class: ["k-popconfirm", unref(o)]
    }, i.$attrs, {
      icon: n.icon,
      "cancel-button-type": "default"
    }), createSlots({ _: 2 }, [
      renderList(i.$slots, (l, c) => ({
        name: c,
        fn: withCtx((u) => [
          renderSlot(i.$slots, c, normalizeProps(guardReactiveProps(u)))
        ])
      }))
    ]), 1040, ["class", "icon"]));
  }
});
var Xy = $e(Gy);
var Yy = { style: { "max-width": "12vw", "max-height": "12vw", display: "flex", "justify-content": "center", "align-items": "center", margin: "0 auto", overflow: "hidden" } };
var Qy = {
  key: 0,
  class: "def-bg"
};
var Jy = ["data-h1"];
var e32 = { key: 1 };
var t3 = { key: 2 };
var n3 = {
  key: 1,
  class: "def-bg"
};
var o3 = { key: 1 };
var a3 = { key: 3 };
var r3 = { style: { display: "flex", "flex-direction": "column", "align-items": "center" } };
var i3 = {
  key: 0,
  class: "base-title"
};
var s3 = {
  key: 1,
  class: "base-title"
};
var l3 = { class: "base-subTitle" };
var c3 = { style: { display: "flex" } };
var u3 = defineComponent({
  name: "KResult",
  __name: "result",
  props: {
    status: { default: "" },
    title: { default: "" },
    content: {}
  },
  setup(e16) {
    const t10 = e16, n = inject("_styleModule", ""), o = ["403", "404", "500"], r = ["success", "warning", "info", "error"], a = computed(() => {
      switch (t10.status) {
        case "403":
          return { title: "你没有权限访问", color: "#a26ef4" };
        case "404":
          return { title: "对不起，您访问的页面不存在", color: "#1890ff" };
        case "500":
          return { title: "对不起，服务器错误", color: "#ff603b" };
        case "success":
          return { title: "success", color: "#52c41a" };
        case "warning":
          return { title: "warning", color: "#faad14" };
        case "info":
          return { title: "info", color: "#1890ff" };
        case "error":
          return { title: "error", color: "#ff4d4f" };
        default:
          return {
            title: "未知状态, 请在组件中正确使用 status / title / subTitle 属性, 或 #icon / #extra 插槽",
            color: "#ff4d4f"
          };
      }
    });
    return (i, s) => {
      const l = resolveComponent("IconLocked"), c = resolveComponent("IconCheck"), u = resolveComponent("IconClose");
      return openBlock(), createElementBlock("div", {
        id: "KResult",
        class: normalizeClass(["k-result", [unref(n)]])
      }, [
        createBaseVNode("div", Yy, [
          renderSlot(i.$slots, "icon", {}, () => [
            o.includes(i.status) ? (openBlock(), createElementBlock("div", Qy, [
              createBaseVNode("h1", { "data-h1": i.status }, [
                createTextVNode(toDisplayString(i.status) + " ", 1),
                createBaseVNode("div", {
                  class: "presuppose-icon",
                  style: normalizeStyle({ backgroundColor: a.value.color })
                }, [
                  i.status == "403" ? (openBlock(), createBlock(l, {
                    key: 0,
                    size: "1.8vw",
                    color: "#FFFFFF"
                  })) : createCommentVNode("", true),
                  i.status == "404" ? (openBlock(), createElementBlock("span", e32, "?")) : createCommentVNode("", true),
                  i.status == "500" ? (openBlock(), createElementBlock("span", t3, "!")) : createCommentVNode("", true)
                ], 4)
              ], 8, Jy),
              s[0] || (s[0] = createStaticVNode('<svg width="1132px" height="1098px" viewBox="0 0 1132 1098" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" data-v-2c7b8a62><g id="页面-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" data-v-2c7b8a62><g id="画板" transform="translate(-170, 0)" fill-rule="nonzero" data-v-2c7b8a62><g id="undraw_read_notes_gqmq" transform="translate(170, 0)" data-v-2c7b8a62><path id="路径" d="M1132,566.004115 C1132,878.608187 941.771293,858.439574 629.169503,858.439574 C559.683535,858.439574 429.971413,1119.48065 368.484892,1096.57632 L368.466007,1096.57632 C366.201988,1095.74618 363.956855,1094.87838 361.711702,1093.99156 C361.070292,1093.76516 360.428788,1093.51989 359.806263,1093.25574 C356.278197,1091.89739 352.768922,1090.48238 349.278626,1089.02959 C342.090426,1086.04871 334.977656,1082.91677 327.959312,1079.67173 C324.318065,1077.97368 320.69557,1076.25684 317.110979,1074.48336 C283.830162,1058.16354 252.379448,1038.65521 223.155001,1016.37351 C208.438908,1005.16663 194.270022,993.22402 180.742661,980.658672 C169.535861,970.244272 158.76307,959.39586 148.461814,948.113436 C145.216691,944.585343 142.04711,941.019499 138.915281,937.415996 C137.632366,935.963214 136.387091,934.510546 135.160833,933.057764 C126.274596,922.662136 117.784596,911.926925 109.671949,900.889882 C107.049463,897.324038 104.46473,893.720516 101.917768,890.079128 C84.6169594,865.363653 69.2406832,839.176529 55.9962459,811.781893 C20.1118094,737.446761 0,654.074336 0,566.004115 C0,253.400042 253.398229,0 566.000019,0 C878.601808,0 1132,253.400042 1132,566.004115 Z" fill="#eaeaea" data-v-2c7b8a62></path><path id="路径" d="M169.71637,924.60466 C169.71637,925.50539 170.43968,926.22869 171.3404,926.22869 L980.98032,926.22869 C981.88101,926.22869 982.60435,925.50538 982.60435,924.60466 C982.60435,923.70394 981.881,922.98063 980.98032,922.98063 L171.3404,922.98063 C170.43968,922.98063 169.71637,923.70394 169.71637,924.60466 Z" fill="#c2c3cb" data-v-2c7b8a62></path><path id="路径" d="M589.55989,764.33668 C587.33679,777.81193 575.61059,788.1245 561.51566,788.1245 C547.42073,788.1245 535.69457,777.81193 533.47147,764.33668 L461.72286,764.33668 L461.72286,919.82785 L661.30849,919.82785 L661.30849,764.33668 L589.55986,764.33668 L589.5599,764.33668 L589.55989,764.33668 Z" fill="#B6B3C5" data-v-2c7b8a62></path><rect id="矩形" fill="#B6B3C5" x="465.204" y="919.24777" width="19.72649" height="3.48113" data-v-2c7b8a62></rect><rect id="矩形" fill="#B6B3C5" x="639.84147" y="919.82798" width="19.72649" height="3.48113" data-v-2c7b8a62></rect><path id="路径" d="M962.90439,768.39805 L160.12674,768.39805 C153.99139,768.39805 149,763.40634 149,757.27126 L149,299.12674 C149,292.99168 153.99139,288 160.12674,288 L962.90439,288 C969.03976,288 974.03139,292.99168 974.03139,299.12674 L974.03139,757.2713 C974.03139,763.40638 969.03968,768.39805 962.90439,768.39805 L962.90439,768.39805 Z" fill="#c2c3cb" data-v-2c7b8a62></path><rect id="矩形" fill="#FFFFFF" x="169.30667" y="307.72662" width="785.57844" height="443.26583" data-v-2c7b8a62></rect></g></g></g></svg>', 1))
            ])) : createCommentVNode("", true),
            r.includes(i.status) ? (openBlock(), createElementBlock("div", n3, [
              createBaseVNode("div", {
                class: "presuppose-icon",
                style: normalizeStyle({ backgroundColor: a.value.color })
              }, [
                i.status == "success" ? (openBlock(), createBlock(c, {
                  key: 0,
                  size: "1.8vw",
                  color: "#FFFFFF"
                })) : createCommentVNode("", true),
                i.status == "warning" ? (openBlock(), createElementBlock("span", o3, "!")) : createCommentVNode("", true),
                i.status == "error" ? (openBlock(), createBlock(u, {
                  key: 2,
                  size: "1.8vw",
                  color: "#FFFFFF"
                })) : createCommentVNode("", true),
                i.status == "info" ? (openBlock(), createElementBlock("span", a3, "i")) : createCommentVNode("", true)
              ], 4)
            ])) : createCommentVNode("", true)
          ], true)
        ]),
        renderSlot(i.$slots, "title", {}, () => [
          createBaseVNode("div", r3, [
            i.title ? (openBlock(), createElementBlock("p", s3, toDisplayString(i.title), 1)) : (openBlock(), createElementBlock("p", i3, toDisplayString(a.value.title), 1)),
            createBaseVNode("p", l3, toDisplayString(i.content), 1)
          ])
        ], true),
        createBaseVNode("div", c3, [
          renderSlot(i.$slots, "extra", {}, void 0, true)
        ])
      ], 2);
    };
  }
});
var Ta = (e16, t10) => {
  const n = e16.__vccOpts || e16;
  for (const [o, r] of t10)
    n[o] = r;
  return n;
};
var d3 = Ta(u3, [["__scopeId", "data-v-2c7b8a62"]]);
var f3 = $e(d3);
var m3 = "data:image/svg+xml,%3csvg%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20fill='none'%20version='1.1'%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%3e%3cdefs%3e%3cclipPath%20id='master_svg0_3253_09938'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3cclipPath%20id='master_svg1_3253_09939'%3e%3crect%20x='0'%20y='0'%20width='24'%20height='24'%20rx='0'/%3e%3c/clipPath%3e%3c/defs%3e%3cg%20clip-path='url(%23master_svg0_3253_09938)'%3e%3cg%20clip-path='url(%23master_svg1_3253_09939)'%3e%3c/g%3e%3cg%3e%3cpath%20d='M8.6666259765625,11.375L3.6666259765625,11.375C3.3214479765625002,11.375,3.0416259765625,11.654822,3.0416259765625,12C3.0416259765625,12.345178,3.3214479765625002,12.625,3.6666259765625,12.625L8.0416259765625,12.625L8.0416259765625,14.5C8.0416259765625,14.84518,8.3214459765625,15.125,8.6666259765625,15.125L15.3333259765625,15.125C15.6784259765625,15.125,15.9583259765625,14.84518,15.9583259765625,14.5L15.9583259765625,12.625L20.3333259765625,12.625C20.6784259765625,12.625,20.9583259765625,12.345178,20.9583259765625,12C20.9583259765625,11.654822,20.6784259765625,11.375,20.3333259765625,11.375L15.3333259765625,11.375C14.9881259765625,11.375,14.7083259765625,11.654822,14.7083259765625,12L14.7083259765625,13.875L9.2916259765625,13.875L9.2916259765625,12C9.2916259765625,11.654822,9.0118059765625,11.375,8.6666259765625,11.375Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3cg%3e%3cpath%20d='M20.9185259765625,11.780555876464843C20.9448259765625,11.850725876464843,20.9583259765625,11.925055876464842,20.9583259765625,12.000005876464844L20.9583259765625,17.000035876464842Q20.9583259765625,17.949235876464844,20.2871259765625,18.620435876464846Q19.6158259765625,19.291635876464845,18.6666259765625,19.291635876464845L5.3332959765625,19.291635876464845Q4.3840559765625,19.291635876464845,3.7128399765625,18.620435876464846Q3.0416259765625,17.949235876464844,3.041626026233,17.000035876464842L3.0416259765625,12.000005876464844C3.041626026233,11.925055876464842,3.0551053765625,11.850725876464843,3.0814202765625,11.780555876464843L5.1758759765625,6.1953458764648435Q5.4274359765625,5.524509876464844,6.0163059765625,5.116422876464844Q6.6051759765625,4.708335876464844,7.3216259765625,4.708335876464844L16.678325976562498,4.7083359758059435Q17.394725976562498,4.708336025476844,17.9836259765625,5.116422876464844Q18.572525976562503,5.524510876464844,18.824025976562503,6.1953458764648435L20.9185259765625,11.780555876464843ZM17.653625976562502,6.634245876464844L19.7083259765625,12.113335876464845L19.7083259765625,17.000035876464842Q19.7083259765625,17.431435876464846,19.4032259765625,17.736535876464842Q19.0981259765625,18.041635876464845,18.6666259765625,18.041635876464845L5.3332959765625,18.041635876464845Q4.9018159765625,18.041635876464845,4.5967259765624995,17.736535876464842Q4.2916259765625,17.431435876464846,4.2916259765625,17.000035876464842L4.2916259765625,12.113335876464845L6.3462859765625,6.634245876464844Q6.5997559765625,5.958335876464844,7.3216259765625,5.958335876464844L16.678325976562498,5.958335876464844Q17.4001259765625,5.958335876464844,17.653625976562502,6.634245876464844Z'%20fill-rule='evenodd'%20fill='%2338363C'%20fill-opacity='1'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
var p3 = ["src"];
var h3 = defineComponent({
  name: "KEmpty",
  __name: "empty",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElEmpty), mergeProps({
      ref_key: "KEmptyRef",
      ref: o,
      class: ["k-empty", unref(n)]
    }, a.$attrs), createSlots({
      image: withCtx(() => [
        renderSlot(a.$slots, "icon", {}, () => [
          createBaseVNode("img", { src: unref(m3) }, null, 8, p3)
        ])
      ]),
      _: 2
    }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var g3 = $e(h3);
var Js = (e16) => {
  if (typeof e16 == "string")
    e16 = {
      message: e16
    };
  else {
    const { type: t10 } = e16;
    t10 === "warning" && (e16.icon = Rl);
  }
  return ElMessage(e16);
};
["success", "error", "info", "warning"].forEach((e16) => {
  const t10 = e16;
  Js[e16] = (n) => (typeof n == "string" ? n = {
    message: n,
    type: t10
  } : (e16 === "warning" && (n.icon = Rl), n.type = t10), Js(n));
});
var Bf = H2(Js, "$message");
var v3 = defineComponent({
  name: "KDialog",
  __name: "dialog",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref();
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElDialog), mergeProps({
      ref_key: "kDialogRef",
      ref: o,
      class: ["k-dialog", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var Zf = $e(v3);
var zu = [
  {
    label: "exactDate",
    value: "date"
  },
  {
    label: "dateRange",
    value: "range"
  },
  {
    label: "today",
    value: "today"
  },
  {
    label: "tomorrow",
    value: "tomorrow"
  },
  {
    label: "yesterday",
    value: "yesterday"
  },
  {
    label: "thisWeek",
    value: "current-week"
  },
  {
    label: "lastWeek",
    value: "last-week"
  },
  {
    label: "thisMonth",
    value: "current-month"
  },
  {
    label: "lastMonth",
    value: "last-month"
  },
  {
    label: "withinThePastSevenDays",
    value: "past-seven-days"
  },
  {
    label: "withinThePastThirtyDays",
    value: "past-thirty-days"
  }
];
var _s = [
  {
    type: "number",
    logicList: [
      {
        logic: "equal",
        handler(e16, t10) {
          return Number(e16) === Number(t10);
        }
      },
      {
        logic: "gt",
        handler(e16, t10) {
          return Number(e16) > Number(t10);
        }
      },
      {
        logic: "lt",
        handler(e16, t10) {
          return Number(e16) < Number(t10);
        }
      },
      {
        logic: "gte",
        handler(e16, t10) {
          return Number(e16) >= Number(t10);
        }
      },
      {
        logic: "lte",
        handler(e16, t10) {
          return Number(e16) <= Number(t10);
        }
      },
      {
        logic: "notEqual",
        handler(e16, t10) {
          return Number(e16) !== Number(t10);
        }
      },
      {
        logic: "empty",
        handler(e16) {
          return e16 == null || !e16.toString();
        }
      },
      {
        logic: "nonEmpty",
        handler(e16) {
          return !(e16 == null || !e16.toString());
        }
      }
    ]
  },
  {
    type: "string",
    logicList: [
      {
        logic: "equal",
        handler(e16, t10, n) {
          return n ? e16.toLowerCase() === t10.toLowerCase() : e16 === t10;
        }
      },
      {
        logic: "notEqual",
        handler(e16, t10, n) {
          return n ? e16.toLowerCase() === t10.toLowerCase() : e16 !== t10;
        }
      },
      {
        logic: "contain",
        handler(e16, t10, n) {
          return n ? e16.toLowerCase() === t10.toLowerCase() : e16.includes(t10);
        }
      },
      {
        logic: "empty",
        handler(e16) {
          return !e16;
        }
      },
      {
        logic: "nonEmpty",
        handler(e16) {
          return e16;
        }
      }
    ]
  },
  {
    type: "date",
    logicList: [
      {
        logic: "equal",
        handler(e16, t10) {
          return Array.isArray(t10) ? gn(e16) > gn(t10[0]) && gn(e16) < gn(t10[1]) : gn(e16) === gn(t10);
        }
      },
      {
        logic: "before",
        handler(e16, t10) {
          return gn(e16) < gn(t10);
        }
      },
      {
        logic: "after",
        handler(e16, t10) {
          return gn(e16) > gn(t10);
        }
      },
      {
        logic: "empty",
        handler(e16) {
          return !e16;
        }
      },
      {
        logic: "nonEmpty",
        handler(e16) {
          return e16;
        }
      }
    ]
  }
];
function gn(e16) {
  return e16 instanceof Date ? e16.getTime() : new Date(e16).getTime();
}
var y3 = { key: 1 };
var b3 = { class: "k-filter__content" };
var _3 = { class: "k-filter__header" };
var w3 = ["title"];
var T3 = { class: "k-filter__condition" };
var C3 = { class: "k-filter__logic" };
var k3 = ["title"];
var S3 = {
  key: 0,
  class: "k-filter__date-box"
};
var N3 = ["onClick"];
var M3 = { class: "k-filer__operate-left" };
var $3 = { class: "k-filer__operate-right" };
var x3 = { class: "select-label" };
var I3 = defineComponent({
  name: "KFilter",
  __name: "filter",
  props: {
    data: { default: () => [] },
    column: {},
    options: {},
    border: { type: Boolean, default: true },
    size: {},
    childrenField: { default: "children" },
    filterKey: { default: "title" },
    defaultCondition: {},
    remote: { type: [Boolean, Array] },
    formatter: {},
    ignoreCase: { type: Boolean, default: false },
    showPopper: { type: Boolean }
  },
  emits: ["confirm", "clear", "show", "hide"],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = kt(o);
    onMounted(() => {
      ["column"].forEach((K) => {
        o[K] && console.warn(`[KFilter] The "${K}" field is deprecated, please use "options" instead.`);
      });
    });
    const a = ref(""), i = inject("_styleModule", ""), s = n, l = inject("$t"), c = ref([]), u = ref(0), d = computed(() => Fr(Sr(o.options), "group")), m = computed(
      () => function(E) {
        var ee;
        return (ee = d.value) == null ? void 0 : ee.find((V) => V[o.filterKey] === E);
      }
    ), p = computed(
      () => function(E) {
        var V;
        const K = (V = d.value) == null ? void 0 : V.find((le) => le[o.filterKey] === E.key), ee = (K == null ? void 0 : K.dataType) || "string";
        return _s.find((le) => le.type === ee);
      }
    ), f = computed(
      () => function(E) {
        if (E.logic === "equal")
          return zu;
        const K = ["past-seven-days", "past-thirty-days"];
        return zu.filter((ee) => !K.includes(ee.value));
      }
    ), h10 = computed(() => c.value.some(
      (E) => E.key && E.logic && (E.value || ["empty", "nonEmpty"].includes(E.logic))
    )), g = computed(
      () => function(E) {
        const K = ["empty", "nonEmpty"];
        return !E.logic || K.includes(E.logic);
      }
    ), v = computed(
      () => function(E) {
        const K = ["date", "range"];
        return g.value(E) || !K.includes(E.dateRange);
      }
    ), y = computed(() => {
      const E = c.value.map((K) => K.key);
      return o.remote === true || Array.isArray(o.remote) && o.remote.some((K) => E.includes(K));
    });
    watch(
      () => y.value,
      (E) => {
        E && (u.value = 1);
      },
      { immediate: true }
    ), k();
    function k() {
      var K, ee, V;
      u.value = ((K = o.defaultCondition) == null ? void 0 : K.filterRule) ?? 0;
      const { conditionList: E = [] } = o.defaultCondition ?? {};
      if (!Array.isArray(E) || !E.length) {
        T();
        return;
      }
      for (let le = 0; le < E.length; le++)
        T();
      for (let le = 0; le < c.value.length; le++) {
        const pe = c.value[le], { title: Te, logic: Z, value: X, showValue: Q, key: W, handler: de } = E[le];
        pe.title = Te.split("-"), pe.logic = Z, pe.value = X, pe.showValue = Q, pe.key = W, pe.handler = de;
        const Ne = (ee = d.value) == null ? void 0 : ee.find((Pe) => Pe[o.filterKey] === W);
        pe._allowSelectLogic = !((V = Ne.options) != null && V.length), Ne.dataType === "date" && !Array.isArray(X) ? (pe.dateRange = "date", pe.dateType = "datetime") : Ne.dataType === "date" && Array.isArray(X) && (pe.dateRange = "range", pe.dateType = "datetimerange");
      }
    }
    function T() {
      const E = {
        title: [],
        logic: "",
        showValue: "",
        value: "",
        key: "",
        handler: null,
        dateRange: "date",
        dateType: "datetime"
      };
      c.value.push(E);
    }
    function w(E) {
      if (E === 0 && c.value.length === 1) {
        _(false);
        return;
      }
      c.value.splice(E, 1);
    }
    function _(E = true) {
      return c.value.length = 0, T(), E ? x() : {};
    }
    function M() {
      const { conditionInfo: E, tableData: K } = x();
      s("confirm", E, K ?? []);
    }
    function x(E) {
      const K = Array.isArray(E) ? E : o.data, ee = R();
      if (ee.conditionList.length === 0 || o.remote === true)
        return {
          conditionInfo: ee,
          tableData: K
        };
      const V = I(), le = K == null ? void 0 : K.filter((pe) => u.value === 0 ? ee.conditionList.some((Te) => {
        var X, Q;
        if (V.has(Te.key))
          return true;
        const Z = (X = d.value) == null ? void 0 : X.find((W) => W[o.filterKey] === Te.key);
        return !Z || !Z[o.filterKey] ? false : (Q = Te.handler) == null ? void 0 : Q.call(Te, pe[Z[o.filterKey]], Te.value, o.ignoreCase);
      }) : ee.conditionList.every((Te) => {
        var X, Q;
        if (V.has(Te.key))
          return true;
        const Z = (X = d.value) == null ? void 0 : X.find((W) => W[o.filterKey] === Te.key);
        return !Z || !Z[o.filterKey] ? false : (Q = Te.handler) == null ? void 0 : Q.call(Te, pe[Z[o.filterKey]], Te.value, o.ignoreCase);
      }));
      return {
        conditionInfo: ee,
        tableData: le ?? []
      };
    }
    function R() {
      const E = ["empty", "nonEmpty"];
      return {
        conditionList: c.value.filter(
          (ee) => ee.key && ee.logic && (vd(ee.value) || E.includes(ee.logic))
        ).map((ee) => ({
          title: ee.title.join(" - "),
          logic: l == null ? void 0 : l(ee.logic),
          key: ee.key,
          showValue: ee.showValue,
          value: ee.value,
          handler: ee.handler
        })),
        filterRule: u.value
      };
    }
    function I() {
      return Array.isArray(o.remote) ? new Map(o.remote.map((E, K) => [E, K])) : /* @__PURE__ */ new Map();
    }
    function P(E) {
      var Te;
      const K = c.value[E], ee = K.title ?? [];
      if (ee.length === 0) {
        K.key = null, K.logic = "equal", K.value = "", K.showValue = "";
        return;
      }
      let V = o.options ?? [], le;
      for (const Z of ee)
        le = V == null ? void 0 : V.find((X) => X.title === Z), V = (le == null ? void 0 : le.group) ?? [];
      K.key = le == null ? void 0 : le[o.filterKey], K.logic = "equal";
      const pe = _s.find(
        (Z) => Z.type === ((le == null ? void 0 : le.dataType) || "string")
      );
      if (pe) {
        const Z = pe.logicList.find((X) => X.logic === "equal");
        K.handler = (Z == null ? void 0 : Z.handler) ?? null;
      }
      (Te = le == null ? void 0 : le.options) != null && Te.length ? (K.value = le.options[0].value, K.showValue = le.options[0].label, K._allowSelectLogic = false) : (K.value = "", K.showValue = "", K._allowSelectLogic = true);
    }
    function F(E) {
      var le;
      (E.logic === "after" || E.logic === "before") && E.dateType === "datetimerange" && (E.dateType = "datetime", E.dateRange = "date");
      const K = ((le = m.value(E.key)) == null ? void 0 : le.dataType) ?? "string", ee = _s.find((pe) => pe.type === K);
      if (!ee)
        return;
      g.value(E) && (E.value = "", E.showValue = "");
      const V = ee.logicList.find((pe) => pe.logic === E.logic);
      E.handler = (V == null ? void 0 : V.handler) ?? null, K === "date" && N(E);
    }
    function N(E) {
      if (g.value(E)) {
        E.value = "", E.showValue = "";
        return;
      }
      j(E);
    }
    function j(E) {
      te(E);
      let K = Array.isArray(E.value) ? "" : E.value;
      switch (E.dateRange) {
        case "range":
          K = ["", ""];
          break;
        case "today":
          K = z(0);
          break;
        case "tomorrow":
          K = z(1);
          break;
        case "yesterday":
          K = z(-1);
          break;
        case "current-week":
          K = [z(-A() + 1), z(7 - A(), true)];
          break;
        case "last-week":
          K = [z(-A() - 6), z(-A(), true)];
          break;
        case "current-month":
          K = [
            z(-B() + 1),
            z(D() - B(), true)
          ];
          break;
        case "last-month":
          K = [
            z(-B() - D(true) + 1),
            z(-B(), true)
          ];
          break;
        case "past-seven-days":
          K = [z(-7), z(-1, true)];
          break;
        case "past-thirty-days":
          K = [z(-30), z(-1, true)];
          break;
      }
      const ee = ["current-week", "last-week", "current-month", "last-month"];
      E.dateType === "datetime" && ee.includes(E.dateRange) ? (E.value = K[0], E.showValue = hr(K[0], o.formatter)) : (E.value = K, Array.isArray(K) ? E.showValue = hr(K, o.formatter).join(" - ") : E.showValue = hr(K, o.formatter));
    }
    function z(E, K = false) {
      const ee = /* @__PURE__ */ new Date(), V = new Date(ee);
      return V.setDate(V.getDate() + E), K ? V.setHours(23, 59, 59, 0) : V.setHours(0, 0, 0, 0), V;
    }
    function A() {
      return (/* @__PURE__ */ new Date()).getDay();
    }
    function B() {
      return (/* @__PURE__ */ new Date()).getDate();
    }
    function D(E = false) {
      const K = (/* @__PURE__ */ new Date()).getMonth() + 1, ee = E ? K - 1 : K, V = [1, 3, 5, 7, 8, 10, 12], le = [4, 6, 9, 11];
      if (V.includes(ee))
        return 31;
      if (le.includes(ee))
        return 30;
      const pe = (/* @__PURE__ */ new Date()).getFullYear();
      return pe % 4 === 0 && pe % 100 !== 0 || pe % 400 === 0 ? 29 : 28;
    }
    function te(E) {
      if (E.logic === "equal") {
        const K = ["date", "today", "tomorrow", "yesterday"];
        E.dateType = K.includes(E.dateRange) ? "datetime" : "datetimerange";
      } else if (E.logic === "after" || E.logic === "before") {
        const K = ["range"];
        E.dateType = K.includes(E.dateRange) ? "datetimerange" : "datetime";
      }
    }
    function ie(E, K, ee) {
      if (K === "input")
        E.showValue = E.value;
      else if (K === "select") {
        const V = ee == null ? void 0 : ee.find((le) => le.value === E.value);
        E.showValue = (V == null ? void 0 : V.label) ?? "";
      }
    }
    function U(E, K) {
      const ee = hr(E, o.formatter);
      K.showValue = Array.isArray(ee) ? ee.join(" - ") : ee;
    }
    function oe() {
      s("show");
    }
    function se() {
      s("hide");
    }
    return t10({ filter: x, clearFilter: _, getConditionInfo: R }), (E, K) => {
      const ee = resolveComponent("k-date-picker");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          "k-filter",
          { "text-sm": unref(r).ownSize === "sm", "text-base": unref(r).ownSize !== "sm" },
          unref(i)
        ])
      }, [
        createVNode(unref(Io), {
          trigger: "click",
          width: "auto",
          teleported: false,
          placement: "bottom-end",
          "popper-class": a.value,
          onBeforeEnter: K[2] || (K[2] = () => a.value = "k-filter-popper__enter"),
          onBeforeLeave: K[3] || (K[3] = () => a.value = "k-filter-popper__leave"),
          onShow: oe,
          onHide: se
        }, {
          reference: withCtx(() => [
            renderSlot(E.$slots, "reference", { hasConfigCondition: h10.value }, () => [
              E.border ? (openBlock(), createBlock(unref(Lt), {
                key: 0,
                size: unref(r).ownSize
              }, {
                default: withCtx(() => [
                  h10.value ? (openBlock(), createBlock(unref(Ir), {
                    key: 1,
                    color: "#2882FF"
                  })) : (openBlock(), createBlock(unref(La), { key: 0 }))
                ]),
                _: 1
              }, 8, ["size"])) : (openBlock(), createElementBlock("span", y3, [
                h10.value ? (openBlock(), createBlock(unref(Ir), {
                  key: 1,
                  color: "#2882FF"
                })) : (openBlock(), createBlock(unref(La), { key: 0 }))
              ]))
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", b3, [
              createBaseVNode("div", _3, [
                createBaseVNode("span", {
                  class: normalizeClass([unref(r).ownSize === "sm" ? "text-base" : "text-lg", "font-bold"])
                }, toDisplayString(E.$t("advancedFilter")), 3),
                createBaseVNode("span", {
                  class: normalizeClass(unref(r).ownSize === "sm" ? "text-sm" : "text-base"),
                  onClick: K[0] || (K[0] = () => {
                    _(), s("clear");
                  })
                }, [
                  createVNode(unref(h0)),
                  createTextVNode(" " + toDisplayString(E.$t("clearAll")), 1)
                ], 2)
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(c.value, (V, le) => {
                var pe, Te, Z, X, Q;
                return openBlock(), createElementBlock("div", {
                  key: le,
                  title: (pe = V.title) == null ? void 0 : pe.join("/"),
                  class: "k-filter__item"
                }, [
                  createBaseVNode("div", T3, [
                    createVNode(unref(Lf), {
                      modelValue: V.title,
                      "onUpdate:modelValue": (W) => V.title = W,
                      teleported: false,
                      size: unref(r).ownSize,
                      options: E.options,
                      props: {
                        label: "title",
                        value: "title",
                        children: o.childrenField
                      },
                      clearable: "",
                      onChange: (W) => P(le)
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "size", "options", "props", "onChange"])
                  ]),
                  createBaseVNode("div", C3, [
                    createVNode(unref(Go), {
                      modelValue: V.logic,
                      "onUpdate:modelValue": (W) => V.logic = W,
                      size: unref(r).ownSize,
                      teleported: false,
                      clearable: "",
                      disabled: V._allowSelectLogic === false,
                      onChange: (W) => F(V)
                    }, {
                      default: withCtx(() => {
                        var W;
                        return [
                          (openBlock(true), createElementBlock(Fragment, null, renderList((W = p.value(V)) == null ? void 0 : W.logicList, (de) => (openBlock(), createBlock(unref(vo), {
                            key: de.logic,
                            label: E.$t(de.logic),
                            value: de.logic
                          }, null, 8, ["label", "value"]))), 128))
                        ];
                      }),
                      _: 2
                    }, 1032, ["modelValue", "onUpdate:modelValue", "size", "disabled", "onChange"])
                  ]),
                  createBaseVNode("div", {
                    class: "k-filter__value",
                    title: (Te = V.value) == null ? void 0 : Te.toString()
                  }, [
                    ((Z = m.value(V.key)) == null ? void 0 : Z.dataType) === "date" ? (openBlock(), createElementBlock("div", S3, [
                      createVNode(unref(Go), {
                        modelValue: V.dateRange,
                        "onUpdate:modelValue": (W) => V.dateRange = W,
                        size: unref(r).ownSize,
                        teleported: false,
                        clearable: "",
                        disabled: g.value(V),
                        onChange: (W) => j(V)
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(f.value(V), (W) => (openBlock(), createBlock(unref(vo), {
                            key: W.value,
                            label: E.$t(W.label),
                            value: W.value,
                            disabled: (V.logic === "after" || V.logic === "before") && W.value === "range"
                          }, null, 8, ["label", "value", "disabled"]))), 128))
                        ]),
                        _: 2
                      }, 1032, ["modelValue", "onUpdate:modelValue", "size", "disabled", "onChange"]),
                      createVNode(ee, {
                        modelValue: V.value,
                        "onUpdate:modelValue": (W) => V.value = W,
                        type: V.dateType,
                        teleported: false,
                        size: unref(r).ownSize,
                        clearable: "",
                        disabled: v.value(V),
                        onChange: (W) => {
                          U(W, V);
                        }
                      }, null, 8, ["modelValue", "onUpdate:modelValue", "type", "size", "disabled", "onChange"])
                    ])) : (Q = (X = m.value(V.key)) == null ? void 0 : X.options) != null && Q.length ? (openBlock(), createBlock(unref(Go), {
                      key: 1,
                      modelValue: V.value,
                      "onUpdate:modelValue": (W) => V.value = W,
                      size: unref(r).ownSize,
                      teleported: false,
                      disabled: g.value(V),
                      clearable: "",
                      onChange: (W) => ie(V, "select", m.value(V.key).options)
                    }, {
                      default: withCtx(() => {
                        var W;
                        return [
                          (openBlock(true), createElementBlock(Fragment, null, renderList((W = m.value(V.key)) == null ? void 0 : W.options, (de) => (openBlock(), createBlock(unref(vo), {
                            key: de.value,
                            label: de.label,
                            value: de.value
                          }, null, 8, ["label", "value"]))), 128))
                        ];
                      }),
                      _: 2
                    }, 1032, ["modelValue", "onUpdate:modelValue", "size", "disabled", "onChange"])) : (openBlock(), createBlock(unref(ro), {
                      key: 2,
                      modelValue: V.value,
                      "onUpdate:modelValue": (W) => V.value = W,
                      size: unref(r).ownSize,
                      disabled: g.value(V),
                      clearable: "",
                      onChange: (W) => ie(V, "input", m.value(V.key).options)
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "size", "disabled", "onChange"]))
                  ], 8, k3),
                  createBaseVNode("i", {
                    class: "close-icon",
                    onClick: (W) => w(le)
                  }, [
                    createVNode(unref(yl))
                  ], 8, N3)
                ], 8, w3);
              }), 128)),
              createBaseVNode("div", {
                class: normalizeClass(["k-filter__operate", unref(r).ownSize === "sm" ? "text-sm" : "text-base"])
              }, [
                createBaseVNode("div", M3, [
                  createBaseVNode("span", { onClick: T }, [
                    createVNode(unref(_p)),
                    createTextVNode(" " + toDisplayString(E.$t("addCondition")), 1)
                  ])
                ]),
                createBaseVNode("div", $3, [
                  createBaseVNode("span", x3, toDisplayString(E.$t("aboveCondition")) + "：", 1),
                  createVNode(unref(Go), {
                    modelValue: u.value,
                    "onUpdate:modelValue": K[1] || (K[1] = (V) => u.value = V),
                    size: unref(r).ownSize,
                    disabled: y.value,
                    teleported: false
                  }, {
                    default: withCtx(() => [
                      createVNode(unref(vo), {
                        label: E.$t("anyOne"),
                        value: 0
                      }, null, 8, ["label"]),
                      createVNode(unref(vo), {
                        label: E.$t("all"),
                        value: 1
                      }, null, 8, ["label"])
                    ]),
                    _: 1
                  }, 8, ["modelValue", "size", "disabled"]),
                  createVNode(unref(Lt), {
                    size: unref(r).ownSize,
                    main: "",
                    onClick: M
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(E.$t("query")), 1)
                    ]),
                    _: 1
                  }, 8, ["size"])
                ])
              ], 2)
            ])
          ]),
          _: 3
        }, 8, ["popper-class"])
      ], 2);
    };
  }
});
var Wf = $e(I3);
var na = null;
var ws = null;
var Wn = null;
var Pu = "z-index-manage";
var ho = null;
var Ru = "z-index-style";
var qf = "m";
var Vf = "s";
var Ga = {
  m: 1e3,
  s: 1e3
};
function Ql() {
  return na || typeof document < "u" && (na = document), na;
}
function Hf() {
  return na && !ws && (ws = na.body || na.getElementsByTagName("body")[0]), ws;
}
function D3() {
  var e16 = 0, t10 = Ql();
  if (t10) {
    var n = Hf();
    if (n)
      for (var o = n.getElementsByTagName("*"), r = 0; r < o.length; r++) {
        var a = o[r];
        if (a && a.style && a.nodeType === 1) {
          var i = a.style.zIndex;
          i && /^\d+$/.test(i) && (e16 = Math.max(e16, Number(i)));
        }
      }
  }
  return e16;
}
function A3() {
  if (!ho) {
    var e16 = Ql();
    e16 && (ho = e16.getElementById(Ru), ho || (ho = e16.createElement("style"), ho.id = Ru, e16.getElementsByTagName("head")[0].appendChild(ho)));
  }
  return ho;
}
function Uf() {
  var e16 = A3();
  if (e16) {
    var t10 = "--dom-", n = "-z-index";
    e16.innerHTML = ":root{" + t10 + "main" + n + ":" + Ti() + ";" + t10 + "sub" + n + ":" + tc() + "}";
  }
}
function Gf() {
  if (!Wn) {
    var e16 = Ql();
    if (e16 && (Wn = e16.getElementById(Pu), !Wn)) {
      var t10 = Hf();
      t10 && (Wn = e16.createElement("div"), Wn.id = Pu, Wn.style.display = "none", t10.appendChild(Wn), Jl(Ga.m), ec(Ga.s));
    }
  }
  return Wn;
}
function Xf(e16) {
  return function(t10) {
    if (t10) {
      t10 = Number(t10), Ga[e16] = t10;
      var n = Gf();
      n && (n.dataset ? n.dataset[e16] = t10 + "" : n.setAttribute("data-" + e16, t10 + ""));
    }
    return Uf(), Ga[e16];
  };
}
var Jl = Xf(qf);
function Yf(e16, t10) {
  return function(o) {
    var r, a = Gf();
    if (a) {
      var i = a.dataset ? a.dataset[e16] : a.getAttribute("data-" + e16);
      i && (r = Number(i));
    }
    return r || (r = Ga[e16]), o ? Number(o) < r ? t10() : o : r;
  };
}
var Ti = Yf(qf, Qf);
function Qf() {
  return Jl(Ti() + 1);
}
var ec = Xf(Vf);
var Jf = Yf(Vf, e1);
function tc() {
  return Ti() + Jf();
}
function e1() {
  return ec(Jf() + 1), tc();
}
var Lu = {
  setCurrent: Jl,
  getCurrent: Ti,
  getNext: Qf,
  setSubCurrent: ec,
  getSubCurrent: tc,
  getSubNext: e1,
  getMax: D3
};
Uf();
var E3 = { class: "__column-drag-icon" };
var K3 = "desc-change";
var z3 = "hide-column";
var P3 = defineComponent({
  name: "KTable",
  __name: "table",
  props: {
    data: {},
    showDragColumn: { type: Boolean, default: false },
    showColumnMenu: { type: Boolean }
  },
  emits: [
    "desc-change",
    "hide-column",
    "drag",
    "sort-change",
    "clear-sort",
    "filter-change",
    "filter-visible",
    "clear-filter"
  ],
  setup(e16, { expose: t10, emit: n }) {
    const o = {
      descChange: {
        name: "desc-change",
        callback: h10.bind(this)
      },
      hideColumn: {
        name: "hide-column",
        callback: g.bind(this)
      },
      clearFilter: {
        name: "clear-filter",
        callback: x.bind(this)
      },
      filterChange: {
        name: "filter-change",
        callback: _.bind(this)
      },
      filterVisible: {
        name: "filter-visible",
        callback: M.bind(this)
      },
      sortChange: {
        name: "sort-change",
        callback: T.bind(this)
      },
      clearSort: {
        name: "clear-sort",
        callback: w.bind(this)
      }
    }, r = e16, a = inject("_styleModule", ""), i = useSlots(), s = Dt(8), l = inject("_emitter");
    for (const I in o) {
      const { name: P, callback: F } = o[I];
      l.on(P, s, F);
    }
    const c = n;
    onMounted(() => {
      p();
    });
    const u = ref();
    let d, m;
    nextTick(() => {
      d = setTimeout(() => {
        f();
      }, 500), R.value && (R.value.openFilter = y, R.value.closeFilter = k);
    }), onUnmounted(() => {
      for (const I in o) {
        const { name: P } = o[I];
        l.remove(P, s);
      }
      clearTimeout(d), m && m.destroy();
    });
    function p() {
      const I = Lu.getMax();
      Lu.setCurrent(I + 1);
    }
    function f() {
      const I = u.value;
      if (!I || !I.$el)
        return;
      const P = I.$el.querySelector(".body--wrapper > .vxe-table--body tbody");
      P && (m = sortable_esm_default.create(P, {
        handle: ".__column-drag-icon",
        animation: 150,
        onEnd: (F) => {
          c("drag", F);
        }
      }));
    }
    function h10(I, P) {
      c(K3, I, P);
    }
    function g(I) {
      c(z3, I);
    }
    const v = ref({
      field: "___default___",
      isOpen: false
    });
    function y(I) {
      return new Promise((P) => {
        let F = I;
        typeof I == "object" && (F = I.field ?? ""), v.value.field = F, v.value.isOpen = true, P(true);
      });
    }
    function k(I) {
      return new Promise((P) => {
        let F = I;
        typeof I == "object" && (F = I.field ?? ""), v.value.field = F, v.value.isOpen = false, P(true);
      });
    }
    function T(I) {
      c("sort-change", I);
    }
    function w(I) {
      c("clear-sort", I);
    }
    function _(I) {
      c("filter-change", I);
    }
    function M(I) {
      c("filter-visible", I);
    }
    function x(I) {
      c("clear-filter", I);
    }
    provide("tableInstance", u), provide("tableId", s), provide("showColumnMenu", r.showColumnMenu), provide("filterPanelConfig", v);
    const R = computed(() => u.value);
    return t10({
      tableInstance: R
    }), (I, P) => (openBlock(), createBlock(unref(VxeTable), mergeProps({
      ref_key: "vxeTableRef",
      ref: u,
      class: ["k-table", unref(a), { drag_table: I.showDragColumn }],
      data: I.data
    }, I.$attrs), createSlots({
      default: withCtx(() => [
        I.showDragColumn ? (openBlock(), createBlock(unref(VxeColumn), {
          key: 0,
          width: "25",
          class: "drag-column"
        }, {
          default: withCtx(() => [
            createBaseVNode("span", E3, [
              renderSlot(I.$slots, "dragIcon", {}, () => [
                createVNode(unref(bl))
              ])
            ])
          ]),
          _: 3
        })) : createCommentVNode("", true),
        renderSlot(I.$slots, "default", normalizeProps(guardReactiveProps(I.data)))
      ]),
      _: 2
    }, [
      i.empty ? {
        name: "empty",
        fn: withCtx((F) => [
          renderSlot(I.$slots, "empty", normalizeProps(guardReactiveProps(F)))
        ]),
        key: "0"
      } : void 0,
      i.loading ? {
        name: "loading",
        fn: withCtx((F) => [
          renderSlot(I.$slots, "loading", normalizeProps(guardReactiveProps(F)))
        ]),
        key: "1"
      } : void 0
    ]), 1040, ["class", "data"]));
  }
});
var R3 = { class: "filter-menu" };
var L3 = { class: "filter-menu-item" };
var F3 = { class: "filter-buttons" };
var Fu = defineComponent({
  __name: "filter_popper",
  props: {
    filters: { default: () => [] },
    column: { default: () => ({}) },
    trigger: { default: "hover" },
    visible: { type: Boolean, default: void 0 },
    text: { default: () => ({}) }
  },
  emits: ["set-filter", "clear-filter", "filter-change", "filter-visible"],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = n, a = ref(), i = ref(false), s = ref(false);
    function l() {
      var f;
      c(false), r("filter-visible", o.column, (f = o.column) == null ? void 0 : f.field, true, o.filters);
    }
    function c(f) {
      var g, v, y;
      if (f && r("filter-change", o.column, (g = o.column) == null ? void 0 : g.field, o.filters), !Array.isArray(o.filters)) {
        i.value = false;
        return;
      }
      i.value = (v = o.filters) == null ? void 0 : v.every((k) => k.checked);
      const h10 = (y = o.filters) == null ? void 0 : y.some((k) => k.checked);
      !i.value && h10 ? s.value = true : s.value = false;
    }
    function u() {
      var f, h10;
      i.value && s.value && (s.value = false), (f = o.filters) == null || f.forEach((g) => {
        g.checked = i.value;
      }), r("filter-change", o.column, (h10 = o.column) == null ? void 0 : h10.field, o.filters);
    }
    function d() {
      r("set-filter", o.column, o.filters), p();
    }
    function m() {
      var f;
      (f = o.filters) == null || f.forEach((h10) => {
        h10.checked = false;
      }), s.value = false, i.value = false, r("clear-filter", o.column), p();
    }
    function p() {
      var f;
      (f = a.value) == null || f.hide();
    }
    return t10({ closeFilterPanel: p }), (f, h10) => {
      var g;
      return openBlock(), createBlock(unref(Io), {
        ref_key: "filterPopper",
        ref: a,
        trigger: f.trigger,
        "show-arrow": false,
        placement: "right-start",
        "popper-class": "filter-box",
        offset: 2,
        disabled: !((g = o.filters) != null && g.length),
        teleported: true,
        visible: f.visible,
        onShow: l
      }, {
        reference: withCtx(() => [
          renderSlot(f.$slots, "default")
        ]),
        default: withCtx(() => [
          renderSlot(f.$slots, "filter", {}, () => [
            createBaseVNode("ul", R3, [
              createBaseVNode("li", L3, [
                createVNode(unref(fa), {
                  modelValue: i.value,
                  "onUpdate:modelValue": h10[0] || (h10[0] = (v) => i.value = v),
                  label: f.$t("all"),
                  value: "all",
                  indeterminate: s.value,
                  onChange: u
                }, null, 8, ["modelValue", "label", "indeterminate"])
              ]),
              (openBlock(true), createElementBlock(Fragment, null, renderList(o.filters, (v, y) => (openBlock(), createElementBlock("li", {
                key: y,
                class: "filter-menu-item"
              }, [
                createVNode(unref(fa), {
                  modelValue: v.checked,
                  "onUpdate:modelValue": (k) => v.checked = k,
                  label: v.label,
                  value: v.value,
                  onChange: h10[1] || (h10[1] = (k) => c(true))
                }, null, 8, ["modelValue", "onUpdate:modelValue", "label", "value"])
              ]))), 128))
            ])
          ]),
          createBaseVNode("div", F3, [
            createVNode(unref(Lt), {
              size: "sm",
              onClick: m
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(f.text.resetButtonText ?? f.$t("reset")), 1)
              ]),
              _: 1
            }),
            createVNode(unref(Lt), {
              class: "filter-btn-item",
              size: "sm",
              secondary: "",
              onClick: d
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(f.text.confirmButtonText ?? f.$t("filter")), 1)
              ]),
              _: 1
            })
          ])
        ]),
        _: 3
      }, 8, ["trigger", "disabled", "visible"]);
    };
  }
});
var j3 = {
  key: 0,
  class: "k-table-column__header"
};
var O3 = { class: "k-table-column__title" };
var B3 = {
  key: 0,
  class: "k-table-column__edit vxe-table-icon-edit"
};
var Z3 = { class: "k-column__header-dialog" };
var W3 = { class: "header-dialog__buttons" };
var q3 = { class: "k-table-column__operate" };
var V3 = {
  key: 0,
  class: "k-table-column__tooltip"
};
var H3 = ["onClick"];
var U3 = ["onClick"];
var G3 = {
  key: 3,
  class: "k-table-column__more"
};
var X3 = { class: "more-menu" };
var Y3 = { class: "more-menu-item" };
var Q3 = { class: "more-menu-item" };
var J3 = { class: "sort-menu" };
var e82 = ["onClick"];
var t8 = ["onClick"];
var n8 = ["onClick"];
var o8 = ["onClick"];
var a8 = { key: 1 };
var t1 = defineComponent({
  name: "KTableColumn",
  __name: "table_column",
  props: {
    sortable: { type: Boolean },
    filters: {},
    desc: {},
    showColumnMenu: { type: Boolean, default: void 0 },
    editRender: {},
    type: {},
    field: {}
  },
  setup(e16) {
    const t10 = inject(
      "tableInstance",
      computed(() => null)
    ), n = inject("__showTransfer", computed(() => false)), o = inject("tableId"), r = inject(
      "filterPanelConfig",
      computed(() => ({
        field: "___default___",
        isOpen: false
      }))
    ), a = inject("showColumnMenu", false), i = e16, s = useSlots(), l = ref(), c = ref(false), u = ref(""), d = ref(""), m = ref(false), p = ref(""), f = ref(false), h10 = inject("_emitter");
    watch(() => i.desc, (A) => {
      A && (d.value = A);
    }, { immediate: true }), watch(() => r.value, () => {
      const { field: A, isOpen: B } = r.value;
      i.field === A && (B === true ? f.value = true : B === false && (f.value = false));
    }, { deep: true });
    const g = computed(() => i.showColumnMenu ?? a), v = computed(() => {
      var A;
      return (A = t10.value) == null ? void 0 : A.isFilter(i.field ?? "");
    }), y = computed(() => {
      var A;
      return ((A = t10.value) == null ? void 0 : A.filterConfig) ?? {};
    }), k = computed(() => {
      const { confirmButtonText: A, resetButtonText: B } = y.value;
      return {
        confirmButtonText: A,
        resetButtonText: B
      };
    }), T = computed(() => {
      var A;
      return ((A = t10.value) == null ? void 0 : A.sortConfig) ?? {};
    });
    function w(A, B) {
      const D = B.order;
      let te = null;
      A === "_asc-icon" && D !== "asc" ? te = "asc" : A === "_desc-icon" && D !== "desc" && (te = "desc"), _(B, te);
    }
    function _(A, B) {
      var D;
      (D = t10.value) == null || D.sort(A.field ?? "", B), h10.emit("sort-change", o, { column: A, field: A.field, order: B });
    }
    function M(A) {
      var B;
      (B = t10.value) == null || B.clearSort(A), h10.emit("clear-sort", o);
    }
    function x(A) {
      var D, te;
      c.value = A;
      let B = "";
      A ? (u.value = (D = t10.value) == null ? void 0 : D.getColumnWidth(i.field ?? ""), B = "40") : B = u.value ?? "", (te = t10.value) == null || te.setColumnWidth(i.field ?? "", B);
    }
    function R() {
      p.value = d.value ?? "";
    }
    function I(A) {
      d.value = p.value, m.value = false, h10 == null || h10.emit("desc-change", o, A, d.value);
    }
    function P(A) {
      var B;
      h10 == null || h10.emit("hide-column", o, A), (B = l.value) == null || B.hide();
    }
    async function F(A, B) {
      t10.value && (await t10.value.setFilter(A, B), t10.value.updateData());
    }
    async function N(A) {
      t10.value && (await t10.value.clearFilter(A), h10 == null || h10.emit("clear-filter", o, { filterList: i.filters }));
    }
    function j(A, B, D) {
      h10.emit("filter-change", o, { column: A, field: B, filterList: D });
    }
    function z(A, B, D, te) {
      h10.emit("filter-visible", o, { column: A, field: B, visible: D, filterList: te });
    }
    return (A, B) => (openBlock(), createBlock(unref(VxeColumn), mergeProps(A.$attrs, {
      "edit-render": A.editRender,
      filters: A.filters,
      sortable: A.sortable,
      type: A.type,
      field: A.field,
      class: "k-table-column"
    }), createSlots({ _: 2 }, [
      A.type ? void 0 : {
        name: "header",
        fn: withCtx((D) => {
          var te;
          return [
            c.value ? (openBlock(), createElementBlock("div", a8, [
              createVNode(unref(Qh), {
                style: {
                  width: "20px",
                  cursor: "pointer"
                },
                class: "expand-icon",
                onClick: B[6] || (B[6] = (ie) => x(false))
              })
            ])) : (openBlock(), createElementBlock("div", j3, [
              createBaseVNode("div", O3, [
                renderSlot(A.$slots, "header", normalizeProps(guardReactiveProps(D)), () => {
                  var ie, U, oe;
                  return [
                    (ie = unref(t10)) != null && ie.editConfig && ((oe = (U = unref(t10)) == null ? void 0 : U.editConfig) == null ? void 0 : oe.showIcon) !== false && A.editRender ? (openBlock(), createElementBlock("i", B3)) : createCommentVNode("", true),
                    createTextVNode(" " + toDisplayString(D.column.title ?? "-"), 1)
                  ];
                })
              ]),
              g.value ? (openBlock(), createBlock(unref(Zf), {
                key: 0,
                modelValue: m.value,
                "onUpdate:modelValue": B[2] || (B[2] = (ie) => m.value = ie),
                title: A.$t("customDescription"),
                onOpen: R
              }, {
                default: withCtx(() => [
                  createBaseVNode("div", Z3, [
                    createVNode(unref(ro), {
                      modelValue: p.value,
                      "onUpdate:modelValue": B[0] || (B[0] = (ie) => p.value = ie),
                      type: "textarea"
                    }, null, 8, ["modelValue"]),
                    createBaseVNode("div", W3, [
                      createVNode(unref(Lt), {
                        onClick: B[1] || (B[1] = () => m.value = false)
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(A.$t("cancel")), 1)
                        ]),
                        _: 1
                      }),
                      createVNode(unref(Lt), {
                        main: "",
                        onClick: (ie) => I(D.column)
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(A.$t("confirm")), 1)
                        ]),
                        _: 2
                      }, 1032, ["onClick"])
                    ])
                  ])
                ]),
                _: 2
              }, 1032, ["modelValue", "title"])) : createCommentVNode("", true),
              createBaseVNode("div", q3, [
                d.value ? (openBlock(), createElementBlock("span", V3, [
                  createVNode(unref(wa), {
                    trigger: "click",
                    content: d.value,
                    placement: "top"
                  }, {
                    reference: withCtx(() => [
                      createBaseVNode("i", null, [
                        createVNode(unref(gd))
                      ])
                    ]),
                    _: 1
                  }, 8, ["content"])
                ])) : createCommentVNode("", true),
                i.sortable && ((te = T.value) == null ? void 0 : te.showIcon) !== false ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: normalizeClass([
                    "k-table-column__sort",
                    T.value.iconLayout === "horizontal" ? "sort-icon__horizontal" : "sort-icon__vertical"
                  ])
                }, [
                  T.value.iconAsc ? (openBlock(), createBlock(resolveDynamicComponent(T.value.iconAsc), {
                    key: 0,
                    style: normalizeStyle({
                      color: D.column.order == "asc" ? "#2882FF" : "",
                      fontSize: "15px"
                    }),
                    onClick: (ie) => w("_asc-icon", D.column)
                  }, null, 8, ["style", "onClick"])) : (openBlock(), createElementBlock("i", {
                    key: 1,
                    class: "vxe-table-icon-caret-up icon-asc",
                    style: normalizeStyle({ color: D.column.order == "asc" ? "#2882FF" : "" }),
                    onClick: (ie) => w("_asc-icon", D.column)
                  }, null, 12, H3)),
                  T.value.iconDesc ? (openBlock(), createBlock(resolveDynamicComponent(T.value.iconDesc), {
                    key: 2,
                    style: normalizeStyle({
                      color: D.column.order == "desc" ? "#2882FF" : "",
                      fontSize: "15px"
                    }),
                    onClick: (ie) => w("_desc-icon", D.column)
                  }, null, 8, ["style", "onClick"])) : (openBlock(), createElementBlock("i", {
                    key: 3,
                    class: "vxe-table-icon-caret-down icon-desc",
                    style: normalizeStyle({ color: D.column.order == "desc" ? "#2882FF" : "" }),
                    onClick: (ie) => w("_desc-icon", D.column)
                  }, null, 12, U3))
                ], 2)) : createCommentVNode("", true),
                i.filters ? (openBlock(), createBlock(Fu, {
                  key: 2,
                  filters: i.filters,
                  column: D.column,
                  trigger: "click",
                  text: k.value,
                  onSetFilter: F,
                  onClearFilter: N,
                  onFilterChange: j,
                  onFilterVisible: z
                }, {
                  default: withCtx(() => {
                    var ie;
                    return [
                      withDirectives(createBaseVNode("span", {
                        class: "k-table-column__filter",
                        onClick: B[3] || (B[3] = () => f.value = !f.value)
                      }, [
                        y.value.iconNone && !v.value ? (openBlock(), createBlock(resolveDynamicComponent(y.value.iconNone), { key: 0 })) : y.value.iconMatch && v.value ? (openBlock(), createBlock(resolveDynamicComponent(y.value.iconMatch), { key: 1 })) : v.value ? (openBlock(), createBlock(unref(Ir), {
                          key: 2,
                          size: 16,
                          color: "#2882FF"
                        })) : (openBlock(), createBlock(unref(La), {
                          key: 3,
                          size: 16
                        }))
                      ], 512), [
                        [vShow, i.filters && ((ie = y.value) == null ? void 0 : ie.showIcon) !== false]
                      ]),
                      A.$slots.filter ? renderSlot(A.$slots, "filter", {
                        key: 0,
                        column: D.column,
                        setFilter: F,
                        clearFilter: N
                      }) : createCommentVNode("", true)
                    ];
                  }),
                  _: 2
                }, 1032, ["filters", "column", "text"])) : createCommentVNode("", true),
                g.value ? (openBlock(), createElementBlock("span", G3, [
                  createVNode(unref(Io), {
                    ref_key: "popoverRef",
                    ref: l,
                    trigger: "click",
                    "show-arrow": false,
                    placement: "bottom-start",
                    "popper-class": "more-box",
                    offset: 2,
                    width: "160px"
                  }, {
                    reference: withCtx(() => [
                      createBaseVNode("i", null, [
                        createVNode(unref(oi))
                      ])
                    ]),
                    default: withCtx(() => [
                      createBaseVNode("ul", X3, [
                        createBaseVNode("li", Y3, [
                          createVNode(Fu, {
                            filters: i.filters,
                            column: D.column,
                            text: k.value,
                            onSetFilter: F,
                            onClearFilter: N,
                            onFilterChange: j,
                            onFilterVisible: z
                          }, {
                            default: withCtx(() => [
                              createBaseVNode("div", {
                                class: normalizeClass(["filter-select-item", { disabled: !i.filters }])
                              }, [
                                createVNode(unref(La), { class: "menu-item-icon" }),
                                createTextVNode(" " + toDisplayString(A.$t("filter")), 1)
                              ], 2),
                              A.$slots.filter ? renderSlot(A.$slots, "filter", {
                                key: 0,
                                column: D.column,
                                setFilter: F,
                                clearFilter: N
                              }) : createCommentVNode("", true)
                            ]),
                            _: 2
                          }, 1032, ["filters", "column", "text"])
                        ]),
                        createBaseVNode("li", Q3, [
                          createVNode(unref(Io), {
                            trigger: "hover",
                            "show-arrow": false,
                            placement: "right-start",
                            "popper-class": "more-box",
                            offset: 2,
                            disabled: !i.sortable,
                            teleported: false
                          }, {
                            reference: withCtx(() => [
                              createBaseVNode("div", {
                                class: normalizeClass(["sort-select-item", { disabled: !i.sortable }])
                              }, [
                                createVNode(unref(Xh), { class: "menu-item-icon" }),
                                createTextVNode(" " + toDisplayString(A.$t("sort")) + " ", 1),
                                createVNode(unref(vl), { class: "sort-arrow-right" })
                              ], 2)
                            ]),
                            default: withCtx(() => [
                              createBaseVNode("ul", J3, [
                                createBaseVNode("li", {
                                  class: "sort-menu-item",
                                  onClick: (ie) => _(D.column, "asc")
                                }, [
                                  createVNode(unref(Yh)),
                                  createTextVNode(" " + toDisplayString(A.$t("ascendingOrder")), 1)
                                ], 8, e82),
                                createBaseVNode("li", {
                                  class: "sort-menu-item",
                                  onClick: (ie) => _(D.column, "desc")
                                }, [
                                  createVNode(unref(Gh)),
                                  createTextVNode(" " + toDisplayString(A.$t("descendingOrder")), 1)
                                ], 8, t8),
                                createBaseVNode("li", {
                                  class: "sort-menu-item",
                                  onClick: (ie) => M(D.column)
                                }, [
                                  createVNode(unref(h0)),
                                  createTextVNode(" " + toDisplayString(A.$t("clearSorting")), 1)
                                ], 8, n8)
                              ])
                            ]),
                            _: 2
                          }, 1032, ["disabled"])
                        ]),
                        createBaseVNode("li", {
                          class: "more-menu-item",
                          onClick: B[4] || (B[4] = (ie) => x(true))
                        }, [
                          createVNode(unref($p), { class: "menu-item-icon" }),
                          createTextVNode(" " + toDisplayString(A.$t("retract")), 1)
                        ]),
                        unref(n) ? (openBlock(), createElementBlock("li", {
                          key: 0,
                          class: "more-menu-item",
                          onClick: (ie) => P(D.column)
                        }, [
                          createVNode(unref(xp), { class: "menu-item-icon" }),
                          createTextVNode(" " + toDisplayString(A.$t("hide")), 1)
                        ], 8, o8)) : createCommentVNode("", true),
                        createBaseVNode("li", {
                          class: "more-menu-item",
                          onClick: B[5] || (B[5] = () => m.value = true)
                        }, [
                          createVNode(unref(Sp), { class: "menu-item-icon" }),
                          createTextVNode(" " + toDisplayString(A.$t("customDescription")), 1)
                        ])
                      ])
                    ]),
                    _: 2
                  }, 1536)
                ])) : createCommentVNode("", true)
              ])
            ]))
          ];
        }),
        key: "0"
      },
      c.value ? {
        name: "default",
        fn: withCtx(() => [
          B[7] || (B[7] = createBaseVNode("span", null, "-", -1))
        ]),
        key: "1"
      } : s.default && !c.value ? {
        name: "default",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "default", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "2"
      } : void 0,
      s.footer ? {
        name: "footer",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "footer", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "3"
      } : void 0,
      s.radio ? {
        name: "radio",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "radio", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "4"
      } : void 0,
      s.checkbox ? {
        name: "checkbox",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "checkbox", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "5"
      } : void 0,
      s.title ? {
        name: "title",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "title", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "6"
      } : void 0,
      s.edit ? {
        name: "edit",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "edit", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "7"
      } : void 0,
      s.valid ? {
        name: "valid",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "valid", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "8"
      } : void 0,
      s.content ? {
        name: "content",
        fn: withCtx((D) => [
          renderSlot(A.$slots, "content", normalizeProps(guardReactiveProps(D)))
        ]),
        key: "9"
      } : void 0
    ]), 1040, ["edit-render", "filters", "sortable", "type", "field"]));
  }
});
var n1 = defineComponent({
  name: "KColumnGroup",
  __name: "column_group",
  setup(e16) {
    const t10 = useSlots();
    return (n, o) => (openBlock(), createBlock(unref(VxeColgroup), normalizeProps(guardReactiveProps(n.$attrs)), createSlots({
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 2
    }, [
      t10.header ? {
        name: "header",
        fn: withCtx((r) => [
          renderSlot(n.$slots, "header", normalizeProps(guardReactiveProps(r)))
        ]),
        key: "0"
      } : void 0
    ]), 1040));
  }
});
var Hr = $e(P3, { TableColumn: t1, ColumnGroup: n1 });
var Ur = tn(t1);
var o1 = tn(n1);
var r8 = defineComponent({
  name: "KDrawer",
  __name: "drawer",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElDrawer), mergeProps({
      ref_key: "KDrawerRef",
      ref: o,
      class: ["k-drawer", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var i8 = $e(r8);
var s8 = defineComponent({
  name: "KForm",
  __name: "form",
  props: {
    size: {},
    showColon: { type: Boolean }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = kt(n), a = ref();
    return t10(Ae({}, a)), provide(fn, r), provide(
      "__showColon__",
      computed(() => n.showColon)
    ), (s, l) => (openBlock(), createBlock(unref(ElForm), mergeProps({
      ref_key: "KFormRef",
      ref: a,
      class: ["k-form", unref(o)]
    }, s.$attrs, {
      size: unref(r).elSize
    }), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var a1 = defineComponent({
  name: "KFormItem",
  __name: "form_item",
  props: {
    size: {}
  },
  setup(e16, { expose: t10 }) {
    const o = kt(e16), r = inject("_styleModule", ""), a = ref(null);
    t10(Ae({}, a));
    const s = inject(
      "__showColon__",
      computed(() => false)
    );
    return (l, c) => (openBlock(), createBlock(unref(ElFormItem), mergeProps({
      ref_key: "KFormItemRef",
      ref: a,
      class: ["k-form-item", unref(r), { "k-form-item--colon": unref(s) }]
    }, l.$attrs, {
      size: unref(o).elSize
    }), createSlots({ _: 2 }, [
      renderList(l.$slots, (u, d) => ({
        name: d,
        fn: withCtx((m) => [
          renderSlot(l.$slots, d, normalizeProps(guardReactiveProps(m)))
        ])
      }))
    ]), 1040, ["class", "size"]));
  }
});
var r1 = $e(s8, { FormItem: a1 });
var i1 = tn(a1);
var l8 = defineComponent({
  name: "KSteps",
  props: {
    processStatus: {
      type: String,
      default: "finish"
    },
    finishStatus: {
      type: String,
      default: "success"
    },
    useAntStyle: {
      type: Boolean,
      default: false
    },
    capsule: {
      type: Boolean,
      default: false
    },
    height: {
      type: [String, Number],
      default: void 0
    },
    active: {
      type: Number,
      default: void 0
    }
  },
  setup(e16, {
    attrs: t10,
    expose: n,
    slots: o
  }) {
    const r = inject("_styleModule", ""), a = ref([]), i = Dt(8), s = ref(null);
    watch(() => e16.height, (u) => {
      u && typeof window < "u" && nextTick(() => {
        const d = typeof u == "number" ? `${u}px` : String(u), m = document.getElementById(i);
        m == null || m.style.setProperty("--height", d);
      });
    }, {
      immediate: true
    });
    function l(u) {
      switch (u) {
        case "primary":
          return "finish";
        case "wait":
          return "wait";
        case "success":
          return "success";
        case "error":
          return "error";
        default:
          return "finish";
      }
    }
    return provide("stepProps", e16), provide("stepsInfo", a), n(Ae({}, s)), () => {
      var u, d, m;
      if (e16.capsule) {
        const p = ((d = (u = o.default) == null ? void 0 : u.call(o)[0]) == null ? void 0 : d.children) || [];
        a.value = p.map((f, h10) => {
          var g;
          return f.type && f.type.name === "KStep" ? {
            key: h10,
            name: ((g = f.props) == null ? void 0 : g.title) || ""
          } : null;
        }).filter((f) => f);
      }
      return createVNode("div", {
        class: `k-steps ${r}`
      }, [e16.capsule ? createVNode("div", {
        id: i,
        class: "k-step__capsule"
      }, [(m = o.default) == null ? void 0 : m.call(o)]) : createVNode(ElSteps, mergeProps({
        ref: s
      }, t10, {
        "process-status": l(e16.processStatus),
        "finish-status": l(e16.finishStatus),
        active: e16.active,
        class: {
          "k-steps--ant": e16.useAntStyle
        }
      }), o)]);
    };
  }
});
var c8 = ["id"];
var u8 = { class: "k-step__title" };
var s1 = defineComponent({
  name: "KStep",
  __name: "step",
  props: {
    title: { default: "" },
    description: { default: "" },
    icon: {},
    status: { default: "" },
    color: {}
  },
  setup(e16, { expose: t10 }) {
    var p;
    const n = e16, o = inject("stepProps", {}), r = inject("stepsInfo", computed(() => [])), a = inject("_styleModule", ""), i = Dt(8), s = ((p = r.value.find((f) => f.name === n.title)) == null ? void 0 : p.key) ?? "", l = {
      primary: "#2882FF",
      success: "#22C55E",
      error: "#EF4444",
      wait: "#EAE8EB"
    };
    watch(
      () => o.active,
      (f) => {
        if (!Z6(f) || f < 0 || f >= r.value.length || n.status || n.color)
          return;
        const h10 = Object.keys(l);
        let g = "";
        if (f === s) {
          const v = u(o.processStatus);
          g = h10.includes(v) ? l[v] : l.primary;
        } else if (f > s) {
          const v = u(o.finishStatus);
          g = h10.includes(v) ? l[v] : l.success;
        } else
          g = l.wait;
        g && c(g);
      },
      { immediate: true }
    ), watch(
      () => [n.color, n.status],
      (f) => {
        if (!f[0] && !f[1])
          return;
        let h10;
        n.status && [n.status] ? h10 = l[n.status] : n.color ? h10 = n.color : h10 = l.primary, c(h10);
      },
      { immediate: true, deep: true }
    );
    function c(f) {
      typeof window < "u" && nextTick(() => {
        var g;
        const h10 = document.getElementById(i);
        (g = h10 == null ? void 0 : h10.style) == null || g.setProperty("--default-bgColor", f);
      });
    }
    function u(f) {
      switch (f) {
        case "primary":
          return "finish";
        case "wait":
          return "wait";
        case "success":
          return "success";
        case "error":
          return "error";
        default:
          return "";
      }
    }
    const d = ref(null);
    return t10(Ae({}, d)), (f, h10) => unref(o).capsule ? (openBlock(), createElementBlock("div", {
      key: 1,
      id: unref(i),
      class: normalizeClass(["k-step__capsule-box", unref(a)])
    }, [
      createVNode(unref(Io), {
        "show-after": 500,
        disabled: !n.description
      }, {
        reference: withCtx(() => [
          renderSlot(f.$slots, "title", {}, () => [
            createBaseVNode("span", u8, [
              n.icon ? (openBlock(), createBlock(resolveDynamicComponent(n.icon), { key: 0 })) : createCommentVNode("", true),
              createTextVNode(" " + toDisplayString(n.title), 1)
            ])
          ])
        ]),
        default: withCtx(() => [
          createTextVNode(" " + toDisplayString(n.description), 1)
        ]),
        _: 3
      }, 8, ["disabled"])
    ], 10, c8)) : (openBlock(), createBlock(unref(ElStep), mergeProps({
      key: 0,
      ref_key: "KStepRef",
      ref: d,
      class: ["k-step", unref(a)]
    }, f.$attrs, {
      title: f.title,
      description: f.description,
      icon: f.icon,
      status: u(f.status)
    }), createSlots({ _: 2 }, [
      renderList(f.$slots, (g, v) => ({
        name: v,
        fn: withCtx((y) => [
          renderSlot(f.$slots, v, normalizeProps(guardReactiveProps(y)))
        ])
      }))
    ]), 1040, ["class", "title", "description", "icon", "status"]));
  }
});
var d8 = $e(l8, { Step: s1 });
var f8 = tn(s1);
var m8 = defineComponent({
  name: "KCollapse",
  __name: "collapse",
  props: {
    block: {
      type: Boolean,
      default: false
    },
    isOutline: {
      type: Boolean,
      default: false
    },
    useAntStyle: {
      type: Boolean,
      default: false
    },
    useStepStyle: {
      type: Boolean,
      default: false
    }
  },
  setup(e16, { expose: t10 }) {
    const n = e16;
    provide(
      "__isBlock__",
      computed(() => n.block)
    );
    const o = inject("_styleModule", ""), r = ref(null);
    return t10(Ae({}, r)), (i, s) => (openBlock(), createElementBlock("div", {
      class: normalizeClass([{ "k-collapse-outline": e16.isOutline }])
    }, [
      createVNode(unref(ElCollapse), mergeProps({
        ref_key: "kCollapseRef",
        ref: r,
        class: [
          "k-collapse",
          unref(o),
          { "is-useAntStyle": e16.useAntStyle, "is-useStepStyle": e16.useStepStyle }
        ]
      }, i.$attrs), createSlots({ _: 2 }, [
        renderList(i.$slots, (l, c) => ({
          name: c,
          fn: withCtx((u) => [
            renderSlot(i.$slots, c, normalizeProps(guardReactiveProps(u)))
          ])
        }))
      ]), 1040, ["class"])
    ], 2));
  }
});
var l1 = defineComponent({
  name: "KCollapseItem",
  __name: "collapse_item",
  props: {
    block: {
      type: Boolean
    },
    process: {
      type: Boolean
    },
    wait: {
      type: Boolean
    },
    finish: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    warning: {
      type: Boolean
    }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = inject(
      "__isBlock__",
      computed(() => n.block)
    ), a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createBlock(unref(ElCollapseItem), mergeProps({
      ref_key: "kCollapseItemRef",
      ref: a,
      class: [
        "k-collapse-item",
        unref(o),
        { "is-block": unref(r) },
        {
          "is-process": e16.process,
          "is-wait": e16.wait,
          "is-finish": e16.finish,
          "is-error": e16.error,
          "is-warning": e16.warning
        }
      ]
    }, s.$attrs), createSlots({ _: 2 }, [
      renderList(s.$slots, (c, u) => ({
        name: u,
        fn: withCtx((d) => [
          renderSlot(s.$slots, u, normalizeProps(guardReactiveProps(d)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var p8 = $e(m8, { CollapseItem: l1 });
var h8 = tn(l1);
var g8 = ["draggable"];
var v8 = { class: "k-view-item__label" };
var y8 = { class: "k-view-item__other" };
var b8 = { key: 0 };
var ju = defineComponent({
  name: "KViewItem",
  __name: "view_item",
  props: {
    label: {},
    value: {},
    count: {},
    custom: { type: Boolean },
    disabled: { type: Boolean },
    showCustomControl: { type: Boolean },
    originData: {}
  },
  emits: ["change", "remove", "_drag-start", "_drag-drop"],
  setup(e16, { emit: t10 }) {
    const n = e16, o = t10, r = inject("activeView", ref(0)), a = inject("_styleModule", ""), i = inject("parentProps", {});
    function s(p) {
      switch (p) {
        case "remove":
          c();
      }
    }
    function l() {
      n.disabled || r.value === n.value || o("change", n.originData);
    }
    function c() {
      o("remove", n.originData);
    }
    function u(p) {
      i.draggable && o("_drag-start", p.currentTarget, n.originData);
    }
    function d(p) {
      i.draggable && p.preventDefault();
    }
    function m(p) {
      i.draggable && o("_drag-drop", p.currentTarget);
    }
    return (p, f) => (openBlock(), createElementBlock("div", {
      class: normalizeClass([
        "k-view-item",
        unref(a),
        {
          "k-view-active": unref(r) === n.value,
          "k-view-disabled": n.disabled
        }
      ]),
      draggable: unref(i).draggable,
      onDragstart: u,
      onDragover: d,
      onDrop: m,
      onClick: l
    }, [
      createBaseVNode("div", v8, [
        renderSlot(p.$slots, "label", {}, () => [
          createTextVNode(toDisplayString(n.label), 1)
        ])
      ]),
      createBaseVNode("div", y8, [
        unref(i).showCount ? (openBlock(), createElementBlock("span", b8, toDisplayString(n.count), 1)) : createCommentVNode("", true),
        p.showCustomControl ?? unref(i).showCustomControl ? (openBlock(), createBlock(unref(ElDropdown), {
          key: 1,
          trigger: "click",
          onCommand: s
        }, {
          dropdown: withCtx(() => [
            createVNode(unref(ElDropdownMenu), null, {
              default: withCtx(() => [
                createVNode(unref(ElDropdownItem), { command: "remove" }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(p.$t("remove")), 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createBaseVNode("span", {
              class: "k-view-item-remove",
              onClick: f[0] || (f[0] = withModifiers(() => {
              }, ["stop", "prevent"]))
            }, [
              createVNode(unref(oi))
            ])
          ]),
          _: 1
        })) : createCommentVNode("", true)
      ])
    ], 42, g8));
  }
});
var _8 = { class: "k-tree-node-label" };
var w8 = defineComponent({
  name: "KTree",
  __name: "tree",
  props: {
    filterMethod: { type: Function, default: (e16, t10) => {
      var n;
      return (n = t10.label) == null ? void 0 : n.includes(e16);
    } },
    icon: { type: [Function, String], default: "" },
    expandIcon: { type: [Function, String], default: "" },
    collapseIcon: { type: [Function, String], default: "" },
    showArrow: { type: Boolean, default: true },
    props: {}
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(), a = computed(() => (s, l) => {
      let c = "";
      return s.isLeaf ? c = n.icon : s.expanded ? c = n.expandIcon : c = n.collapseIcon, typeof c == "function" ? c(s, l) : c;
    });
    return t10(Ae({}, r)), (s, l) => (openBlock(), createBlock(unref(ElTree), mergeProps({
      ref_key: "KTreeRef",
      ref: r,
      class: ["k-tree", unref(o), { "k-tree-show-arrow": n.showArrow }],
      "filter-method": s.filterMethod,
      props: n.props
    }, s.$attrs), {
      default: withCtx(({ node: c, data: u }) => [
        a.value(c, u) ? (openBlock(), createBlock(resolveDynamicComponent(a.value(c, u)), { key: 0 })) : createCommentVNode("", true),
        createBaseVNode("span", _8, [
          renderSlot(s.$slots, "default", {
            node: c,
            data: u
          }, () => {
            var d, m;
            return [
              createTextVNode(toDisplayString(typeof ((d = n.props) == null ? void 0 : d.label) == "function" ? u[n.props.label(u, c) ?? "label"] : u[((m = n.props) == null ? void 0 : m.label) ?? "label"]), 1)
            ];
          })
        ])
      ]),
      _: 3
    }, 16, ["class", "filter-method", "props"]));
  }
});
var el = $e(w8);
var T8 = { class: "k-view__header" };
var C8 = { class: "view-title text-base font-bold" };
var k8 = ["id"];
var S8 = ["id"];
var N8 = { class: "custom-table-box" };
var M8 = { class: "k-view-content" };
var $8 = defineComponent({
  name: "KView",
  __name: "view",
  props: {
    defaultActive: {},
    data: {},
    draggable: { type: Boolean, default: false },
    collapse: { type: Boolean, default: false },
    showCustomControl: { type: Boolean, default: false },
    useTree: { type: Boolean, default: false },
    treeConfig: { default: () => ({}) },
    showArrow: { type: Boolean, default: false },
    showCount: { type: Boolean, default: true },
    props: {}
  },
  emits: [
    "refresh",
    "change",
    "remove",
    "drag",
    "visible",
    "node-expand",
    "node-collapse"
  ],
  setup(e16, { expose: t10, emit: n }) {
    const o = {
      label: "label",
      value: "value",
      count: "count",
      children: "children",
      disabled: "disabled",
      custom: "custom"
    }, r = e16, a = n, i = inject("_styleModule", ""), s = ref(""), l = computed(() => Object.assign(o, r.props ?? {})), c = computed(() => {
      var D;
      return ((D = r.data) == null ? void 0 : D.filter((te) => !te[l.value.custom])) ?? [];
    }), u = computed(() => {
      var D;
      return (D = r.data) == null ? void 0 : D.filter((te) => !!te[l.value.custom]);
    }), d = ref([]), m = ref("");
    watch(
      () => r.defaultActive,
      (D) => {
        var ie, U;
        let te = D;
        D || (te = ((U = (ie = r.data) == null ? void 0 : ie[0]) == null ? void 0 : U[l.value.value]) ?? ""), s.value = te, d.value = [te ?? ""], m.value = te ?? "";
      },
      { immediate: true }
    );
    function p() {
      a("refresh");
    }
    function f(D, te) {
      s.value = D[l.value.value], a("change", { value: s.value, data: D, node: te });
    }
    function h10(D) {
      a("remove", { value: D[l.value.value], data: D });
    }
    function g(D, te) {
      y(te) || a("node-expand", D, te);
    }
    function v(D, te) {
      y(te) || a("node-collapse", D, te);
    }
    function y(D) {
      return D.isLeaf;
    }
    const k = {
      element: null,
      data: null
    };
    let T = false;
    const w = Dt(8), _ = Dt(8);
    function M(D, te) {
      k.element = D, k.data = te, T = te[l.value.custom] ?? false;
    }
    function x(D) {
      var oe;
      if (!k.element || k.element === D)
        return;
      const te = T ? _ : w, ie = document.getElementById(te);
      if (!R(ie, D))
        return;
      const U = document.createElement("div");
      ie == null || ie.appendChild(U), ie == null || ie.replaceChild(U, D), ie == null || ie.replaceChild(D, k.element), ie == null || ie.replaceChild(k.element, U), k.element = null, T = false, a("drag", { value: (oe = k.data) == null ? void 0 : oe[l.value.value], data: k.data }), k.data = null;
    }
    function R(D, te) {
      return !D || !te ? false : D.contains(te);
    }
    const I = ref(r.collapse);
    function P() {
      F(), a("visible", !I.value);
    }
    function F() {
      I.value = !I.value;
    }
    function N() {
      I.value = false;
    }
    function j() {
      I.value = true;
    }
    function z() {
      return !I.value;
    }
    function A() {
      return I.value;
    }
    function B(D) {
      return {
        label: D[l.value.label] ?? "",
        value: D[l.value.value] ?? "",
        count: D[l.value.count] ?? 0,
        disabled: D[l.value.disabled] ?? false,
        custom: D[l.value.custom] ?? false,
        showCustomControl: D.showCustomControl ?? false
      };
    }
    return provide("activeView", s), provide("parentProps", r), t10({
      expand: N,
      collapse: j,
      toggle: F,
      isExpand: z,
      isCollapse: A
    }), (D, te) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["k-view", "text-base", unref(i)])
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["k-view-nav p-2 h-full border-r border-gray-200 relative flex-shrink-0", { "is-collapse": I.value }])
      }, [
        createBaseVNode("div", {
          class: "showViewBtn flex justify-center items-center rounded-full",
          onClick: P
        }, [
          createVNode(unref(vl), {
            class: normalizeClass({ "is-collapse": !I.value })
          }, null, 8, ["class"])
        ]),
        createBaseVNode("div", {
          class: "k-view-aside",
          style: normalizeStyle({ display: I.value ? "none" : "flex" })
        }, [
          createBaseVNode("div", T8, [
            createBaseVNode("div", C8, [
              renderSlot(D.$slots, "header", {}, () => [
                createTextVNode(toDisplayString(D.$t("view")), 1)
              ])
            ]),
            createBaseVNode("span", {
              class: "view-fresh",
              onClick: p
            }, [
              renderSlot(D.$slots, "refresh", {}, () => [
                createVNode(unref(g0))
              ])
            ])
          ]),
          createBaseVNode("div", {
            id: unref(w),
            class: "k-view__special-data"
          }, [
            createVNode(unref(ElScrollbar), null, {
              default: withCtx(() => {
                var ie;
                return [
                  D.useTree ? (openBlock(), createBlock(unref(el), mergeProps({
                    key: 1,
                    ref: "KViewTree",
                    class: "k-tree-view-item",
                    "node-key": l.value.value,
                    props: {
                      label: l.value.label,
                      disabled: l.value.disabled,
                      children: l.value.children
                    },
                    "default-expanded-keys": d.value,
                    "current-node-key": m.value,
                    data: r.data,
                    "show-arrow": D.showArrow,
                    "highlight-current": ""
                  }, D.treeConfig, {
                    onCurrentChange: f,
                    onNodeExpand: g,
                    onNodeCollapse: v
                  }), createSlots({ _: 2 }, [
                    D.$slots.label ? {
                      name: "default",
                      fn: withCtx(({ node: U, data: oe }) => [
                        renderSlot(D.$slots, "label", {
                          node: U,
                          data: oe
                        })
                      ]),
                      key: "0"
                    } : void 0
                  ]), 1040, ["node-key", "props", "default-expanded-keys", "current-node-key", "data", "show-arrow"])) : (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(c.value, (U) => (openBlock(), createBlock(ju, mergeProps({
                    key: U[l.value.value],
                    "origin-data": U,
                    ref_for: true
                  }, B(U), {
                    onChange: f,
                    onRemove: h10,
                    on_dragStart: M,
                    on_dragDrop: x
                  }), createSlots({ _: 2 }, [
                    D.$slots.label ? {
                      name: "label",
                      fn: withCtx(() => [
                        renderSlot(D.$slots, "label", { data: U })
                      ]),
                      key: "0"
                    } : void 0
                  ]), 1040, ["origin-data"]))), 128)),
                  (ie = u.value) != null && ie.length ? (openBlock(), createElementBlock("div", {
                    key: 2,
                    id: unref(_),
                    class: "k-view__custom-data text-base"
                  }, [
                    renderSlot(D.$slots, "custom-header", {}, () => [
                      createBaseVNode("span", N8, toDisplayString(D.$t("customView")), 1)
                    ]),
                    D.useTree ? (openBlock(), createBlock(unref(el), mergeProps({
                      key: 1,
                      ref: "KCustomViewTree",
                      class: "k-tree-view-item",
                      "node-key": l.value.value,
                      props: {
                        label: l.value.label,
                        disabled: l.value.disabled,
                        children: l.value.children
                      },
                      "default-expanded-keys": d.value,
                      "current-node-key": m.value,
                      data: r.data,
                      "highlight-current": "",
                      "show-arrow": D.showArrow
                    }, D.treeConfig, {
                      onCurrentChange: f,
                      onNodeExpand: g,
                      onNodeCollapse: v
                    }), createSlots({ _: 2 }, [
                      D.$slots.label ? {
                        name: "default",
                        fn: withCtx(({ node: U, data: oe }) => [
                          renderSlot(D.$slots, "label", {
                            node: U,
                            data: oe
                          })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["node-key", "props", "default-expanded-keys", "current-node-key", "data", "show-arrow"])) : (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(u.value, (U) => (openBlock(), createBlock(ju, mergeProps({
                      key: U[l.value.value],
                      "origin-data": U,
                      ref_for: true
                    }, B(U), {
                      onChange: f,
                      onRemove: h10,
                      on_dragStart: M,
                      on_dragDrop: x
                    }), createSlots({ _: 2 }, [
                      D.$slots.label ? {
                        name: "label",
                        fn: withCtx(() => [
                          renderSlot(D.$slots, "label", { data: U })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["origin-data"]))), 128))
                  ], 8, S8)) : createCommentVNode("", true)
                ];
              }),
              _: 3
            })
          ], 8, k8)
        ], 4)
      ], 2),
      createBaseVNode("div", M8, [
        renderSlot(D.$slots, "default"),
        renderSlot(D.$slots, s.value)
      ])
    ], 2));
  }
});
var x8 = $e($8);
var I8 = defineComponent({
  name: "KBadge",
  __name: "badge",
  setup(e16, { expose: t10 }) {
    const n = inject("_styleModule", ""), o = ref(null);
    return t10(Ae({}, o)), (a, i) => (openBlock(), createBlock(unref(ElBadge), mergeProps({
      ref_key: "badgeRef",
      ref: o,
      class: ["k-badge", unref(n)]
    }, a.$attrs), createSlots({ _: 2 }, [
      renderList(a.$slots, (s, l) => ({
        name: l,
        fn: withCtx((c) => [
          renderSlot(a.$slots, l, normalizeProps(guardReactiveProps(c)))
        ])
      }))
    ]), 1040, ["class"]));
  }
});
var D8 = $e(I8);
var A8 = defineComponent({
  name: "KTimeline",
  __name: "time_line",
  props: {
    showLine: { type: Boolean, default: true }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = computed(() => !n.showLine), a = ref(null);
    return t10(Ae({}, a)), (s, l) => (openBlock(), createElementBlock("div", {
      ref_key: "KTimelineRef",
      ref: a,
      class: normalizeClass(["k-timeline", unref(o), { "hidden-line": r.value }])
    }, [
      createVNode(unref(ElTimeline), null, {
        default: withCtx(() => [
          renderSlot(s.$slots, "default")
        ]),
        _: 3
      })
    ], 2));
  }
});
var c1 = defineComponent({
  name: "KTimelineItem",
  __name: "timeline_item",
  props: {
    placement: { default: "top" },
    type: { default: "wait" },
    color: {},
    hollow: { type: Boolean }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = Dt(8);
    let a, i;
    onMounted(() => {
      a = document.getElementById(r), i = (a == null ? void 0 : a.querySelector(".el-timeline-item__node")) || null;
    }), watch(() => n.color, (d) => {
      nextTick(() => {
        !i || !d || !n.hollow || (i.style.borderColor = n.color || "");
      });
    }, { immediate: true });
    const s = computed(() => n.placement === "right");
    function l(d) {
      const m = ["primary", "success", "warning"];
      if (d === "wait")
        return "info";
      if (d === "error")
        return "danger";
      if (m.includes(d))
        return d;
    }
    const c = ref(null);
    return t10(Ae({}, c)), (d, m) => (openBlock(), createBlock(unref(ElTimelineItem), mergeProps(d.$attrs, {
      id: unref(r),
      ref_key: "KTimelineItemRef",
      ref: c,
      type: l(d.type),
      placement: d.placement === "right" ? "top" : d.placement,
      hollow: d.hollow,
      color: d.color,
      class: [
        "k-timeline__item",
        unref(o),
        {
          "is-show-right": s.value,
          "is-hollow": n.hollow
        }
      ]
    }), createSlots({ _: 2 }, [
      renderList(d.$slots, (p, f) => ({
        name: f,
        fn: withCtx((h10) => [
          renderSlot(d.$slots, f, normalizeProps(guardReactiveProps(h10)))
        ])
      }))
    ]), 1040, ["id", "type", "placement", "hollow", "color", "class"]));
  }
});
var E8 = $e(A8, { TimelineItem: c1 });
var K8 = tn(c1);
var z8 = {
  1: "初一",
  2: "初二",
  3: "初三",
  4: "初四",
  5: "初五",
  6: "初六",
  7: "初七",
  8: "初八",
  9: "初九",
  10: "初十",
  11: "十一",
  12: "十二",
  13: "十三",
  14: "十四",
  15: "十五",
  16: "十六",
  17: "十七",
  18: "十八",
  19: "十九",
  20: "二十",
  21: "廿一",
  22: "廿二",
  23: "廿三",
  24: "廿四",
  25: "廿五",
  26: "廿六",
  27: "廿七",
  28: "廿八",
  29: "廿九",
  30: "三十"
};
var P8 = {
  1: "元月",
  2: "二月",
  3: "三月",
  4: "四月",
  5: "五月",
  6: "六月",
  7: "七月",
  8: "八月",
  9: "九月",
  10: "十月",
  11: "冬月",
  12: "腊月"
};
var R8 = { class: "k-calendar__header" };
var L8 = { class: "k-calendar__header-left" };
var F8 = { class: "k-calendar__header-right" };
var j8 = { class: "k-calendar__item" };
var O8 = { class: "k-calendar__date" };
var B8 = { class: "k-calendar__solar" };
var Z8 = { class: "k-calendar__schedule" };
var W8 = defineComponent({
  name: "KCalendar",
  __name: "calendar",
  props: {
    schedule: { default: () => [] },
    showLunar: { type: Boolean, default: false },
    adaptive: { type: Boolean, default: false }
  },
  setup(e16, { expose: t10 }) {
    const n = e16, o = inject("_styleModule", ""), r = ref(), a = ref(false), i = computed(
      () => function(p) {
        const f = p.getFullYear(), h10 = p.getMonth() + 1, g = p.getDate(), v = (0, import_chinese_lunar_calendar.getLunar)(f, h10, g);
        return {
          ...v,
          lunarMonth_zh: P8[v.lunarMonth],
          lunarDate_zh: z8[v.lunarDate]
        };
      }
    ), s = computed(() => n.schedule.map((p) => {
      const { date: f } = p;
      let h10;
      const g = new Date(f);
      return g instanceof Date && !Number.isNaN(g == null ? void 0 : g.getTime()) && (h10 = d(g)), {
        date: h10,
        content: p.content
      };
    }).filter((p) => p.date)), l = computed(
      () => function(p) {
        const f = s.value.find(
          (h10) => h10.date === d(p)
        );
        return (f == null ? void 0 : f.content) || [];
      }
    );
    function c(p) {
      var f;
      (f = r.value) == null || f.selectDate(p);
    }
    function u(p) {
      a.value = p;
    }
    function d(p) {
      const f = p.getFullYear(), h10 = p.getMonth() + 1, g = p.getDate();
      return `${f}-${h10 < 10 ? "0" : ""}${h10}-${g < 10 ? "0" : ""}${g}`;
    }
    return t10(Ae({
      jumpDate: c,
      handleLunar: u
    }, r)), (p, f) => {
      const h10 = resolveComponent("k-button");
      return openBlock(), createBlock(unref(ElCalendar), mergeProps({
        ref_key: "kCalendarRef",
        ref: r,
        class: ["k-calendar", unref(o), { "k-calendar--adaptive": p.adaptive }, "text-base"]
      }, p.$attrs), {
        header: withCtx(({ date: g }) => [
          renderSlot(p.$slots, "header", { date: g }, () => [
            createBaseVNode("div", R8, [
              createBaseVNode("div", L8, [
                createVNode(h10, {
                  onClick: f[0] || (f[0] = (v) => c("today"))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(p.$t("today")), 1)
                  ]),
                  _: 1
                }),
                createVNode(h10, {
                  onClick: f[1] || (f[1] = (v) => c("prev-month"))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(wp))
                  ]),
                  _: 1
                }),
                createVNode(h10, {
                  onClick: f[2] || (f[2] = (v) => c("next-month"))
                }, {
                  default: withCtx(() => [
                    createVNode(unref(vl))
                  ]),
                  _: 1
                }),
                createBaseVNode("span", null, toDisplayString(g), 1)
              ]),
              createBaseVNode("div", F8, [
                p.showLunar ? (openBlock(), createBlock(unref(fa), {
                  key: 0,
                  modelValue: a.value,
                  "onUpdate:modelValue": f[3] || (f[3] = (v) => a.value = v),
                  label: p.$t("showLunar")
                }, null, 8, ["modelValue", "label"])) : createCommentVNode("", true)
              ])
            ])
          ])
        ]),
        "date-cell": withCtx((g) => [
          renderSlot(p.$slots, "date-cell", normalizeProps(guardReactiveProps(g)), () => [
            createBaseVNode("div", j8, [
              createBaseVNode("div", O8, [
                createBaseVNode("span", B8, toDisplayString(g.data.date.getDate()), 1),
                withDirectives(createBaseVNode("span", { class: "k-calendar__lunar" }, toDisplayString(i.value(g.data.date).lunarDate_zh), 513), [
                  [vShow, a.value]
                ])
              ]),
              renderSlot(p.$slots, "schedule", {
                date: g.data.date
              }, () => [
                createBaseVNode("div", Z8, [
                  createBaseVNode("ul", null, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(l.value(g.data.date), (v) => (openBlock(), createElementBlock("li", {
                      key: v,
                      ref_for: true,
                      ref: "scheduleItemRef",
                      class: "k-calendar__schedule-item"
                    }, toDisplayString(v), 1))), 128))
                  ])
                ])
              ])
            ])
          ])
        ]),
        _: 3
      }, 16, ["class"]);
    };
  }
});
var q8 = $e(W8);
var V8 = {
  key: 0,
  class: "column-default__content"
};
var H8 = defineComponent({
  __name: "table_column_content",
  props: {
    row: {
      type: Object,
      default: () => {
      }
    },
    col: {
      type: Object,
      default: () => {
      }
    },
    size: {
      type: String,
      default: "default"
    },
    align: {
      type: String,
      default: () => "left"
    }
  },
  setup(e16) {
    const t10 = inject("tableInstance"), n = e16, o = computed(
      () => (a) => {
        var i;
        return ((i = a.iconStyle) == null ? void 0 : i.size) ?? (n.size === "mini" ? 16 : 20);
      }
    ), r = computed(() => (a) => {
      var i;
      return a.__folder ? (i = t10.value) != null && i.isTreeExpandByRow(a) ? "IconFolderOpen" : "IconFlowNested" : a.icon;
    });
    return (a, i) => {
      var s, l, c, u;
      return e16.col.type ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", V8, [
        n.col.showIcon && (e16.row.icon || e16.row.__folder) ? (openBlock(), createBlock(resolveDynamicComponent(r.value(e16.row)), {
          key: 0,
          color: e16.row.__folder ? "#FAC814" : (s = e16.row.iconStyle) != null && s.empty ? "#cdcacf" : (l = e16.row.iconStyle) == null ? void 0 : l.color,
          size: o.value(e16.row),
          grayscale: !!((c = e16.row.iconStyle) != null && c.grayscale)
        }, null, 8, ["color", "size", "grayscale"])) : createCommentVNode("", true),
        createBaseVNode("span", {
          class: "column-default__content__text",
          style: normalizeStyle({
            marginLeft: (e16.row.icon || e16.row.__folder) && e16.col.showIcon ? `${o.value(e16.row) + (((u = e16.row.iconStyle) == null ? void 0 : u.indent) ?? 3)}px` : 0
          })
        }, [
          a.$slots[`${e16.col.field ?? ""}-label`] ? renderSlot(a.$slots, `${e16.col.field ?? ""}-label`, {
            key: 0,
            row: e16.row,
            column: e16.col
          }) : typeof e16.col.formatter == "function" ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(e16.col.formatter({ cellValue: e16.row[e16.col.field], row: e16.row, column: e16.col })), 1)
          ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            createTextVNode(toDisplayString(e16.row[e16.col.field] === "" ? "-" : e16.row[e16.col.field] ?? "-"), 1)
          ], 64))
        ], 4)
      ]));
    };
  }
});
var U8 = ["header", "edit"];
var G8 = defineComponent({
  name: "ColumnGroup",
  props: {
    data: Array,
    column: {
      type: Object,
      default: () => ({})
    },
    size: {
      type: String,
      default: "default"
    },
    align: {
      type: String,
      default: () => "left"
    }
  },
  setup(e16, {
    slots: t10
  }) {
    return () => Array.isArray(e16.column.group) && e16.column.group.length ? n(e16.column) : o(t10, e16.column);
    function n(a) {
      const i = a.group || [], s = r(t10, a.field);
      return createVNode(o1, mergeProps(a, {
        key: a,
        resizable: true
      }), {
        default: () => [i.map((l) => Array.isArray(l.group) && l.group.length ? n(l) : o(t10, l))],
        ...s
      });
    }
    function o(a, i) {
      const s = r(a, i.field);
      return !i.render && (a[i.field ?? ""] || i.showIcon) && !i.type && (s.default = (l) => {
        var d;
        const c = i.field ?? "", {
          row: u
        } = l;
        if (a[c])
          return (d = a[c]) == null ? void 0 : d.call(a, l);
        if (i.showIcon) {
          const m = {}, p = `${c}-label`;
          return a[p] && (m[p] = (f) => {
            var h10;
            return (h10 = a[p]) == null ? void 0 : h10.call(a, f);
          }), createVNode(H8, {
            key: i.field,
            col: i,
            row: u,
            size: e16.size,
            align: e16.align
          }, m);
        }
      }), createVNode(Ur, mergeProps({
        key: i.field
      }, i), s);
    }
    function r(a, i) {
      if (!i)
        return {};
      const s = {};
      for (const l of U8) {
        const c = `${i}-${l}`;
        a[c] && (s[l] = (u) => {
          var d;
          return (d = a[c]) == null ? void 0 : d.call(a, u);
        });
      }
      return s;
    }
  }
});
function X8(e16, t10) {
  const n = {
    data: [],
    sortData: [],
    filterData: []
  }, o = ref([]), r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), s = [], l = computed(() => {
    var N;
    return ((N = e16.rowConfig) == null ? void 0 : N.keyField) ?? "id";
  }), c = (N) => new Promise((j) => {
    var A;
    const z = Array.isArray(N) ? N : [N];
    if (_(), !e16.useTree)
      o.value.unshift(...z);
    else
      for (let B = 0; B < z.length; B++) {
        const D = z[B], te = ((A = e16.treeConfig) == null ? void 0 : A.parentField) ?? "pid", ie = o.value.find((oe) => oe[l.value] === D[te]);
        if (!ie) {
          o.value.unshift(D);
          return;
        }
        const U = o.value.findIndex((oe) => oe[te] === ie[l.value]);
        U === -1 ? o.value.unshift(D) : o.value.splice(U, 0, D);
      }
    w(z, r), M(), j(N);
  }), u = (N, j, z = false) => new Promise((A) => {
    var D;
    const B = Array.isArray(N) ? N : [N];
    if (_(), e16.useTree) {
      const te = [], ie = [];
      let U = -1;
      for (let oe = 0; oe < B.length; oe++) {
        const se = B[oe], E = ((D = e16.treeConfig) == null ? void 0 : D.parentField) ?? "pid";
        if (typeof j == "object" && (j[E] === se[E] || !j[E] && !se[E]))
          U = o.value.findIndex((K) => K[l.value] === j[l.value]), U !== -1 && te.push(se);
        else {
          const K = o.value.find((ee) => ee[l.value] === se[E]);
          K ? (U = o.value.findIndex((ee) => ee[E] === K[l.value]), U === -1 ? ie.push(se) : te.push(se)) : ie.push(se);
        }
      }
      o.value.splice(z ? U + 1 : U, 0, ...te), o.value.push(...ie);
    } else {
      let te;
      const ie = o.value.length;
      if (typeof j == "number")
        te = (Number.isNaN(Math.floor(j)) ? 0 : Math.floor(j)) % ie;
      else if (typeof j == "object") {
        const U = o.value.findIndex((oe) => oe[l.value] === (j == null ? void 0 : j[l.value]));
        te = U === -1 ? 0 : U;
      } else
        te = 0;
      te === -1 ? o.value.push(...B) : (te = z ? te + 1 : te, o.value.splice(te, 0, ...B));
    }
    w(B, r), M(), A(N);
  }), d = (N, j) => u(N, j), m = (N, j) => u(N, j, true), p = () => new Promise((N) => {
    _();
    const j = Array.from(r.values());
    for (let z = 0; z < o.value.length - 1 && r.size !== 0; z++) {
      const A = o.value[z][l.value];
      r.has(A) && (o.value.splice(z, 1), r.delete(A), z--);
    }
    M(), N({ rows: j, row: j });
  }), f = () => Array.from(r.values()), h10 = (N) => r.has(N[l.value]), g = (N) => new Promise((j) => {
    N === void 0 && (o.value.length = 0, j({ rows: [], row: null }));
    let z = N;
    Array.isArray(N) || (z = [N]);
    const A = new Map(z.map((B) => [B[l.value], B]));
    for (let B = 0; B < o.value.length; B++) {
      const D = o.value[B][l.value];
      A.has(D) && (o.value.splice(B, 1), A.delete(D), B--);
    }
    w(z, a), j({ rows: N, row: N });
  }), v = () => Array.from(a.values()), y = () => ({
    insertRecords: Array.from(r.values()),
    removeRecords: Array.from(a.values()),
    updateRecords: Array.from(i.values()),
    pendingRecords: []
  }), k = (N, j) => new Promise((z) => {
    (!N || !j) && z(N);
    let A = N;
    Array.isArray(N) || (A = [N]), A.forEach((B) => {
      Object.assign(B, j), i.set(B[l.value], B);
    }), z(N);
  }), T = (N) => {
    if (_(), !(N != null && N.length)) {
      o.value.length = 0, o.value.push(...n.data);
      return;
    }
    eg(o.value, N), M();
  };
  function w(N, j) {
    N.forEach((z) => {
      j.set(z[l.value], z);
    });
  }
  function _() {
    const N = t10.value;
    !N || !e16.useTree || (s.length = 0, s.push(...N.getTreeExpandRecords() ?? []));
  }
  async function M() {
    const N = t10.value;
    !N || !e16.useTree || setTimeout(async () => {
      await N.setTreeExpand(s, true), s.length = 0;
    });
  }
  function x(N) {
    var U, oe, se, E, K, ee, V, le;
    _();
    const j = N.item, z = j.previousElementSibling, A = (U = t10.value) == null ? void 0 : U.getRowNode(j);
    if (!A)
      return false;
    const B = A.item, D = (oe = o.value) == null ? void 0 : oe.findIndex((pe) => pe.id === B.id), te = (se = o.value) == null ? void 0 : se.splice(D, 1)[0];
    let ie = 0;
    if (z) {
      const pe = (E = t10.value) == null ? void 0 : E.getRowNode(z);
      if (!pe)
        return false;
      const Te = pe.item;
      if (I(te, Te))
        return console.warn("Can not move to child node"), R(te, D), false;
      const Z = (K = o.value) == null ? void 0 : K.findIndex((Q) => Q.id === Te.id), X = (ee = t10.value) == null ? void 0 : ee.getRowById(Te.parentId);
      ie = Z + 1, (V = t10.value) != null && V.isTreeExpandByRow(Te) ? te.parentId = Te.id : (le = t10.value) != null && le.isTreeExpandByRow(X) ? te.parentId = Te.parentId ?? null : te.parentId = (X == null ? void 0 : X.parentId) ?? null;
    } else
      te.parentId = null, ie = 0;
    return R(te, ie), true;
  }
  function R(N, j) {
    setTimeout(() => {
      var z;
      (z = o.value) == null || z.splice(j, 0, N), M();
    });
  }
  function I(N, j) {
    var D;
    const z = ((D = e16.treeConfig) == null ? void 0 : D.parentField) ?? "pid", A = l.value;
    if (!N[A] || !j || !j[z])
      return false;
    if (N[A] === j[z])
      return true;
    const B = o.value.find((te) => te[A] === j[z]);
    return I(N, B);
  }
  async function P(N, j, z = 100) {
    return new Promise(async (A) => {
      var te, ie, U, oe, se;
      const B = Array.isArray(N) ? N : [N];
      (((te = e16.treeConfig) == null ? void 0 : te.lazy) ?? false) || (await ((ie = t10.value) == null ? void 0 : ie.setTreeExpand(B, j)), A(null));
      try {
        const E = new Event("click", { bubbles: true });
        for (const K of B) {
          if (await ((U = t10.value) == null ? void 0 : U.clearTreeExpandLoaded(K)), ((oe = t10.value) == null ? void 0 : oe.isTreeExpandByRow(K)) === j)
            continue;
          const V = (se = t10.value) == null ? void 0 : se.$el.querySelector(`[rowid='${K.id}'] .vxe-tree--btn-wrapper`);
          V && V.dispatchEvent(E);
        }
      } catch (E) {
        console.error(E);
      }
      setTimeout(() => {
        A(null);
      }, z);
    });
  }
  function F(N) {
    r.clear(), a.clear(), i.clear();
    const j = Array.isArray(N) ? N : [];
    return o.value = Array.from(j), n.data = [...o.value], o.value;
  }
  return {
    _methods: {
      insert: c,
      insertAt: d,
      insertNextAt: m,
      removeInsertRow: p,
      getInsertRecords: f,
      isInsertByRow: h10,
      remove: g,
      getRemoveRecords: v,
      getRecordset: y,
      setRow: k,
      setTreeExpand: P
    },
    setTableData: F,
    sortChange: T,
    dragSort: x
  };
}
function Y8(e16, t10, n) {
  const o = {}, r = ref(/* @__PURE__ */ new Set()), a = /* @__PURE__ */ new Set(), i = computed(() => r.value.size);
  onMounted(() => {
    const { checkRowKeys: w, checkAll: _ } = s.value, M = Array.isArray(w) ? w : [], R = (_ ? t10.value.map((I) => I[l.value]) : M).map((I) => {
      var F;
      return (F = e16.value) == null ? void 0 : F.getRowById(I);
    });
    d(R, true);
  });
  const s = computed(() => Object.assign(o, n.checkboxConfig || {})), l = computed(() => {
    var w;
    return ((w = n.rowConfig) == null ? void 0 : w.keyField) ?? "id";
  }), c = (w, _) => new Promise((M) => {
    var I;
    const x = Array.isArray(w) ? w : [w], R = [];
    for (const P of x)
      k(P) || R.push(P);
    d(R, _), (I = e16.value) == null || I.setCheckboxRow(R, _), M({ rows: w, checked: _ });
  }), u = (w) => new Promise((_) => {
    var x, R;
    const M = [];
    if (w) {
      for (const I of t10.value)
        k(I) || M.push(I);
      d(M, w), (x = e16.value) == null || x.setCheckboxRow(M, w);
    } else
      T(), (R = e16.value) == null || R.setAllCheckboxRow(w);
    _({ checked: w });
  }), d = (w, _) => {
    var x;
    const M = Array.isArray(w) ? w : [w];
    for (const R of M) {
      const I = (x = e16.value) == null ? void 0 : x.getRowById(R[l.value]);
      m(I, _);
    }
  }, m = (w, _) => {
    if (w && (_ ? r.value.add(w[l.value]) : r.value.delete(w[l.value]), (!w.children || w.children.length === 0) && (_ ? a.add(w[l.value]) : a.delete(w[l.value])), w.children && w.children.length))
      for (const M of w.children)
        m(M, _);
  };
  async function p() {
    var _, M, x;
    if (await ((_ = e16.value) == null ? void 0 : _.clearCheckboxRow()), a.size === 0)
      return;
    const w = [];
    for (const R of a.values()) {
      const I = (M = e16.value) == null ? void 0 : M.getRowById(R);
      I && w.push(I);
    }
    (x = e16.value) == null || x.setCheckboxRow(w, true);
  }
  const f = () => new Promise((w) => {
    var _;
    n.showPage && !n.useTree ? d(t10.value, false) : T(), (_ = e16.value) == null || _.clearCheckboxRow(), w(void 0);
  }), h10 = async () => {
    var w;
    await ((w = e16.value) == null ? void 0 : w.clearCheckboxReserve()), new Promise((_) => {
      var M, x;
      if (n.showPage && !n.useTree) {
        const R = (M = e16.value) == null ? void 0 : M.getCheckboxRecords();
        r.value = new Set(R.map((I) => I[l.value])), (x = e16.value) == null || x.setCheckboxRow(R, true);
      }
      _(void 0);
    });
  };
  function g({ row: w, checked: _ }) {
    d(w, _);
  }
  function v({ checked: w }) {
    var x;
    const M = (((x = e16.value) == null ? void 0 : x.getCheckboxRecords()) ?? []).filter((R) => !R.children || !R.children.length);
    d(M, w);
  }
  function y() {
    f(), T(), e16.value.clearCheckboxReserve();
  }
  function k(w) {
    const { visibleMethod: _, checkMethod: M } = s.value;
    return typeof _ == "function" && !_({ row: w }) || typeof M == "function" && !M({ row: w });
  }
  function T() {
    r.value.clear(), a.clear();
  }
  return {
    _checkboxMethods: {
      setAllCheckboxRow: u,
      setCheckboxRow: c,
      clearCheckboxRow: f,
      clearCheckboxReserve: h10
    },
    checkBoxChange: g,
    checkboxAll: v,
    closeBatchOperation: y,
    isCheckboxDisabled: k,
    clearCheckedData: T,
    resetCheckboxStatus: p,
    checkedDataSize: i,
    checkboxConfig: s
  };
}
var Q8 = {
  key: 0,
  class: "k-tree-table__header-pure"
};
var J8 = {
  key: 0,
  class: "k-table-info"
};
var eb = { key: 0 };
var tb = ["title"];
var nb = { class: "k-table-func" };
var ob = { class: "text-sm" };
var ab = { class: "text-sm" };
var rb = { class: "table-box flex-1 overflow-auto" };
var ib = {
  key: 0,
  class: "batch-operate"
};
var sb = {
  key: 2,
  ref: "RefTablePagination",
  class: "pagination-box"
};
var lb = defineComponent({
  name: "KTreeTable",
  __name: "tree_table",
  props: {
    data: {},
    size: {},
    sortConfig: {},
    seqConfig: {},
    rowConfig: {},
    editConfig: {},
    scrollY: {},
    columnConfig: {},
    checkboxConfig: {},
    treeConfig: {},
    showOverflow: { type: [String, Boolean], default: true },
    autoResize: { type: Boolean, default: true },
    height: { default: "100%" },
    align: {},
    border: { type: [Boolean, String], default: "default" },
    emptyText: {},
    rowStyle: {},
    column: {},
    showPage: { type: Boolean, default: true },
    useTree: { type: Boolean },
    isRemoteQuery: { type: Boolean },
    isServerPaging: { type: Boolean },
    paginationConfig: {},
    showDescription: { type: Boolean, default: true },
    showHeaderTools: { type: Boolean, default: true },
    batchOperations: {},
    showBatchOperation: { type: Boolean },
    showColumnMenu: { type: Boolean, default: false },
    showDragColumn: { type: Boolean },
    cellClickToggleHighlight: { type: Boolean, default: true },
    widgets: {},
    showSearchInput: { type: Boolean, default: true },
    showFilter: { type: Boolean, default: true },
    showRefresh: { type: Boolean, default: true },
    showTransfer: { type: Boolean, default: false },
    showSizeControl: { type: Boolean },
    advancedFilterConfig: {},
    searchConfig: {},
    style: {},
    class: {},
    simple: { type: Boolean },
    defaultTransferData: {},
    onTransferShow: {},
    onTransferHide: {},
    onTransferChange: {},
    onAdvancedFilterShow: {},
    onAdvancedFilterHide: {},
    useAntStyle: { type: Boolean },
    round: { type: Boolean, default: false },
    adaptive: { type: Boolean }
  },
  emits: [
    "remote-query",
    "server-paging",
    "refresh",
    "highlight-clear",
    "highlight-change",
    "cell-click",
    "resizable-change",
    "hide-column",
    "checkbox-change",
    "checkbox-all",
    "drag",
    "sort-change",
    "advanced-filter-confirm",
    "advanced-filter-clear",
    "page-current-change",
    "page-size-change",
    "page-change",
    "prev-click",
    "next-click"
  ],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = inject("_styleModule", ""), a = useSlots(), i = inject("$t"), s = [25, 50, 80, 100, 150], l = /* @__PURE__ */ new Map([
      ["search", "search"],
      ["refresh", "refresh"],
      ["filter", "filter"],
      ["sizeControl", "sizeControl"],
      ["transfer", "transfer"]
    ]), c = {
      isHover: true,
      isCurrent: true,
      useKey: true,
      keyField: "id"
    }, u = {
      transform: true,
      rowField: "id",
      parentField: "pid",
      childrenField: "children",
      trigger: "cell",
      hasChildField: "hasChild"
    }, d = {
      pagerCount: 7,
      currentPage: 1,
      pageSizes: s,
      pageSize: s[0],
      size: o.useAntStyle ? "sm" : void 0,
      layout: o.useAntStyle ? "total, prev, pager, next, sizes" : void 0
    }, m = {}, p = {
      key: "id",
      trigger: "click",
      mode: "cell"
    }, f = {
      seqMethod: ({ rowIndex: C }) => {
        var ue;
        const G = ((ue = o.seqConfig) == null ? void 0 : ue.startIndex) ?? 1;
        if (Z.value) {
          const { pageSize: ge, currentPage: J } = B.value;
          return (J - 1) * ge + C + G;
        }
        return C + G;
      }
    }, h10 = { enabled: true }, g = { resizable: true }, v = n, y = ref(), k = ref(o.size), T = [
      { label: "默认", value: "" },
      { label: "中等", value: "medium" },
      { label: "小号", value: "small" },
      { label: "紧凑", value: "mini" }
    ], w = ref(), _ = ref([]), M = ref([]), x = ref([]), R = ref(""), I = ref(""), P = ref([]), F = ref([]), N = ref([]), j = ref(), z = ref([]), A = ref(), B = ref(d), D = computed(() => {
      const C = [];
      if (!Array.isArray(o.widgets))
        return o.showSearchInput && C.push({
          id: "search",
          slot: null
        }), o.showRefresh && C.push({
          id: "refresh",
          slot: null
        }), o.showFilter && C.push({
          id: "filter",
          slot: null
        }), o.showSizeControl && C.push({
          id: "sizeControl",
          slot: null
        }), o.showTransfer && C.push({
          id: "transfer",
          slot: null
        }), C;
      for (const G of o.widgets) {
        if (!G)
          continue;
        const ue = typeof G;
        ue === "string" ? l.get(G) ? C.push({ id: G, slot: null }) : C.push({ id: G, slot: G }) : (ue === "object" || ue === "function") && C.push(G);
      }
      return C;
    }), te = computed(() => {
      const { filterColumns: C, filterAll: G, exclude: ue = [] } = o.advancedFilterConfig ?? {}, ge = _d(
        Sr(_.value),
        "group",
        (J) => !J.type && J.title && J.field && (G !== false || J.visible !== false) && !ue.includes(J.field)
      );
      return C ? wd(ge, "group", C, "field") : ge;
    }), ie = computed(() => {
      var G;
      return (G = y.value) == null ? void 0 : G.tableInstance;
    }), U = computed(() => {
      var G, ue;
      let C = "";
      if ((ue = (G = A.value) == null ? void 0 : G.conditionList) != null && ue.length) {
        const { filterRule: ge } = A.value;
        C += ge === 0 ? i == null ? void 0 : i("anyOne") : i == null ? void 0 : i("all"), A.value.conditionList.forEach((J, Ce) => {
          const We = o.useTree && Ce === 0 ? "" : "·";
          C += `  ${We} ${J.title} ${J.logic} ${J.showValue}`;
        });
      } else {
        const ge = o.useTree ? "" : "· ";
        C += `${ge}${i == null ? void 0 : i("showAll")}`;
      }
      return C;
    }), oe = computed(() => k.value ?? void 0), se = computed(() => {
      const C = D.value.map((G) => G.id);
      return !!(o.showHeaderTools && C.includes("transfer"));
    }), E = computed(() => {
      if (o.useTree)
        return Object.assign(u, o.treeConfig || {});
    }), K = computed(() => Object.assign(m, o.sortConfig || {})), ee = computed(() => Object.assign(c, o.rowConfig || {})), V = computed(() => Object.assign(p, o.editConfig || {})), le = computed(() => {
      const C = Object.assign(h10, o.scrollY || {});
      return o.adaptive && (C.enabled = false), C;
    }), pe = computed(() => Object.assign(g, o.columnConfig || {})), Te = computed(() => Object.assign(f, o.seqConfig || {})), Z = computed(() => o.showPage && !o.useTree && !o.simple), X = computed(() => he()), Q = computed(() => {
      pn();
      const { isRemotePaging: C } = B.value;
      return !Z.value || o.isServerPaging || C ? X.value : un(X.value);
    }), W = computed(() => {
      const { isRemotePaging: C, total: G } = B.value;
      return Z.value && (C || o.isServerPaging) ? G : X.value.length;
    }), { setTableData: de, sortChange: Ne, dragSort: Pe, _methods: tt } = X8(o, ie), {
      checkedDataSize: Qe,
      checkboxConfig: lt,
      closeBatchOperation: Be,
      checkBoxChange: Xe,
      checkboxAll: it,
      clearCheckedData: St,
      resetCheckboxStatus: pn,
      _checkboxMethods: hn
    } = Y8(ie, Q, o);
    watch(
      [() => o.data, () => {
        var C;
        return (C = o.data) == null ? void 0 : C.length;
      }],
      () => {
        St(), x.value = de(o.data), zi();
      },
      { immediate: true }
    ), watch(
      () => o.paginationConfig,
      () => {
        B.value = Object.assign(B.value, o.paginationConfig || {});
      },
      { immediate: true, deep: true }
    ), onMounted(() => {
      Ai();
    }), watch(
      () => o.column,
      () => {
        _.value = o.column.map((C) => {
          const G = C.visible !== false, ue = C.field ?? `_table_column_${C.type ?? ""}`;
          return { ...Sr(C), visible: G, field: ue };
        }), cr(), lr();
      },
      { deep: true }
    );
    let cn = false;
    watch(
      () => {
        var C;
        return (C = Q.value) == null ? void 0 : C.length;
      },
      () => {
        o.useTree && nextTick(() => {
          var C, G;
          if (R.value.trim() || cn) {
            cn = false;
            const ue = Q.value.length > 500 ? 500 : Q.value.length, ge = Q.value.slice(0, ue);
            (C = ie.value) == null || C.setTreeExpand(ge, true);
          } else
            (G = ie.value) == null || G.clearTreeExpand();
        });
      },
      { immediate: true }
    );
    let ne = /* @__PURE__ */ new Map();
    const ae = /* @__PURE__ */ new Map();
    function he() {
      var Rt, ct, Zn;
      const C = (ct = (Rt = A.value) == null ? void 0 : Rt.conditionList) != null && ct.length ? z.value : x.value, { strict: G, searchMethod: ue, ignoreCase: ge = false } = o.searchConfig ?? {}, J = R.value.trim().replace(/\\/g, "\\\\");
      if (o.isRemoteQuery || (Zn = o.searchConfig) != null && Zn.isRemoteQuery)
        return v("remote-query", J), C;
      if (!J)
        return C;
      if (typeof ue == "function")
        return ue(J, C);
      const We = M.value.filter((ft) => ft.visible !== false).map((ft) => ft.field && !ft.type ? ft.field : null).filter((ft) => ft !== null);
      let vt = C.filter((ft) => We.some((Wo) => {
        const Ri = ie.value.getCellLabel(ft, Wo);
        return G === true ? Ri === J : ge ? String(Ri).toLowerCase().indexOf(J.toLowerCase()) !== -1 : String(Ri).indexOf(J) !== -1;
      }));
      if (o.useTree) {
        const { rowField: ft } = Oo();
        ne = new Map(x.value.map((Wo) => [Wo[ft], Wo])), xe(vt), vt = Ie([...ae.values()], x.value, ft);
      } else
        jo(vt.length);
      return vt;
    }
    function xe(C) {
      const { parentField: G, rowField: ue } = Oo();
      ae.clear();
      for (let J = 0; J < C.length; J++) {
        const Ce = C[J];
        ae.get(Ce[ue]) || (ae.set(Ce[ue], Ce), Je(Ce, G));
      }
      const ge = Ve();
      Ee(C, ge);
    }
    function Ee(C, G) {
      if (!C || !C.length)
        return;
      const ue = ee.value.keyField;
      for (const ge of C) {
        const J = G.get(ge[ue]);
        J && (J.children.forEach((Ce) => {
          ae.get(Ce[ue]) || ae.set(Ce[ue], Ce);
        }), Ee(J.children, G));
      }
    }
    function Ve() {
      const C = /* @__PURE__ */ new Map(), { rowField: G, parentField: ue } = Oo();
      for (const ge of x.value) {
        C.has(ge[G]) || C.set(ge[G], { node: ge, children: [] });
        const J = C.get(ge[ue]);
        J && J.children.push(ge);
      }
      return C;
    }
    function Je(C, G, ue) {
      const ge = C[G], J = ne.get(ge);
      J && (ae.get(ge) || ae.set(ge, J), J[G] !== null && Je(J, G));
    }
    function Ie(C, G, ue) {
      const ge = G.map((J) => J[ue]);
      return C.sort((J, Ce) => ge.indexOf(J[ue]) < ge.indexOf(Ce[ue]) ? -1 : 1);
    }
    function Nt() {
      I.value = "", R.value = "";
    }
    function bt(C) {
      B.value.pageSize = C;
      const { isRemotePaging: G } = B.value;
      (o.isServerPaging || G) && v("server-paging", B.value), v("page-size-change", C);
    }
    function Ze(C) {
      B.value.currentPage = C;
      const { isRemotePaging: G } = B.value;
      (o.isServerPaging || G) && v("server-paging", B.value), v("page-current-change", C);
    }
    function un(C) {
      const { isRemotePaging: G } = B.value;
      if (o.isServerPaging || G)
        return v("server-paging", B.value), C;
      const { currentPage: ue, pageSize: ge } = B.value, J = (ue - 1) * ge, Ce = J + ge;
      return C.slice(J, Ce);
    }
    function jo(C) {
      let { currentPage: G } = B.value;
      const ue = B.value.pageSize;
      for (; (G - 1) * ue + 1 > C && G > 1; )
        G--;
      B.value.currentPage = G;
    }
    function lo(C) {
      if (!o.rowStyle) {
        const { row: G } = C;
        return G.style || {};
      }
      return typeof o.rowStyle == "function" ? o.rowStyle(C) : o.rowStyle;
    }
    function lr() {
      for (const C of M.value)
        typeof C.render == "function" && (C.cellRender = {
          name: Dt(16),
          ...C.cellRender || {}
        }, index_esm_default2.renderer.add(C.cellRender.name, {
          renderDefault(G, { row: ue, column: ge }) {
            var J;
            return (J = C.render) == null ? void 0 : J.call(C, { row: ue, column: ge });
          }
        }), index_esm_default2.renderer.add(C.cellRender.name, {
          renderTableDefault(G, { row: ue, column: ge }) {
            var J;
            return (J = C.render) == null ? void 0 : J.call(C, { row: ue, column: ge });
          }
        })), typeof C.renderEdit == "function" && (C.editRender = {
          name: Dt(16),
          ...C.editRender || {}
        }, index_esm_default2.renderer.add(C.editRender.name, {
          renderTableEdit(G, { row: ue, column: ge }) {
            var J;
            return (J = C.renderEdit) == null ? void 0 : J.call(C, { row: ue, column: ge });
          }
        }));
    }
    function Oo() {
      var ue, ge;
      const C = ((ue = E.value) == null ? void 0 : ue.parentField) || "pid", G = ((ge = E.value) == null ? void 0 : ge.rowField) || "id";
      return { parentField: C, rowField: G };
    }
    function ka(C) {
      M.value.forEach((G) => {
        C.includes(G.field) ? G.visible = true : G.visible = false;
      });
    }
    async function Ai() {
      var J;
      let C = o.defaultTransferData ?? [];
      typeof o.defaultTransferData == "function" && (C = await ((J = o.defaultTransferData) == null ? void 0 : J.call(o))), C = Array.isArray(C) ? C : [];
      const G = new Map(
        C.map((Ce) => [Ce.key, Ce])
      ), ue = C.map((Ce) => Ce.key), ge = o.column.map((Ce) => {
        var ct, Zn;
        const We = Ce.field ?? `_table_column_${Ce.type ?? ""}`, vt = ((ct = G.get(We)) == null ? void 0 : ct.visible) ?? Ce.visible !== false, Rt = (Zn = G.get(We)) == null ? void 0 : Zn.width;
        return { ...Sr(Ce), visible: vt, field: We, __width__: Rt };
      });
      _.value = ge.sort((Ce, We) => ue.indexOf(Ce.field) - ue.indexOf(We.field)), cr(), lr(), vc(C), setTimeout(() => {
        Bn = JSON.stringify(fr());
      });
    }
    function cr() {
      M.value = Fr(_.value, "group"), F.value = M.value.map((C) => {
        if (C.field)
          return {
            label: C.title || C.type || "undefined",
            key: C.field
          };
      }).filter((C) => C !== void 0), P.value = M.value.filter((C) => C.visible !== false).map((C) => {
        if (C.field)
          return {
            label: C.title || C.type || "undefined",
            key: C.field
          };
      }).filter((C) => C !== void 0), N.value = P.value.map((C) => C.key).filter((C) => C !== void 0);
    }
    function ur(C) {
      if (!se.value)
        return;
      const G = M.value.find((ue) => ue.field === C.field);
      G && (G.visible = false, P.value = M.value.filter((ue) => ue.visible !== false).map((ue) => {
        if (ue.title && ue.field)
          return {
            label: ue.title,
            key: ue.field
          };
      }).filter((ue) => ue !== void 0), v("hide-column", C));
    }
    function co(C) {
      if (!Array.isArray(C))
        return;
      let G = 0;
      const ue = new Map(M.value.map((J) => [J.field, J])), ge = (J) => {
        var Ce;
        for (const [We, vt] of J.entries())
          if (Array.isArray(vt.group) && vt.group.length > 0)
            ge(vt.group);
          else {
            const Rt = (Ce = C[G++]) == null ? void 0 : Ce.key;
            J[We] = ue.get(Rt) ?? {};
          }
      };
      ge(_.value), M.value = Fr(_.value, "group");
    }
    function Bo() {
      typeof o.onTransferShow == "function" && o.onTransferShow();
    }
    let Bn = "";
    function uo() {
      if (typeof o.onTransferChange == "function") {
        const C = fr();
        JSON.stringify(C) !== Bn && (o.onTransferChange(C), Bn = JSON.stringify(C));
      }
    }
    function Ei() {
      if (typeof o.onTransferHide == "function") {
        const C = fr();
        o.onTransferHide(C);
      }
    }
    function Zo(C, G, ue = true) {
      var ge;
      if (A.value = C, z.value = G, o.useTree) {
        xe(z.value);
        const { rowField: J } = Oo();
        z.value = Ie([...ae.values()], x.value, J);
      }
      (ge = C == null ? void 0 : C.conditionList) != null && ge.length ? cn = true : cn = false, ue && v("advanced-filter-confirm", { conditionInfo: C, tableData: G });
    }
    function Ki(C) {
      R.value = C ?? "";
    }
    function nm() {
      typeof o.onAdvancedFilterShow == "function" && o.onAdvancedFilterShow();
    }
    function om() {
      if (typeof o.onAdvancedFilterHide == "function") {
        const C = gc(), G = z.value;
        o.onAdvancedFilterHide({ conditionInfo: C, filterData: G });
      }
    }
    let Sa = false, dr = null;
    function am({ row: C, rowid: G }) {
      var J, Ce, We;
      if (!o.cellClickToggleHighlight)
        return;
      Sa ? Sa && dr === G && ((J = ie.value) == null || J.setCurrentRow(null), Sa = false, dr = null, v("highlight-clear", C)) : Sa = true;
      const ue = (Ce = ie.value) == null ? void 0 : Ce.getCurrentRecord(), ge = (We = ie.value) == null ? void 0 : We.getRowid(ue);
      dr !== G && ge === G && (dr = G), v("highlight-change", C, Sa);
    }
    function rm(C) {
      Pe(C) && v("drag", x.value);
    }
    async function zi(C) {
      var J, Ce, We;
      if (!j.value)
        return;
      await nextTick();
      const G = (We = (Ce = (J = j.value) == null ? void 0 : J[0]) == null ? void 0 : Ce.filter) == null ? void 0 : We.call(Ce, C), { conditionInfo: ue, tableData: ge } = G ?? {};
      return Zo(ue, ge, false), { conditionInfo: ue, tableData: ge };
    }
    async function Pi() {
      var ge, J, Ce;
      if (!j.value)
        return;
      await nextTick();
      const C = (Ce = (J = (ge = j.value) == null ? void 0 : ge[0]) == null ? void 0 : J.clearFilter) == null ? void 0 : Ce.call(J), { conditionInfo: G, tableData: ue } = C ?? {};
      return Zo(G, ue, false), { conditionInfo: G, tableData: ue };
    }
    function im(C) {
      Array.isArray(C) && (x.value = de(C), zi(C));
    }
    function gc() {
      var C, G;
      return (G = (C = j.value) == null ? void 0 : C[0]) == null ? void 0 : G.getConditionInfo();
    }
    function sm(C) {
      const G = ie.value.getSortColumns();
      Ne(G), v("sort-change", C);
    }
    function lm(C) {
      var Ce;
      const G = (Ce = ie.value) == null ? void 0 : Ce.getRowById(C);
      if (G)
        return G;
      const ue = x.value.find(
        (We) => We[ee.value.keyField] === C
      );
      return ue || (ie.value.getInsertRecords().find(
        (We) => We[ee.value.keyField] === C
      ) ?? null);
    }
    function cm() {
      return Q.value;
    }
    function um() {
      const C = document.querySelector(".vxe-table--tooltip-wrapper");
      C && (C == null || C.remove());
    }
    function fr() {
      var We, vt, Rt, ct, Zn;
      const C = /* @__PURE__ */ new Map(), G = (We = ie.value) == null ? void 0 : We.getColumns();
      for (const ft of G) {
        const Wo = (vt = ie.value) == null ? void 0 : vt.getColumnWidth(ft);
        C.set(ft.field, Wo);
      }
      const { sourceData: ue = [], selectData: ge = [] } = ((Zn = (ct = (Rt = w.value) == null ? void 0 : Rt[0]) == null ? void 0 : ct.getTransferData) == null ? void 0 : Zn.call(ct)) ?? [], J = new Set(ge.map((ft) => ft.key));
      return ue.map((ft) => ({
        label: ft.label,
        key: ft.key,
        width: C.get(ft.key) ?? "",
        visible: J.has(ft.key),
        disabled: ft.disabled ?? false
      }));
    }
    function dm(C) {
      var G, ue;
      (G = C.forEach) == null || G.call(C, (ge) => {
        const J = M.value.find((Ce) => Ce.field === ge.key);
        J && (ge.visible ? J.visible = true : J.visible = false);
      }), F.value = ((ue = C.map) == null ? void 0 : ue.call(C, (ge) => ({
        label: ge.label ?? "",
        key: ge.key ?? `_${Dt(8)}`,
        disabled: ge.disabled ?? false,
        visible: ge.visible !== false
      }))) ?? [], P.value = F.value.filter((ge) => ge.visible !== false), co(C), vc(C);
    }
    function vc(C) {
      const G = new Map(
        C.map((ue) => [ue.key, ue])
      );
      for (const ue of _.value) {
        const ge = G.get(ue.field);
        !ge || !ge.width || (ue.width = ge.width);
      }
    }
    function fm() {
      return k.value === "small" || k.value === "mini" ? "sm" : "base";
    }
    provide("__showTransfer", se), provide(
      fn,
      computed(() => fm())
    );
    const mm = {
      tableInstance: ie,
      filter: Ki,
      advancedFilter: zi,
      clearAdvancedFilter: Pi,
      getAdvancedCondition: gc,
      getVisibleData: cm,
      getRowById: lm,
      loadData: im,
      disposeRowTooltip: um,
      getHeaderControllerData: fr,
      setHeaderControllerData: dm,
      clearSearch: Nt,
      ...tt,
      ...hn
    };
    return t10(Ae(mm, ie)), (C, G) => {
      const ue = resolveDirective("ksw_tooltip"), ge = resolveDirective("ksw_drag");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass([
          "k-tree-table flex flex-col h-full",
          o.class,
          unref(r),
          { "tree-table-use-ant-style": C.useAntStyle }
        ]),
        style: normalizeStyle({ height: C.height, ...C.style })
      }, [
        C.simple && C.showSearchInput ? (openBlock(), createElementBlock("div", Q8, [
          createVNode(unref(ro), {
            modelValue: I.value,
            "onUpdate:modelValue": G[0] || (G[0] = (J) => I.value = J),
            "suffix-icon": unref(Dr),
            placeholder: C.$t("searchTable"),
            clearable: "",
            onChange: Ki
          }, null, 8, ["modelValue", "suffix-icon", "placeholder"])
        ])) : C.showHeaderTools && !C.simple ? (openBlock(), createElementBlock("div", {
          key: 1,
          ref: "RefTableHeader",
          class: "k-tree-table__header",
          style: normalizeStyle({
            justifyContent: C.showDescription ? "space-between" : "flex-end"
          })
        }, [
          C.showDescription ? (openBlock(), createElementBlock("div", J8, [
            renderSlot(C.$slots, "description", {
              total: W.value,
              conditionInfo: A.value
            }, () => {
              var J, Ce, We, vt;
              return [
                C.useTree ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", eb, toDisplayString(C.$t("total")) + " " + toDisplayString(W.value) + " " + toDisplayString(C.$t("data")), 1)),
                createBaseVNode("span", {
                  title: U.value,
                  class: "condition-info"
                }, toDisplayString(U.value), 9, tb),
                (Ce = (J = A.value) == null ? void 0 : J.conditionList) != null && Ce.length && ((vt = (We = j.value) == null ? void 0 : We[0]) != null && vt.clearFilter) ? (openBlock(), createElementBlock("span", {
                  key: 1,
                  class: "filter-reset",
                  onClick: G[1] || (G[1] = () => {
                    Pi(), v("advanced-filter-clear");
                  })
                }, " · " + toDisplayString(C.$t("reset")), 1)) : createCommentVNode("", true)
              ];
            })
          ])) : createCommentVNode("", true),
          createBaseVNode("div", nb, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(D.value, (J) => {
              var Ce, We, vt, Rt;
              return openBlock(), createElementBlock(Fragment, {
                key: J.id
              }, [
                J.slot && C.$slots[J.slot] ? renderSlot(C.$slots, J.slot, { key: 0 }) : J.id === "search" ? (openBlock(), createBlock(unref(ro), {
                  key: 1,
                  modelValue: I.value,
                  "onUpdate:modelValue": G[2] || (G[2] = (ct) => I.value = ct),
                  "suffix-icon": unref(Dr),
                  placeholder: C.$t("searchTable"),
                  clearable: "",
                  onChange: Ki
                }, null, 8, ["modelValue", "suffix-icon", "placeholder"])) : J.id === "refresh" ? withDirectives((openBlock(), createBlock(unref(Lt), {
                  key: 2,
                  onClick: G[3] || (G[3] = () => {
                    v("refresh");
                  })
                }, {
                  default: withCtx(() => [
                    createVNode(unref(g0))
                  ]),
                  _: 1
                })), [
                  [ue, C.$t("refresh")]
                ]) : J.id === "filter" ? (openBlock(), createBlock(unref(Wf), {
                  key: 3,
                  ref_for: true,
                  ref_key: "tableFilterRef",
                  ref: j,
                  data: x.value,
                  options: te.value,
                  "children-field": "group",
                  "filter-key": "field",
                  remote: ((Ce = C.advancedFilterConfig) == null ? void 0 : Ce.remote) ?? false,
                  "ignore-case": (We = C.advancedFilterConfig) == null ? void 0 : We.ignoreCase,
                  formatter: ((vt = C.advancedFilterConfig) == null ? void 0 : vt.dateFormat) ?? "YYYY-MM-DD HH:mm:ss",
                  "default-condition": ((Rt = C.advancedFilterConfig) == null ? void 0 : Rt.defaultCondition) ?? A.value,
                  onConfirm: Zo,
                  onClear: G[4] || (G[4] = () => {
                    Pi(), v("advanced-filter-clear");
                  }),
                  onShow: nm,
                  onHide: om
                }, {
                  reference: withCtx(({ hasConfigCondition: ct }) => [
                    withDirectives((openBlock(), createElementBlock("div", null, [
                      J.widget ? (openBlock(), createBlock(resolveDynamicComponent(typeof J.widget == "function" ? J.widget() : J.widget), { key: 0 })) : renderSlot(C.$slots, "filterTrigger", {
                        key: 1,
                        isFilter: ct
                      }, () => [
                        createVNode(unref(Lt), null, {
                          default: withCtx(() => [
                            ct ? (openBlock(), createBlock(unref(Ir), {
                              key: 1,
                              color: "#2882FF"
                            })) : (openBlock(), createBlock(unref(La), { key: 0 }))
                          ]),
                          _: 2
                        }, 1024)
                      ])
                    ])), [
                      [ue, C.$t("advancedFilter_c")]
                    ])
                  ]),
                  _: 2
                }, 1032, ["data", "options", "remote", "ignore-case", "formatter", "default-condition"])) : J.id === "sizeControl" ? (openBlock(), createBlock(unref(ar), {
                  key: 4,
                  trigger: "click",
                  onCommand: G[5] || (G[5] = (ct) => {
                    k.value = ct || void 0;
                  })
                }, {
                  title: withCtx(() => [
                    withDirectives((openBlock(), createElementBlock("div", ob, [
                      J.widget ? (openBlock(), createBlock(resolveDynamicComponent(typeof J.widget == "function" ? J.widget() : J.widget), { key: 0 })) : renderSlot(C.$slots, "sizeControlTrigger", { key: 1 }, () => [
                        createVNode(unref(Lt), null, {
                          default: withCtx(() => [
                            createVNode(unref(Uh))
                          ]),
                          _: 1
                        })
                      ])
                    ])), [
                      [ue, C.$t("sizeControlTrigger")]
                    ])
                  ]),
                  default: withCtx(() => [
                    (openBlock(), createElementBlock(Fragment, null, renderList(T, (ct) => createVNode(unref(rr), {
                      key: ct.value,
                      style: normalizeStyle({
                        color: k.value === (ct.value || void 0) ? "#2882FF" : ""
                      }),
                      command: ct.value
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(ct.label), 1)
                      ]),
                      _: 2
                    }, 1032, ["style", "command"])), 64))
                  ]),
                  _: 2
                }, 1024)) : J.id === "transfer" ? (openBlock(), createBlock(unref(Io), {
                  key: 5,
                  trigger: "click",
                  width: "auto",
                  teleported: false,
                  onShow: Bo,
                  onHide: G[7] || (G[7] = () => {
                    Ei(), uo();
                  })
                }, {
                  reference: withCtx(() => [
                    withDirectives((openBlock(), createElementBlock("div", ab, [
                      J.widget ? (openBlock(), createBlock(resolveDynamicComponent(typeof J.widget == "function" ? J.widget() : J.widget), { key: 0 })) : renderSlot(C.$slots, "transferTrigger", { key: 1 }, () => [
                        createVNode(unref(Lt), null, {
                          default: withCtx(() => [
                            createVNode(unref(Hh))
                          ]),
                          _: 1
                        })
                      ])
                    ])), [
                      [ue, C.$t("columnHeaderController")]
                    ])
                  ]),
                  default: withCtx(() => [
                    createVNode(unref(jf), {
                      ref_for: true,
                      ref_key: "tableTransferRef",
                      ref: w,
                      modelValue: P.value,
                      "onUpdate:modelValue": G[6] || (G[6] = (ct) => P.value = ct),
                      data: F.value,
                      "default-keys": N.value,
                      titles: [C.$t("unselectedFields"), C.$t("selectedFields")],
                      onChange: ka,
                      onReset: ka,
                      onSort: co
                    }, null, 8, ["modelValue", "data", "default-keys", "titles"])
                  ]),
                  _: 2
                }, 1024)) : J.widget ? (openBlock(), createBlock(resolveDynamicComponent(typeof J.widget == "function" ? J.widget() : J.widget), { key: 6 })) : createCommentVNode("", true)
              ], 64);
            }), 128))
          ])
        ], 4)) : createCommentVNode("", true),
        createBaseVNode("div", rb, [
          createVNode(unref(Hr), mergeProps({
            ref_key: "xTree",
            ref: y,
            border: C.useAntStyle ? "inner" : C.border,
            size: oe.value,
            height: C.adaptive ? void 0 : "100%",
            data: Q.value,
            "row-config": ee.value,
            "sort-config": K.value,
            "tree-config": E.value,
            "seq-config": Te.value,
            "checkbox-config": unref(lt),
            "edit-config": V.value,
            "column-config": pe.value,
            "empty-text": C.emptyText || C.$t("noData"),
            "scroll-y": le.value,
            "row-style": lo,
            "show-overflow": C.showOverflow,
            "auto-resize": C.autoResize,
            "show-column-menu": C.showColumnMenu,
            "show-drag-column": C.showDragColumn,
            align: C.align,
            round: C.useAntStyle || C.round
          }, C.$attrs, {
            onCheckboxChange: G[8] || (G[8] = (J) => {
              unref(Xe)(J), v("checkbox-change", J);
            }),
            onCheckboxAll: G[9] || (G[9] = (J) => {
              unref(it)(J), v("checkbox-all", J);
            }),
            onHideColumn: ur,
            onCellClick: G[10] || (G[10] = (J) => {
              am(J), v("cell-click", J);
            }),
            onResizableChange: G[11] || (G[11] = (J) => {
              uo(), v("resizable-change", J);
            }),
            onSortChange: sm,
            onDrag: rm
          }), createSlots({
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_.value, (J, Ce) => (openBlock(), createBlock(unref(G8), {
                key: Ce,
                column: J,
                size: C.size,
                align: C.align
              }, createSlots({ _: 2 }, [
                renderList(C.$slots, (We, vt) => ({
                  name: vt,
                  fn: withCtx((Rt) => [
                    renderSlot(C.$slots, vt, mergeProps({ ref_for: true }, Rt))
                  ])
                }))
              ]), 1032, ["column", "size", "align"]))), 128))
            ]),
            _: 2
          }, [
            a.empty ? {
              name: "empty",
              fn: withCtx(() => [
                renderSlot(C.$slots, "empty")
              ]),
              key: "0"
            } : void 0,
            a.dragIcon ? {
              name: "dragIcon",
              fn: withCtx(() => [
                renderSlot(C.$slots, "dragIcon")
              ]),
              key: "1"
            } : void 0,
            a.loading ? {
              name: "loading",
              fn: withCtx(() => [
                renderSlot(C.$slots, "loading")
              ]),
              key: "2"
            } : void 0
          ]), 1040, ["border", "size", "height", "data", "row-config", "sort-config", "tree-config", "seq-config", "checkbox-config", "edit-config", "column-config", "empty-text", "scroll-y", "show-overflow", "auto-resize", "show-column-menu", "show-drag-column", "align", "round"]),
          C.showBatchOperation && unref(Qe) > 0 ? withDirectives((openBlock(), createElementBlock("div", ib, [
            createVNode(unref(Of), {
              total: unref(Qe),
              data: C.batchOperations,
              onClose: unref(Be)
            }, null, 8, ["total", "data", "onClose"])
          ])), [
            [ge]
          ]) : createCommentVNode("", true)
        ]),
        Z.value ? (openBlock(), createElementBlock("div", sb, [
          createVNode(unref(zf), mergeProps(B.value, {
            total: W.value,
            onCurrentChange: Ze,
            onSizeChange: bt,
            onChange: G[12] || (G[12] = (J, Ce) => {
              v("page-change", J, Ce);
            }),
            onPrevClick: G[13] || (G[13] = (J) => {
              v("prev-click", J);
            }),
            onNextClick: G[14] || (G[14] = (J) => {
              v("next-click", J);
            })
          }), null, 16, ["total"])
        ], 512)) : createCommentVNode("", true)
      ], 6);
    };
  }
});
var cb = $e(lb);
var ub = {
  key: 0,
  class: "k-transfer__filter"
};
var db = {
  class: "k-transfer__body"
};
var fb = {
  class: "k-transfer-content k-transfer-content__left"
};
var mb = ["onClick"];
var pb = ["title"];
var hb = {
  class: "k-transfer-content k-transfer-content__right"
};
var gb = {
  class: "k-transfer__list"
};
var vb = {
  class: "right-data-header"
};
var yb = {
  class: "right-data-title"
};
var bb = {
  class: "column-body"
};
var _b = {
  class: "column-content"
};
var wb = ["title"];
var Tb = {
  class: "column-operate"
};
var Cb = defineComponent({
  name: "KTreeTransfer",
  __name: "tree_transfer",
  props: {
    data: {},
    defaultData: {
      default: () => []
    },
    titles: {},
    showSearchInput: {
      type: Boolean,
      default: true
    },
    useTree: {
      type: Boolean,
      default: false
    },
    expandIcon: {},
    expandIconColor: {},
    collapseIcon: {},
    collapseIconColor: {},
    icon: {},
    iconColor: {},
    treeConfig: {},
    label: {
      default: "label"
    },
    scrollY: {},
    drag: {
      type: Boolean
    },
    showDrag: {
      type: Boolean,
      default: false
    },
    checkMethod: {},
    searchMethod: {}
  },
  emits: ["change", "sort"],
  setup(e16, {
    expose: t10,
    emit: n
  }) {
    const o = e16, r = inject("_styleModule", ""), a = n, i = {
      transform: true,
      rowField: "id",
      parentField: "pid",
      childrenField: "children",
      trigger: "cell",
      hasChildField: "hasChild",
      indent: 0,
      showIcon: false
    }, s = ref([]), l = ref([]), c = ref([]), u = ref(""), d = ref(), m = ref(), p = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map();
    onMounted(() => {
      pe();
    });
    const h10 = computed(() => function(Z) {
      var W;
      const X = (W = d.value) == null ? void 0 : W.tableInstance.isTreeExpandByRow(Z), Q = !(Z.children && Z.children.length);
      if (Q && Z.nodeType === 1)
        return {
          icon: E(o.collapseIcon, Z),
          color: o.collapseIconColor
        };
      if (o.icon && Q)
        return {
          icon: E(o.icon, Z),
          color: o.iconColor
        };
      if (o.expandIcon && X && !Q)
        return {
          icon: E(o.expandIcon, Z),
          color: o.expandIconColor
        };
      if (o.collapseIcon && !X && !Q)
        return {
          icon: E(o.collapseIcon, Z),
          color: o.collapseIconColor
        };
    }), g = computed(() => {
      if (o.useTree) {
        const Z = Object.assign(i, o.treeConfig || {});
        return Z.indent = 0, Z;
      }
    }), v = computed(() => ({
      enabled: true,
      ...o.scrollY || {}
    })), y = computed(() => (Z) => B(Z)), k = computed(() => function(Z) {
      let X = Z;
      for (; X.pid; ) {
        const de = l.value.find((Ne) => Ne.id === X.pid);
        if (de)
          X = de;
        else
          break;
      }
      const Q = X.name;
      return {
        data: Z[o.label],
        name: Q
      };
    });
    watch(() => o.data, () => {
      s.value = Array.isArray(o.data) ? [...o.data] : [], l.value = [...s.value], setTimeout(() => {
        T();
      });
    }, {
      immediate: true
    });
    function T() {
      var X;
      for (const Q of o.data) {
        if (!o.useTree) {
          f.set(Q.id, {
            row: Q,
            checked: false
          });
          continue;
        }
        Q.disabled || o.data.find((de) => de.pid === Q.id) || f.set(Q.id, {
          row: {
            ...Q
          },
          checked: false
        });
      }
      const Z = (X = d == null ? void 0 : d.value) == null ? void 0 : X.tableInstance;
      if (Z) {
        const Q = Z.getCheckboxRecords();
        for (const W of Q) {
          const de = f.get(W.id);
          de && (de.checked = true);
        }
      }
      _();
    }
    function w(Z, X, Q = false) {
      M(Z, X, Q), _(), a("change", se());
    }
    function _() {
      const Z = l.value.filter((X) => {
        var Q;
        return ((Q = f.get(X.id)) == null ? void 0 : Q.checked) ?? false;
      });
      c.value = Z.filter((X) => {
        var Q;
        return !((Q = o.defaultData) != null && Q.includes(X.id) && !K({
          row: X
        }));
      }), c.value = oe(c.value, s.value);
    }
    function M(Z, X, Q) {
      if (Q) {
        const Ne = d.value.tableInstance.getCheckboxRecords().filter((Pe) => !Pe.children || !Pe.children.length);
        for (const Pe of Ne) {
          const tt = f.get(Pe.id);
          tt && (tt.checked = X);
        }
        return;
      }
      const W = Array.isArray(Z) ? Z : [Z];
      for (const de of W) {
        const Ne = f.get(Z.id);
        if (Ne && (Ne.checked = X), de.children && de.children.length)
          for (const Pe of de.children)
            M(Pe, X, Q);
      }
    }
    function x(Z) {
      if (!Z)
        return;
      const X = f.get(Z.id);
      X && (X.checked = false);
      const Q = d.value.tableInstance.getRowById(Z.id);
      d.value.tableInstance.setCheckboxRow(Q, false);
      const W = c.value.findIndex((de) => de.id === Z.id);
      W >= 0 && c.value.splice(W, 1), a("change", se());
    }
    function R() {
      for (const Z of c.value) {
        const X = f.get(Z.id);
        if (X) {
          X.checked = false;
          const Q = d.value.tableInstance.getRowById(Z.id);
          d.value.tableInstance.setCheckboxRow(Q, false);
        }
      }
      c.value = [], a("change", se());
    }
    async function I() {
      await F(), _();
    }
    function P() {
      return u.value;
    }
    async function F() {
      const Z = d.value.tableInstance, X = u.value.trim();
      let Q = [];
      if (typeof o.searchMethod == "function")
        Q = await o.searchMethod(X, o.data);
      else if (Q = o.data.filter((W) => W[o.label].toString().indexOf(X) !== -1), o.useTree) {
        N(Q);
        const {
          rowField: W
        } = te();
        Q = D([...p.values()], o.data, W), Q.length < 500 && X && nextTick(() => {
          Z.setAllTreeExpand(true);
        }), X || nextTick(() => {
          Z.setAllTreeExpand(false);
        });
      }
      await Z.clearCheckboxRow(), l.value = Q, await nextTick(), A();
    }
    function N(Z) {
      const {
        parentField: X,
        rowField: Q
      } = te();
      p.clear();
      for (let W = 0; W < Z.length; W++) {
        const de = Z[W];
        p.get(de[Q]) || (p.set(de[Q], de), z(de, X, Q));
      }
      j(Z);
    }
    function j(Z) {
      const {
        parentField: X,
        rowField: Q
      } = te(), W = new Map(Z.map((de) => [de[Q], de]));
      for (const de of o.data) {
        const Ne = de[X];
        W.get(Ne) && (p.set(de[Q], de), j([de]));
      }
    }
    function z(Z, X, Q) {
      var Ne;
      const W = Z[X], de = (Ne = o.data) == null ? void 0 : Ne.find((Pe) => Pe[Q] === W);
      de && (p.get(W) || p.set(W, de), de[X] !== null && z(de, X, Q));
    }
    async function A() {
      for (const {
        row: Z,
        checked: X
      } of f.values()) {
        const Q = d.value.tableInstance.getRowById(Z.id);
        Q && await d.value.tableInstance.setCheckboxRow(Q, X);
      }
    }
    function B(Z) {
      if (!o.useTree)
        return 0;
      const {
        parentField: X,
        rowField: Q
      } = te();
      if (!Z[X])
        return 0;
      const W = o.data.find((de) => de[Q] === Z[X]);
      return W ? 1 + B(W) : 0;
    }
    function D(Z, X, Q) {
      const W = X.map((de) => de[Q]);
      return Z.sort((de, Ne) => W.indexOf(de[Q]) < W.indexOf(Ne[Q]) ? -1 : 1);
    }
    function te() {
      var Q, W;
      const Z = ((Q = g.value) == null ? void 0 : Q.parentField) || "pid", X = ((W = g.value) == null ? void 0 : W.rowField) || "id";
      return {
        parentField: Z,
        rowField: X
      };
    }
    function ie(Z, X) {
      o.useTree && !ee(Z) && (X.stopPropagation(), d.value.tableInstance.toggleTreeExpand(Z));
    }
    function U(Z) {
      const {
        oldIndex: X,
        newIndex: Q
      } = Z;
      if (Q === void 0 || X === void 0 || Q === X)
        return;
      const W = c.value.map((Ne) => Ne.id);
      W.splice(Q, 0, W.splice(X, 1)[0]), s.value = yd(s.value, W);
      const de = se();
      a("change", de), a("sort", de), _();
    }
    function oe(Z, X) {
      const Q = X.map((W) => W.id);
      return Z.sort((W, de) => Q.indexOf(W.id) < Q.indexOf(de.id) ? -1 : 1);
    }
    function se() {
      return s.value.filter((Z) => {
        var X;
        return ((X = f.get(Z.id)) == null ? void 0 : X.checked) ?? false;
      });
    }
    function E(Z, X) {
      return typeof Z == "function" ? Z == null ? void 0 : Z(X) : Z;
    }
    function K(Z) {
      var Q;
      const {
        row: X
      } = Z;
      return ((Q = o.checkMethod) == null ? void 0 : Q.call(o, Z)) ?? !X.disabled ?? true;
    }
    function ee(Z) {
      return !Z.children || Z.children.length === 0;
    }
    async function V(Z, X) {
      const W = (Array.isArray(Z) ? Z : [Z]).map((de) => {
        const Ne = d.value.tableInstance.getRowById(de);
        return Ne && K({
          row: Ne
        }) && !Ne.disabled ? Ne : null;
      }).filter((de) => de !== null);
      await d.value.tableInstance.setCheckboxRow(W, X), w(W, X);
    }
    function le(Z) {
      const X = d.value.tableInstance.getRowById(Z);
      return d.value.tableInstance.isCheckedByCheckboxRow(X);
    }
    function pe() {
      var X;
      const Z = (X = m.value) == null ? void 0 : X.$el.querySelector(".el-input__suffix");
      Z ? Z.addEventListener("click", I) : console.error("Element with class .el-input__suffix not found");
    }
    async function Te() {
      u.value = "", await I(), R();
    }
    return t10({
      clearData: R,
      setCheckboxRow: V,
      isCheckedRow: le,
      clearQuery: Te,
      getQuery: P
    }), (Z, X) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["k-tree-transfer", unref(r)])
    }, [Z.showSearchInput ? (openBlock(), createElementBlock("div", ub, [createVNode(unref(ro), {
      ref_key: "KTransferInputRef",
      ref: m,
      modelValue: u.value,
      "onUpdate:modelValue": X[0] || (X[0] = (Q) => u.value = Q),
      placeholder: Z.$t("enterInputSearch"),
      "suffix-icon": unref(Dr),
      onKeyup: withKeys(I, ["enter"])
    }, null, 8, ["modelValue", "placeholder", "suffix-icon"])])) : createCommentVNode("", true), createBaseVNode("div", db, [createBaseVNode("div", fb, [createBaseVNode("div", {
      class: normalizeClass(["k-transfer__list", Z.useTree ? "transfer-tree-table" : ""])
    }, [createVNode(unref(Hr), {
      ref_key: "treeLeftRef",
      ref: d,
      size: "mini",
      border: false,
      height: "100%",
      data: l.value,
      "tree-config": g.value,
      "row-config": {
        keyField: "id"
      },
      "scroll-y": v.value,
      "checkbox-config": {
        checkRowKeys: Z.defaultData,
        trigger: "cell",
        checkMethod: K
      },
      onCheckboxChange: X[1] || (X[1] = ({
        row: Q,
        checked: W
      }) => {
        w(Q, W);
      }),
      onCheckboxAll: X[2] || (X[2] = ({
        row: Q,
        checked: W
      }) => {
        w(Q, W, true);
      })
    }, createSlots({
      default: withCtx(() => {
        var Q;
        return [createVNode(unref(Ur), {
          type: "checkbox",
          field: Z.label,
          title: ((Q = Z.titles) == null ? void 0 : Q[0]) ?? "",
          "tree-node": o.useTree
        }, {
          default: withCtx(({
            row: W
          }) => {
            var de, Ne, Pe;
            return [createBaseVNode("span", {
              class: normalizeClass(["tree-transfer__cell", {
                "list-item-disabled": W.disabled
              }]),
              style: normalizeStyle({
                marginLeft: `${y.value(W) * (((de = o.treeConfig) == null ? void 0 : de.indent) ?? 12)}px`
              }),
              onClick: (tt) => ie(W, tt)
            }, [(openBlock(), createBlock(resolveDynamicComponent((Ne = h10.value(W)) == null ? void 0 : Ne.icon), {
              class: "column-icon",
              color: (Pe = h10.value(W)) == null ? void 0 : Pe.color
            }, null, 8, ["color"])), createBaseVNode("span", {
              class: "tree-transfer__cell-label",
              title: W[o.label]
            }, toDisplayString(W[o.label]), 9, pb)], 14, mb)];
          }),
          _: 1
        }, 8, ["field", "title", "tree-node"])];
      }),
      _: 2
    }, [Z.$slots.empty && u.value ? {
      name: "empty",
      fn: withCtx(() => [renderSlot(Z.$slots, "empty", {
        query: u.value
      })]),
      key: "0"
    } : void 0]), 1032, ["data", "tree-config", "scroll-y", "checkbox-config"])], 2)]), createBaseVNode("div", hb, [createBaseVNode("div", gb, [createVNode(unref(Hr), {
      size: "mini",
      border: false,
      height: "100%",
      data: c.value,
      "row-config": {
        useKey: true
      },
      "scroll-y": v.value,
      onDrag: U
    }, createSlots({
      default: withCtx(() => [createVNode(unref(Ur), {
        field: Z.label
      }, {
        header: withCtx((Q) => [renderSlot(Z.$slots, "rightHeader", normalizeProps(guardReactiveProps(Q)), () => {
          var W;
          return [createBaseVNode("div", vb, [createBaseVNode("span", yb, toDisplayString(((W = o.titles) == null ? void 0 : W[1]) ?? ""), 1), createBaseVNode("span", {
            class: "clear-data",
            onClick: R
          }, toDisplayString(Z.$t("clearData")), 1)])];
        })]),
        default: withCtx(({
          row: Q
        }) => [createBaseVNode("div", bb, [createBaseVNode("span", _b, [renderSlot(Z.$slots, "right-cell", {}, () => [o.icon ? (openBlock(), createBlock(resolveDynamicComponent(E(o.icon, Q)), {
          key: 0,
          class: "column-icon"
        })) : createCommentVNode("", true), renderSlot(Z.$slots, "right-label", {
          parentData: k.value(Q)
        }, () => [createBaseVNode("span", {
          class: "tree-transfer__cell-label",
          title: Q[o.label]
        }, toDisplayString(Q[o.label]), 9, wb)])])]), createBaseVNode("div", Tb, [o.showDrag ? (openBlock(), createBlock(unref(bl), {
          key: 0,
          class: "__column-drag-icon"
        })) : createCommentVNode("", true), createVNode(unref(yl), {
          class: "column-close",
          onClick: (W) => x(Q)
        }, null, 8, ["onClick"])])])]),
        _: 3
      }, 8, ["field"])]),
      _: 2
    }, [Z.$slots.empty && u.value ? {
      name: "empty",
      fn: withCtx(() => [renderSlot(Z.$slots, "empty", {
        query: u.value
      })]),
      key: "0"
    } : void 0]), 1032, ["data", "scroll-y"])])])])], 2));
  }
});
var kb = $e(Cb);
var Sb = defineComponent({
  name: "KTreeSelect",
  __name: "tree_select",
  props: {
    name: {},
    icon: {},
    size: {},
    expandIcon: { default: "IconFolderOpen" },
    collapseIcon: { default: "IconFlowNested" },
    debounce: { default: 500 },
    className: {},
    nodeStyle: {}
  },
  emits: ["input", "blur"],
  setup(e16, { expose: t10, emit: n }) {
    const o = ["empty", "default"], r = e16, a = kt(r), i = inject("_styleModule", ""), s = n, l = ref(), c = ref({
      value: ""
    }), u = Dt(8), d = computed(() => (f) => {
      const { node: h10, data: g } = f;
      return g.icon ? g.icon : h10.isLeaf ? r.icon ?? "IconFlowNested" : h10.expanded ? r.expandIcon ?? "IconFolderOpen" : r.collapseIcon ?? "IconFlowNested";
    }), m = (f) => {
      O6(() => {
        const g = l.value.$el.querySelector(`[name="${r.name ?? u}"]`);
        c.value.value = g.value;
      }, r.debounce)(), s("input", f);
    };
    return provide(fn, a), t10(Ae({}, l)), (f, h10) => (openBlock(), createBlock(unref(ElTreeSelect), mergeProps({
      ref_key: "KTreeSelectRef",
      ref: l,
      name: f.name ?? unref(u),
      class: ["k-tree-select", unref(i)],
      size: unref(a).elSize
    }, f.$attrs, {
      onInput: m,
      onBlur: h10[0] || (h10[0] = (g) => {
        c.value.value = "", s("blur", g);
      })
    }), createSlots({
      default: withCtx((g) => [
        renderSlot(f.$slots, "default", normalizeProps(guardReactiveProps(g)), () => [
          createBaseVNode("span", {
            style: normalizeStyle(
              typeof r.nodeStyle == "function" ? r.nodeStyle(g) : r.nodeStyle
            ),
            class: normalizeClass(
              typeof r.className == "function" ? r.className(g) : r.className
            )
          }, [
            (openBlock(), createBlock(resolveDynamicComponent(d.value(g)), {
              class: normalizeClass([{ "tree-item-icon--noChildren": g.node.isLeaf }])
            }, null, 8, ["class"])),
            createTextVNode(" " + toDisplayString(g.data.label), 1)
          ], 6)
        ])
      ]),
      empty: withCtx(() => [
        renderSlot(f.$slots, "empty", { query: c.value }, () => [
          createTextVNode("未找到'" + toDisplayString(c.value.value) + "'相关内容", 1)
        ])
      ]),
      _: 2
    }, [
      renderList(f.$slots, (g, v) => ({
        name: v,
        fn: withCtx((y) => [
          o.includes(v) ? createCommentVNode("", true) : renderSlot(f.$slots, v, normalizeProps(mergeProps({ key: 0 }, y)))
        ])
      }))
    ]), 1040, ["name", "class", "size"]));
  }
});
var Nb = $e(Sb);
var Mb = defineComponent({
  name: "KFilterForm",
  __name: "filter_form",
  props: {
    items: { default: () => [] },
    size: {},
    collapse: { type: Boolean, default: true },
    reserve: { type: Boolean, default: false },
    visible: { type: Boolean, default: false },
    showColon: { type: Boolean }
  },
  emits: ["search", "reset", "change"],
  setup(e16, { expose: t10, emit: n }) {
    const o = ["base", "sm"], r = inject("_styleModule", ""), a = e16, i = kt(a), s = n, l = ref({});
    let c = {};
    const u = ref(), d = ref(), m = ref(), p = ref(), f = ref(a.collapse), h10 = ref(1), g = ref(1), v = ref("");
    onMounted(() => {
      if (!a.collapse) {
        w();
        return;
      }
      I(), p == null || p.value.style.setProperty("--transition-duration", "0.3s"), p == null || p.value.classList.remove("is-expand"), m == null || m.value.classList.remove("is-expand");
    }), window.addEventListener("resize", I), onUnmounted(() => {
      window.removeEventListener("resize", I);
    });
    const y = computed(() => (N = {}) => {
      const { size: j } = N;
      return j && o.includes(j) ? j : i.value.ownSize;
    }), k = computed(() => (N) => {
      let j = N.visible ?? true;
      if (typeof j == "function" && (j = j(l.value)), j === false && N.prop && !a.reserve) {
        const z = a.items.find((A) => A.prop === N.prop);
        l.value[N.prop] = z == null ? void 0 : z.value;
      }
      return j;
    });
    watch(
      () => a.items,
      () => {
        c = {};
      }
    ), watch(
      () => a.items,
      () => {
        var N;
        (N = a.items) == null || N.forEach((j) => {
          const { prop: z, value: A } = j;
          A !== c[z] && (l.value[z] = A, c[z] = A);
        });
      },
      { deep: true, immediate: true }
    ), watch(
      () => l.value,
      (N) => {
        s("change", N), setTimeout(() => {
          var B, D;
          const j = m.value.offsetTop;
          u == null || u.value.style.setProperty("--top-new", `${j}px`);
          const z = ((B = d.value) == null ? void 0 : B.$el.clientHeight) ?? 0;
          p == null || p.value.style.setProperty("--expandHeight", `${z}px`);
          const A = getComputedStyle((D = d == null ? void 0 : d.value) == null ? void 0 : D.$el).gridTemplateRows.split(" ");
          v.value = A[0], g.value = A.length;
        }, 100);
      },
      { deep: true }
    );
    function T() {
      u == null || u.value.classList.toggle("is-expand"), m == null || m.value.classList.toggle("is-expand"), p == null || p.value.classList.toggle("is-expand"), f.value = !f.value;
      const N = m.value.offsetTop;
      u == null || u.value.style.setProperty("--top-new", `${N}px`), setTimeout(() => {
        var A;
        const j = ((A = d.value) == null ? void 0 : A.$el.clientHeight) ?? 0;
        p == null || p.value.style.setProperty("--expandHeight", `${j}px`);
        const z = m.value.offsetTop;
        u == null || u.value.style.setProperty("--top-new", `${z}px`);
      }, 1);
    }
    function w() {
      u == null || u.value.classList.add("is-expand"), d == null || d.value.$el.classList.add("is-expand"), f.value = false;
    }
    function _() {
      u == null || u.value.classList.remove("is-expand"), d == null || d.value.$el.classList.remove("is-expand"), f.value = true;
    }
    function M() {
      s("search", l.value);
    }
    function x() {
      a.items.forEach((N) => {
        l.value[N.prop] = N.value;
      }), d.value.resetFields(), s("reset");
    }
    function R() {
      return l.value;
    }
    function I() {
      var z, A;
      if (!((z = d == null ? void 0 : d.value) != null && z.$el)) return;
      let N = 1;
      const j = getComputedStyle((A = d == null ? void 0 : d.value) == null ? void 0 : A.$el).gridTemplateColumns.split(" ");
      for (let B = 1; B < j.length; B++) {
        if (Math.abs(parseInt(j[B]) - parseInt(j[B - 1])) > 2) {
          h10.value = N;
          break;
        }
        N++;
      }
      h10.value = N, setTimeout(() => {
        P();
      }, 1);
    }
    function P() {
      var B, D;
      const N = ((B = d.value) == null ? void 0 : B.$el.clientHeight) ?? 0, j = m.value.offsetTop, z = getComputedStyle((D = d == null ? void 0 : d.value) == null ? void 0 : D.$el).gridTemplateRows.split(" "), A = z[0];
      g.value = z.length, p == null || p.value.style.setProperty("--expandHeight", `${N}px`), p == null || p.value.style.setProperty("--transition-duration", "0.3s"), u == null || u.value.style.setProperty("--top-new", `${j}px`), p == null || p.value.style.setProperty("--firstRowHeight", `${A}`);
    }
    return t10(Ae({ reset: x, getFormData: R, search: M, toggle: T, expand: w, collapse: _ }, d)), (N, j) => (openBlock(), createElementBlock("div", {
      ref_key: "filterForm",
      ref: p,
      class: "filterForm is-expand"
    }, [
      createVNode(unref(r1), {
        ref_key: "KFormRef",
        ref: d,
        class: normalizeClass(["filtr-items w-full relative grid grid-cols-1 2xs:grid-cols-2 xs:grid-cols-2 sm:grid-cols-3 base:grid-cols-4 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6", ["k-form", unref(r)]]),
        model: l.value,
        size: N.size,
        "show-colon": N.showColon
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(N.items, (z) => (openBlock(), createElementBlock(Fragment, {
            key: z.prop
          }, [
            k.value(z) ? (openBlock(), createBlock(unref(i1), mergeProps({
              key: z.prop,
              ref_for: true
            }, z, {
              style: `grid-column: span ${z.column === void 0 ? 1 : z.column < h10.value ? z.column : h10.value}`,
              class: "grid-auto-rows:max-content;"
            }), {
              default: withCtx(() => [
                renderSlot(N.$slots, z.prop, { formData: l.value }, () => {
                  var A, B;
                  return [
                    typeof z.render == "function" ? (openBlock(), createBlock(resolveDynamicComponent(z.render(l.value)), { key: 0 })) : z.type === "select" ? (openBlock(), createBlock(unref(Go), mergeProps({
                      key: 1,
                      modelValue: l.value[z.prop],
                      "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                      ref_for: true
                    }, z.attrs, {
                      size: y.value(z.attrs),
                      placeholder: ((A = z.attrs) == null ? void 0 : A.placeholder) ?? N.$t("pleaseSelect")
                    }), {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(z.options, (D) => (openBlock(), createBlock(unref(vo), mergeProps({ ref_for: true }, D, { key: D }), null, 16))), 128))
                      ]),
                      _: 2
                    }, 1040, ["modelValue", "onUpdate:modelValue", "size", "placeholder"])) : z.type === "radio" ? (openBlock(), createBlock(unref($f), mergeProps({
                      key: 2,
                      modelValue: l.value[z.prop],
                      "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                      ref_for: true
                    }, z.attrs, {
                      size: y.value(z.attrs)
                    }), {
                      default: withCtx(() => [
                        (openBlock(true), createElementBlock(Fragment, null, renderList(z.options, (D) => (openBlock(), createBlock(unref(Mf), mergeProps({ ref_for: true }, D, { key: D }), null, 16))), 128))
                      ]),
                      _: 2
                    }, 1040, ["modelValue", "onUpdate:modelValue", "size"])) : z.type === "checkbox" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
                      Array.isArray(z.value) ? (openBlock(), createBlock(unref(If), mergeProps({
                        key: 0,
                        modelValue: l.value[z.prop],
                        "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                        ref_for: true
                      }, z.attrs, {
                        size: y.value(z.attrs)
                      }), {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(z.options, (D) => (openBlock(), createBlock(unref(fa), mergeProps({ ref_for: true }, D, {
                            key: D,
                            size: y.value(z.attrs)
                          }), null, 16, ["size"]))), 128))
                        ]),
                        _: 2
                      }, 1040, ["modelValue", "onUpdate:modelValue", "size"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(z.options, (D) => (openBlock(), createBlock(unref(fa), mergeProps({ ref_for: true }, D, {
                        key: D,
                        modelValue: l.value[z.prop],
                        "onUpdate:modelValue": (te) => l.value[z.prop] = te,
                        size: y.value(z.attrs)
                      }), null, 16, ["modelValue", "onUpdate:modelValue", "size"]))), 128))
                    ], 64)) : z.type === "date" ? (openBlock(), createBlock(unref(Ff), mergeProps({
                      key: 4,
                      modelValue: l.value[z.prop],
                      "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                      ref_for: true
                    }, z.attrs, {
                      size: y.value(z.attrs)
                    }), null, 16, ["modelValue", "onUpdate:modelValue", "size"])) : (openBlock(), createElementBlock(Fragment, { key: 5 }, [
                      k.value(z) ? (openBlock(), createBlock(unref(ro), mergeProps({
                        key: 0,
                        modelValue: l.value[z.prop],
                        "onUpdate:modelValue": (D) => l.value[z.prop] = D,
                        ref_for: true
                      }, z.attrs, {
                        placeholder: ((B = z.attrs) == null ? void 0 : B.placeholder) ?? N.$t("pleaseInput"),
                        size: y.value(z.attrs)
                      }), null, 16, ["modelValue", "onUpdate:modelValue", "placeholder", "size"])) : createCommentVNode("", true)
                    ], 64))
                  ];
                }, true)
              ]),
              _: 2
            }, 1040, ["style"])) : createCommentVNode("", true)
          ], 64))), 128)),
          createBaseVNode("div", {
            ref_key: "markers",
            ref: m,
            class: "markers flex w-full h-8 is-expand",
            style: normalizeStyle(`grid-column: ${h10.value} / ${h10.value + 1}; `)
          }, null, 4),
          createBaseVNode("div", {
            ref_key: "filterBtn",
            ref: u,
            class: "filtr-btns flex bg-white"
          }, [
            renderSlot(N.$slots, "action", {}, () => [
              createVNode(unref(Lt), {
                size: y.value(),
                onClick: x
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(N.$t("reset")), 1)
                ]),
                _: 1
              }, 8, ["size"]),
              createVNode(unref(Lt), {
                size: y.value(),
                main: "",
                onClick: M
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(N.$t("query")), 1)
                ]),
                _: 1
              }, 8, ["size"]),
              withDirectives(createVNode(unref(Lt), {
                text: "",
                "icon-right": f.value ? "IconArrowBottom" : "IconArrowTop",
                onClick: T
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(f.value ? N.$t("expand") : N.$t("collapse")), 1)
                ]),
                _: 1
              }, 8, ["icon-right"]), [
                [vShow, g.value > 1]
              ])
            ], true)
          ], 512)
        ]),
        _: 3
      }, 8, ["model", "size", "class", "show-colon"])
    ], 512));
  }
});
var $b = Ta(Mb, [["__scopeId", "data-v-4f868e9a"]]);
var xb = $e($b);
var Ib = defineComponent({
  name: "TabLabel",
  props: {
    tabs: {
      type: Array,
      default: () => []
    }
  },
  setup(e16, {
    slots: t10,
    attrs: n
  }) {
    return () => createVNode(Fragment, null, [createVNode(ar, mergeProps(n, {
      disabled: e16.tabs.length === 0
    }), {
      default: () => [e16.tabs.map((o) => createVNode(rr, {
        key: o,
        disabled: o.disabled
      }, {
        default: () => [typeof (o == null ? void 0 : o.label) == "function" ? o.label() : o.label]
      }))],
      ...t10
    })]);
  }
});
var Db = { class: "k-button-more-trigger" };
var Ab = defineComponent({
  name: "KButtonContainer",
  __name: "button_container",
  props: {
    trigger: { default: "click" },
    maxHeight: { default: 300 },
    placement: { default: "bottom" },
    hideOnClick: { type: Boolean, default: true },
    showTimeout: {},
    hideTimeout: {},
    popperClass: {},
    teleported: { type: Boolean, default: true },
    triggerIcon: { default: "IconMore" }
  },
  setup(e16) {
    var h10;
    const t10 = inject("__elementObserver"), n = inject("_styleModule", ""), o = e16, r = useSlots(), a = ref(), i = ref(), s = m(jr((h10 = r.default) == null ? void 0 : h10.call(r))), l = ref([]);
    let c;
    const u = `_${Dt(8)}`;
    onMounted(() => {
      var g;
      c = (g = a.value) == null ? void 0 : g.querySelectorAll(".k-button"), i.value.setAttribute("data-observer-key", u), f(), t10.observe(i.value, f);
    }), onBeforeUnmount(() => {
      var g;
      i.value && ((g = t10 == null ? void 0 : t10.unobserve) == null || g.call(t10, i.value));
    });
    const d = kt(o);
    watch(() => d.value, () => {
      nextTick(() => {
        f();
      });
    }, { deep: true });
    function m(g) {
      return g.map((v) => {
        if (Cd(v)) {
          const y = { ...v.props || {} };
          for (const [T, w] of Object.entries(y))
            delete y[T], y[Td(T)] = w;
          return {
            label: (v.children || {}).default,
            disabled: !!y.disabled
          };
        }
        return null;
      }).filter((v) => v !== null);
    }
    function p(g) {
      var k;
      const v = g.getBoundingClientRect(), y = (k = a.value) == null ? void 0 : k.getBoundingClientRect();
      return y ? v.left >= y.left && v.right <= y.right : true;
    }
    function f() {
      const g = [];
      if (!s)
        return [];
      c == null || c.forEach((v, y) => {
        !p(v) && s[y] ? (v.style.opacity = "0", g.push(s[y])) : v.style.opacity = "1";
      }), l.value = g;
    }
    return (g, v) => (openBlock(), createElementBlock("div", {
      ref_key: "box",
      ref: i,
      class: normalizeClass(["k-button-container", unref(n)])
    }, [
      createBaseVNode("div", {
        ref_key: "container",
        ref: a,
        class: "container"
      }, [
        renderSlot(g.$slots, "default")
      ], 512),
      createBaseVNode("div", {
        class: "k-button-more",
        style: normalizeStyle({
          opacity: l.value.length > 0 ? 1 : 0
        })
      }, [
        createVNode(unref(Ib), mergeProps({
          tabs: l.value,
          trigger: g.trigger,
          "max-height": g.maxHeight,
          placement: g.placement,
          "hide-on-click": g.hideOnClick,
          teleported: g.teleported,
          "show-timeout": g.showTimeout,
          "hide-timeout": g.hideTimeout,
          "popper-class": g.popperClass
        }, g.$attrs), {
          title: withCtx(() => [
            createBaseVNode("span", Db, [
              renderSlot(g.$slots, "trigger", {}, () => [
                (openBlock(), createBlock(resolveDynamicComponent(o.triggerIcon)))
              ])
            ])
          ]),
          _: 3
        }, 16, ["tabs", "trigger", "max-height", "placement", "hide-on-click", "teleported", "show-timeout", "hide-timeout", "popper-class"])
      ], 4)
    ], 2));
  }
});
var Eb = $e(Ab);
var Kb = ["onClick"];
var zb = defineComponent({
  name: "KSliderButton",
  __name: "sliderButton",
  props: {
    items: { default: () => [] },
    active: {}
  },
  emits: ["change"],
  setup(e16, { emit: t10 }) {
    const n = e16, o = t10, r = ref(n.active ?? n.items[0].name), a = ref();
    window.addEventListener("resize", i), onMounted(() => {
      i();
    });
    function i() {
      var m, p, f;
      const l = document.querySelector(".k-slider-button-pane.is-active"), { width: c } = (l == null ? void 0 : l.getBoundingClientRect()) || { width: 0, height: 0 }, u = (l == null ? void 0 : l.offsetTop) || 0, d = (l == null ? void 0 : l.offsetLeft) || 0;
      (m = a == null ? void 0 : a.value) == null || m.style.setProperty("--item-top", `${u}px`), (p = a == null ? void 0 : a.value) == null || p.style.setProperty("--item-left", `${d}px`), (f = a == null ? void 0 : a.value) == null || f.style.setProperty("--item-width", `${c}px`);
    }
    function s(l) {
      r.value !== l.name && (r.value = l.name, nextTick(() => {
        i(), o("change", l.name);
      }));
    }
    return (l, c) => (openBlock(), createElementBlock("div", {
      ref_key: "sliderButton",
      ref: a,
      class: "k-slider-button p-1 rounded-lg flex w-full bg-gray-100"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(n.items, (u) => (openBlock(), createElementBlock("div", {
        class: normalizeClass([{ "is-active": r.value === u.name }, "k-slider-button-pane w-full rounded flex justify-center items-center text-center text-gray-500 cursor-pointer relative"]),
        onClick: (d) => s(u)
      }, toDisplayString(u.label), 11, Kb))), 256))
    ], 512));
  }
});
var Pb = $e(zb);
var Rb = { class: "k-script-input-prepend" };
var Lb = { class: "k-script-input-append" };
var Fb = defineComponent({
  name: "KScriptInput",
  __name: "script_input",
  props: {
    modelValue: {},
    size: { default: "base" },
    placeholder: {},
    disabled: { type: Boolean },
    options: { default: () => [] },
    useTree: { type: Boolean, default: false },
    showPopperSwitch: { type: Boolean, default: true },
    showModeSwitch: { type: Boolean, default: true },
    defaultMode: { default: "string" },
    height: {},
    treeConfig: {}
  },
  emits: ["change", "input", "focus", "blur", "select", "update:modelValue"],
  setup(e16, { expose: t10, emit: n }) {
    const o = inject("_styleModule", ""), r = inject("__diffMatchPatch"), a = e16, i = {
      parentField: "pid",
      rowField: "value",
      expandAll: false
    }, s = n;
    onMounted(() => {
      document.addEventListener("keydown", le), document.addEventListener("click", Pe), hn();
    }), onBeforeUnmount(() => {
      document.removeEventListener("keydown", le), document.removeEventListener("click", Pe);
    });
    const l = `_${Dt(8)}`, c = [{ field: "label", label: "", treeNode: true }], u = ref(), d = ref(), m = ref(), p = ref(a.defaultMode === "string");
    let f = "", h10 = "";
    const g = ref(""), v = ref(0);
    let y = false;
    const k = ref(false), T = ref(true);
    let w = false;
    const _ = ref(false), M = ref(false), x = ref(0), R = /fx\((.*?)\)/, I = /* @__PURE__ */ new Set();
    window.addEventListener("resize", hn), onUnmounted(() => {
      window.removeEventListener("resize", hn);
    });
    const P = computed(() => {
      if (a.useTree)
        return Object.assign(i, a.treeConfig || {});
    }), F = computed(() => {
      var ae;
      const ne = ((ae = d.value) == null ? void 0 : ae.getTableData().fullData) ?? [];
      return bd(ne, "children") ?? [];
    });
    watch(
      () => g.value,
      () => {
        var ne, ae, he;
        if (g.value === "" && !y) {
          k.value = false;
          return;
        }
        (ne = d.value) == null || ne.filter(g.value), (he = (ae = d.value) == null ? void 0 : ae.getVisibleData()) != null && he.length ? k.value = true : k.value = false;
      },
      { immediate: true }
    ), watch(
      () => [a.modelValue, a.options],
      () => {
        const ne = typeof a.modelValue;
        if (ne !== "string" && ne !== "number" || a.modelValue === void 0) {
          console.warn(`'modelValue' must be a string or number, but got ${ne}`);
          return;
        }
        a.modelValue !== h10 && nextTick(() => {
          const ae = E(a.modelValue.toString());
          z(ae), h10 = a.modelValue.toString(), f = j(), A = f, Te();
        });
      },
      { immediate: true, deep: true }
    );
    function N(ne) {
      h10 = ne, s("update:modelValue", ne);
    }
    function j() {
      return cn(u.value.innerHTML);
    }
    function z(ne) {
      u.value.innerHTML = ne;
    }
    let A = "";
    function B(ne) {
      if (!(ne.target instanceof HTMLElement) || !T.value)
        return;
      ne.data === " " ? g.value = "" : ne.data === null && g.value.length ? g.value = g.value.slice(0, -1) : ne.data !== null && (g.value += ne.data ?? ""), f = A, A = j();
      const { result: ae = "" } = se();
      N(ae);
    }
    function D() {
      _.value = true, w = true, s("focus");
    }
    function te(ne) {
      if (!(ne.target instanceof HTMLElement))
        return;
      const ae = de(`.${l}`);
      ae && !ae.contains(ne.relatedTarget) && (w = false, s("blur"), s("change", se()), _.value = false, k.value = false);
    }
    function ie({ row: ne }) {
      var he;
      if (ne.optional === false)
        return;
      const ae = F.value.findIndex((xe) => xe.value === ne.value);
      v.value = ae, !((he = ne.children) != null && he.length) && U(ne);
    }
    function U(ne) {
      const { value: ae, key: he } = oe(ne);
      g.value = "", z(ae), f = j(), A = f, Te(he), s("select", ne), k.value = false, nextTick(() => {
        const xe = se();
        N((xe == null ? void 0 : xe.result) ?? ""), s("change", xe);
      });
    }
    function oe(ne) {
      const ae = Dt(8), he = p.value ? V(ne.label, ae) : ne.value;
      if (y)
        return {
          value: j() + he,
          key: ae
        };
      const xe = r.diff_main(f, j());
      let Ee = "";
      const Ve = xe.find((Ze) => Ze[0] === 0), Je = (Ve == null ? void 0 : Ve[1]) ?? "", [Ie, Nt] = xe.find(
        (Ze) => Ze[0] !== 0
      ) ?? [-2, ""];
      Ie === 1 ? Ee = (Je + Nt).slice(0, -g.value.length) : Ie === -1 ? Ee = Je.slice(0, -g.value.length) : Ee = Je;
      let bt = "";
      return Ve ? (Ve[1] = `${Ee}${he}`, bt = xe.filter((Ze) => Ze[0] === 0).map((Ze) => Ze[1]).join("")) : bt = he, {
        value: bt,
        key: ae
      };
    }
    function se() {
      if (!Be())
        return {
          result: j(),
          scriptTags: []
        };
      let ne = "";
      const ae = [], he = (Ee) => {
        if (!Ee)
          return;
        const Ve = Ee.childNodes;
        for (let Je = 0; Je < Ve.length; Je++) {
          const Ie = Ve[Je];
          if (Ie.nodeType === 3)
            ne += Ie.textContent ?? "";
          else if (Ie.tagName.toUpperCase() === "DIV" && Ie.classList.contains("k-script-tag")) {
            const Nt = Ie.innerText;
            if (I.has(Nt))
              ne += `fx(${Nt})`, ae.push(null);
            else {
              const bt = a.options.find((Ze) => Ze.label === Nt);
              ne += `fx(${(bt == null ? void 0 : bt.value) ?? null})`, ae.push(bt ?? null);
            }
          } else Ie.tagName.toUpperCase() === "DIV" && he(Ie);
        }
      };
      he(u.value), ne = ne.split(" ").filter((Ee) => Ee !== "").join(" ");
      const xe = K(ne);
      return s("input", xe), {
        result: xe,
        scriptTags: ae
      };
    }
    function E(ne) {
      I.clear();
      let ae = ne.replace(/''/g, "'");
      if (!Be())
        return ae;
      for (ae = ee(ae); R.test(ae); ) {
        const he = ae.match(R);
        if ((he == null ? void 0 : he[0]) === void 0 || (he == null ? void 0 : he[1]) === void 0)
          break;
        const xe = he[1], Ee = a.options.find((Nt) => Nt.value === xe);
        let Ve = (Ee == null ? void 0 : Ee.label) ?? "", Je = false;
        Ee || (Ve = xe, Bf.error(`'${xe}' not found`), I.add(Ve), Je = true);
        const Ie = Dt(8);
        ae = ae.replace(he == null ? void 0 : he[0], V(Ve, Ie, Je));
      }
      return ae;
    }
    function K(ne) {
      var xe, Ee;
      const ae = /fx\((.*?)\)/;
      if (ne = ne.replace(/'/g, "''"), !p.value)
        return ne;
      let he = "";
      for (; ae.test(ne); ) {
        const Ve = ((xe = ne.match(ae)) == null ? void 0 : xe[0]) ?? "", Je = ne.indexOf(Ve), Ie = ne.slice(0, Je);
        (Ee = Ie == null ? void 0 : Ie.trim()) != null && Ee.length && (he += ` '${Ie == null ? void 0 : Ie.trim()}' `), he += ` ${Ve} `, ne = ne.slice(Je + Ve.length);
      }
      return ne != null && ne.length && (he += `'${ne}'`), he.trim();
    }
    function ee(ne) {
      const ae = ne.split("''");
      return ae.forEach((he, xe) => {
        ae[xe] = he.replace(/'/g, "");
      }), ae.join("'");
    }
    function V(ne, ae, he = false) {
      return `<div class="k-script-tag ${he ? "is-error" : ""}" data-key="${ae}"  contenteditable="false">${ne}</div>`;
    }
    function le(ne) {
      var Ve, Je, Ie;
      const ae = F.value.length, he = de(`.${l} .el-input__inner`);
      if (ne.code === "ArrowUp")
        for (he == null || he.blur(), v.value = (v.value - 1 + ae) % ae; pe(F.value[v.value]) || F.value[v.value].optional === false; )
          v.value = (v.value - 1 + ae) % ae;
      else if (ne.code === "ArrowDown")
        for (he == null || he.blur(), v.value = (v.value + 1) % ae; pe(F.value[v.value]) || F.value[v.value].optional === false; )
          v.value = (v.value + 1) % ae;
      const xe = F.value[v.value], Ee = (Ve = d.value) == null ? void 0 : Ve.getRowById(xe == null ? void 0 : xe.value);
      Ee && d.value.setCurrentRow(Ee), ne.code === "Enter" && k.value && document.activeElement !== he ? (ne.preventDefault(), a.useTree && Ee && ((Je = Ee.children) != null && Je.length) && !Ee.optional ? (Ie = d.value) == null || Ie.toggleTreeExpand(Ee) : U(xe)) : ne.code === "Enter" && (g.value = "");
    }
    function pe(ne) {
      var he, xe;
      const ae = (he = d.value) == null ? void 0 : he.getRowById(ne == null ? void 0 : ne.pid);
      return ae ? !!(!((xe = d.value) != null && xe.isTreeExpandByRow(ae)) && ne.pid) : false;
    }
    function Te(ne) {
      if (!w || window.getSelection === void 0)
        return;
      const ae = window.getSelection();
      if (ne === void 0)
        u.value.focus(), ae == null || ae.selectAllChildren(u.value), ae == null || ae.collapseToEnd();
      else {
        const he = document.createRange();
        he.selectNodeContents(u.value);
        const { node: xe, offset: Ee } = Z(ne);
        he.setStart(xe, Ee), he.collapse(true), ae == null || ae.removeAllRanges(), ae == null || ae.addRange(he);
      }
    }
    function Z(ne) {
      if (!ne)
        return { node: u.value, offset: 0 };
      let ae = false;
      const he = {
        node: u.value,
        offset: 0
      }, xe = (Ee) => {
        var Je, Ie, Nt;
        if (ae)
          return;
        const Ve = Ee.childNodes;
        for (let bt = 0; bt < Ve.length && !ae; bt++) {
          const Ze = Ve[bt];
          if (Ze.parentNode !== he.node && (he.node = Ze.parentNode, he.offset = bt), he.offset++, ((Je = Ze == null ? void 0 : Ze.getAttribute) == null ? void 0 : Je.call(Ze, "data-key")) === ne) {
            ae = true;
            break;
          }
          Ze.nodeType !== 3 && ((Ie = Ze == null ? void 0 : Ze.tagName) == null ? void 0 : Ie.toUpperCase()) === "DIV" && !((Nt = Ze == null ? void 0 : Ze.classList) != null && Nt.contains("k-script-tag")) && (he.node = Ze, he.offset = 0, xe(Ze));
        }
      };
      return xe(u.value), he;
    }
    function X() {
      var he, xe, Ee;
      const ne = (xe = (he = F.value) == null ? void 0 : he[0]) == null ? void 0 : xe.value, ae = (Ee = d.value) == null ? void 0 : Ee.getRowById(ne);
      ae && d.value.setCurrentRow(ae);
    }
    function Q() {
      var ne, ae;
      v.value = 0, (ne = d.value) == null || ne.setCurrentRow(null), (ae = d.value) == null || ae.clearTreeExpand(), M.value = false, y && (y = false);
    }
    function W() {
      k.value || (g.value = "", M.value = true, k.value = true, _.value = true, setTimeout(() => {
        y = true;
      }), nextTick(() => {
        const ne = de(`.${l} .el-input__inner`);
        ne == null || ne.focus();
      }));
    }
    function de(ne) {
      return document.querySelector(ne);
    }
    function Ne() {
      k.value = false, _.value = false, Q();
    }
    function Pe(ne) {
      var he;
      const ae = de(`.${l}`);
      !y || (he = ae == null ? void 0 : ae.contains) != null && he.call(ae, ne.target) || Ne();
    }
    function tt() {
      z(""), f = "", g.value = "";
    }
    function Qe() {
      St(), p.value = !p.value, pn();
    }
    function lt(ne) {
      Be() !== ne && (St(), p.value = ne, pn());
    }
    function Be() {
      return p.value;
    }
    const Xe = {
      expression: "",
      string: ""
    }, it = {
      expression: "",
      string: ""
    };
    function St() {
      const ne = Be() ? "string" : "expression";
      it[ne] = j();
    }
    function pn() {
      tt();
      const ne = Be() ? "string" : "expression";
      z(Xe[ne]);
      const ae = se();
      h10 = (ae == null ? void 0 : ae.result) ?? "", Xe.expression = it.expression, Xe.string = it.string, s("update:modelValue", (ae == null ? void 0 : ae.result) ?? ""), s("change", ae);
    }
    function hn() {
      nextTick(() => {
        var ne;
        x.value = ((ne = m.value) == null ? void 0 : ne.offsetWidth) ?? 0;
      });
    }
    function cn(ne) {
      return ne.replace(/&nbsp;/g, " ");
    }
    return t10({
      clear: tt,
      showPopper: W,
      hidePopper: Ne,
      toggleMode: Qe,
      setStringMode: lt,
      isStringMode: Be
    }), (ne, ae) => {
      const he = resolveComponent("k-button"), xe = resolveComponent("k-tree-table"), Ee = resolveComponent("el-scrollbar"), Ve = resolveComponent("k-popover"), Je = resolveComponent("IconVariable");
      return openBlock(), createElementBlock("div", {
        ref_key: "KScriptInputWrapper",
        ref: m,
        class: "k-script-input-wrapper"
      }, [
        createBaseVNode("div", Rb, [
          ne.showModeSwitch ? (openBlock(), createBlock(he, {
            key: 0,
            onClick: Qe
          }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(p.value ? "IconModeExpression" : "IconModeExpressionColor"), { color: "var(--k-gray-400)" }))
            ]),
            _: 1
          })) : createCommentVNode("", true),
          renderSlot(ne.$slots, "prepend")
        ]),
        createVNode(Ve, {
          width: x.value,
          "show-arrow": false,
          visible: k.value,
          "popper-class": `k-script-input-popper ${l}`,
          onShow: X,
          onHide: Q,
          class: "overflow-hidden"
        }, {
          reference: withCtx(() => [
            createBaseVNode("div", {
              ref_key: "KScriptInput",
              ref: u,
              class: normalizeClass(["k-script-input", unref(o)]),
              style: normalizeStyle({
                height: ne.height
              }),
              contenteditable: "",
              spellcheck: false,
              onInput: B,
              onBlur: te,
              onFocus: D,
              onCompositionstart: ae[0] || (ae[0] = () => {
                T.value = false;
              }),
              onCompositionend: ae[1] || (ae[1] = (Ie) => {
                T.value = true, B(Ie);
              })
            }, null, 38)
          ]),
          default: withCtx(() => [
            createBaseVNode("div", null, [
              createVNode(Ee, null, {
                default: withCtx(() => [
                  _.value ? (openBlock(), createBlock(xe, {
                    key: 0,
                    id: "k-script-input-tree",
                    class: "mytable-scrollbar",
                    ref_key: "$tree",
                    ref: d,
                    border: "none",
                    height: "320px",
                    "use-tree": ne.useTree,
                    column: c,
                    data: ne.options,
                    "show-search-input": M.value,
                    "show-filter": false,
                    "show-header": false,
                    "show-page": false,
                    "show-header-tools": M.value,
                    "cell-click-toggle-highlight": false,
                    "show-description": false,
                    "show-refresh": false,
                    "row-config": {
                      keyField: "value",
                      isCurrent: true,
                      currentMethod: ({ row: Ie }) => Ie.optional !== false
                    },
                    "row-class-name": ({ row: Ie }) => {
                      var Nt;
                      return Ie.optional === false && !((Nt = Ie.children) != null && Nt.length) ? "k-script-input-tree-disabled" : "";
                    },
                    "tree-config": P.value,
                    "highlight-current": "",
                    adaptive: "",
                    onCellClick: ie
                  }, null, 8, ["use-tree", "data", "show-search-input", "show-header-tools", "row-config", "row-class-name", "tree-config"])) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ])
          ]),
          _: 1
        }, 8, ["width", "visible", "popper-class"]),
        createBaseVNode("div", Lb, [
          renderSlot(ne.$slots, "append"),
          ne.showPopperSwitch ? (openBlock(), createBlock(he, {
            key: 0,
            onClick: W
          }, {
            default: withCtx(() => [
              createVNode(Je)
            ]),
            _: 1
          })) : createCommentVNode("", true)
        ])
      ], 512);
    };
  }
});
var jb = $e(Fb);
var Ou = [
  {
    id: 0,
    name: "add",
    componentName: "IconAdd",
    title: "添加",
    category: "Character",
    categoryCN: "符号标识",
    author: "KSW",
    tag: ["新建", "增加", "创建"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 1,
    name: "aom-menu-AOMRZ-color",
    componentName: "IconAomMenuAOMRZColor",
    title: "AOM日志",
    category: "AOM Menu",
    categoryCN: "AOM 菜单",
    author: "KSW",
    tag: ["AOM", "日志"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 2,
    name: "aom-menu-BBCX-color",
    componentName: "IconAomMenuBBCXColor",
    title: "报表查询",
    category: "AOM Menu",
    categoryCN: "AOM 菜单",
    author: "KSW",
    tag: ["AOM", "报表"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 3,
    name: "aom-menu-BBSH-color",
    componentName: "IconAomMenuBBSHColor",
    title: "菜单按钮颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "按钮", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 4,
    name: "aom-menu-BBSJ-color",
    componentName: "IconAomMenuBBSJColor",
    title: "菜单",
    category: "Menu",
    categoryCN: "菜单",
    author: "KSW",
    tag: ["菜单", "论坛", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 5,
    name: "aom-menu-BBYL-color",
    componentName: "IconAomMenuBBYLColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 6,
    name: "aom-menu-BCLLPZ-color",
    componentName: "IconAomMenuBCLLPZColor",
    title: "菜单图标",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "导航", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 7,
    name: "aom-menu-BCZXKanban-color",
    componentName: "IconAomMenuBCZXKanbanColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 8,
    name: "aom-menu-BDCK-color",
    componentName: "IconAomMenuBDCKColor",
    title: "菜单工具颜色",
    category: "Tools",
    categoryCN: "工具",
    author: "KSW",
    tag: ["菜单", "工具", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 9,
    name: "aom-menu-BDGL-color",
    componentName: "IconAomMenuBDGLColor",
    title: "菜单选项颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "选项", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 10,
    name: "aom-menu-BDKanban-color",
    componentName: "IconAomMenuBDKanbanColor",
    title: "自动化菜单",
    category: "Automation",
    categoryCN: "自动化工具",
    author: "KSW",
    tag: ["自动化", "菜单", "看板", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 11,
    name: "aom-menu-CJCL-color",
    componentName: "IconAomMenuCJCLColor",
    title: "菜单颜色选择器",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "颜色", "选择器"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 12,
    name: "aom-menu-CKGL-color",
    componentName: "IconAomMenuCKGLColor",
    title: "代码菜单",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["代码", "菜单", "颜色", "开发", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 13,
    name: "aom-menu-CLJL-color",
    componentName: "IconAomMenuCLJLColor",
    title: "菜单列表颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "列表", "颜色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 14,
    name: "aom-menu-CZRZ-color",
    componentName: "IconAomMenuCZRZColor",
    title: "菜单颜色设置",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["菜单", "颜色", "设置", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 15,
    name: "aom-menu-default-color",
    componentName: "IconAomMenuDefaultColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 16,
    name: "aom-menu-DLDGL-color",
    componentName: "IconAomMenuDLDGLColor",
    title: "菜单选项颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 17,
    name: "aom-menu-DLDSJ-color",
    componentName: "IconAomMenuDLDSJColor",
    title: "自动化菜单",
    category: "Automation",
    categoryCN: "自动化工具",
    author: "KSW",
    tag: ["自动化", "菜单", "动态数据监控", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 18,
    name: "aom-menu-DLDXC-color",
    componentName: "IconAomMenuDLDXCColor",
    title: "菜单选项颜色",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["菜单", "选项", "颜色", "界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 19,
    name: "aom-menu-DLDXX-color",
    componentName: "IconAomMenuDLDXXColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单图标",
    author: "KSW",
    tag: ["菜单", "颜色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 20,
    name: "aom-menu-DLDXZ-color",
    componentName: "IconAomMenuDLDXZColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 21,
    name: "aom-menu-DPGL-color",
    componentName: "IconAomMenuDPGLColor",
    title: "大屏管理",
    category: "AOM Menu",
    categoryCN: "AOM 菜单",
    author: "KSW",
    tag: ["AOM", "大屏", "管理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 22,
    name: "aom-menu-DPYL-color",
    componentName: "IconAomMenuDPYLColor",
    title: "大屏预览",
    category: "AOM Menu",
    categoryCN: "AOM 菜单",
    author: "KSW",
    tag: ["AOM", "大屏", "预览", "演示"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 23,
    name: "aom-menu-DXSZ-color",
    componentName: "IconAomMenuDXSZColor",
    title: "菜单设置颜色",
    category: "Menu",
    categoryCN: "菜单配置",
    author: "KSW",
    tag: ["菜单", "设置", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 24,
    name: "aom-menu-DYGX-color",
    componentName: "IconAomMenuDYGXColor",
    title: "菜单选项",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["菜单", "选项", "导航", "界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 25,
    name: "aom-menu-FFQDJ-color",
    componentName: "IconAomMenuFFQDJColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单图标",
    author: "KSW",
    tag: ["菜单", "颜色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 26,
    name: "aom-menu-FFQSL-color",
    componentName: "IconAomMenuFFQSLColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 27,
    name: "aom-menu-FPGL-color",
    componentName: "IconAomMenuFPGLColor",
    title: "分屏管理",
    category: "AOM Menu",
    categoryCN: "AOM 菜单",
    author: "KSW",
    tag: ["AOM", "大屏", "分屏", "管理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 28,
    name: "aom-menu-FWQPZ-color",
    componentName: "IconAomMenuFWQPZColor",
    title: "自动化菜单配置",
    category: "Automation",
    categoryCN: "自动化工具",
    author: "KSW",
    tag: ["自动化", "菜单", "配置", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 29,
    name: "aom-menu-FWQXX-color",
    componentName: "IconAomMenuFWQXXColor",
    title: "服务器菜单",
    category: "Server",
    categoryCN: "服务器管理",
    author: "KSW",
    tag: ["服务器", "菜单", "管理", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 30,
    name: "aom-menu-GLST-color",
    componentName: "IconAomMenuGLSTColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 31,
    name: "aom-menu-GNHS-color",
    componentName: "IconAomMenuGNHSColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单图标",
    author: "KSW",
    tag: ["菜单", "图标", "绿色", "圆形"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 32,
    name: "aom-menu-GRBL-color",
    componentName: "IconAomMenuGRBLColor",
    title: "奥姆菜单GRBL颜色",
    category: "Software",
    categoryCN: "软件工具",
    author: "KSW",
    tag: ["奥姆", "菜单", "GRBL", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 33,
    name: "aom-menu-HSZ-color",
    componentName: "IconAomMenuHSZColor",
    title: "菜单选项",
    category: "Menu",
    categoryCN: "菜单选项",
    author: "KSW",
    tag: ["菜单", "选项", "HSZ颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 34,
    name: "aom-menu-JBGL-color",
    componentName: "IconAomMenuJBGLColor",
    title: "菜单管理",
    category: "Menu",
    categoryCN: "菜单管理",
    author: "KSW",
    tag: ["菜单", "管理", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 35,
    name: "aom-menu-JBKanban-color",
    componentName: "IconAomMenuJBKanbanColor",
    title: "AOM菜单",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "看板", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 36,
    name: "aom-menu-JBRZ-color",
    componentName: "IconAomMenuJBRZColor",
    title: "菜单选项",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["菜单", "选项", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 37,
    name: "aom-menu-JBSM-color",
    componentName: "IconAomMenuJBSMColor",
    title: "菜单栏颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "颜色", "界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 38,
    name: "aom-menu-JCYWPTKanban-color",
    componentName: "IconAomMenuJCYWPTKanbanColor",
    title: "菜单",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "看板", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 39,
    name: "aom-menu-JGCL-color",
    componentName: "IconAomMenuJGCLColor",
    title: "菜单颜色选择器",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "颜色", "选择器"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 40,
    name: "aom-menu-JQFA-color",
    componentName: "IconAomMenuJQFAColor",
    title: "菜单颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "颜色", "界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 41,
    name: "aom-menu-JRLC-color",
    componentName: "IconAomMenuJRLCColor",
    title: "菜单选项颜色",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["菜单", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 42,
    name: "aom-menu-JXCX-color",
    componentName: "IconAomMenuJXCXColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T07:40:46.000Z"
  },
  {
    id: 43,
    name: "aom-menu-JXPZ-color",
    componentName: "IconAomMenuJXPZColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T07:40:46.000Z"
  },
  {
    id: 44,
    name: "aom-menu-JXSH-color",
    componentName: "IconAomMenuJXSHColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T07:40:46.000Z"
  },
  {
    id: 45,
    name: "aom-menu-JXYL-color",
    componentName: "IconAomMenuJXYLColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T07:40:46.000Z"
  },
  {
    id: 46,
    name: "aom-menu-KZTGL-color",
    componentName: "IconAomMenuKZTGLColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单工具",
    author: "KSW",
    tag: ["菜单", "管理", "工具", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 47,
    name: "aom-menu-LCCK-color",
    componentName: "IconAomMenuLCCKColor",
    title: "菜单选项颜色",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["菜单", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 48,
    name: "aom-menu-LCJG-color",
    componentName: "IconAomMenuLCJGColor",
    title: "菜单图标",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "导航", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 49,
    name: "aom-menu-LCKanban-color",
    componentName: "IconAomMenuLCKanbanColor",
    title: "菜单",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "看板", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 50,
    name: "aom-menu-LCMB-color",
    componentName: "IconAomMenuLCMBColor",
    title: "菜单图标",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "导航", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 51,
    name: "aom-menu-LCSH-color",
    componentName: "IconAomMenuLCSHColor",
    title: "菜单选项",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["菜单", "选项", "导航"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 52,
    name: "aom-menu-LCST-color",
    componentName: "IconAomMenuLCSTColor",
    title: "菜单图标",
    category: "Menu",
    categoryCN: "菜单",
    author: "KSW",
    tag: ["菜单", "导航", "选项"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 53,
    name: "aom-menu-LYCDL-color",
    componentName: "IconAomMenuLYCDLColor",
    title: "菜单图标",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "导航", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 54,
    name: "aom-menu-MBCS-color",
    componentName: "IconAomMenuMBCSColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 55,
    name: "aom-menu-MBGL-color",
    componentName: "IconAomMenuMBGLColor",
    title: "菜单MBGL颜色",
    category: "Menu",
    categoryCN: "菜单",
    author: "KSW",
    tag: ["菜单", "MBGL", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 56,
    name: "aom-menu-MJRW-color",
    componentName: "IconAomMenuMJRWColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 57,
    name: "aom-menu-QDGL-color",
    componentName: "IconAomMenuQDGLColor",
    title: "质量管理菜单",
    category: "Quality",
    categoryCN: "质量管理",
    author: "KSW",
    tag: ["质量管理", "菜单", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 58,
    name: "aom-menu-QJBL-color",
    componentName: "IconAomMenuQJBLColor",
    title: "菜单图标",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "导航", "界面", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 59,
    name: "aom-menu-QXGL-color",
    componentName: "IconAomMenuQXGLColor",
    title: "菜单",
    category: "Menu",
    categoryCN: "菜单管理",
    author: "KSW",
    tag: ["菜单", "权限管理", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 60,
    name: "aom-menu-RLPZ-color",
    componentName: "IconAomMenuRLPZColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单图标",
    author: "KSW",
    tag: ["菜单", "颜色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 61,
    name: "aom-menu-RWCX-color",
    componentName: "IconAomMenuRWCXColor",
    title: "菜单列表颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "列表", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 62,
    name: "aom-menu-RWGL-color",
    componentName: "IconAomMenuRWGLColor",
    title: "菜单列表",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "列表", "彩色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 63,
    name: "aom-menu-RWXQ-color",
    componentName: "IconAomMenuRWXQColor",
    title: "菜单选项颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "选项", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 64,
    name: "aom-menu-RYFA-color",
    componentName: "IconAomMenuRYFAColor",
    title: "菜单选项",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["菜单", "选项", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 65,
    name: "aom-menu-RZLC-color",
    componentName: "IconAomMenuRZLCColor",
    title: "菜单选项颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "选项", "颜色", "界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 66,
    name: "aom-menu-SBST-color",
    componentName: "IconAomMenuSBSTColor",
    title: "菜单选项颜色",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["菜单", "选项", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 67,
    name: "aom-menu-SJCX-color",
    componentName: "IconAomMenuSJCXColor",
    title: "自动化菜单",
    category: "Automation",
    categoryCN: "自动化工具",
    author: "KSW",
    tag: ["自动化", "菜单", "系统检查", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 68,
    name: "aom-menu-SJGL-color",
    componentName: "IconAomMenuSJGLColor",
    title: "菜单设置颜色",
    category: "Menu",
    categoryCN: "菜单设置",
    author: "KSW",
    tag: ["菜单", "设置", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 69,
    name: "aom-menu-SJHB-color",
    componentName: "IconAomMenuSJHBColor",
    title: "奥姆菜单SJHB颜色",
    category: "Software",
    categoryCN: "软件工具",
    author: "KSW",
    tag: ["菜单", "颜色", "软件", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 70,
    name: "aom-menu-SJKLJ-color",
    componentName: "IconAomMenuSJKLJColor",
    title: "菜单选项颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "选项", "颜色", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 71,
    name: "aom-menu-SSSJ-color",
    componentName: "IconAomMenuSSSJColor",
    title: "菜单信息颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "信息", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 72,
    name: "aom-menu-TZJL-color",
    componentName: "IconAomMenuTZJLColor",
    title: "菜单项颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "颜色", "界面", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 73,
    name: "aom-menu-WHQGL-color",
    componentName: "IconAomMenuWHQGLColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单图标",
    author: "KSW",
    tag: ["菜单", "图标", "颜色", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 74,
    name: "aom-menu-WWGL-color",
    componentName: "IconAomMenuWWGLColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单",
    author: "KSW",
    tag: ["菜单", "WWGL", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 75,
    name: "aom-menu-XTSZ-color",
    componentName: "IconAomMenuXTSZColor",
    title: "菜单选项",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "选项", "颜色", "XTSZ"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 76,
    name: "aom-menu-YHGL-color",
    componentName: "IconAomMenuYHGLColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单",
    author: "KSW",
    tag: ["菜单", "颜色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 77,
    name: "aom-menu-YWBCZL-color",
    componentName: "IconAomMenuYWBCZLColor",
    title: "菜单工具箱",
    category: "Tools",
    categoryCN: "工具",
    author: "KSW",
    tag: ["菜单", "工具箱", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 78,
    name: "aom-menu-YYST-color",
    componentName: "IconAomMenuYYSTColor",
    title: "菜单颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "颜色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 79,
    name: "aom-menu-ZBGL-color",
    componentName: "IconAomMenuZBGLColor",
    title: "自动化管理菜单",
    category: "Automation",
    categoryCN: "自动化管理",
    author: "KSW",
    tag: ["自动化", "管理", "菜单", "综合管理", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 80,
    name: "aom-menu-ZBZXSZ-color",
    componentName: "IconAomMenuZBZXSZColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 81,
    name: "aom-menu-ZHCL-color",
    componentName: "IconAomMenuZHCLColor",
    title: "菜单图标",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "界面", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 82,
    name: "aom-menu-ZHJG-color",
    componentName: "IconAomMenuZHJGColor",
    title: "菜单",
    category: "Menu",
    categoryCN: "菜单",
    author: "KSW",
    tag: ["菜单", "中国", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 83,
    name: "aom-menu-ZXLS-color",
    componentName: "IconAomMenuZXLSColor",
    title: "奥姆菜单",
    category: "Menu",
    categoryCN: "菜单",
    author: "KSW",
    tag: ["菜单", "自定义", "列表", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 84,
    name: "aom-menu-ZYSJ-color",
    componentName: "IconAomMenuZYSJColor",
    title: "菜单",
    category: "Menu",
    categoryCN: "菜单",
    author: "KSW",
    tag: ["菜单", "自定义设置", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 85,
    name: "aom-menu-ZZFWQ-color",
    componentName: "IconAomMenuZZFWQColor",
    title: "自动化菜单配置",
    category: "System",
    categoryCN: "系统配置",
    author: "KSW",
    tag: ["自动化", "菜单", "配置", "系统管理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 86,
    name: "argument",
    componentName: "IconArgument",
    title: "参数",
    category: "Programming",
    categoryCN: "编程",
    author: "KSW",
    tag: ["参数", "编程", "代码"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 87,
    name: "arrow-bottom",
    componentName: "IconArrowBottom",
    title: "向下箭头",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["箭头", "底部", "方向"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 88,
    name: "arrow-left",
    componentName: "IconArrowLeft",
    title: "左箭头",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["箭头", "方向", "返回", "导航"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 89,
    name: "arrow-right",
    componentName: "IconArrowRight",
    title: "右箭头",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["箭头", "方向", "右"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 90,
    name: "arrow-to-left",
    componentName: "IconArrowToLeft",
    title: "向左箭头",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["箭头", "方向", "左"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 91,
    name: "arrow-to-right",
    componentName: "IconArrowToRight",
    title: "向右箭头",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["箭头", "方向", "右"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 92,
    name: "arrow-top",
    componentName: "IconArrowTop",
    title: "向上箭头",
    category: "Directional",
    categoryCN: "方向图标",
    author: "KSW",
    tag: ["箭头", "向上", "方向"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 93,
    name: "arrow-up-right",
    componentName: "IconArrowUpRight",
    title: "向上右箭头",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["箭头", "方向", "导航", "向上", "右"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 94,
    name: "bot",
    componentName: "IconBot",
    title: "机器人",
    category: "Artificial",
    categoryCN: "人工智能",
    author: "KSW",
    tag: ["自动化", "聊天机器人", "虚拟助手"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 95,
    name: "c-type-autoit-color",
    componentName: "IconCTypeAutoitColor",
    title: "C型自动色彩",
    category: "Color",
    categoryCN: "色彩工具",
    author: "KSW",
    tag: ["色彩", "自动色彩", "C型色彩"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 96,
    name: "c-type-bat-color",
    componentName: "IconCTypeBatColor",
    title: "C型蝙蝠颜色",
    category: "Animal",
    categoryCN: "动物",
    author: "KSW",
    tag: ["蝙蝠", "颜色", "C型"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 97,
    name: "c-type-c-sharp-color",
    componentName: "IconCTypeCSharpColor",
    title: "C型C尖锐颜色",
    category: "Technology",
    categoryCN: "科技",
    author: "KSW",
    tag: ["科技", "图标", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 98,
    name: "c-type-cn-color",
    componentName: "IconCTypeCnColor",
    title: "中文类型颜色",
    category: "Color",
    categoryCN: "颜色",
    author: "KSW",
    tag: ["中文", "类型", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 99,
    name: "c-type-en-color",
    componentName: "IconCTypeEnColor",
    title: "英文类型颜色",
    category: "Color",
    categoryCN: "颜色",
    author: "KSW",
    tag: ["颜色", "英文", "类型"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 100,
    name: "c-type-fn-color",
    componentName: "IconCTypeFnColor",
    title: "函数颜色类型",
    category: "Function",
    categoryCN: "函数颜色类型",
    author: "KSW",
    tag: ["函数", "颜色", "类型"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 101,
    name: "c-type-JS-color",
    componentName: "IconCTypeJSColor",
    title: "JavaScript颜色类型",
    category: "Programming",
    categoryCN: "编程",
    author: "KSW",
    tag: ["JavaScript", "颜色", "编程语言"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 102,
    name: "c-type-lego-color",
    componentName: "IconCTypeLegoColor",
    title: "C型乐高颜色",
    category: "Building",
    categoryCN: "积木",
    author: "KSW",
    tag: ["乐高", "积木", "颜色", "玩具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 103,
    name: "c-type-linuxshell-color",
    componentName: "IconCTypeLinuxshellColor",
    title: "C类型Linux",
    category: "Programming",
    categoryCN: "编程工具",
    author: "KSW",
    tag: ["编程", "Linux", "Shell", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 104,
    name: "c-type-perl-color",
    componentName: "IconCTypePerlColor",
    title: "C型Perl颜色",
    category: "Programming",
    categoryCN: "编程工具",
    author: "KSW",
    tag: ["编程", "Perl", "颜色", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 105,
    name: "c-type-powershell-color",
    componentName: "IconCTypePowershellColor",
    title: "C型PowerShell颜色",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["编程", "PowerShell", "颜色", "开发"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 106,
    name: "c-type-python-color",
    componentName: "IconCTypePythonColor",
    title: "C型Python颜色",
    category: "Programming",
    categoryCN: "编程工具",
    author: "KSW",
    tag: ["Python", "编程", "颜色", "开发工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 107,
    name: "c-type-vbs-color",
    componentName: "IconCTypeVbsColor",
    title: "VBS颜色类型",
    category: "Programming",
    categoryCN: "编程",
    author: "KSW",
    tag: ["VBS", "颜色", "编程语言"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 108,
    name: "c-type-yaml-color",
    componentName: "IconCTypeYamlColor",
    title: "C型YAML颜色",
    category: "Programming",
    categoryCN: "编程工具",
    author: "KSW",
    tag: ["编程", "YAML", "颜色", "代码"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 109,
    name: "calendar-color",
    componentName: "IconCalendarColor",
    title: "日历颜色",
    category: "Calendar",
    categoryCN: "日历",
    author: "KSW",
    tag: ["日历", "日期", "时间", "事件"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 110,
    name: "card",
    componentName: "IconCard",
    title: "卡片",
    category: "Finance",
    categoryCN: "金融",
    author: "KSW",
    tag: ["信用卡", "银行卡", "支付", "金融工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 111,
    name: "chart-pie-color",
    componentName: "IconChartPieColor",
    title: "彩色饼图",
    category: "Data",
    categoryCN: "数据可视化",
    author: "KSW",
    tag: ["图表", "饼图", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 112,
    name: "chart-pie",
    componentName: "IconChartPie",
    title: "饼图",
    category: "Data",
    categoryCN: "数据可视化",
    author: "KSW",
    tag: ["图表", "数据", "分析", "展示"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 113,
    name: "check-ed-color",
    componentName: "IconCheckEdColor",
    title: "已选中颜色",
    category: "Status",
    categoryCN: "状态指示器",
    author: "KSW",
    tag: ["选中", "颜色", "确认", "完成"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 114,
    name: "check-normal-color",
    componentName: "IconCheckNormalColor",
    title: "正常颜色检查",
    category: "Verification",
    categoryCN: "验证",
    author: "KSW",
    tag: ["检查", "正常", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 115,
    name: "check-or-color",
    componentName: "IconCheckOrColor",
    title: "检查或颜色",
    category: "Tools",
    categoryCN: "工具",
    author: "KSW",
    tag: ["检查", "颜色", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 116,
    name: "check",
    componentName: "IconCheck",
    title: "勾选",
    category: "Icons",
    categoryCN: "图标",
    author: "KSW",
    tag: ["勾选", "确认", "完成", "选择"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 117,
    name: "clear",
    componentName: "IconClear",
    title: "清除",
    category: "Action",
    categoryCN: "动作",
    author: "KSW",
    tag: ["清除", "删除", "取消"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 118,
    name: "clear2",
    componentName: "IconClear2",
    title: "清除2",
    category: "Cleaning",
    categoryCN: "清洁工具",
    author: "KSW",
    tag: ["清洁", "工具", "扫帚"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 119,
    name: "clearDate",
    componentName: "IconClearDate",
    title: "清除日期",
    category: "Date",
    categoryCN: "日期操作",
    author: "KSW",
    tag: ["日期", "清除", "时间管理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 120,
    name: "close",
    componentName: "IconClose",
    title: "关闭",
    category: "Interface",
    categoryCN: "界面",
    author: "KSW",
    tag: ["关闭", "退出", "终止"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 121,
    name: "Collect",
    componentName: "IconCollect",
    title: "收藏",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["收藏", "星形", "标记", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 122,
    name: "copy",
    componentName: "IconCopy",
    title: "复制",
    category: "Editing",
    categoryCN: "编辑工具",
    author: "KSW",
    tag: ["复制", "粘贴", "剪切"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 123,
    name: "cursor-pointer",
    componentName: "IconCursorPointer",
    title: "光标指针",
    category: "Cursor",
    categoryCN: "光标",
    author: "KSW",
    tag: ["鼠标", "指针", "光标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 124,
    name: "date",
    componentName: "IconDate",
    title: "日期",
    category: "Calendar",
    categoryCN: "日历",
    author: "KSW",
    tag: ["时间", "日期", "日历", "计划", "事件"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 125,
    name: "delete",
    componentName: "IconDelete",
    title: "删除",
    category: "Action",
    categoryCN: "动作",
    author: "KSW",
    tag: ["删除", "移除", "取消"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 126,
    name: "dev-color",
    componentName: "IconDevColor",
    title: "开发颜色",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["开发", "颜色", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 127,
    name: "down-c",
    componentName: "IconDownC",
    title: "向下箭头",
    category: "Direction",
    categoryCN: "方向",
    author: "KSW",
    tag: ["箭头", "向下", "方向"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 128,
    name: "download",
    componentName: "IconDownload",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 129,
    name: "Drag",
    componentName: "IconDrag",
    title: "拖动",
    category: "Interaction",
    categoryCN: "交互",
    author: "KSW",
    tag: ["拖拽", "移动", "操作"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 130,
    name: "Edit",
    componentName: "IconEdit",
    title: "编辑",
    category: "Editing",
    categoryCN: "编辑工具",
    author: "KSW",
    tag: ["编辑", "修改", "调整"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 131,
    name: "EmptyBox",
    componentName: "IconEmptyBox",
    title: "空盒子",
    category: "Containers",
    categoryCN: "容器",
    author: "KSW",
    tag: ["空", "盒子", "容器", "存储"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 132,
    name: "fall",
    componentName: "IconFall",
    title: "秋天",
    category: "Season",
    categoryCN: "季节",
    author: "KSW",
    tag: ["秋天", "落叶", "丰收", "凉爽"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 133,
    name: "file-add",
    componentName: "IconFileAdd",
    title: "文件添加",
    category: "Document",
    categoryCN: "文档",
    author: "KSW",
    tag: ["文件", "添加", "文档", "新建"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 134,
    name: "file-starred-color",
    componentName: "IconFileStarredColor",
    title: "星标文件",
    category: "Documents",
    categoryCN: "文档",
    author: "KSW",
    tag: ["文件", "星标", "重要", "文档"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 135,
    name: "file",
    componentName: "IconFile",
    title: "文件",
    category: "Document",
    categoryCN: "文档",
    author: "KSW",
    tag: ["文件", "文档", "数据"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 136,
    name: "filter-fill",
    componentName: "IconFilterFill",
    title: "填充过滤器",
    category: "Tools",
    categoryCN: "工具",
    author: "KSW",
    tag: ["过滤器", "填充", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 137,
    name: "filter",
    componentName: "IconFilter",
    title: "过滤器",
    category: "Data",
    categoryCN: "数据处理",
    author: "KSW",
    tag: ["过滤", "筛选", "数据处理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 138,
    name: "flow-add",
    componentName: "IconFlowAdd",
    title: "流程添加",
    category: "Process",
    categoryCN: "流程管理",
    author: "KSW",
    tag: ["流程", "添加", "管理", "工作流"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 139,
    name: "flow-back",
    componentName: "IconFlowBack",
    title: "回流",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["返回", "箭头", "导航", "界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 140,
    name: "flow-batch-processing-color",
    componentName: "IconFlowBatchProcessingColor",
    title: "批量处理流程",
    category: "Data",
    categoryCN: "数据处理",
    author: "KSW",
    tag: ["批量处理", "流程", "彩色", "数据", "处理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 141,
    name: "flow-check-color",
    componentName: "IconFlowCheckColor",
    title: "流程检查颜色",
    category: "Process",
    categoryCN: "流程管理",
    author: "KSW",
    tag: ["流程", "检查", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 142,
    name: "flow-component-color",
    componentName: "IconFlowComponentColor",
    title: "流动组件颜色",
    category: "UI",
    categoryCN: "用户界面组件",
    author: "KSW",
    tag: ["颜色", "组件", "流动", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 143,
    name: "flow-controls-color",
    componentName: "IconFlowControlsColor",
    title: "流程控制颜色",
    category: "Flow",
    categoryCN: "流程控制",
    author: "KSW",
    tag: ["流程", "控制", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 144,
    name: "flow-end-color",
    componentName: "IconFlowEndColor",
    title: "流程结束颜色",
    category: "Flow",
    categoryCN: "流程",
    author: "KSW",
    tag: ["流程", "结束", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 145,
    name: "flow-end",
    componentName: "IconFlowEnd",
    title: "流程结束",
    category: "Process",
    categoryCN: "流程",
    author: "KSW",
    tag: ["流程", "结束", "标志"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 146,
    name: "flow-if-color",
    componentName: "IconFlowIfColor",
    title: "流程判断颜色",
    category: "Flow",
    categoryCN: "流程控制",
    author: "KSW",
    tag: ["流程", "判断", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 147,
    name: "flow-nested-color",
    componentName: "IconFlowNestedColor",
    title: "流动嵌套颜色",
    category: "Design",
    categoryCN: "设计元素",
    author: "KSW",
    tag: ["流动", "嵌套", "颜色", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 148,
    name: "flow-nested",
    componentName: "IconFlowNested",
    title: "流动嵌套",
    category: "Design",
    categoryCN: "设计元素",
    author: "KSW",
    tag: ["流动", "嵌套", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 149,
    name: "flow-quote-color",
    componentName: "IconFlowQuoteColor",
    title: "流动引文颜色",
    category: "Design",
    categoryCN: "设计元素",
    author: "KSW",
    tag: ["流动", "引文", "颜色", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 150,
    name: "flow-start-color",
    componentName: "IconFlowStartColor",
    title: "流动开始颜色",
    category: "Color",
    categoryCN: "颜色",
    author: "KSW",
    tag: ["流动", "开始", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 151,
    name: "flow-start",
    componentName: "IconFlowStart",
    title: "流程开始",
    category: "Process",
    categoryCN: "流程",
    author: "KSW",
    tag: ["流程", "开始", "启动"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 152,
    name: "flow-tips-color",
    componentName: "IconFlowTipsColor",
    title: "流动提示颜色",
    category: "Design",
    categoryCN: "设计元素",
    author: "KSW",
    tag: ["流动", "提示", "颜色", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 153,
    name: "flow-toolBox",
    componentName: "IconFlowToolBox",
    title: "流程工具箱",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["流程", "工具", "开发"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 154,
    name: "flow",
    componentName: "IconFlow",
    title: "流程",
    category: "Process",
    categoryCN: "流程图",
    author: "KSW",
    tag: ["流程", "图表", "结构"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 155,
    name: "fn-add",
    componentName: "IconFnAdd",
    title: "添加功能",
    category: "Function",
    categoryCN: "功能",
    author: "KSW",
    tag: ["添加", "功能", "操作"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 156,
    name: "fn",
    componentName: "IconFn",
    title: "函数",
    category: "Mathematics",
    categoryCN: "数学",
    author: "KSW",
    tag: ["函数", "数学", "公式"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 157,
    name: "fold",
    componentName: "IconFold",
    title: "折叠",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["折叠", "展开", "箭头", "方向"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 158,
    name: "folder-add",
    componentName: "IconFolderAdd",
    title: "添加文件夹",
    category: "File",
    categoryCN: "文件管理",
    author: "KSW",
    tag: ["文件夹", "添加", "新建"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 159,
    name: "folder-close",
    componentName: "IconFolderClose",
    title: "关闭文件夹",
    category: "File",
    categoryCN: "文件管理",
    author: "KSW",
    tag: ["文件夹", "关闭", "文档", "管理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 160,
    name: "folder-open",
    componentName: "IconFolderOpen",
    title: "打开文件夹",
    category: "File",
    categoryCN: "文件管理",
    author: "KSW",
    tag: ["文件夹", "打开", "文档", "存储"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 161,
    name: "full-screen",
    componentName: "IconFullScreen",
    title: "全屏",
    category: "Display",
    categoryCN: "显示",
    author: "KSW",
    tag: ["全屏", "显示", "屏幕"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 162,
    name: "GlobalOperation",
    componentName: "IconGlobalOperation",
    title: "全球操作",
    category: "International",
    categoryCN: "国际服务",
    author: "KSW",
    tag: ["全球", "操作", "国际", "服务"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 163,
    name: "hard-drive-color",
    componentName: "IconHardDriveColor",
    title: "彩色硬盘",
    category: "Storage",
    categoryCN: "存储设备",
    author: "KSW",
    tag: ["硬盘", "存储", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 164,
    name: "hide",
    componentName: "IconHide",
    title: "隐藏",
    category: "Visibility",
    categoryCN: "可见性",
    author: "KSW",
    tag: ["隐藏", "不可见", "遮挡"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 165,
    name: "icon-def",
    componentName: "IconIconDef",
    title: "图标定义",
    category: "Design",
    categoryCN: "设计元素",
    author: "KSW",
    tag: ["图标", "设计", "元素", "定义"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 166,
    name: "ide-pause",
    componentName: "IconIdePause",
    title: "IDE暂停",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["编程", "IDE", "暂停", "开发", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 167,
    name: "ide-play",
    componentName: "IconIdePlay",
    title: "IDE播放",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["编程", "开发", "IDE", "播放"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 168,
    name: "ide-refresh",
    componentName: "IconIdeRefresh",
    title: "IDE刷新",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["IDE", "刷新", "开发", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 169,
    name: "ide-stop",
    componentName: "IconIdeStop",
    title: "IDE停止",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["IDE", "停止", "开发", "编程"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 170,
    name: "IP",
    componentName: "IconIP",
    title: "IP地址",
    category: "Network",
    categoryCN: "网络",
    author: "KSW",
    tag: ["互联网", "地址", "网络", "连接"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 171,
    name: "item-def-color",
    componentName: "IconItemDefColor",
    title: "默认颜色项",
    category: "Color",
    categoryCN: "颜色管理",
    author: "KSW",
    tag: ["颜色", "默认", "图标", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 172,
    name: "left-menu-display",
    componentName: "IconLeftMenuDisplay",
    title: "左侧菜单显示",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["菜单", "显示", "左侧"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 173,
    name: "line",
    componentName: "IconLine",
    title: "线条",
    category: "Design",
    categoryCN: "设计",
    author: "KSW",
    tag: ["线条", "设计元素", "图形"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 174,
    name: "list-close",
    componentName: "IconListClose",
    title: "列表关闭",
    category: "List",
    categoryCN: "列表管理",
    author: "KSW",
    tag: ["列表", "关闭", "管理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 175,
    name: "list-open",
    componentName: "IconListOpen",
    title: "列表打开",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["列表", "打开", "导航", "下拉"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 176,
    name: "list-search",
    componentName: "IconListSearch",
    title: "列表搜索",
    category: "Edit",
    categoryCN: "编辑",
    author: "KSW",
    tag: ["列表", "搜索", "查看"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 177,
    name: "loading",
    componentName: "IconLoading",
    title: "加载中",
    category: "Progress",
    categoryCN: "进度",
    author: "KSW",
    tag: ["加载", "缓冲", "等待", "进度条"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 178,
    name: "lock",
    componentName: "IconLock",
    title: "锁",
    category: "Security",
    categoryCN: "安全",
    author: "KSW",
    tag: ["安全", "保护", "隐私"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 179,
    name: "locked",
    componentName: "IconLocked",
    title: "锁定",
    category: "Security",
    categoryCN: "安全",
    author: "KSW",
    tag: ["锁定", "安全", "保护", "隐私"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 180,
    name: "logout",
    componentName: "IconLogout",
    title: "登出",
    category: "User",
    categoryCN: "用户界面",
    author: "KSW",
    tag: ["退出", "注销", "离开"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 181,
    name: "medal-1",
    componentName: "IconMedal1",
    title: "奖章1",
    category: "Awards",
    categoryCN: "奖项",
    author: "KSW",
    tag: ["奖章", "荣誉", "成就"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 182,
    name: "medal-2",
    componentName: "IconMedal2",
    title: "奖章",
    category: "Awards",
    categoryCN: "奖项",
    author: "KSW",
    tag: ["奖章", "荣誉", "成就"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 183,
    name: "medal-3",
    componentName: "IconMedal3",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 184,
    name: "menu-collect",
    componentName: "IconMenuCollect",
    title: "菜单收藏",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["菜单", "收藏", "导航"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 185,
    name: "menu-collected",
    componentName: "IconMenuCollected",
    title: "菜单收藏",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["菜单", "收藏", "导航"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 186,
    name: "menu-def-color",
    componentName: "IconMenuDefColor",
    title: "菜单默认颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["菜单", "颜色", "默认"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 187,
    name: "Message",
    componentName: "IconMessage",
    title: "消息",
    category: "Communication",
    categoryCN: "通信",
    author: "KSW",
    tag: ["消息", "通信", "通知", "提醒"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 188,
    name: "mode-expression-color",
    componentName: "IconModeExpressionColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T09:42:16.000Z"
  },
  {
    id: 189,
    name: "mode-expression",
    componentName: "IconModeExpression",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-12-02T09:38:42.000Z"
  },
  {
    id: 190,
    name: "more",
    componentName: "IconMore",
    title: "更多",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["更多选项", "菜单", "扩展"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 191,
    name: "organization",
    componentName: "IconOrganization",
    title: "组织",
    category: "Business",
    categoryCN: "商业",
    author: "KSW",
    tag: ["公司", "机构", "团队"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 192,
    name: "patch-color",
    componentName: "IconPatchColor",
    title: "补丁颜色",
    category: "Design",
    categoryCN: "设计工具",
    author: "KSW",
    tag: ["补丁", "颜色", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 193,
    name: "patch-set-color",
    componentName: "IconPatchSetColor",
    title: "补丁设置颜色",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["补丁", "颜色设置", "开发工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 194,
    name: "personnel",
    componentName: "IconPersonnel",
    title: "人员",
    category: "Human",
    categoryCN: "人力资源",
    author: "KSW",
    tag: ["员工", "人事", "管理", "招聘"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 195,
    name: "plug-in-360-color",
    componentName: "IconPlugIn360Color",
    title: "360度彩色插件",
    category: "Software",
    categoryCN: "软件工具",
    author: "KSW",
    tag: ["插件", "360度", "彩色", "软件"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 196,
    name: "plug-in-Chrome-color",
    componentName: "IconPlugInChromeColor",
    title: "插件",
    category: "Browser",
    categoryCN: "浏览器插件",
    author: "KSW",
    tag: ["插件", "Chrome", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 197,
    name: "plug-in-Edge-color",
    componentName: "IconPlugInEdgeColor",
    title: "插件边缘颜色",
    category: "Software",
    categoryCN: "软件工具",
    author: "KSW",
    tag: ["插件", "边缘", "颜色", "设计", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 198,
    name: "plug-in-excel-color",
    componentName: "IconPlugInExcelColor",
    title: "Excel插件颜色",
    category: "Software",
    categoryCN: "软件工具",
    author: "KSW",
    tag: ["Excel", "插件", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 199,
    name: "plug-in-Firefox-color",
    componentName: "IconPlugInFirefoxColor",
    title: "火狐插件颜色",
    category: "Browser",
    categoryCN: "浏览器插件",
    author: "KSW",
    tag: ["火狐", "插件", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 200,
    name: "plug-in-image-color",
    componentName: "IconPlugInImageColor",
    title: "插件图像颜色",
    category: "Image",
    categoryCN: "图像处理",
    author: "KSW",
    tag: ["插件", "图像", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 201,
    name: "plug-in-java-color",
    componentName: "IconPlugInJavaColor",
    title: "插件Java颜色",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["插件", "Java", "颜色", "开发工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 202,
    name: "plug-in-Mail-color",
    componentName: "IconPlugInMailColor",
    title: "插件邮件颜色",
    category: "Email",
    categoryCN: "电子邮件插件",
    author: "KSW",
    tag: ["邮件", "插件", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 203,
    name: "plug-in-Net-color-2",
    componentName: "IconPlugInNetColor2",
    title: "插件网络颜色2",
    category: "Software",
    categoryCN: "软件工具",
    author: "KSW",
    tag: ["插件", "网络", "颜色", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 204,
    name: "plug-in-Net-color",
    componentName: "IconPlugInNetColor",
    title: "插件",
    category: "Software",
    categoryCN: "软件开发",
    author: "KSW",
    tag: ["插件", "Net", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 205,
    name: "plug-in-OCR-color",
    componentName: "IconPlugInOCRColor",
    title: "插件OCR颜色识别",
    category: "Image",
    categoryCN: "图像处理",
    author: "KSW",
    tag: ["OCR", "颜色识别", "插件"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 206,
    name: "plug-in-pdf-color",
    componentName: "IconPlugInPdfColor",
    title: "插件PDF颜色",
    category: "Software",
    categoryCN: "软件工具",
    author: "KSW",
    tag: ["插件", "PDF", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 207,
    name: "plug-in-sogou-color",
    componentName: "IconPlugInSogouColor",
    title: "搜狗插件颜色",
    category: "Software",
    categoryCN: "软件工具",
    author: "KSW",
    tag: ["插件", "搜狗", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 208,
    name: "plug-in-SSL-color",
    componentName: "IconPlugInSSLColor",
    title: "插件SSL颜色",
    category: "Security",
    categoryCN: "安全",
    author: "KSW",
    tag: ["插件", "SSL", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 209,
    name: "plug-in-text-color",
    componentName: "IconPlugInTextColor",
    title: "插件文本颜色",
    category: "Text",
    categoryCN: "文本编辑",
    author: "KSW",
    tag: ["插件", "文本", "颜色", "编辑"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 210,
    name: "portfolio",
    componentName: "IconPortfolio",
    title: "投资组合",
    category: "Finance",
    categoryCN: "金融",
    author: "KSW",
    tag: ["投资", "组合", "金融", "管理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 211,
    name: "project-logo-gf-color",
    componentName: "IconProjectLogoGfColor",
    title: "项目标志GF彩色",
    category: "Logo",
    categoryCN: "标志",
    author: "KSW",
    tag: ["项目", "标志", "彩色", "设计"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 212,
    name: "Question-line",
    componentName: "IconQuestionLine",
    title: "问号",
    category: "Symbols",
    categoryCN: "符号",
    author: "KSW",
    tag: ["问题", "帮助", "询问", "信息"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 213,
    name: "question",
    componentName: "IconQuestion",
    title: "问题",
    category: "Help",
    categoryCN: "帮助",
    author: "KSW",
    tag: ["问题", "帮助", "询问"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 214,
    name: "ranking-color",
    componentName: "IconRankingColor",
    title: "排名颜色",
    category: "Color",
    categoryCN: "颜色",
    author: "KSW",
    tag: ["排名", "颜色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 215,
    name: "ranking",
    componentName: "IconRanking",
    title: "排名",
    category: "Data",
    categoryCN: "数据分析",
    author: "KSW",
    tag: ["排名", "数据", "分析", "图表"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 216,
    name: "re-screen",
    componentName: "IconReScreen",
    title: "重新筛选",
    category: "Data",
    categoryCN: "数据处理",
    author: "KSW",
    tag: ["筛选", "数据", "处理", "分析"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 217,
    name: "refresh",
    componentName: "IconRefresh",
    title: "刷新",
    category: "Action",
    categoryCN: "动作",
    author: "KSW",
    tag: ["刷新", "更新", "重新加载"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 218,
    name: "reset",
    componentName: "IconReset",
    title: "重置",
    category: "System",
    categoryCN: "系统",
    author: "KSW",
    tag: ["重置", "恢复", "初始化"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 219,
    name: "rise",
    componentName: "IconRise",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 220,
    name: "save",
    componentName: "IconSave",
    title: "保存",
    category: "File",
    categoryCN: "文件管理",
    author: "KSW",
    tag: ["保存", "文件", "存储"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 221,
    name: "scan",
    componentName: "IconScan",
    title: "扫描",
    category: "Technology",
    categoryCN: "科技",
    author: "KSW",
    tag: ["扫描仪", "条形码", "二维码"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 222,
    name: "scrip-color",
    componentName: "IconScripColor",
    title: "脚本颜色",
    category: "Development",
    categoryCN: "开发工具",
    author: "KSW",
    tag: ["编程", "代码", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 223,
    name: "scrip",
    componentName: "IconScrip",
    title: "脚本",
    category: "Programming",
    categoryCN: "编程",
    author: "KSW",
    tag: ["脚本", "编程", "代码"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 224,
    name: "seal",
    componentName: "IconSeal",
    title: "印章",
    category: "Stationery",
    categoryCN: "文具",
    author: "KSW",
    tag: ["印章", "办公用品", "文具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 225,
    name: "search",
    componentName: "IconSearch",
    title: "搜索",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["搜索", "放大镜", "查找"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 226,
    name: "setting-animation",
    componentName: "IconSettingAnimation",
    title: "设置动画",
    category: "Design",
    categoryCN: "设计工具",
    author: "KSW",
    tag: ["设置", "动画", "设计", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 227,
    name: "setting-fill",
    componentName: "IconSettingFill",
    title: "设置填充",
    category: "Tools",
    categoryCN: "工具",
    author: "KSW",
    tag: ["设置", "配置", "选项", "工具"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 228,
    name: "setting",
    componentName: "IconSetting",
    title: "设置",
    category: "System",
    categoryCN: "系统工具",
    author: "KSW",
    tag: ["设置", "配置", "系统管理"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 229,
    name: "show",
    componentName: "IconShow",
    title: "显示",
    category: "Visibility",
    categoryCN: "可见性",
    author: "KSW",
    tag: ["显示", "可见", "视觉"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 230,
    name: "size-controls",
    componentName: "IconSizeControls",
    title: "大小控制",
    category: "Edit",
    categoryCN: "编辑",
    author: "KSW",
    tag: ["控制"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 231,
    name: "sort-bottom",
    componentName: "IconSortBottom",
    title: "底部排序",
    category: "Sorting",
    categoryCN: "排序",
    author: "KSW",
    tag: ["排序", "底部", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 232,
    name: "sort-down",
    componentName: "IconSortDown",
    title: "向下排序",
    category: "Sorting",
    categoryCN: "排序",
    author: "KSW",
    tag: ["排序", "向下", "箭头"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 233,
    name: "sort-top",
    componentName: "IconSortTop",
    title: "顶部排序",
    category: "Sorting",
    categoryCN: "排序",
    author: "KSW",
    tag: ["排序", "顶部", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 234,
    name: "sort-up",
    componentName: "IconSortUp",
    title: "排序上升",
    category: "Sorting",
    categoryCN: "排序",
    author: "KSW",
    tag: ["排序", "上升", "箭头"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 235,
    name: "status-403",
    componentName: "IconStatus403",
    title: "状态",
    category: "HTTP",
    categoryCN: "HTTP状态",
    author: "KSW",
    tag: ["错误", "访问被拒绝", "403"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 236,
    name: "status-404",
    componentName: "IconStatus404",
    title: "状态",
    category: "Error",
    categoryCN: "错误页面",
    author: "KSW",
    tag: ["错误", "404", "未找到"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 237,
    name: "status-500",
    componentName: "IconStatus500",
    title: "状态500",
    category: "Error",
    categoryCN: "错误",
    author: "KSW",
    tag: ["错误", "500", "服务器错误"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 238,
    name: "status-danger",
    componentName: "IconStatusDanger",
    title: "危险状态",
    category: "Status",
    categoryCN: "状态指示器",
    author: "KSW",
    tag: ["警告", "错误", "危险", "注意"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 239,
    name: "status-def",
    componentName: "IconStatusDef",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 240,
    name: "status-empty-color",
    componentName: "IconStatusEmptyColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 241,
    name: "status-empty",
    componentName: "IconStatusEmpty",
    title: "状态空",
    category: "Status",
    categoryCN: "状态",
    author: "KSW",
    tag: ["状态", "空", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 242,
    name: "status-info",
    componentName: "IconStatusInfo",
    title: "状态信息",
    category: "Information",
    categoryCN: "信息",
    author: "KSW",
    tag: ["状态", "信息", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 243,
    name: "status-success",
    componentName: "IconStatusSuccess",
    title: "状态成功",
    category: "Status",
    categoryCN: "状态指示器",
    author: "KSW",
    tag: ["成功", "完成", "确认", "勾选"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 244,
    name: "status-warning",
    componentName: "IconStatusWarning",
    title: "状态警告",
    category: "Alerts",
    categoryCN: "警告",
    author: "KSW",
    tag: ["警告", "状态", "注意", "错误"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 245,
    name: "Step-Status-Failure",
    componentName: "IconStepStatusFailure",
    title: "步骤状态失败",
    category: "Process",
    categoryCN: "流程状态",
    author: "KSW",
    tag: ["步骤", "状态", "失败", "流程", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 246,
    name: "Step-Status-Success",
    componentName: "IconStepStatusSuccess",
    title: "步骤状态成功",
    category: "Progress",
    categoryCN: "进度指示器",
    author: "KSW",
    tag: ["步骤", "状态", "成功", "完成", "进度"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 247,
    name: "store-color",
    componentName: "IconStoreColor",
    title: "商店颜色",
    category: "Shopping",
    categoryCN: "购物",
    author: "KSW",
    tag: ["商店", "颜色", "购物"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 248,
    name: "SupportCenter",
    componentName: "IconSupportCenter",
    title: "支持中心",
    category: "Customer",
    categoryCN: "客户服务",
    author: "KSW",
    tag: ["帮助", "支持", "客服", "问题解答"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 249,
    name: "SystemType-aix-color",
    componentName: "IconSystemTypeAixColor",
    title: "系统类型",
    category: "Operating",
    categoryCN: "操作系统",
    author: "KSW",
    tag: ["AIX", "系统", "彩色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 250,
    name: "SystemType-android-color",
    componentName: "IconSystemTypeAndroidColor",
    title: "系统类型",
    category: "System",
    categoryCN: "系统",
    author: "KSW",
    tag: ["系统", "安卓", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 251,
    name: "SystemType-arm-color",
    componentName: "IconSystemTypeArmColor",
    title: "系统类型",
    category: "System",
    categoryCN: "系统",
    author: "KSW",
    tag: ["系统", "ARM", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 252,
    name: "SystemType-AS-color",
    componentName: "IconSystemTypeASColor",
    title: "系统类型",
    category: "System",
    categoryCN: "系统组件",
    author: "KSW",
    tag: ["系统", "类型", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 253,
    name: "SystemType-firewall-color",
    componentName: "IconSystemTypeFirewallColor",
    title: "系统类型",
    category: "System",
    categoryCN: "系统组件",
    author: "KSW",
    tag: ["系统", "防火墙", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 254,
    name: "SystemType-interchanger-color",
    componentName: "IconSystemTypeInterchangerColor",
    title: "",
    category: "Other",
    categoryCN: "其他",
    author: "KSW",
    tag: [],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 255,
    name: "SystemType-ios-color",
    componentName: "IconSystemTypeIosColor",
    title: "系统类型",
    category: "Operating",
    categoryCN: "操作系统",
    author: "KSW",
    tag: ["系统", "iOS", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 256,
    name: "SystemType-LB-color",
    componentName: "IconSystemTypeLBColor",
    title: "系统类型",
    category: "System",
    categoryCN: "系统组件",
    author: "KSW",
    tag: ["系统", "负载均衡", "彩色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 257,
    name: "SystemType-linux-color",
    componentName: "IconSystemTypeLinuxColor",
    title: "Linux系统类型",
    category: "Operating",
    categoryCN: "操作系统",
    author: "KSW",
    tag: ["Linux", "系统", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 258,
    name: "SystemType-router-color",
    componentName: "IconSystemTypeRouterColor",
    title: "系统类型",
    category: "Networking",
    categoryCN: "网络",
    author: "KSW",
    tag: ["路由器", "网络设备", "无线", "连接"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 259,
    name: "SystemType-Unix-color",
    componentName: "IconSystemTypeUnixColor",
    title: "Unix系统类型",
    category: "Operating",
    categoryCN: "操作系统",
    author: "KSW",
    tag: ["Unix", "操作系统", "彩色图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 260,
    name: "SystemType-windows-color",
    componentName: "IconSystemTypeWindowsColor",
    title: "系统类型",
    category: "Operating",
    categoryCN: "操作系统",
    author: "KSW",
    tag: ["系统", "Windows", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 261,
    name: "table-control-more",
    componentName: "IconTableControlMore",
    title: "表格控制更多",
    category: "Table",
    categoryCN: "表格控件",
    author: "KSW",
    tag: ["表格", "控制", "更多选项"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 262,
    name: "table-sort-down-color",
    componentName: "IconTableSortDownColor",
    title: "表格排序向下颜色",
    category: "Data",
    categoryCN: "数据管理",
    author: "KSW",
    tag: ["表格", "排序", "向下", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 263,
    name: "table-sort-normal-color",
    componentName: "IconTableSortNormalColor",
    title: "表格排序",
    category: "Data",
    categoryCN: "数据管理",
    author: "KSW",
    tag: ["表格", "排序", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 264,
    name: "table-sort-up-color",
    componentName: "IconTableSortUpColor",
    title: "表格排序上升颜色",
    category: "Data",
    categoryCN: "数据管理",
    author: "KSW",
    tag: ["表格", "排序", "上升", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 265,
    name: "task",
    componentName: "IconTask",
    title: "任务",
    category: "Productivity",
    categoryCN: "生产力",
    author: "KSW",
    tag: ["任务管理", "待办事项", "工作效率"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 266,
    name: "test-color",
    componentName: "IconTestColor",
    title: "测试颜色",
    category: "Color",
    categoryCN: "颜色",
    author: "KSW",
    tag: ["颜色", "测试", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 267,
    name: "time",
    componentName: "IconTime",
    title: "时间",
    category: "Clock",
    categoryCN: "时钟",
    author: "KSW",
    tag: ["时间", "时钟", "计时"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 268,
    name: "tips",
    componentName: "IconTips",
    title: "提示",
    category: "Helpful",
    categoryCN: "帮助资源",
    author: "KSW",
    tag: ["建议", "技巧", "帮助", "指南"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 269,
    name: "top1-color",
    componentName: "IconTop1Color",
    title: "第一名颜色",
    category: "Achievement",
    categoryCN: "成就",
    author: "KSW",
    tag: ["第一名", "奖牌", "荣誉"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 270,
    name: "top2-color",
    componentName: "IconTop2Color",
    title: "顶部2号彩色",
    category: "Icons",
    categoryCN: "图标",
    author: "KSW",
    tag: ["顶部", "数字", "彩色", "图标"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 271,
    name: "top3-color",
    componentName: "IconTop3Color",
    title: "前三名颜色",
    category: "Achievement",
    categoryCN: "成就",
    author: "KSW",
    tag: ["排名", "前三名", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 272,
    name: "triangle-bottom",
    componentName: "IconTriangleBottom",
    title: "底部三角形",
    category: "Shapes",
    categoryCN: "形状",
    author: "KSW",
    tag: ["三角形", "底部", "几何形状"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 273,
    name: "triangle-top",
    componentName: "IconTriangleTop",
    title: "三角形顶部",
    category: "Shapes",
    categoryCN: "形状",
    author: "KSW",
    tag: ["几何", "图形", "三角形"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 274,
    name: "unfold",
    componentName: "IconUnfold",
    title: "展开",
    category: "Navigation",
    categoryCN: "导航",
    author: "KSW",
    tag: ["展开", "箭头", "方向"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 275,
    name: "upload",
    componentName: "IconUpload",
    title: "上传",
    category: "File",
    categoryCN: "文件管理",
    author: "KSW",
    tag: ["上传", "文件", "数据传输"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 276,
    name: "user-filled",
    componentName: "IconUserFilled",
    title: "用户-填充",
    category: "User",
    categoryCN: "用户",
    author: "KSW",
    tag: ["用户", "人们"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 277,
    name: "users-filled",
    componentName: "IconUsersFilled",
    title: "用户们-填充",
    category: "User",
    categoryCN: "用户",
    author: "KSW",
    tag: ["用户们", "人们"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 278,
    name: "users",
    componentName: "IconUsers",
    title: "用户们",
    category: "User",
    categoryCN: "用户",
    author: "KSW",
    tag: ["用户们", "人们"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 279,
    name: "variable",
    componentName: "IconVariable",
    title: "变量",
    category: "Programming",
    categoryCN: "编程",
    author: "KSW",
    tag: ["变量", "编程", "数据存储"],
    projectName: "base",
    modifiedTime: "2024-11-28T08:21:35.000Z"
  },
  {
    id: 280,
    name: "view-switch-card",
    componentName: "IconViewSwitchCard",
    title: "视图切换卡",
    category: "UI",
    categoryCN: "用户界面组件",
    author: "KSW",
    tag: ["视图", "切换", "卡片", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 281,
    name: "view-switch-color",
    componentName: "IconViewSwitchColor",
    title: "视图切换颜色",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["视图", "切换", "颜色"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 282,
    name: "view-toggle-details",
    componentName: "IconViewToggleDetails",
    title: "视图切换详情",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["视图", "切换", "详情", "用户界面"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 283,
    name: "view-toggle-table",
    componentName: "IconViewToggleTable",
    title: "视图切换表格",
    category: "UI",
    categoryCN: "用户界面元素",
    author: "KSW",
    tag: ["视图", "切换", "表格", "UI", "交互"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  },
  {
    id: 284,
    name: "warning",
    componentName: "IconWarning",
    title: "警告",
    category: "Safety",
    categoryCN: "安全",
    author: "KSW",
    tag: ["警告", "注意", "危险"],
    projectName: "base",
    modifiedTime: "2024-11-04T09:03:16.000Z"
  }
];
var Ob = { class: "icon-container" };
var Bb = { class: "icon-list" };
var Zb = defineComponent({
  name: "KIconPopver",
  __name: "icon_popver",
  emits: ["updataIcon"],
  setup(e16, { expose: t10, emit: n }) {
    const o = ref(null), r = {}, a = ref(""), i = async (c) => {
      l("updataIcon", c);
    }, s = computed(() => a.value.trim() === "" ? Ou : Ou.filter((c) => {
      const u = c.name.includes(a.value), d = c.componentName.includes(a.value), m = c.tag.some((p) => p.includes(a.value));
      return u || d || m;
    })), l = n;
    return t10(Ae(r, o)), (c, u) => {
      const d = resolveComponent("k-input"), m = resolveComponent("k-button"), p = resolveComponent("k-popover");
      return openBlock(), createElementBlock("div", {
        ref_key: "KIconPopver",
        ref: o
      }, [
        createVNode(p, {
          trigger: "click",
          width: 470,
          placement: "bottom"
        }, {
          reference: withCtx(() => [
            renderSlot(c.$slots, "default", {}, () => [
              createVNode(m, null, {
                default: withCtx(() => u[1] || (u[1] = [
                  createTextVNode("点击我")
                ])),
                _: 1
              })
            ])
          ]),
          default: withCtx(() => [
            createBaseVNode("div", Ob, [
              createVNode(d, {
                modelValue: a.value,
                "onUpdate:modelValue": u[0] || (u[0] = (f) => a.value = f)
              }, null, 8, ["modelValue"]),
              createBaseVNode("div", Bb, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(s.value, (f) => (openBlock(), createBlock(resolveDynamicComponent(f.componentName), {
                  class: "icon-item",
                  onClick: (h10) => i(f.componentName)
                }, null, 8, ["onClick"]))), 256))
              ])
            ])
          ]),
          _: 3
        })
      ], 512);
    };
  }
});
var Wb = $e(Zb);
var u1 = [
  Lt,
  Eb,
  ro,
  Y6,
  Mf,
  $f,
  fa,
  If,
  ay,
  Ef,
  Kf,
  zf,
  Go,
  vo,
  my,
  Lf,
  Ff,
  Ny,
  jf,
  Of,
  Hy,
  Io,
  Xy,
  f3,
  g3,
  Bf,
  Zf,
  wa,
  Wf,
  Hr,
  Ur,
  o1,
  i8,
  r1,
  i1,
  d8,
  f8,
  p8,
  h8,
  x8,
  D8,
  E8,
  K8,
  q8,
  el,
  cb,
  ar,
  rr,
  kb,
  Nb,
  xb,
  Pb,
  jb,
  Wb
];
var qb = { class: "drawer-btn w-5 h-5 border rounded-full flex justify-center items-center text-sm bg-white text-gray-400 hover:text-blue-400 hover:font-bold hover:border-blue-400" };
var Vb = { class: "KPageViewBus-content w-56 h-full" };
var Hb = { class: "KPageViewBus-content--drawer w-56 h-full flex flex-col" };
var Ub = { class: "KPageViewBus-head flex justify-between items-center py-4 border-b border-gray-200 box-border" };
var Gb = { class: "KPageViewBus-head-title text-xl" };
var Xb = {
  key: 0,
  class: "KPageViewBus-head-info"
};
var Yb = { class: "KPageViewBus-main pt-3 h-full flex" };
var Qb = {
  key: 0,
  class: "KPageViewBus-foot pt-3"
};
var Jb = defineComponent({
  name: "KPageViewBus",
  __name: "PageViewBus",
  props: {
    title: {
      type: String,
      default: ""
    },
    info: {
      type: String,
      default: void 0
    },
    refresh: {
      type: Boolean,
      default: true
    }
  },
  emits: ["refresh"],
  setup(e16, { emit: t10 }) {
    const n = ref(false), o = ref(false), r = e16, a = t10;
    return (i, s) => {
      const l = resolveComponent("IconArrowLeft"), c = resolveComponent("IconTips"), u = resolveComponent("IconRefresh"), d = resolveComponent("KButton");
      return openBlock(), createElementBlock("div", {
        id: "KPageViewBus",
        class: normalizeClass(["KPageViewBus px-3 border-r border-gray-100 relative", { "is-close": o.value }])
      }, [
        createBaseVNode("div", {
          class: "drawer-btn-box absolute w-6 h-6 flex justify-center items-center",
          onClick: s[0] || (s[0] = () => o.value = !o.value)
        }, [
          createBaseVNode("div", qb, [
            createVNode(l, { class: "text-gray-400" })
          ])
        ]),
        createBaseVNode("div", Vb, [
          createBaseVNode("div", Hb, [
            createBaseVNode("div", Ub, [
              createBaseVNode("div", {
                class: "flex items-center gap-1 h-8",
                onMouseenter: s[2] || (s[2] = () => n.value = true)
              }, [
                createBaseVNode("p", Gb, toDisplayString(e16.title), 1),
                r.info ? (openBlock(), createElementBlock("div", Xb, [
                  createVNode(unref(wa), {
                    content: r.info,
                    onHide: s[1] || (s[1] = () => n.value = false)
                  }, {
                    default: withCtx(() => [
                      withDirectives(createVNode(c, {
                        color: "#4193f2",
                        size: "16"
                      }, null, 512), [
                        [vShow, n.value]
                      ])
                    ]),
                    _: 1
                  }, 8, ["content"])
                ])) : createCommentVNode("", true)
              ], 32),
              renderSlot(i.$slots, "head", {}, () => [
                r.refresh ? (openBlock(), createBlock(d, {
                  key: 0,
                  text: "",
                  style: { "padding-right": "0" },
                  onClick: s[3] || (s[3] = () => a("refresh"))
                }, {
                  default: withCtx(() => [
                    createVNode(u)
                  ]),
                  _: 1
                })) : createCommentVNode("", true)
              ], true)
            ]),
            createBaseVNode("div", Yb, [
              renderSlot(i.$slots, "default", {}, void 0, true)
            ]),
            i.$slots.foot ? (openBlock(), createElementBlock("div", Qb, [
              renderSlot(i.$slots, "foot", {}, void 0, true)
            ])) : createCommentVNode("", true)
          ])
        ])
      ], 2);
    };
  }
});
var e92 = Ta(Jb, [["__scopeId", "data-v-43e1cc5f"]]);
var d1 = $e(e92);
var t9 = { class: "titel text-base text-gray-400 text-nowrap leading-6" };
var n9 = { class: "value text-base text-normal min-h-6 flex items-center leading-6 w-full" };
var o9 = { key: 0 };
var a9 = defineComponent({
  name: "KDetailsItem",
  __name: "DetailsItem",
  props: {
    label: {},
    value: {},
    render: {},
    showLine: { type: Boolean, default: void 0 },
    column: { default: 1 },
    direction: {},
    useflex: { type: Boolean, default: false }
  },
  setup(e16) {
    const t10 = e16, n = inject(
      "__maxColumn__",
      computed(() => t10.column)
    ), o = computed(() => n.value ? n.value >= t10.column ? t10.column : n.value : t10.column);
    return (r, a) => (openBlock(), createElementBlock("div", {
      ref: "RefDetailsItem",
      class: normalizeClass(["k-detailsItem bbm h-fit flex flex-col gap-1 shrink-0 pb-2", [
        { "border-b border-gray-200": t10.showLine === true },
        { "!flex-row": t10.direction === "horizontal" },
        { "min-w-24": t10.useflex === true }
      ]]),
      style: normalizeStyle(t10.useflex ? "" : `grid-column: span ${o.value};`)
    }, [
      createBaseVNode("p", t9, toDisplayString(r.label) + ":", 1),
      createBaseVNode("p", n9, [
        typeof r.value == "string" ? (openBlock(), createElementBlock("span", o9, toDisplayString(r.value), 1)) : createCommentVNode("", true),
        (openBlock(), createBlock(resolveDynamicComponent(typeof r.render == "function" ? r.render() : r.render)))
      ])
    ], 6));
  }
});
var Ci = Ta(a9, [["__scopeId", "data-v-f45a48bc"]]);
var r9 = {
  id: "KPageDetails",
  class: "KPageDetails h-full flex-1",
  style: { "min-width": "0" }
};
var i9 = { class: "KPageDetailsHead-content w-full flex flex-col bg-white rounded overflow-hidden mb-2 shadow-sm" };
var s9 = { class: "extra-head px-6 py-2 border-b border-gray-200" };
var l9 = { class: "w-full flex justify-between items-center" };
var c9 = { class: "head-title" };
var u9 = { class: "flex items-center gap-1 h-8" };
var d9 = { class: "head-toolbar" };
var f9 = { class: "extra-head-body px-6 py-3" };
var m9 = { class: "w-full relative overflow-auto scrollbar-hide flex gap-4" };
var p9 = { class: "shadow-sm flex-1" };
var h9 = defineComponent({
  name: "KPageDetails",
  __name: "PageDetails",
  props: {
    pageIcon: {
      type: String,
      default: ""
    },
    pageTitle: {
      type: String,
      default: "标题"
    },
    pageDescriptions: {
      type: String,
      default: ""
    },
    abstract: {
      type: Array,
      default: () => []
    },
    showLine: {
      type: Boolean,
      default: false
    },
    direction: {
      type: String,
      default: "vertical"
    },
    useflex: {
      type: Boolean,
      default: true
    }
  },
  setup(e16) {
    const t10 = e16;
    return (n, o) => (openBlock(), createElementBlock("div", r9, [
      createBaseVNode("div", i9, [
        createBaseVNode("div", s9, [
          renderSlot(n.$slots, "extra-head", {}, () => [
            createBaseVNode("div", l9, [
              createBaseVNode("div", c9, [
                renderSlot(n.$slots, "head-title", {}, () => [
                  createBaseVNode("div", u9, [
                    e16.pageIcon ? (openBlock(), createBlock(resolveDynamicComponent(e16.pageIcon), {
                      key: 0,
                      size: "24"
                    })) : createCommentVNode("", true),
                    createBaseVNode("span", null, toDisplayString(e16.pageTitle), 1)
                  ])
                ], true)
              ]),
              createBaseVNode("div", d9, [
                renderSlot(n.$slots, "head-toolbar", {}, void 0, true)
              ])
            ])
          ], true)
        ]),
        createBaseVNode("div", f9, [
          renderSlot(n.$slots, "head-abstract", {}, () => [
            createBaseVNode("div", m9, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(t10.abstract, (r) => (openBlock(), createBlock(Ci, {
                key: r.label,
                label: r.label,
                value: r.value,
                render: r.render,
                "show-line": e16.showLine,
                direction: e16.direction,
                useflex: e16.useflex
              }, null, 8, ["label", "value", "render", "show-line", "direction", "useflex"]))), 128))
            ])
          ], true)
        ])
      ]),
      createBaseVNode("div", p9, [
        renderSlot(n.$slots, "default", {}, void 0, true)
      ])
    ]));
  }
});
var g9 = Ta(h9, [["__scopeId", "data-v-29bd0471"]]);
var v9 = $e(g9);
var y9 = {
  id: "KPageTableView",
  class: "KPageTableView bbm w-full h-full bg-white rounded flex text-gray-700"
};
var b9 = {
  id: "KPageContent",
  class: "KPageContent h-full flex-1 flex flex-col pl-6 pr-3 pt-3",
  style: {
    "min-width": "0",
    "min-height": "0"
  }
};
var _9 = {
  id: "KPageHead",
  class: "KPageHead flex justify-between pb-1"
};
var w9 = {
  key: 0,
  class: "KPageHead-icon w-6 h-6 mr-1"
};
var T9 = {
  class: "KPageHead-title"
};
var C9 = {
  key: 1,
  class: "KPageHead-info pl-1"
};
var k9 = {
  id: "KPageBody",
  class: "KPageBody h-full"
};
var S9 = defineComponent({
  name: "KPageTableView",
  __name: "PageTableView",
  props: {
    showAside: {
      type: Boolean,
      default: false
    },
    asideTitle: {
      type: String,
      default: "viewBus"
    },
    asideInfo: {
      type: String,
      default: ""
    },
    asideRefresh: {
      type: Boolean,
      default: false
    },
    pageIcon: {
      type: String,
      default: ""
    },
    pageTitle: {
      type: String,
      default: "页面标题"
    },
    pageInfo: {
      type: String,
      default: ""
    }
  },
  emits: ["refresh"],
  setup(e16, {
    emit: t10
  }) {
    const n = e16, o = ref(false), a = /.(jpg|jpeg|png|gif|svg)$/.test(n.pageIcon) ? () => createVNode("img", {
      src: n.pageIcon,
      alt: "icon",
      class: "KPageHead-icon"
    }, null) : n.pageIcon, i = t10;
    return (s, l) => {
      const c = resolveComponent("IconTips");
      return openBlock(), createElementBlock("div", y9, [e16.showAside ? (openBlock(), createBlock(unref(d1), {
        key: 0,
        title: e16.asideTitle,
        info: e16.asideInfo,
        refresh: e16.asideRefresh,
        onRefresh: l[0] || (l[0] = (u) => i("refresh"))
      }, {
        head: withCtx(() => [renderSlot(s.$slots, "aside-toolbar")]),
        foot: withCtx(() => [renderSlot(s.$slots, "aside-foot")]),
        default: withCtx(() => [renderSlot(s.$slots, "aside")]),
        _: 3
      }, 8, ["title", "info", "refresh"])) : createCommentVNode("", true), createBaseVNode("div", b9, [createBaseVNode("div", _9, [createBaseVNode("div", {
        class: "KPageHead-title-container flex items-center",
        onMouseenter: l[2] || (l[2] = () => o.value = true)
      }, [e16.pageIcon ? (openBlock(), createElementBlock("div", w9, [(openBlock(), createBlock(resolveDynamicComponent(unref(a)), {
        size: "24"
      }))])) : createCommentVNode("", true), createBaseVNode("p", T9, toDisplayString(e16.pageTitle), 1), e16.pageIcon ? (openBlock(), createElementBlock("div", C9, [e16.pageInfo ? (openBlock(), createBlock(unref(wa), {
        key: 0,
        content: e16.pageInfo,
        onHide: l[1] || (l[1] = () => o.value = false)
      }, {
        default: withCtx(() => [withDirectives(createVNode(c, {
          color: "#4193f2",
          size: "16"
        }, null, 512), [[vShow, o.value]])]),
        _: 1
      }, 8, ["content"])) : createCommentVNode("", true)])) : createCommentVNode("", true)], 32), createBaseVNode("div", null, [renderSlot(s.$slots, "toolbar")])]), createBaseVNode("div", k9, [renderSlot(s.$slots, "default")])])]);
    };
  }
});
var N9 = $e(S9);
var M9 = defineComponent({
  name: "KDetails",
  __name: "Details",
  props: {
    abstract: {},
    direction: { default: "vertical" },
    showLine: { type: Boolean, default: false },
    useflex: { type: Boolean, default: false }
  },
  setup(e16) {
    const t10 = e16, n = ref(), o = ref();
    onMounted(() => {
      r();
    }), window.addEventListener("resize", r), onUnmounted(() => {
      window.removeEventListener("resize", r);
    });
    function r() {
      if (!n.value) return;
      let a = 1;
      const i = getComputedStyle(n.value).gridTemplateColumns.split(" ");
      for (let s = 1; s < i.length; s++) {
        if (Math.abs(parseInt(i[s]) - parseInt(i[s - 1])) > 2) {
          o.value = a;
          break;
        }
        a++;
      }
      o.value = a;
    }
    return provide("__maxColumn__", o), provide("__parentProps__", t10), (a, i) => (openBlock(), createElementBlock("div", {
      ref_key: "RefKDetails",
      ref: n,
      class: "box k-details w-full h-fit grid grid-cols-1 2xs:grid-cols-2 xs:grid-cols-2 sm:grid-cols-3 base:grid-cols-4 lg:grid-cols-4 xl:grid-cols-5 2xl:grid-cols-6 gap-4"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(a.abstract, (s, l) => (openBlock(), createBlock(Ci, mergeProps({
        key: l,
        ref_for: true
      }, s, {
        "show-line": a.showLine,
        useflex: a.useflex,
        direction: a.direction
      }), null, 16, ["show-line", "useflex", "direction"]))), 128))
    ], 512));
  }
});
var $9 = $e(M9, { DetailsItem: Ci });
var f1 = tn(Ci);
var Vt = (e16, t10) => {
  const { o: n, i: o, u: r } = e16;
  let a = n, i;
  const s = (u, d) => {
    const m = a, p = u, f = d || (o ? !o(m, p) : m !== p);
    return (f || r) && (a = p, i = m), [a, f, i];
  };
  return [t10 ? (u) => s(t10(a, i), u) : s, (u) => [a, !!u, i]];
};
var x9 = typeof window < "u" && typeof HTMLElement < "u" && !!window.document;
var Ft = x9 ? window : {};
var m1 = Math.max;
var I9 = Math.min;
var tl = Math.round;
var Gr = Math.abs;
var Bu = Math.sign;
var p1 = Ft.cancelAnimationFrame;
var nc = Ft.requestAnimationFrame;
var Xr = Ft.setTimeout;
var nl = Ft.clearTimeout;
var ki = (e16) => typeof Ft[e16] < "u" ? Ft[e16] : void 0;
var D9 = ki("MutationObserver");
var Zu = ki("IntersectionObserver");
var Yr = ki("ResizeObserver");
var Nr = ki("ScrollTimeline");
var oc = (e16) => e16 === void 0;
var Si = (e16) => e16 === null;
var Mn = (e16) => typeof e16 == "number";
var ir = (e16) => typeof e16 == "string";
var ac = (e16) => typeof e16 == "boolean";
var ln = (e16) => typeof e16 == "function";
var xn = (e16) => Array.isArray(e16);
var Qr = (e16) => typeof e16 == "object" && !xn(e16) && !Si(e16);
var rc = (e16) => {
  const t10 = !!e16 && e16.length, n = Mn(t10) && t10 > -1 && t10 % 1 == 0;
  return xn(e16) || !ln(e16) && n ? t10 > 0 && Qr(e16) ? t10 - 1 in e16 : true : false;
};
var Jr = (e16) => !!e16 && e16.constructor === Object;
var ei = (e16) => e16 instanceof HTMLElement;
var Ni = (e16) => e16 instanceof Element;
function et(e16, t10) {
  if (rc(e16))
    for (let n = 0; n < e16.length && t10(e16[n], n, e16) !== false; n++)
      ;
  else e16 && et(Object.keys(e16), (n) => t10(e16[n], n, e16));
  return e16;
}
var h1 = (e16, t10) => e16.indexOf(t10) >= 0;
var Xa = (e16, t10) => e16.concat(t10);
var ht = (e16, t10, n) => (!ir(t10) && rc(t10) ? Array.prototype.push.apply(e16, t10) : e16.push(t10), e16);
var so = (e16) => Array.from(e16 || []);
var ic = (e16) => xn(e16) ? e16 : !ir(e16) && rc(e16) ? so(e16) : [e16];
var ol = (e16) => !!e16 && !e16.length;
var al = (e16) => so(new Set(e16));
var Jt = (e16, t10, n) => {
  et(e16, (r) => r ? r.apply(void 0, t10 || []) : true), !n && (e16.length = 0);
};
var g1 = "paddingTop";
var v1 = "paddingRight";
var y1 = "paddingLeft";
var b1 = "paddingBottom";
var _1 = "marginLeft";
var w1 = "marginRight";
var T1 = "marginBottom";
var C1 = "overflowX";
var k1 = "overflowY";
var Mi = "width";
var $i = "height";
var qn = "visible";
var bo = "hidden";
var ma = "scroll";
var A9 = (e16) => {
  const t10 = String(e16 || "");
  return t10 ? t10[0].toUpperCase() + t10.slice(1) : "";
};
var xi = (e16, t10, n, o) => {
  if (e16 && t10) {
    let r = true;
    return et(n, (a) => {
      const i = e16[a], s = t10[a];
      i !== s && (r = false);
    }), r;
  }
  return false;
};
var S1 = (e16, t10) => xi(e16, t10, ["w", "h"]);
var Mr = (e16, t10) => xi(e16, t10, ["x", "y"]);
var E9 = (e16, t10) => xi(e16, t10, ["t", "r", "b", "l"]);
var So = () => {
};
var Me = (e16, ...t10) => e16.bind(0, ...t10);
var Xo = (e16) => {
  let t10;
  const n = e16 ? Xr : nc, o = e16 ? nl : p1;
  return [(r) => {
    o(t10), t10 = n(() => r(), ln(e16) ? e16() : e16);
  }, () => o(t10)];
};
var rl = (e16, t10) => {
  const { _: n, v: o, p: r, S: a } = t10 || {};
  let i, s, l, c, u = So;
  const d = function(g) {
    u(), nl(i), c = i = s = void 0, u = So, e16.apply(this, g);
  }, m = (h10) => a && s ? a(s, h10) : h10, p = () => {
    u !== So && d(m(l) || l);
  }, f = function() {
    const g = so(arguments), v = ln(n) ? n() : n;
    if (Mn(v) && v >= 0) {
      const k = ln(o) ? o() : o, T = Mn(k) && k >= 0, w = v > 0 ? Xr : nc, _ = v > 0 ? nl : p1, x = m(g) || g, R = d.bind(0, x);
      let I;
      u(), r && !c ? (R(), c = true, I = w(() => c = void 0, v)) : (I = w(R, v), T && !i && (i = Xr(p, k))), u = () => _(I), s = l = x;
    } else
      d(g);
  };
  return f.m = p, f;
};
var N1 = (e16, t10) => Object.prototype.hasOwnProperty.call(e16, t10);
var dn = (e16) => e16 ? Object.keys(e16) : [];
var qe = (e16, t10, n, o, r, a, i) => {
  const s = [t10, n, o, r, a, i];
  return (typeof e16 != "object" || Si(e16)) && !ln(e16) && (e16 = {}), et(s, (l) => {
    et(l, (c, u) => {
      const d = l[u];
      if (e16 === d)
        return true;
      const m = xn(d);
      if (d && Jr(d)) {
        const p = e16[u];
        let f = p;
        m && !xn(p) ? f = [] : !m && !Jr(p) && (f = {}), e16[u] = qe(f, d);
      } else
        e16[u] = m ? d.slice() : d;
    });
  }), e16;
};
var M1 = (e16, t10) => et(qe({}, e16), (n, o, r) => {
  n === void 0 ? delete r[o] : n && Jr(n) && (r[o] = M1(n));
});
var sc = (e16) => !dn(e16).length;
var $1 = (e16, t10, n) => m1(e16, I9(t10, n));
var No = (e16) => al((xn(e16) ? e16 : (e16 || "").split(" ")).filter((t10) => t10));
var lc = (e16, t10) => e16 && e16.getAttribute(t10);
var Wu = (e16, t10) => e16 && e16.hasAttribute(t10);
var An = (e16, t10, n) => {
  et(No(t10), (o) => {
    e16 && e16.setAttribute(o, String(n || ""));
  });
};
var vn = (e16, t10) => {
  et(No(t10), (n) => e16 && e16.removeAttribute(n));
};
var Ii = (e16, t10) => {
  const n = No(lc(e16, t10)), o = Me(An, e16, t10), r = (a, i) => {
    const s = new Set(n);
    return et(No(a), (l) => {
      s[i](l);
    }), so(s).join(" ");
  };
  return {
    O: (a) => o(r(a, "delete")),
    $: (a) => o(r(a, "add")),
    C: (a) => {
      const i = No(a);
      return i.reduce((s, l) => s && n.includes(l), i.length > 0);
    }
  };
};
var x1 = (e16, t10, n) => (Ii(e16, t10).O(n), Me(cc, e16, t10, n));
var cc = (e16, t10, n) => (Ii(e16, t10).$(n), Me(x1, e16, t10, n));
var ti = (e16, t10, n, o) => (o ? cc : x1)(e16, t10, n);
var uc = (e16, t10, n) => Ii(e16, t10).C(n);
var I1 = (e16) => Ii(e16, "class");
var D1 = (e16, t10) => {
  I1(e16).O(t10);
};
var dc = (e16, t10) => (I1(e16).$(t10), Me(D1, e16, t10));
var A1 = (e16, t10) => {
  const n = t10 ? Ni(t10) && t10 : document;
  return n ? so(n.querySelectorAll(e16)) : [];
};
var K9 = (e16, t10) => {
  const n = t10 ? Ni(t10) && t10 : document;
  return n && n.querySelector(e16);
};
var il = (e16, t10) => Ni(e16) && e16.matches(t10);
var E1 = (e16) => il(e16, "body");
var sl = (e16) => e16 ? so(e16.childNodes) : [];
var Ya = (e16) => e16 && e16.parentElement;
var Yo = (e16, t10) => Ni(e16) && e16.closest(t10);
var ll = (e16) => document.activeElement;
var z9 = (e16, t10, n) => {
  const o = Yo(e16, t10), r = e16 && K9(n, o), a = Yo(r, t10) === o;
  return o && r ? o === e16 || r === e16 || a && Yo(Yo(e16, n), t10) !== o : false;
};
var pa = (e16) => {
  et(ic(e16), (t10) => {
    const n = Ya(t10);
    t10 && n && n.removeChild(t10);
  });
};
var Gt = (e16, t10) => Me(pa, e16 && t10 && et(ic(t10), (n) => {
  n && e16.appendChild(n);
}));
var oa = (e16) => {
  const t10 = document.createElement("div");
  return An(t10, "class", e16), t10;
};
var K1 = (e16) => {
  const t10 = oa();
  return t10.innerHTML = e16.trim(), et(sl(t10), (n) => pa(n));
};
var qu = (e16, t10) => e16.getPropertyValue(t10) || e16[t10] || "";
var z1 = (e16) => {
  const t10 = e16 || 0;
  return isFinite(t10) ? t10 : 0;
};
var yr = (e16) => z1(parseFloat(e16 || ""));
var cl = (e16) => Math.round(e16 * 1e4) / 1e4;
var P1 = (e16) => `${cl(z1(e16))}px`;
function Qa(e16, t10) {
  e16 && t10 && et(t10, (n, o) => {
    try {
      const r = e16.style, a = Si(n) || ac(n) ? "" : Mn(n) ? P1(n) : n;
      o.indexOf("--") === 0 ? r.setProperty(o, a) : r[o] = a;
    } catch {
    }
  });
}
function Ln(e16, t10, n) {
  const o = ir(t10);
  let r = o ? "" : {};
  if (e16) {
    const a = Ft.getComputedStyle(e16, n) || e16.style;
    r = o ? qu(a, t10) : so(t10).reduce((i, s) => (i[s] = qu(a, s), i), r);
  }
  return r;
}
var Vu = (e16, t10, n) => {
  const o = t10 ? `${t10}-` : "", r = n ? `-${n}` : "", a = `${o}top${r}`, i = `${o}right${r}`, s = `${o}bottom${r}`, l = `${o}left${r}`, c = Ln(e16, [a, i, s, l]);
  return {
    t: yr(c[a]),
    r: yr(c[i]),
    b: yr(c[s]),
    l: yr(c[l])
  };
};
var P9 = (e16, t10) => `translate${Qr(e16) ? `(${e16.x},${e16.y})` : `Y(${e16})`}`;
var R9 = (e16) => !!(e16.offsetWidth || e16.offsetHeight || e16.getClientRects().length);
var L9 = {
  w: 0,
  h: 0
};
var Di = (e16, t10) => t10 ? {
  w: t10[`${e16}Width`],
  h: t10[`${e16}Height`]
} : L9;
var F9 = (e16) => Di("inner", e16 || Ft);
var aa = Me(Di, "offset");
var R1 = Me(Di, "client");
var ni = Me(Di, "scroll");
var fc = (e16) => {
  const t10 = parseFloat(Ln(e16, Mi)) || 0, n = parseFloat(Ln(e16, $i)) || 0;
  return {
    w: t10 - tl(t10),
    h: n - tl(n)
  };
};
var Ts = (e16) => e16.getBoundingClientRect();
var j9 = (e16) => !!e16 && R9(e16);
var ul = (e16) => !!(e16 && (e16[$i] || e16[Mi]));
var L1 = (e16, t10) => {
  const n = ul(e16);
  return !ul(t10) && n;
};
var Hu = (e16, t10, n, o) => {
  et(No(t10), (r) => {
    e16 && e16.removeEventListener(r, n, o);
  });
};
var ut = (e16, t10, n, o) => {
  var r;
  const a = (r = o && o.H) != null ? r : true, i = o && o.I || false, s = o && o.A || false, l = {
    passive: a,
    capture: i
  };
  return Me(Jt, No(t10).map((c) => {
    const u = s ? (d) => {
      Hu(e16, c, u, i), n && n(d);
    } : n;
    return e16 && e16.addEventListener(c, u, l), Me(Hu, e16, c, u, i);
  }));
};
var F1 = (e16) => e16.stopPropagation();
var dl = (e16) => e16.preventDefault();
var j1 = (e16) => F1(e16) || dl(e16);
var Cn = (e16, t10) => {
  const { x: n, y: o } = Mn(t10) ? {
    x: t10,
    y: t10
  } : t10 || {};
  Mn(n) && (e16.scrollLeft = n), Mn(o) && (e16.scrollTop = o);
};
var Xt = (e16) => ({
  x: e16.scrollLeft,
  y: e16.scrollTop
});
var O1 = () => ({
  D: {
    x: 0,
    y: 0
  },
  M: {
    x: 0,
    y: 0
  }
});
var O9 = (e16, t10) => {
  const { D: n, M: o } = e16, { w: r, h: a } = t10, i = (d, m, p) => {
    let f = Bu(d) * p, h10 = Bu(m) * p;
    if (f === h10) {
      const g = Gr(d), v = Gr(m);
      h10 = g > v ? 0 : h10, f = g < v ? 0 : f;
    }
    return f = f === h10 ? 0 : f, [f + 0, h10 + 0];
  }, [s, l] = i(n.x, o.x, r), [c, u] = i(n.y, o.y, a);
  return {
    D: {
      x: s,
      y: c
    },
    M: {
      x: l,
      y: u
    }
  };
};
var Uu = ({ D: e16, M: t10 }) => {
  const n = (o, r) => o === 0 && o <= r;
  return {
    x: n(e16.x, t10.x),
    y: n(e16.y, t10.y)
  };
};
var Gu = ({ D: e16, M: t10 }, n) => {
  const o = (r, a, i) => $1(0, 1, (r - i) / (r - a) || 0);
  return {
    x: o(e16.x, t10.x, n.x),
    y: o(e16.y, t10.y, n.y)
  };
};
var fl = (e16) => {
  e16 && e16.focus && e16.focus({
    preventScroll: true
  });
};
var Xu = (e16, t10) => {
  et(ic(t10), e16);
};
var ml = (e16) => {
  const t10 = /* @__PURE__ */ new Map(), n = (a, i) => {
    if (a) {
      const s = t10.get(a);
      Xu((l) => {
        s && s[l ? "delete" : "clear"](l);
      }, i);
    } else
      t10.forEach((s) => {
        s.clear();
      }), t10.clear();
  }, o = (a, i) => {
    if (ir(a)) {
      const c = t10.get(a) || /* @__PURE__ */ new Set();
      return t10.set(a, c), Xu((u) => {
        ln(u) && c.add(u);
      }, i), Me(n, a, i);
    }
    ac(i) && i && n();
    const s = dn(a), l = [];
    return et(s, (c) => {
      const u = a[c];
      u && ht(l, o(c, u));
    }), Me(Jt, l);
  }, r = (a, i) => {
    et(so(t10.get(a)), (s) => {
      i && !ol(i) ? s.apply(0, i) : s();
    });
  };
  return o(e16 || {}), [o, n, r];
};
var Yu = (e16) => JSON.stringify(e16, (t10, n) => {
  if (ln(n))
    throw 0;
  return n;
});
var Qu = (e16, t10) => e16 ? `${t10}`.split(".").reduce((n, o) => n && N1(n, o) ? n[o] : void 0, e16) : void 0;
var B9 = {
  paddingAbsolute: false,
  showNativeOverlaidScrollbars: false,
  update: {
    elementEvents: [["img", "load"]],
    debounce: [0, 33],
    attributes: null,
    ignoreMutation: null
  },
  overflow: {
    x: "scroll",
    y: "scroll"
  },
  scrollbars: {
    theme: "os-theme-dark",
    visibility: "auto",
    autoHide: "never",
    autoHideDelay: 1300,
    autoHideSuspend: false,
    dragScroll: true,
    clickScroll: false,
    pointers: ["mouse", "touch", "pen"]
  }
};
var B1 = (e16, t10) => {
  const n = {}, o = Xa(dn(t10), dn(e16));
  return et(o, (r) => {
    const a = e16[r], i = t10[r];
    if (Qr(a) && Qr(i))
      qe(n[r] = {}, B1(a, i)), sc(n[r]) && delete n[r];
    else if (N1(t10, r) && i !== a) {
      let s = true;
      if (xn(a) || xn(i))
        try {
          Yu(a) === Yu(i) && (s = false);
        } catch {
        }
      s && (n[r] = i);
    }
  }), n;
};
var Ju = (e16, t10, n) => (o) => [Qu(e16, o), n || Qu(t10, o) !== void 0];
var Ca = "data-overlayscrollbars";
var $r = "os-environment";
var br = `${$r}-scrollbar-hidden`;
var Cs = `${Ca}-initialize`;
var xr = "noClipping";
var e0 = `${Ca}-body`;
var Qn = Ca;
var Z9 = "host";
var En = `${Ca}-viewport`;
var W9 = C1;
var q9 = k1;
var V9 = "arrange";
var Z1 = "measuring";
var H9 = "scrolling";
var W1 = "scrollbarHidden";
var U9 = "noContent";
var pl = `${Ca}-padding`;
var t0 = `${Ca}-content`;
var mc = "os-size-observer";
var G9 = `${mc}-appear`;
var X9 = `${mc}-listener`;
var Y9 = "os-trinsic-observer";
var Q9 = "os-theme-none";
var nn = "os-scrollbar";
var J9 = `${nn}-rtl`;
var e72 = `${nn}-horizontal`;
var t7 = `${nn}-vertical`;
var q1 = `${nn}-track`;
var pc = `${nn}-handle`;
var n7 = `${nn}-visible`;
var o7 = `${nn}-cornerless`;
var n0 = `${nn}-interaction`;
var o0 = `${nn}-unusable`;
var hl = `${nn}-auto-hide`;
var a0 = `${hl}-hidden`;
var r0 = `${nn}-wheel`;
var a7 = `${q1}-interactive`;
var r7 = `${pc}-interactive`;
var V1;
var i7 = () => V1;
var s7 = (e16) => {
  V1 = e16;
};
var ks;
var l7 = () => {
  const e16 = (T, w, _) => {
    Gt(document.body, T), Gt(document.body, T);
    const M = R1(T), x = aa(T), R = fc(w);
    return _ && pa(T), {
      x: x.h - M.h + R.h,
      y: x.w - M.w + R.w
    };
  }, t10 = (T) => {
    let w = false;
    const _ = dc(T, br);
    try {
      w = Ln(T, "scrollbar-width") === "none" || Ln(T, "display", "::-webkit-scrollbar") === "none";
    } catch {
    }
    return _(), w;
  }, n = `.${$r}{scroll-behavior:auto!important;position:fixed;opacity:0;visibility:hidden;overflow:scroll;height:200px;width:200px;z-index:-1}.${$r} div{width:200%;height:200%;margin:10px 0}.${br}{scrollbar-width:none!important}.${br}::-webkit-scrollbar,.${br}::-webkit-scrollbar-corner{appearance:none!important;display:none!important;width:0!important;height:0!important}`, r = K1(`<div class="${$r}"><div></div><style>${n}</style></div>`)[0], a = r.firstChild, i = r.lastChild, s = i7();
  s && (i.nonce = s);
  const [l, , c] = ml(), [u, d] = Vt({
    o: e16(r, a),
    i: Mr
  }, Me(e16, r, a, true)), [m] = d(), p = t10(r), f = {
    x: m.x === 0,
    y: m.y === 0
  }, h10 = {
    elements: {
      host: null,
      padding: !p,
      viewport: (T) => p && E1(T) && T,
      content: false
    },
    scrollbars: {
      slot: true
    },
    cancel: {
      nativeScrollbarsOverlaid: false,
      body: null
    }
  }, g = qe({}, B9), v = Me(qe, {}, g), y = Me(qe, {}, h10), k = {
    T: m,
    k: f,
    R: p,
    V: !!Nr,
    L: Me(l, "r"),
    U: y,
    P: (T) => qe(h10, T) && y(),
    N: v,
    q: (T) => qe(g, T) && v(),
    B: qe({}, h10),
    F: qe({}, g)
  };
  if (vn(r, "style"), pa(r), ut(Ft, "resize", () => {
    c("r", []);
  }), ln(Ft.matchMedia) && !p && (!f.x || !f.y)) {
    const T = (w) => {
      const _ = Ft.matchMedia(`(resolution: ${Ft.devicePixelRatio}dppx)`);
      ut(_, "change", () => {
        w(), T(w);
      }, {
        A: true
      });
    };
    T(() => {
      const [w, _] = u();
      qe(k.T, w), c("r", [_]);
    });
  }
  return k;
};
var In = () => (ks || (ks = l7()), ks);
var H1 = (e16, t10) => ln(t10) ? t10.apply(0, e16) : t10;
var c7 = (e16, t10, n, o) => {
  const r = oc(o) ? n : o;
  return H1(e16, r) || t10.apply(0, e16);
};
var U1 = (e16, t10, n, o) => {
  const r = oc(o) ? n : o, a = H1(e16, r);
  return !!a && (ei(a) ? a : t10.apply(0, e16));
};
var u7 = (e16, t10) => {
  const { nativeScrollbarsOverlaid: n, body: o } = t10 || {}, { k: r, R: a, U: i } = In(), { nativeScrollbarsOverlaid: s, body: l } = i().cancel, c = n ?? s, u = oc(o) ? l : o, d = (r.x || r.y) && c, m = e16 && (Si(u) ? !a : u);
  return !!d || !!m;
};
var hc = /* @__PURE__ */ new WeakMap();
var d7 = (e16, t10) => {
  hc.set(e16, t10);
};
var f7 = (e16) => {
  hc.delete(e16);
};
var G1 = (e16) => hc.get(e16);
var m7 = (e16, t10, n) => {
  let o = false;
  const r = n ? /* @__PURE__ */ new WeakMap() : false, a = () => {
    o = true;
  }, i = (s) => {
    if (r && n) {
      const l = n.map((c) => {
        const [u, d] = c || [];
        return [d && u ? (s || A1)(u, e16) : [], d];
      });
      et(l, (c) => et(c[0], (u) => {
        const d = c[1], m = r.get(u) || [];
        if (e16.contains(u) && d) {
          const f = ut(u, d, (h10) => {
            o ? (f(), r.delete(u)) : t10(h10);
          });
          r.set(u, ht(m, f));
        } else
          Jt(m), r.delete(u);
      }));
    }
  };
  return i(), [a, i];
};
var i0 = (e16, t10, n, o) => {
  let r = false;
  const { j: a, X: i, Y: s, W: l, J: c, G: u } = o || {}, d = rl(() => r && n(true), {
    _: 33,
    v: 99
  }), [m, p] = m7(e16, d, s), f = a || [], h10 = i || [], g = Xa(f, h10), v = (k, T) => {
    if (!ol(T)) {
      const w = c || So, _ = u || So, M = [], x = [];
      let R = false, I = false;
      if (et(T, (P) => {
        const { attributeName: F, target: N, type: j, oldValue: z, addedNodes: A, removedNodes: B } = P, D = j === "attributes", te = j === "childList", ie = e16 === N, U = D && F, oe = U && lc(N, F || ""), se = ir(oe) ? oe : null, E = U && z !== se, K = h1(h10, F) && E;
        if (t10 && (te || !ie)) {
          const ee = D && E, V = ee && l && il(N, l), pe = (V ? !w(N, F, z, se) : !D || ee) && !_(P, !!V, e16, o);
          et(A, (Te) => ht(M, Te)), et(B, (Te) => ht(M, Te)), I = I || pe;
        }
        !t10 && ie && E && !w(N, F, z, se) && (ht(x, F), R = R || K);
      }), p((P) => al(M).reduce((F, N) => (ht(F, A1(P, N)), il(N, P) ? ht(F, N) : F), [])), t10)
        return !k && I && n(false), [false];
      if (!ol(x) || R) {
        const P = [al(x), R];
        return !k && n.apply(0, P), P;
      }
    }
  }, y = new D9(Me(v, false));
  return [() => (y.observe(e16, {
    attributes: true,
    attributeOldValue: true,
    attributeFilter: g,
    subtree: t10,
    childList: t10,
    characterData: t10
  }), r = true, () => {
    r && (m(), y.disconnect(), r = false);
  }), () => {
    if (r)
      return d.m(), v(true, y.takeRecords());
  }];
};
var X1 = {};
var Y1 = {};
var p7 = (e16) => {
  et(e16, (t10) => et(t10, (n, o) => {
    X1[o] = t10[o];
  }));
};
var Q1 = (e16, t10, n) => dn(e16).map((o) => {
  const { static: r, instance: a } = e16[o], [i, s, l] = n || [], c = n ? a : r;
  if (c) {
    const u = n ? c(i, s, t10) : c(t10);
    return (l || Y1)[o] = u;
  }
});
var sr = (e16) => Y1[e16];
var h7 = "__osOptionsValidationPlugin";
var g7 = "__osSizeObserverPlugin";
var v7 = (e16, t10) => {
  const { k: n } = t10, [o, r] = e16("showNativeOverlaidScrollbars");
  return [o && n.x && n.y, r];
};
var ha = (e16) => e16.indexOf(qn) === 0;
var y7 = (e16, t10) => {
  const n = (r, a, i, s) => {
    const l = r === qn ? bo : r.replace(`${qn}-`, ""), c = ha(r), u = ha(i);
    return !a && !s ? bo : c && u ? qn : c ? a && s ? l : a ? qn : bo : a ? l : u && s ? qn : bo;
  }, o = {
    x: n(t10.x, e16.x, t10.y, e16.y),
    y: n(t10.y, e16.y, t10.x, e16.x)
  };
  return {
    K: o,
    Z: {
      x: o.x === ma,
      y: o.y === ma
    }
  };
};
var J1 = "__osScrollbarsHidingPlugin";
var b7 = "__osClickScrollPlugin";
var em = (e16, t10, n) => {
  const { dt: o } = n || {}, r = sr(g7), [a] = Vt({
    o: false,
    u: true
  });
  return () => {
    const i = [], l = K1(`<div class="${mc}"><div class="${X9}"></div></div>`)[0], c = l.firstChild, u = (d) => {
      const m = d instanceof ResizeObserverEntry;
      let p = false, f = false;
      if (m) {
        const [h10, , g] = a(d.contentRect), v = ul(h10);
        f = L1(h10, g), p = !f && !v;
      } else
        f = d === true;
      p || t10({
        ft: true,
        dt: f
      });
    };
    if (Yr) {
      const d = new Yr((m) => u(m.pop()));
      d.observe(c), ht(i, () => {
        d.disconnect();
      });
    } else if (r) {
      const [d, m] = r(c, u, o);
      ht(i, Xa([dc(l, G9), ut(l, "animationstart", d)], m));
    } else
      return So;
    return Me(Jt, ht(i, Gt(e16, l)));
  };
};
var _7 = (e16, t10) => {
  let n;
  const o = (l) => l.h === 0 || l.isIntersecting || l.intersectionRatio > 0, r = oa(Y9), [a] = Vt({
    o: false
  }), i = (l, c) => {
    if (l) {
      const u = a(o(l)), [, d] = u;
      return d && !c && t10(u) && [u];
    }
  }, s = (l, c) => i(c.pop(), l);
  return [() => {
    const l = [];
    if (Zu)
      n = new Zu(Me(s, false), {
        root: e16
      }), n.observe(r), ht(l, () => {
        n.disconnect();
      });
    else {
      const c = () => {
        const u = aa(r);
        i(u);
      };
      ht(l, em(r, c)()), c();
    }
    return Me(Jt, ht(l, Gt(e16, r)));
  }, () => n && s(true, n.takeRecords())];
};
var w7 = (e16, t10, n, o) => {
  let r, a, i, s, l, c;
  const u = `[${Qn}]`, d = `[${En}]`, m = ["id", "class", "style", "open", "wrap", "cols", "rows"], { vt: p, ht: f, ot: h10, gt: g, bt: v, nt: y, wt: k, yt: T, St: w, Ot: _ } = e16, M = (K) => Ln(K, "direction") === "rtl", x = {
    $t: false,
    ct: M(p)
  }, R = In(), I = sr(J1), [P] = Vt({
    i: S1,
    o: {
      w: 0,
      h: 0
    }
  }, () => {
    const K = I && I.tt(e16, t10, x, R, n).ut, V = !(k && y) && uc(f, Qn, xr), le = !y && T(V9), pe = le && Xt(g), Te = pe && _(), Z = w(Z1, V), X = le && K && K()[0], Q = ni(h10), W = fc(h10);
    return X && X(), Cn(g, pe), Te && Te(), V && Z(), {
      w: Q.w + W.w,
      h: Q.h + W.h
    };
  }), F = rl(o, {
    _: () => r,
    v: () => a,
    S(K, ee) {
      const [V] = K, [le] = ee;
      return [Xa(dn(V), dn(le)).reduce((pe, Te) => (pe[Te] = V[Te] || le[Te], pe), {})];
    }
  }), N = (K) => {
    const ee = M(p);
    qe(K, {
      Ct: c !== ee
    }), qe(x, {
      ct: ee
    }), c = ee;
  }, j = (K, ee) => {
    const [V, le] = K, pe = {
      xt: le
    };
    return qe(x, {
      $t: V
    }), !ee && o(pe), pe;
  }, z = ({ ft: K, dt: ee }) => {
    const le = !(K && !ee) && R.R ? F : o, pe = {
      ft: K || ee,
      dt: ee
    };
    N(pe), le(pe);
  }, A = (K, ee) => {
    const [, V] = P(), le = {
      Ht: V
    };
    return N(le), V && !ee && (K ? o : F)(le), le;
  }, B = (K, ee, V) => {
    const le = {
      Et: ee
    };
    return N(le), ee && !V && F(le), le;
  }, [D, te] = v ? _7(f, j) : [], ie = !y && em(f, z, {
    dt: true
  }), [U, oe] = i0(f, false, B, {
    X: m,
    j: m
  }), se = y && Yr && new Yr((K) => {
    const ee = K[K.length - 1].contentRect;
    z({
      ft: true,
      dt: L1(ee, l)
    }), l = ee;
  }), E = rl(() => {
    const [, K] = P();
    o({
      Ht: K
    });
  }, {
    _: 222,
    p: true
  });
  return [() => {
    se && se.observe(f);
    const K = ie && ie(), ee = D && D(), V = U(), le = R.L((pe) => {
      pe ? F({
        zt: pe
      }) : E();
    });
    return () => {
      se && se.disconnect(), K && K(), ee && ee(), s && s(), V(), le();
    };
  }, ({ It: K, At: ee, Dt: V }) => {
    const le = {}, [pe] = K("update.ignoreMutation"), [Te, Z] = K("update.attributes"), [X, Q] = K("update.elementEvents"), [W, de] = K("update.debounce"), Ne = Q || Z, Pe = ee || V, tt = (Qe) => ln(pe) && pe(Qe);
    if (Ne) {
      i && i(), s && s();
      const [Qe, lt] = i0(v || h10, true, A, {
        j: Xa(m, Te || []),
        Y: X,
        W: u,
        G: (Be, Xe) => {
          const { target: it, attributeName: St } = Be;
          return (!Xe && St && !y ? z9(it, u, d) : false) || !!Yo(it, `.${nn}`) || !!tt(Be);
        }
      });
      s = Qe(), i = lt;
    }
    if (de)
      if (F.m(), xn(W)) {
        const Qe = W[0], lt = W[1];
        r = Mn(Qe) && Qe, a = Mn(lt) && lt;
      } else Mn(W) ? (r = W, a = false) : (r = false, a = false);
    if (Pe) {
      const Qe = oe(), lt = te && te(), Be = i && i();
      Qe && qe(le, B(Qe[0], Qe[1], Pe)), lt && qe(le, j(lt[0], Pe)), Be && qe(le, A(Be[0], Pe));
    }
    return N(le), le;
  }, x];
};
var T7 = (e16, t10, n, o) => {
  const r = "--os-viewport-percent", a = "--os-scroll-percent", i = "--os-scroll-direction", { U: s } = In(), { scrollbars: l } = s(), { slot: c } = l, { vt: u, ht: d, ot: m, Mt: p, gt: f, wt: h10, nt: g } = t10, { scrollbars: v } = p ? {} : e16, { slot: y } = v || {}, k = [], T = [], w = [], _ = U1([u, d, m], () => g && h10 ? u : d, c, y), M = (U) => {
    if (Nr) {
      const oe = new Nr({
        source: f,
        axis: U
      });
      return {
        kt: (E) => {
          const K = E.Tt.animate({
            clear: ["left"],
            [a]: [0, 1]
          }, {
            timeline: oe
          });
          return () => K.cancel();
        }
      };
    }
  }, x = {
    x: M("x"),
    y: M("y")
  }, R = () => {
    const { Rt: U, Vt: oe } = n, se = (E, K) => $1(0, 1, E / (E + K) || 0);
    return {
      x: se(oe.x, U.x),
      y: se(oe.y, U.y)
    };
  }, I = (U, oe, se) => {
    const E = se ? dc : D1;
    et(U, (K) => {
      E(K.Tt, oe);
    });
  }, P = (U, oe) => {
    et(U, (se) => {
      const [E, K] = oe(se);
      Qa(E, K);
    });
  }, F = (U, oe, se) => {
    const E = ac(se), K = E ? se : true, ee = E ? !se : true;
    K && I(T, U, oe), ee && I(w, U, oe);
  }, N = () => {
    const U = R(), oe = (se) => (E) => [E.Tt, {
      [r]: cl(se) + ""
    }];
    P(T, oe(U.x)), P(w, oe(U.y));
  }, j = () => {
    if (!Nr) {
      const { Lt: U } = n, oe = Gu(U, Xt(f)), se = (E) => (K) => [K.Tt, {
        [a]: cl(E) + ""
      }];
      P(T, se(oe.x)), P(w, se(oe.y));
    }
  }, z = () => {
    const { Lt: U } = n, oe = Uu(U), se = (E) => (K) => [K.Tt, {
      [i]: E ? "0" : "1"
    }];
    P(T, se(oe.x)), P(w, se(oe.y));
  }, A = () => {
    if (g && !h10) {
      const { Rt: U, Lt: oe } = n, se = Uu(oe), E = Gu(oe, Xt(f)), K = (ee) => {
        const { Tt: V } = ee, le = Ya(V) === m && V, pe = (Te, Z, X) => {
          const Q = Z * Te;
          return P1(X ? Q : -Q);
        };
        return [le, le && {
          transform: P9({
            x: pe(E.x, U.x, se.x),
            y: pe(E.y, U.y, se.y)
          })
        }];
      };
      P(T, K), P(w, K);
    }
  }, B = (U) => {
    const oe = U ? "x" : "y", E = oa(`${nn} ${U ? e72 : t7}`), K = oa(q1), ee = oa(pc), V = {
      Tt: E,
      Ut: K,
      Pt: ee
    }, le = x[oe];
    return ht(U ? T : w, V), ht(k, [Gt(E, K), Gt(K, ee), Me(pa, E), le && le.kt(V), o(V, F, U)]), V;
  }, D = Me(B, true), te = Me(B, false), ie = () => (Gt(_, T[0].Tt), Gt(_, w[0].Tt), Me(Jt, k));
  return D(), te(), [{
    Nt: N,
    qt: j,
    Bt: z,
    Ft: A,
    jt: F,
    Xt: {
      Yt: T,
      Wt: D,
      Jt: Me(P, T)
    },
    Gt: {
      Yt: w,
      Wt: te,
      Jt: Me(P, w)
    }
  }, ie];
};
var C7 = (e16, t10, n, o) => (r, a, i) => {
  const { ht: s, ot: l, nt: c, gt: u, Kt: d, Ot: m } = t10, { Tt: p, Ut: f, Pt: h10 } = r, [g, v] = Xo(333), [y, k] = Xo(444), T = (M) => {
    ln(u.scrollBy) && u.scrollBy({
      behavior: "smooth",
      left: M.x,
      top: M.y
    });
  }, w = () => {
    const M = "pointerup pointercancel lostpointercapture", x = `client${i ? "X" : "Y"}`, R = i ? Mi : $i, I = i ? "left" : "top", P = i ? "w" : "h", F = i ? "x" : "y", N = (z, A) => (B) => {
      const { Rt: D } = n, te = aa(f)[P] - aa(h10)[P], U = A * B / te * D[F];
      Cn(u, {
        [F]: z + U
      });
    }, j = [];
    return ut(f, "pointerdown", (z) => {
      const A = Yo(z.target, `.${pc}`) === h10, B = A ? h10 : f, D = e16.scrollbars, te = D[A ? "dragScroll" : "clickScroll"], { button: ie, isPrimary: U, pointerType: oe } = z, { pointers: se } = D;
      if (ie === 0 && U && te && (se || []).includes(oe)) {
        Jt(j), k();
        const K = !A && (z.shiftKey || te === "instant"), ee = Me(Ts, h10), V = Me(Ts, f), le = (Xe, it) => (Xe || ee())[I] - (it || V())[I], pe = tl(Ts(u)[R]) / aa(u)[P] || 1, Te = N(Xt(u)[F], 1 / pe), Z = z[x], X = ee(), Q = V(), W = X[R], de = le(X, Q) + W / 2, Ne = Z - Q[I], Pe = A ? 0 : Ne - de, tt = (Xe) => {
          Jt(Be), B.releasePointerCapture(Xe.pointerId);
        }, Qe = A || K, lt = m(), Be = [ut(d, M, tt), ut(d, "selectstart", (Xe) => dl(Xe), {
          H: false
        }), ut(f, M, tt), Qe && ut(f, "pointermove", (Xe) => Te(Pe + (Xe[x] - Z))), Qe && (() => {
          const Xe = Xt(u);
          lt();
          const it = Xt(u), St = {
            x: it.x - Xe.x,
            y: it.y - Xe.y
          };
          (Gr(St.x) > 3 || Gr(St.y) > 3) && (m(), Cn(u, Xe), T(St), y(lt));
        })];
        if (B.setPointerCapture(z.pointerId), K)
          Te(Pe);
        else if (!A) {
          const Xe = sr(b7);
          if (Xe) {
            const it = Xe(Te, Pe, W, (St) => {
              St ? lt() : ht(Be, lt);
            });
            ht(Be, it), ht(j, Me(it, true));
          }
        }
      }
    });
  };
  let _ = true;
  return Me(Jt, [ut(h10, "pointermove pointerleave", o), ut(p, "pointerenter", () => {
    a(n0, true);
  }), ut(p, "pointerleave pointercancel", () => {
    a(n0, false);
  }), !c && ut(p, "mousedown", () => {
    const M = ll();
    (Wu(M, En) || Wu(M, Qn) || M === document.body) && Xr(Me(fl, l), 25);
  }), ut(p, "wheel", (M) => {
    const { deltaX: x, deltaY: R, deltaMode: I } = M;
    _ && I === 0 && Ya(p) === s && T({
      x,
      y: R
    }), _ = false, a(r0, true), g(() => {
      _ = true, a(r0);
    }), dl(M);
  }, {
    H: false,
    I: true
  }), ut(p, "pointerdown", Me(ut, d, "click", j1, {
    A: true,
    I: true,
    H: false
  }), {
    I: true
  }), w(), v, k]);
};
var k7 = (e16, t10, n, o, r, a) => {
  let i, s, l, c, u, d = So, m = 0;
  const p = (U) => U.pointerType === "mouse", [f, h10] = Xo(), [g, v] = Xo(100), [y, k] = Xo(100), [T, w] = Xo(() => m), [_, M] = T7(e16, r, o, C7(t10, r, o, (U) => p(U) && B())), { ht: x, Qt: R, wt: I } = r, { jt: P, Nt: F, qt: N, Bt: j, Ft: z } = _, A = (U, oe) => {
    if (w(), U)
      P(a0);
    else {
      const se = Me(P, a0, true);
      m > 0 && !oe ? T(se) : se();
    }
  }, B = () => {
    (l ? !i : !c) && (A(true), g(() => {
      A(false);
    }));
  }, D = (U) => {
    P(hl, U, true), P(hl, U, false);
  }, te = (U) => {
    p(U) && (i = l, l && A(true));
  }, ie = [w, v, k, h10, () => d(), ut(x, "pointerover", te, {
    A: true
  }), ut(x, "pointerenter", te), ut(x, "pointerleave", (U) => {
    p(U) && (i = false, l && A(false));
  }), ut(x, "pointermove", (U) => {
    p(U) && s && B();
  }), ut(R, "scroll", (U) => {
    f(() => {
      N(), B();
    }), a(U), z();
  })];
  return [() => Me(Jt, ht(ie, M())), ({ It: U, Dt: oe, Zt: se, tn: E }) => {
    const { nn: K, sn: ee, en: V, cn: le } = E || {}, { Ct: pe, dt: Te } = se || {}, { ct: Z } = n, { k: X } = In(), { K: Q, rn: W } = o, [de, Ne] = U("showNativeOverlaidScrollbars"), [Pe, tt] = U("scrollbars.theme"), [Qe, lt] = U("scrollbars.visibility"), [Be, Xe] = U("scrollbars.autoHide"), [it, St] = U("scrollbars.autoHideSuspend"), [pn] = U("scrollbars.autoHideDelay"), [hn, cn] = U("scrollbars.dragScroll"), [ne, ae] = U("scrollbars.clickScroll"), [he, xe] = U("overflow"), Ee = Te && !oe, Ve = W.x || W.y, Je = K || ee || le || pe || oe, Ie = V || lt || xe, Nt = de && X.x && X.y, bt = (Ze, un, jo) => {
      const lo = Ze.includes(ma) && (Qe === qn || Qe === "auto" && un === ma);
      return P(n7, lo, jo), lo;
    };
    if (m = pn, Ee && (it && Ve ? (D(false), d(), y(() => {
      d = ut(R, "scroll", Me(D, true), {
        A: true
      });
    })) : D(true)), Ne && P(Q9, Nt), tt && (P(u), P(Pe, true), u = Pe), St && !it && D(true), Xe && (s = Be === "move", l = Be === "leave", c = Be === "never", A(c, true)), cn && P(r7, hn), ae && P(a7, !!ne), Ie) {
      const Ze = bt(he.x, Q.x, true), un = bt(he.y, Q.y, false);
      P(o7, !(Ze && un));
    }
    Je && (N(), F(), z(), le && j(), P(o0, !W.x, true), P(o0, !W.y, false), P(J9, Z && !I));
  }, {}, _];
};
var S7 = (e16) => {
  const t10 = In(), { U: n, R: o } = t10, { elements: r } = n(), { padding: a, viewport: i, content: s } = r, l = ei(e16), c = l ? {} : e16, { elements: u } = c, { padding: d, viewport: m, content: p } = u || {}, f = l ? e16 : c.target, h10 = E1(f), g = f.ownerDocument, v = g.documentElement, y = () => g.defaultView || Ft, k = Me(c7, [f]), T = Me(U1, [f]), w = Me(oa, ""), _ = Me(k, w, i), M = Me(T, w, s), x = (W) => {
    const de = aa(W), Ne = ni(W), Pe = Ln(W, C1), tt = Ln(W, k1);
    return Ne.w - de.w > 0 && !ha(Pe) || Ne.h - de.h > 0 && !ha(tt);
  }, R = _(m), I = R === f, P = I && h10, F = !I && M(p), N = !I && R === F, j = P ? v : R, z = P ? j : f, A = !I && T(w, a, d), B = !N && F, D = [B, j, A, z].map((W) => ei(W) && !Ya(W) && W), te = (W) => W && h1(D, W), ie = !te(j) && x(j) ? j : f, U = P ? v : j, se = {
    vt: f,
    ht: z,
    ot: j,
    ln: A,
    bt: B,
    gt: U,
    Qt: P ? g : j,
    an: h10 ? v : ie,
    Kt: g,
    wt: h10,
    Mt: l,
    nt: I,
    un: y,
    yt: (W) => uc(j, En, W),
    St: (W, de) => ti(j, En, W, de),
    Ot: () => ti(U, En, H9, true)
  }, { vt: E, ht: K, ln: ee, ot: V, bt: le } = se, pe = [() => {
    vn(K, [Qn, Cs]), vn(E, Cs), h10 && vn(v, [Cs, Qn]);
  }];
  let Te = sl([le, V, ee, K, E].find((W) => W && !te(W)));
  const Z = P ? E : le || V, X = Me(Jt, pe);
  return [se, () => {
    const W = y(), de = ll(), Ne = (Be) => {
      Gt(Ya(Be), sl(Be)), pa(Be);
    }, Pe = (Be) => ut(Be, "focusin focusout focus blur", j1, {
      I: true,
      H: false
    }), tt = "tabindex", Qe = lc(V, tt), lt = Pe(de);
    return An(K, Qn, I ? "" : Z9), An(ee, pl, ""), An(V, En, ""), An(le, t0, ""), I || (An(V, tt, Qe || "-1"), h10 && An(v, e0, "")), Gt(Z, Te), Gt(K, ee), Gt(ee || K, !I && V), Gt(V, le), ht(pe, [lt, () => {
      const Be = ll(), Xe = te(V), it = Xe && Be === V ? E : Be, St = Pe(it);
      vn(ee, pl), vn(le, t0), vn(V, En), h10 && vn(v, e0), Qe ? An(V, tt, Qe) : vn(V, tt), te(le) && Ne(le), Xe && Ne(V), te(ee) && Ne(ee), fl(it), St();
    }]), o && !I && (cc(V, En, W1), ht(pe, Me(vn, V, En))), fl(!I && h10 && de === E && W.top === W ? V : de), lt(), Te = 0, X;
  }, X];
};
var N7 = ({ bt: e16 }) => ({ Zt: t10, _n: n, Dt: o }) => {
  const { xt: r } = t10 || {}, { $t: a } = n;
  e16 && (r || o) && Qa(e16, {
    [$i]: a && "100%"
  });
};
var M7 = ({ ht: e16, ln: t10, ot: n, nt: o }, r) => {
  const [a, i] = Vt({
    i: E9,
    o: Vu()
  }, Me(Vu, e16, "padding", ""));
  return ({ It: s, Zt: l, _n: c, Dt: u }) => {
    let [d, m] = i(u);
    const { R: p } = In(), { ft: f, Ht: h10, Ct: g } = l || {}, { ct: v } = c, [y, k] = s("paddingAbsolute");
    (f || m || (u || h10)) && ([d, m] = a(u));
    const w = !o && (k || g || m);
    if (w) {
      const _ = !y || !t10 && !p, M = d.r + d.l, x = d.t + d.b, R = {
        [w1]: _ && !v ? -M : 0,
        [T1]: _ ? -x : 0,
        [_1]: _ && v ? -M : 0,
        top: _ ? -d.t : 0,
        right: _ ? v ? -d.r : "auto" : 0,
        left: _ ? v ? "auto" : -d.l : 0,
        [Mi]: _ && `calc(100% + ${M}px)`
      }, I = {
        [g1]: _ ? d.t : 0,
        [v1]: _ ? d.r : 0,
        [b1]: _ ? d.b : 0,
        [y1]: _ ? d.l : 0
      };
      Qa(t10 || n, R), Qa(n, I), qe(r, {
        ln: d,
        dn: !_,
        rt: t10 ? I : qe({}, R, I)
      });
    }
    return {
      fn: w
    };
  };
};
var $7 = (e16, t10) => {
  const n = In(), { ht: o, ln: r, ot: a, nt: i, Qt: s, gt: l, wt: c, St: u, un: d } = e16, { R: m } = n, p = c && i, f = Me(m1, 0), h10 = {
    display: () => false,
    direction: (oe) => oe !== "ltr",
    flexDirection: (oe) => oe.endsWith("-reverse"),
    writingMode: (oe) => oe !== "horizontal-tb"
  }, g = dn(h10), v = {
    i: S1,
    o: {
      w: 0,
      h: 0
    }
  }, y = {
    i: Mr,
    o: {}
  }, k = (oe) => {
    u(Z1, !p && oe);
  }, T = (oe) => {
    if (!g.some((Z) => {
      const X = oe[Z];
      return X && h10[Z](X);
    }))
      return {
        D: {
          x: 0,
          y: 0
        },
        M: {
          x: 1,
          y: 1
        }
      };
    k(true);
    const E = Xt(l), K = u(U9, true), ee = ut(s, ma, (Z) => {
      const X = Xt(l);
      Z.isTrusted && X.x === E.x && X.y === E.y && F1(Z);
    }, {
      I: true,
      A: true
    });
    Cn(l, {
      x: 0,
      y: 0
    }), K();
    const V = Xt(l), le = ni(l);
    Cn(l, {
      x: le.w,
      y: le.h
    });
    const pe = Xt(l);
    Cn(l, {
      x: pe.x - V.x < 1 && -le.w,
      y: pe.y - V.y < 1 && -le.h
    });
    const Te = Xt(l);
    return Cn(l, E), nc(() => ee()), {
      D: V,
      M: Te
    };
  }, w = (oe, se) => {
    const E = Ft.devicePixelRatio % 1 !== 0 ? 1 : 0, K = {
      w: f(oe.w - se.w),
      h: f(oe.h - se.h)
    };
    return {
      w: K.w > E ? K.w : 0,
      h: K.h > E ? K.h : 0
    };
  }, [_, M] = Vt(v, Me(fc, a)), [x, R] = Vt(v, Me(ni, a)), [I, P] = Vt(v), [F] = Vt(y), [N, j] = Vt(v), [z] = Vt(y), [A] = Vt({
    i: (oe, se) => xi(oe, se, g),
    o: {}
  }, () => j9(a) ? Ln(a, g) : {}), [B, D] = Vt({
    i: (oe, se) => Mr(oe.D, se.D) && Mr(oe.M, se.M),
    o: O1()
  }), te = sr(J1), ie = (oe, se) => `${se ? W9 : q9}${A9(oe)}`, U = (oe) => {
    const se = (K) => [qn, bo, ma].map((ee) => ie(ee, K)), E = se(true).concat(se()).join(" ");
    u(E), u(dn(oe).map((K) => ie(oe[K], K === "x")).join(" "), true);
  };
  return ({ It: oe, Zt: se, _n: E, Dt: K }, { fn: ee }) => {
    const { ft: V, Ht: le, Ct: pe, dt: Te, zt: Z } = se || {}, X = te && te.tt(e16, t10, E, n, oe), { it: Q, ut: W, _t: de } = X || {}, [Ne, Pe] = v7(oe, n), [tt, Qe] = oe("overflow"), lt = ha(tt.x), Be = ha(tt.y), Xe = true;
    let it = M(K), St = R(K), pn = P(K), hn = j(K);
    Pe && m && u(W1, !Ne);
    {
      uc(o, Qn, xr) && k(true);
      const [ur] = W ? W() : [], [co] = it = _(K), [Bo] = St = x(K), Bn = R1(a), uo = p && F9(d()), Ei = {
        w: f(Bo.w + co.w),
        h: f(Bo.h + co.h)
      }, Zo = {
        w: f((uo ? uo.w : Bn.w + f(Bn.w - Bo.w)) + co.w),
        h: f((uo ? uo.h : Bn.h + f(Bn.h - Bo.h)) + co.h)
      };
      ur && ur(), hn = N(Zo), pn = I(w(Ei, Zo), K);
    }
    const [cn, ne] = hn, [ae, he] = pn, [xe, Ee] = St, [Ve, Je] = it, [Ie, Nt] = F({
      x: ae.w > 0,
      y: ae.h > 0
    }), bt = lt && Be && (Ie.x || Ie.y) || lt && Ie.x && !Ie.y || Be && Ie.y && !Ie.x, Ze = ee || pe || Z || Je || Ee || ne || he || Qe || Pe || Xe, un = y7(Ie, tt), [jo, lo] = z(un.K), [lr, Oo] = A(K), ka = pe || Te || Oo || Nt || K, [Ai, cr] = ka ? B(T(lr), K) : D();
    return Ze && (lo && U(un.K), de && Q && Qa(a, de(un, E, Q(un, xe, Ve)))), k(false), ti(o, Qn, xr, bt), ti(r, pl, xr, bt), qe(t10, {
      K: jo,
      Vt: {
        x: cn.w,
        y: cn.h
      },
      Rt: {
        x: ae.w,
        y: ae.h
      },
      rn: Ie,
      Lt: O9(Ai, ae)
    }), {
      en: lo,
      nn: ne,
      sn: he,
      cn: cr || he,
      vn: ka
    };
  };
};
var x7 = (e16) => {
  const [t10, n, o] = S7(e16), r = {
    ln: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    },
    dn: false,
    rt: {
      [w1]: 0,
      [T1]: 0,
      [_1]: 0,
      [g1]: 0,
      [v1]: 0,
      [b1]: 0,
      [y1]: 0
    },
    Vt: {
      x: 0,
      y: 0
    },
    Rt: {
      x: 0,
      y: 0
    },
    K: {
      x: bo,
      y: bo
    },
    rn: {
      x: false,
      y: false
    },
    Lt: O1()
  }, { vt: a, gt: i, nt: s, Ot: l } = t10, { R: c, k: u } = In(), d = !c && (u.x || u.y), m = [N7(t10), M7(t10, r), $7(t10, r)];
  return [n, (p) => {
    const f = {}, g = d && Xt(i), v = g && l();
    return et(m, (y) => {
      qe(f, y(p, f) || {});
    }), Cn(i, g), v && v(), !s && Cn(a, 0), f;
  }, r, t10, o];
};
var I7 = (e16, t10, n, o, r) => {
  let a = false;
  const i = Ju(t10, {}), [s, l, c, u, d] = x7(e16), [m, p, f] = w7(u, c, i, (T) => {
    k({}, T);
  }), [h10, g, , v] = k7(e16, t10, f, c, u, r), y = (T) => dn(T).some((w) => !!T[w]), k = (T, w) => {
    if (n())
      return false;
    const { pn: _, Dt: M, At: x, hn: R } = T, I = _ || {}, P = !!M || !a, F = {
      It: Ju(t10, I, P),
      pn: I,
      Dt: P
    };
    if (R)
      return g(F), false;
    const N = w || p(qe({}, F, {
      At: x
    })), j = l(qe({}, F, {
      _n: f,
      Zt: N
    }));
    g(qe({}, F, {
      Zt: N,
      tn: j
    }));
    const z = y(N), A = y(j), B = z || A || !sc(I) || P;
    return a = true, B && o(T, {
      Zt: N,
      tn: j
    }), B;
  };
  return [() => {
    const { an: T, gt: w, Ot: _ } = u, M = Xt(T), x = [m(), s(), h10()], R = _();
    return Cn(w, M), R(), Me(Jt, x);
  }, k, () => ({
    gn: f,
    bn: c
  }), {
    wn: u,
    yn: v
  }, d];
};
var kn = (e16, t10, n) => {
  const { N: o } = In(), r = ei(e16), a = r ? e16 : e16.target, i = G1(a);
  if (t10 && !i) {
    let s = false;
    const l = [], c = {}, u = (I) => {
      const P = M1(I), F = sr(h7);
      return F ? F(P, true) : P;
    }, d = qe({}, o(), u(t10)), [m, p, f] = ml(), [h10, g, v] = ml(n), y = (I, P) => {
      v(I, P), f(I, P);
    }, [k, T, w, _, M] = I7(e16, d, () => s, ({ pn: I, Dt: P }, { Zt: F, tn: N }) => {
      const { ft: j, Ct: z, xt: A, Ht: B, Et: D, dt: te } = F, { nn: ie, sn: U, en: oe, cn: se } = N;
      y("updated", [R, {
        updateHints: {
          sizeChanged: !!j,
          directionChanged: !!z,
          heightIntrinsicChanged: !!A,
          overflowEdgeChanged: !!ie,
          overflowAmountChanged: !!U,
          overflowStyleChanged: !!oe,
          scrollCoordinatesChanged: !!se,
          contentMutation: !!B,
          hostMutation: !!D,
          appear: !!te
        },
        changedOptions: I || {},
        force: !!P
      }]);
    }, (I) => y("scroll", [R, I])), x = (I) => {
      f7(a), Jt(l), s = true, y("destroyed", [R, I]), p(), g();
    }, R = {
      options(I, P) {
        if (I) {
          const F = P ? o() : {}, N = B1(d, qe(F, u(I)));
          sc(N) || (qe(d, N), T({
            pn: N
          }));
        }
        return qe({}, d);
      },
      on: h10,
      off: (I, P) => {
        I && P && g(I, P);
      },
      state() {
        const { gn: I, bn: P } = w(), { ct: F } = I, { Vt: N, Rt: j, K: z, rn: A, ln: B, dn: D, Lt: te } = P;
        return qe({}, {
          overflowEdge: N,
          overflowAmount: j,
          overflowStyle: z,
          hasOverflow: A,
          scrollCoordinates: {
            start: te.D,
            end: te.M
          },
          padding: B,
          paddingAbsolute: D,
          directionRTL: F,
          destroyed: s
        });
      },
      elements() {
        const { vt: I, ht: P, ln: F, ot: N, bt: j, gt: z, Qt: A } = _.wn, { Xt: B, Gt: D } = _.yn, te = (U) => {
          const { Pt: oe, Ut: se, Tt: E } = U;
          return {
            scrollbar: E,
            track: se,
            handle: oe
          };
        }, ie = (U) => {
          const { Yt: oe, Wt: se } = U, E = te(oe[0]);
          return qe({}, E, {
            clone: () => {
              const K = te(se());
              return T({
                hn: true
              }), K;
            }
          });
        };
        return qe({}, {
          target: I,
          host: P,
          padding: F || N,
          viewport: N,
          content: j || N,
          scrollOffsetElement: z,
          scrollEventElement: A,
          scrollbarHorizontal: ie(B),
          scrollbarVertical: ie(D)
        });
      },
      update: (I) => T({
        Dt: I,
        At: true
      }),
      destroy: Me(x, false),
      plugin: (I) => c[dn(I)[0]]
    };
    return ht(l, [M]), d7(a, R), Q1(X1, kn, [R, m, c]), u7(_.wn.wt, !r && e16.cancel) ? (x(true), R) : (ht(l, k()), y("initialized", [R]), R.update(), R);
  }
  return i;
};
kn.plugin = (e16) => {
  const t10 = xn(e16), n = t10 ? e16 : [e16], o = n.map((r) => Q1(r, kn)[0]);
  return p7(n), t10 ? o : o[0];
};
kn.valid = (e16) => {
  const t10 = e16 && e16.elements, n = ln(t10) && t10();
  return Jr(n) && !!G1(n.target);
};
kn.env = () => {
  const { T: e16, k: t10, R: n, V: o, B: r, F: a, U: i, P: s, N: l, q: c } = In();
  return qe({}, {
    scrollbarsSize: e16,
    scrollbarsOverlaid: t10,
    scrollbarsHiding: n,
    scrollTimeline: o,
    staticDefaultInitialization: r,
    staticDefaultOptions: a,
    getDefaultInitialization: i,
    setDefaultInitialization: s,
    getDefaultOptions: l,
    setDefaultOptions: c
  });
};
kn.nonce = s7;
var D7 = () => {
  if (typeof window > "u") {
    const c = () => {
    };
    return [c, c];
  }
  let e16, t10;
  const n = window, o = typeof n.requestIdleCallback == "function", r = n.requestAnimationFrame, a = n.cancelAnimationFrame, i = o ? n.requestIdleCallback : r, s = o ? n.cancelIdleCallback : a, l = () => {
    s(e16), a(t10);
  };
  return [
    (c, u) => {
      l(), e16 = i(
        o ? () => {
          l(), t10 = r(c);
        } : c,
        typeof u == "object" ? u : { timeout: 2233 }
      );
    },
    l
  ];
};
var A7 = (e16) => {
  let t10 = null, n, o, r;
  const a = shallowRef(e16 || {}), [i, s] = D7();
  return watch(
    () => {
      var l;
      return unref((l = a.value) == null ? void 0 : l.defer);
    },
    (l) => {
      r = l;
    },
    { deep: true, immediate: true }
  ), watch(
    () => {
      var l;
      return unref((l = a.value) == null ? void 0 : l.options);
    },
    (l) => {
      n = l, kn.valid(t10) && t10.options(n || {}, true);
    },
    { deep: true, immediate: true }
  ), watch(
    () => {
      var l;
      return unref((l = a.value) == null ? void 0 : l.events);
    },
    (l) => {
      o = l, kn.valid(t10) && t10.on(
        /* c8 ignore next */
        o || {},
        true
      );
    },
    { deep: true, immediate: true }
  ), onUnmounted(() => {
    s(), t10 == null || t10.destroy();
  }), [
    (l) => {
      if (kn.valid(t10))
        return t10;
      const c = () => t10 = kn(l, n || {}, o || {});
      r ? i(c, r) : c();
    },
    () => t10
  ];
};
var s0 = defineComponent({
  __name: "OverlayScrollbarsComponent",
  props: {
    element: {
      type: [String, Object],
      default: "div"
    },
    options: { type: Object },
    events: { type: Object },
    defer: { type: [Boolean, Object] }
  },
  emits: ["osInitialized", "osUpdated", "osDestroyed", "osScroll"],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = {
      initialized: "osInitialized",
      updated: "osUpdated",
      destroyed: "osDestroyed",
      scroll: "osScroll"
    }, { element: a, options: i, events: s, defer: l } = toRefs(o), c = shallowRef(null), u = shallowRef(null), d = ref(), [m, p] = A7({ options: i, events: d, defer: l });
    return t10({
      osInstance: p,
      getElement: () => c.value
    }), watchPostEffect((f) => {
      const { value: h10 } = c, { value: g } = u;
      h10 && (m(
        a.value === "body" ? {
          target: h10,
          cancel: {
            body: null
          }
        } : {
          target: h10,
          elements: {
            viewport: g,
            content: g
          }
        }
      ), f(() => {
        var v;
        return (v = p()) == null ? void 0 : v.destroy();
      }));
    }), watch(
      () => unref(s),
      (f) => {
        const h10 = f || {};
        d.value = Object.keys(r).reduce((g, v) => {
          const y = h10[v];
          return g[v] = [
            (...k) => n(
              r[v],
              ...k
            ),
            ...(Array.isArray(y) ? y : [y]).filter(Boolean)
          ], g;
        }, {});
      },
      { deep: true, immediate: true }
    ), (f, h10) => (openBlock(), createBlock(resolveDynamicComponent(unref(a)), {
      "data-overlayscrollbars-initialize": "",
      ref_key: "elementRef",
      ref: c
    }, {
      default: withCtx(() => [
        unref(a) === "body" ? renderSlot(f.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock("div", {
          key: 1,
          "data-overlayscrollbars-contents": "",
          ref_key: "slotRef",
          ref: u
        }, [
          renderSlot(f.$slots, "default")
        ], 512))
      ]),
      _: 3
    }, 512));
  }
});
var E7 = { class: "k-menu-item__title" };
var K7 = { class: "k-menu-item__title" };
var z7 = defineComponent({
  name: "SubMenu",
  __name: "subMenu",
  props: {
    options: {}
  },
  emits: ["click"],
  setup(e16, { emit: t10 }) {
    const n = e16, o = t10, r = computed(() => (i) => {
      const { children: s, ...l } = i;
      return l;
    }), a = (i) => {
      o("click", i);
    };
    return (i, s) => {
      const l = resolveComponent("sub-menu", true);
      return openBlock(true), createElementBlock(Fragment, null, renderList(n.options, (c) => (openBlock(), createElementBlock(Fragment, null, [
        Array.isArray(c.children) && c.children.length > 0 ? (openBlock(), createBlock(unref(ElSubMenu), mergeProps({
          key: 0,
          index: c.index,
          ref_for: true
        }, r.value(c)), {
          title: withCtx(() => [
            c.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(c.icon)))
              ]),
              _: 2
            }, 1024)) : createCommentVNode("", true),
            renderSlot(i.$slots, `${c.index}-title`, {}, () => [
              createBaseVNode("span", E7, toDisplayString(c.title), 1)
            ])
          ]),
          default: withCtx(() => [
            createVNode(l, {
              options: c.children,
              onClick: a
            }, createSlots({ _: 2 }, [
              renderList(i.$slots, (u, d) => ({
                name: d,
                fn: withCtx((m) => [
                  renderSlot(i.$slots, d, mergeProps({ ref_for: true }, m))
                ])
              }))
            ]), 1032, ["options"])
          ]),
          _: 2
        }, 1040, ["index"])) : (openBlock(), createBlock(unref(ElMenuItem), {
          key: 1,
          index: c.index,
          disabled: c.disabled,
          route: c.route,
          onClick: a
        }, {
          title: withCtx(() => [
            renderSlot(i.$slots, `${c.index}-title`, {}, () => [
              createBaseVNode("span", K7, toDisplayString(c.title), 1)
            ])
          ]),
          default: withCtx(() => [
            c.icon ? (openBlock(), createBlock(unref(ElIcon), { key: 0 }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(c.icon)))
              ]),
              _: 2
            }, 1024)) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1032, ["index", "disabled", "route"]))
      ], 64))), 256);
    };
  }
});
var P7 = { class: "k-layout-container h-screen flex overflow-hidden" };
var R7 = { class: "k-layout-content h-screen overflow-hidden flex flex-col flex-1" };
var L7 = { class: "k-layout-header bg-white h-12 px-4 flex w-full justify-between items-center border-b" };
var F7 = { class: "k-layout-main" };
var j7 = { class: "k-layout-footer" };
var O7 = defineComponent({
  name: "KMenuView",
  __name: "MenuView",
  props: {
    options: { default: () => [] },
    active: {},
    showCollapse: { type: Boolean, default: true },
    collapse: { type: Boolean, default: void 0 }
  },
  emits: ["click", "select"],
  setup(e16, { expose: t10, emit: n }) {
    const o = e16, r = n, a = computed(() => o.collapse !== void 0 ? o.collapse : i.value), i = ref(false), s = (m) => {
      r("click", m);
    }, l = () => {
      o.collapse === void 0 && (i.value = true);
    }, c = () => {
      o.collapse === void 0 && (i.value = false);
    }, u = () => {
      o.collapse === void 0 && (i.value = !i.value);
    }, d = (m) => {
      r("select", m);
    };
    return t10({ collapse: l, expand: c, toggleCollapse: u }), (m, p) => (openBlock(), createElementBlock("div", P7, [
      createBaseVNode("div", {
        class: normalizeClass(["k-layout-aside flex flex-col", { "is-collapse": a.value }])
      }, [
        m.$slots["app-logo"] ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["logo-box h-12 flex justify-start items-center p-4", { "is-collapse": a.value }])
        }, [
          renderSlot(m.$slots, "app-logo")
        ], 2)) : createCommentVNode("", true),
        createVNode(unref(s0), {
          defer: "",
          class: "OverlayScrollbarsComponent flex-1",
          options: { scrollbars: { autoHide: "scroll", theme: "os-theme-light" } }
        }, {
          default: withCtx(() => [
            createVNode(unref(ElMenu), mergeProps(m.$attrs, {
              collapse: a.value,
              onSelect: d
            }), {
              default: withCtx(() => [
                createVNode(z7, {
                  options: m.options,
                  onClick: s
                }, createSlots({ _: 2 }, [
                  renderList(m.$slots, (f, h10) => ({
                    name: h10,
                    fn: withCtx((g) => [
                      renderSlot(m.$slots, h10, normalizeProps(guardReactiveProps(g)))
                    ])
                  }))
                ]), 1032, ["options"])
              ]),
              _: 3
            }, 16, ["collapse"])
          ]),
          _: 3
        })
      ], 2),
      createBaseVNode("div", R7, [
        createBaseVNode("div", L7, [
          o.showCollapse && o.collapse === void 0 ? (openBlock(), createBlock(unref(Ip), {
            key: 0,
            class: normalizeClass([{ "rotate-180": !i.value }, "collapse-btn cursor-pointer"]),
            color: "black",
            size: "20",
            onClick: p[0] || (p[0] = (f) => i.value = !i.value)
          }, null, 8, ["class"])) : createCommentVNode("", true),
          renderSlot(m.$slots, "header")
        ]),
        createVNode(unref(s0), {
          defer: "",
          options: { scrollbars: { autoHide: "scroll" } },
          class: "flex-1"
        }, {
          default: withCtx(() => [
            createBaseVNode("div", F7, [
              renderSlot(m.$slots, "main")
            ]),
            createBaseVNode("div", j7, [
              renderSlot(m.$slots, "footer")
            ])
          ]),
          _: 3
        })
      ])
    ]));
  }
});
var B7 = $e(O7);
var Z7 = {
  id: "GFPageDetails",
  class: "GFPageDetails",
  style: { "min-width": "0" }
};
var W7 = { class: "GFPageDetailsHead-content px-10 w-full flex flex-col bg-white rounded overflow-hidden shadow-sm" };
var q7 = { class: "head" };
var V7 = { class: "w-full flex justify-between items-center mb-4" };
var H7 = { class: "head-title" };
var U7 = { class: "flex items-center gap-1 h-8" };
var G7 = { class: "text-2xl font-bold" };
var X7 = { class: "head-toolbar" };
var Y7 = { class: "head-abstract mb-4 flex flex-col" };
var Q7 = {
  key: 0,
  class: "!m-auto p-2"
};
var J7 = { class: "GFPageDetails-slot--default flex-1" };
var e_ = defineComponent({
  name: "GFPageDetails",
  __name: "GFPageDetails",
  props: {
    icon: { default: "" },
    title: { default: "标题" },
    descriptions: {},
    columns: { default: 3 },
    abstract: { default: () => [] },
    tabsConfig: {},
    tabs: { default: () => [] },
    direction: { default: "horizontal" },
    useItemCollapse: { type: Boolean, default: false }
  },
  setup(e16, { expose: t10 }) {
    var f;
    const n = e16, o = ref(true), r = ref(), a = (f = n.tabsConfig) == null ? void 0 : f.defaultActive, i = ref(a ?? n.tabs[0].name), s = ref(1), l = ref(1);
    onMounted(() => {
      u(), m();
    });
    function c(h10) {
      i.value = h10;
    }
    function u() {
      var g;
      return (g = r.value) == null ? void 0 : g.children[0].children[0].clientHeight;
    }
    function d() {
      o.value = !o.value;
    }
    function m() {
      if (!(r != null && r.value)) return;
      let h10 = 1;
      const g = getComputedStyle(r == null ? void 0 : r.value).gridTemplateColumns.split(
        " "
      );
      for (let v = 1; v < g.length; v++) {
        if (Math.abs(parseInt(g[v]) - parseInt(g[v - 1])) > 2) {
          s.value = h10;
          break;
        }
        h10++;
      }
      s.value = h10, setTimeout(() => {
        p();
      }, 1);
    }
    function p() {
      var y;
      const h10 = ((y = r.value) == null ? void 0 : y.clientHeight) ?? 0, g = getComputedStyle(r == null ? void 0 : r.value).gridTemplateRows.split(
        " "
      ), v = g[0];
      l.value = g.length, r == null || r.value.style.setProperty("--expandHeight", `${h10}px`), r == null || r.value.style.setProperty("--transition-duration", "0.3s"), r == null || r.value.style.setProperty("--firstRowHeight", `${v}`);
    }
    return t10({ toggleActiveTab: c }), (h10, g) => {
      const v = resolveComponent("IconArrowTop"), y = resolveComponent("k-button");
      return openBlock(), createElementBlock("div", Z7, [
        createBaseVNode("div", W7, [
          createBaseVNode("div", q7, [
            renderSlot(h10.$slots, "extra-head", {}, () => [
              createBaseVNode("div", V7, [
                createBaseVNode("div", H7, [
                  renderSlot(h10.$slots, "head-title", {}, () => [
                    createBaseVNode("div", U7, [
                      h10.icon ? (openBlock(), createBlock(resolveDynamicComponent(h10.icon), {
                        key: 0,
                        size: "24"
                      })) : createCommentVNode("", true),
                      createBaseVNode("span", G7, toDisplayString(h10.title), 1)
                    ])
                  ])
                ]),
                createBaseVNode("div", X7, [
                  renderSlot(h10.$slots, "head-toolbar")
                ])
              ])
            ])
          ]),
          createBaseVNode("div", Y7, [
            renderSlot(h10.$slots, "head-abstract", {}, () => [
              createBaseVNode("div", {
                ref_key: "RefHeadAbstract",
                ref: r,
                class: normalizeClass(["RefHeadAbstract grid gap-4", {
                  "is-collapse": !o.value && h10.useItemCollapse,
                  "use-collapse": h10.useItemCollapse && o.value
                }]),
                style: normalizeStyle(`grid-template-columns:repeat(${h10.columns},minmax(0, 1fr))`)
              }, [
                (openBlock(true), createElementBlock(Fragment, null, renderList(n.abstract, (k) => (openBlock(), createBlock(unref(f1), {
                  key: k.label,
                  label: k.label,
                  value: k.value,
                  render: k.render,
                  style: normalizeStyle(`grid-column: span ${k.column}`),
                  direction: h10.direction
                }, null, 8, ["label", "value", "render", "style", "direction"]))), 128))
              ], 6),
              h10.useItemCollapse ? (openBlock(), createElementBlock("div", Q7, [
                createVNode(y, {
                  text: "",
                  onClick: d
                }, {
                  default: withCtx(() => [
                    createVNode(v, {
                      rotate: o.value ? 180 : 0
                    }, null, 8, ["rotate"]),
                    createTextVNode(" " + toDisplayString(o.value ? "展开详情" : "收起详情"), 1)
                  ]),
                  _: 1
                })
              ])) : createCommentVNode("", true)
            ])
          ])
        ]),
        createBaseVNode("div", J7, [
          renderSlot(h10.$slots, "detail", {}, () => [
            createVNode(unref(Ef), mergeProps({
              modelValue: i.value,
              "onUpdate:modelValue": g[0] || (g[0] = (k) => i.value = k)
            }, h10.tabsConfig), {
              default: withCtx(() => [
                (openBlock(true), createElementBlock(Fragment, null, renderList(h10.tabs, (k) => (openBlock(), createBlock(unref(Kf), mergeProps({
                  key: k.name,
                  ref_for: true
                }, k), createSlots({
                  default: withCtx(() => [
                    renderSlot(h10.$slots, k.name)
                  ]),
                  _: 2
                }, [
                  h10.$slots[`${k.name}-label`] ? {
                    name: "label",
                    fn: withCtx(() => [
                      renderSlot(h10.$slots, `${k.name}-label`)
                    ]),
                    key: "0"
                  } : void 0
                ]), 1040))), 128))
              ]),
              _: 3
            }, 16, ["modelValue"])
          ])
        ])
      ]);
    };
  }
});
var t_ = $e(e_);
var n_ = {
  class: "KNewTransfer"
};
var o_ = {
  class: "transfer-dialog-content"
};
var a_ = {
  key: 0,
  class: "my-box"
};
var r_ = {
  class: "empty-text"
};
var i_ = {
  class: "footer"
};
var s_ = defineComponent({
  name: "KNewTransfer",
  __name: "newTransfer",
  props: {
    treeTransferData: {
      default: () => []
    },
    title: {
      default: "仅允许选择同一种类型的机器"
    },
    defaultVal: {
      default: ""
    },
    selectList: {
      default: () => []
    },
    defaultData: {
      default: () => []
    }
  },
  setup(e16, {
    expose: t10
  }) {
    const n = e16, o = reactive({
      machineType: n.defaultVal
    }), r = ref(null), a = () => {
      o.machineType = u, setTimeout(() => {
        r.value.clearData();
      }, 0), c.value = false;
    }, i = () => {
      c.value = false;
    }, s = ref(n.defaultData), l = (h10) => {
      s.value = h10;
    }, c = ref(false);
    let u = "";
    const d = (h10) => {
      u = h10, o.machineType && s.value.length !== 0 ? c.value = true : o.machineType = h10;
    };
    watch(() => o.machineType, (h10) => {
      setTimeout(() => {
        r.value.clearQuery();
      }, 0);
      const g = n.selectList.find((v) => v.type === h10);
      g && g.fun && typeof g.fun == "function" && g.fun(u);
    });
    const m = ref(), p = () => {
      m.value && m.value.validate((h10) => h10 ? {
        arr: s.value,
        type: o.machineType
      } : (console.warn("error submit!!"), false));
    }, f = () => {
    };
    return t10({
      handleSubmit: p,
      handleSelectType: d,
      handleCancel: f
    }), (h10, g) => {
      const v = resolveComponent("IconTips"), y = resolveComponent("k-radio"), k = resolveComponent("k-popconfirm"), T = resolveComponent("k-radio-group"), w = resolveComponent("k-form-item"), _ = resolveComponent("k-form"), M = resolveComponent("k-tree-transfer"), x = resolveComponent("k-button");
      return openBlock(), createElementBlock("div", n_, [renderSlot(h10.$slots, "header", {}, () => [createBaseVNode("div", o_, [createVNode(v, {
        class: "transfer-dialog-icon"
      }), createTextVNode(" " + toDisplayString(h10.title), 1)])], true), createVNode(_, {
        ref_key: "KFormRef",
        ref: m,
        model: o,
        "labk-width": "auto",
        style: {
          "max-width": "600px"
        }
      }, {
        default: withCtx(() => [createVNode(w, {
          label: "选择机器类型",
          prop: "machineType",
          rules: {
            required: true,
            message: "请选择类型"
          }
        }, {
          default: withCtx(() => [createVNode(T, {
            modelValue: o.machineType,
            "onUpdate:modelValue": g[1] || (g[1] = (R) => o.machineType = R)
          }, {
            default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(h10.selectList, (R, I) => (openBlock(), createBlock(k, {
              key: I,
              visible: R.type === o.machineType && c.value,
              "confirm-button-text": "Yes",
              "cancel-button-text": "No",
              icon: "IconClear",
              "icon-color": "#626AEF",
              title: "切换类型会清空你已选择的数据, 是否继续?",
              onConfirm: g[0] || (g[0] = (P) => a()),
              onCancel: i
            }, {
              reference: withCtx(() => [createVNode(y, {
                value: R.type,
                size: "large",
                onClick: withModifiers((P) => d(R.type), ["prevent"])
              }, {
                default: withCtx(() => [createTextVNode(toDisplayString(R.name), 1)]),
                _: 2
              }, 1032, ["value", "onClick"])]),
              _: 2
            }, 1032, ["visible"]))), 128))]),
            _: 1
          }, 8, ["modelValue"])]),
          _: 1
        })]),
        _: 1
      }, 8, ["model"]), o.machineType ? (openBlock(), createElementBlock("div", a_, [createVNode(M, mergeProps({
        ref_key: "myTreeTransfer",
        ref: r,
        data: h10.treeTransferData,
        titles: ["待选IP", "已选IP"],
        "default-data": h10.defaultData,
        label: "name",
        "expand-icon": "IconFolderOpen",
        "expand-icon-color": "#f60",
        "collapse-icon-color": "red",
        "icon-color": "green",
        "collapse-icon": "IconFolderClose",
        class: "my-box-item"
      }, h10.$attrs, {
        onChange: l
      }), {
        empty: withCtx(({
          query: R
        }) => [createBaseVNode("div", r_, [g[3] || (g[3] = createBaseVNode("div", null, "没有找到包含", -1)), createBaseVNode("div", null, "'" + toDisplayString(R) + "'", 1), g[4] || (g[4] = createBaseVNode("div", null, "的数据", -1))])]),
        _: 1
      }, 16, ["data", "default-data"])])) : createCommentVNode("", true), renderSlot(h10.$slots, "footer", {}, () => [createBaseVNode("div", i_, [createVNode(x, {
        onClick: f
      }, {
        default: withCtx(() => g[5] || (g[5] = [createTextVNode("取消")])),
        _: 1
      }), createVNode(x, {
        type: "primary",
        main: "",
        onClick: g[2] || (g[2] = (R) => p())
      }, {
        default: withCtx(() => g[6] || (g[6] = [createTextVNode("确定")])),
        _: 1
      })])], true)]);
    };
  }
});
var l_ = Ta(s_, [["__scopeId", "data-v-bafdc337"]]);
var c_ = $e(l_);
var u_ = [
  d1,
  v9,
  f1,
  $9,
  N9,
  B7,
  t_,
  c_
];
var d_ = (e16) => {
  [...u1, ...u_].forEach((o) => {
    !o || !o.install || !(o != null && o.name) || e16.use(o);
  });
  const n = f_();
  for (const o in n)
    e16.component(o, n[o]);
};
function f_() {
  const e16 = "K", t10 = {};
  for (const n in es_exports)
    if (/^El[A-Z]/.test(n)) {
      const o = n.replace(/^El/, e16);
      u1.find((a) => a.name === o) || (t10[o] = es_exports[n]);
    }
  return t10;
}
var m_ = {
  name: "zh-cn",
  el: {
    breadcrumb: {
      label: "面包屑"
    },
    colorpicker: {
      confirm: "确定",
      clear: "清空",
      defaultLabel: "颜色选择器",
      description: "当前颜色 {color}，按 Enter 键选择新颜色",
      alphaLabel: "选择透明度的值"
    },
    datepicker: {
      now: "此刻",
      today: "今天",
      cancel: "取消",
      clear: "清空",
      confirm: "确定",
      dateTablePrompt: "使用方向键与 Enter 键可选择日期",
      monthTablePrompt: "使用方向键与 Enter 键可选择月份",
      yearTablePrompt: "使用方向键与 Enter 键可选择年份",
      selectedDate: "已选日期",
      selectDate: "选择日期",
      selectTime: "选择时间",
      startDate: "开始日期",
      startTime: "开始时间",
      endDate: "结束日期",
      endTime: "结束时间",
      prevYear: "前一年",
      nextYear: "后一年",
      prevMonth: "上个月",
      nextMonth: "下个月",
      year: "年",
      month1: "1 月",
      month2: "2 月",
      month3: "3 月",
      month4: "4 月",
      month5: "5 月",
      month6: "6 月",
      month7: "7 月",
      month8: "8 月",
      month9: "9 月",
      month10: "10 月",
      month11: "11 月",
      month12: "12 月",
      weeks: {
        sun: "日",
        mon: "一",
        tue: "二",
        wed: "三",
        thu: "四",
        fri: "五",
        sat: "六"
      },
      weeksFull: {
        sun: "星期日",
        mon: "星期一",
        tue: "星期二",
        wed: "星期三",
        thu: "星期四",
        fri: "星期五",
        sat: "星期六"
      },
      months: {
        jan: "一月",
        feb: "二月",
        mar: "三月",
        apr: "四月",
        may: "五月",
        jun: "六月",
        jul: "七月",
        aug: "八月",
        sep: "九月",
        oct: "十月",
        nov: "十一月",
        dec: "十二月"
      }
    },
    inputNumber: {
      decrease: "减少数值",
      increase: "增加数值"
    },
    select: {
      loading: "加载中",
      noMatch: "无匹配数据",
      noData: "无数据",
      placeholder: "请选择"
    },
    dropdown: {
      toggleDropdown: "切换下拉选项"
    },
    mention: {
      loading: "加载中"
    },
    cascader: {
      noMatch: "无匹配数据",
      loading: "加载中",
      placeholder: "请选择",
      noData: "暂无数据"
    },
    pagination: {
      goto: "前往",
      pagesize: "条/页",
      total: "共 {total} 条",
      pageClassifier: "页",
      page: "页",
      prev: "上一页",
      next: "下一页",
      currentPage: "第 {pager} 页",
      prevPages: "向前 {pager} 页",
      nextPages: "向后 {pager} 页",
      deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
    },
    dialog: {
      close: "关闭此对话框"
    },
    drawer: {
      close: "关闭此对话框"
    },
    messagebox: {
      title: "提示",
      confirm: "确定",
      cancel: "取消",
      error: "输入的数据不合法!",
      close: "关闭此对话框"
    },
    upload: {
      deleteTip: "按 delete 键可删除",
      delete: "删除",
      preview: "查看图片",
      continue: "继续上传"
    },
    slider: {
      defaultLabel: "滑块介于 {min} 至 {max}",
      defaultRangeStartLabel: "选择起始值",
      defaultRangeEndLabel: "选择结束值"
    },
    table: {
      emptyText: "暂无数据",
      confirmFilter: "筛选",
      resetFilter: "重置",
      clearFilter: "全部",
      sumText: "合计"
    },
    tour: {
      next: "下一步",
      previous: "上一步",
      finish: "结束导览"
    },
    tree: {
      emptyText: "暂无数据"
    },
    transfer: {
      noMatch: "无匹配数据",
      noData: "无数据",
      titles: ["列表 1", "列表 2"],
      filterPlaceholder: "请输入搜索内容",
      noCheckedFormat: "共 {total} 项",
      hasCheckedFormat: "已选 {checked}/{total} 项"
    },
    image: {
      error: "加载失败"
    },
    pageHeader: {
      title: "返回"
    },
    popconfirm: {
      confirmButtonText: "确定",
      cancelButtonText: "取消"
    },
    carousel: {
      leftArrow: "上一张幻灯片",
      rightArrow: "下一张幻灯片",
      indicator: "幻灯片切换至索引 {index}"
    }
  }
};
var p_ = {
  name: "en",
  el: {
    breadcrumb: {
      label: "Breadcrumb"
    },
    colorpicker: {
      confirm: "OK",
      clear: "Clear",
      defaultLabel: "color picker",
      description: "current color is {color}. press enter to select a new color.",
      alphaLabel: "pick alpha value"
    },
    datepicker: {
      now: "Now",
      today: "Today",
      cancel: "Cancel",
      clear: "Clear",
      confirm: "OK",
      dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
      monthTablePrompt: "Use the arrow keys and enter to select the month",
      yearTablePrompt: "Use the arrow keys and enter to select the year",
      selectedDate: "Selected date",
      selectDate: "Select date",
      selectTime: "Select time",
      startDate: "Start Date",
      startTime: "Start Time",
      endDate: "End Date",
      endTime: "End Time",
      prevYear: "Previous Year",
      nextYear: "Next Year",
      prevMonth: "Previous Month",
      nextMonth: "Next Month",
      year: "",
      month1: "January",
      month2: "February",
      month3: "March",
      month4: "April",
      month5: "May",
      month6: "June",
      month7: "July",
      month8: "August",
      month9: "September",
      month10: "October",
      month11: "November",
      month12: "December",
      week: "week",
      weeks: {
        sun: "Sun",
        mon: "Mon",
        tue: "Tue",
        wed: "Wed",
        thu: "Thu",
        fri: "Fri",
        sat: "Sat"
      },
      weeksFull: {
        sun: "Sunday",
        mon: "Monday",
        tue: "Tuesday",
        wed: "Wednesday",
        thu: "Thursday",
        fri: "Friday",
        sat: "Saturday"
      },
      months: {
        jan: "Jan",
        feb: "Feb",
        mar: "Mar",
        apr: "Apr",
        may: "May",
        jun: "Jun",
        jul: "Jul",
        aug: "Aug",
        sep: "Sep",
        oct: "Oct",
        nov: "Nov",
        dec: "Dec"
      }
    },
    inputNumber: {
      decrease: "decrease number",
      increase: "increase number"
    },
    select: {
      loading: "Loading",
      noMatch: "No matching data",
      noData: "No data",
      placeholder: "Select"
    },
    mention: {
      loading: "Loading"
    },
    dropdown: {
      toggleDropdown: "Toggle Dropdown"
    },
    cascader: {
      noMatch: "No matching data",
      loading: "Loading",
      placeholder: "Select",
      noData: "No data"
    },
    pagination: {
      goto: "Go to",
      pagesize: "/page",
      total: "Total {total}",
      pageClassifier: "",
      page: "Page",
      prev: "Go to previous page",
      next: "Go to next page",
      currentPage: "page {pager}",
      prevPages: "Previous {pager} pages",
      nextPages: "Next {pager} pages",
      deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
    },
    dialog: {
      close: "Close this dialog"
    },
    drawer: {
      close: "Close this dialog"
    },
    messagebox: {
      title: "Message",
      confirm: "OK",
      cancel: "Cancel",
      error: "Illegal input",
      close: "Close this dialog"
    },
    upload: {
      deleteTip: "press delete to remove",
      delete: "Delete",
      preview: "Preview",
      continue: "Continue"
    },
    slider: {
      defaultLabel: "slider between {min} and {max}",
      defaultRangeStartLabel: "pick start value",
      defaultRangeEndLabel: "pick end value"
    },
    table: {
      emptyText: "No Data",
      confirmFilter: "Confirm",
      resetFilter: "Reset",
      clearFilter: "All",
      sumText: "Sum"
    },
    tour: {
      next: "Next",
      previous: "Previous",
      finish: "Finish"
    },
    tree: {
      emptyText: "No Data"
    },
    transfer: {
      noMatch: "No matching data",
      noData: "No data",
      titles: ["List 1", "List 2"],
      filterPlaceholder: "Enter keyword",
      noCheckedFormat: "{total} items",
      hasCheckedFormat: "{checked}/{total} checked"
    },
    image: {
      error: "FAILED"
    },
    pageHeader: {
      title: "Back"
    },
    popconfirm: {
      confirmButtonText: "Yes",
      cancelButtonText: "No"
    },
    carousel: {
      leftArrow: "Carousel arrow left",
      rightArrow: "Carousel arrow right",
      indicator: "Carousel switch to index {index}"
    }
  }
};
function h_(e16, t10 = {}) {
  e16.use(installer, {
    ...t10 == null ? void 0 : t10.ElementPlusOptions,
    locale: t10.locale === "en" ? p_ : m_
  }), e16.use(index_esm_default2).use(index_esm_default3), index_esm_default3.setConfig(t10.vxeGlobalConfig ?? {});
}
var g_ = {
  advancedFilter: "高级筛选",
  clearAll: "清除所有条件",
  addCondition: "添加条件",
  aboveCondition: "以上条件",
  anyOne: "满足任意一项",
  all: "全部满足",
  query: "查询",
  exactDate: "具体日期",
  dateRange: "日期区间",
  today: "今天",
  tomorrow: "明天",
  yesterday: "昨天",
  thisWeek: "本周",
  lastWeek: "上周",
  thisMonth: "本月",
  lastMonth: "上月",
  withinThePastSevenDays: "过去七天内",
  withinThePastThirtyDays: "过去30天内",
  equal: "等于",
  before: "早于",
  after: "晚于",
  empty: "为空",
  nonEmpty: "不为空",
  batchOperation: "批量操作",
  customDescription: "自定义说明",
  cancel: "取消",
  confirm: "确认",
  filter: "筛选",
  reset: "重置",
  sort: "排序",
  ascendingOrder: "升序",
  descendingOrder: "降序",
  clearSorting: "清除排序",
  hide: "隐藏",
  retract: "收起",
  uploadDragSign: "单击或拖拽文件到此处上传",
  uploadFile: "上传文件",
  selectFile: "选择文件",
  remove: "移除",
  view: "视图",
  customView: "自定义视图",
  pleaseInput: "请输入",
  pleaseSelect: "请选择",
  expand: "展开",
  collapse: "收起",
  success: "成功",
  error: "错误",
  warning: "警告",
  noData: "暂无数据",
  selectedFields: "已选字段",
  unselectedFields: "待选字段",
  restoreDefault: "恢复默认",
  searchHeaderName: "搜索表头名称",
  showLunar: "显示农历",
  next: "下一步",
  previous: "上一步",
  finish: "完成",
  searchTable: "搜索此列表",
  data: "数据",
  showAll: "显示全部",
  total: "共",
  gt: "大于",
  lt: "小于",
  gte: "大于等于",
  lte: "小于等于",
  contain: "包含",
  notEqual: "不等于",
  clearData: "清除数据",
  enterInputSearch: "按下回车键搜索",
  within7days: "7天内",
  within15days: "15天内",
  curMonth: "本月",
  curQuarter: "本季度",
  curYear: "本年度",
  refresh: "刷新",
  columnHeaderController: "列头控制器",
  advancedFilter_c: "高级筛选",
  sizeControlTrigger: "调整表格大小"
};
var v_ = {
  advancedFilter: "Advanced Filter",
  clearAll: "clear all",
  addCondition: "add condition",
  aboveCondition: "above condition",
  anyOne: "Any One",
  all: "All",
  query: "query",
  exactDate: "exact date",
  dateRange: "date range",
  today: "today",
  tomorrow: "tomorrow",
  yesterday: "yesterday",
  thisWeek: "this week",
  lastWeek: "last week",
  thisMonth: "this month",
  lastMonth: "last month",
  withinThePastSevenDays: "within the past seven days",
  withinThePastThirtyDays: "Within the past thirty days",
  equal: "equal",
  before: "before",
  after: "after",
  empty: "empty",
  nonEmpty: "non empty",
  batchOperation: "Operation",
  customDescription: "custom description",
  cancel: "cancel",
  confirm: "confirm",
  filter: "filter",
  reset: "reset",
  sort: "sort",
  ascendingOrder: "ascending order",
  descendingOrder: "descending order",
  clearSorting: "clear sorting",
  hide: "hide",
  retract: "retract",
  uploadDragSign: "Click or drag the file here to upload",
  uploadFile: "upload file",
  selectFile: "select file",
  remove: "remove",
  view: "view",
  customView: "custom view",
  pleaseInput: "Please Input",
  pleaseSelect: "Please Select",
  expand: "expand",
  collapse: "collapse",
  success: "success",
  error: "error",
  warning: "warning",
  noData: "no data",
  selectedFields: "Selected",
  unselectedFields: "Unselected",
  restoreDefault: "Restore",
  searchHeaderName: "Search Header Name",
  showLunar: "show lunar",
  next: "next",
  previous: "previous",
  finish: "finish",
  searchTable: "search table data",
  total: "total",
  data: "data",
  showAll: "show all",
  gt: "gt",
  lt: "lt",
  gte: "gte",
  lte: "lte",
  contain: "contain",
  notEqual: "not equal",
  clearData: "Clear Data",
  enterInputSearch: "Press Enter to search",
  within7days: "within 7 days",
  within15days: "within 15 days",
  curMonth: "current month",
  curQuarter: "current quarter",
  curYear: "current year",
  refresh: "refresh",
  columnHeaderController: "column header controller",
  advancedFilter_c: "advanced filter",
  sizeControlTrigger: "Size Control"
};
function y_(e16, t10 = {}) {
  const n = { zh: g_, en: v_ }, o = createI18n({
    locale: (t10 == null ? void 0 : t10.locale) === "en" ? "en" : "zh",
    messages: n
  });
  e16.use(o), e16.config.globalProperties.$t = o.global.t, e16.provide("$t", o.global.t);
}
var b_ = {
  mounted(e16) {
    e16.style.cursor = "move", e16.style.position = "absolute";
    const t10 = (n) => {
      n.preventDefault(), n.stopPropagation();
      const o = n.clientX, r = n.clientY, a = e16.getBoundingClientRect(), i = o - a.left, s = r - a.top, l = e16.parentElement.getBoundingClientRect(), c = (d) => {
        let m = d.clientX - i, p = d.clientY - s;
        m < l.left && (m = l.left), p < l.top && (p = l.top), m + a.width > l.right && (m = l.right - a.width), p + a.height > l.bottom && (p = l.bottom - a.height), e16.style.left = `${m - l.left}px`, e16.style.top = `${p - l.top}px`;
      }, u = () => {
        document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
      };
      document.addEventListener("mousemove", c), document.addEventListener("mouseup", u);
    };
    e16.addEventListener("mousedown", t10), e16._handleMouseDown = t10;
  },
  beforeUnmount(e16) {
    e16.removeEventListener("mousedown", e16._handleMouseDown);
  }
};
var __ = {
  mounted(e16, t10) {
    w_(e16, t10);
  }
};
var w_ = (e16, t10) => {
  const n = document.querySelector("#_tooltip_root");
  n && n.remove(), e16._tipRoot = null, e16._tipApp = null;
  const o = "_tooltip_root", r = document.createElement("div");
  r.id = o, r.classList.add("_tipRoot");
  const { trigger: a, placement: i, content: s, showAfter: l, autoClose: c } = (t10 == null ? void 0 : t10.value) ?? {}, u = createApp(wa, {
    virtualRef: e16,
    rawContent: true,
    virtualTriggering: true,
    trigger: a ?? "hover",
    placement: i ?? "bottom",
    content: typeof t10.value == "object" ? String(s) : String(t10.value),
    showAfter: l ?? 500,
    autoClose: c ?? 1e3
  });
  e16._tipRoot = r, e16._tipApp = u, document.body.appendChild(r), u && r && e16._tipApp.mount(`#${o}`);
};
var l0 = Object.freeze(Object.defineProperty({
  __proto__: null,
  drag: b_,
  tooltip: __
}, Symbol.toStringTag, { value: "Module" }));
function T_(e16) {
  for (const t10 in l0)
    e16.directive(`ksw_${t10}`, l0[t10]);
}
function C_(e16, t10 = {}) {
  const n = t10.styleModule, o = ["AOM", "GFAOM", "KingAutometa"];
  let r = "AOM";
  if (typeof n == "string" && o.includes(n) ? r = n : n !== void 0 && console.warn(
    `'styleModule' expected to be ${o.map((a) => `'${a}'`).join(" | ")}, but got '${n}'.`
  ), typeof document < "u") {
    const a = document == null ? void 0 : document.getElementsByTagName("body")[0];
    a == null || a.classList.add(r);
  }
  e16.provide("_styleModule", r === "AOM" ? "" : r);
}
function k_(e16) {
  return e16 && e16.__esModule && Object.prototype.hasOwnProperty.call(e16, "default") ? e16.default : e16;
}
var tm = { exports: {} };
(function(e16) {
  var t10 = function() {
    this.Diff_Timeout = 1, this.Diff_EditCost = 4, this.Match_Threshold = 0.5, this.Match_Distance = 1e3, this.Patch_DeleteThreshold = 0.5, this.Patch_Margin = 4, this.Match_MaxBits = 32;
  }, n = -1, o = 1, r = 0;
  t10.Diff = function(a, i) {
    return [a, i];
  }, t10.prototype.diff_main = function(a, i, s, l) {
    typeof l > "u" && (this.Diff_Timeout <= 0 ? l = Number.MAX_VALUE : l = (/* @__PURE__ */ new Date()).getTime() + this.Diff_Timeout * 1e3);
    var c = l;
    if (a == null || i == null)
      throw new Error("Null input. (diff_main)");
    if (a == i)
      return a ? [new t10.Diff(r, a)] : [];
    typeof s > "u" && (s = true);
    var u = s, d = this.diff_commonPrefix(a, i), m = a.substring(0, d);
    a = a.substring(d), i = i.substring(d), d = this.diff_commonSuffix(a, i);
    var p = a.substring(a.length - d);
    a = a.substring(0, a.length - d), i = i.substring(0, i.length - d);
    var f = this.diff_compute_(a, i, u, c);
    return m && f.unshift(new t10.Diff(r, m)), p && f.push(new t10.Diff(r, p)), this.diff_cleanupMerge(f), f;
  }, t10.prototype.diff_compute_ = function(a, i, s, l) {
    var c;
    if (!a)
      return [new t10.Diff(o, i)];
    if (!i)
      return [new t10.Diff(n, a)];
    var u = a.length > i.length ? a : i, d = a.length > i.length ? i : a, m = u.indexOf(d);
    if (m != -1)
      return c = [
        new t10.Diff(o, u.substring(0, m)),
        new t10.Diff(r, d),
        new t10.Diff(
          o,
          u.substring(m + d.length)
        )
      ], a.length > i.length && (c[0][0] = c[2][0] = n), c;
    if (d.length == 1)
      return [
        new t10.Diff(n, a),
        new t10.Diff(o, i)
      ];
    var p = this.diff_halfMatch_(a, i);
    if (p) {
      var f = p[0], h10 = p[1], g = p[2], v = p[3], y = p[4], k = this.diff_main(f, g, s, l), T = this.diff_main(h10, v, s, l);
      return k.concat(
        [new t10.Diff(r, y)],
        T
      );
    }
    return s && a.length > 100 && i.length > 100 ? this.diff_lineMode_(a, i, l) : this.diff_bisect_(a, i, l);
  }, t10.prototype.diff_lineMode_ = function(a, i, s) {
    var l = this.diff_linesToChars_(a, i);
    a = l.chars1, i = l.chars2;
    var c = l.lineArray, u = this.diff_main(a, i, false, s);
    this.diff_charsToLines_(u, c), this.diff_cleanupSemantic(u), u.push(new t10.Diff(r, ""));
    for (var d = 0, m = 0, p = 0, f = "", h10 = ""; d < u.length; ) {
      switch (u[d][0]) {
        case o:
          p++, h10 += u[d][1];
          break;
        case n:
          m++, f += u[d][1];
          break;
        case r:
          if (m >= 1 && p >= 1) {
            u.splice(
              d - m - p,
              m + p
            ), d = d - m - p;
            for (var g = this.diff_main(f, h10, false, s), v = g.length - 1; v >= 0; v--)
              u.splice(d, 0, g[v]);
            d = d + g.length;
          }
          p = 0, m = 0, f = "", h10 = "";
          break;
      }
      d++;
    }
    return u.pop(), u;
  }, t10.prototype.diff_bisect_ = function(a, i, s) {
    for (var l = a.length, c = i.length, u = Math.ceil((l + c) / 2), d = u, m = 2 * u, p = new Array(m), f = new Array(m), h10 = 0; h10 < m; h10++)
      p[h10] = -1, f[h10] = -1;
    p[d + 1] = 0, f[d + 1] = 0;
    for (var g = l - c, v = g % 2 != 0, y = 0, k = 0, T = 0, w = 0, _ = 0; _ < u && !((/* @__PURE__ */ new Date()).getTime() > s); _++) {
      for (var M = -_ + y; M <= _ - k; M += 2) {
        var x = d + M, R;
        M == -_ || M != _ && p[x - 1] < p[x + 1] ? R = p[x + 1] : R = p[x - 1] + 1;
        for (var I = R - M; R < l && I < c && a.charAt(R) == i.charAt(I); )
          R++, I++;
        if (p[x] = R, R > l)
          k += 2;
        else if (I > c)
          y += 2;
        else if (v) {
          var P = d + g - M;
          if (P >= 0 && P < m && f[P] != -1) {
            var F = l - f[P];
            if (R >= F)
              return this.diff_bisectSplit_(a, i, R, I, s);
          }
        }
      }
      for (var N = -_ + T; N <= _ - w; N += 2) {
        var P = d + N, F;
        N == -_ || N != _ && f[P - 1] < f[P + 1] ? F = f[P + 1] : F = f[P - 1] + 1;
        for (var j = F - N; F < l && j < c && a.charAt(l - F - 1) == i.charAt(c - j - 1); )
          F++, j++;
        if (f[P] = F, F > l)
          w += 2;
        else if (j > c)
          T += 2;
        else if (!v) {
          var x = d + g - N;
          if (x >= 0 && x < m && p[x] != -1) {
            var R = p[x], I = d + R - x;
            if (F = l - F, R >= F)
              return this.diff_bisectSplit_(a, i, R, I, s);
          }
        }
      }
    }
    return [
      new t10.Diff(n, a),
      new t10.Diff(o, i)
    ];
  }, t10.prototype.diff_bisectSplit_ = function(a, i, s, l, c) {
    var u = a.substring(0, s), d = i.substring(0, l), m = a.substring(s), p = i.substring(l), f = this.diff_main(u, d, false, c), h10 = this.diff_main(m, p, false, c);
    return f.concat(h10);
  }, t10.prototype.diff_linesToChars_ = function(a, i) {
    var s = [], l = {};
    s[0] = "";
    function c(p) {
      for (var f = "", h10 = 0, g = -1, v = s.length; g < p.length - 1; ) {
        g = p.indexOf(`
`, h10), g == -1 && (g = p.length - 1);
        var y = p.substring(h10, g + 1);
        (l.hasOwnProperty ? l.hasOwnProperty(y) : l[y] !== void 0) ? f += String.fromCharCode(l[y]) : (v == u && (y = p.substring(h10), g = p.length), f += String.fromCharCode(v), l[y] = v, s[v++] = y), h10 = g + 1;
      }
      return f;
    }
    var u = 4e4, d = c(a);
    u = 65535;
    var m = c(i);
    return { chars1: d, chars2: m, lineArray: s };
  }, t10.prototype.diff_charsToLines_ = function(a, i) {
    for (var s = 0; s < a.length; s++) {
      for (var l = a[s][1], c = [], u = 0; u < l.length; u++)
        c[u] = i[l.charCodeAt(u)];
      a[s][1] = c.join("");
    }
  }, t10.prototype.diff_commonPrefix = function(a, i) {
    if (!a || !i || a.charAt(0) != i.charAt(0))
      return 0;
    for (var s = 0, l = Math.min(a.length, i.length), c = l, u = 0; s < c; )
      a.substring(u, c) == i.substring(u, c) ? (s = c, u = s) : l = c, c = Math.floor((l - s) / 2 + s);
    return c;
  }, t10.prototype.diff_commonSuffix = function(a, i) {
    if (!a || !i || a.charAt(a.length - 1) != i.charAt(i.length - 1))
      return 0;
    for (var s = 0, l = Math.min(a.length, i.length), c = l, u = 0; s < c; )
      a.substring(a.length - c, a.length - u) == i.substring(i.length - c, i.length - u) ? (s = c, u = s) : l = c, c = Math.floor((l - s) / 2 + s);
    return c;
  }, t10.prototype.diff_commonOverlap_ = function(a, i) {
    var s = a.length, l = i.length;
    if (s == 0 || l == 0)
      return 0;
    s > l ? a = a.substring(s - l) : s < l && (i = i.substring(0, s));
    var c = Math.min(s, l);
    if (a == i)
      return c;
    for (var u = 0, d = 1; ; ) {
      var m = a.substring(c - d), p = i.indexOf(m);
      if (p == -1)
        return u;
      d += p, (p == 0 || a.substring(c - d) == i.substring(0, d)) && (u = d, d++);
    }
  }, t10.prototype.diff_halfMatch_ = function(a, i) {
    if (this.Diff_Timeout <= 0)
      return null;
    var s = a.length > i.length ? a : i, l = a.length > i.length ? i : a;
    if (s.length < 4 || l.length * 2 < s.length)
      return null;
    var c = this;
    function u(k, T, w) {
      for (var _ = k.substring(w, w + Math.floor(k.length / 4)), M = -1, x = "", R, I, P, F; (M = T.indexOf(_, M + 1)) != -1; ) {
        var N = c.diff_commonPrefix(
          k.substring(w),
          T.substring(M)
        ), j = c.diff_commonSuffix(
          k.substring(0, w),
          T.substring(0, M)
        );
        x.length < j + N && (x = T.substring(M - j, M) + T.substring(M, M + N), R = k.substring(0, w - j), I = k.substring(w + N), P = T.substring(0, M - j), F = T.substring(M + N));
      }
      return x.length * 2 >= k.length ? [
        R,
        I,
        P,
        F,
        x
      ] : null;
    }
    var d = u(
      s,
      l,
      Math.ceil(s.length / 4)
    ), m = u(
      s,
      l,
      Math.ceil(s.length / 2)
    ), p;
    if (!d && !m)
      return null;
    m ? d ? p = d[4].length > m[4].length ? d : m : p = m : p = d;
    var f, h10, g, v;
    a.length > i.length ? (f = p[0], h10 = p[1], g = p[2], v = p[3]) : (g = p[0], v = p[1], f = p[2], h10 = p[3]);
    var y = p[4];
    return [f, h10, g, v, y];
  }, t10.prototype.diff_cleanupSemantic = function(a) {
    for (var i = false, s = [], l = 0, c = null, u = 0, d = 0, m = 0, p = 0, f = 0; u < a.length; )
      a[u][0] == r ? (s[l++] = u, d = p, m = f, p = 0, f = 0, c = a[u][1]) : (a[u][0] == o ? p += a[u][1].length : f += a[u][1].length, c && c.length <= Math.max(d, m) && c.length <= Math.max(
        p,
        f
      ) && (a.splice(
        s[l - 1],
        0,
        new t10.Diff(n, c)
      ), a[s[l - 1] + 1][0] = o, l--, l--, u = l > 0 ? s[l - 1] : -1, d = 0, m = 0, p = 0, f = 0, c = null, i = true)), u++;
    for (i && this.diff_cleanupMerge(a), this.diff_cleanupSemanticLossless(a), u = 1; u < a.length; ) {
      if (a[u - 1][0] == n && a[u][0] == o) {
        var h10 = a[u - 1][1], g = a[u][1], v = this.diff_commonOverlap_(h10, g), y = this.diff_commonOverlap_(g, h10);
        v >= y ? (v >= h10.length / 2 || v >= g.length / 2) && (a.splice(u, 0, new t10.Diff(
          r,
          g.substring(0, v)
        )), a[u - 1][1] = h10.substring(0, h10.length - v), a[u + 1][1] = g.substring(v), u++) : (y >= h10.length / 2 || y >= g.length / 2) && (a.splice(u, 0, new t10.Diff(
          r,
          h10.substring(0, y)
        )), a[u - 1][0] = o, a[u - 1][1] = g.substring(0, g.length - y), a[u + 1][0] = n, a[u + 1][1] = h10.substring(y), u++), u++;
      }
      u++;
    }
  }, t10.prototype.diff_cleanupSemanticLossless = function(a) {
    function i(y, k) {
      if (!y || !k)
        return 6;
      var T = y.charAt(y.length - 1), w = k.charAt(0), _ = T.match(t10.nonAlphaNumericRegex_), M = w.match(t10.nonAlphaNumericRegex_), x = _ && T.match(t10.whitespaceRegex_), R = M && w.match(t10.whitespaceRegex_), I = x && T.match(t10.linebreakRegex_), P = R && w.match(t10.linebreakRegex_), F = I && y.match(t10.blanklineEndRegex_), N = P && k.match(t10.blanklineStartRegex_);
      return F || N ? 5 : I || P ? 4 : _ && !x && R ? 3 : x || R ? 2 : _ || M ? 1 : 0;
    }
    for (var s = 1; s < a.length - 1; ) {
      if (a[s - 1][0] == r && a[s + 1][0] == r) {
        var l = a[s - 1][1], c = a[s][1], u = a[s + 1][1], d = this.diff_commonSuffix(l, c);
        if (d) {
          var m = c.substring(c.length - d);
          l = l.substring(0, l.length - d), c = m + c.substring(0, c.length - d), u = m + u;
        }
        for (var p = l, f = c, h10 = u, g = i(l, c) + i(c, u); c.charAt(0) === u.charAt(0); ) {
          l += c.charAt(0), c = c.substring(1) + u.charAt(0), u = u.substring(1);
          var v = i(l, c) + i(c, u);
          v >= g && (g = v, p = l, f = c, h10 = u);
        }
        a[s - 1][1] != p && (p ? a[s - 1][1] = p : (a.splice(s - 1, 1), s--), a[s][1] = f, h10 ? a[s + 1][1] = h10 : (a.splice(s + 1, 1), s--));
      }
      s++;
    }
  }, t10.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/, t10.whitespaceRegex_ = /\s/, t10.linebreakRegex_ = /[\r\n]/, t10.blanklineEndRegex_ = /\n\r?\n$/, t10.blanklineStartRegex_ = /^\r?\n\r?\n/, t10.prototype.diff_cleanupEfficiency = function(a) {
    for (var i = false, s = [], l = 0, c = null, u = 0, d = false, m = false, p = false, f = false; u < a.length; )
      a[u][0] == r ? (a[u][1].length < this.Diff_EditCost && (p || f) ? (s[l++] = u, d = p, m = f, c = a[u][1]) : (l = 0, c = null), p = f = false) : (a[u][0] == n ? f = true : p = true, c && (d && m && p && f || c.length < this.Diff_EditCost / 2 && d + m + p + f == 3) && (a.splice(
        s[l - 1],
        0,
        new t10.Diff(n, c)
      ), a[s[l - 1] + 1][0] = o, l--, c = null, d && m ? (p = f = true, l = 0) : (l--, u = l > 0 ? s[l - 1] : -1, p = f = false), i = true)), u++;
    i && this.diff_cleanupMerge(a);
  }, t10.prototype.diff_cleanupMerge = function(a) {
    a.push(new t10.Diff(r, ""));
    for (var i = 0, s = 0, l = 0, c = "", u = "", d; i < a.length; )
      switch (a[i][0]) {
        case o:
          l++, u += a[i][1], i++;
          break;
        case n:
          s++, c += a[i][1], i++;
          break;
        case r:
          s + l > 1 ? (s !== 0 && l !== 0 && (d = this.diff_commonPrefix(u, c), d !== 0 && (i - s - l > 0 && a[i - s - l - 1][0] == r ? a[i - s - l - 1][1] += u.substring(0, d) : (a.splice(0, 0, new t10.Diff(
            r,
            u.substring(0, d)
          )), i++), u = u.substring(d), c = c.substring(d)), d = this.diff_commonSuffix(u, c), d !== 0 && (a[i][1] = u.substring(u.length - d) + a[i][1], u = u.substring(0, u.length - d), c = c.substring(0, c.length - d))), i -= s + l, a.splice(i, s + l), c.length && (a.splice(
            i,
            0,
            new t10.Diff(n, c)
          ), i++), u.length && (a.splice(
            i,
            0,
            new t10.Diff(o, u)
          ), i++), i++) : i !== 0 && a[i - 1][0] == r ? (a[i - 1][1] += a[i][1], a.splice(i, 1)) : i++, l = 0, s = 0, c = "", u = "";
          break;
      }
    a[a.length - 1][1] === "" && a.pop();
    var m = false;
    for (i = 1; i < a.length - 1; )
      a[i - 1][0] == r && a[i + 1][0] == r && (a[i][1].substring(a[i][1].length - a[i - 1][1].length) == a[i - 1][1] ? (a[i][1] = a[i - 1][1] + a[i][1].substring(0, a[i][1].length - a[i - 1][1].length), a[i + 1][1] = a[i - 1][1] + a[i + 1][1], a.splice(i - 1, 1), m = true) : a[i][1].substring(0, a[i + 1][1].length) == a[i + 1][1] && (a[i - 1][1] += a[i + 1][1], a[i][1] = a[i][1].substring(a[i + 1][1].length) + a[i + 1][1], a.splice(i + 1, 1), m = true)), i++;
    m && this.diff_cleanupMerge(a);
  }, t10.prototype.diff_xIndex = function(a, i) {
    var s = 0, l = 0, c = 0, u = 0, d;
    for (d = 0; d < a.length && (a[d][0] !== o && (s += a[d][1].length), a[d][0] !== n && (l += a[d][1].length), !(s > i)); d++)
      c = s, u = l;
    return a.length != d && a[d][0] === n ? u : u + (i - c);
  }, t10.prototype.diff_prettyHtml = function(a) {
    for (var i = [], s = /&/g, l = /</g, c = />/g, u = /\n/g, d = 0; d < a.length; d++) {
      var m = a[d][0], p = a[d][1], f = p.replace(s, "&amp;").replace(l, "&lt;").replace(c, "&gt;").replace(u, "&para;<br>");
      switch (m) {
        case o:
          i[d] = '<ins style="background:#e6ffe6;">' + f + "</ins>";
          break;
        case n:
          i[d] = '<del style="background:#ffe6e6;">' + f + "</del>";
          break;
        case r:
          i[d] = "<span>" + f + "</span>";
          break;
      }
    }
    return i.join("");
  }, t10.prototype.diff_text1 = function(a) {
    for (var i = [], s = 0; s < a.length; s++)
      a[s][0] !== o && (i[s] = a[s][1]);
    return i.join("");
  }, t10.prototype.diff_text2 = function(a) {
    for (var i = [], s = 0; s < a.length; s++)
      a[s][0] !== n && (i[s] = a[s][1]);
    return i.join("");
  }, t10.prototype.diff_levenshtein = function(a) {
    for (var i = 0, s = 0, l = 0, c = 0; c < a.length; c++) {
      var u = a[c][0], d = a[c][1];
      switch (u) {
        case o:
          s += d.length;
          break;
        case n:
          l += d.length;
          break;
        case r:
          i += Math.max(s, l), s = 0, l = 0;
          break;
      }
    }
    return i += Math.max(s, l), i;
  }, t10.prototype.diff_toDelta = function(a) {
    for (var i = [], s = 0; s < a.length; s++)
      switch (a[s][0]) {
        case o:
          i[s] = "+" + encodeURI(a[s][1]);
          break;
        case n:
          i[s] = "-" + a[s][1].length;
          break;
        case r:
          i[s] = "=" + a[s][1].length;
          break;
      }
    return i.join("	").replace(/%20/g, " ");
  }, t10.prototype.diff_fromDelta = function(a, i) {
    for (var s = [], l = 0, c = 0, u = i.split(/\t/g), d = 0; d < u.length; d++) {
      var m = u[d].substring(1);
      switch (u[d].charAt(0)) {
        case "+":
          try {
            s[l++] = new t10.Diff(o, decodeURI(m));
          } catch {
            throw new Error("Illegal escape in diff_fromDelta: " + m);
          }
          break;
        case "-":
        case "=":
          var p = parseInt(m, 10);
          if (isNaN(p) || p < 0)
            throw new Error("Invalid number in diff_fromDelta: " + m);
          var f = a.substring(c, c += p);
          u[d].charAt(0) == "=" ? s[l++] = new t10.Diff(r, f) : s[l++] = new t10.Diff(n, f);
          break;
        default:
          if (u[d])
            throw new Error("Invalid diff operation in diff_fromDelta: " + u[d]);
      }
    }
    if (c != a.length)
      throw new Error("Delta length (" + c + ") does not equal source text length (" + a.length + ").");
    return s;
  }, t10.prototype.match_main = function(a, i, s) {
    if (a == null || i == null || s == null)
      throw new Error("Null input. (match_main)");
    return s = Math.max(0, Math.min(s, a.length)), a == i ? 0 : a.length ? a.substring(s, s + i.length) == i ? s : this.match_bitap_(a, i, s) : -1;
  }, t10.prototype.match_bitap_ = function(a, i, s) {
    if (i.length > this.Match_MaxBits)
      throw new Error("Pattern too long for this browser.");
    var l = this.match_alphabet_(i), c = this;
    function u(R, I) {
      var P = R / i.length, F = Math.abs(s - I);
      return c.Match_Distance ? P + F / c.Match_Distance : F ? 1 : P;
    }
    var d = this.Match_Threshold, m = a.indexOf(i, s);
    m != -1 && (d = Math.min(u(0, m), d), m = a.lastIndexOf(i, s + i.length), m != -1 && (d = Math.min(u(0, m), d)));
    var p = 1 << i.length - 1;
    m = -1;
    for (var f, h10, g = i.length + a.length, v, y = 0; y < i.length; y++) {
      for (f = 0, h10 = g; f < h10; )
        u(y, s + h10) <= d ? f = h10 : g = h10, h10 = Math.floor((g - f) / 2 + f);
      g = h10;
      var k = Math.max(1, s - h10 + 1), T = Math.min(s + h10, a.length) + i.length, w = Array(T + 2);
      w[T + 1] = (1 << y) - 1;
      for (var _ = T; _ >= k; _--) {
        var M = l[a.charAt(_ - 1)];
        if (y === 0 ? w[_] = (w[_ + 1] << 1 | 1) & M : w[_] = (w[_ + 1] << 1 | 1) & M | ((v[_ + 1] | v[_]) << 1 | 1) | v[_ + 1], w[_] & p) {
          var x = u(y, _ - 1);
          if (x <= d)
            if (d = x, m = _ - 1, m > s)
              k = Math.max(1, 2 * s - m);
            else
              break;
        }
      }
      if (u(y + 1, s) > d)
        break;
      v = w;
    }
    return m;
  }, t10.prototype.match_alphabet_ = function(a) {
    for (var i = {}, s = 0; s < a.length; s++)
      i[a.charAt(s)] = 0;
    for (var s = 0; s < a.length; s++)
      i[a.charAt(s)] |= 1 << a.length - s - 1;
    return i;
  }, t10.prototype.patch_addContext_ = function(a, i) {
    if (i.length != 0) {
      if (a.start2 === null)
        throw Error("patch not initialized");
      for (var s = i.substring(a.start2, a.start2 + a.length1), l = 0; i.indexOf(s) != i.lastIndexOf(s) && s.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin; )
        l += this.Patch_Margin, s = i.substring(
          a.start2 - l,
          a.start2 + a.length1 + l
        );
      l += this.Patch_Margin;
      var c = i.substring(a.start2 - l, a.start2);
      c && a.diffs.unshift(new t10.Diff(r, c));
      var u = i.substring(
        a.start2 + a.length1,
        a.start2 + a.length1 + l
      );
      u && a.diffs.push(new t10.Diff(r, u)), a.start1 -= c.length, a.start2 -= c.length, a.length1 += c.length + u.length, a.length2 += c.length + u.length;
    }
  }, t10.prototype.patch_make = function(a, i, s) {
    var l, c;
    if (typeof a == "string" && typeof i == "string" && typeof s > "u")
      l = /** @type {string} */
      a, c = this.diff_main(
        l,
        /** @type {string} */
        i,
        true
      ), c.length > 2 && (this.diff_cleanupSemantic(c), this.diff_cleanupEfficiency(c));
    else if (a && typeof a == "object" && typeof i > "u" && typeof s > "u")
      c = /** @type {!Array.<!diff_match_patch.Diff>} */
      a, l = this.diff_text1(c);
    else if (typeof a == "string" && i && typeof i == "object" && typeof s > "u")
      l = /** @type {string} */
      a, c = /** @type {!Array.<!diff_match_patch.Diff>} */
      i;
    else if (typeof a == "string" && typeof i == "string" && s && typeof s == "object")
      l = /** @type {string} */
      a, c = /** @type {!Array.<!diff_match_patch.Diff>} */
      s;
    else
      throw new Error("Unknown call format to patch_make.");
    if (c.length === 0)
      return [];
    for (var u = [], d = new t10.patch_obj(), m = 0, p = 0, f = 0, h10 = l, g = l, v = 0; v < c.length; v++) {
      var y = c[v][0], k = c[v][1];
      switch (!m && y !== r && (d.start1 = p, d.start2 = f), y) {
        case o:
          d.diffs[m++] = c[v], d.length2 += k.length, g = g.substring(0, f) + k + g.substring(f);
          break;
        case n:
          d.length1 += k.length, d.diffs[m++] = c[v], g = g.substring(0, f) + g.substring(f + k.length);
          break;
        case r:
          k.length <= 2 * this.Patch_Margin && m && c.length != v + 1 ? (d.diffs[m++] = c[v], d.length1 += k.length, d.length2 += k.length) : k.length >= 2 * this.Patch_Margin && m && (this.patch_addContext_(d, h10), u.push(d), d = new t10.patch_obj(), m = 0, h10 = g, p = f);
          break;
      }
      y !== o && (p += k.length), y !== n && (f += k.length);
    }
    return m && (this.patch_addContext_(d, h10), u.push(d)), u;
  }, t10.prototype.patch_deepCopy = function(a) {
    for (var i = [], s = 0; s < a.length; s++) {
      var l = a[s], c = new t10.patch_obj();
      c.diffs = [];
      for (var u = 0; u < l.diffs.length; u++)
        c.diffs[u] = new t10.Diff(l.diffs[u][0], l.diffs[u][1]);
      c.start1 = l.start1, c.start2 = l.start2, c.length1 = l.length1, c.length2 = l.length2, i[s] = c;
    }
    return i;
  }, t10.prototype.patch_apply = function(a, i) {
    if (a.length == 0)
      return [i, []];
    a = this.patch_deepCopy(a);
    var s = this.patch_addPadding(a);
    i = s + i + s, this.patch_splitMax(a);
    for (var l = 0, c = [], u = 0; u < a.length; u++) {
      var d = a[u].start2 + l, m = this.diff_text1(a[u].diffs), p, f = -1;
      if (m.length > this.Match_MaxBits ? (p = this.match_main(
        i,
        m.substring(0, this.Match_MaxBits),
        d
      ), p != -1 && (f = this.match_main(
        i,
        m.substring(m.length - this.Match_MaxBits),
        d + m.length - this.Match_MaxBits
      ), (f == -1 || p >= f) && (p = -1))) : p = this.match_main(i, m, d), p == -1)
        c[u] = false, l -= a[u].length2 - a[u].length1;
      else {
        c[u] = true, l = p - d;
        var h10;
        if (f == -1 ? h10 = i.substring(p, p + m.length) : h10 = i.substring(p, f + this.Match_MaxBits), m == h10)
          i = i.substring(0, p) + this.diff_text2(a[u].diffs) + i.substring(p + m.length);
        else {
          var g = this.diff_main(m, h10, false);
          if (m.length > this.Match_MaxBits && this.diff_levenshtein(g) / m.length > this.Patch_DeleteThreshold)
            c[u] = false;
          else {
            this.diff_cleanupSemanticLossless(g);
            for (var v = 0, y, k = 0; k < a[u].diffs.length; k++) {
              var T = a[u].diffs[k];
              T[0] !== r && (y = this.diff_xIndex(g, v)), T[0] === o ? i = i.substring(0, p + y) + T[1] + i.substring(p + y) : T[0] === n && (i = i.substring(0, p + y) + i.substring(p + this.diff_xIndex(
                g,
                v + T[1].length
              ))), T[0] !== n && (v += T[1].length);
            }
          }
        }
      }
    }
    return i = i.substring(s.length, i.length - s.length), [i, c];
  }, t10.prototype.patch_addPadding = function(a) {
    for (var i = this.Patch_Margin, s = "", l = 1; l <= i; l++)
      s += String.fromCharCode(l);
    for (var l = 0; l < a.length; l++)
      a[l].start1 += i, a[l].start2 += i;
    var c = a[0], u = c.diffs;
    if (u.length == 0 || u[0][0] != r)
      u.unshift(new t10.Diff(r, s)), c.start1 -= i, c.start2 -= i, c.length1 += i, c.length2 += i;
    else if (i > u[0][1].length) {
      var d = i - u[0][1].length;
      u[0][1] = s.substring(u[0][1].length) + u[0][1], c.start1 -= d, c.start2 -= d, c.length1 += d, c.length2 += d;
    }
    if (c = a[a.length - 1], u = c.diffs, u.length == 0 || u[u.length - 1][0] != r)
      u.push(new t10.Diff(r, s)), c.length1 += i, c.length2 += i;
    else if (i > u[u.length - 1][1].length) {
      var d = i - u[u.length - 1][1].length;
      u[u.length - 1][1] += s.substring(0, d), c.length1 += d, c.length2 += d;
    }
    return s;
  }, t10.prototype.patch_splitMax = function(a) {
    for (var i = this.Match_MaxBits, s = 0; s < a.length; s++)
      if (!(a[s].length1 <= i)) {
        var l = a[s];
        a.splice(s--, 1);
        for (var c = l.start1, u = l.start2, d = ""; l.diffs.length !== 0; ) {
          var m = new t10.patch_obj(), p = true;
          for (m.start1 = c - d.length, m.start2 = u - d.length, d !== "" && (m.length1 = m.length2 = d.length, m.diffs.push(new t10.Diff(r, d))); l.diffs.length !== 0 && m.length1 < i - this.Patch_Margin; ) {
            var f = l.diffs[0][0], h10 = l.diffs[0][1];
            f === o ? (m.length2 += h10.length, u += h10.length, m.diffs.push(l.diffs.shift()), p = false) : f === n && m.diffs.length == 1 && m.diffs[0][0] == r && h10.length > 2 * i ? (m.length1 += h10.length, c += h10.length, p = false, m.diffs.push(new t10.Diff(f, h10)), l.diffs.shift()) : (h10 = h10.substring(
              0,
              i - m.length1 - this.Patch_Margin
            ), m.length1 += h10.length, c += h10.length, f === r ? (m.length2 += h10.length, u += h10.length) : p = false, m.diffs.push(new t10.Diff(f, h10)), h10 == l.diffs[0][1] ? l.diffs.shift() : l.diffs[0][1] = l.diffs[0][1].substring(h10.length));
          }
          d = this.diff_text2(m.diffs), d = d.substring(d.length - this.Patch_Margin);
          var g = this.diff_text1(l.diffs).substring(0, this.Patch_Margin);
          g !== "" && (m.length1 += g.length, m.length2 += g.length, m.diffs.length !== 0 && m.diffs[m.diffs.length - 1][0] === r ? m.diffs[m.diffs.length - 1][1] += g : m.diffs.push(new t10.Diff(r, g))), p || a.splice(++s, 0, m);
        }
      }
  }, t10.prototype.patch_toText = function(a) {
    for (var i = [], s = 0; s < a.length; s++)
      i[s] = a[s];
    return i.join("");
  }, t10.prototype.patch_fromText = function(a) {
    var i = [];
    if (!a)
      return i;
    for (var s = a.split(`
`), l = 0, c = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/; l < s.length; ) {
      var u = s[l].match(c);
      if (!u)
        throw new Error("Invalid patch string: " + s[l]);
      var d = new t10.patch_obj();
      for (i.push(d), d.start1 = parseInt(u[1], 10), u[2] === "" ? (d.start1--, d.length1 = 1) : u[2] == "0" ? d.length1 = 0 : (d.start1--, d.length1 = parseInt(u[2], 10)), d.start2 = parseInt(u[3], 10), u[4] === "" ? (d.start2--, d.length2 = 1) : u[4] == "0" ? d.length2 = 0 : (d.start2--, d.length2 = parseInt(u[4], 10)), l++; l < s.length; ) {
        var m = s[l].charAt(0);
        try {
          var p = decodeURI(s[l].substring(1));
        } catch {
          throw new Error("Illegal escape in patch_fromText: " + p);
        }
        if (m == "-")
          d.diffs.push(new t10.Diff(n, p));
        else if (m == "+")
          d.diffs.push(new t10.Diff(o, p));
        else if (m == " ")
          d.diffs.push(new t10.Diff(r, p));
        else {
          if (m == "@")
            break;
          if (m !== "") throw new Error('Invalid patch mode "' + m + '" in: ' + p);
        }
        l++;
      }
    }
    return i;
  }, t10.patch_obj = function() {
    this.diffs = [], this.start1 = null, this.start2 = null, this.length1 = 0, this.length2 = 0;
  }, t10.patch_obj.prototype.toString = function() {
    var a, i;
    this.length1 === 0 ? a = this.start1 + ",0" : this.length1 == 1 ? a = this.start1 + 1 : a = this.start1 + 1 + "," + this.length1, this.length2 === 0 ? i = this.start2 + ",0" : this.length2 == 1 ? i = this.start2 + 1 : i = this.start2 + 1 + "," + this.length2;
    for (var s = ["@@ -" + a + " +" + i + ` @@
`], l, c = 0; c < this.diffs.length; c++) {
      switch (this.diffs[c][0]) {
        case o:
          l = "+";
          break;
        case n:
          l = "-";
          break;
        case r:
          l = " ";
          break;
      }
      s[c + 1] = l + encodeURI(this.diffs[c][1]) + `
`;
    }
    return s.join("").replace(/%20/g, " ");
  }, e16.exports = t10, e16.exports.diff_match_patch = t10, e16.exports.DIFF_DELETE = n, e16.exports.DIFF_INSERT = o, e16.exports.DIFF_EQUAL = r;
})(tm);
var S_ = tm.exports;
var N_ = k_(S_);
function M_(e16) {
  e16.provide("__elementObserver", new ng()), e16.provide("_emitter", new tg()), e16.provide("__diffMatchPatch", new N_());
}
var P_ = (e16, t10) => {
  d_(e16), C_(e16, t10), h_(e16, t10), y_(e16, t10), T_(e16), M_(e16);
};
export {
  t_ as GFPageDetails,
  ElAffix as KAffix,
  ElAlert as KAlert,
  ElAnchor as KAnchor,
  ElAnchorLink as KAnchorLink,
  ElAside as KAside,
  ElAutoResizer as KAutoResizer,
  ElAutocomplete as KAutocomplete,
  ElAvatar as KAvatar,
  ElBacktop as KBacktop,
  D8 as KBadge,
  ElBreadcrumb as KBreadcrumb,
  ElBreadcrumbItem as KBreadcrumbItem,
  Lt as KButton,
  Eb as KButtonContainer,
  ElButtonGroup as KButtonGroup,
  q8 as KCalendar,
  ElCard as KCard,
  ElCarousel as KCarousel,
  ElCarouselItem as KCarouselItem,
  Lf as KCascader,
  ElCascaderPanel as KCascaderPanel,
  ElCheckTag as KCheckTag,
  fa as KCheckbox,
  ElCheckboxButton as KCheckboxButton,
  If as KCheckboxGroup,
  ElCol as KCol,
  p8 as KCollapse,
  h8 as KCollapseItem,
  ElCollapseTransition as KCollapseTransition,
  ElCollection as KCollection,
  ElCollectionItem as KCollectionItem,
  ElColorPicker as KColorPicker,
  o1 as KColumnGroup,
  ElConfigProvider as KConfigProvider,
  ElContainer as KContainer,
  ElCountdown as KCountdown,
  Ff as KDatePicker,
  ElDescriptions as KDescriptions,
  ElDescriptionsItem as KDescriptionsItem,
  $9 as KDetails,
  f1 as KDetailsItem,
  Zf as KDialog,
  ElDivider as KDivider,
  i8 as KDrawer,
  ar as KDropdown,
  rr as KDropdownItem,
  ElDropdownMenu as KDropdownMenu,
  g3 as KEmpty,
  Wf as KFilter,
  xb as KFilterForm,
  ElFooter as KFooter,
  r1 as KForm,
  i1 as KFormItem,
  ElHeader as KHeader,
  ElIcon as KIcon,
  Wb as KIconPopver,
  ElImage as KImage,
  ElImageViewer as KImageViewer,
  ElInfiniteScroll as KInfiniteScroll,
  ro as KInput,
  Y6 as KInputNumber,
  ElLink as KLink,
  ElLoading as KLoading,
  vLoading as KLoadingDirective,
  Loading as KLoadingService,
  ElMain as KMain,
  ElMention as KMention,
  ElMenu as KMenu,
  ElMenuItem as KMenuItem,
  ElMenuItemGroup as KMenuItemGroup,
  B7 as KMenuView,
  Bf as KMessage,
  ElMessageBox as KMessageBox,
  c_ as KNewTransfer,
  ElNotification as KNotification,
  Of as KOperate,
  vo as KOption,
  my as KOptionGroup,
  ElOverlay as KOverlay,
  v9 as KPageDetails,
  ElPageHeader as KPageHeader,
  N9 as KPageTableView,
  d1 as KPageViewBus,
  zf as KPagination,
  Xy as KPopconfirm,
  Io as KPopover,
  ElPopoverDirective as KPopoverDirective,
  ElPopper as KPopper,
  ElPopperArrow as KPopperArrow,
  ElPopperContent as KPopperContent,
  ElPopperTrigger as KPopperTrigger,
  ElProgress as KProgress,
  Mf as KRadio,
  ElRadioButton as KRadioButton,
  $f as KRadioGroup,
  ElRate as KRate,
  f3 as KResult,
  ElRow as KRow,
  jb as KScriptInput,
  ElScrollbar as KScrollbar,
  Go as KSelect,
  ElSelectV2 as KSelectV2,
  ElSkeleton as KSkeleton,
  ElSkeletonItem as KSkeletonItem,
  ElSlider as KSlider,
  Pb as KSliderButton,
  ElSpace as KSpace,
  ElStatistic as KStatistic,
  f8 as KStep,
  d8 as KSteps,
  ElSubMenu as KSubMenu,
  ay as KSwitch,
  Kf as KTabPane,
  Hr as KTable,
  Ur as KTableColumn,
  Ef as KTabs,
  Hy as KTag,
  ElText as KText,
  ElTimePicker as KTimePicker,
  ElTimeSelect as KTimeSelect,
  E8 as KTimeline,
  K8 as KTimelineItem,
  wa as KTooltip,
  ElTour as KTour,
  ElTourStep as KTourStep,
  jf as KTransfer,
  el as KTree,
  Nb as KTreeSelect,
  cb as KTreeTable,
  kb as KTreeTransfer,
  Ny as KUpload,
  x8 as KView,
  ElWatermark as KWatermark,
  P_ as default
};
/*! Bundled license information:

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.6
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)

@intlify/shared/dist/shared.mjs:
  (*!
    * shared v9.14.2
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    *)

@intlify/message-compiler/dist/message-compiler.esm-browser.js:
  (*!
    * message-compiler v9.14.2
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    *)

@intlify/core-base/dist/core-base.mjs:
  (*!
    * core-base v9.14.2
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    *)

vue-i18n/dist/vue-i18n.mjs:
  (*!
    * vue-i18n v9.14.2
    * (c) 2024 kazuya kawaguchi
    * Released under the MIT License.
    *)

@ksware/ksw-ux/kingsware-ui/index.js:
  (*!
   * GSAP 3.12.5
   * https://gsap.com
   *
   * @license Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
  (*!
   * CSSPlugin 3.12.5
   * https://gsap.com
   *
   * Copyright 2008-2024, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license or for
   * Club GSAP members, the agreement issued with that membership.
   * @author: Jack Doyle, jack@greensock.com
  *)
  (**
  * @vue/shared v3.5.6
  * (c) 2018-present Yuxi (Evan) You and Vue contributors
  * @license MIT
  **)
  (*!
   * OverlayScrollbars
   * Version: 2.10.0
   *
   * Copyright (c) Rene Haas | KingSora.
   * https://github.com/KingSora
   *
   * Released under the MIT license.
   *)
*/
//# sourceMappingURL=@ksware_ksw-ux.js.map
